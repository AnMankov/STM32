bxCAN функциональное описание
31.7.1 Обработка передачи
Для того, чтобы передать сообщение, приложение должно выбрать один пустой (empty) почтовый ящик для передачи, установить идентификатор, код длины данных (DLC) и данные перед запросом передачи настройкой соответствующего бита TXRQ в регистре CAN_TIxR. Как только почтовый ящик покинул empty состояние, программа далее не имеет права записывать регистры почтового ящика. Сразу же после установки бита TXRQ, почтовый ящик входит в состояние pending и ждет того, чтобы стать ящиком с самым высоким приоритетом, см. приоритет передачи (Transmit Priority). Как только ящик получает наивысший приоритет, он становится запланированным (scheduled) для передачи. Передача сообщения scheduled почтового ящика начнется (войдет в состояние transmit), когда CAN шина станет idle. Как только почтовый ящик был успешно отправлен, он снова станет empty. Аппратная часть показывает успешную передачу при настроенных битах RQCP и TXOK в регистре CAN_TSR.
Если передача собьется, причина показывается битом ALST в регистре CAN_TSR в случае потери арбитража, и/или TERR битом, в случае обнаружения ошибки передачи.

Приоритет передачи.

Идентификатором
Когда более чем один почтовый ящик на передачу находится в pending, порядок передачи задается идентификатором сообщения, хранящегося в почтовом ящике. Сообщение с самым меньшим значением идентификатора имеет наивысший приоритет в соответствии с арбитражом протокола CAN. Если значения идентификатора равны, младший номер почтового ящика будет запланированным первым.

Порядком запроса на передачу
Почтовые ящики на передачу могут быть сконфигурированы как передающее FIFO установкой бита TXFP в регистре CAN_MCR. В этом режиме порядок приоритета задается порядком запроса передачи.
Этот режим очень полезен для сегментированной передачи.

Принудительное прекращение (Abort)
Запрос передачи может быть отменен пользователем настройкой бита ABRQ в регистре CAN_TSR. В состоянии pending или scheduled, почтовый ящик немедленно принудительно обрывается. Запрос прекращения в то время как почтовый ящик в состоянии transmit, может привести к 2-м результатам.
Если почтовый ящик передается успешно, почтовый ящик становится empty с установкой бита TXOK в регистре CAN_TSR. Если передача нарушается, почтовый ящик становится scheduled, передача обрывается и становится empty со сбросом TXOK. Во всех случаях почтовый ящик становится empty снова по крайней мере до конца текущей передачи.

Не автоматический режим повторной передачи
Этот режим был реализован для того, чтобы выполнить (fulfill) требование опции стандарта CAN - Time Triggered Communication. Для настройки аппаратной части в этот режим, должен быть установлен бит NART в регистре CAN_MCR.
В этом режиме каждая передача запускается только однажды. Если первая попытка не удалась, из-за потери арбитража или ошибки, аппаратная часть автоматически не перезапустит передачу сообщения.
В конце первой попытки передачи, аппаратная часть рассматривает запрос как завершенный и устанавливает бит RQCP в регистре CAN_TSR. Результат передачи показывается в регистре CAN_TSR битами TXOK, ALST и TERR.

31.7.2
Режим связи с запуском по времени (time triggered)
В этом режиме, внутренний счетчик аппаратной части CAN активируется и используется для генерации метки времени, сохраненной в регистрах CAN_RDTxR/CAN_TDTxR (для Rx и Tx почтовых ящиков). Внутренний счетчик инкрементируется каждый интервал времени CAN (раздел 31.7.7). Внутренний счетчик захватывается по каждой точке выборки бита Start Of Frame при приеме и передаче.

31.7.3
Обработка приема.
Для приема CAN сообщений, предоставляются 3 почтовых ящика, организованных как FIFO. Для того, чтобы не перегружать CPU, упростить ПО и гарантировать согласованность (consistency) данных, FIFO управляется полностью аппаратно. Приложение обращается к сообщениям, храниным в FIFO через выходной почтовый ящик FIFO.

Валидное сообщение
Принятое сообщение рассматривается как валидное когда оно было принято корректно в соответствии с протоколом CAN (нет ошибки до самого последнего одного бита поля EOF) и оно успешно прошло через фильтрацию идентификатора (31.7.4)

Управление FIFO
Стартуя с состояния empty, первое принятое валидное сообщение хранится в FIFO, которое устанавливается в состояние pending_1. Аппратная часть сигнализирует событие установкой битов FMP[1:0] в регистре CAN_RFR значением 01b. Сообщение доступно в выходном почтовом ящике FIFO.
ПО считывает содержимое почтового ящика и освобождает его установкой бита RFOM в регистре CAN_RFR. FIFO снова становится пустым. Если тем временем (meantime) новое валидное сообщение было принято, FIFO остается в состоянии pending_1 и новое сообщение доступно в почтовом ящике.

Если приложение не освобождает почтовый ящик, следующее валидное сообщение будет сохранено в FIFO, которое входит в состояние pending_2 (FMP[1:0] = 10b). Процесс хранения повторяется для следующего валидного сообщения помещая FIFO в состояние pending_3 (FMP[1:0] = 11b). В этой точке программа должна освободить выходной почтовый ящик установкой бита RFOM, так что почтовый ящик опустошается чтобы сохранить следующее валидное сообщение. Иначе следующее принятое валидное сообщение приведет к потере сообщения. (31.7.5)

Набегание данных (overrun)
Как только FIFO переходит в состояние pending_3 (т.е. 3 почтовых ящика полны), следующее валидное сообщение приведет к overrun и сообщение будет потреяно. Аппратная часть сигнализирует состояние overrun установкой бита FVOR в  регистре CAN_RFR. Какое сообщение теряется, зависит от конфигурации FIFO:
-Если функция блокировки FIFO отключается (бит RFLM в регистре CAN_MCR сброшен), последнее сообщение, сохраненное в FIFO будет перезаписано новым входящим сообщением. В этом случае самое последнее сообщение будет всегда доступно приложению.
-Если функция блокировки FIFO включается (бит RFLM в регистре CAN_MCR установлен), самое последнее сообщение будет отброшено и ПО будет доступно 3 самых старых сообщения в FIFO.

Прерывания, связанные с приемом
Как только сообщения были сохранены в FIFO, биты FMP[1:0] обновляются и генерируется запрос прерывания если устанавливается бит FMPIE в регистре CAN_IER.
Когда FIFO становится полным (т.е. третье сообщение сохраняется) бит FULL в регистре CAN_RFR устанавливается и прерывание генерируется если бит FFIE в регистре CAN_IER установлен.
При состояни overrun, бит FVOR устанавливается и прерывание генерируется если бит FOVIE в регистре CAN_IER установлен.

31.7.4 Фильтрация идентификатора
В протоколе CAN идентификатор сообщения не связан с адресом узла, но относится к содержимому сообщения. Поэтому передатчик распространяет свои сообщения ко всем приемникам. По приему сообщения приемный узел решает - в зависимости от идентификатора - нужно ли прикладному ПО сообщение или нет. Если сообщение нужно, оно копируется в SRAM. Если нет, сообщение должно быть отброшено без вмешательства ПО.
Чтобы выполнить (fulfill) это требование bxCAN контроллер предоставляет 14 конфигурируемых и масштабируемых банков фильтрации (13-0) для приложения, для того чтобы принять только сообщения, которые нужны программе.
Эта аппаратная фильтрация сохраняет ресурсы CPU, которые иначе были бы нужны для выполнения программной фильтрации. Каждый банк фильтра x содержит 2 32-х разрядных регистра, CAN_FxR0 и CAN_FxR1.

Масштабируемая ширина
Для оптимизации и адаптирования фильтров к требованиям приложения, каждый банк фильтра может быть масштабирован независимо. В зависимости от масштаба фильтра банк фильтра обеспечивает:
-один 32-х разрядный фильтр для битов STDID[10:0], EXTID[17:0], IDE и RTR.
-два 16 разрядных фильтра для битов STDID[10:0], RTR, IDE и EXTID[17:15].
Обратитесь к рисунку 393.
Кроме того, фильтры могут быть сконфигурированы в режим маски или в режим списка идентификаторов.

Режим маски
В режиме маски регистры идентификатора связаны с регистрами маски, определяющими, какие биты идентификатора обрабатываются как "должен соответствовать" или как "не важно".

Режим списка идентификаторов
В режиме списка идентификаторов, регистры маски используются как идентификаторные регистры. Поэтому вместо определения идентификатора и маски, указываются 2 идентификатора, удваивая количество одиночных идентификаторов. Все биты приходящего идентификатора должны совпадать с битами указанными в регистрах фильтра.

Масштабирование банка фильтра и конфигурация режима
Банки фильтра конфигурируются посредством соответствующего CAN_FMR регистра. Для конфигурации банка фильтра он должен быть деактивирован сбросом бита FACT в регистре CAN_FAR. Масштаб фильтра конфигурируется с помощью соответствующего бита FSCx в регистре CAN_FS1R, рис. 393. Режим списка идентификаторов или маски идентификаторов для соотвующих регистров Mask/Identifier конфигурируются с помощью битов FBMx в регистре CAN_FMR.
Для фильтрации группы идентификаторов, сконфигурируйте регистры Mask/Identifier в режим маски.
Для выбора отдельных идентификаторов, сконфигурируйте регистры Mask/Identifier в режим списка идентификаторов.
Фильтры, не используемые приложением, должны быть деактивированы.
Каждый фильтр в фильтрующем банке нумеруется (называемый Filter Number) от 0 до максимума в зависимости от режима и масштаба каждого из банков фильтра.
Насчет конфигурации фильтра обратитесь к Рис.393

Индекс соответствия (match) фильтра.
Как только сообщение было принято в FIFO, оно доступно приложению. Типично данные приложения копируются в SRAM. Чтобы скопировать данные в нужное место, приложение должно идентифицировать данные посредством идентификатора. Чтобы избежать этого, и облегчить доступ к SRAM, CAN контроллер предоставляет Filter Match Index.
Этот индекс хранится в почтовом ящике вместе с сообщением, соответствующим правилам приоритета фильтра. Поэтому каждое принятое сообщение имеет свой связанный filter match index.

Filter Match index м.б. использован двумя способами:
• Сравнением Filter Match index со списком ожидаемых величин
• Использованием Filter Match index как индекса массива для доступа к месту назначения данных.
Для немаскируемых фильтров, ПО больше не нужно сравнивать идентификатор.
Если фильтр маскируется, ПО сокращает сравнение до только маскируемых битов.
Значение индекса номера фильтра не берет в расчет состояние активации банков фильтра. Дополнительно, две независимые схемы нумерации используются, по одной для каждого FIFO. Обратитесь к рис. 394 за примером.


Правила приоритета фильтра
В зависимости от комбинации фильтра может случиться что идентификатор пройдет успешно через несколько фильтров. В этом случае значение filter match, сохраненное в приемном почтовом ящике, выбирается в соответствии со следующими правилами приоритета:
-32-х битный фильтр имеет приоритет над 16-битным фильтром.
-Для фильтров равных масштабов(шкал), приоритет имеет режим Identifier List над режимом Identifier Mask
-Для фильтров равных масштабов и режимов, приоритет отдается по номеру фильтра (чем меньше номер, тем выше приоритет).
Рисунок 395. Пример механизма фильтрации
Пример выше показывает принцип фильтрации bxCAN. По приему сообщения, идентификатор сравнивается первым с фильтрами, сконфигурированными в режиме Identifier List. Если там есть совпадение, сообщение сохраняется в связанное FIFO и индекс фильтра совпадения сохраняется в Filter Match Index. Как показано в этом примере, идентификатор совпадает с Identifier #2, поэтому содержимое сообщения и FMI 2 сохраняется в FIFO.
Если нет совпадения, то пришедший идентификатор сравнивается с фильтрами, сконфигурированными в режим маски.
Если идентификатор не совпадает с любыми идентификаторами, сконфигурированными в фильтрах, сообщение отбрасывается аппаратно без нарушения ПО.


31.7.5 Хранение сообщения
Интерфейс между ПО и аппаратной частью для сообщений CAN реализуется с помощью почтовых ящиков. Почтовый ящик содержит всю информацию, связанную с сообщением; идентификатор, данные, управление, статус и информация о метке времени.

Почтовый ящик передачи.
ПО устанавливает сообщение для передачи в пустом почтовом ящике. Статус передачи показывается аппаратно в регистре CAN_TSR.

Почтовый ящик приема
Когда сообщение было принято, оно доступно для ПО в выходном почтовом ящике FIFO. Как только ПО обработало сообщение (т.е. прочитало его), ПО должно освободить выходной почтовый ящик FIFO посредством бита RFOM в регистре CAN_RFR чтобы сделать следующее входящее сообщение доступным. 
filter match index хранится в поле MFMI регистра CAN_RDTxR. Значение 16-ти разрядной метки времени хранится в поле TIME[15:0] регистра CAN_RDTxR.


31.7.6 Управление ошибками
Управление ошибками как описано в CAN протоколе обрабатывается целиком аппаратно используя Transmit Error Counter (значение TEC в регистре CAN_ESR) и Receive Error Counter (значение REC, в регистре CAN_ESR), которые увеличиваются или уменьшаются в соответствии с состоянием ошибки. За деталями по управлению TEC и REC обратитесь к CAN стандарту.
Оба из них могут быть считаны программно для определения стабильности сети. Кроме того, аппаратная часть CAN пердоставляет детальную информацию о статусе текущей ошибки в регистре CAN_ESR. С помощью CAN_IER регистра (бит ERRIE и т.д.), программа может сконфигурировать генерацию прерывания по обнаружению ошибки очень гибким способом

Восстановление отключенной шины (Bus-Off recovery)
Bus-Off состояние достигается когда TEC больше 255, это состояния показывается битом BOFF в регистре CAN_ESR. В состоянии Bus-Off, bxCAN больше не может передавать и принимать сообщения.
В зависимости от бита ABOM в регистре CAN_MCR, bxCAN восстановится из Bus-Off (станет снова error active) либо автоматически либо по программному запросу. Но в обоих случаях bxCAN должен ждать по крайней мере последовательности восстановления, указанной в стандарте CAN (128 вхождений 11-ти подряд рецессивных битов, отслеженных на CANRX).
Если ABOM устанавливается, bxCAN начнет автоматически последовательность восстановления после того, как войдет в состояние Bus-Off.
Если ABOM сбрасывается, программа должна начать последовательность восстановления запросом для входа bxCAN и выйти из режима инициализации.

В режиме инициализации, bxCAN не следит за сигналом CANRX, поэтому он не может завершить последовательность восстановления. Для восстановления bxCAN должен быть в нормальном режиме.


31.7.7 Битовая синхронизация (Bit_timing) 
Логика Bit_timing следит за шиной и выполняет выборку и настройку точки выборки синхронизацией по фронту старт-бита и пересинхронизацией по следующим фронтам.
Ее работа может быть объяснена просто разбиением номинального битового времени на 3 сегмента следующим образом:
• Synchronization segment (SYNC_SEG): ожидается что в этом временном сегменте произойдет битовое изменение. У него есть фиксированная длина одного кванта времени (1 * tq).
• Bit segment 1 (BS1): определяет расположение точки выборки. Он включает PROP_SEG и PHASE_SEG1 CAN стандарта. Его длительность программируется между 1 и 16 квантами времени но может быть автоматически удлинена для компенсации положительных дрейфов фазы из-за разностей в частоте различных узлов сети.  
• Bit segment 2 (BS2): определяет расположение точки передачи. Он представляет собой PHASE_SEG2 стандарта CAN. Его длительность программируется между 1 и 8 квантами времени, но может также быть автоматически укорочена для компенсации отрицательных дрейфов фазы.

Ширина перехода ресинхронизации (SJW) оперделяет верхнюю границу итогового удлиннения или укорочения битовых сегментов. Это программируется между 1 и 4 квантами времени.

Валидный фронт определяется как первый переход за некоторое время из доминантного в рецессвный, если сам контроллер не отправляет рецессивный бит.
Если валидный фронт детектируется в BS1 вместо SYNC_SEG, BS1 расширяется до SJW так, что точка выборки задерживается.
Наоборот, если валидный фронт детектируется в BS2 вместо SYNC_SEG, BS2 укорачивается до SJW так, что точка передачи перемещается раньше.
В качестве защиты от ошибок программирования, конфигурация CAN_BTR возможна только когда устройство в режиме Standby.
За деталями по CAN bit timing and resinchronization mechanism, обратитесь к стандарту ISO 11898. 


31.8 Прерывания bxCAN
4 вектора прерываний предназначены для bxCAN. Каждый источник прерываний может быть независимо включен или отключен посредством регистра CAN_IER

• The transmit interrupt может быть сгенерировано следующими событиями:
-Почтовый ящик передачи 0 становится пуст, устанавливается бит RQCP0 в регистре CAN_TSR
-Почтовый ящик передачи 1 становится пуст, устанавливается бит RQCP1 в регистре CAN_TSR
-Почтовый ящик передачи 2 становится пуст, устанавливается бит RQCP2 в регистре CAN_TSR
• The FIFO 0 interrupt может быть сгенерировано следующими событиями:
-Прием нового сообщения, FMP0 биты в регистре CAN_RF0R не равны ‘00’.
-Состояние FIFO0 full, FIFO0 бит в регистре CAN_RF0R установлен
-Состояние FIFO0 overrun, FOVR0 бит в регистре CAN_RF0R установлен
• The FIFO 1 interrupt может быть сгенерировано следующими событиями:
-Прием нового сообщения, FMP1 биты в регистре CAN_RF1R не равны ‘00’.
-Состояние FIFO1 full, FIFO1 бит в регистре CAN_RF1R установлен
-Состояние FIFO1 overrun, FOVR1 бит в регистре CAN_RF1R установлен
• The error and status change interrupt может быть сгенерировано следующими событиями:
-Состояние ошибки, за подробностями к регистру CAN_ESR
-Состояние пробуждения, SOF отслеживается по сигналу CAN Rx
-Вход в Sleep режим.

31.9 CAN регистры
Периферийные регистры должны быть доступны по словам (32 бита).
31.9.1 Защита доступа к регистру
Ошибочный доступ к определенным регистрам конфигурации может привести к тому что аппаратная часть нарушит всю сеть CAN. Поэтому регистр CAN_BTR может быть модифицирован из ПО только пока аппаратная часть CAN в режиме инициализации.
Хотя передача некорректных данных не вызовет проблем на уровне CAN сети, это может серьезно помешать приложению. Почтовый ящик для передачи может быть модифицирован только программой пока он в empty (рис. 391: Transmit mailbox states).
Значения фильтра могут быть модифицированы либо деактивацией связанных банков фильтра,  либо настройкой бита FINIT. Более того, модификация конфигурации фильтра (масштабирование, режим и назначение FIFO) в CAN_FMxR, CAN_FSxR и CAN_FFAR регистрах может быть сделано только когда режим инициализации фльтра устанавливается (FINIT=1) в регистре CAN_FMR.