// Информация о файле: $HeadURL: http://s005.sensor:18080/svn/Sens/trunk/SensProc/SensProc.h $
// $Revision: 8 $  $Date: 2015-12-25 16:23:16 +0300 (РџС‚, 25 РґРµРє 2015) $  $Author: bryakin $
// Версия 0.6
// Отличия в обработке типа S_PROGNUM - теперь он 32-х битный (не доступен по СЕНС старший байт)

#ifndef SENSPROC_H
#define SENSPROC_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

// Текущий уровень доступа
#define USERMODE  2
#define ADMINMODE 1
#define SUPERMODE 0

// Расшифровка поля "Тип параметра"
// Уровни доступа
#define READ_ALL      0xC0
#define READ_ADM      0x80
#define READ_SUP      0x40
#define WRITE_ALL     0x30
#define WRITE_ADM     0x20
#define WRITE_SUP     0x10
#define WRITE_NON     0x00
// Типы данных
#define S_FLOAT       0x00
#define S_BYTE        0x01  // Отображение в int8_t , 0x80 - ошибка
//#define S_LONG    0x02    // Отображение в int16_t  0x8000 - ошибка
//#define S_UBYTE   0x03    // Отображение в uint8_t  0x80 - ошибка
//#define S_UWORD   0x04    // Отображение в uint16_t 0x8000 - ошибка
#define S_EIZM    	 0x08    // Единицы измерения
#define S_VARFLOATTBL 0x09  // Таблица с параметрами Float, хранящаяся в памяти как Float[], и переменной длиной
#define S_FLOATTBL    0x0A  // Таблица с параметрами Float, хранящаяся в памяти как Float[]
#define S_FRAMTABLE   0x0B  // Внешняя таблица - особое обращение!
#define S_PROGNUM     0x0C    // Номер программы. Ссылается на uint32_t. Старший байт по сенс не доступен.
#define S_BITS        0x0D    // Отображение идет в uint16_t, старший байт - маска. Ошибки не предусмотрены
#define S_ADDR        0x0E    // Три одинаковых байта. Ошибки не предусмотрены. Хранится один байт как uint8_t
#define S_TABLE       0x0F    // Таблица. Ошибки не предусмотрены


// Определитель параметров
typedef struct {
  uint8_t ID;     // Номер параметра
  uint8_t Type;   // Тип параметра и дотсуп к параметру
  __attribute__((packed)) void * Pointer;
} SensOneParam;

// Определитель таблицы
typedef struct {
  void * Data;   // Указатель на данные
  uint32_t Length;  // Длина таблицы (в байтах для S_TABLE и float для S_FLOATTBL)
  uint32_t * VarLength; // Указатель на текущую длину таблицы
} SensTable;

#define SAVETIMEOUT 5000 // Пять секунд - для записи настроек в режиме пользователя

/////////////////////////////////////////////////////////
char SensAnswerPkg(uint8_t * buf); // Функция отвечает на пакет СЕНС
void SensPkgProc(void);            // Вызывать постоянно - проверяет таймаут записи настроек

// Функции управления уровнями доступа
uint8_t GetAccessMode(void);             // Возвращает текущий уровень доступа
void ResetAccess(void);                  // Переключает на пользовательский режим без сохранения изменений

////////////////////////////////////////////////////////////////////////////////////
// Служебные функции
void FloatToS3B(__packed uint8_t*buf,float inf); // Преобразование Float -> 3 байта
float S3BToFloat(__packed uint8_t * buf);        // Преобразование 3 байта -> float
float theerr(void);           // Возвращает 0xFFFFFFFF
uint8_t iserr(const float f); // Проверяет только 3 байта, без младшего
uint8_t isok(float f);        // Возвращает 1, если параметр не ошибка и не ноль

const SensOneParam * FindParam(uint8_t idp); // Поиск параметра в списке

/////////////////////////////////////////////////////////
// Эти функции и переменные должны быть описаны в SensDev для конкретного устройства

extern const SensOneParam Params[];

// Данная функция вызывается когда нужно узнать содержимое пункта меню
uint8_t ThePredef(uint8_t,uint8_t*);  // Возвращает пункт меню

// Выполнение команды калибровки, не являющейся основной
// Вход - полный буфер пришедшего пакета
// На выходе может формироваться буфер и возвращается:
//   0 если команда выполнена (буфер формируется сам)
//   1 если команда не выполнена (буфер формируется сам)
//   8 если требуются дополнительные параметры (нужен сформированный буфер)
// 255 если команда неизвестна (буфер должен быть оставлен без изменения)
// Номер команды - в buf[3]
uint8_t SetTCPnt(uint8_t * buf);

void SetSaveData(void);   // Взывать, чтобы при выходе из режима администратора сохранились настройки даже если изменений не было

//extern MySettings DSt;    // Копия настроек в ОЗУ

// Данная функция вызывается когда нужно сохранить изменения в настройках
// При режиме "USER" - после каждого изменения (не рекомендуется использовать)
// При остальных режимах - при возврате к режиму USER
// Передаваемый параметр - код измененного параметра или 0, если сохранять все
void SaveConst(uint8_t);                 // Сохраняет измененные настройки в память
// Данная функция вызывается для копирования настроек в буфер в ОЗУ
void LoadConst(void);
void LoadTCTab(void);
// Данная функция возвращает состояние переключателя физической блокировки настроек
// 0 - запись в память разрешена
//uint8_t GetReadOnly(void);

#ifdef __cplusplus
}
#endif

#endif
