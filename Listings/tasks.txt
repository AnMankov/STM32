; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\tasks.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tasks.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I.\Source\Ext_Dev\inc\AT45 -I.\Objects -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\tasks.crf Source\RTOS\src\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1270   
;;;1271   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1272   	{
000004  4607              MOV      r7,r0
;;;1273   	eTaskState eReturn;
;;;1274   	List_t *pxStateList;
;;;1275   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000006  463e              MOV      r6,r7
;;;1276   
;;;1277   		configASSERT( pxTCB );
000008  b956              CBNZ     r6,|L1.32|
00000a  bf00              NOP      
00000c  2030              MOVS     r0,#0x30
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L1.30|
00001e  e7fe              B        |L1.30|
                  |L1.32|
;;;1278   
;;;1279   		if( pxTCB == pxCurrentTCB )
000020  4813              LDR      r0,|L1.112|
000022  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  4286              CMP      r6,r0
000026  d101              BNE      |L1.44|
;;;1280   		{
;;;1281   			/* The task calling this function is querying its own state. */
;;;1282   			eReturn = eRunning;
000028  2400              MOVS     r4,#0
00002a  e01e              B        |L1.106|
                  |L1.44|
;;;1283   		}
;;;1284   		else
;;;1285   		{
;;;1286   			taskENTER_CRITICAL();
00002c  f7fffffe          BL       vPortEnterCritical
;;;1287   			{
;;;1288   				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
000030  6975              LDR      r5,[r6,#0x14]
;;;1289   			}
;;;1290   			taskEXIT_CRITICAL();
000032  f7fffffe          BL       vPortExitCritical
;;;1291   
;;;1292   			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
000036  480f              LDR      r0,|L1.116|
000038  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00003a  4285              CMP      r5,r0
00003c  d003              BEQ      |L1.70|
00003e  480e              LDR      r0,|L1.120|
000040  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000042  4285              CMP      r5,r0
000044  d101              BNE      |L1.74|
                  |L1.70|
;;;1293   			{
;;;1294   				/* The task being queried is referenced from one of the Blocked
;;;1295   				lists. */
;;;1296   				eReturn = eBlocked;
000046  2402              MOVS     r4,#2
000048  e00f              B        |L1.106|
                  |L1.74|
;;;1297   			}
;;;1298   
;;;1299   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1300   				else if( pxStateList == &xSuspendedTaskList )
00004a  480c              LDR      r0,|L1.124|
00004c  4285              CMP      r5,r0
00004e  d105              BNE      |L1.92|
;;;1301   				{
;;;1302   					/* The task being queried is referenced from the suspended
;;;1303   					list.  Is it genuinely suspended or is it block
;;;1304   					indefinitely? */
;;;1305   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
000050  6ab0              LDR      r0,[r6,#0x28]
000052  b908              CBNZ     r0,|L1.88|
;;;1306   					{
;;;1307   						eReturn = eSuspended;
000054  2403              MOVS     r4,#3
000056  e008              B        |L1.106|
                  |L1.88|
;;;1308   					}
;;;1309   					else
;;;1310   					{
;;;1311   						eReturn = eBlocked;
000058  2402              MOVS     r4,#2
00005a  e006              B        |L1.106|
                  |L1.92|
;;;1312   					}
;;;1313   				}
;;;1314   			#endif
;;;1315   
;;;1316   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1317   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
00005c  4808              LDR      r0,|L1.128|
00005e  4285              CMP      r5,r0
000060  d000              BEQ      |L1.100|
000062  b90d              CBNZ     r5,|L1.104|
                  |L1.100|
;;;1318   				{
;;;1319   					/* The task being queried is referenced from the deleted
;;;1320   					tasks list, or it is not referenced from any lists at
;;;1321   					all. */
;;;1322   					eReturn = eDeleted;
000064  2404              MOVS     r4,#4
000066  e000              B        |L1.106|
                  |L1.104|
;;;1323   				}
;;;1324   			#endif
;;;1325   
;;;1326   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1327   			{
;;;1328   				/* If the task is not in any other state, it must be in the
;;;1329   				Ready (including pending ready) state. */
;;;1330   				eReturn = eReady;
000068  2401              MOVS     r4,#1
                  |L1.106|
;;;1331   			}
;;;1332   		}
;;;1333   
;;;1334   		return eReturn;
00006a  4620              MOV      r0,r4
;;;1335   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1336   
                          ENDP

                  |L1.112|
                          DCD      pxCurrentTCB
                  |L1.116|
                          DCD      pxDelayedTaskList
                  |L1.120|
                          DCD      pxOverflowDelayedTaskList
                  |L1.124|
                          DCD      xSuspendedTaskList
                  |L1.128|
                          DCD      xTasksWaitingTermination

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2182   
;;;2183   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;2184   {
;;;2185   TCB_t *pxTCB;
;;;2186   
;;;2187   	/* If null is passed in here then the name of the calling task is being
;;;2188   	queried. */
;;;2189   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000002  b911              CBNZ     r1,|L2.10|
000004  4809              LDR      r0,|L2.44|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000008  e000              B        |L2.12|
                  |L2.10|
00000a  4608              MOV      r0,r1
                  |L2.12|
00000c  4602              MOV      r2,r0
;;;2190   	configASSERT( pxTCB );
00000e  b952              CBNZ     r2,|L2.38|
000010  bf00              NOP      
000012  2030              MOVS     r0,#0x30
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L2.36|
000024  e7fe              B        |L2.36|
                  |L2.38|
;;;2191   	return &( pxTCB->pcTaskName[ 0 ] );
000026  f1020034          ADD      r0,r2,#0x34
;;;2192   }
00002a  4770              BX       lr
;;;2193   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.44|
                          DCD      pxCurrentTCB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4693   
;;;4694   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4695   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;4696   TickType_t xTimeToWake;
;;;4697   const TickType_t xConstTickCount = xTickCount;
000008  481c              LDR      r0,|L3.124|
00000a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;4698   
;;;4699   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4700   	{
;;;4701   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4702   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4703   		when the task leaves the Blocked state. */
;;;4704   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4705   	}
;;;4706   	#endif
;;;4707   
;;;4708   	/* Remove the task from the ready list before adding it to the blocked list
;;;4709   	as the same list item is used for both lists. */
;;;4710   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  481c              LDR      r0,|L3.128|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
000016  b950              CBNZ     r0,|L3.46|
;;;4711   	{
;;;4712   		/* The current task must be in a ready list, so there is no need to
;;;4713   		check, and the port reset macro can be called directly. */
;;;4714   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000018  4819              LDR      r0,|L3.128|
00001a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  f890102c          LDRB     r1,[r0,#0x2c]
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  4917              LDR      r1,|L3.132|
000026  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000028  4381              BICS     r1,r1,r0
00002a  4816              LDR      r0,|L3.132|
00002c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L3.46|
;;;4715   	}
;;;4716   	else
;;;4717   	{
;;;4718   		mtCOVERAGE_TEST_MARKER();
;;;4719   	}
;;;4720   
;;;4721   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4722   	{
;;;4723   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
00002e  1c68              ADDS     r0,r5,#1
000030  b938              CBNZ     r0,|L3.66|
000032  b136              CBZ      r6,|L3.66|
;;;4724   		{
;;;4725   			/* Add the task to the suspended task list instead of a delayed task
;;;4726   			list to ensure it is not woken by a timing event.  It will block
;;;4727   			indefinitely. */
;;;4728   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
000034  4812              LDR      r0,|L3.128|
000036  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000038  1d09              ADDS     r1,r1,#4
00003a  4813              LDR      r0,|L3.136|
00003c  f7fffffe          BL       vListInsertEnd
000040  e01a              B        |L3.120|
                  |L3.66|
;;;4729   		}
;;;4730   		else
;;;4731   		{
;;;4732   			/* Calculate the time at which the task should be woken if the event
;;;4733   			does not occur.  This may overflow but this doesn't matter, the
;;;4734   			kernel will manage it correctly. */
;;;4735   			xTimeToWake = xConstTickCount + xTicksToWait;
000042  197c              ADDS     r4,r7,r5
;;;4736   
;;;4737   			/* The list item will be inserted in wake time order. */
;;;4738   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
000044  480e              LDR      r0,|L3.128|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  6044              STR      r4,[r0,#4]
;;;4739   
;;;4740   			if( xTimeToWake < xConstTickCount )
00004a  42bc              CMP      r4,r7
00004c  d207              BCS      |L3.94|
;;;4741   			{
;;;4742   				/* Wake time has overflowed.  Place this item in the overflow
;;;4743   				list. */
;;;4744   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00004e  480c              LDR      r0,|L3.128|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  1d09              ADDS     r1,r1,#4
000054  480d              LDR      r0,|L3.140|
000056  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000058  f7fffffe          BL       vListInsert
00005c  e00c              B        |L3.120|
                  |L3.94|
;;;4745   			}
;;;4746   			else
;;;4747   			{
;;;4748   				/* The wake time has not overflowed, so the current block list
;;;4749   				is used. */
;;;4750   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00005e  4808              LDR      r0,|L3.128|
000060  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000062  1d09              ADDS     r1,r1,#4
000064  480a              LDR      r0,|L3.144|
000066  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000068  f7fffffe          BL       vListInsert
;;;4751   
;;;4752   				/* If the task entering the blocked state was placed at the
;;;4753   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4754   				needs to be updated too. */
;;;4755   				if( xTimeToWake < xNextTaskUnblockTime )
00006c  4809              LDR      r0,|L3.148|
00006e  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000070  4284              CMP      r4,r0
000072  d201              BCS      |L3.120|
;;;4756   				{
;;;4757   					xNextTaskUnblockTime = xTimeToWake;
000074  4807              LDR      r0,|L3.148|
000076  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L3.120|
;;;4758   				}
;;;4759   				else
;;;4760   				{
;;;4761   					mtCOVERAGE_TEST_MARKER();
;;;4762   				}
;;;4763   			}
;;;4764   		}
;;;4765   	}
;;;4766   	#else /* INCLUDE_vTaskSuspend */
;;;4767   	{
;;;4768   		/* Calculate the time at which the task should be woken if the event
;;;4769   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4770   		will manage it correctly. */
;;;4771   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4772   
;;;4773   		/* The list item will be inserted in wake time order. */
;;;4774   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4775   
;;;4776   		if( xTimeToWake < xConstTickCount )
;;;4777   		{
;;;4778   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4779   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4780   		}
;;;4781   		else
;;;4782   		{
;;;4783   			/* The wake time has not overflowed, so the current block list is used. */
;;;4784   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4785   
;;;4786   			/* If the task entering the blocked state was placed at the head of the
;;;4787   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;4788   			too. */
;;;4789   			if( xTimeToWake < xNextTaskUnblockTime )
;;;4790   			{
;;;4791   				xNextTaskUnblockTime = xTimeToWake;
;;;4792   			}
;;;4793   			else
;;;4794   			{
;;;4795   				mtCOVERAGE_TEST_MARKER();
;;;4796   			}
;;;4797   		}
;;;4798   
;;;4799   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;4800   		( void ) xCanBlockIndefinitely;
;;;4801   	}
;;;4802   	#endif /* INCLUDE_vTaskSuspend */
;;;4803   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;4804   
                          ENDP

                  |L3.124|
                          DCD      xTickCount
                  |L3.128|
                          DCD      pxCurrentTCB
                  |L3.132|
                          DCD      uxTopReadyPriority
                  |L3.136|
                          DCD      xSuspendedTaskList
                  |L3.140|
                          DCD      pxOverflowDelayedTaskList
                  |L3.144|
                          DCD      pxDelayedTaskList
                  |L3.148|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;964    
;;;965    static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b510              PUSH     {r4,lr}
;;;966    {
000002  4604              MOV      r4,r0
;;;967    	/* Ensure interrupts don't access the task lists while the lists are being
;;;968    	updated. */
;;;969    	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;970    	{
;;;971    		uxCurrentNumberOfTasks++;
000008  4824              LDR      r0,|L4.156|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  4923              LDR      r1,|L4.156|
000010  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;972    		if( pxCurrentTCB == NULL )
000012  4823              LDR      r0,|L4.160|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  b940              CBNZ     r0,|L4.42|
;;;973    		{
;;;974    			/* There are no other tasks, or all the other tasks are in
;;;975    			the suspended state - make this the current task. */
;;;976    			pxCurrentTCB = pxNewTCB;
000018  4821              LDR      r0,|L4.160|
00001a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;977    
;;;978    			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L4.64|
;;;979    			{
;;;980    				/* This is the first task to be created so do the preliminary
;;;981    				initialisation required.  We will not recover if this call
;;;982    				fails, but we will report the failure. */
;;;983    				prvInitialiseTaskLists();
000024  f7fffffe          BL       prvInitialiseTaskLists
000028  e00a              B        |L4.64|
                  |L4.42|
;;;984    			}
;;;985    			else
;;;986    			{
;;;987    				mtCOVERAGE_TEST_MARKER();
;;;988    			}
;;;989    		}
;;;990    		else
;;;991    		{
;;;992    			/* If the scheduler is not already running, make this task the
;;;993    			current task if it is the highest priority task to be created
;;;994    			so far. */
;;;995    			if( xSchedulerRunning == pdFALSE )
00002a  481e              LDR      r0,|L4.164|
00002c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00002e  b938              CBNZ     r0,|L4.64|
;;;996    			{
;;;997    				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000030  481b              LDR      r0,|L4.160|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  6ac0              LDR      r0,[r0,#0x2c]
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  4288              CMP      r0,r1
00003a  d801              BHI      |L4.64|
;;;998    				{
;;;999    					pxCurrentTCB = pxNewTCB;
00003c  4818              LDR      r0,|L4.160|
00003e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L4.64|
;;;1000   				}
;;;1001   				else
;;;1002   				{
;;;1003   					mtCOVERAGE_TEST_MARKER();
;;;1004   				}
;;;1005   			}
;;;1006   			else
;;;1007   			{
;;;1008   				mtCOVERAGE_TEST_MARKER();
;;;1009   			}
;;;1010   		}
;;;1011   
;;;1012   		uxTaskNumber++;
000040  4819              LDR      r0,|L4.168|
000042  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000044  1c40              ADDS     r0,r0,#1
000046  4918              LDR      r1,|L4.168|
000048  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1013   
;;;1014   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1015   		{
;;;1016   			/* Add a counter into the TCB for tracing only. */
;;;1017   			pxNewTCB->uxTCBNumber = uxTaskNumber;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004e  6460              STR      r0,[r4,#0x44]
;;;1018   		}
;;;1019   		#endif /* configUSE_TRACE_FACILITY */
;;;1020   		traceTASK_CREATE( pxNewTCB );
;;;1021   
;;;1022   		prvAddTaskToReadyList( pxNewTCB );
000050  f894102c          LDRB     r1,[r4,#0x2c]
000054  2001              MOVS     r0,#1
000056  4088              LSLS     r0,r0,r1
000058  4914              LDR      r1,|L4.172|
00005a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005c  4308              ORRS     r0,r0,r1
00005e  4913              LDR      r1,|L4.172|
000060  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000062  6ae1              LDR      r1,[r4,#0x2c]
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  4a11              LDR      r2,|L4.176|
00006a  eb020081          ADD      r0,r2,r1,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
;;;1023   
;;;1024   		portSETUP_TCB( pxNewTCB );
;;;1025   	}
;;;1026   	taskEXIT_CRITICAL();
000074  f7fffffe          BL       vPortExitCritical
;;;1027   
;;;1028   	if( xSchedulerRunning != pdFALSE )
000078  480a              LDR      r0,|L4.164|
00007a  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00007c  b168              CBZ      r0,|L4.154|
;;;1029   	{
;;;1030   		/* If the created task is of a higher priority than the current task
;;;1031   		then it should run now. */
;;;1032   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
00007e  4808              LDR      r0,|L4.160|
000080  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000082  6ac0              LDR      r0,[r0,#0x2c]
000084  6ae1              LDR      r1,[r4,#0x2c]
000086  4288              CMP      r0,r1
000088  d207              BCS      |L4.154|
;;;1033   		{
;;;1034   			taskYIELD_IF_USING_PREEMPTION();
00008a  f04f5080          MOV      r0,#0x10000000
00008e  4909              LDR      r1,|L4.180|
000090  6008              STR      r0,[r1,#0]
000092  f3bf8f4f          DSB      
000096  f3bf8f6f          ISB      
                  |L4.154|
;;;1035   		}
;;;1036   		else
;;;1037   		{
;;;1038   			mtCOVERAGE_TEST_MARKER();
;;;1039   		}
;;;1040   	}
;;;1041   	else
;;;1042   	{
;;;1043   		mtCOVERAGE_TEST_MARKER();
;;;1044   	}
;;;1045   }
00009a  bd10              POP      {r4,pc}
;;;1046   /*-----------------------------------------------------------*/
                          ENDP

                  |L4.156|
                          DCD      uxCurrentNumberOfTasks
                  |L4.160|
                          DCD      pxCurrentTCB
                  |L4.164|
                          DCD      xSchedulerRunning
                  |L4.168|
                          DCD      uxTaskNumber
                  |L4.172|
                          DCD      uxTopReadyPriority
                  |L4.176|
                          DCD      pxReadyTasksLists
                  |L4.180|
                          DCD      0xe000ed04

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3366   
;;;3367   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;3368   {
;;;3369   
;;;3370   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3371   
;;;3372   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3373   	{
;;;3374   		BaseType_t xListIsEmpty;
;;;3375   
;;;3376   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3377   		too often in the idle task. */
;;;3378   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000002  e023              B        |L5.76|
                  |L5.4|
;;;3379   		{
;;;3380   			vTaskSuspendAll();
000004  f7fffffe          BL       vTaskSuspendAll
;;;3381   			{
;;;3382   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000008  4813              LDR      r0,|L5.88|
00000a  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
00000c  b908              CBNZ     r0,|L5.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L5.20|
                  |L5.18|
000012  2000              MOVS     r0,#0
                  |L5.20|
000014  4605              MOV      r5,r0
;;;3383   			}
;;;3384   			( void ) xTaskResumeAll();
000016  f7fffffe          BL       xTaskResumeAll
;;;3385   
;;;3386   			if( xListIsEmpty == pdFALSE )
00001a  b9bd              CBNZ     r5,|L5.76|
;;;3387   			{
;;;3388   				TCB_t *pxTCB;
;;;3389   
;;;3390   				taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;3391   				{
;;;3392   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
000020  480d              LDR      r0,|L5.88|
000022  68c0              LDR      r0,[r0,#0xc]
000024  68c4              LDR      r4,[r0,#0xc]
;;;3393   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       uxListRemove
;;;3394   					--uxCurrentNumberOfTasks;
00002c  480b              LDR      r0,|L5.92|
00002e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000030  1e40              SUBS     r0,r0,#1
000032  490a              LDR      r1,|L5.92|
000034  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3395   					--uxDeletedTasksWaitingCleanUp;
000036  480a              LDR      r0,|L5.96|
000038  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
00003a  1e40              SUBS     r0,r0,#1
00003c  4908              LDR      r1,|L5.96|
00003e  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3396   				}
;;;3397   				taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;3398   
;;;3399   				prvDeleteTCB( pxTCB );
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       prvDeleteTCB
;;;3400   			}
00004a  bf00              NOP      
                  |L5.76|
00004c  4804              LDR      r0,|L5.96|
00004e  6800              LDR      r0,[r0,#0]            ;3378  ; uxDeletedTasksWaitingCleanUp
000050  2800              CMP      r0,#0                 ;3378
000052  d1d7              BNE      |L5.4|
;;;3401   			else
;;;3402   			{
;;;3403   				mtCOVERAGE_TEST_MARKER();
;;;3404   			}
;;;3405   		}
;;;3406   	}
;;;3407   	#endif /* INCLUDE_vTaskDelete */
;;;3408   }
000054  bd70              POP      {r4-r6,pc}
;;;3409   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      xTasksWaitingTermination
                  |L5.92|
                          DCD      uxCurrentNumberOfTasks
                  |L5.96|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3582   
;;;3583   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3584   	{
000002  4604              MOV      r4,r0
;;;3585   		/* This call is required specifically for the TriCore port.  It must be
;;;3586   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3587   		want to allocate and clean RAM statically. */
;;;3588   		portCLEAN_UP_TCB( pxTCB );
;;;3589   
;;;3590   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3591   		to the task to free any memory allocated at the application level. */
;;;3592   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3593   		{
;;;3594   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3595   		}
;;;3596   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3597   
;;;3598   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3599   		{
;;;3600   			/* The task can only have been allocated dynamically - free both
;;;3601   			the stack and TCB. */
;;;3602   			vPortFree( pxTCB->pxStack );
000004  6b20              LDR      r0,[r4,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3603   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3604   		}
;;;3605   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
;;;3606   		{
;;;3607   			/* The task could have been allocated statically or dynamically, so
;;;3608   			check what was statically allocated before trying to free the
;;;3609   			memory. */
;;;3610   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3611   			{
;;;3612   				/* Both the stack and TCB were allocated dynamically, so both
;;;3613   				must be freed. */
;;;3614   				vPortFree( pxTCB->pxStack );
;;;3615   				vPortFree( pxTCB );
;;;3616   			}
;;;3617   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3618   			{
;;;3619   				/* Only the stack was statically allocated, so the TCB is the
;;;3620   				only memory that must be freed. */
;;;3621   				vPortFree( pxTCB );
;;;3622   			}
;;;3623   			else
;;;3624   			{
;;;3625   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3626   				nothing needs to be freed. */
;;;3627   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
;;;3628   				mtCOVERAGE_TEST_MARKER();
;;;3629   			}
;;;3630   		}
;;;3631   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3632   	}
000010  bd10              POP      {r4,pc}
;;;3633   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=1

                  prvIdleTask PROC
;;;3132    */
;;;3133   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L7.2|
;;;3134   {
;;;3135   	/* Stop warnings. */
;;;3136   	( void ) pvParameters;
;;;3137   
;;;3138   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3139   	SCHEDULER IS STARTED. **/
;;;3140   
;;;3141   	for( ;; )
;;;3142   	{
;;;3143   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3144   		is responsible for freeing the deleted task's TCB and stack. */
;;;3145   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3146   
;;;3147   		#if ( configUSE_PREEMPTION == 0 )
;;;3148   		{
;;;3149   			/* If we are not using preemption we keep forcing a task switch to
;;;3150   			see if any other task has become available.  If we are using
;;;3151   			preemption we don't need to do this as any task becoming available
;;;3152   			will automatically get the processor anyway. */
;;;3153   			taskYIELD();
;;;3154   		}
;;;3155   		#endif /* configUSE_PREEMPTION */
;;;3156   
;;;3157   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3158   		{
;;;3159   			/* When using preemption tasks of equal priority will be
;;;3160   			timesliced.  If a task that is sharing the idle priority is ready
;;;3161   			to run then the idle task should yield before the end of the
;;;3162   			timeslice.
;;;3163   
;;;3164   			A critical region is not required here as we are just reading from
;;;3165   			the list, and an occasional incorrect value will not matter.  If
;;;3166   			the ready list at the idle priority contains more than one task
;;;3167   			then a task other than the idle task is ready to execute. */
;;;3168   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
;;;3169   			{
;;;3170   				taskYIELD();
;;;3171   			}
;;;3172   			else
;;;3173   			{
;;;3174   				mtCOVERAGE_TEST_MARKER();
;;;3175   			}
;;;3176   		}
;;;3177   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3178   
;;;3179   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3180   		{
;;;3181   			extern void vApplicationIdleHook( void );
;;;3182   
;;;3183   			/* Call the user defined function from within the idle task.  This
;;;3184   			allows the application designer to add background functionality
;;;3185   			without the overhead of a separate task.
;;;3186   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3187   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3188   			vApplicationIdleHook();
000006  f7fffffe          BL       vApplicationIdleHook
00000a  e7fa              B        |L7.2|
;;;3189   		}
;;;3190   		#endif /* configUSE_IDLE_HOOK */
;;;3191   
;;;3192   		/* This conditional compilation should use inequality to 0, not equality
;;;3193   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3194   		user defined low power mode	implementations require
;;;3195   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3196   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3197   		{
;;;3198   		TickType_t xExpectedIdleTime;
;;;3199   
;;;3200   			/* It is not desirable to suspend then resume the scheduler on
;;;3201   			each iteration of the idle task.  Therefore, a preliminary
;;;3202   			test of the expected idle time is performed without the
;;;3203   			scheduler suspended.  The result here is not necessarily
;;;3204   			valid. */
;;;3205   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3206   
;;;3207   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3208   			{
;;;3209   				vTaskSuspendAll();
;;;3210   				{
;;;3211   					/* Now the scheduler is suspended, the expected idle
;;;3212   					time can be sampled again, and this time its value can
;;;3213   					be used. */
;;;3214   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3215   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3216   
;;;3217   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3218   					{
;;;3219   						traceLOW_POWER_IDLE_BEGIN();
;;;3220   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3221   						traceLOW_POWER_IDLE_END();
;;;3222   					}
;;;3223   					else
;;;3224   					{
;;;3225   						mtCOVERAGE_TEST_MARKER();
;;;3226   					}
;;;3227   				}
;;;3228   				( void ) xTaskResumeAll();
;;;3229   			}
;;;3230   			else
;;;3231   			{
;;;3232   				mtCOVERAGE_TEST_MARKER();
;;;3233   			}
;;;3234   		}
;;;3235   		#endif /* configUSE_TICKLESS_IDLE */
;;;3236   	}
;;;3237   }
;;;3238   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;768    
;;;769    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;770    									const char * const pcName,
;;;771    									const uint32_t ulStackDepth,
;;;772    									void * const pvParameters,
;;;773    									UBaseType_t uxPriority,
;;;774    									TaskHandle_t * const pxCreatedTask,
;;;775    									TCB_t *pxNewTCB,
;;;776    									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;777    {
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  9e0a              LDR      r6,[sp,#0x28]
00000e  9c0c              LDR      r4,[sp,#0x30]
;;;778    StackType_t *pxTopOfStack;
;;;779    UBaseType_t x;
;;;780    
;;;781    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;782    		/* Should the task be created in privileged mode? */
;;;783    		BaseType_t xRunPrivileged;
;;;784    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;785    		{
;;;786    			xRunPrivileged = pdTRUE;
;;;787    		}
;;;788    		else
;;;789    		{
;;;790    			xRunPrivileged = pdFALSE;
;;;791    		}
;;;792    		uxPriority &= ~portPRIVILEGE_BIT;
;;;793    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;794    
;;;795    	/* Avoid dependency on memset() if it is not required. */
;;;796    	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;797    	{
;;;798    		/* Fill the stack with a known value to assist debugging. */
;;;799    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000010  ea4f0188          LSL      r1,r8,#2
000014  22a5              MOVS     r2,#0xa5
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       __aeabi_memset
;;;800    	}
;;;801    	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;802    
;;;803    	/* Calculate the top of stack address.  This depends on whether the stack
;;;804    	grows from high memory to low (as per the 80x86) or vice versa.
;;;805    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;806    	by the port. */
;;;807    	#if( portSTACK_GROWTH < 0 )
;;;808    	{
;;;809    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
00001c  f1a80001          SUB      r0,r8,#1
000020  6b21              LDR      r1,[r4,#0x30]
000022  eb010980          ADD      r9,r1,r0,LSL #2
;;;810    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000026  f0290907          BIC      r9,r9,#7
;;;811    
;;;812    		/* Check the alignment of the calculated top of stack is correct. */
;;;813    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
00002a  f0090007          AND      r0,r9,#7
00002e  b908              CBNZ     r0,|L8.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L8.54|
                  |L8.52|
000034  2000              MOVS     r0,#0
                  |L8.54|
000036  b950              CBNZ     r0,|L8.78|
000038  bf00              NOP      
00003a  2030              MOVS     r0,#0x30
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L8.76|
00004c  e7fe              B        |L8.76|
                  |L8.78|
;;;814    	}
;;;815    	#else /* portSTACK_GROWTH */
;;;816    	{
;;;817    		pxTopOfStack = pxNewTCB->pxStack;
;;;818    
;;;819    		/* Check the alignment of the stack buffer is correct. */
;;;820    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;821    
;;;822    		/* The other extreme of the stack space is required if stack checking is
;;;823    		performed. */
;;;824    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;825    	}
;;;826    	#endif /* portSTACK_GROWTH */
;;;827    
;;;828    	/* Store the task name in the TCB. */
;;;829    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
00004e  2500              MOVS     r5,#0
000050  e007              B        |L8.98|
                  |L8.82|
;;;830    	{
;;;831    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000052  5d79              LDRB     r1,[r7,r5]
000054  f1040034          ADD      r0,r4,#0x34
000058  5541              STRB     r1,[r0,r5]
;;;832    
;;;833    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;834    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;835    		string is not accessible (extremely unlikely). */
;;;836    		if( pcName[ x ] == 0x00 )
00005a  5d78              LDRB     r0,[r7,r5]
00005c  b900              CBNZ     r0,|L8.96|
;;;837    		{
;;;838    			break;
00005e  e002              B        |L8.102|
                  |L8.96|
000060  1c6d              ADDS     r5,r5,#1              ;829
                  |L8.98|
000062  2d10              CMP      r5,#0x10              ;829
000064  d3f5              BCC      |L8.82|
                  |L8.102|
000066  bf00              NOP      
;;;839    		}
;;;840    		else
;;;841    		{
;;;842    			mtCOVERAGE_TEST_MARKER();
;;;843    		}
;;;844    	}
;;;845    
;;;846    	/* Ensure the name string is terminated in the case that the string length
;;;847    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;848    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000068  2100              MOVS     r1,#0
00006a  2043              MOVS     r0,#0x43
00006c  5501              STRB     r1,[r0,r4]
;;;849    
;;;850    	/* This is used as an array index so must ensure it's not too large.  First
;;;851    	remove the privilege bit if one is present. */
;;;852    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00006e  2e07              CMP      r6,#7
000070  d300              BCC      |L8.116|
;;;853    	{
;;;854    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000072  2606              MOVS     r6,#6
                  |L8.116|
;;;855    	}
;;;856    	else
;;;857    	{
;;;858    		mtCOVERAGE_TEST_MARKER();
;;;859    	}
;;;860    
;;;861    	pxNewTCB->uxPriority = uxPriority;
000074  62e6              STR      r6,[r4,#0x2c]
;;;862    	#if ( configUSE_MUTEXES == 1 )
;;;863    	{
;;;864    		pxNewTCB->uxBasePriority = uxPriority;
000076  64e6              STR      r6,[r4,#0x4c]
;;;865    		pxNewTCB->uxMutexesHeld = 0;
000078  2000              MOVS     r0,#0
00007a  6520              STR      r0,[r4,#0x50]
;;;866    	}
;;;867    	#endif /* configUSE_MUTEXES */
;;;868    
;;;869    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
00007c  1d20              ADDS     r0,r4,#4
00007e  f7fffffe          BL       vListInitialiseItem
;;;870    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000082  f1040018          ADD      r0,r4,#0x18
000086  f7fffffe          BL       vListInitialiseItem
;;;871    
;;;872    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;873    	back to	the containing TCB from a generic item in a list. */
;;;874    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
00008a  6124              STR      r4,[r4,#0x10]
;;;875    
;;;876    	/* Event lists are always in priority order. */
;;;877    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008c  f1c60007          RSB      r0,r6,#7
000090  61a0              STR      r0,[r4,#0x18]
;;;878    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000092  6264              STR      r4,[r4,#0x24]
;;;879    
;;;880    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;881    	{
;;;882    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;883    	}
;;;884    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;885    
;;;886    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;887    	{
;;;888    		pxNewTCB->pxTaskTag = NULL;
;;;889    	}
;;;890    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;891    
;;;892    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;893    	{
;;;894    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;895    	}
;;;896    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;897    
;;;898    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;899    	{
;;;900    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;901    	}
;;;902    	#else
;;;903    	{
;;;904    		/* Avoid compiler warning about unreferenced parameter. */
;;;905    		( void ) xRegions;
;;;906    	}
;;;907    	#endif
;;;908    
;;;909    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;910    	{
;;;911    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;912    		{
;;;913    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;914    		}
;;;915    	}
;;;916    	#endif
;;;917    
;;;918    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;919    	{
;;;920    		pxNewTCB->ulNotifiedValue = 0;
000094  2000              MOVS     r0,#0
000096  6560              STR      r0,[r4,#0x54]
;;;921    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000098  f8840058          STRB     r0,[r4,#0x58]
;;;922    	}
;;;923    	#endif
;;;924    
;;;925    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;926    	{
;;;927    		/* Initialise this task's Newlib reent structure. */
;;;928    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;929    	}
;;;930    	#endif
;;;931    
;;;932    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;933    	{
;;;934    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;935    	}
;;;936    	#endif
;;;937    
;;;938    	/* Initialize the TCB stack to look as if the task was already running,
;;;939    	but had been interrupted by the scheduler.  The return address is set
;;;940    	to the start of the task function. Once the stack has been initialised
;;;941    	the	top of stack variable is updated. */
;;;942    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;943    	{
;;;944    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;945    	}
;;;946    	#else /* portUSING_MPU_WRAPPERS */
;;;947    	{
;;;948    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
00009c  465a              MOV      r2,r11
00009e  4651              MOV      r1,r10
0000a0  4648              MOV      r0,r9
0000a2  f7fffffe          BL       pxPortInitialiseStack
0000a6  6020              STR      r0,[r4,#0]
;;;949    	}
;;;950    	#endif /* portUSING_MPU_WRAPPERS */
;;;951    
;;;952    	if( ( void * ) pxCreatedTask != NULL )
0000a8  980b              LDR      r0,[sp,#0x2c]
0000aa  b108              CBZ      r0,|L8.176|
;;;953    	{
;;;954    		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;955    		change the created task's priority, delete the created task, etc.*/
;;;956    		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
0000ac  980b              LDR      r0,[sp,#0x2c]
0000ae  6004              STR      r4,[r0,#0]
                  |L8.176|
;;;957    	}
;;;958    	else
;;;959    	{
;;;960    		mtCOVERAGE_TEST_MARKER();
;;;961    	}
;;;962    }
0000b0  e8bd9ff0          POP      {r4-r12,pc}
;;;963    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3334   
;;;3335   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;3336   {
;;;3337   UBaseType_t uxPriority;
;;;3338   
;;;3339   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L9.22|
                  |L9.6|
;;;3340   	{
;;;3341   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L9.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3339
                  |L9.22|
000016  2c07              CMP      r4,#7                 ;3339
000018  d3f5              BCC      |L9.6|
;;;3342   	}
;;;3343   
;;;3344   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L9.76|
00001c  f7fffffe          BL       vListInitialise
;;;3345   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L9.80|
000022  f7fffffe          BL       vListInitialise
;;;3346   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L9.84|
000028  f7fffffe          BL       vListInitialise
;;;3347   
;;;3348   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3349   	{
;;;3350   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L9.88|
00002e  f7fffffe          BL       vListInitialise
;;;3351   	}
;;;3352   	#endif /* INCLUDE_vTaskDelete */
;;;3353   
;;;3354   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3355   	{
;;;3356   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L9.92|
000034  f7fffffe          BL       vListInitialise
;;;3357   	}
;;;3358   	#endif /* INCLUDE_vTaskSuspend */
;;;3359   
;;;3360   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3361   	using list2. */
;;;3362   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L9.76|
00003a  4909              LDR      r1,|L9.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3363   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L9.80|
000040  4908              LDR      r1,|L9.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3364   }
000044  bd10              POP      {r4,pc}
;;;3365   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      pxReadyTasksLists
                  |L9.76|
                          DCD      xDelayedTaskList1
                  |L9.80|
                          DCD      xDelayedTaskList2
                  |L9.84|
                          DCD      xPendingReadyList
                  |L9.88|
                          DCD      xTasksWaitingTermination
                  |L9.92|
                          DCD      xSuspendedTaskList
                  |L9.96|
                          DCD      pxDelayedTaskList
                  |L9.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=1

                  prvListTasksWithinSingleList PROC
;;;3501   
;;;3502   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3503   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;3504   	volatile TCB_t *pxNextTCB, *pxFirstTCB;
;;;3505   	UBaseType_t uxTask = 0;
00000a  2600              MOVS     r6,#0
;;;3506   
;;;3507   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
00000c  6820              LDR      r0,[r4,#0]
00000e  b348              CBZ      r0,|L10.100|
;;;3508   		{
;;;3509   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
000010  4620              MOV      r0,r4
000012  6841              LDR      r1,[r0,#4]
000014  6849              LDR      r1,[r1,#4]
000016  6041              STR      r1,[r0,#4]
000018  f1000108          ADD      r1,r0,#8
00001c  6842              LDR      r2,[r0,#4]
00001e  428a              CMP      r2,r1
000020  d102              BNE      |L10.40|
000022  6841              LDR      r1,[r0,#4]
000024  6849              LDR      r1,[r1,#4]
000026  6041              STR      r1,[r0,#4]
                  |L10.40|
000028  6841              LDR      r1,[r0,#4]
00002a  f8d1900c          LDR      r9,[r1,#0xc]
;;;3510   
;;;3511   			/* Populate an TaskStatus_t structure within the
;;;3512   			pxTaskStatusArray array for each task that is referenced from
;;;3513   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3514   			meaning of each TaskStatus_t structure member. */
;;;3515   			do
00002e  bf00              NOP      
                  |L10.48|
;;;3516   			{
;;;3517   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
000030  4620              MOV      r0,r4
000032  6841              LDR      r1,[r0,#4]
000034  6849              LDR      r1,[r1,#4]
000036  6041              STR      r1,[r0,#4]
000038  f1000108          ADD      r1,r0,#8
00003c  6842              LDR      r2,[r0,#4]
00003e  428a              CMP      r2,r1
000040  d102              BNE      |L10.72|
000042  6841              LDR      r1,[r0,#4]
000044  6849              LDR      r1,[r1,#4]
000046  6041              STR      r1,[r0,#4]
                  |L10.72|
000048  6841              LDR      r1,[r0,#4]
00004a  68cd              LDR      r5,[r1,#0xc]
;;;3518   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
00004c  eb0600c6          ADD      r0,r6,r6,LSL #3
000050  eb070180          ADD      r1,r7,r0,LSL #2
000054  4643              MOV      r3,r8
000056  2201              MOVS     r2,#1
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       vTaskGetInfo
;;;3519   				uxTask++;
00005e  1c76              ADDS     r6,r6,#1
;;;3520   			} while( pxNextTCB != pxFirstTCB );
000060  454d              CMP      r5,r9
000062  d1e5              BNE      |L10.48|
                  |L10.100|
;;;3521   		}
;;;3522   		else
;;;3523   		{
;;;3524   			mtCOVERAGE_TEST_MARKER();
;;;3525   		}
;;;3526   
;;;3527   		return uxTask;
000064  4630              MOV      r0,r6
;;;3528   	}
000066  e8bd87f0          POP      {r4-r10,pc}
;;;3529   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3636   
;;;3637   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L11.44|
;;;3638   {
;;;3639   TCB_t *pxTCB;
;;;3640   
;;;3641   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L11.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  2100              MOVS     r1,#0
                  |L11.14|
00000e  b121              CBZ      r1,|L11.26|
;;;3642   	{
;;;3643   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3644   		the maximum possible value so it is	extremely unlikely that the
;;;3645   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3646   		there is an item in the delayed list. */
;;;3647   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L11.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L11.40|
                  |L11.26|
;;;3648   	}
;;;3649   	else
;;;3650   	{
;;;3651   		/* The new current delayed list is not empty, get the value of
;;;3652   		the item at the head of the delayed list.  This is the time at
;;;3653   		which the task at the head of the delayed list should be removed
;;;3654   		from the Blocked state. */
;;;3655   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00001a  4904              LDR      r1,|L11.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3656   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000022  4a03              LDR      r2,|L11.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L11.40|
;;;3657   	}
;;;3658   }
000028  4770              BX       lr
;;;3659   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      pxDelayedTaskList
                  |L11.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=1

                  prvTaskCheckFreeStackSpace PROC
;;;3534   
;;;3535   	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  4602              MOV      r2,r0
;;;3536   	{
;;;3537   	uint32_t ulCount = 0U;
000002  2100              MOVS     r1,#0
;;;3538   
;;;3539   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
000004  e001              B        |L12.10|
                  |L12.6|
;;;3540   		{
;;;3541   			pucStackByte -= portSTACK_GROWTH;
000006  1c52              ADDS     r2,r2,#1
;;;3542   			ulCount++;
000008  1c49              ADDS     r1,r1,#1
                  |L12.10|
00000a  7810              LDRB     r0,[r2,#0]            ;3539
00000c  28a5              CMP      r0,#0xa5              ;3539
00000e  d0fa              BEQ      |L12.6|
;;;3543   		}
;;;3544   
;;;3545   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
000010  0889              LSRS     r1,r1,#2
;;;3546   
;;;3547   		return ( uint16_t ) ulCount;
000012  b288              UXTH     r0,r1
;;;3548   	}
000014  4770              BX       lr
;;;3549   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1657   
;;;1658   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1659   	{
000002  4602              MOV      r2,r0
;;;1660   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1661   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000006  4611              MOV      r1,r2
;;;1662   
;;;1663   		/* Accesses xPendingReadyList so must be called from a critical
;;;1664   		section. */
;;;1665   
;;;1666   		/* It does not make sense to check if the calling task is suspended. */
;;;1667   		configASSERT( xTask );
000008  b952              CBNZ     r2,|L13.32|
00000a  bf00              NOP      
00000c  2330              MOVS     r3,#0x30
00000e  f3838811          MSR      BASEPRI,r3
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L13.30|
00001e  e7fe              B        |L13.30|
                  |L13.32|
;;;1668   
;;;1669   		/* Is the task being resumed actually in the suspended list? */
;;;1670   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000020  4c0b              LDR      r4,|L13.80|
000022  694b              LDR      r3,[r1,#0x14]
000024  42a3              CMP      r3,r4
000026  d101              BNE      |L13.44|
000028  2301              MOVS     r3,#1
00002a  e000              B        |L13.46|
                  |L13.44|
00002c  2300              MOVS     r3,#0
                  |L13.46|
00002e  b173              CBZ      r3,|L13.78|
;;;1671   		{
;;;1672   			/* Has the task already been resumed from within an ISR? */
;;;1673   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000030  4c08              LDR      r4,|L13.84|
000032  6a8b              LDR      r3,[r1,#0x28]
000034  42a3              CMP      r3,r4
000036  d101              BNE      |L13.60|
000038  2301              MOVS     r3,#1
00003a  e000              B        |L13.62|
                  |L13.60|
00003c  2300              MOVS     r3,#0
                  |L13.62|
00003e  b933              CBNZ     r3,|L13.78|
;;;1674   			{
;;;1675   				/* Is it in the suspended list because it is in the	Suspended
;;;1676   				state, or because is is blocked with no timeout? */
;;;1677   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000040  6a8b              LDR      r3,[r1,#0x28]
000042  b90b              CBNZ     r3,|L13.72|
000044  2301              MOVS     r3,#1
000046  e000              B        |L13.74|
                  |L13.72|
000048  2300              MOVS     r3,#0
                  |L13.74|
00004a  b103              CBZ      r3,|L13.78|
;;;1678   				{
;;;1679   					xReturn = pdTRUE;
00004c  2001              MOVS     r0,#1
                  |L13.78|
;;;1680   				}
;;;1681   				else
;;;1682   				{
;;;1683   					mtCOVERAGE_TEST_MARKER();
;;;1684   				}
;;;1685   			}
;;;1686   			else
;;;1687   			{
;;;1688   				mtCOVERAGE_TEST_MARKER();
;;;1689   			}
;;;1690   		}
;;;1691   		else
;;;1692   		{
;;;1693   			mtCOVERAGE_TEST_MARKER();
;;;1694   		}
;;;1695   
;;;1696   		return xReturn;
;;;1697   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00004e  bd10              POP      {r4,pc}
;;;1698   
                          ENDP

                  |L13.80|
                          DCD      xSuspendedTaskList
                  |L13.84|
                          DCD      xPendingReadyList

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4179   
;;;4180   	void *pvTaskIncrementMutexHeldCount( void )
000000  4806              LDR      r0,|L14.28|
;;;4181   	{
;;;4182   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4183   		then pxCurrentTCB will be NULL. */
;;;4184   		if( pxCurrentTCB != NULL )
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000004  b130              CBZ      r0,|L14.20|
;;;4185   		{
;;;4186   			( pxCurrentTCB->uxMutexesHeld )++;
000006  4905              LDR      r1,|L14.28|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  f1010050          ADD      r0,r1,#0x50
00000e  6d09              LDR      r1,[r1,#0x50]
000010  1c49              ADDS     r1,r1,#1
000012  6001              STR      r1,[r0,#0]
                  |L14.20|
;;;4187   		}
;;;4188   
;;;4189   		return pxCurrentTCB;
000014  4801              LDR      r0,|L14.28|
000016  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;4190   	}
000018  4770              BX       lr
;;;4191   
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      pxCurrentTCB

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4196   
;;;4197   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4198   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4199   	uint32_t ulReturn;
;;;4200   
;;;4201   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4202   		{
;;;4203   			/* Only block if the notification count is not already non-zero. */
;;;4204   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4818              LDR      r0,|L15.108|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  6d40              LDR      r0,[r0,#0x54]
000010  b988              CBNZ     r0,|L15.54|
;;;4205   			{
;;;4206   				/* Mark this task as waiting for a notification. */
;;;4207   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  2001              MOVS     r0,#1
000014  4915              LDR      r1,|L15.108|
000016  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000018  f8810058          STRB     r0,[r1,#0x58]
;;;4208   
;;;4209   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b15d              CBZ      r5,|L15.54|
;;;4210   				{
;;;4211   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4212   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4213   
;;;4214   					/* All ports are written to allow a yield in a critical
;;;4215   					section (some will yield immediately, others wait until the
;;;4216   					critical section exits) - but it is not something that
;;;4217   					application code should ever do. */
;;;4218   					portYIELD_WITHIN_API();
000026  f04f5080          MOV      r0,#0x10000000
00002a  4911              LDR      r1,|L15.112|
00002c  6008              STR      r0,[r1,#0]
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L15.54|
;;;4219   				}
;;;4220   				else
;;;4221   				{
;;;4222   					mtCOVERAGE_TEST_MARKER();
;;;4223   				}
;;;4224   			}
;;;4225   			else
;;;4226   			{
;;;4227   				mtCOVERAGE_TEST_MARKER();
;;;4228   			}
;;;4229   		}
;;;4230   		taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;4231   
;;;4232   		taskENTER_CRITICAL();
00003a  f7fffffe          BL       vPortEnterCritical
;;;4233   		{
;;;4234   			traceTASK_NOTIFY_TAKE();
;;;4235   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003e  480b              LDR      r0,|L15.108|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  6d44              LDR      r4,[r0,#0x54]
;;;4236   
;;;4237   			if( ulReturn != 0UL )
000044  b14c              CBZ      r4,|L15.90|
;;;4238   			{
;;;4239   				if( xClearCountOnExit != pdFALSE )
000046  b126              CBZ      r6,|L15.82|
;;;4240   				{
;;;4241   					pxCurrentTCB->ulNotifiedValue = 0UL;
000048  2000              MOVS     r0,#0
00004a  4908              LDR      r1,|L15.108|
00004c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004e  6548              STR      r0,[r1,#0x54]
000050  e003              B        |L15.90|
                  |L15.82|
;;;4242   				}
;;;4243   				else
;;;4244   				{
;;;4245   					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
000052  1e60              SUBS     r0,r4,#1
000054  4905              LDR      r1,|L15.108|
000056  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000058  6548              STR      r0,[r1,#0x54]
                  |L15.90|
;;;4246   				}
;;;4247   			}
;;;4248   			else
;;;4249   			{
;;;4250   				mtCOVERAGE_TEST_MARKER();
;;;4251   			}
;;;4252   
;;;4253   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00005a  2000              MOVS     r0,#0
00005c  4903              LDR      r1,|L15.108|
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  f8810058          STRB     r0,[r1,#0x58]
;;;4254   		}
;;;4255   		taskEXIT_CRITICAL();
000064  f7fffffe          BL       vPortExitCritical
;;;4256   
;;;4257   		return ulReturn;
000068  4620              MOV      r0,r4
;;;4258   	}
00006a  bd70              POP      {r4-r6,pc}
;;;4259   
                          ENDP

                  |L15.108|
                          DCD      pxCurrentTCB
                  |L15.112|
                          DCD      0xe000ed04

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2174   
;;;2175   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L16.8|
;;;2176   {
;;;2177   	/* A critical section is not required because the variables are of type
;;;2178   	BaseType_t. */
;;;2179   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2180   }
000004  4770              BX       lr
;;;2181   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2322   
;;;2323   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2324   	{
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;2325   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
00000a  2400              MOVS     r4,#0
00000c  2707              MOVS     r7,#7
;;;2326   
;;;2327   		vTaskSuspendAll();
00000e  f7fffffe          BL       vTaskSuspendAll
;;;2328   		{
;;;2329   			/* Is there a space in the array for each task in the system? */
;;;2330   			if( uxArraySize >= uxCurrentNumberOfTasks )
000012  4821              LDR      r0,|L17.152|
000014  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000016  4580              CMP      r8,r0
000018  d339              BCC      |L17.142|
;;;2331   			{
;;;2332   				/* Fill in an TaskStatus_t structure with information on each
;;;2333   				task in the Ready state. */
;;;2334   				do
00001a  bf00              NOP      
                  |L17.28|
;;;2335   				{
;;;2336   					uxQueue--;
00001c  1e7f              SUBS     r7,r7,#1
;;;2337   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
00001e  eb070287          ADD      r2,r7,r7,LSL #2
000022  4b1e              LDR      r3,|L17.156|
000024  eb030182          ADD      r1,r3,r2,LSL #2
000028  eb0402c4          ADD      r2,r4,r4,LSL #3
00002c  eb050082          ADD      r0,r5,r2,LSL #2
000030  2201              MOVS     r2,#1
000032  f7fffffe          BL       prvListTasksWithinSingleList
000036  4404              ADD      r4,r4,r0
;;;2338   
;;;2339   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000038  2f00              CMP      r7,#0
00003a  d1ef              BNE      |L17.28|
;;;2340   
;;;2341   				/* Fill in an TaskStatus_t structure with information on each
;;;2342   				task in the Blocked state. */
;;;2343   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
00003c  eb0401c4          ADD      r1,r4,r4,LSL #3
000040  eb050081          ADD      r0,r5,r1,LSL #2
000044  2202              MOVS     r2,#2
000046  4916              LDR      r1,|L17.160|
000048  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00004a  f7fffffe          BL       prvListTasksWithinSingleList
00004e  4404              ADD      r4,r4,r0
;;;2344   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000050  eb0401c4          ADD      r1,r4,r4,LSL #3
000054  eb050081          ADD      r0,r5,r1,LSL #2
000058  2202              MOVS     r2,#2
00005a  4912              LDR      r1,|L17.164|
00005c  6809              LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
00005e  f7fffffe          BL       prvListTasksWithinSingleList
000062  4404              ADD      r4,r4,r0
;;;2345   
;;;2346   				#if( INCLUDE_vTaskDelete == 1 )
;;;2347   				{
;;;2348   					/* Fill in an TaskStatus_t structure with information on
;;;2349   					each task that has been deleted but not yet cleaned up. */
;;;2350   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000064  eb0401c4          ADD      r1,r4,r4,LSL #3
000068  eb050081          ADD      r0,r5,r1,LSL #2
00006c  2204              MOVS     r2,#4
00006e  490e              LDR      r1,|L17.168|
000070  f7fffffe          BL       prvListTasksWithinSingleList
000074  4404              ADD      r4,r4,r0
;;;2351   				}
;;;2352   				#endif
;;;2353   
;;;2354   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2355   				{
;;;2356   					/* Fill in an TaskStatus_t structure with information on
;;;2357   					each task in the Suspended state. */
;;;2358   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
000076  eb0401c4          ADD      r1,r4,r4,LSL #3
00007a  eb050081          ADD      r0,r5,r1,LSL #2
00007e  2203              MOVS     r2,#3
000080  490a              LDR      r1,|L17.172|
000082  f7fffffe          BL       prvListTasksWithinSingleList
000086  4404              ADD      r4,r4,r0
;;;2359   				}
;;;2360   				#endif
;;;2361   
;;;2362   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2363   				{
;;;2364   					if( pulTotalRunTime != NULL )
;;;2365   					{
;;;2366   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2367   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2368   						#else
;;;2369   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2370   						#endif
;;;2371   					}
;;;2372   				}
;;;2373   				#else
;;;2374   				{
;;;2375   					if( pulTotalRunTime != NULL )
000088  b10e              CBZ      r6,|L17.142|
;;;2376   					{
;;;2377   						*pulTotalRunTime = 0;
00008a  2000              MOVS     r0,#0
00008c  6030              STR      r0,[r6,#0]
                  |L17.142|
;;;2378   					}
;;;2379   				}
;;;2380   				#endif
;;;2381   			}
;;;2382   			else
;;;2383   			{
;;;2384   				mtCOVERAGE_TEST_MARKER();
;;;2385   			}
;;;2386   		}
;;;2387   		( void ) xTaskResumeAll();
00008e  f7fffffe          BL       xTaskResumeAll
;;;2388   
;;;2389   		return uxTask;
000092  4620              MOV      r0,r4
;;;2390   	}
000094  e8bd81f0          POP      {r4-r8,pc}
;;;2391   
                          ENDP

                  |L17.152|
                          DCD      uxCurrentNumberOfTasks
                  |L17.156|
                          DCD      pxReadyTasksLists
                  |L17.160|
                          DCD      pxDelayedTaskList
                  |L17.164|
                          DCD      pxOverflowDelayedTaskList
                  |L17.168|
                          DCD      xTasksWaitingTermination
                  |L17.172|
                          DCD      xSuspendedTaskList

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=1

                  uxTaskGetTaskNumber PROC
;;;3085   
;;;3086   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  4601              MOV      r1,r0
;;;3087   	{
;;;3088   	UBaseType_t uxReturn;
;;;3089   	TCB_t *pxTCB;
;;;3090   
;;;3091   		if( xTask != NULL )
000002  b111              CBZ      r1,|L18.10|
;;;3092   		{
;;;3093   			pxTCB = ( TCB_t * ) xTask;
000004  460a              MOV      r2,r1
;;;3094   			uxReturn = pxTCB->uxTaskNumber;
000006  6c90              LDR      r0,[r2,#0x48]
000008  e000              B        |L18.12|
                  |L18.10|
;;;3095   		}
;;;3096   		else
;;;3097   		{
;;;3098   			uxReturn = 0U;
00000a  2000              MOVS     r0,#0
                  |L18.12|
;;;3099   		}
;;;3100   
;;;3101   		return uxReturn;
;;;3102   	}
00000c  4770              BX       lr
;;;3103   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1341   
;;;1342   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1343   	{
000002  4604              MOV      r4,r0
;;;1344   	TCB_t *pxTCB;
;;;1345   	UBaseType_t uxReturn;
;;;1346   
;;;1347   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1348   		{
;;;1349   			/* If null is passed in here then it is the priority of the that
;;;1350   			called uxTaskPriorityGet() that is being queried. */
;;;1351   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L19.16|
00000a  4805              LDR      r0,|L19.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L19.18|
                  |L19.16|
000010  4620              MOV      r0,r4
                  |L19.18|
000012  4606              MOV      r6,r0
;;;1352   			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;1353   		}
;;;1354   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1355   
;;;1356   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1357   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1358   
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1363   
;;;1364   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1365   	{
000004  4605              MOV      r5,r0
;;;1366   	TCB_t *pxTCB;
;;;1367   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1368   
;;;1369   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1370   		maximum	system call (or maximum API call) interrupt priority.
;;;1371   		Interrupts that are	above the maximum system call priority are keep
;;;1372   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1373   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1374   		is defined in FreeRTOSConfig.h then
;;;1375   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1376   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1377   		been assigned a priority above the configured maximum system call
;;;1378   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1379   		from interrupts	that have been assigned a priority at or (logically)
;;;1380   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1381   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1382   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1383   		provided on the following link:
;;;1384   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1385   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000006  f7fffffe          BL       vPortValidateInterruptPriority
;;;1386   
;;;1387   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  2130              MOVS     r1,#0x30
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4604              MOV      r4,r0
;;;1388   		{
;;;1389   			/* If null is passed in here then it is the priority of the calling
;;;1390   			task that is being queried. */
;;;1391   			pxTCB = prvGetTCBFromHandle( xTask );
000022  b915              CBNZ     r5,|L20.42|
000024  4806              LDR      r0,|L20.64|
000026  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000028  e000              B        |L20.44|
                  |L20.42|
00002a  4628              MOV      r0,r5
                  |L20.44|
00002c  4607              MOV      r7,r0
;;;1392   			uxReturn = pxTCB->uxPriority;
00002e  6afe              LDR      r6,[r7,#0x2c]
;;;1393   		}
;;;1394   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000030  bf00              NOP      
000032  f3848811          MSR      BASEPRI,r4
000036  bf00              NOP      
;;;1395   
;;;1396   		return uxReturn;
000038  4630              MOV      r0,r6
;;;1397   	}
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1398   
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4163   
;;;4164   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L21.24|
;;;4165   {
;;;4166   TickType_t uxReturn;
;;;4167   
;;;4168   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;4169   
;;;4170   	/* Reset the event list item to its normal value - so it can be used with
;;;4171   	queues and semaphores. */
;;;4172   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L21.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10107          RSB      r1,r1,#7
000010  4a01              LDR      r2,|L21.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;4173   
;;;4174   	return uxReturn;
;;;4175   }
000016  4770              BX       lr
;;;4176   /*-----------------------------------------------------------*/
                          ENDP

                  |L21.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1225   
;;;1226   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;1227   	{
000002  4604              MOV      r4,r0
;;;1228   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1229   
;;;1230   		/* A delay time of zero just forces a reschedule. */
;;;1231   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b1d4              CBZ      r4,|L22.62|
;;;1232   		{
;;;1233   			configASSERT( uxSchedulerSuspended == 0 );
000008  4812              LDR      r0,|L22.84|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b908              CBNZ     r0,|L22.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L22.20|
                  |L22.18|
000012  2000              MOVS     r0,#0
                  |L22.20|
000014  b950              CBNZ     r0,|L22.44|
000016  bf00              NOP      
000018  2030              MOVS     r0,#0x30
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L22.42|
00002a  e7fe              B        |L22.42|
                  |L22.44|
;;;1234   			vTaskSuspendAll();
00002c  f7fffffe          BL       vTaskSuspendAll
;;;1235   			{
;;;1236   				traceTASK_DELAY();
;;;1237   
;;;1238   				/* A task that is removed from the event list while the
;;;1239   				scheduler is suspended will not get placed in the ready
;;;1240   				list or removed from the blocked list until the scheduler
;;;1241   				is resumed.
;;;1242   
;;;1243   				This task cannot be in an event list as it is the currently
;;;1244   				executing task. */
;;;1245   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1246   			}
;;;1247   			xAlreadyYielded = xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
00003c  4605              MOV      r5,r0
                  |L22.62|
;;;1248   		}
;;;1249   		else
;;;1250   		{
;;;1251   			mtCOVERAGE_TEST_MARKER();
;;;1252   		}
;;;1253   
;;;1254   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1255   		have put ourselves to sleep. */
;;;1256   		if( xAlreadyYielded == pdFALSE )
00003e  b93d              CBNZ     r5,|L22.80|
;;;1257   		{
;;;1258   			portYIELD_WITHIN_API();
000040  f04f5080          MOV      r0,#0x10000000
000044  4904              LDR      r1,|L22.88|
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
                  |L22.80|
;;;1259   		}
;;;1260   		else
;;;1261   		{
;;;1262   			mtCOVERAGE_TEST_MARKER();
;;;1263   		}
;;;1264   	}
000050  bd70              POP      {r4-r6,pc}
;;;1265   
                          ENDP

000052  0000              DCW      0x0000
                  |L22.84|
                          DCD      uxSchedulerSuspended
                  |L22.88|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1141   
;;;1142   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1143   	{
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1144   	TickType_t xTimeToWake;
;;;1145   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1146   
;;;1147   		configASSERT( pxPreviousWakeTime );
00000c  b954              CBNZ     r4,|L23.36|
00000e  bf00              NOP      
000010  2030              MOVS     r0,#0x30
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L23.34|
000022  e7fe              B        |L23.34|
                  |L23.36|
;;;1148   		configASSERT( ( xTimeIncrement > 0U ) );
000024  b10f              CBZ      r7,|L23.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L23.44|
                  |L23.42|
00002a  2000              MOVS     r0,#0
                  |L23.44|
00002c  b950              CBNZ     r0,|L23.68|
00002e  bf00              NOP      
000030  2030              MOVS     r0,#0x30
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L23.66|
000042  e7fe              B        |L23.66|
                  |L23.68|
;;;1149   		configASSERT( uxSchedulerSuspended == 0 );
000044  4820              LDR      r0,|L23.200|
000046  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000048  b908              CBNZ     r0,|L23.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L23.80|
                  |L23.78|
00004e  2000              MOVS     r0,#0
                  |L23.80|
000050  b950              CBNZ     r0,|L23.104|
000052  bf00              NOP      
000054  2030              MOVS     r0,#0x30
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  bf00              NOP      
000064  bf00              NOP      
                  |L23.102|
000066  e7fe              B        |L23.102|
                  |L23.104|
;;;1150   
;;;1151   		vTaskSuspendAll();
000068  f7fffffe          BL       vTaskSuspendAll
;;;1152   		{
;;;1153   			/* Minor optimisation.  The tick count cannot change in this
;;;1154   			block. */
;;;1155   			const TickType_t xConstTickCount = xTickCount;
00006c  4817              LDR      r0,|L23.204|
00006e  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1156   
;;;1157   			/* Generate the tick time at which the task wants to wake. */
;;;1158   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000070  6820              LDR      r0,[r4,#0]
000072  19c5              ADDS     r5,r0,r7
;;;1159   
;;;1160   			if( xConstTickCount < *pxPreviousWakeTime )
000074  6820              LDR      r0,[r4,#0]
000076  42b0              CMP      r0,r6
000078  d907              BLS      |L23.138|
;;;1161   			{
;;;1162   				/* The tick count has overflowed since this function was
;;;1163   				lasted called.  In this case the only time we should ever
;;;1164   				actually delay is if the wake time has also	overflowed,
;;;1165   				and the wake time is greater than the tick time.  When this
;;;1166   				is the case it is as if neither time had overflowed. */
;;;1167   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
00007a  6820              LDR      r0,[r4,#0]
00007c  42a8              CMP      r0,r5
00007e  d90b              BLS      |L23.152|
000080  42b5              CMP      r5,r6
000082  d909              BLS      |L23.152|
;;;1168   				{
;;;1169   					xShouldDelay = pdTRUE;
000084  f04f0901          MOV      r9,#1
000088  e006              B        |L23.152|
                  |L23.138|
;;;1170   				}
;;;1171   				else
;;;1172   				{
;;;1173   					mtCOVERAGE_TEST_MARKER();
;;;1174   				}
;;;1175   			}
;;;1176   			else
;;;1177   			{
;;;1178   				/* The tick time has not overflowed.  In this case we will
;;;1179   				delay if either the wake time has overflowed, and/or the
;;;1180   				tick time is less than the wake time. */
;;;1181   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00008a  6820              LDR      r0,[r4,#0]
00008c  42a8              CMP      r0,r5
00008e  d801              BHI      |L23.148|
000090  42b5              CMP      r5,r6
000092  d901              BLS      |L23.152|
                  |L23.148|
;;;1182   				{
;;;1183   					xShouldDelay = pdTRUE;
000094  f04f0901          MOV      r9,#1
                  |L23.152|
;;;1184   				}
;;;1185   				else
;;;1186   				{
;;;1187   					mtCOVERAGE_TEST_MARKER();
;;;1188   				}
;;;1189   			}
;;;1190   
;;;1191   			/* Update the wake time ready for the next call. */
;;;1192   			*pxPreviousWakeTime = xTimeToWake;
000098  6025              STR      r5,[r4,#0]
;;;1193   
;;;1194   			if( xShouldDelay != pdFALSE )
00009a  f1b90f00          CMP      r9,#0
00009e  d003              BEQ      |L23.168|
;;;1195   			{
;;;1196   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1197   
;;;1198   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1199   				the time to wake, so subtract the current tick count. */
;;;1200   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
0000a0  1ba8              SUBS     r0,r5,r6
0000a2  2100              MOVS     r1,#0
0000a4  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L23.168|
;;;1201   			}
;;;1202   			else
;;;1203   			{
;;;1204   				mtCOVERAGE_TEST_MARKER();
;;;1205   			}
;;;1206   		}
;;;1207   		xAlreadyYielded = xTaskResumeAll();
0000a8  f7fffffe          BL       xTaskResumeAll
0000ac  4680              MOV      r8,r0
;;;1208   
;;;1209   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1210   		have put ourselves to sleep. */
;;;1211   		if( xAlreadyYielded == pdFALSE )
0000ae  f1b80f00          CMP      r8,#0
0000b2  d107              BNE      |L23.196|
;;;1212   		{
;;;1213   			portYIELD_WITHIN_API();
0000b4  f04f5080          MOV      r0,#0x10000000
0000b8  4905              LDR      r1,|L23.208|
0000ba  6008              STR      r0,[r1,#0]
0000bc  f3bf8f4f          DSB      
0000c0  f3bf8f6f          ISB      
                  |L23.196|
;;;1214   		}
;;;1215   		else
;;;1216   		{
;;;1217   			mtCOVERAGE_TEST_MARKER();
;;;1218   		}
;;;1219   	}
0000c4  e8bd87f0          POP      {r4-r10,pc}
;;;1220   
                          ENDP

                  |L23.200|
                          DCD      uxSchedulerSuspended
                  |L23.204|
                          DCD      xTickCount
                  |L23.208|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1049   
;;;1050   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1051   	{
000002  4605              MOV      r5,r0
;;;1052   	TCB_t *pxTCB;
;;;1053   
;;;1054   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1055   		{
;;;1056   			/* If null is passed in here then it is the calling task that is
;;;1057   			being deleted. */
;;;1058   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L24.16|
00000a  4830              LDR      r0,|L24.204|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L24.18|
                  |L24.16|
000010  4628              MOV      r0,r5
                  |L24.18|
000012  4604              MOV      r4,r0
;;;1059   
;;;1060   			/* Remove task from the ready list. */
;;;1061   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L24.60|
;;;1062   			{
;;;1063   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  492b              LDR      r1,|L24.208|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L24.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4928              LDR      r1,|L24.212|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  4826              LDR      r0,|L24.212|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L24.60|
;;;1064   			}
;;;1065   			else
;;;1066   			{
;;;1067   				mtCOVERAGE_TEST_MARKER();
;;;1068   			}
;;;1069   
;;;1070   			/* Is the task waiting on an event also? */
;;;1071   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L24.72|
;;;1072   			{
;;;1073   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L24.72|
;;;1074   			}
;;;1075   			else
;;;1076   			{
;;;1077   				mtCOVERAGE_TEST_MARKER();
;;;1078   			}
;;;1079   
;;;1080   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1081   			detect that the task lists need re-generating.  This is done before
;;;1082   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1083   			not return. */
;;;1084   			uxTaskNumber++;
000048  4823              LDR      r0,|L24.216|
00004a  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004c  1c40              ADDS     r0,r0,#1
00004e  4922              LDR      r1,|L24.216|
000050  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1085   
;;;1086   			if( pxTCB == pxCurrentTCB )
000052  481e              LDR      r0,|L24.204|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d109              BNE      |L24.110|
;;;1087   			{
;;;1088   				/* A task is deleting itself.  This cannot complete within the
;;;1089   				task itself, as a context switch to another task is required.
;;;1090   				Place the task in the termination list.  The idle task will
;;;1091   				check the termination list and free up any memory allocated by
;;;1092   				the scheduler for the TCB and stack of the deleted task. */
;;;1093   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
00005a  1d21              ADDS     r1,r4,#4
00005c  481f              LDR      r0,|L24.220|
00005e  f7fffffe          BL       vListInsertEnd
;;;1094   
;;;1095   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1096   				there is a task that has been deleted and that it should therefore
;;;1097   				check the xTasksWaitingTermination list. */
;;;1098   				++uxDeletedTasksWaitingCleanUp;
000062  481f              LDR      r0,|L24.224|
000064  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000066  1c40              ADDS     r0,r0,#1
000068  491d              LDR      r1,|L24.224|
00006a  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
00006c  e009              B        |L24.130|
                  |L24.110|
;;;1099   
;;;1100   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1101   				in which Windows specific clean up operations are performed,
;;;1102   				after which it is not possible to yield away from this task -
;;;1103   				hence xYieldPending is used to latch that a context switch is
;;;1104   				required. */
;;;1105   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1106   			}
;;;1107   			else
;;;1108   			{
;;;1109   				--uxCurrentNumberOfTasks;
00006e  481d              LDR      r0,|L24.228|
000070  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000072  1e40              SUBS     r0,r0,#1
000074  491b              LDR      r1,|L24.228|
000076  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1110   				prvDeleteTCB( pxTCB );
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       prvDeleteTCB
;;;1111   
;;;1112   				/* Reset the next expected unblock time in case it referred to
;;;1113   				the task that has just been deleted. */
;;;1114   				prvResetNextTaskUnblockTime();
00007e  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L24.130|
;;;1115   			}
;;;1116   
;;;1117   			traceTASK_DELETE( pxTCB );
;;;1118   		}
;;;1119   		taskEXIT_CRITICAL();
000082  f7fffffe          BL       vPortExitCritical
;;;1120   
;;;1121   		/* Force a reschedule if it is the currently running task that has just
;;;1122   		been deleted. */
;;;1123   		if( xSchedulerRunning != pdFALSE )
000086  4818              LDR      r0,|L24.232|
000088  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00008a  b1e8              CBZ      r0,|L24.200|
;;;1124   		{
;;;1125   			if( pxTCB == pxCurrentTCB )
00008c  480f              LDR      r0,|L24.204|
00008e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000090  4284              CMP      r4,r0
000092  d119              BNE      |L24.200|
;;;1126   			{
;;;1127   				configASSERT( uxSchedulerSuspended == 0 );
000094  4815              LDR      r0,|L24.236|
000096  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000098  b908              CBNZ     r0,|L24.158|
00009a  2001              MOVS     r0,#1
00009c  e000              B        |L24.160|
                  |L24.158|
00009e  2000              MOVS     r0,#0
                  |L24.160|
0000a0  b950              CBNZ     r0,|L24.184|
0000a2  bf00              NOP      
0000a4  2030              MOVS     r0,#0x30
0000a6  f3808811          MSR      BASEPRI,r0
0000aa  f3bf8f4f          DSB      
0000ae  f3bf8f6f          ISB      
0000b2  bf00              NOP      
0000b4  bf00              NOP      
                  |L24.182|
0000b6  e7fe              B        |L24.182|
                  |L24.184|
;;;1128   				portYIELD_WITHIN_API();
0000b8  f04f5080          MOV      r0,#0x10000000
0000bc  490c              LDR      r1,|L24.240|
0000be  6008              STR      r0,[r1,#0]
0000c0  f3bf8f4f          DSB      
0000c4  f3bf8f6f          ISB      
                  |L24.200|
;;;1129   			}
;;;1130   			else
;;;1131   			{
;;;1132   				mtCOVERAGE_TEST_MARKER();
;;;1133   			}
;;;1134   		}
;;;1135   	}
0000c8  bd70              POP      {r4-r6,pc}
;;;1136   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L24.204|
                          DCD      pxCurrentTCB
                  |L24.208|
                          DCD      pxReadyTasksLists
                  |L24.212|
                          DCD      uxTopReadyPriority
                  |L24.216|
                          DCD      uxTaskNumber
                  |L24.220|
                          DCD      xTasksWaitingTermination
                  |L24.224|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L24.228|
                          DCD      uxCurrentNumberOfTasks
                  |L24.232|
                          DCD      xSchedulerRunning
                  |L24.236|
                          DCD      uxSchedulerSuspended
                  |L24.240|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1934   
;;;1935   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1936   {
;;;1937   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1938   	routine so the original ISRs can be restored if necessary.  The port
;;;1939   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1940   	portDISABLE_INTERRUPTS();
000002  bf00              NOP      
000004  2030              MOVS     r0,#0x30
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;1941   	xSchedulerRunning = pdFALSE;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L25.32|
000018  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1942   	vPortEndScheduler();
00001a  f7fffffe          BL       vPortEndScheduler
;;;1943   }
00001e  bd10              POP      {r4,pc}
;;;1944   /*----------------------------------------------------------*/
                          ENDP

                  |L25.32|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3412   
;;;3413   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3414   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3415   	TCB_t *pxTCB;
;;;3416   
;;;3417   		/* xTask is NULL then get the state of the calling task. */
;;;3418   		pxTCB = prvGetTCBFromHandle( xTask );
00000c  b917              CBNZ     r7,|L26.20|
00000e  4819              LDR      r0,|L26.116|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000012  e000              B        |L26.22|
                  |L26.20|
000014  4638              MOV      r0,r7
                  |L26.22|
000016  4605              MOV      r5,r0
;;;3419   
;;;3420   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
000018  6025              STR      r5,[r4,#0]
;;;3421   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
00001a  f1050034          ADD      r0,r5,#0x34
00001e  6060              STR      r0,[r4,#4]
;;;3422   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
000020  6ae8              LDR      r0,[r5,#0x2c]
000022  6120              STR      r0,[r4,#0x10]
;;;3423   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000024  6b28              LDR      r0,[r5,#0x30]
000026  61e0              STR      r0,[r4,#0x1c]
;;;3424   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
000028  6c68              LDR      r0,[r5,#0x44]
00002a  60a0              STR      r0,[r4,#8]
;;;3425   
;;;3426   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3427   		{
;;;3428   			/* If the task is in the suspended list then there is a chance it is
;;;3429   			actually just blocked indefinitely - so really it should be reported as
;;;3430   			being in the Blocked state. */
;;;3431   			if( pxTaskStatus->eCurrentState == eSuspended )
00002c  7b20              LDRB     r0,[r4,#0xc]
00002e  2803              CMP      r0,#3
000030  d107              BNE      |L26.66|
;;;3432   			{
;;;3433   				vTaskSuspendAll();
000032  f7fffffe          BL       vTaskSuspendAll
;;;3434   				{
;;;3435   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000036  6aa8              LDR      r0,[r5,#0x28]
000038  b108              CBZ      r0,|L26.62|
;;;3436   					{
;;;3437   						pxTaskStatus->eCurrentState = eBlocked;
00003a  2002              MOVS     r0,#2
00003c  7320              STRB     r0,[r4,#0xc]
                  |L26.62|
;;;3438   					}
;;;3439   				}
;;;3440   				xTaskResumeAll();
00003e  f7fffffe          BL       xTaskResumeAll
                  |L26.66|
;;;3441   			}
;;;3442   		}
;;;3443   		#endif /* INCLUDE_vTaskSuspend */
;;;3444   
;;;3445   		#if ( configUSE_MUTEXES == 1 )
;;;3446   		{
;;;3447   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
000042  6ce8              LDR      r0,[r5,#0x4c]
000044  6160              STR      r0,[r4,#0x14]
;;;3448   		}
;;;3449   		#else
;;;3450   		{
;;;3451   			pxTaskStatus->uxBasePriority = 0;
;;;3452   		}
;;;3453   		#endif
;;;3454   
;;;3455   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3456   		{
;;;3457   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
;;;3458   		}
;;;3459   		#else
;;;3460   		{
;;;3461   			pxTaskStatus->ulRunTimeCounter = 0;
000046  2000              MOVS     r0,#0
000048  61a0              STR      r0,[r4,#0x18]
;;;3462   		}
;;;3463   		#endif
;;;3464   
;;;3465   		/* Obtaining the task state is a little fiddly, so is only done if the value
;;;3466   		of eState passed into this function is eInvalid - otherwise the state is
;;;3467   		just set to whatever is passed in. */
;;;3468   		if( eState != eInvalid )
00004a  2e05              CMP      r6,#5
00004c  d001              BEQ      |L26.82|
;;;3469   		{
;;;3470   			pxTaskStatus->eCurrentState = eState;
00004e  7326              STRB     r6,[r4,#0xc]
000050  e003              B        |L26.90|
                  |L26.82|
;;;3471   		}
;;;3472   		else
;;;3473   		{
;;;3474   			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       eTaskGetState
000058  7320              STRB     r0,[r4,#0xc]
                  |L26.90|
;;;3475   		}
;;;3476   
;;;3477   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3478   		parameter is provided to allow it to be skipped. */
;;;3479   		if( xGetFreeStackSpace != pdFALSE )
00005a  f1b80f00          CMP      r8,#0
00005e  d004              BEQ      |L26.106|
;;;3480   		{
;;;3481   			#if ( portSTACK_GROWTH > 0 )
;;;3482   			{
;;;3483   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3484   			}
;;;3485   			#else
;;;3486   			{
;;;3487   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
000060  6b28              LDR      r0,[r5,#0x30]
000062  f7fffffe          BL       prvTaskCheckFreeStackSpace
000066  8420              STRH     r0,[r4,#0x20]
000068  e001              B        |L26.110|
                  |L26.106|
;;;3488   			}
;;;3489   			#endif
;;;3490   		}
;;;3491   		else
;;;3492   		{
;;;3493   			pxTaskStatus->usStackHighWaterMark = 0;
00006a  2000              MOVS     r0,#0
00006c  8420              STRH     r0,[r4,#0x20]
                  |L26.110|
;;;3494   		}
;;;3495   	}
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;3496   
                          ENDP

000072  0000              DCW      0x0000
                  |L26.116|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3077   
;;;3078   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;3079   {
;;;3080   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L27.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3081   }
000006  4770              BX       lr
;;;3082   /*-----------------------------------------------------------*/
                          ENDP

                  |L27.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4574   
;;;4575   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4576   	{
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;4577   	TCB_t * pxTCB;
;;;4578   	uint8_t ucOriginalNotifyState;
;;;4579   	UBaseType_t uxSavedInterruptStatus;
;;;4580   
;;;4581   		configASSERT( xTaskToNotify );
000008  b955              CBNZ     r5,|L28.32|
00000a  bf00              NOP      
00000c  2030              MOVS     r0,#0x30
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L28.30|
00001e  e7fe              B        |L28.30|
                  |L28.32|
;;;4582   
;;;4583   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4584   		maximum	system call (or maximum API call) interrupt priority.
;;;4585   		Interrupts that are	above the maximum system call priority are keep
;;;4586   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4587   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4588   		is defined in FreeRTOSConfig.h then
;;;4589   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4590   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4591   		been assigned a priority above the configured maximum system call
;;;4592   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4593   		from interrupts	that have been assigned a priority at or (logically)
;;;4594   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4595   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4596   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4597   		provided on the following link:
;;;4598   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4599   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000020  f7fffffe          BL       vPortValidateInterruptPriority
;;;4600   
;;;4601   		pxTCB = ( TCB_t * ) xTaskToNotify;
000024  462c              MOV      r4,r5
;;;4602   
;;;4603   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  bf00              NOP      
000028  2130              MOVS     r1,#0x30
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  f3818811          MSR      BASEPRI,r1
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  4606              MOV      r6,r0
;;;4604   		{
;;;4605   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00003e  f8948058          LDRB     r8,[r4,#0x58]
;;;4606   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000042  2002              MOVS     r0,#2
000044  f8840058          STRB     r0,[r4,#0x58]
;;;4607   
;;;4608   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4609   			semaphore. */
;;;4610   			( pxTCB->ulNotifiedValue )++;
000048  6d60              LDR      r0,[r4,#0x54]
00004a  1c40              ADDS     r0,r0,#1
00004c  6560              STR      r0,[r4,#0x54]
;;;4611   
;;;4612   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4613   
;;;4614   			/* If the task is in the blocked state specifically to wait for a
;;;4615   			notification then unblock it now. */
;;;4616   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00004e  f1b80f01          CMP      r8,#1
000052  d13b              BNE      |L28.204|
;;;4617   			{
;;;4618   				/* The task should not have been on an event list. */
;;;4619   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000054  6aa0              LDR      r0,[r4,#0x28]
000056  b908              CBNZ     r0,|L28.92|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L28.94|
                  |L28.92|
00005c  2000              MOVS     r0,#0
                  |L28.94|
00005e  b950              CBNZ     r0,|L28.118|
000060  bf00              NOP      
000062  2030              MOVS     r0,#0x30
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L28.116|
000074  e7fe              B        |L28.116|
                  |L28.118|
;;;4620   
;;;4621   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000076  4818              LDR      r0,|L28.216|
000078  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00007a  b9a8              CBNZ     r0,|L28.168|
;;;4622   				{
;;;4623   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00007c  1d20              ADDS     r0,r4,#4
00007e  f7fffffe          BL       uxListRemove
;;;4624   					prvAddTaskToReadyList( pxTCB );
000082  f894102c          LDRB     r1,[r4,#0x2c]
000086  2001              MOVS     r0,#1
000088  4088              LSLS     r0,r0,r1
00008a  4914              LDR      r1,|L28.220|
00008c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00008e  4308              ORRS     r0,r0,r1
000090  4912              LDR      r1,|L28.220|
000092  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000094  6ae1              LDR      r1,[r4,#0x2c]
000096  eb010181          ADD      r1,r1,r1,LSL #2
00009a  4a11              LDR      r2,|L28.224|
00009c  eb020081          ADD      r0,r2,r1,LSL #2
0000a0  1d21              ADDS     r1,r4,#4
0000a2  f7fffffe          BL       vListInsertEnd
0000a6  e004              B        |L28.178|
                  |L28.168|
;;;4625   				}
;;;4626   				else
;;;4627   				{
;;;4628   					/* The delayed and ready lists cannot be accessed, so hold
;;;4629   					this task pending until the scheduler is resumed. */
;;;4630   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000a8  f1040118          ADD      r1,r4,#0x18
0000ac  480d              LDR      r0,|L28.228|
0000ae  f7fffffe          BL       vListInsertEnd
                  |L28.178|
;;;4631   				}
;;;4632   
;;;4633   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000b2  490d              LDR      r1,|L28.232|
0000b4  6ae0              LDR      r0,[r4,#0x2c]
0000b6  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000b8  6ac9              LDR      r1,[r1,#0x2c]
0000ba  4288              CMP      r0,r1
0000bc  d906              BLS      |L28.204|
;;;4634   				{
;;;4635   					/* The notified task has a priority above the currently
;;;4636   					executing task so a yield is required. */
;;;4637   					if( pxHigherPriorityTaskWoken != NULL )
0000be  b117              CBZ      r7,|L28.198|
;;;4638   					{
;;;4639   						*pxHigherPriorityTaskWoken = pdTRUE;
0000c0  2001              MOVS     r0,#1
0000c2  6038              STR      r0,[r7,#0]
0000c4  e002              B        |L28.204|
                  |L28.198|
;;;4640   					}
;;;4641   					else
;;;4642   					{
;;;4643   						/* Mark that a yield is pending in case the user is not
;;;4644   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4645   						safe FreeRTOS function. */
;;;4646   						xYieldPending = pdTRUE;
0000c6  2001              MOVS     r0,#1
0000c8  4908              LDR      r1,|L28.236|
0000ca  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L28.204|
;;;4647   					}
;;;4648   				}
;;;4649   				else
;;;4650   				{
;;;4651   					mtCOVERAGE_TEST_MARKER();
;;;4652   				}
;;;4653   			}
;;;4654   		}
;;;4655   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000cc  bf00              NOP      
0000ce  f3868811          MSR      BASEPRI,r6
0000d2  bf00              NOP      
;;;4656   	}
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;4657   
                          ENDP

                  |L28.216|
                          DCD      uxSchedulerSuspended
                  |L28.220|
                          DCD      uxTopReadyPriority
                  |L28.224|
                          DCD      pxReadyTasksLists
                  |L28.228|
                          DCD      xPendingReadyList
                  |L28.232|
                          DCD      pxCurrentTCB
                  |L28.236|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2821   
;;;2822   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2823   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2824   	configASSERT( pxEventList );
000006  b954              CBNZ     r4,|L29.30|
000008  bf00              NOP      
00000a  2030              MOVS     r0,#0x30
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L29.28|
00001c  e7fe              B        |L29.28|
                  |L29.30|
;;;2825   
;;;2826   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2827   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2828   
;;;2829   	/* Place the event list item of the TCB in the appropriate event list.
;;;2830   	This is placed in the list in priority order so the highest priority task
;;;2831   	is the first to be woken by the event.  The queue that contains the event
;;;2832   	list is locked, preventing simultaneous access from interrupts. */
;;;2833   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00001e  4805              LDR      r0,|L29.52|
000020  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000022  3118              ADDS     r1,r1,#0x18
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       vListInsert
;;;2834   
;;;2835   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2836   }
000032  bd70              POP      {r4-r6,pc}
;;;2837   /*-----------------------------------------------------------*/
                          ENDP

                  |L29.52|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;2864   
;;;2865   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;2866   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;2867   		configASSERT( pxEventList );
000008  b955              CBNZ     r5,|L30.32|
00000a  bf00              NOP      
00000c  2030              MOVS     r0,#0x30
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L30.30|
00001e  e7fe              B        |L30.30|
                  |L30.32|
;;;2868   
;;;2869   		/* This function should not be called by application code hence the
;;;2870   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2871   		designed for use by kernel code, and has special calling requirements -
;;;2872   		it should be called with the scheduler suspended. */
;;;2873   
;;;2874   
;;;2875   		/* Place the event list item of the TCB in the appropriate event list.
;;;2876   		In this case it is assume that this is the only task that is going to
;;;2877   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2878   		can be used in place of vListInsert. */
;;;2879   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000020  4806              LDR      r0,|L30.60|
000022  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000024  3118              ADDS     r1,r1,#0x18
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       vListInsertEnd
;;;2880   
;;;2881   		/* If the task should block indefinitely then set the block time to a
;;;2882   		value that will be recognised as an indefinite delay inside the
;;;2883   		prvAddCurrentTaskToDelayedList() function. */
;;;2884   		if( xWaitIndefinitely != pdFALSE )
00002c  b10c              CBZ      r4,|L30.50|
;;;2885   		{
;;;2886   			xTicksToWait = portMAX_DELAY;
00002e  f04f36ff          MOV      r6,#0xffffffff
                  |L30.50|
;;;2887   		}
;;;2888   
;;;2889   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;2890   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
000032  4621              MOV      r1,r4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2891   	}
00003a  bd70              POP      {r4-r6,pc}
;;;2892   
                          ENDP

                  |L30.60|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2838   
;;;2839   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2840   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2841   	configASSERT( pxEventList );
000008  b954              CBNZ     r4,|L31.32|
00000a  bf00              NOP      
00000c  2030              MOVS     r0,#0x30
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L31.30|
00001e  e7fe              B        |L31.30|
                  |L31.32|
;;;2842   
;;;2843   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2844   	the event groups implementation. */
;;;2845   	configASSERT( uxSchedulerSuspended != 0 );
000020  4810              LDR      r0,|L31.100|
000022  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000024  b108              CBZ      r0,|L31.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L31.44|
                  |L31.42|
00002a  2000              MOVS     r0,#0
                  |L31.44|
00002c  b950              CBNZ     r0,|L31.68|
00002e  bf00              NOP      
000030  2030              MOVS     r0,#0x30
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L31.66|
000042  e7fe              B        |L31.66|
                  |L31.68|
;;;2846   
;;;2847   	/* Store the item value in the event list item.  It is safe to access the
;;;2848   	event list item here as interrupts won't access the event list item of a
;;;2849   	task that is not in the Blocked state. */
;;;2850   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000044  f0454000          ORR      r0,r5,#0x80000000
000048  4907              LDR      r1,|L31.104|
00004a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004c  6188              STR      r0,[r1,#0x18]
;;;2851   
;;;2852   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2853   	list.  It is safe to access the event list here because it is part of an
;;;2854   	event group implementation - and interrupts don't access event groups
;;;2855   	directly (instead they access them indirectly by pending function calls to
;;;2856   	the task level). */
;;;2857   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00004e  4806              LDR      r0,|L31.104|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  3118              ADDS     r1,r1,#0x18
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       vListInsertEnd
;;;2858   
;;;2859   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00005a  2101              MOVS     r1,#1
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2860   }
000062  bd70              POP      {r4-r6,pc}
;;;2861   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.100|
                          DCD      uxSchedulerSuspended
                  |L31.104|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  vTaskPriorityInherit PROC
;;;3707   
;;;3708   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3709   	{
000002  4605              MOV      r5,r0
;;;3710   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3711   
;;;3712   		/* If the mutex was given back by an interrupt while the queue was
;;;3713   		locked then the mutex holder might now be NULL. */
;;;3714   		if( pxMutexHolder != NULL )
000006  2d00              CMP      r5,#0
000008  d04b              BEQ      |L32.162|
;;;3715   		{
;;;3716   			/* If the holder of the mutex has a priority below the priority of
;;;3717   			the task attempting to obtain the mutex then it will temporarily
;;;3718   			inherit the priority of the task attempting to obtain the mutex. */
;;;3719   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  4926              LDR      r1,|L32.164|
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000010  6ac9              LDR      r1,[r1,#0x2c]
000012  4288              CMP      r0,r1
000014  d245              BCS      |L32.162|
;;;3720   			{
;;;3721   				/* Adjust the mutex holder state to account for its new
;;;3722   				priority.  Only reset the event list item value if the value is
;;;3723   				not	being used for anything else. */
;;;3724   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0004000          AND      r0,r0,#0x80000000
00001c  b928              CBNZ     r0,|L32.42|
;;;3725   				{
;;;3726   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001e  4821              LDR      r0,|L32.164|
000020  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000022  6ac0              LDR      r0,[r0,#0x2c]
000024  f1c00007          RSB      r0,r0,#7
000028  61a0              STR      r0,[r4,#0x18]
                  |L32.42|
;;;3727   				}
;;;3728   				else
;;;3729   				{
;;;3730   					mtCOVERAGE_TEST_MARKER();
;;;3731   				}
;;;3732   
;;;3733   				/* If the task being modified is in the ready state it will need
;;;3734   				to be moved into a new list. */
;;;3735   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00002a  6ae1              LDR      r1,[r4,#0x2c]
00002c  eb010181          ADD      r1,r1,r1,LSL #2
000030  4a1d              LDR      r2,|L32.168|
000032  eb020181          ADD      r1,r2,r1,LSL #2
000036  6960              LDR      r0,[r4,#0x14]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L32.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L32.66|
                  |L32.64|
000040  2000              MOVS     r0,#0
                  |L32.66|
000042  b350              CBZ      r0,|L32.154|
;;;3736   				{
;;;3737   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       uxListRemove
00004a  b978              CBNZ     r0,|L32.108|
;;;3738   					{
;;;3739   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00004c  6ae0              LDR      r0,[r4,#0x2c]
00004e  eb000080          ADD      r0,r0,r0,LSL #2
000052  4915              LDR      r1,|L32.168|
000054  f8510020          LDR      r0,[r1,r0,LSL #2]
000058  b940              CBNZ     r0,|L32.108|
00005a  f894102c          LDRB     r1,[r4,#0x2c]
00005e  2001              MOVS     r0,#1
000060  4088              LSLS     r0,r0,r1
000062  4912              LDR      r1,|L32.172|
000064  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000066  4381              BICS     r1,r1,r0
000068  4810              LDR      r0,|L32.172|
00006a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L32.108|
;;;3740   					}
;;;3741   					else
;;;3742   					{
;;;3743   						mtCOVERAGE_TEST_MARKER();
;;;3744   					}
;;;3745   
;;;3746   					/* Inherit the priority before being moved into the new list. */
;;;3747   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00006c  480d              LDR      r0,|L32.164|
00006e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000070  6ac0              LDR      r0,[r0,#0x2c]
000072  62e0              STR      r0,[r4,#0x2c]
;;;3748   					prvAddTaskToReadyList( pxTCB );
000074  f894102c          LDRB     r1,[r4,#0x2c]
000078  2001              MOVS     r0,#1
00007a  4088              LSLS     r0,r0,r1
00007c  490b              LDR      r1,|L32.172|
00007e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000080  4308              ORRS     r0,r0,r1
000082  490a              LDR      r1,|L32.172|
000084  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000086  6ae1              LDR      r1,[r4,#0x2c]
000088  eb010181          ADD      r1,r1,r1,LSL #2
00008c  4a06              LDR      r2,|L32.168|
00008e  eb020081          ADD      r0,r2,r1,LSL #2
000092  1d21              ADDS     r1,r4,#4
000094  f7fffffe          BL       vListInsertEnd
000098  e003              B        |L32.162|
                  |L32.154|
;;;3749   				}
;;;3750   				else
;;;3751   				{
;;;3752   					/* Just inherit the priority. */
;;;3753   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00009a  4802              LDR      r0,|L32.164|
00009c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00009e  6ac0              LDR      r0,[r0,#0x2c]
0000a0  62e0              STR      r0,[r4,#0x2c]
                  |L32.162|
;;;3754   				}
;;;3755   
;;;3756   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3757   			}
;;;3758   			else
;;;3759   			{
;;;3760   				mtCOVERAGE_TEST_MARKER();
;;;3761   			}
;;;3762   		}
;;;3763   		else
;;;3764   		{
;;;3765   			mtCOVERAGE_TEST_MARKER();
;;;3766   		}
;;;3767   	}
0000a2  bd70              POP      {r4-r6,pc}
;;;3768   
                          ENDP

                  |L32.164|
                          DCD      pxCurrentTCB
                  |L32.168|
                          DCD      pxReadyTasksLists
                  |L32.172|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1403   
;;;1404   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1405   	{
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;1406   	TCB_t *pxTCB;
;;;1407   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1408   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1409   
;;;1410   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
00000c  2d07              CMP      r5,#7
00000e  d201              BCS      |L33.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L33.22|
                  |L33.20|
000014  2000              MOVS     r0,#0
                  |L33.22|
000016  b950              CBNZ     r0,|L33.46|
000018  bf00              NOP      
00001a  2030              MOVS     r0,#0x30
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L33.44|
00002c  e7fe              B        |L33.44|
                  |L33.46|
;;;1411   
;;;1412   		/* Ensure the new priority is valid. */
;;;1413   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00002e  2d07              CMP      r5,#7
000030  d300              BCC      |L33.52|
;;;1414   		{
;;;1415   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000032  2506              MOVS     r5,#6
                  |L33.52|
;;;1416   		}
;;;1417   		else
;;;1418   		{
;;;1419   			mtCOVERAGE_TEST_MARKER();
;;;1420   		}
;;;1421   
;;;1422   		taskENTER_CRITICAL();
000034  f7fffffe          BL       vPortEnterCritical
;;;1423   		{
;;;1424   			/* If null is passed in here then it is the priority of the calling
;;;1425   			task that is being changed. */
;;;1426   			pxTCB = prvGetTCBFromHandle( xTask );
000038  f1b80f00          CMP      r8,#0
00003c  d102              BNE      |L33.68|
00003e  4831              LDR      r0,|L33.260|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  e000              B        |L33.70|
                  |L33.68|
000044  4640              MOV      r0,r8
                  |L33.70|
000046  4604              MOV      r4,r0
;;;1427   
;;;1428   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1429   
;;;1430   			#if ( configUSE_MUTEXES == 1 )
;;;1431   			{
;;;1432   				uxCurrentBasePriority = pxTCB->uxBasePriority;
000048  6ce6              LDR      r6,[r4,#0x4c]
;;;1433   			}
;;;1434   			#else
;;;1435   			{
;;;1436   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1437   			}
;;;1438   			#endif
;;;1439   
;;;1440   			if( uxCurrentBasePriority != uxNewPriority )
00004a  42ae              CMP      r6,r5
00004c  d056              BEQ      |L33.252|
;;;1441   			{
;;;1442   				/* The priority change may have readied a task of higher
;;;1443   				priority than the calling task. */
;;;1444   				if( uxNewPriority > uxCurrentBasePriority )
00004e  42b5              CMP      r5,r6
000050  d90b              BLS      |L33.106|
;;;1445   				{
;;;1446   					if( pxTCB != pxCurrentTCB )
000052  482c              LDR      r0,|L33.260|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d00d              BEQ      |L33.118|
;;;1447   					{
;;;1448   						/* The priority of a task other than the currently
;;;1449   						running task is being raised.  Is the priority being
;;;1450   						raised above that of the running task? */
;;;1451   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
00005a  482a              LDR      r0,|L33.260|
00005c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005e  6ac0              LDR      r0,[r0,#0x2c]
000060  42a8              CMP      r0,r5
000062  d808              BHI      |L33.118|
;;;1452   						{
;;;1453   							xYieldRequired = pdTRUE;
000064  f04f0901          MOV      r9,#1
000068  e005              B        |L33.118|
                  |L33.106|
;;;1454   						}
;;;1455   						else
;;;1456   						{
;;;1457   							mtCOVERAGE_TEST_MARKER();
;;;1458   						}
;;;1459   					}
;;;1460   					else
;;;1461   					{
;;;1462   						/* The priority of the running task is being raised,
;;;1463   						but the running task must already be the highest
;;;1464   						priority task able to run so no yield is required. */
;;;1465   					}
;;;1466   				}
;;;1467   				else if( pxTCB == pxCurrentTCB )
00006a  4826              LDR      r0,|L33.260|
00006c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006e  4284              CMP      r4,r0
000070  d101              BNE      |L33.118|
;;;1468   				{
;;;1469   					/* Setting the priority of the running task down means
;;;1470   					there may now be another task of higher priority that
;;;1471   					is ready to execute. */
;;;1472   					xYieldRequired = pdTRUE;
000072  f04f0901          MOV      r9,#1
                  |L33.118|
;;;1473   				}
;;;1474   				else
;;;1475   				{
;;;1476   					/* Setting the priority of any other task down does not
;;;1477   					require a yield as the running task must be above the
;;;1478   					new priority of the task being modified. */
;;;1479   				}
;;;1480   
;;;1481   				/* Remember the ready list the task might be referenced from
;;;1482   				before its uxPriority member is changed so the
;;;1483   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1484   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000076  6ae7              LDR      r7,[r4,#0x2c]
;;;1485   
;;;1486   				#if ( configUSE_MUTEXES == 1 )
;;;1487   				{
;;;1488   					/* Only change the priority being used if the task is not
;;;1489   					currently using an inherited priority. */
;;;1490   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000078  6ae1              LDR      r1,[r4,#0x2c]
00007a  6ce0              LDR      r0,[r4,#0x4c]
00007c  4288              CMP      r0,r1
00007e  d100              BNE      |L33.130|
;;;1491   					{
;;;1492   						pxTCB->uxPriority = uxNewPriority;
000080  62e5              STR      r5,[r4,#0x2c]
                  |L33.130|
;;;1493   					}
;;;1494   					else
;;;1495   					{
;;;1496   						mtCOVERAGE_TEST_MARKER();
;;;1497   					}
;;;1498   
;;;1499   					/* The base priority gets set whatever. */
;;;1500   					pxTCB->uxBasePriority = uxNewPriority;
000082  64e5              STR      r5,[r4,#0x4c]
;;;1501   				}
;;;1502   				#else
;;;1503   				{
;;;1504   					pxTCB->uxPriority = uxNewPriority;
;;;1505   				}
;;;1506   				#endif
;;;1507   
;;;1508   				/* Only reset the event list item value if the value is not
;;;1509   				being used for anything else. */
;;;1510   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000084  69a0              LDR      r0,[r4,#0x18]
000086  f0004000          AND      r0,r0,#0x80000000
00008a  b910              CBNZ     r0,|L33.146|
;;;1511   				{
;;;1512   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008c  f1c50007          RSB      r0,r5,#7
000090  61a0              STR      r0,[r4,#0x18]
                  |L33.146|
;;;1513   				}
;;;1514   				else
;;;1515   				{
;;;1516   					mtCOVERAGE_TEST_MARKER();
;;;1517   				}
;;;1518   
;;;1519   				/* If the task is in the blocked or suspended list we need do
;;;1520   				nothing more than change it's priority variable. However, if
;;;1521   				the task is in a ready list it needs to be removed and placed
;;;1522   				in the list appropriate to its new priority. */
;;;1523   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000092  eb070187          ADD      r1,r7,r7,LSL #2
000096  4a1c              LDR      r2,|L33.264|
000098  eb020181          ADD      r1,r2,r1,LSL #2
00009c  6960              LDR      r0,[r4,#0x14]
00009e  4288              CMP      r0,r1
0000a0  d101              BNE      |L33.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L33.168|
                  |L33.166|
0000a6  2000              MOVS     r0,#0
                  |L33.168|
0000a8  b1e0              CBZ      r0,|L33.228|
;;;1524   				{
;;;1525   					/* The task is currently in its ready list - remove before adding
;;;1526   					it to it's new ready list.  As we are in a critical section we
;;;1527   					can do this even if the scheduler is suspended. */
;;;1528   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0000aa  1d20              ADDS     r0,r4,#4
0000ac  f7fffffe          BL       uxListRemove
0000b0  b930              CBNZ     r0,|L33.192|
;;;1529   					{
;;;1530   						/* It is known that the task is in its ready list so
;;;1531   						there is no need to check again and the port level
;;;1532   						reset macro can be called directly. */
;;;1533   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
0000b2  2001              MOVS     r0,#1
0000b4  40b8              LSLS     r0,r0,r7
0000b6  4915              LDR      r1,|L33.268|
0000b8  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000ba  4381              BICS     r1,r1,r0
0000bc  4813              LDR      r0,|L33.268|
0000be  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L33.192|
;;;1534   					}
;;;1535   					else
;;;1536   					{
;;;1537   						mtCOVERAGE_TEST_MARKER();
;;;1538   					}
;;;1539   					prvAddTaskToReadyList( pxTCB );
0000c0  f894102c          LDRB     r1,[r4,#0x2c]
0000c4  2001              MOVS     r0,#1
0000c6  4088              LSLS     r0,r0,r1
0000c8  4910              LDR      r1,|L33.268|
0000ca  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000cc  4308              ORRS     r0,r0,r1
0000ce  490f              LDR      r1,|L33.268|
0000d0  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000d2  6ae1              LDR      r1,[r4,#0x2c]
0000d4  eb010181          ADD      r1,r1,r1,LSL #2
0000d8  4a0b              LDR      r2,|L33.264|
0000da  eb020081          ADD      r0,r2,r1,LSL #2
0000de  1d21              ADDS     r1,r4,#4
0000e0  f7fffffe          BL       vListInsertEnd
                  |L33.228|
;;;1540   				}
;;;1541   				else
;;;1542   				{
;;;1543   					mtCOVERAGE_TEST_MARKER();
;;;1544   				}
;;;1545   
;;;1546   				if( xYieldRequired != pdFALSE )
0000e4  f1b90f00          CMP      r9,#0
0000e8  d007              BEQ      |L33.250|
;;;1547   				{
;;;1548   					taskYIELD_IF_USING_PREEMPTION();
0000ea  f04f5080          MOV      r0,#0x10000000
0000ee  4908              LDR      r1,|L33.272|
0000f0  6008              STR      r0,[r1,#0]
0000f2  f3bf8f4f          DSB      
0000f6  f3bf8f6f          ISB      
                  |L33.250|
;;;1549   				}
;;;1550   				else
;;;1551   				{
;;;1552   					mtCOVERAGE_TEST_MARKER();
;;;1553   				}
;;;1554   
;;;1555   				/* Remove compiler warning about unused variables when the port
;;;1556   				optimised task selection is not being used. */
;;;1557   				( void ) uxPriorityUsedOnEntry;
0000fa  bf00              NOP      
                  |L33.252|
;;;1558   			}
;;;1559   		}
;;;1560   		taskEXIT_CRITICAL();
0000fc  f7fffffe          BL       vPortExitCritical
;;;1561   	}
000100  e8bd87f0          POP      {r4-r10,pc}
;;;1562   
                          ENDP

                  |L33.260|
                          DCD      pxCurrentTCB
                  |L33.264|
                          DCD      pxReadyTasksLists
                  |L33.268|
                          DCD      uxTopReadyPriority
                  |L33.272|
                          DCD      0xe000ed04

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1703   
;;;1704   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1705   	{
000002  4605              MOV      r5,r0
;;;1706   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000004  462c              MOV      r4,r5
;;;1707   
;;;1708   		/* It does not make sense to resume the calling task. */
;;;1709   		configASSERT( xTaskToResume );
000006  b955              CBNZ     r5,|L34.30|
000008  bf00              NOP      
00000a  2030              MOVS     r0,#0x30
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L34.28|
00001c  e7fe              B        |L34.28|
                  |L34.30|
;;;1710   
;;;1711   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1712   		currently executing task. */
;;;1713   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
00001e  b374              CBZ      r4,|L34.126|
000020  4817              LDR      r0,|L34.128|
000022  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  4284              CMP      r4,r0
000026  d02a              BEQ      |L34.126|
;;;1714   		{
;;;1715   			taskENTER_CRITICAL();
000028  f7fffffe          BL       vPortEnterCritical
;;;1716   			{
;;;1717   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvTaskIsTaskSuspended
000032  b310              CBZ      r0,|L34.122|
;;;1718   				{
;;;1719   					traceTASK_RESUME( pxTCB );
;;;1720   
;;;1721   					/* As we are in a critical section we can access the ready
;;;1722   					lists even if the scheduler is suspended. */
;;;1723   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       uxListRemove
;;;1724   					prvAddTaskToReadyList( pxTCB );
00003a  f894102c          LDRB     r1,[r4,#0x2c]
00003e  2001              MOVS     r0,#1
000040  4088              LSLS     r0,r0,r1
000042  4910              LDR      r1,|L34.132|
000044  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000046  4308              ORRS     r0,r0,r1
000048  490e              LDR      r1,|L34.132|
00004a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00004c  6ae1              LDR      r1,[r4,#0x2c]
00004e  eb010181          ADD      r1,r1,r1,LSL #2
000052  4a0d              LDR      r2,|L34.136|
000054  eb020081          ADD      r0,r2,r1,LSL #2
000058  1d21              ADDS     r1,r4,#4
00005a  f7fffffe          BL       vListInsertEnd
;;;1725   
;;;1726   					/* We may have just resumed a higher priority task. */
;;;1727   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00005e  4908              LDR      r1,|L34.128|
000060  6ae0              LDR      r0,[r4,#0x2c]
000062  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000064  6ac9              LDR      r1,[r1,#0x2c]
000066  4288              CMP      r0,r1
000068  d307              BCC      |L34.122|
;;;1728   					{
;;;1729   						/* This yield may not cause the task just resumed to run,
;;;1730   						but will leave the lists in the correct state for the
;;;1731   						next yield. */
;;;1732   						taskYIELD_IF_USING_PREEMPTION();
00006a  f04f5080          MOV      r0,#0x10000000
00006e  4907              LDR      r1,|L34.140|
000070  6008              STR      r0,[r1,#0]
000072  f3bf8f4f          DSB      
000076  f3bf8f6f          ISB      
                  |L34.122|
;;;1733   					}
;;;1734   					else
;;;1735   					{
;;;1736   						mtCOVERAGE_TEST_MARKER();
;;;1737   					}
;;;1738   				}
;;;1739   				else
;;;1740   				{
;;;1741   					mtCOVERAGE_TEST_MARKER();
;;;1742   				}
;;;1743   			}
;;;1744   			taskEXIT_CRITICAL();
00007a  f7fffffe          BL       vPortExitCritical
                  |L34.126|
;;;1745   		}
;;;1746   		else
;;;1747   		{
;;;1748   			mtCOVERAGE_TEST_MARKER();
;;;1749   		}
;;;1750   	}
00007e  bd70              POP      {r4-r6,pc}
;;;1751   
                          ENDP

                  |L34.128|
                          DCD      pxCurrentTCB
                  |L34.132|
                          DCD      uxTopReadyPriority
                  |L34.136|
                          DCD      pxReadyTasksLists
                  |L34.140|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=1

                  vTaskSetTaskNumber PROC
;;;3108   
;;;3109   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  b108              CBZ      r0,|L35.6|
;;;3110   	{
;;;3111   	TCB_t *pxTCB;
;;;3112   
;;;3113   		if( xTask != NULL )
;;;3114   		{
;;;3115   			pxTCB = ( TCB_t * ) xTask;
000002  4602              MOV      r2,r0
;;;3116   			pxTCB->uxTaskNumber = uxHandle;
000004  6491              STR      r1,[r2,#0x48]
                  |L35.6|
;;;3117   		}
;;;3118   	}
000006  4770              BX       lr
;;;3119   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3008   
;;;3009   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b950              CBNZ     r0,|L36.24|
;;;3010   {
;;;3011   	configASSERT( pxTimeOut );
000002  bf00              NOP      
000004  2130              MOVS     r1,#0x30
000006  f3818811          MSR      BASEPRI,r1
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
000014  bf00              NOP      
                  |L36.22|
000016  e7fe              B        |L36.22|
                  |L36.24|
;;;3012   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000018  4903              LDR      r1,|L36.40|
00001a  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
00001c  6001              STR      r1,[r0,#0]
;;;3013   	pxTimeOut->xTimeOnEntering = xTickCount;
00001e  4903              LDR      r1,|L36.44|
000020  6809              LDR      r1,[r1,#0]  ; xTickCount
000022  6041              STR      r1,[r0,#4]
;;;3014   }
000024  4770              BX       lr
;;;3015   /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L36.40|
                          DCD      xNumOfOverflows
                  |L36.44|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1827   
;;;1828   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1829   {
;;;1830   BaseType_t xReturn;
;;;1831   
;;;1832   	/* Add the idle task at the lowest priority. */
;;;1833   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1834   	{
;;;1835   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1836   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1837   		uint32_t ulIdleTaskStackSize;
;;;1838   
;;;1839   		/* The Idle task is created using user provided RAM - obtain the
;;;1840   		address of the RAM then create the idle task. */
;;;1841   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1842   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1843   												"IDLE",
;;;1844   												ulIdleTaskStackSize,
;;;1845   												( void * ) NULL,
;;;1846   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1847   												pxIdleTaskStackBuffer,
;;;1848   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1849   
;;;1850   		if( xIdleTaskHandle != NULL )
;;;1851   		{
;;;1852   			xReturn = pdPASS;
;;;1853   		}
;;;1854   		else
;;;1855   		{
;;;1856   			xReturn = pdFAIL;
;;;1857   		}
;;;1858   	}
;;;1859   	#else
;;;1860   	{
;;;1861   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1862   		xReturn = xTaskCreate(	prvIdleTask,
000002  481d              LDR      r0,|L37.120|
000004  2100              MOVS     r1,#0
000006  460b              MOV      r3,r1
000008  2240              MOVS     r2,#0x40
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  a11b              ADR      r1,|L37.124|
000010  481c              LDR      r0,|L37.132|
000012  f7fffffe          BL       xTaskCreate
000016  4604              MOV      r4,r0
;;;1863   								"IDLE", configMINIMAL_STACK_SIZE,
;;;1864   								( void * ) NULL,
;;;1865   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1866   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1867   	}
;;;1868   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1869   
;;;1870   	#if ( configUSE_TIMERS == 1 )
;;;1871   	{
;;;1872   		if( xReturn == pdPASS )
000018  2c01              CMP      r4,#1
00001a  d102              BNE      |L37.34|
;;;1873   		{
;;;1874   			xReturn = xTimerCreateTimerTask();
00001c  f7fffffe          BL       xTimerCreateTimerTask
000020  4604              MOV      r4,r0
                  |L37.34|
;;;1875   		}
;;;1876   		else
;;;1877   		{
;;;1878   			mtCOVERAGE_TEST_MARKER();
;;;1879   		}
;;;1880   	}
;;;1881   	#endif /* configUSE_TIMERS */
;;;1882   
;;;1883   	if( xReturn == pdPASS )
000022  2c01              CMP      r4,#1
000024  d115              BNE      |L37.82|
;;;1884   	{
;;;1885   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1886   		before or during the call to xPortStartScheduler().  The stacks of
;;;1887   		the created tasks contain a status word with interrupts switched on
;;;1888   		so interrupts will automatically get re-enabled when the first task
;;;1889   		starts to run. */
;;;1890   		portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  2030              MOVS     r0,#0x30
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;1891   
;;;1892   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1893   		{
;;;1894   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1895   			structure specific to the task that will run first. */
;;;1896   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1897   		}
;;;1898   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1899   
;;;1900   		xNextTaskUnblockTime = portMAX_DELAY;
000038  f04f30ff          MOV      r0,#0xffffffff
00003c  4912              LDR      r1,|L37.136|
00003e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1901   		xSchedulerRunning = pdTRUE;
000040  2001              MOVS     r0,#1
000042  4912              LDR      r1,|L37.140|
000044  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1902   		xTickCount = ( TickType_t ) 0U;
000046  2000              MOVS     r0,#0
000048  4911              LDR      r1,|L37.144|
00004a  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1903   
;;;1904   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1905   		macro must be defined to configure the timer/counter used to generate
;;;1906   		the run time counter time base. */
;;;1907   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1908   
;;;1909   		/* Setting up the timer tick is hardware specific and thus in the
;;;1910   		portable interface. */
;;;1911   		if( xPortStartScheduler() != pdFALSE )
00004c  f7fffffe          BL       xPortStartScheduler
000050  e010              B        |L37.116|
                  |L37.82|
;;;1912   		{
;;;1913   			/* Should not reach here as if the scheduler is running the
;;;1914   			function will not return. */
;;;1915   		}
;;;1916   		else
;;;1917   		{
;;;1918   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1919   		}
;;;1920   	}
;;;1921   	else
;;;1922   	{
;;;1923   		/* This line will only be reached if the kernel could not be started,
;;;1924   		because there was not enough FreeRTOS heap to create the idle task
;;;1925   		or the timer task. */
;;;1926   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000052  1c60              ADDS     r0,r4,#1
000054  b108              CBZ      r0,|L37.90|
000056  2001              MOVS     r0,#1
000058  e000              B        |L37.92|
                  |L37.90|
00005a  2000              MOVS     r0,#0
                  |L37.92|
00005c  b950              CBNZ     r0,|L37.116|
00005e  bf00              NOP      
000060  2030              MOVS     r0,#0x30
000062  f3808811          MSR      BASEPRI,r0
000066  f3bf8f4f          DSB      
00006a  f3bf8f6f          ISB      
00006e  bf00              NOP      
000070  bf00              NOP      
                  |L37.114|
000072  e7fe              B        |L37.114|
                  |L37.116|
;;;1927   	}
;;;1928   
;;;1929   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;1930   	meaning xIdleTaskHandle is not used anywhere else. */
;;;1931   	( void ) xIdleTaskHandle;
;;;1932   }
000074  bd1c              POP      {r2-r4,pc}
;;;1933   /*-----------------------------------------------------------*/
                          ENDP

000076  0000              DCW      0x0000
                  |L37.120|
                          DCD      xIdleTaskHandle
                  |L37.124|
00007c  49444c45          DCB      "IDLE",0
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L37.132|
                          DCD      prvIdleTask
                  |L37.136|
                          DCD      xNextTaskUnblockTime
                  |L37.140|
                          DCD      xSchedulerRunning
                  |L37.144|
                          DCD      xTickCount

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1567   
;;;1568   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1569   	{
000002  4605              MOV      r5,r0
;;;1570   	TCB_t *pxTCB;
;;;1571   
;;;1572   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1573   		{
;;;1574   			/* If null is passed in here then it is the running task that is
;;;1575   			being suspended. */
;;;1576   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L38.16|
00000a  482e              LDR      r0,|L38.196|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L38.18|
                  |L38.16|
000010  4628              MOV      r0,r5
                  |L38.18|
000012  4604              MOV      r4,r0
;;;1577   
;;;1578   			traceTASK_SUSPEND( pxTCB );
;;;1579   
;;;1580   			/* Remove task from the ready/delayed list and place in the
;;;1581   			suspended list. */
;;;1582   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L38.60|
;;;1583   			{
;;;1584   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  4929              LDR      r1,|L38.200|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L38.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4926              LDR      r1,|L38.204|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  4824              LDR      r0,|L38.204|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L38.60|
;;;1585   			}
;;;1586   			else
;;;1587   			{
;;;1588   				mtCOVERAGE_TEST_MARKER();
;;;1589   			}
;;;1590   
;;;1591   			/* Is the task waiting on an event also? */
;;;1592   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L38.72|
;;;1593   			{
;;;1594   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L38.72|
;;;1595   			}
;;;1596   			else
;;;1597   			{
;;;1598   				mtCOVERAGE_TEST_MARKER();
;;;1599   			}
;;;1600   
;;;1601   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000048  1d21              ADDS     r1,r4,#4
00004a  4821              LDR      r0,|L38.208|
00004c  f7fffffe          BL       vListInsertEnd
;;;1602   		}
;;;1603   		taskEXIT_CRITICAL();
000050  f7fffffe          BL       vPortExitCritical
;;;1604   
;;;1605   		if( xSchedulerRunning != pdFALSE )
000054  481f              LDR      r0,|L38.212|
000056  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000058  b128              CBZ      r0,|L38.102|
;;;1606   		{
;;;1607   			/* Reset the next expected unblock time in case it referred to the
;;;1608   			task that is now in the Suspended state. */
;;;1609   			taskENTER_CRITICAL();
00005a  f7fffffe          BL       vPortEnterCritical
;;;1610   			{
;;;1611   				prvResetNextTaskUnblockTime();
00005e  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1612   			}
;;;1613   			taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
                  |L38.102|
;;;1614   		}
;;;1615   		else
;;;1616   		{
;;;1617   			mtCOVERAGE_TEST_MARKER();
;;;1618   		}
;;;1619   
;;;1620   		if( pxTCB == pxCurrentTCB )
000066  4817              LDR      r0,|L38.196|
000068  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006a  4284              CMP      r4,r0
00006c  d129              BNE      |L38.194|
;;;1621   		{
;;;1622   			if( xSchedulerRunning != pdFALSE )
00006e  4819              LDR      r0,|L38.212|
000070  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000072  b1d0              CBZ      r0,|L38.170|
;;;1623   			{
;;;1624   				/* The current task has just been suspended. */
;;;1625   				configASSERT( uxSchedulerSuspended == 0 );
000074  4818              LDR      r0,|L38.216|
000076  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000078  b908              CBNZ     r0,|L38.126|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L38.128|
                  |L38.126|
00007e  2000              MOVS     r0,#0
                  |L38.128|
000080  b950              CBNZ     r0,|L38.152|
000082  bf00              NOP      
000084  2030              MOVS     r0,#0x30
000086  f3808811          MSR      BASEPRI,r0
00008a  f3bf8f4f          DSB      
00008e  f3bf8f6f          ISB      
000092  bf00              NOP      
000094  bf00              NOP      
                  |L38.150|
000096  e7fe              B        |L38.150|
                  |L38.152|
;;;1626   				portYIELD_WITHIN_API();
000098  f04f5080          MOV      r0,#0x10000000
00009c  490f              LDR      r1,|L38.220|
00009e  6008              STR      r0,[r1,#0]
0000a0  f3bf8f4f          DSB      
0000a4  f3bf8f6f          ISB      
0000a8  e00b              B        |L38.194|
                  |L38.170|
;;;1627   			}
;;;1628   			else
;;;1629   			{
;;;1630   				/* The scheduler is not running, but the task that was pointed
;;;1631   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1632   				must be adjusted to point to a different task. */
;;;1633   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
0000aa  4809              LDR      r0,|L38.208|
0000ac  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
0000ae  490c              LDR      r1,|L38.224|
0000b0  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
0000b2  4288              CMP      r0,r1
0000b4  d103              BNE      |L38.190|
;;;1634   				{
;;;1635   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1636   					NULL so when the next task is created pxCurrentTCB will
;;;1637   					be set to point to it no matter what its relative priority
;;;1638   					is. */
;;;1639   					pxCurrentTCB = NULL;
0000b6  2000              MOVS     r0,#0
0000b8  4902              LDR      r1,|L38.196|
0000ba  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0000bc  e001              B        |L38.194|
                  |L38.190|
;;;1640   				}
;;;1641   				else
;;;1642   				{
;;;1643   					vTaskSwitchContext();
0000be  f7fffffe          BL       vTaskSwitchContext
                  |L38.194|
;;;1644   				}
;;;1645   			}
;;;1646   		}
;;;1647   		else
;;;1648   		{
;;;1649   			mtCOVERAGE_TEST_MARKER();
;;;1650   		}
;;;1651   	}
0000c2  bd70              POP      {r4-r6,pc}
;;;1652   
                          ENDP

                  |L38.196|
                          DCD      pxCurrentTCB
                  |L38.200|
                          DCD      pxReadyTasksLists
                  |L38.204|
                          DCD      uxTopReadyPriority
                  |L38.208|
                          DCD      xSuspendedTaskList
                  |L38.212|
                          DCD      xSchedulerRunning
                  |L38.216|
                          DCD      uxSchedulerSuspended
                  |L38.220|
                          DCD      0xe000ed04
                  |L38.224|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1945   
;;;1946   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L39.12|
;;;1947   {
;;;1948   	/* A critical section is not required as the variable is of type
;;;1949   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1950   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1951   	http://goo.gl/wu4acr */
;;;1952   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L39.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1953   }
00000a  4770              BX       lr
;;;1954   /*----------------------------------------------------------*/
                          ENDP

                  |L39.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2762   
;;;2763   void vTaskSwitchContext( void )
000000  b510              PUSH     {r4,lr}
;;;2764   {
;;;2765   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  4824              LDR      r0,|L40.148|
000004  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000006  b118              CBZ      r0,|L40.16|
;;;2766   	{
;;;2767   		/* The scheduler is currently suspended - do not allow a context
;;;2768   		switch. */
;;;2769   		xYieldPending = pdTRUE;
000008  2001              MOVS     r0,#1
00000a  4923              LDR      r1,|L40.152|
00000c  6008              STR      r0,[r1,#0]  ; xYieldPending
00000e  e040              B        |L40.146|
                  |L40.16|
;;;2770   	}
;;;2771   	else
;;;2772   	{
;;;2773   		xYieldPending = pdFALSE;
000010  2000              MOVS     r0,#0
000012  4921              LDR      r1,|L40.152|
000014  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2774   		traceTASK_SWITCHED_OUT();
;;;2775   
;;;2776   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2777   		{
;;;2778   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2779   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2780   				#else
;;;2781   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2782   				#endif
;;;2783   
;;;2784   				/* Add the amount of time the task has been running to the
;;;2785   				accumulated time so far.  The time the task started running was
;;;2786   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2787   				protection here so count values are only valid until the timer
;;;2788   				overflows.  The guard against negative values is to protect
;;;2789   				against suspect run time stat counter implementations - which
;;;2790   				are provided by the application, not the kernel. */
;;;2791   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2792   				{
;;;2793   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2794   				}
;;;2795   				else
;;;2796   				{
;;;2797   					mtCOVERAGE_TEST_MARKER();
;;;2798   				}
;;;2799   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2800   		}
;;;2801   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2802   
;;;2803   		/* Check for stack overflow, if configured. */
;;;2804   		taskCHECK_FOR_STACK_OVERFLOW();
000016  4821              LDR      r0,|L40.156|
000018  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001a  6800              LDR      r0,[r0,#0]
00001c  491f              LDR      r1,|L40.156|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  6b09              LDR      r1,[r1,#0x30]
000022  4288              CMP      r0,r1
000024  d805              BHI      |L40.50|
000026  481d              LDR      r0,|L40.156|
000028  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00002a  3134              ADDS     r1,r1,#0x34
00002c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00002e  f7fffffe          BL       vApplicationStackOverflowHook
                  |L40.50|
;;;2805   
;;;2806   		/* Select a new task to run using either the generic C or port
;;;2807   		optimised asm code. */
;;;2808   		taskSELECT_HIGHEST_PRIORITY_TASK();
000032  481b              LDR      r0,|L40.160|
000034  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
000036  fab0f080          CLZ      r0,r0
00003a  f1c0011f          RSB      r1,r0,#0x1f
00003e  eb010081          ADD      r0,r1,r1,LSL #2
000042  4a18              LDR      r2,|L40.164|
000044  f8520020          LDR      r0,[r2,r0,LSL #2]
000048  b108              CBZ      r0,|L40.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L40.80|
                  |L40.78|
00004e  2000              MOVS     r0,#0
                  |L40.80|
000050  b950              CBNZ     r0,|L40.104|
000052  bf00              NOP      
000054  2030              MOVS     r0,#0x30
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  bf00              NOP      
000064  bf00              NOP      
                  |L40.102|
000066  e7fe              B        |L40.102|
                  |L40.104|
000068  eb010281          ADD      r2,r1,r1,LSL #2
00006c  4b0d              LDR      r3,|L40.164|
00006e  eb030082          ADD      r0,r3,r2,LSL #2
000072  6842              LDR      r2,[r0,#4]
000074  6852              LDR      r2,[r2,#4]
000076  6042              STR      r2,[r0,#4]
000078  f1000208          ADD      r2,r0,#8
00007c  6843              LDR      r3,[r0,#4]
00007e  4293              CMP      r3,r2
000080  d102              BNE      |L40.136|
000082  6842              LDR      r2,[r0,#4]
000084  6852              LDR      r2,[r2,#4]
000086  6042              STR      r2,[r0,#4]
                  |L40.136|
000088  6842              LDR      r2,[r0,#4]
00008a  68d2              LDR      r2,[r2,#0xc]
00008c  4b03              LDR      r3,|L40.156|
00008e  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
000090  bf00              NOP      
                  |L40.146|
;;;2809   		traceTASK_SWITCHED_IN();
;;;2810   
;;;2811   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2812   		{
;;;2813   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2814   			structure specific to this task. */
;;;2815   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2816   		}
;;;2817   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2818   	}
;;;2819   }
000092  bd10              POP      {r4,pc}
;;;2820   /*-----------------------------------------------------------*/
                          ENDP

                  |L40.148|
                          DCD      uxSchedulerSuspended
                  |L40.152|
                          DCD      xYieldPending
                  |L40.156|
                          DCD      pxCurrentTCB
                  |L40.160|
                          DCD      uxTopReadyPriority
                  |L40.164|
                          DCD      pxReadyTasksLists

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3016   
;;;3017   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3018   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3019   BaseType_t xReturn;
;;;3020   
;;;3021   	configASSERT( pxTimeOut );
000006  b954              CBNZ     r4,|L41.30|
000008  bf00              NOP      
00000a  2030              MOVS     r0,#0x30
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L41.28|
00001c  e7fe              B        |L41.28|
                  |L41.30|
;;;3022   	configASSERT( pxTicksToWait );
00001e  b955              CBNZ     r5,|L41.54|
000020  bf00              NOP      
000022  2030              MOVS     r0,#0x30
000024  f3808811          MSR      BASEPRI,r0
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
000030  bf00              NOP      
000032  bf00              NOP      
                  |L41.52|
000034  e7fe              B        |L41.52|
                  |L41.54|
;;;3023   
;;;3024   	taskENTER_CRITICAL();
000036  f7fffffe          BL       vPortEnterCritical
;;;3025   	{
;;;3026   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3027   		const TickType_t xConstTickCount = xTickCount;
00003a  4812              LDR      r0,|L41.132|
00003c  6803              LDR      r3,[r0,#0]  ; xTickCount
;;;3028   
;;;3029   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3030   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3031   			{
;;;3032   				/* The delay was aborted, which is not the same as a time out,
;;;3033   				but has the same result. */
;;;3034   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3035   				xReturn = pdTRUE;
;;;3036   			}
;;;3037   			else
;;;3038   		#endif
;;;3039   
;;;3040   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3041   			if( *pxTicksToWait == portMAX_DELAY )
00003e  6828              LDR      r0,[r5,#0]
000040  1c40              ADDS     r0,r0,#1
000042  b908              CBNZ     r0,|L41.72|
;;;3042   			{
;;;3043   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3044   				specified is the maximum block time then the task should block
;;;3045   				indefinitely, and therefore never time out. */
;;;3046   				xReturn = pdFALSE;
000044  2600              MOVS     r6,#0
000046  e019              B        |L41.124|
                  |L41.72|
;;;3047   			}
;;;3048   			else
;;;3049   		#endif
;;;3050   
;;;3051   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000048  490f              LDR      r1,|L41.136|
00004a  6820              LDR      r0,[r4,#0]
00004c  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
00004e  4288              CMP      r0,r1
000050  d004              BEQ      |L41.92|
000052  6860              LDR      r0,[r4,#4]
000054  4298              CMP      r0,r3
000056  d801              BHI      |L41.92|
;;;3052   		{
;;;3053   			/* The tick count is greater than the time at which
;;;3054   			vTaskSetTimeout() was called, but has also overflowed since
;;;3055   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3056   			around and gone past again. This passed since vTaskSetTimeout()
;;;3057   			was called. */
;;;3058   			xReturn = pdTRUE;
000058  2601              MOVS     r6,#1
00005a  e00f              B        |L41.124|
                  |L41.92|
;;;3059   		}
;;;3060   		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
00005c  6860              LDR      r0,[r4,#4]
00005e  1a18              SUBS     r0,r3,r0
000060  6829              LDR      r1,[r5,#0]
000062  4288              CMP      r0,r1
000064  d209              BCS      |L41.122|
;;;3061   		{
;;;3062   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3063   			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
000066  6828              LDR      r0,[r5,#0]
000068  6861              LDR      r1,[r4,#4]
00006a  1a59              SUBS     r1,r3,r1
00006c  1a40              SUBS     r0,r0,r1
00006e  6028              STR      r0,[r5,#0]
;;;3064   			vTaskSetTimeOutState( pxTimeOut );
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       vTaskSetTimeOutState
;;;3065   			xReturn = pdFALSE;
000076  2600              MOVS     r6,#0
000078  e000              B        |L41.124|
                  |L41.122|
;;;3066   		}
;;;3067   		else
;;;3068   		{
;;;3069   			xReturn = pdTRUE;
00007a  2601              MOVS     r6,#1
                  |L41.124|
;;;3070   		}
;;;3071   	}
;;;3072   	taskEXIT_CRITICAL();
00007c  f7fffffe          BL       vPortExitCritical
;;;3073   
;;;3074   	return xReturn;
000080  4630              MOV      r0,r6
;;;3075   }
000082  bd70              POP      {r4-r6,pc}
;;;3076   /*-----------------------------------------------------------*/
                          ENDP

                  |L41.132|
                          DCD      xTickCount
                  |L41.136|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;677    
;;;678    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;679    							const char * const pcName,
;;;680    							const uint16_t usStackDepth,
;;;681    							void * const pvParameters,
;;;682    							UBaseType_t uxPriority,
;;;683    							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;684    	{
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  e9ddab12          LDRD     r10,r11,[sp,#0x48]
;;;685    	TCB_t *pxNewTCB;
;;;686    	BaseType_t xReturn;
;;;687    
;;;688    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;689    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;690    		the TCB then the stack. */
;;;691    		#if( portSTACK_GROWTH > 0 )
;;;692    		{
;;;693    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;694    			the implementation of the port malloc function and whether or not static
;;;695    			allocation is being used. */
;;;696    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;697    
;;;698    			if( pxNewTCB != NULL )
;;;699    			{
;;;700    				/* Allocate space for the stack used by the task being created.
;;;701    				The base of the stack memory stored in the TCB so the task can
;;;702    				be deleted later if required. */
;;;703    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;704    
;;;705    				if( pxNewTCB->pxStack == NULL )
;;;706    				{
;;;707    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;708    					vPortFree( pxNewTCB );
;;;709    					pxNewTCB = NULL;
;;;710    				}
;;;711    			}
;;;712    		}
;;;713    		#else /* portSTACK_GROWTH */
;;;714    		{
;;;715    		StackType_t *pxStack;
;;;716    
;;;717    			/* Allocate space for the stack used by the task being created. */
;;;718    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000010  00b8              LSLS     r0,r7,#2
000012  f7fffffe          BL       pvPortMalloc
000016  4606              MOV      r6,r0
;;;719    
;;;720    			if( pxStack != NULL )
000018  b156              CBZ      r6,|L42.48|
;;;721    			{
;;;722    				/* Allocate space for the TCB. */
;;;723    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
00001a  205c              MOVS     r0,#0x5c
00001c  f7fffffe          BL       pvPortMalloc
000020  4604              MOV      r4,r0
;;;724    
;;;725    				if( pxNewTCB != NULL )
000022  b10c              CBZ      r4,|L42.40|
;;;726    				{
;;;727    					/* Store the stack location in the TCB. */
;;;728    					pxNewTCB->pxStack = pxStack;
000024  6326              STR      r6,[r4,#0x30]
000026  e004              B        |L42.50|
                  |L42.40|
;;;729    				}
;;;730    				else
;;;731    				{
;;;732    					/* The stack cannot be used as the TCB was not created.  Free
;;;733    					it again. */
;;;734    					vPortFree( pxStack );
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       vPortFree
00002e  e000              B        |L42.50|
                  |L42.48|
;;;735    				}
;;;736    			}
;;;737    			else
;;;738    			{
;;;739    				pxNewTCB = NULL;
000030  2400              MOVS     r4,#0
                  |L42.50|
;;;740    			}
;;;741    		}
;;;742    		#endif /* portSTACK_GROWTH */
;;;743    
;;;744    		if( pxNewTCB != NULL )
000032  b17c              CBZ      r4,|L42.84|
;;;745    		{
;;;746    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;;;747    			{
;;;748    				/* Tasks can be created statically or dynamically, so note this
;;;749    				task was created dynamically in case it is later deleted. */
;;;750    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;751    			}
;;;752    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;753    
;;;754    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000034  2000              MOVS     r0,#0
000036  e9cdab00          STRD     r10,r11,[sp,#0]
00003a  e9cd4002          STRD     r4,r0,[sp,#8]
00003e  463a              MOV      r2,r7
000040  4649              MOV      r1,r9
000042  4640              MOV      r0,r8
000044  9b08              LDR      r3,[sp,#0x20]
000046  f7fffffe          BL       prvInitialiseNewTask
;;;755    			prvAddNewTaskToReadyList( pxNewTCB );
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       prvAddNewTaskToReadyList
;;;756    			xReturn = pdPASS;
000050  2501              MOVS     r5,#1
000052  e001              B        |L42.88|
                  |L42.84|
;;;757    		}
;;;758    		else
;;;759    		{
;;;760    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000054  f04f35ff          MOV      r5,#0xffffffff
                  |L42.88|
;;;761    		}
;;;762    
;;;763    		return xReturn;
000058  4628              MOV      r0,r5
;;;764    	}
00005a  b009              ADD      sp,sp,#0x24
00005c  e8bd8ff0          POP      {r4-r11,pc}
;;;765    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4344   
;;;4345   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4346   	{
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;4347   	TCB_t * pxTCB;
;;;4348   	BaseType_t xReturn = pdPASS;
00000c  f04f0a01          MOV      r10,#1
;;;4349   	uint8_t ucOriginalNotifyState;
;;;4350   
;;;4351   		configASSERT( xTaskToNotify );
000010  b956              CBNZ     r6,|L43.40|
000012  bf00              NOP      
000014  2030              MOVS     r0,#0x30
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L43.38|
000026  e7fe              B        |L43.38|
                  |L43.40|
;;;4352   		pxTCB = ( TCB_t * ) xTaskToNotify;
000028  4634              MOV      r4,r6
;;;4353   
;;;4354   		taskENTER_CRITICAL();
00002a  f7fffffe          BL       vPortEnterCritical
;;;4355   		{
;;;4356   			if( pulPreviousNotificationValue != NULL )
00002e  f1b80f00          CMP      r8,#0
000032  d002              BEQ      |L43.58|
;;;4357   			{
;;;4358   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000034  6d60              LDR      r0,[r4,#0x54]
000036  f8c80000          STR      r0,[r8,#0]
                  |L43.58|
;;;4359   			}
;;;4360   
;;;4361   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00003a  f8949058          LDRB     r9,[r4,#0x58]
;;;4362   
;;;4363   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00003e  2002              MOVS     r0,#2
000040  f8840058          STRB     r0,[r4,#0x58]
;;;4364   
;;;4365   			switch( eAction )
000044  2f05              CMP      r7,#5
000046  d217              BCS      |L43.120|
000048  e8dff007          TBB      [pc,r7]
00004c  1503070b          DCB      0x15,0x03,0x07,0x0b
000050  0d00              DCB      0x0d,0x00
;;;4366   			{
;;;4367   				case eSetBits	:
;;;4368   					pxTCB->ulNotifiedValue |= ulValue;
000052  6d60              LDR      r0,[r4,#0x54]
000054  4328              ORRS     r0,r0,r5
000056  6560              STR      r0,[r4,#0x54]
;;;4369   					break;
000058  e00e              B        |L43.120|
;;;4370   
;;;4371   				case eIncrement	:
;;;4372   					( pxTCB->ulNotifiedValue )++;
00005a  6d60              LDR      r0,[r4,#0x54]
00005c  1c40              ADDS     r0,r0,#1
00005e  6560              STR      r0,[r4,#0x54]
;;;4373   					break;
000060  e00a              B        |L43.120|
;;;4374   
;;;4375   				case eSetValueWithOverwrite	:
;;;4376   					pxTCB->ulNotifiedValue = ulValue;
000062  6565              STR      r5,[r4,#0x54]
;;;4377   					break;
000064  e008              B        |L43.120|
;;;4378   
;;;4379   				case eSetValueWithoutOverwrite :
;;;4380   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000066  f1b90f02          CMP      r9,#2
00006a  d001              BEQ      |L43.112|
;;;4381   					{
;;;4382   						pxTCB->ulNotifiedValue = ulValue;
00006c  6565              STR      r5,[r4,#0x54]
00006e  e001              B        |L43.116|
                  |L43.112|
;;;4383   					}
;;;4384   					else
;;;4385   					{
;;;4386   						/* The value could not be written to the task. */
;;;4387   						xReturn = pdFAIL;
000070  f04f0a00          MOV      r10,#0
                  |L43.116|
;;;4388   					}
;;;4389   					break;
000074  e000              B        |L43.120|
;;;4390   
;;;4391   				case eNoAction:
;;;4392   					/* The task is being notified without its notify value being
;;;4393   					updated. */
;;;4394   					break;
000076  bf00              NOP      
                  |L43.120|
000078  bf00              NOP                            ;4369
;;;4395   			}
;;;4396   
;;;4397   			traceTASK_NOTIFY();
;;;4398   
;;;4399   			/* If the task is in the blocked state specifically to wait for a
;;;4400   			notification then unblock it now. */
;;;4401   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00007a  f1b90f01          CMP      r9,#1
00007e  d133              BNE      |L43.232|
;;;4402   			{
;;;4403   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000080  1d20              ADDS     r0,r4,#4
000082  f7fffffe          BL       uxListRemove
;;;4404   				prvAddTaskToReadyList( pxTCB );
000086  f894102c          LDRB     r1,[r4,#0x2c]
00008a  2001              MOVS     r0,#1
00008c  4088              LSLS     r0,r0,r1
00008e  4919              LDR      r1,|L43.244|
000090  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000092  4308              ORRS     r0,r0,r1
000094  4917              LDR      r1,|L43.244|
000096  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000098  6ae1              LDR      r1,[r4,#0x2c]
00009a  eb010181          ADD      r1,r1,r1,LSL #2
00009e  4a16              LDR      r2,|L43.248|
0000a0  eb020081          ADD      r0,r2,r1,LSL #2
0000a4  1d21              ADDS     r1,r4,#4
0000a6  f7fffffe          BL       vListInsertEnd
;;;4405   
;;;4406   				/* The task should not have been on an event list. */
;;;4407   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000aa  6aa0              LDR      r0,[r4,#0x28]
0000ac  b908              CBNZ     r0,|L43.178|
0000ae  2001              MOVS     r0,#1
0000b0  e000              B        |L43.180|
                  |L43.178|
0000b2  2000              MOVS     r0,#0
                  |L43.180|
0000b4  b950              CBNZ     r0,|L43.204|
0000b6  bf00              NOP      
0000b8  2030              MOVS     r0,#0x30
0000ba  f3808811          MSR      BASEPRI,r0
0000be  f3bf8f4f          DSB      
0000c2  f3bf8f6f          ISB      
0000c6  bf00              NOP      
0000c8  bf00              NOP      
                  |L43.202|
0000ca  e7fe              B        |L43.202|
                  |L43.204|
;;;4408   
;;;4409   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4410   				{
;;;4411   					/* If a task is blocked waiting for a notification then
;;;4412   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4413   					out time.  If the task is unblocked for a reason other than
;;;4414   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4415   					because it will automatically get reset to a new value when
;;;4416   					the tick count equals xNextTaskUnblockTime.  However if
;;;4417   					tickless idling is used it might be more important to enter
;;;4418   					sleep mode at the earliest possible time - so reset
;;;4419   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4420   					earliest possible time. */
;;;4421   					prvResetNextTaskUnblockTime();
;;;4422   				}
;;;4423   				#endif
;;;4424   
;;;4425   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000cc  490b              LDR      r1,|L43.252|
0000ce  6ae0              LDR      r0,[r4,#0x2c]
0000d0  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000d2  6ac9              LDR      r1,[r1,#0x2c]
0000d4  4288              CMP      r0,r1
0000d6  d907              BLS      |L43.232|
;;;4426   				{
;;;4427   					/* The notified task has a priority above the currently
;;;4428   					executing task so a yield is required. */
;;;4429   					taskYIELD_IF_USING_PREEMPTION();
0000d8  f04f5080          MOV      r0,#0x10000000
0000dc  4908              LDR      r1,|L43.256|
0000de  6008              STR      r0,[r1,#0]
0000e0  f3bf8f4f          DSB      
0000e4  f3bf8f6f          ISB      
                  |L43.232|
;;;4430   				}
;;;4431   				else
;;;4432   				{
;;;4433   					mtCOVERAGE_TEST_MARKER();
;;;4434   				}
;;;4435   			}
;;;4436   			else
;;;4437   			{
;;;4438   				mtCOVERAGE_TEST_MARKER();
;;;4439   			}
;;;4440   		}
;;;4441   		taskEXIT_CRITICAL();
0000e8  f7fffffe          BL       vPortExitCritical
;;;4442   
;;;4443   		return xReturn;
0000ec  4650              MOV      r0,r10
;;;4444   	}
0000ee  e8bd87f0          POP      {r4-r10,pc}
;;;4445   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L43.244|
                          DCD      uxTopReadyPriority
                  |L43.248|
                          DCD      pxReadyTasksLists
                  |L43.252|
                          DCD      pxCurrentTCB
                  |L43.256|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4450   
;;;4451   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4452   	{
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;4453   	TCB_t * pxTCB;
;;;4454   	uint8_t ucOriginalNotifyState;
;;;4455   	BaseType_t xReturn = pdPASS;
000010  2001              MOVS     r0,#1
000012  9000              STR      r0,[sp,#0]
;;;4456   	UBaseType_t uxSavedInterruptStatus;
;;;4457   
;;;4458   		configASSERT( xTaskToNotify );
000014  b957              CBNZ     r7,|L44.44|
000016  bf00              NOP      
000018  2030              MOVS     r0,#0x30
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L44.42|
00002a  e7fe              B        |L44.42|
                  |L44.44|
;;;4459   
;;;4460   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4461   		maximum	system call (or maximum API call) interrupt priority.
;;;4462   		Interrupts that are	above the maximum system call priority are keep
;;;4463   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4464   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4465   		is defined in FreeRTOSConfig.h then
;;;4466   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4467   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4468   		been assigned a priority above the configured maximum system call
;;;4469   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4470   		from interrupts	that have been assigned a priority at or (logically)
;;;4471   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4472   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4473   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4474   		provided on the following link:
;;;4475   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4476   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00002c  f7fffffe          BL       vPortValidateInterruptPriority
;;;4477   
;;;4478   		pxTCB = ( TCB_t * ) xTaskToNotify;
000030  463c              MOV      r4,r7
;;;4479   
;;;4480   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000032  bf00              NOP      
000034  2130              MOVS     r1,#0x30
000036  f3ef8011          MRS      r0,BASEPRI
00003a  f3818811          MSR      BASEPRI,r1
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  4605              MOV      r5,r0
;;;4481   		{
;;;4482   			if( pulPreviousNotificationValue != NULL )
00004a  f1b90f00          CMP      r9,#0
00004e  d002              BEQ      |L44.86|
;;;4483   			{
;;;4484   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000050  6d60              LDR      r0,[r4,#0x54]
000052  f8c90000          STR      r0,[r9,#0]
                  |L44.86|
;;;4485   			}
;;;4486   
;;;4487   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000056  f894a058          LDRB     r10,[r4,#0x58]
;;;4488   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00005a  2002              MOVS     r0,#2
00005c  f8840058          STRB     r0,[r4,#0x58]
;;;4489   
;;;4490   			switch( eAction )
000060  f1b80f05          CMP      r8,#5
000064  d217              BCS      |L44.150|
000066  e8dff008          TBB      [pc,r8]
00006a  1503              DCB      0x15,0x03
00006c  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4491   			{
;;;4492   				case eSetBits	:
;;;4493   					pxTCB->ulNotifiedValue |= ulValue;
000070  6d60              LDR      r0,[r4,#0x54]
000072  4330              ORRS     r0,r0,r6
000074  6560              STR      r0,[r4,#0x54]
;;;4494   					break;
000076  e00e              B        |L44.150|
;;;4495   
;;;4496   				case eIncrement	:
;;;4497   					( pxTCB->ulNotifiedValue )++;
000078  6d60              LDR      r0,[r4,#0x54]
00007a  1c40              ADDS     r0,r0,#1
00007c  6560              STR      r0,[r4,#0x54]
;;;4498   					break;
00007e  e00a              B        |L44.150|
;;;4499   
;;;4500   				case eSetValueWithOverwrite	:
;;;4501   					pxTCB->ulNotifiedValue = ulValue;
000080  6566              STR      r6,[r4,#0x54]
;;;4502   					break;
000082  e008              B        |L44.150|
;;;4503   
;;;4504   				case eSetValueWithoutOverwrite :
;;;4505   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000084  f1ba0f02          CMP      r10,#2
000088  d001              BEQ      |L44.142|
;;;4506   					{
;;;4507   						pxTCB->ulNotifiedValue = ulValue;
00008a  6566              STR      r6,[r4,#0x54]
00008c  e001              B        |L44.146|
                  |L44.142|
;;;4508   					}
;;;4509   					else
;;;4510   					{
;;;4511   						/* The value could not be written to the task. */
;;;4512   						xReturn = pdFAIL;
00008e  2000              MOVS     r0,#0
000090  9000              STR      r0,[sp,#0]
                  |L44.146|
;;;4513   					}
;;;4514   					break;
000092  e000              B        |L44.150|
;;;4515   
;;;4516   				case eNoAction :
;;;4517   					/* The task is being notified without its notify value being
;;;4518   					updated. */
;;;4519   					break;
000094  bf00              NOP      
                  |L44.150|
000096  bf00              NOP                            ;4494
;;;4520   			}
;;;4521   
;;;4522   			traceTASK_NOTIFY_FROM_ISR();
;;;4523   
;;;4524   			/* If the task is in the blocked state specifically to wait for a
;;;4525   			notification then unblock it now. */
;;;4526   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000098  f1ba0f01          CMP      r10,#1
00009c  d13e              BNE      |L44.284|
;;;4527   			{
;;;4528   				/* The task should not have been on an event list. */
;;;4529   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
00009e  6aa0              LDR      r0,[r4,#0x28]
0000a0  b908              CBNZ     r0,|L44.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L44.168|
                  |L44.166|
0000a6  2000              MOVS     r0,#0
                  |L44.168|
0000a8  b950              CBNZ     r0,|L44.192|
0000aa  bf00              NOP      
0000ac  2030              MOVS     r0,#0x30
0000ae  f3808811          MSR      BASEPRI,r0
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
0000ba  bf00              NOP      
0000bc  bf00              NOP      
                  |L44.190|
0000be  e7fe              B        |L44.190|
                  |L44.192|
;;;4530   
;;;4531   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0000c0  481a              LDR      r0,|L44.300|
0000c2  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0000c4  b9a8              CBNZ     r0,|L44.242|
;;;4532   				{
;;;4533   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000c6  1d20              ADDS     r0,r4,#4
0000c8  f7fffffe          BL       uxListRemove
;;;4534   					prvAddTaskToReadyList( pxTCB );
0000cc  f894102c          LDRB     r1,[r4,#0x2c]
0000d0  2001              MOVS     r0,#1
0000d2  4088              LSLS     r0,r0,r1
0000d4  4916              LDR      r1,|L44.304|
0000d6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000d8  4308              ORRS     r0,r0,r1
0000da  4915              LDR      r1,|L44.304|
0000dc  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000de  6ae1              LDR      r1,[r4,#0x2c]
0000e0  eb010181          ADD      r1,r1,r1,LSL #2
0000e4  4a13              LDR      r2,|L44.308|
0000e6  eb020081          ADD      r0,r2,r1,LSL #2
0000ea  1d21              ADDS     r1,r4,#4
0000ec  f7fffffe          BL       vListInsertEnd
0000f0  e004              B        |L44.252|
                  |L44.242|
;;;4535   				}
;;;4536   				else
;;;4537   				{
;;;4538   					/* The delayed and ready lists cannot be accessed, so hold
;;;4539   					this task pending until the scheduler is resumed. */
;;;4540   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000f2  f1040118          ADD      r1,r4,#0x18
0000f6  4810              LDR      r0,|L44.312|
0000f8  f7fffffe          BL       vListInsertEnd
                  |L44.252|
;;;4541   				}
;;;4542   
;;;4543   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000fc  490f              LDR      r1,|L44.316|
0000fe  6ae0              LDR      r0,[r4,#0x2c]
000100  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000102  6ac9              LDR      r1,[r1,#0x2c]
000104  4288              CMP      r0,r1
000106  d909              BLS      |L44.284|
;;;4544   				{
;;;4545   					/* The notified task has a priority above the currently
;;;4546   					executing task so a yield is required. */
;;;4547   					if( pxHigherPriorityTaskWoken != NULL )
000108  f1bb0f00          CMP      r11,#0
00010c  d003              BEQ      |L44.278|
;;;4548   					{
;;;4549   						*pxHigherPriorityTaskWoken = pdTRUE;
00010e  2001              MOVS     r0,#1
000110  f8cb0000          STR      r0,[r11,#0]
000114  e002              B        |L44.284|
                  |L44.278|
;;;4550   					}
;;;4551   					else
;;;4552   					{
;;;4553   						/* Mark that a yield is pending in case the user is not
;;;4554   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4555   						safe FreeRTOS function. */
;;;4556   						xYieldPending = pdTRUE;
000116  2001              MOVS     r0,#1
000118  4909              LDR      r1,|L44.320|
00011a  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L44.284|
;;;4557   					}
;;;4558   				}
;;;4559   				else
;;;4560   				{
;;;4561   					mtCOVERAGE_TEST_MARKER();
;;;4562   				}
;;;4563   			}
;;;4564   		}
;;;4565   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00011c  bf00              NOP      
00011e  f3858811          MSR      BASEPRI,r5
000122  bf00              NOP      
;;;4566   
;;;4567   		return xReturn;
000124  9800              LDR      r0,[sp,#0]
;;;4568   	}
000126  e8bd8ff8          POP      {r3-r11,pc}
;;;4569   
                          ENDP

00012a  0000              DCW      0x0000
                  |L44.300|
                          DCD      uxSchedulerSuspended
                  |L44.304|
                          DCD      uxTopReadyPriority
                  |L44.308|
                          DCD      pxReadyTasksLists
                  |L44.312|
                          DCD      xPendingReadyList
                  |L44.316|
                          DCD      pxCurrentTCB
                  |L44.320|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3662   
;;;3663   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L45.8|
;;;3664   	{
;;;3665   	TaskHandle_t xReturn;
;;;3666   
;;;3667   		/* A critical section is not required as this is not called from
;;;3668   		an interrupt and the current TCB will always be the same for any
;;;3669   		individual execution thread. */
;;;3670   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3671   
;;;3672   		return xReturn;
;;;3673   	}
000004  4770              BX       lr
;;;3674   
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3679   
;;;3680   	BaseType_t xTaskGetSchedulerState( void )
000000  4905              LDR      r1,|L46.24|
;;;3681   	{
;;;3682   	BaseType_t xReturn;
;;;3683   
;;;3684   		if( xSchedulerRunning == pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000004  b909              CBNZ     r1,|L46.10|
;;;3685   		{
;;;3686   			xReturn = taskSCHEDULER_NOT_STARTED;
000006  2001              MOVS     r0,#1
000008  e005              B        |L46.22|
                  |L46.10|
;;;3687   		}
;;;3688   		else
;;;3689   		{
;;;3690   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000a  4904              LDR      r1,|L46.28|
00000c  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
00000e  b909              CBNZ     r1,|L46.20|
;;;3691   			{
;;;3692   				xReturn = taskSCHEDULER_RUNNING;
000010  2002              MOVS     r0,#2
000012  e000              B        |L46.22|
                  |L46.20|
;;;3693   			}
;;;3694   			else
;;;3695   			{
;;;3696   				xReturn = taskSCHEDULER_SUSPENDED;
000014  2000              MOVS     r0,#0
                  |L46.22|
;;;3697   			}
;;;3698   		}
;;;3699   
;;;3700   		return xReturn;
;;;3701   	}
000016  4770              BX       lr
;;;3702   
                          ENDP

                  |L46.24|
                          DCD      xSchedulerRunning
                  |L46.28|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2128   
;;;2129   TickType_t xTaskGetTickCount( void )
000000  4901              LDR      r1,|L47.8|
;;;2130   {
;;;2131   TickType_t xTicks;
;;;2132   
;;;2133   	/* Critical section required if running on a 16 bit processor. */
;;;2134   	portTICK_TYPE_ENTER_CRITICAL();
;;;2135   	{
;;;2136   		xTicks = xTickCount;
000002  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;2137   	}
;;;2138   	portTICK_TYPE_EXIT_CRITICAL();
;;;2139   
;;;2140   	return xTicks;
;;;2141   }
000004  4770              BX       lr
;;;2142   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L47.8|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2143   
;;;2144   TickType_t xTaskGetTickCountFromISR( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2145   {
;;;2146   TickType_t xReturn;
;;;2147   UBaseType_t uxSavedInterruptStatus;
;;;2148   
;;;2149   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2150   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2151   	above the maximum system call priority are kept permanently enabled, even
;;;2152   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2153   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2154   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2155   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2156   	assigned a priority above the configured maximum system call priority.
;;;2157   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2158   	that have been assigned a priority at or (logically) below the maximum
;;;2159   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2160   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2161   	More information (albeit Cortex-M specific) is provided on the following
;;;2162   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2163   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000002  f7fffffe          BL       vPortValidateInterruptPriority
;;;2164   
;;;2165   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
000006  2500              MOVS     r5,#0
;;;2166   	{
;;;2167   		xReturn = xTickCount;
000008  4801              LDR      r0,|L48.16|
00000a  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;2168   	}
;;;2169   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2170   
;;;2171   	return xReturn;
00000c  4620              MOV      r0,r4
;;;2172   }
00000e  bd70              POP      {r4-r6,pc}
;;;2173   /*-----------------------------------------------------------*/
                          ENDP

                  |L48.16|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2500   
;;;2501   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2502   {
;;;2503   TCB_t * pxTCB;
;;;2504   TickType_t xItemValue;
;;;2505   BaseType_t xSwitchRequired = pdFALSE;
000004  f04f0800          MOV      r8,#0
;;;2506   
;;;2507   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2508   	Increments the tick then checks to see if the new tick value will cause any
;;;2509   	tasks to be unblocked. */
;;;2510   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2511   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  4844              LDR      r0,|L49.284|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  2800              CMP      r0,#0
00000e  d177              BNE      |L49.256|
;;;2512   	{
;;;2513   		/* Minor optimisation.  The tick count cannot change in this
;;;2514   		block. */
;;;2515   		const TickType_t xConstTickCount = xTickCount + 1;
000010  4843              LDR      r0,|L49.288|
000012  6800              LDR      r0,[r0,#0]  ; xTickCount
000014  1c45              ADDS     r5,r0,#1
;;;2516   
;;;2517   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2518   		delayed lists if it wraps to 0. */
;;;2519   		xTickCount = xConstTickCount;
000016  4842              LDR      r0,|L49.288|
000018  6005              STR      r5,[r0,#0]  ; xTickCount
;;;2520   
;;;2521   		if( xConstTickCount == ( TickType_t ) 0U )
00001a  bb15              CBNZ     r5,|L49.98|
;;;2522   		{
;;;2523   			taskSWITCH_DELAYED_LISTS();
00001c  4841              LDR      r0,|L49.292|
00001e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000020  6800              LDR      r0,[r0,#0]
000022  b908              CBNZ     r0,|L49.40|
000024  2001              MOVS     r0,#1
000026  e000              B        |L49.42|
                  |L49.40|
000028  2000              MOVS     r0,#0
                  |L49.42|
00002a  b950              CBNZ     r0,|L49.66|
00002c  bf00              NOP      
00002e  2030              MOVS     r0,#0x30
000030  f3808811          MSR      BASEPRI,r0
000034  f3bf8f4f          DSB      
000038  f3bf8f6f          ISB      
00003c  bf00              NOP      
00003e  bf00              NOP      
                  |L49.64|
000040  e7fe              B        |L49.64|
                  |L49.66|
000042  4838              LDR      r0,|L49.292|
000044  6807              LDR      r7,[r0,#0]  ; pxDelayedTaskList
000046  4838              LDR      r0,|L49.296|
000048  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
00004a  4936              LDR      r1,|L49.292|
00004c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
00004e  4836              LDR      r0,|L49.296|
000050  6007              STR      r7,[r0,#0]  ; pxOverflowDelayedTaskList
000052  4836              LDR      r0,|L49.300|
000054  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000056  1c40              ADDS     r0,r0,#1
000058  4934              LDR      r1,|L49.300|
00005a  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
00005c  f7fffffe          BL       prvResetNextTaskUnblockTime
000060  bf00              NOP      
                  |L49.98|
;;;2524   		}
;;;2525   		else
;;;2526   		{
;;;2527   			mtCOVERAGE_TEST_MARKER();
;;;2528   		}
;;;2529   
;;;2530   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2531   		the	queue in the order of their wake time - meaning once one task
;;;2532   		has been found whose block time has not expired there is no need to
;;;2533   		look any further down the list. */
;;;2534   		if( xConstTickCount >= xNextTaskUnblockTime )
000062  4833              LDR      r0,|L49.304|
000064  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000066  4285              CMP      r5,r0
000068  d33c              BCC      |L49.228|
;;;2535   		{
;;;2536   			for( ;; )
00006a  bf00              NOP      
                  |L49.108|
;;;2537   			{
;;;2538   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
00006c  482d              LDR      r0,|L49.292|
00006e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000070  6800              LDR      r0,[r0,#0]
000072  b908              CBNZ     r0,|L49.120|
000074  2001              MOVS     r0,#1
000076  e000              B        |L49.122|
                  |L49.120|
000078  2000              MOVS     r0,#0
                  |L49.122|
00007a  b120              CBZ      r0,|L49.134|
;;;2539   				{
;;;2540   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2541   					to the maximum possible value so it is extremely
;;;2542   					unlikely that the
;;;2543   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2544   					next time through. */
;;;2545   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00007c  f04f30ff          MOV      r0,#0xffffffff
000080  492b              LDR      r1,|L49.304|
000082  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2546   					break;
000084  e02d              B        |L49.226|
                  |L49.134|
;;;2547   				}
;;;2548   				else
;;;2549   				{
;;;2550   					/* The delayed list is not empty, get the value of the
;;;2551   					item at the head of the delayed list.  This is the time
;;;2552   					at which the task at the head of the delayed list must
;;;2553   					be removed from the Blocked state. */
;;;2554   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000086  4827              LDR      r0,|L49.292|
000088  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00008a  68c0              LDR      r0,[r0,#0xc]
00008c  68c4              LDR      r4,[r0,#0xc]
;;;2555   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
00008e  6866              LDR      r6,[r4,#4]
;;;2556   
;;;2557   					if( xConstTickCount < xItemValue )
000090  42b5              CMP      r5,r6
000092  d202              BCS      |L49.154|
;;;2558   					{
;;;2559   						/* It is not time to unblock this item yet, but the
;;;2560   						item value is the time at which the task at the head
;;;2561   						of the blocked list must be removed from the Blocked
;;;2562   						state -	so record the item value in
;;;2563   						xNextTaskUnblockTime. */
;;;2564   						xNextTaskUnblockTime = xItemValue;
000094  4826              LDR      r0,|L49.304|
000096  6006              STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2565   						break;
000098  e023              B        |L49.226|
                  |L49.154|
;;;2566   					}
;;;2567   					else
;;;2568   					{
;;;2569   						mtCOVERAGE_TEST_MARKER();
;;;2570   					}
;;;2571   
;;;2572   					/* It is time to remove the item from the Blocked state. */
;;;2573   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00009a  1d20              ADDS     r0,r4,#4
00009c  f7fffffe          BL       uxListRemove
;;;2574   
;;;2575   					/* Is the task waiting on an event also?  If so remove
;;;2576   					it from the event list. */
;;;2577   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0000a0  6aa0              LDR      r0,[r4,#0x28]
0000a2  b118              CBZ      r0,|L49.172|
;;;2578   					{
;;;2579   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0000a4  f1040018          ADD      r0,r4,#0x18
0000a8  f7fffffe          BL       uxListRemove
                  |L49.172|
;;;2580   					}
;;;2581   					else
;;;2582   					{
;;;2583   						mtCOVERAGE_TEST_MARKER();
;;;2584   					}
;;;2585   
;;;2586   					/* Place the unblocked task into the appropriate ready
;;;2587   					list. */
;;;2588   					prvAddTaskToReadyList( pxTCB );
0000ac  f894102c          LDRB     r1,[r4,#0x2c]
0000b0  2001              MOVS     r0,#1
0000b2  4088              LSLS     r0,r0,r1
0000b4  491f              LDR      r1,|L49.308|
0000b6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b8  4308              ORRS     r0,r0,r1
0000ba  491e              LDR      r1,|L49.308|
0000bc  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000be  6ae1              LDR      r1,[r4,#0x2c]
0000c0  eb010181          ADD      r1,r1,r1,LSL #2
0000c4  4a1c              LDR      r2,|L49.312|
0000c6  eb020081          ADD      r0,r2,r1,LSL #2
0000ca  1d21              ADDS     r1,r4,#4
0000cc  f7fffffe          BL       vListInsertEnd
;;;2589   
;;;2590   					/* A task being unblocked cannot cause an immediate
;;;2591   					context switch if preemption is turned off. */
;;;2592   					#if (  configUSE_PREEMPTION == 1 )
;;;2593   					{
;;;2594   						/* Preemption is on, but a context switch should
;;;2595   						only be performed if the unblocked task has a
;;;2596   						priority that is equal to or higher than the
;;;2597   						currently executing task. */
;;;2598   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000d0  491a              LDR      r1,|L49.316|
0000d2  6ae0              LDR      r0,[r4,#0x2c]
0000d4  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000d6  6ac9              LDR      r1,[r1,#0x2c]
0000d8  4288              CMP      r0,r1
0000da  d3c7              BCC      |L49.108|
;;;2599   						{
;;;2600   							xSwitchRequired = pdTRUE;
0000dc  f04f0801          MOV      r8,#1
0000e0  e7c4              B        |L49.108|
                  |L49.226|
0000e2  bf00              NOP                            ;2546
                  |L49.228|
;;;2601   						}
;;;2602   						else
;;;2603   						{
;;;2604   							mtCOVERAGE_TEST_MARKER();
;;;2605   						}
;;;2606   					}
;;;2607   					#endif /* configUSE_PREEMPTION */
;;;2608   				}
;;;2609   			}
;;;2610   		}
;;;2611   
;;;2612   		/* Tasks of equal priority to the currently running task will share
;;;2613   		processing time (time slice) if preemption is on, and the application
;;;2614   		writer has not explicitly turned time slicing off. */
;;;2615   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2616   		{
;;;2617   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0000e4  4815              LDR      r0,|L49.316|
0000e6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000e8  6ac0              LDR      r0,[r0,#0x2c]
0000ea  eb000080          ADD      r0,r0,r0,LSL #2
0000ee  4912              LDR      r1,|L49.312|
0000f0  f8510020          LDR      r0,[r1,r0,LSL #2]
0000f4  2801              CMP      r0,#1
0000f6  d901              BLS      |L49.252|
;;;2618   			{
;;;2619   				xSwitchRequired = pdTRUE;
0000f8  f04f0801          MOV      r8,#1
                  |L49.252|
;;;2620   			}
;;;2621   			else
;;;2622   			{
;;;2623   				mtCOVERAGE_TEST_MARKER();
;;;2624   			}
;;;2625   		}
;;;2626   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2627   
;;;2628   		#if ( configUSE_TICK_HOOK == 1 )
;;;2629   		{
;;;2630   			/* Guard against the tick hook being called when the pended tick
;;;2631   			count is being unwound (when the scheduler is being unlocked). */
;;;2632   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2633   			{
;;;2634   				vApplicationTickHook();
;;;2635   			}
;;;2636   			else
;;;2637   			{
;;;2638   				mtCOVERAGE_TEST_MARKER();
;;;2639   			}
;;;2640   		}
;;;2641   		#endif /* configUSE_TICK_HOOK */
;;;2642   	}
0000fc  e005              B        |L49.266|
0000fe  e7ff              B        |L49.256|
                  |L49.256|
;;;2643   	else
;;;2644   	{
;;;2645   		++uxPendedTicks;
000100  480f              LDR      r0,|L49.320|
000102  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
000104  1c40              ADDS     r0,r0,#1
000106  490e              LDR      r1,|L49.320|
000108  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L49.266|
;;;2646   
;;;2647   		/* The tick hook gets called at regular intervals, even if the
;;;2648   		scheduler is locked. */
;;;2649   		#if ( configUSE_TICK_HOOK == 1 )
;;;2650   		{
;;;2651   			vApplicationTickHook();
;;;2652   		}
;;;2653   		#endif
;;;2654   	}
;;;2655   
;;;2656   	#if ( configUSE_PREEMPTION == 1 )
;;;2657   	{
;;;2658   		if( xYieldPending != pdFALSE )
00010a  480e              LDR      r0,|L49.324|
00010c  6800              LDR      r0,[r0,#0]  ; xYieldPending
00010e  b108              CBZ      r0,|L49.276|
;;;2659   		{
;;;2660   			xSwitchRequired = pdTRUE;
000110  f04f0801          MOV      r8,#1
                  |L49.276|
;;;2661   		}
;;;2662   		else
;;;2663   		{
;;;2664   			mtCOVERAGE_TEST_MARKER();
;;;2665   		}
;;;2666   	}
;;;2667   	#endif /* configUSE_PREEMPTION */
;;;2668   
;;;2669   	return xSwitchRequired;
000114  4640              MOV      r0,r8
;;;2670   }
000116  e8bd81f0          POP      {r4-r8,pc}
;;;2671   /*-----------------------------------------------------------*/
                          ENDP

00011a  0000              DCW      0x0000
                  |L49.284|
                          DCD      uxSchedulerSuspended
                  |L49.288|
                          DCD      xTickCount
                  |L49.292|
                          DCD      pxDelayedTaskList
                  |L49.296|
                          DCD      pxOverflowDelayedTaskList
                  |L49.300|
                          DCD      xNumOfOverflows
                  |L49.304|
                          DCD      xNextTaskUnblockTime
                  |L49.308|
                          DCD      uxTopReadyPriority
                  |L49.312|
                          DCD      pxReadyTasksLists
                  |L49.316|
                          DCD      pxCurrentTCB
                  |L49.320|
                          DCD      uxPendedTicks
                  |L49.324|
                          DCD      xYieldPending

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4663   
;;;4664   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;4665   	{
000002  4605              MOV      r5,r0
;;;4666   	TCB_t *pxTCB;
;;;4667   	BaseType_t xReturn;
;;;4668   
;;;4669   		/* If null is passed in here then it is the calling task that is having
;;;4670   		its notification state cleared. */
;;;4671   		pxTCB = prvGetTCBFromHandle( xTask );
000004  b915              CBNZ     r5,|L50.12|
000006  480a              LDR      r0,|L50.48|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L50.14|
                  |L50.12|
00000c  4628              MOV      r0,r5
                  |L50.14|
00000e  4606              MOV      r6,r0
;;;4672   
;;;4673   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;4674   		{
;;;4675   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000014  f8960058          LDRB     r0,[r6,#0x58]
000018  2802              CMP      r0,#2
00001a  d104              BNE      |L50.38|
;;;4676   			{
;;;4677   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00001c  2000              MOVS     r0,#0
00001e  f8860058          STRB     r0,[r6,#0x58]
;;;4678   				xReturn = pdPASS;
000022  2401              MOVS     r4,#1
000024  e000              B        |L50.40|
                  |L50.38|
;;;4679   			}
;;;4680   			else
;;;4681   			{
;;;4682   				xReturn = pdFAIL;
000026  2400              MOVS     r4,#0
                  |L50.40|
;;;4683   			}
;;;4684   		}
;;;4685   		taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;4686   
;;;4687   		return xReturn;
00002c  4620              MOV      r0,r4
;;;4688   	}
00002e  bd70              POP      {r4-r6,pc}
;;;4689   
                          ENDP

                  |L50.48|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4264   
;;;4265   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4266   	{
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;4267   	BaseType_t xReturn;
;;;4268   
;;;4269   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4270   		{
;;;4271   			/* Only block if a notification is not already pending. */
;;;4272   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4821              LDR      r0,|L51.152|
000012  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000014  f8900058          LDRB     r0,[r0,#0x58]
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L51.78|
;;;4273   			{
;;;4274   				/* Clear bits in the task's notification value as bits may get
;;;4275   				set	by the notifying task or interrupt.  This can be used to
;;;4276   				clear the value to zero. */
;;;4277   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  491e              LDR      r1,|L51.152|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  f1010054          ADD      r0,r1,#0x54
000024  6d49              LDR      r1,[r1,#0x54]
000026  43b9              BICS     r1,r1,r7
000028  6001              STR      r1,[r0,#0]
;;;4278   
;;;4279   				/* Mark this task as waiting for a notification. */
;;;4280   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
00002a  2001              MOVS     r0,#1
00002c  491a              LDR      r1,|L51.152|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f8810058          STRB     r0,[r1,#0x58]
;;;4281   
;;;4282   				if( xTicksToWait > ( TickType_t ) 0 )
000034  b15d              CBZ      r5,|L51.78|
;;;4283   				{
;;;4284   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4285   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4286   
;;;4287   					/* All ports are written to allow a yield in a critical
;;;4288   					section (some will yield immediately, others wait until the
;;;4289   					critical section exits) - but it is not something that
;;;4290   					application code should ever do. */
;;;4291   					portYIELD_WITHIN_API();
00003e  f04f5080          MOV      r0,#0x10000000
000042  4916              LDR      r1,|L51.156|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L51.78|
;;;4292   				}
;;;4293   				else
;;;4294   				{
;;;4295   					mtCOVERAGE_TEST_MARKER();
;;;4296   				}
;;;4297   			}
;;;4298   			else
;;;4299   			{
;;;4300   				mtCOVERAGE_TEST_MARKER();
;;;4301   			}
;;;4302   		}
;;;4303   		taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;4304   
;;;4305   		taskENTER_CRITICAL();
000052  f7fffffe          BL       vPortEnterCritical
;;;4306   		{
;;;4307   			traceTASK_NOTIFY_WAIT();
;;;4308   
;;;4309   			if( pulNotificationValue != NULL )
000056  b11c              CBZ      r4,|L51.96|
;;;4310   			{
;;;4311   				/* Output the current notification value, which may or may not
;;;4312   				have changed. */
;;;4313   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000058  480f              LDR      r0,|L51.152|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  6d40              LDR      r0,[r0,#0x54]
00005e  6020              STR      r0,[r4,#0]
                  |L51.96|
;;;4314   			}
;;;4315   
;;;4316   			/* If ucNotifyValue is set then either the task never entered the
;;;4317   			blocked state (because a notification was already pending) or the
;;;4318   			task unblocked because of a notification.  Otherwise the task
;;;4319   			unblocked because of a timeout. */
;;;4320   			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000060  480d              LDR      r0,|L51.152|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  f8900058          LDRB     r0,[r0,#0x58]
000068  2801              CMP      r0,#1
00006a  d101              BNE      |L51.112|
;;;4321   			{
;;;4322   				/* A notification was not received. */
;;;4323   				xReturn = pdFALSE;
00006c  2600              MOVS     r6,#0
00006e  e008              B        |L51.130|
                  |L51.112|
;;;4324   			}
;;;4325   			else
;;;4326   			{
;;;4327   				/* A notification was already pending or a notification was
;;;4328   				received while the task was waiting. */
;;;4329   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000070  4909              LDR      r1,|L51.152|
000072  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000074  f1010054          ADD      r0,r1,#0x54
000078  6d49              LDR      r1,[r1,#0x54]
00007a  ea210108          BIC      r1,r1,r8
00007e  6001              STR      r1,[r0,#0]
;;;4330   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
                  |L51.130|
;;;4331   			}
;;;4332   
;;;4333   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000082  2000              MOVS     r0,#0
000084  4904              LDR      r1,|L51.152|
000086  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000088  f8810058          STRB     r0,[r1,#0x58]
;;;4334   		}
;;;4335   		taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;4336   
;;;4337   		return xReturn;
000090  4630              MOV      r0,r6
;;;4338   	}
000092  e8bd81f0          POP      {r4-r8,pc}
;;;4339   
                          ENDP

000096  0000              DCW      0x0000
                  |L51.152|
                          DCD      pxCurrentTCB
                  |L51.156|
                          DCD      0xe000ed04

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;3773   
;;;3774   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3775   	{
000002  4605              MOV      r5,r0
;;;3776   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3777   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;3778   
;;;3779   		if( pxMutexHolder != NULL )
000008  2d00              CMP      r5,#0
00000a  d055              BEQ      |L52.184|
;;;3780   		{
;;;3781   			/* A task can only have an inherited priority if it holds the mutex.
;;;3782   			If the mutex is held by a task then it cannot be given from an
;;;3783   			interrupt, and if a mutex is given by the holding task then it must
;;;3784   			be the running state task. */
;;;3785   			configASSERT( pxTCB == pxCurrentTCB );
00000c  482b              LDR      r0,|L52.188|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  4284              CMP      r4,r0
000012  d101              BNE      |L52.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L52.26|
                  |L52.24|
000018  2000              MOVS     r0,#0
                  |L52.26|
00001a  b950              CBNZ     r0,|L52.50|
00001c  bf00              NOP      
00001e  2030              MOVS     r0,#0x30
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
00002c  bf00              NOP      
00002e  bf00              NOP      
                  |L52.48|
000030  e7fe              B        |L52.48|
                  |L52.50|
;;;3786   
;;;3787   			configASSERT( pxTCB->uxMutexesHeld );
000032  6d20              LDR      r0,[r4,#0x50]
000034  b950              CBNZ     r0,|L52.76|
000036  bf00              NOP      
000038  2030              MOVS     r0,#0x30
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L52.74|
00004a  e7fe              B        |L52.74|
                  |L52.76|
;;;3788   			( pxTCB->uxMutexesHeld )--;
00004c  6d20              LDR      r0,[r4,#0x50]
00004e  1e40              SUBS     r0,r0,#1
000050  6520              STR      r0,[r4,#0x50]
;;;3789   
;;;3790   			/* Has the holder of the mutex inherited the priority of another
;;;3791   			task? */
;;;3792   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000052  6ce1              LDR      r1,[r4,#0x4c]
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  4288              CMP      r0,r1
000058  d02e              BEQ      |L52.184|
;;;3793   			{
;;;3794   				/* Only disinherit if no other mutexes are held. */
;;;3795   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
00005a  6d20              LDR      r0,[r4,#0x50]
00005c  bb60              CBNZ     r0,|L52.184|
;;;3796   				{
;;;3797   					/* A task can only have an inherited priority if it holds
;;;3798   					the mutex.  If the mutex is held by a task then it cannot be
;;;3799   					given from an interrupt, and if a mutex is given by the
;;;3800   					holding	task then it must be the running state task.  Remove
;;;3801   					the	holding task from the ready	list. */
;;;3802   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00005e  1d20              ADDS     r0,r4,#4
000060  f7fffffe          BL       uxListRemove
000064  b978              CBNZ     r0,|L52.134|
;;;3803   					{
;;;3804   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000066  6ae0              LDR      r0,[r4,#0x2c]
000068  eb000080          ADD      r0,r0,r0,LSL #2
00006c  4914              LDR      r1,|L52.192|
00006e  f8510020          LDR      r0,[r1,r0,LSL #2]
000072  b940              CBNZ     r0,|L52.134|
000074  f894102c          LDRB     r1,[r4,#0x2c]
000078  2001              MOVS     r0,#1
00007a  4088              LSLS     r0,r0,r1
00007c  4911              LDR      r1,|L52.196|
00007e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000080  4381              BICS     r1,r1,r0
000082  4810              LDR      r0,|L52.196|
000084  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L52.134|
;;;3805   					}
;;;3806   					else
;;;3807   					{
;;;3808   						mtCOVERAGE_TEST_MARKER();
;;;3809   					}
;;;3810   
;;;3811   					/* Disinherit the priority before adding the task into the
;;;3812   					new	ready list. */
;;;3813   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3814   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000086  6ce0              LDR      r0,[r4,#0x4c]
000088  62e0              STR      r0,[r4,#0x2c]
;;;3815   
;;;3816   					/* Reset the event list item value.  It cannot be in use for
;;;3817   					any other purpose if this task is running, and it must be
;;;3818   					running to give back the mutex. */
;;;3819   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008a  6ae0              LDR      r0,[r4,#0x2c]
00008c  f1c00007          RSB      r0,r0,#7
000090  61a0              STR      r0,[r4,#0x18]
;;;3820   					prvAddTaskToReadyList( pxTCB );
000092  f894102c          LDRB     r1,[r4,#0x2c]
000096  2001              MOVS     r0,#1
000098  4088              LSLS     r0,r0,r1
00009a  490a              LDR      r1,|L52.196|
00009c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00009e  4308              ORRS     r0,r0,r1
0000a0  4908              LDR      r1,|L52.196|
0000a2  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000a4  6ae1              LDR      r1,[r4,#0x2c]
0000a6  eb010181          ADD      r1,r1,r1,LSL #2
0000aa  4a05              LDR      r2,|L52.192|
0000ac  eb020081          ADD      r0,r2,r1,LSL #2
0000b0  1d21              ADDS     r1,r4,#4
0000b2  f7fffffe          BL       vListInsertEnd
;;;3821   
;;;3822   					/* Return true to indicate that a context switch is required.
;;;3823   					This is only actually required in the corner case whereby
;;;3824   					multiple mutexes were held and the mutexes were given back
;;;3825   					in an order different to that in which they were taken.
;;;3826   					If a context switch did not occur when the first mutex was
;;;3827   					returned, even if a task was waiting on it, then a context
;;;3828   					switch should occur when the last mutex is returned whether
;;;3829   					a task is waiting on it or not. */
;;;3830   					xReturn = pdTRUE;
0000b6  2601              MOVS     r6,#1
                  |L52.184|
;;;3831   				}
;;;3832   				else
;;;3833   				{
;;;3834   					mtCOVERAGE_TEST_MARKER();
;;;3835   				}
;;;3836   			}
;;;3837   			else
;;;3838   			{
;;;3839   				mtCOVERAGE_TEST_MARKER();
;;;3840   			}
;;;3841   		}
;;;3842   		else
;;;3843   		{
;;;3844   			mtCOVERAGE_TEST_MARKER();
;;;3845   		}
;;;3846   
;;;3847   		return xReturn;
0000b8  4630              MOV      r0,r6
;;;3848   	}
0000ba  bd70              POP      {r4-r6,pc}
;;;3849   
                          ENDP

                  |L52.188|
                          DCD      pxCurrentTCB
                  |L52.192|
                          DCD      pxReadyTasksLists
                  |L52.196|
                          DCD      uxTopReadyPriority

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2895   
;;;2896   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;2897   {
000002  4606              MOV      r6,r0
;;;2898   TCB_t *pxUnblockedTCB;
;;;2899   BaseType_t xReturn;
;;;2900   
;;;2901   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2902   	called from a critical section within an ISR. */
;;;2903   
;;;2904   	/* The event list is sorted in priority order, so the first in the list can
;;;2905   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2906   	the delayed list, and add it to the ready list.
;;;2907   
;;;2908   	If an event is for a queue that is locked then this function will never
;;;2909   	get called - the lock count on the queue will get modified instead.  This
;;;2910   	means exclusive access to the event list is guaranteed here.
;;;2911   
;;;2912   	This function assumes that a check has already been made to ensure that
;;;2913   	pxEventList is not empty. */
;;;2914   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;2915   	configASSERT( pxUnblockedTCB );
000008  b954              CBNZ     r4,|L53.32|
00000a  bf00              NOP      
00000c  2030              MOVS     r0,#0x30
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L53.30|
00001e  e7fe              B        |L53.30|
                  |L53.32|
;;;2916   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000020  f1040018          ADD      r0,r4,#0x18
000024  f7fffffe          BL       uxListRemove
;;;2917   
;;;2918   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000028  4815              LDR      r0,|L53.128|
00002a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002c  b9a8              CBNZ     r0,|L53.90|
;;;2919   	{
;;;2920   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
00002e  1d20              ADDS     r0,r4,#4
000030  f7fffffe          BL       uxListRemove
;;;2921   		prvAddTaskToReadyList( pxUnblockedTCB );
000034  f894102c          LDRB     r1,[r4,#0x2c]
000038  2001              MOVS     r0,#1
00003a  4088              LSLS     r0,r0,r1
00003c  4911              LDR      r1,|L53.132|
00003e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000040  4308              ORRS     r0,r0,r1
000042  4910              LDR      r1,|L53.132|
000044  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000046  6ae1              LDR      r1,[r4,#0x2c]
000048  eb010181          ADD      r1,r1,r1,LSL #2
00004c  4a0e              LDR      r2,|L53.136|
00004e  eb020081          ADD      r0,r2,r1,LSL #2
000052  1d21              ADDS     r1,r4,#4
000054  f7fffffe          BL       vListInsertEnd
000058  e004              B        |L53.100|
                  |L53.90|
;;;2922   	}
;;;2923   	else
;;;2924   	{
;;;2925   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2926   		pending until the scheduler is resumed. */
;;;2927   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00005a  f1040118          ADD      r1,r4,#0x18
00005e  480b              LDR      r0,|L53.140|
000060  f7fffffe          BL       vListInsertEnd
                  |L53.100|
;;;2928   	}
;;;2929   
;;;2930   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000064  490a              LDR      r1,|L53.144|
000066  6ae0              LDR      r0,[r4,#0x2c]
000068  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00006a  6ac9              LDR      r1,[r1,#0x2c]
00006c  4288              CMP      r0,r1
00006e  d904              BLS      |L53.122|
;;;2931   	{
;;;2932   		/* Return true if the task removed from the event list has a higher
;;;2933   		priority than the calling task.  This allows the calling task to know if
;;;2934   		it should force a context switch now. */
;;;2935   		xReturn = pdTRUE;
000070  2501              MOVS     r5,#1
;;;2936   
;;;2937   		/* Mark that a yield is pending in case the user is not using the
;;;2938   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2939   		xYieldPending = pdTRUE;
000072  2001              MOVS     r0,#1
000074  4907              LDR      r1,|L53.148|
000076  6008              STR      r0,[r1,#0]  ; xYieldPending
000078  e000              B        |L53.124|
                  |L53.122|
;;;2940   	}
;;;2941   	else
;;;2942   	{
;;;2943   		xReturn = pdFALSE;
00007a  2500              MOVS     r5,#0
                  |L53.124|
;;;2944   	}
;;;2945   
;;;2946   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2947   	{
;;;2948   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2949   		might be set to the blocked task's time out time.  If the task is
;;;2950   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2951   		normally left unchanged, because it is automatically reset to a new
;;;2952   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2953   		tickless idling is used it might be more important to enter sleep mode
;;;2954   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2955   		ensure it is updated at the earliest possible time. */
;;;2956   		prvResetNextTaskUnblockTime();
;;;2957   	}
;;;2958   	#endif
;;;2959   
;;;2960   	return xReturn;
00007c  4628              MOV      r0,r5
;;;2961   }
00007e  bd70              POP      {r4-r6,pc}
;;;2962   /*-----------------------------------------------------------*/
                          ENDP

                  |L53.128|
                          DCD      uxSchedulerSuspended
                  |L53.132|
                          DCD      uxTopReadyPriority
                  |L53.136|
                          DCD      pxReadyTasksLists
                  |L53.140|
                          DCD      xPendingReadyList
                  |L53.144|
                          DCD      pxCurrentTCB
                  |L53.148|
                          DCD      xYieldPending

                          AREA ||i.xTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromUnorderedEventList PROC
;;;2963   
;;;2964   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2965   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;2966   TCB_t *pxUnblockedTCB;
;;;2967   BaseType_t xReturn;
;;;2968   
;;;2969   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2970   	the event flags implementation. */
;;;2971   	configASSERT( uxSchedulerSuspended != pdFALSE );
000008  4824              LDR      r0,|L54.156|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b108              CBZ      r0,|L54.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L54.20|
                  |L54.18|
000012  2000              MOVS     r0,#0
                  |L54.20|
000014  b950              CBNZ     r0,|L54.44|
000016  bf00              NOP      
000018  2030              MOVS     r0,#0x30
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L54.42|
00002a  e7fe              B        |L54.42|
                  |L54.44|
;;;2972   
;;;2973   	/* Store the new item value in the event list. */
;;;2974   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00002c  f0474000          ORR      r0,r7,#0x80000000
000030  6028              STR      r0,[r5,#0]
;;;2975   
;;;2976   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2977   	event flags. */
;;;2978   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
000032  68ec              LDR      r4,[r5,#0xc]
;;;2979   	configASSERT( pxUnblockedTCB );
000034  b954              CBNZ     r4,|L54.76|
000036  bf00              NOP      
000038  2030              MOVS     r0,#0x30
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L54.74|
00004a  e7fe              B        |L54.74|
                  |L54.76|
;;;2980   	( void ) uxListRemove( pxEventListItem );
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       uxListRemove
;;;2981   
;;;2982   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2983   	scheduler is suspended so interrupts will not be accessing the ready
;;;2984   	lists. */
;;;2985   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000052  1d20              ADDS     r0,r4,#4
000054  f7fffffe          BL       uxListRemove
;;;2986   	prvAddTaskToReadyList( pxUnblockedTCB );
000058  f894102c          LDRB     r1,[r4,#0x2c]
00005c  2001              MOVS     r0,#1
00005e  4088              LSLS     r0,r0,r1
000060  490f              LDR      r1,|L54.160|
000062  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000064  4308              ORRS     r0,r0,r1
000066  490e              LDR      r1,|L54.160|
000068  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00006a  6ae1              LDR      r1,[r4,#0x2c]
00006c  eb010181          ADD      r1,r1,r1,LSL #2
000070  4a0c              LDR      r2,|L54.164|
000072  eb020081          ADD      r0,r2,r1,LSL #2
000076  1d21              ADDS     r1,r4,#4
000078  f7fffffe          BL       vListInsertEnd
;;;2987   
;;;2988   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00007c  490a              LDR      r1,|L54.168|
00007e  6ae0              LDR      r0,[r4,#0x2c]
000080  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000082  6ac9              LDR      r1,[r1,#0x2c]
000084  4288              CMP      r0,r1
000086  d904              BLS      |L54.146|
;;;2989   	{
;;;2990   		/* Return true if the task removed from the event list has
;;;2991   		a higher priority than the calling task.  This allows
;;;2992   		the calling task to know if it should force a context
;;;2993   		switch now. */
;;;2994   		xReturn = pdTRUE;
000088  2601              MOVS     r6,#1
;;;2995   
;;;2996   		/* Mark that a yield is pending in case the user is not using the
;;;2997   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2998   		xYieldPending = pdTRUE;
00008a  2001              MOVS     r0,#1
00008c  4907              LDR      r1,|L54.172|
00008e  6008              STR      r0,[r1,#0]  ; xYieldPending
000090  e000              B        |L54.148|
                  |L54.146|
;;;2999   	}
;;;3000   	else
;;;3001   	{
;;;3002   		xReturn = pdFALSE;
000092  2600              MOVS     r6,#0
                  |L54.148|
;;;3003   	}
;;;3004   
;;;3005   	return xReturn;
000094  4630              MOV      r0,r6
;;;3006   }
000096  e8bd81f0          POP      {r4-r8,pc}
;;;3007   /*-----------------------------------------------------------*/
                          ENDP

00009a  0000              DCW      0x0000
                  |L54.156|
                          DCD      uxSchedulerSuspended
                  |L54.160|
                          DCD      uxTopReadyPriority
                  |L54.164|
                          DCD      pxReadyTasksLists
                  |L54.168|
                          DCD      pxCurrentTCB
                  |L54.172|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2018   
;;;2019   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2020   {
;;;2021   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2022   BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;2023   
;;;2024   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2025   	previous call to vTaskSuspendAll(). */
;;;2026   	configASSERT( uxSchedulerSuspended );
000006  4836              LDR      r0,|L55.224|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b950              CBNZ     r0,|L55.34|
00000c  bf00              NOP      
00000e  2030              MOVS     r0,#0x30
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L55.32|
000020  e7fe              B        |L55.32|
                  |L55.34|
;;;2027   
;;;2028   	/* It is possible that an ISR caused a task to be removed from an event
;;;2029   	list while the scheduler was suspended.  If this was the case then the
;;;2030   	removed task will have been added to the xPendingReadyList.  Once the
;;;2031   	scheduler has been resumed it is safe to move all the pending ready
;;;2032   	tasks from this list into their appropriate ready list. */
;;;2033   	taskENTER_CRITICAL();
000022  f7fffffe          BL       vPortEnterCritical
;;;2034   	{
;;;2035   		--uxSchedulerSuspended;
000026  482e              LDR      r0,|L55.224|
000028  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002a  1e40              SUBS     r0,r0,#1
00002c  492c              LDR      r1,|L55.224|
00002e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2036   
;;;2037   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000030  4608              MOV      r0,r1
000032  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000034  2800              CMP      r0,#0
000036  d14f              BNE      |L55.216|
;;;2038   		{
;;;2039   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000038  482a              LDR      r0,|L55.228|
00003a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00003c  2800              CMP      r0,#0
00003e  d04b              BEQ      |L55.216|
;;;2040   			{
;;;2041   				/* Move any readied tasks from the pending list into the
;;;2042   				appropriate ready list. */
;;;2043   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000040  e024              B        |L55.140|
                  |L55.66|
;;;2044   				{
;;;2045   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000042  4829              LDR      r0,|L55.232|
000044  68c0              LDR      r0,[r0,#0xc]
000046  68c4              LDR      r4,[r0,#0xc]
;;;2046   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000048  f1040018          ADD      r0,r4,#0x18
00004c  f7fffffe          BL       uxListRemove
;;;2047   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;2048   					prvAddTaskToReadyList( pxTCB );
000056  f894102c          LDRB     r1,[r4,#0x2c]
00005a  2001              MOVS     r0,#1
00005c  4088              LSLS     r0,r0,r1
00005e  4923              LDR      r1,|L55.236|
000060  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000062  4308              ORRS     r0,r0,r1
000064  4921              LDR      r1,|L55.236|
000066  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000068  6ae1              LDR      r1,[r4,#0x2c]
00006a  eb010181          ADD      r1,r1,r1,LSL #2
00006e  4a20              LDR      r2,|L55.240|
000070  eb020081          ADD      r0,r2,r1,LSL #2
000074  1d21              ADDS     r1,r4,#4
000076  f7fffffe          BL       vListInsertEnd
;;;2049   
;;;2050   					/* If the moved task has a priority higher than the current
;;;2051   					task then a yield must be performed. */
;;;2052   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00007a  491e              LDR      r1,|L55.244|
00007c  6ae0              LDR      r0,[r4,#0x2c]
00007e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000080  6ac9              LDR      r1,[r1,#0x2c]
000082  4288              CMP      r0,r1
000084  d302              BCC      |L55.140|
;;;2053   					{
;;;2054   						xYieldPending = pdTRUE;
000086  2001              MOVS     r0,#1
000088  491b              LDR      r1,|L55.248|
00008a  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L55.140|
00008c  4816              LDR      r0,|L55.232|
00008e  6800              LDR      r0,[r0,#0]            ;2043  ; xPendingReadyList
000090  b908              CBNZ     r0,|L55.150|
000092  2001              MOVS     r0,#1                 ;2043
000094  e000              B        |L55.152|
                  |L55.150|
000096  2000              MOVS     r0,#0                 ;2043
                  |L55.152|
000098  2800              CMP      r0,#0                 ;2043
00009a  d0d2              BEQ      |L55.66|
;;;2055   					}
;;;2056   					else
;;;2057   					{
;;;2058   						mtCOVERAGE_TEST_MARKER();
;;;2059   					}
;;;2060   				}
;;;2061   
;;;2062   				if( pxTCB != NULL )
00009c  b10c              CBZ      r4,|L55.162|
;;;2063   				{
;;;2064   					/* A task was unblocked while the scheduler was suspended,
;;;2065   					which may have prevented the next unblock time from being
;;;2066   					re-calculated, in which case re-calculate it now.  Mainly
;;;2067   					important for low power tickless implementations, where
;;;2068   					this can prevent an unnecessary exit from low power
;;;2069   					state. */
;;;2070   					prvResetNextTaskUnblockTime();
00009e  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L55.162|
;;;2071   				}
;;;2072   
;;;2073   				/* If any ticks occurred while the scheduler was suspended then
;;;2074   				they should be processed now.  This ensures the tick count does
;;;2075   				not	slip, and that any delayed tasks are resumed at the correct
;;;2076   				time. */
;;;2077   				{
;;;2078   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
0000a2  4816              LDR      r0,|L55.252|
0000a4  6805              LDR      r5,[r0,#0]  ; uxPendedTicks
;;;2079   
;;;2080   					if( uxPendedCounts > ( UBaseType_t ) 0U )
0000a6  b165              CBZ      r5,|L55.194|
;;;2081   					{
;;;2082   						do
0000a8  bf00              NOP      
                  |L55.170|
;;;2083   						{
;;;2084   							if( xTaskIncrementTick() != pdFALSE )
0000aa  f7fffffe          BL       xTaskIncrementTick
0000ae  b110              CBZ      r0,|L55.182|
;;;2085   							{
;;;2086   								xYieldPending = pdTRUE;
0000b0  2001              MOVS     r0,#1
0000b2  4911              LDR      r1,|L55.248|
0000b4  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L55.182|
;;;2087   							}
;;;2088   							else
;;;2089   							{
;;;2090   								mtCOVERAGE_TEST_MARKER();
;;;2091   							}
;;;2092   							--uxPendedCounts;
0000b6  1e6d              SUBS     r5,r5,#1
;;;2093   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
0000b8  2d00              CMP      r5,#0
0000ba  d1f6              BNE      |L55.170|
;;;2094   
;;;2095   						uxPendedTicks = 0;
0000bc  2000              MOVS     r0,#0
0000be  490f              LDR      r1,|L55.252|
0000c0  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L55.194|
;;;2096   					}
;;;2097   					else
;;;2098   					{
;;;2099   						mtCOVERAGE_TEST_MARKER();
;;;2100   					}
;;;2101   				}
;;;2102   
;;;2103   				if( xYieldPending != pdFALSE )
0000c2  480d              LDR      r0,|L55.248|
0000c4  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000c6  b138              CBZ      r0,|L55.216|
;;;2104   				{
;;;2105   					#if( configUSE_PREEMPTION != 0 )
;;;2106   					{
;;;2107   						xAlreadyYielded = pdTRUE;
0000c8  2601              MOVS     r6,#1
;;;2108   					}
;;;2109   					#endif
;;;2110   					taskYIELD_IF_USING_PREEMPTION();
0000ca  0730              LSLS     r0,r6,#28
0000cc  490c              LDR      r1,|L55.256|
0000ce  6008              STR      r0,[r1,#0]
0000d0  f3bf8f4f          DSB      
0000d4  f3bf8f6f          ISB      
                  |L55.216|
;;;2111   				}
;;;2112   				else
;;;2113   				{
;;;2114   					mtCOVERAGE_TEST_MARKER();
;;;2115   				}
;;;2116   			}
;;;2117   		}
;;;2118   		else
;;;2119   		{
;;;2120   			mtCOVERAGE_TEST_MARKER();
;;;2121   		}
;;;2122   	}
;;;2123   	taskEXIT_CRITICAL();
0000d8  f7fffffe          BL       vPortExitCritical
;;;2124   
;;;2125   	return xAlreadyYielded;
0000dc  4630              MOV      r0,r6
;;;2126   }
0000de  bd70              POP      {r4-r6,pc}
;;;2127   /*-----------------------------------------------------------*/
                          ENDP

                  |L55.224|
                          DCD      uxSchedulerSuspended
                  |L55.228|
                          DCD      uxCurrentNumberOfTasks
                  |L55.232|
                          DCD      xPendingReadyList
                  |L55.236|
                          DCD      uxTopReadyPriority
                  |L55.240|
                          DCD      pxReadyTasksLists
                  |L55.244|
                          DCD      pxCurrentTCB
                  |L55.248|
                          DCD      xYieldPending
                  |L55.252|
                          DCD      uxPendedTicks
                  |L55.256|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1757   
;;;1758   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1759   	{
000004  4606              MOV      r6,r0
;;;1760   	BaseType_t xYieldRequired = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1761   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000008  4634              MOV      r4,r6
;;;1762   	UBaseType_t uxSavedInterruptStatus;
;;;1763   
;;;1764   		configASSERT( xTaskToResume );
00000a  b956              CBNZ     r6,|L56.34|
00000c  bf00              NOP      
00000e  2030              MOVS     r0,#0x30
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L56.32|
000020  e7fe              B        |L56.32|
                  |L56.34|
;;;1765   
;;;1766   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1767   		maximum	system call (or maximum API call) interrupt priority.
;;;1768   		Interrupts that are	above the maximum system call priority are keep
;;;1769   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1770   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1771   		is defined in FreeRTOSConfig.h then
;;;1772   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1773   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1774   		been assigned a priority above the configured maximum system call
;;;1775   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1776   		from interrupts	that have been assigned a priority at or (logically)
;;;1777   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1778   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1779   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1780   		provided on the following link:
;;;1781   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1782   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000022  f7fffffe          BL       vPortValidateInterruptPriority
;;;1783   
;;;1784   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  bf00              NOP      
000028  2130              MOVS     r1,#0x30
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  f3818811          MSR      BASEPRI,r1
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  4605              MOV      r5,r0
;;;1785   		{
;;;1786   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvTaskIsTaskSuspended
000044  b320              CBZ      r0,|L56.144|
;;;1787   			{
;;;1788   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1789   
;;;1790   				/* Check the ready lists can be accessed. */
;;;1791   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000046  4816              LDR      r0,|L56.160|
000048  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00004a  b9e0              CBNZ     r0,|L56.134|
;;;1792   				{
;;;1793   					/* Ready lists can be accessed so move the task from the
;;;1794   					suspended list to the ready list directly. */
;;;1795   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00004c  4915              LDR      r1,|L56.164|
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000052  6ac9              LDR      r1,[r1,#0x2c]
000054  4288              CMP      r0,r1
000056  d300              BCC      |L56.90|
;;;1796   					{
;;;1797   						xYieldRequired = pdTRUE;
000058  2701              MOVS     r7,#1
                  |L56.90|
;;;1798   					}
;;;1799   					else
;;;1800   					{
;;;1801   						mtCOVERAGE_TEST_MARKER();
;;;1802   					}
;;;1803   
;;;1804   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00005a  1d20              ADDS     r0,r4,#4
00005c  f7fffffe          BL       uxListRemove
;;;1805   					prvAddTaskToReadyList( pxTCB );
000060  f894102c          LDRB     r1,[r4,#0x2c]
000064  2001              MOVS     r0,#1
000066  4088              LSLS     r0,r0,r1
000068  490f              LDR      r1,|L56.168|
00006a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00006c  4308              ORRS     r0,r0,r1
00006e  490e              LDR      r1,|L56.168|
000070  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000072  6ae1              LDR      r1,[r4,#0x2c]
000074  eb010181          ADD      r1,r1,r1,LSL #2
000078  4a0c              LDR      r2,|L56.172|
00007a  eb020081          ADD      r0,r2,r1,LSL #2
00007e  1d21              ADDS     r1,r4,#4
000080  f7fffffe          BL       vListInsertEnd
000084  e004              B        |L56.144|
                  |L56.134|
;;;1806   				}
;;;1807   				else
;;;1808   				{
;;;1809   					/* The delayed or ready lists cannot be accessed so the task
;;;1810   					is held in the pending ready list until the scheduler is
;;;1811   					unsuspended. */
;;;1812   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000086  f1040118          ADD      r1,r4,#0x18
00008a  4809              LDR      r0,|L56.176|
00008c  f7fffffe          BL       vListInsertEnd
                  |L56.144|
;;;1813   				}
;;;1814   			}
;;;1815   			else
;;;1816   			{
;;;1817   				mtCOVERAGE_TEST_MARKER();
;;;1818   			}
;;;1819   		}
;;;1820   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000090  bf00              NOP      
000092  f3858811          MSR      BASEPRI,r5
000096  bf00              NOP      
;;;1821   
;;;1822   		return xYieldRequired;
000098  4638              MOV      r0,r7
;;;1823   	}
00009a  e8bd81f0          POP      {r4-r8,pc}
;;;1824   
                          ENDP

00009e  0000              DCW      0x0000
                  |L56.160|
                          DCD      uxSchedulerSuspended
                  |L56.164|
                          DCD      pxCurrentTCB
                  |L56.168|
                          DCD      uxTopReadyPriority
                  |L56.172|
                          DCD      pxReadyTasksLists
                  |L56.176|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        140
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
