L 1 "Source\Ext_Dev\src\MPU-9250_acc_gyro_mag_driver_ll.cpp"
N#include "MPU-9250_acc_gyro_mag_driver_ll.h"
L 1 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_acc_gyro_mag_driver_ll.h" 1
N#ifndef __MPU_9250_ACC_GYRO_MAG_DRIVER_LL_H
N#define __MPU_9250_ACC_GYRO_MAG_DRIVER_LL_H
N
N#include <cstdint>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdint" 1
N /*
N * C++ header for C header stdint.h
N * Copyright (C) Advanced RISC Machines Limited, 1997. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstdint
N#define __cstdint
N#define __ARMCLIB_VERSION 5060019
N
N  #define __STDINT_NO_EXPORTS 1
N  #include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.2.1 */
S
S    /* minimum values of exact-width signed integer types */
S#define INT8_MIN                   -128
S#define INT16_MIN                -32768
S#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
S#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
S
S    /* maximum values of exact-width signed integer types */
S#define INT8_MAX                    127
S#define INT16_MAX                 32767
S#define INT32_MAX            2147483647
S#define INT64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of exact-width unsigned integer types */
S#define UINT8_MAX                   255
S#define UINT16_MAX                65535
S#define UINT32_MAX           4294967295u
S#define UINT64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.2 */
S
S    /* minimum values of minimum-width signed integer types */
S#define INT_LEAST8_MIN                   -128
S#define INT_LEAST16_MIN                -32768
S#define INT_LEAST32_MIN          (~0x7fffffff)
S#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of minimum-width signed integer types */
S#define INT_LEAST8_MAX                    127
S#define INT_LEAST16_MAX                 32767
S#define INT_LEAST32_MAX            2147483647
S#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of minimum-width unsigned integer types */
S#define UINT_LEAST8_MAX                   255
S#define UINT_LEAST16_MAX                65535
S#define UINT_LEAST32_MAX           4294967295u
S#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.3 */
S
S    /* minimum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MIN           (~0x7fffffff)
S#define INT_FAST16_MIN          (~0x7fffffff)
S#define INT_FAST32_MIN          (~0x7fffffff)
S#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MAX             2147483647
S#define INT_FAST16_MAX            2147483647
S#define INT_FAST32_MAX            2147483647
S#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of fastest minimum-width unsigned integer types */
S#define UINT_FAST8_MAX            4294967295u
S#define UINT_FAST16_MAX           4294967295u
S#define UINT_FAST32_MAX           4294967295u
S#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.4 */
S
S    /* minimum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MIN INT64_MIN
S#else
S#define INTPTR_MIN INT32_MIN
S#endif
S
S    /* maximum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MAX INT64_MAX
S#else
S#define INTPTR_MAX INT32_MAX
S#endif
S
S    /* maximum value of pointer-holding unsigned integer type */
S#if __sizeof_ptr == 8
S#define UINTPTR_MAX UINT64_MAX
S#else
S#define UINTPTR_MAX UINT32_MAX
S#endif
S
S    /* 7.18.2.5 */
S
S    /* minimum value of greatest-width signed integer type */
S#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
S
S    /* maximum value of greatest-width signed integer type */
S#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
S
S    /* maximum value of greatest-width unsigned integer type */
S#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
S
S    /* 7.18.3 */
S
S    /* limits of ptrdiff_t */
S#if __sizeof_ptr == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
S#else
S#define PTRDIFF_MIN INT32_MIN
S#define PTRDIFF_MAX INT32_MAX
S#endif
S
S    /* limits of sig_atomic_t */
S#define SIG_ATOMIC_MIN (~0x7fffffff)
S#define SIG_ATOMIC_MAX   2147483647
S
S    /* limit of size_t */
S#if __sizeof_ptr == 8
S#define SIZE_MAX UINT64_MAX
S#else
S#define SIZE_MAX UINT32_MAX
S#endif
S
S    /* limits of wchar_t */
S    /* NB we have to undef and redef because they're defined in both
S     * stdint.h and wchar.h */
S#undef WCHAR_MIN
S#undef WCHAR_MAX
S
S#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
S#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
S#endif
S
S    /* limits of wint_t */
S#define WINT_MIN (~0x7fffffff)
S#define WINT_MAX 2147483647
S
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.4.1 macros for minimum-width integer constants */
S#define INT8_C(x)   (x)
S#define INT16_C(x)  (x)
S#define INT32_C(x)  (x)
S#define INT64_C(x)  __INT64_C(x)
S
S#define UINT8_C(x)  (x ## u)
S#define UINT16_C(x) (x ## u)
S#define UINT32_C(x) (x ## u)
S#define UINT64_C(x) __UINT64_C(x)
S
S    /* 7.18.4.2 macros for greatest-width integer constants */
S#define INTMAX_C(x)  __ESCAPE__(x ## ll)
S#define UINTMAX_C(x) __ESCAPE__(x ## ull)
S
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
N    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdint" 2
N  #undef __STDINT_NO_EXPORTS
N
N  
N  #undef __stdint_h  // later inclusion of stdint.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstdint */
N
L 5 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_acc_gyro_mag_driver_ll.h" 2
N//#include <vector>
N
N#include "MPU-9250_register_map.h"
L 1 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_register_map.h" 1
N#ifndef __MPU_9250_REGISTER_MAP_H
N#define __MPU_9250_REGISTER_MAP_H
N
N#include <cstdint>
N
Nnamespace MPU_9250
N{
N  using std::uint8_t;
N  using std::uint16_t;
N  
N  namespace reg_gyro_acc
N  {
N    const uint8_t SELF_TEST_X_GYRO   = uint8_t(0x00);
N    const uint8_t SELF_TEST_Y_GYRO   = uint8_t(0x01);
N    const uint8_t SELF_TEST_Z_GYRO   = uint8_t(0x02);
N    const uint8_t SELF_TEST_X_ACCEL  = uint8_t(0x0D);
N    const uint8_t SELF_TEST_Y_ACCEL  = uint8_t(0x0E);
N    const uint8_t SELF_TEST_Z_ACCEL  = uint8_t(0x0F);
N    const uint8_t XG_OFFSET_H        = uint8_t(0x13);
N    const uint8_t XG_OFFSET_L        = uint8_t(0x14);
N    const uint8_t YG_OFFSET_H        = uint8_t(0x15);
N    const uint8_t YG_OFFSET_L        = uint8_t(0x16);
N    const uint8_t ZG_OFFSET_H        = uint8_t(0x17);
N    const uint8_t ZG_OFFSET_L        = uint8_t(0x18);
N    const uint8_t SMPLRT_DIV         = uint8_t(0x19);
N    const uint8_t CONFIG             = uint8_t(0x1A);
N    const uint8_t GYRO_CONFIG        = uint8_t(0x1B);
N    const uint8_t ACCEL_CONFIG       = uint8_t(0x1C);
N    const uint8_t ACCEL_CONFIG_2     = uint8_t(0x1D);
N    const uint8_t LP_ACCEL_ODR       = uint8_t(0x1E);
N    const uint8_t WOM_THR            = uint8_t(0x1F);
N    const uint8_t FIFO_EN            = uint8_t(0x23);
N    const uint8_t I2C_MST_CTRL       = uint8_t(0x24);
N    const uint8_t I2C_SLV0_ADDR      = uint8_t(0x25);
N    const uint8_t I2C_SLV0_REG       = uint8_t(0x26);
N    const uint8_t I2C_SLV0_CTRL      = uint8_t(0x27);
N    const uint8_t I2C_SLV1_ADDR      = uint8_t(0x28);
N    const uint8_t I2C_SLV1_REG       = uint8_t(0x29);
N    const uint8_t I2C_SLV1_CTRL      = uint8_t(0x2A);
N    const uint8_t I2C_SLV2_ADDR      = uint8_t(0x2B);
N    const uint8_t I2C_SLV2_REG       = uint8_t(0x2C);
N    const uint8_t I2C_SLV2_CTRL      = uint8_t(0x2D);
N    const uint8_t I2C_SLV3_ADDR      = uint8_t(0x2E);
N    const uint8_t I2C_SLV3_REG       = uint8_t(0x2F);
N    const uint8_t I2C_SLV3_CTRL      = uint8_t(0x30);
N    const uint8_t I2C_SLV4_ADDR      = uint8_t(0x31);
N    const uint8_t I2C_SLV4_REG       = uint8_t(0x32);
N    const uint8_t I2C_SLV4_DO        = uint8_t(0x33);
N    const uint8_t I2C_SLV4_CTRL      = uint8_t(0x34);
N    const uint8_t I2C_SLV4_DI        = uint8_t(0x35);
N    const uint8_t I2C_MST_STATUS     = uint8_t(0x36);
N    const uint8_t INT_PIN_CFG        = uint8_t(0x37);
N    const uint8_t INT_ENABLE         = uint8_t(0x38);
N    const uint8_t INT_STATUS         = uint8_t(0x3A);
N    const uint8_t ACCEL_XOUT_H       = uint8_t(0x3B);
N    const uint8_t ACCEL_XOUT_L       = uint8_t(0x3C);
N    const uint8_t ACCEL_YOUT_H       = uint8_t(0x3D);
N    const uint8_t ACCEL_YOUT_L       = uint8_t(0x3E);
N    const uint8_t ACCEL_ZOUT_H       = uint8_t(0x3F);
N    const uint8_t ACCEL_ZOUT_L       = uint8_t(0x40);
N    const uint8_t TEMP_OUT_H         = uint8_t(0x41);
N    const uint8_t TEMP_OUT_L         = uint8_t(0x42);
N    const uint8_t GYRO_XOUT_H        = uint8_t(0x43);
N    const uint8_t GYRO_XOUT_L        = uint8_t(0x44);
N    const uint8_t GYRO_YOUT_H        = uint8_t(0x45);
N    const uint8_t GYRO_YOUT_L        = uint8_t(0x46);
N    const uint8_t GYRO_ZOUT_H        = uint8_t(0x47);
N    const uint8_t GYRO_ZOUT_L        = uint8_t(0x48);
N    const uint8_t EXT_SENS_DATA_00   = uint8_t(0x49);
N    const uint8_t EXT_SENS_DATA_01   = uint8_t(0x4A);
N    const uint8_t EXT_SENS_DATA_02   = uint8_t(0x4B);
N    const uint8_t EXT_SENS_DATA_03   = uint8_t(0x4C);
N    const uint8_t EXT_SENS_DATA_04   = uint8_t(0x4D);
N    const uint8_t EXT_SENS_DATA_05   = uint8_t(0x4E);
N    const uint8_t EXT_SENS_DATA_06   = uint8_t(0x4F);
N    const uint8_t EXT_SENS_DATA_07   = uint8_t(0x50);
N    const uint8_t EXT_SENS_DATA_08   = uint8_t(0x51);
N    const uint8_t EXT_SENS_DATA_09   = uint8_t(0x52);
N    const uint8_t EXT_SENS_DATA_10   = uint8_t(0x53);
N    const uint8_t EXT_SENS_DATA_11   = uint8_t(0x54);
N    const uint8_t EXT_SENS_DATA_12   = uint8_t(0x55);
N    const uint8_t EXT_SENS_DATA_13   = uint8_t(0x56);
N    const uint8_t EXT_SENS_DATA_14   = uint8_t(0x57);
N    const uint8_t EXT_SENS_DATA_15   = uint8_t(0x58);
N    const uint8_t EXT_SENS_DATA_16   = uint8_t(0x59);
N    const uint8_t EXT_SENS_DATA_17   = uint8_t(0x5A);
N    const uint8_t EXT_SENS_DATA_18   = uint8_t(0x5B);
N    const uint8_t EXT_SENS_DATA_19   = uint8_t(0x5C);
N    const uint8_t EXT_SENS_DATA_20   = uint8_t(0x5D);
N    const uint8_t EXT_SENS_DATA_21   = uint8_t(0x5E);
N    const uint8_t EXT_SENS_DATA_22   = uint8_t(0x5F);
N    const uint8_t EXT_SENS_DATA_23   = uint8_t(0x60);
N    const uint8_t I2C_SLV0_DO        = uint8_t(0x63);
N    const uint8_t I2C_SLV1_DO        = uint8_t(0x64);
N    const uint8_t I2C_SLV2_DO        = uint8_t(0x65);
N    const uint8_t I2C_SLV3_DO        = uint8_t(0x66);
N    const uint8_t I2C_MST_DELAY_CTRL = uint8_t(0x67);
N    const uint8_t SIGNAL_PATH_RESET  = uint8_t(0x68);
N    const uint8_t MOT_DETECT_CTRL    = uint8_t(0x69);
N    const uint8_t USER_CTRL          = uint8_t(0x6A);
N    const uint8_t PWR_MGMT_1         = uint8_t(0x6B);
N    const uint8_t PWR_MGMT_2         = uint8_t(0x6C);
N    const uint8_t FIFO_COUNTH        = uint8_t(0x72);
N    const uint8_t FIFO_COUNTL        = uint8_t(0x73);
N    const uint8_t FIFO_R_W           = uint8_t(0x74);
N    const uint8_t WHO_AM_I           = uint8_t(0x75);
N    const uint8_t XA_OFFSET_H        = uint8_t(0x77);
N    const uint8_t XA_OFFSET_L        = uint8_t(0x78);
N    const uint8_t YA_OFFSET_H        = uint8_t(0x7A);
N    const uint8_t YA_OFFSET_L        = uint8_t(0x7B);
N    const uint8_t ZA_OFFSET_H        = uint8_t(0x7D);
N    const uint8_t ZA_OFFSET_L        = uint8_t(0x7E);	 
N  }
N  
N  namespace reg_mag
N  {    
N    const uint8_t WIA                = uint8_t(0x00);
N    const uint8_t INFO               = uint8_t(0x01);
N    const uint8_t ST1                = uint8_t(0x02);
N    const uint8_t HXL                = uint8_t(0x03);
N    const uint8_t HXH                = uint8_t(0x04);
N    const uint8_t HYL                = uint8_t(0x05);
N    const uint8_t HYH                = uint8_t(0x06);
N    const uint8_t HZL                = uint8_t(0x07);
N    const uint8_t HZH                = uint8_t(0x08);
N    const uint8_t ST2                = uint8_t(0x09);
N    const uint8_t CNTL1              = uint8_t(0x0A);
N    const uint8_t CNTL2              = uint8_t(0x0B);
N    const uint8_t ASTC               = uint8_t(0x0C);
N    const uint8_t TS1                = uint8_t(0x0D);
N    const uint8_t TS2                = uint8_t(0x0E);
N    const uint8_t I2CDIS             = uint8_t(0x0F);
N    const uint8_t ASAX               = uint8_t(0x10);
N    const uint8_t ASAY               = uint8_t(0x11);
N    const uint8_t ASAZ               = uint8_t(0x12);	
N  }
N  
N  namespace sensitivity_gyro
N  {
N    const float _0_FS_SEL = 131.0f;
N    const float _1_FS_SEL =  65.5f;
N    const float _2_FS_SEL =  32.8f;
N    const float _3_FS_SEL =  16.4f;
N  }
N  
N  namespace sensitivity_accel
N  {
N    const uint16_t _0_FS_SEL = 16384;
N    const uint16_t _1_FS_SEL =  8192;
N    const uint16_t _2_FS_SEL =  4096;
N    const uint16_t _3_FS_SEL =  2048;
N  }
N  
N  namespace sensitivity_mag
N  {
N    const float _14_BIT_SENS = 0.6f;  //в мкТл
N    const float _16_BIT_SENS = 0.15f; //в мкТл
N  }
N  namespace temp_mpu_9250
N  {
N    const uint8_t ROOM_TEMP_OFFSET  = 21;
N	  const float SENSITIVITY        = 340.0f;
N  } 
N}
N
N#endif
N
N
N
N
N
N
N
L 8 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_acc_gyro_mag_driver_ll.h" 2
N#include "MPU-9250_types.h"
L 1 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_types.h" 1
N#ifndef __MPU_9250_TYPES_H
N#define __MPU_9250_TYPES_H
N
N#pragma anon_unions
N
N#include <cstdint>
N
Nnamespace MPU_9250
N{
N  using std::uint8_t;
N  using std::uint16_t;
N  
N  // Register 26 – Configuration
N  struct TFifoModeConfig
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N
N  struct TFsyncPinConfig
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 3;
N    uint8_t Reserved2 : 2;
N  };
N
N  struct TFilterGyroTempConfig
N  {
N    uint8_t Dest      : 3;
N    uint8_t Reserved1 : 5;
N  };
N
N  // Register 27 – Gyroscope Configuration  
N  struct TEnableXGyroSelfTest
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N
N  struct TEnableYGyroSelfTest
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TEnableZGyroSelfTest
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TGyroFullScaleSelect
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 2;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TGyroFilterChoise
N  {
N    uint8_t Dest      : 2;
N    uint8_t Reserved1 : 6;
N  };
N
N  //  Register 28 – Accelerometer Configuration
N  struct TEnableXAccelSelfTest
N  {
N    uint8_t Reserved  : 7;
N	  uint8_t Dest      : 1;
N  };
N  struct TEnableYAccelSelfTest
N  {
N    uint8_t Reserved1 : 6;
N	  uint8_t Dest      : 1;
N	  uint8_t Reserved2 : 1;
N  };
N
N  struct TEnableZAccelSelfTest
N  {
N    uint8_t Reserved1 : 5;
N	  uint8_t Dest      : 1;
N	  uint8_t Reserved2 : 2;
N  };
N
N  struct TAccelFullScaleSelect
N  {
N    uint8_t Reserved1 : 3;
N	  uint8_t Dest      : 2;
N	  uint8_t Reserved2 : 3;
N  };
N
N  // Register 29 – Accelerometer Configuration 2
N  struct TAcceFilterChoise
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;	 
N  };
N
N  struct TSetAccelFilter
N  {
N    uint8_t Dest      : 3;
N    uint8_t Reserved  : 5;	 
N  };
N  
N  // Register 30 – Low Power Accelerometer ODR Control
N  struct TSetAccelWakeupFreq
N  {
N    uint8_t Dest      : 4;
N	  uint8_t Reserved  : 4;
N  };
N  
N  // Register 35 – FIFO Enable
N  struct TWrTempToFifo
N  {
N	  uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TWrGyroXToFifo
N  {
N	  uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N	  uint8_t Reserved2 : 1;
N  };
N  
N  struct TWrGyroYToFifo
N  {
N	  uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N	  uint8_t Reserved2 : 2;
N  };
N  
N  struct TWrGyroZToFifo
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TWrAccelToFifo
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TWrSlave2ToFifo
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TWrSlave1ToFifo
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  struct TWrSlave0ToFifo
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N  
N  // Register 36 – I2C Master Control
N  struct TMultiMasterEnable
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TDelayDataReadyInt
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TWriteDataSlv3ToFifo
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TCtrlSlaveReadTransition
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TCfgInternalClk
N  {
N    uint8_t Dest      : 4;
N    uint8_t Reserved2 : 4;
N  };
N  
N  // Register 37 - I2C_SLV0_ADDR
N  struct TSlv0DirectTransfer
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv0PhyAddress
N  {
N    uint8_t Dest      : 7;
N    uint8_t Reserved  : 1;
N  };
N  
N  // Register 39 - I2C_SLV0_CTRL
N  struct TSlv0Enable
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv0SwapBytes
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TSlv0WriteReg
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TSlv0GroupData
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TSlv0NumBytesRead
N  {
N    uint8_t Dest      : 4;
N    uint8_t Reserved  : 4;
N  };
N   
N  // Register 40 - I2C_SLV1_ADDR
N  struct TSlv1TransferType
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv1PhyAddress
N  {
N    uint8_t Dest      : 7;
N    uint8_t Reserved  : 1;
N  };
N   
N  // Register 42 - I2C_SLV1_CTRL
N  struct TSlv1Enable
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv1SwapBytes
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TSlv1TransactionCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TSlv1DetermineAddress
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TSlv1NumBytesRead
N  {
N    uint8_t Dest      : 4;
N    uint8_t Reserved2 : 4;
N  };
N  
N  // Register 43 - I2C_SLV2_ADDR
N  struct TSlv2TransferType
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv2PhyAddress
N  {
N    uint8_t Dest      : 7;
N    uint8_t Reserved  : 1;
N  };
N  
N  // Register 45 - I2C_SLV2_CTRL
N  struct TSlv2Enable
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv2SwapBytes
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TSlv2TransactionCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TSlv2DetermineAddress
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TSlv2NumBytesRead
N  {
N    uint8_t Dest      : 4;
N    uint8_t Reserved2 : 4;
N  };
N  
N  // Register 46 - I2C_SLV3_ADDR
N  struct TSlv3TransferType
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv3PhyAddress
N  {
N    uint8_t Dest      : 7;
N    uint8_t Reserved  : 1;
N  };
N  
N  // Register 48 - I2C_SLV3_CTRL
N  struct TSlv3Enable
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv3SwapBytes
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TSlv3TransactionCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TSlv3DetermineAddress
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TSlv3NumBytesRead
N  {
N    uint8_t Dest      : 4;
N    uint8_t Reserved2 : 4;
N  };
N  
N  // Register 49 - I2C_SLV4_ADDR
N  struct TSlv4TransferType
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv4PhyAddress
N  {
N    uint8_t Dest      : 7;
N    uint8_t Reserved  : 1;
N  };
N  
N  // Register 52 - I2C_SLV4_CTRL
N  struct TSlv4Enable
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv4Complete
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TSlv4TransactionCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TNumSamplesCtrl
N  {
N    uint8_t Dest      : 5;
N    uint8_t Reserved  : 3;
N  };
N  
N  // Register 54 – I2C Master Status
N  struct TStatusFsyncInterrupt
N  {
N    uint8_t Reserved1 : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv4TransferComplete
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TSlvLostArbitration
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TSlv4RxNack
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TSlv3RxNack
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TSlv2RxNack
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TSlv1RxNack
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  struct TSlv0RxNack
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 7;
N  };
N  
N  // Register 55 – INT Pin / Bypass Enable Configuration
N  struct TIntLogicLevel
N  {
N    uint8_t Reserved1 : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TIntPinConfig
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TIntLatchCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TIntStatusCtrl
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TFsyncLevelCtrl
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TFsyncEnable
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TI2CMasterPinsCtrl
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  // Register 56 – Interrupt Enable
N  struct TWakeOnMotionIntCtrl
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TFifoOvrfIntCtrl
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TFsyncIntCtrl
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TRawDataReadyIntCtrl
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved1 : 7;
N  };
N  
N  // Register 58 – Interrupt Status
N  struct TWakeOnMotionIntStatus
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TFifoOvrfIntStatus
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TFsyncIntStatus
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TRawDataReadyIntStatus
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N  
N  // Register 103 – I2C Master Delay Control
N  struct TDelayShadowExtSense
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSlv4DlyAccessCtrl
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TSlv3DlyAccessCtrl
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TSlv2DlyAccessCtrl
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TSlv1DlyAccessCtrl
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  struct TSlv0DlyAccessCtrl
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N  
N  // Register 104 – Signal Path Reset
N  struct TResetGyroSignalPath
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TResetAccelSignalPath
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  struct TResetTempSignalPath
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N	 
N  // Register 105 – Accelerometer Interrupt Control 
N  struct TAccelWakeOnMotionCtrl
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TAccelCompareSamplesCtrl
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  	 
N  // Register 106 – User Control
N  struct TFifoModeCtrl
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TI2CMasterIFModuleCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TInterfaceModeCtrl
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TResetFifoModule
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TResetI2CMasterModule
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  struct TResetAllSignalPath
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N  
N	 
N  // Register 107 – Power Management 1
N  struct TResetAndRestoreInternalRegs
N  {
N    uint8_t Reserved  : 7;
N    uint8_t Dest      : 1;
N  };
N  
N  struct TSleepCtrl
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TCycleCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TGyroStandbyCtrl
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TVoltageGeneratorCtrl
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TClockSrcChoise
N  {
N    uint8_t Dest      : 3;
N    uint8_t Reserved  : 5;
N  };
N	 
N  // Register 108 – Power Management 2
N  struct TAccelXCtrl
N  {
N    uint8_t Reserved1 : 5;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 2;
N  };
N  
N  struct TAccelYCtrl
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  struct TAccelZCtrl
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N  
N  struct TGyroXCtrl
N  {
N    uint8_t Reserved1 : 2;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 5;
N  };
N  
N  struct TGyroYCtrl
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N  
N  struct TGyroZCtrl
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N	 
N  // Register 114 and 115 – FIFO Count Registers
N  struct TFifoHighBits
N  {
N    uint8_t Dest      : 5;
N    uint8_t Reserved  : 3;
N  };
N  
N  // ST1: Status 1
N  struct TDataReady
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N  
N  struct TDataOverrun
N  {
N    uint8_t Reserved1 : 1;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 6;
N  };
N
N  // ST2: Status 2
N  struct TMagSensorOvrf
N  {
N    uint8_t Reserved1 : 3;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 4;
N  };
N 
N  struct TOutBitSetting
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N  
N  // CNTL1: Control 1
N  struct TMagMode
N  {
N    uint8_t Dest      : 4;
N    uint8_t Reserved  : 4;
N  };
N  
N  struct TMagBit
N  {
N    uint8_t Reserved1 : 4;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 3;
N  };
N
N  // CNTL2: Control 2
N  struct TSoftReset
N  {
N    uint8_t Dest      : 1;
N    uint8_t Reserved  : 7;
N  };
N  
N  // ASTC: Self-Test Control
N  struct TSelfTestControl
N  {
N    uint8_t Reserved1 : 6;
N    uint8_t Dest      : 1;
N    uint8_t Reserved2 : 1;
N  };
N  
N  struct TAccData
N  {
N    union
N    {
N      struct
N      {
N        uint8_t ACCEL_XOUT_H; 
N        uint8_t ACCEL_XOUT_L;
N      };
N      uint16_t ACCEL_XOUT;
N    };
N    union
N    {
N      struct
N      {
N        uint8_t ACCEL_YOUT_H;
N        uint8_t ACCEL_YOUT_L;
N      };
N      uint16_t ACCEL_YOUT;
N    };
N    union
N    {
N      struct
N      {
N        uint8_t ACCEL_ZOUT_H;
N        uint8_t ACCEL_ZOUT_L;
N      };
N      uint16_t ACCEL_ZOUT;
N    };
N  };
N  
N  
N  struct TReadData
N  {
N    struct
N    {
N      union
N      {
N        struct
N        {
N          uint8_t ACCEL_XOUT_H; 
N          uint8_t ACCEL_XOUT_L;
N        };
N        uint16_t ACCEL_XOUT;
N      };
N      union
N      {
N        struct
N        {
N          uint8_t ACCEL_YOUT_H;
N          uint8_t ACCEL_YOUT_L;
N        };
N        uint16_t ACCEL_YOUT;
N      };
N      union
N      {
N        struct
N        {
N          uint8_t ACCEL_ZOUT_H;
N          uint8_t ACCEL_ZOUT_L;
N        };
N        uint16_t ACCEL_ZOUT;
N      };
N    };
N	 
N	  struct
N	  {
N	    union
N		  {
N		    struct
N		    {
N	        uint8_t TEMP_OUT_H;  
N	        uint8_t TEMP_OUT_L;
N		    };
N		    uint16_t TEMP_DATA;
N		  }; 
N	  }; 
N	 
N	  struct
N	  {
N	    union
N		  {
N		    struct 
N		    {
N	        uint8_t GYRO_XOUT_H; 
N	        uint8_t GYRO_XOUT_L;
N		    };
N		    uint16_t GYRO_XOUT;
N		  };
N	    union
N		  {
N		    struct 
N		    {
N	        uint8_t GYRO_YOUT_H; 
N	        uint8_t GYRO_YOUT_L;
N		    };
N		    uint16_t GYRO_YOUT;
N		  };
N	    union
N		  {
N		    struct 
N		    {
N	        uint8_t GYRO_ZOUT_H; 
N	        uint8_t GYRO_ZOUT_L; 
N		    };
N		    uint16_t GYRO_ZOUT;
N		  };  
N	  };
N  };  
N}
N
N#endif
L 9 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_acc_gyro_mag_driver_ll.h" 2
N#include "MPU-9250_vals.h"
L 1 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_vals.h" 1
N#ifndef __MPU_9250_VALS_H
N#define __MPU_9250_VALS_H
N
N//#include <cstdint>
N
Nnamespace MPU_9250
N{
N  using std::uint8_t;
N  using std::uint32_t;
N
N//  enum TI2CProtocol  //константы - I2C протокол датчика
N//  {
N//    ST,    //старт условие
N//    SADW,  //slave адрес + записать
N//    SADR,  //slave адрес + считать
N//    SAK,   //подтверждение от slave
N//    SUB,   //передача подадреса
N//    DATAS, //передача данных от slave
N//    DATAM, //передача данных от master
N//    SP,    //стоп условие
N//    SR,    //повстарт
N//    MAK,   //подтверждение от master
N//    NMAK,  //нет подтверждения от slave
N//    MAX_P
N//  };
N  
N//  enum I2CModes
N//  {
N//    STANDARD,                    //до 100кГц
N//    FAST,                        //до 400кГц
N//  };
N
N  enum VGyroSensitivity : uint32_t  //mLSB/dps
N  {
N  
N  };
N  
N  enum TCommType : uint8_t
N  {
N	 _WRITE = 0,
N    _READ,
N  };
N  
N  enum TLogicLevelAD0 : uint8_t
N  {
N    _LOW = 0,
N	 _HIGH
N  };
N  
N//  enum class TInternalSensor : uint8_t
N//  {
N//    _ACCEL_GYRO,
N//	 _MAGNETO
N//  };
N//  
N  enum class VEnDis : uint8_t
N  {
N    _DISABLE,
N	 _ENABLE
N  };
N  
N  enum class VLogicLevelINT : bool
N  {
N    _ACTIVE_HIGH,
N	 _ACTIVE_LOW
N  };
N
N  enum class VPinConfigINT : bool
N  {
N    _PUSH_PULL,
N	 _OPEN_DRAIN
N  };
N
N  enum class VI2CMasterCtrl : bool
N  {
N    _DISABLE_I2C_MASTER_MODULE,
N	 _ENABLE_I2C_MASTER_MODULE
N  };
N
N  enum class VLatchINT : bool
N  {
N	 _PULSE_50us,
N    _LEVEL_HELD_UNTIL_CLR
N  };
N
N  enum class VFifoModeConfig : bool
N  {
N    _FIFO_FULL_YES_WRITE = 0,
N    _FIFO_FULL_NO_WRITE
N  };
N
N  enum class VFsyncPinConfig : uint8_t
N  {
N    _DISABLED,
N	 _TEMP_OUT_L_0,
N	 _GYRO_XOUT_L_0,
N	 _GYRO_YOUT_L_0,
N	 _GYRO_ZOUT_L_0,
N	 _ACCEL_XOUT_L_0,
N	 _ACCEL_YOUT_L_0,
N	 _ACCEL_ZOUT_L_0
N  };
N  
N  enum class VFilterGyroTempConfig : uint8_t
N  { // Gyroscope: 1)Bandwidth 2)Delay 3)Fs. Temperature Sensor: 1)Bandwidth 2)Delay.
N    _G250_097_8_T4000_004,
N    _G184_2d9_1_T188_1d9,
N    _G92_3d9_1_T98_2d8,
N    _G41_5d9_1_T42_4d8,
N    _G20_9d9_1_T20_8d3,
N    _G10_17d85_1_T10_13d4,
N    _G5_33d48_1_T5_18d6,
N    _G3600_0d17_8_T4000_0d04,
N  };
N  
N  enum class VGyroFullScaleSelect : uint8_t
N  {
N    _250_DPS,
N    _500_DPS,
N    _1000_DPS,
N    _2000_DPS
N  };
N  
N  enum class VGyroFilterChoise : uint8_t
N  {
N    _x0 = 1, //значения FCHOICE - это инверсия Fchoice_b
N	 _01 = 2,
N	 _11 = 0
N  };
N  
N  enum class VAccelFullScaleSelect : uint8_t
N  {
N    _2G,
N    _4G,
N    _8G,
N    _16G,
N  };
N  
N  enum class VAccelFilterChoise : uint8_t
N  {
N    _0 = 1, //значение accel_fchoice - инверсия accel_fchoice_b
N	  _1 = 0
N  };
N  
N  enum class VSetAccelFilter : uint8_t
N  { // 3dB_BW(Hz)___Delay (ms) 
N    _218_1Hz_1_88ms = 0, 
N    _99Hz_2_88ms    = 2, 
N    _44_8Hz_4_88ms  = 3, 
N    _21_2Hz_8_87ms  = 4, 
N    _10_2Hz_16_83ms = 5, 
N    _5_05Hz_32_48ms = 6, 
N    _420Hz_1_38ms   = 7,
N  };
N  
N  enum class VSetAccelWakeupFreq : uint8_t
N  {
N    _0_24Hz,
N    _0_49Hz,
N    _0_98Hz,
N    _1_95Hz,
N    _3_91Hz,
N    _7_81Hz,
N    _15_63Hz,
N    _31_25Hz,
N    _62_50Hz,
N    _125Hz,
N    _250Hz,
N    _500Hz,
N  };
N  
N  enum class VConfigInternalClk : uint8_t
N  { //I2C Master Clock Speed_____8MHz Closk Divider
N    _348kHz_23,	 
N    _333kHz_24,
N    _320kHz_25,
N    _308kHz_26,
N    _296kHz_27,
N    _286kHz_28,
N    _276kHz_29,
N    _267kHz_30,
N    _258kHz_31,
N    _500kHz_16,
N    _471kHz_17,
N    _444kHz_18,
N    _421kHz_19,
N    _400kHz_20,
N    _381kHz_21,
N    _364kHz_22	 
N  };
N  
N  enum class VI2CTransferType : uint8_t
N  {
N	 _TRANSFER_IS_WRITE,
N    _TRANSFER_IS_READ
N  };
N  
N  enum class VStatusFlag : bool
N  {
N    _NO,
N	 _YES
N  };
N  
N  enum class VSetReset : uint8_t
N  {
N	 _RESET,
N    _SET
N  };
N	
N  enum class VSlvNumBytesRead : uint8_t
N  {
N    _0_BYTES_TO_READ,
N    _1_BYTES_TO_READ,
N    _2_BYTES_TO_READ,
N    _3_BYTES_TO_READ,
N    _4_BYTES_TO_READ,
N    _5_BYTES_TO_READ,
N    _6_BYTES_TO_READ,
N    _7_BYTES_TO_READ,
N    _8_BYTES_TO_READ,
N    _9_BYTES_TO_READ,
N    _10_BYTES_TO_READ,
N    _11_BYTES_TO_READ,
N    _12_BYTES_TO_READ,
N    _13_BYTES_TO_READ,
N    _14_BYTES_TO_READ,
N    _15_BYTES_TO_READ,
N  };
N  
N  enum class VNumSamplesCtrl : uint8_t
N  {
N    _ONE_PLUS_0_SAMPLES,
N    _ONE_PLUS_1_SAMPLES,
N    _ONE_PLUS_2_SAMPLES,
N    _ONE_PLUS_3_SAMPLES,
N    _ONE_PLUS_4_SAMPLES,
N    _ONE_PLUS_5_SAMPLES,
N    _ONE_PLUS_6_SAMPLES,
N    _ONE_PLUS_7_SAMPLES,
N    _ONE_PLUS_8_SAMPLES,
N    _ONE_PLUS_9_SAMPLES,
N    _ONE_PLUS_10_SAMPLES,
N    _ONE_PLUS_11_SAMPLES,
N    _ONE_PLUS_12_SAMPLES,
N    _ONE_PLUS_13_SAMPLES,
N    _ONE_PLUS_14_SAMPLES,
N    _ONE_PLUS_15_SAMPLES,
N    _ONE_PLUS_16_SAMPLES,
N    _ONE_PLUS_17_SAMPLES,
N    _ONE_PLUS_18_SAMPLES,
N    _ONE_PLUS_19_SAMPLES,
N    _ONE_PLUS_20_SAMPLES,
N    _ONE_PLUS_21_SAMPLES,
N    _ONE_PLUS_22_SAMPLES,
N    _ONE_PLUS_23_SAMPLES,
N    _ONE_PLUS_24_SAMPLES,
N    _ONE_PLUS_25_SAMPLES,
N    _ONE_PLUS_26_SAMPLES,
N    _ONE_PLUS_27_SAMPLES,
N    _ONE_PLUS_28_SAMPLES,
N    _ONE_PLUS_29_SAMPLES,
N    _ONE_PLUS_30_SAMPLES,
N    _ONE_PLUS_31_SAMPLES,
N  };
N  
N  enum class VClockSrcChoise : uint8_t
N  {
N    _INTERNAL_20MHz  = 0,
N	 _PLL_OR_INTERNAL = 1,
N	 _STOP_CLK        = 7
N  };
N  
N  enum class VMagOperationModeSet : uint8_t
N  {
N    _POWER_DOWN             = 0,
N	 _SINGLE_MEAS            = 1, 
N	 _CONTINUOUS_MEAS_MODE_1 = 2,
N	 _CONTINUOUS_MEAS_MODE_2 = 6,
N	 _EXTERNAL_TRIG_MEAS     = 4,
N	 _SELF_TEST              = 8,
N	 _FUSE_ROM_ACCESS        = 15
N  };
N  
N  enum class VMagOutputBitSet : uint8_t
N  {
N    _14_BIT_OUTPUT = 0,
N    _16_BIT_OUTPUT = 1,
N  };
N  
N  enum class VMagSoftResetCtrl : uint8_t
N  {
N    _NORMAL = 0,
N    _RESET  = 1,
N  };
N  
N  enum class VMagSelfTestCtrl : uint8_t
N  {
N    _NORMAL             = 0,
N	 _GENERATE_MAG_FIELD = 1
N  }; 
N}
N
N#endif
L 10 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_acc_gyro_mag_driver_ll.h" 2
N#include "I2C_Protocol.h"
L 1 ".\Source\Ext_Dev\inc\I2C_Protocol.h" 1
N#ifndef _I2C_PROTOCOL_H
N#define _I2C_PROTOCOL_H
N
N  enum TI2CProtocol  //константы - I2C протокол датчика
N  {
N    ST,    //старт условие
N    SADW,  //slave адрес + записать
N    SADR,  //slave адрес + считать
N    SAK,   //подтверждение от slave
N    SUB,   //передача подадреса
N    DATAS, //передача данных от slave
N    DATAM, //передача данных от master
N    SP,    //стоп условие
N    SR,    //повстарт
N    MAK,   //подтверждение от master
N    NMAK,  //нет подтверждения от slave
N    MAX_P
N  };
N  
N#endif
L 11 ".\Source\Ext_Dev\inc\MPU-9250\MPU-9250_acc_gyro_mag_driver_ll.h" 2
N
Nnamespace std
N{
N  typedef decltype(nullptr) nullptr_t;
N}
N
Nnamespace MPU_9250
N{
N  using std::uint8_t;
N
N  class TAccGyroMagDriver_LL
N  {
N  public:
N    TAccGyroMagDriver_LL();
N    ~TAccGyroMagDriver_LL();
N	 
N//	 std::vector<TI2CProtocol> ProtocolWrOne;
N//	 std::vector<TI2CProtocol> ProtocolWrMul;
N//	 std::vector<TI2CProtocol> ProtocolRdOne;
N//	 std::vector<TI2CProtocol> ProtocolRdMul;
N	 const uint8_t WIA      = 0x48; //Идентификатор магнитометра
N	 
N  protected:	 
N    const uint8_t WHO_AM_I = 0x71; //Идентификатор акселерометра с гироскопом
N	 
N	 uint8_t get_acc_gyro_addr(TLogicLevelAD0 Level) const; //AD0 - определяется аппаратным подключением вывода 9 микросхемы MPU-9250
N	 uint8_t get_mag_addr() const; //По этому адресу к магнитометру можно обратиться, когда микросхема будет настроена в режим Pass-Through
N	 
N
N//----- REGISTER MAP FOR ACCELEROMETER AND GYROSCOPE -----------------------------------
N
N	 // Registers 0 to 2 – Gyroscope Self-Test Registers 
N	 uint8_t get_st_x_gyro(){return reg_gyro_acc::SELF_TEST_X_GYRO;}
N    uint8_t get_st_y_gyro(){return reg_gyro_acc::SELF_TEST_Y_GYRO;}
N    uint8_t get_st_z_gyro(){return reg_gyro_acc::SELF_TEST_Z_GYRO;}
N    
N	 // Registers 13 to 15 – Accelerometer Self-Test Registers
N	 uint8_t get_st_x_accel(){return reg_gyro_acc::SELF_TEST_X_ACCEL;}
N    uint8_t get_st_y_accel(){return reg_gyro_acc::SELF_TEST_Y_ACCEL;}
N    uint8_t get_st_z_accel(){return reg_gyro_acc::SELF_TEST_Z_ACCEL;} 
N
N	 //  Registers 19 to 24 – Gyro Offset Registers
N	 uint8_t remove_gyro_bias_x_h(){return reg_gyro_acc::XG_OFFSET_H;}
N	 uint8_t remove_gyro_bias_x_l(){return reg_gyro_acc::XG_OFFSET_L;}
N	 uint8_t remove_gyro_bias_y_h(){return reg_gyro_acc::YG_OFFSET_H;}
N	 uint8_t remove_gyro_bias_y_l(){return reg_gyro_acc::YG_OFFSET_L;}
N	 uint8_t remove_gyro_bias_z_h(){return reg_gyro_acc::ZG_OFFSET_H;}
N	 uint8_t remove_gyro_bias_z_l(){return reg_gyro_acc::ZG_OFFSET_L;}
N	 
N	 // Register 25 – Sample Rate Divider
N	 uint8_t sample_rate_divider(){return reg_gyro_acc::SMPLRT_DIV;} 
N	 
N	 // Register 26 – Configuration
N	 uint8_t fifo_mode_config(uint8_t *const Byte = nullptr, VFifoModeConfig FIFO_MODE = VFifoModeConfig::_FIFO_FULL_YES_WRITE); //вкл/выкл дополнительную запись в fifo, когда fifo заполнено (запись с заменой) 
N	 uint8_t fsync_pin_config(uint8_t *const Byte = nullptr, VFsyncPinConfig EXT_SYNC_SET = VFsyncPinConfig::_DISABLED); //выбор защелкиваемого параметра по входу FSYNC
N	 uint8_t filter_gyro_temp_config(uint8_t *const Byte = nullptr, VFilterGyroTempConfig DLPF_CFG = VFilterGyroTempConfig::_G3600_0d17_8_T4000_0d04); //выбор значений фильтрации для гироскопа и термодатчика
N    uint8_t filter_gyro_temp_read(uint8_t Byte = 0, VFilterGyroTempConfig *DLPF_CFG = nullptr);
N
N	 // Register 27 – Gyroscope Configuration
N	 uint8_t enable_x_gyro_self_test(uint8_t *const Byte = nullptr, VEnDis XGYRO_Cten = VEnDis::_DISABLE); //вкл/выкл самотестирования оси X гироскопа
N	 uint8_t enable_y_gyro_self_test(uint8_t *const Byte = nullptr, VEnDis YGYRO_Cten = VEnDis::_DISABLE); //вкл/выкл самотестирования оси Y гироскопа
N	 uint8_t enable_z_gyro_self_test(uint8_t *const Byte = nullptr, VEnDis ZGYRO_Cten = VEnDis::_DISABLE); //вкл/выкл самотестирования оси Z гироскопа
N	 uint8_t gyro_full_scale_select(uint8_t *const Byte = nullptr, VGyroFullScaleSelect GYRO_FS_SEL = VGyroFullScaleSelect::_2000_DPS); //выбор предела измерения гироскопа
N	 uint8_t gyro_full_scale_read(const uint8_t Byte, VGyroFullScaleSelect *GYRO_FS_SEL);
N	 uint8_t gyro_filter_choise(uint8_t *const Byte = nullptr, VGyroFilterChoise Fchoice_b = VGyroFilterChoise::_11);
N
N	 // Register 28 – Accelerometer Configuration
N	 uint8_t enable_x_accel_self_test(uint8_t *const Byte = nullptr, VEnDis ax_st_en = VEnDis::_DISABLE); //вкл/выкл самотестирования оси X акселерометра
N	 uint8_t enable_y_accel_self_test(uint8_t *const Byte = nullptr, VEnDis ay_st_en = VEnDis::_DISABLE); //вкл/выкл самотестирования оси Y акселерометра
N	 uint8_t enable_z_accel_self_test(uint8_t *const Byte = nullptr, VEnDis az_st_en = VEnDis::_DISABLE); //вкл/выкл самотестирования оси Z акселерометра
N	 uint8_t accel_full_scale_select(uint8_t *const Byte = nullptr, VAccelFullScaleSelect ACCEL_FS_SEL = VAccelFullScaleSelect::_16G); //выбор предела измерения акселерометра
N
N	 // Register 29 – Accelerometer Configuration 2
N    uint8_t accel_filter_choise(uint8_t *const Byte = nullptr, VAccelFilterChoise accel_fchoice_b = VAccelFilterChoise::_0);
N    uint8_t accel_filter_read(uint8_t Byte = 0, VSetAccelFilter *A_DLPFCFG = nullptr);
N	 uint8_t set_accel_filter(uint8_t *const Byte = nullptr, VSetAccelFilter A_DLPFCFG = VSetAccelFilter::_218_1Hz_1_88ms);
N
N	 // Register 30 - Low Power Accelerometer ODR Control
N	 uint8_t set_accel_wakeup_freq(uint8_t *const Byte = nullptr, VSetAccelWakeupFreq lposc_clksel = VSetAccelWakeupFreq::_0_24Hz);
N
N	 // Register 31 – Wake-on Motion Threshold
N	 uint8_t set_wakeon_motion_thr(){return reg_gyro_acc::WOM_THR;}
N
N	 // Register 35 – FIFO Enable
N	 uint8_t write_temp_to_fifo(uint8_t *const Byte = nullptr,   VEnDis TEMP_OUT  = VEnDis::_DISABLE);
N	 uint8_t write_gyro_x_to_fifo(uint8_t *const Byte = nullptr, VEnDis GYRO_XOUT = VEnDis::_DISABLE);
N	 uint8_t write_gyro_y_to_fifo(uint8_t *const Byte = nullptr, VEnDis GYRO_YOUT = VEnDis::_DISABLE);
N	 uint8_t write_gyro_z_to_fifo(uint8_t *const Byte = nullptr, VEnDis GYRO_ZOUT = VEnDis::_DISABLE);
N	 uint8_t write_accel_to_fifo(uint8_t *const Byte = nullptr,  VEnDis ACCEL = VEnDis::_DISABLE);
N	 uint8_t write_slave2_to_fifo(uint8_t *const Byte = nullptr, VEnDis SLV_2 = VEnDis::_DISABLE);
N	 uint8_t write_slave1_to_fifo(uint8_t *const Byte = nullptr, VEnDis SLV_1 = VEnDis::_DISABLE);
N	 uint8_t write_slave0_to_fifo(uint8_t *const Byte = nullptr, VEnDis SLV_0 = VEnDis::_DISABLE);
N	 
N	 // Register 36 – I2C Master Control
N    uint8_t multi_master_enable(uint8_t *const Byte = nullptr,        VEnDis MULT_MST_EN   = VEnDis::_DISABLE);
N	 uint8_t delay_data_ready_int(uint8_t *const Byte = nullptr,       VEnDis WAIT_FOR_ES   = VEnDis::_DISABLE);
N	 uint8_t write_data_slv3_to_fifo(uint8_t *const Byte = nullptr,    VEnDis SLV_3_FIFO_EN = VEnDis::_DISABLE);
N	 uint8_t ctrl_slave_read_transition(uint8_t *const Byte = nullptr, VEnDis I2C_MST_P_NSR = VEnDis::_DISABLE);
N	 uint8_t config_internal_clk(uint8_t *const Byte = nullptr, VConfigInternalClk I2C_MST_CLK = VConfigInternalClk::_400kHz_20);
N	 
N	 // Register 37 - I2C_SLV0_ADDR
N	 uint8_t slv0_direct_transfer(uint8_t *const Byte = nullptr, VI2CTransferType I2C_SLV0_RNW = VI2CTransferType::_TRANSFER_IS_WRITE);
N	 uint8_t slv0_phy_address(uint8_t *const Byte = nullptr, const uint8_t Addr_7Bit = 0);
N	 
N	 // Register 38 - I2C_SLV0_REG 
N	 uint8_t slv0_reg_address_begin(){return reg_gyro_acc::I2C_SLV0_REG;}
N	 
N	 // Register 39 - I2C_SLV0_CTRL
N	 uint8_t slv0_enable(uint8_t *const Byte = nullptr, VEnDis I2C_SLV0_EN = VEnDis::_DISABLE);
N	 uint8_t slv0_swap_bytes(uint8_t *const Byte = nullptr, VEnDis I2C_SLV0_BYTE_SW = VEnDis::_DISABLE);
N	 uint8_t slv0_write_reg_enable(uint8_t *const Byte = nullptr, VEnDis I2C_SLV0_REG_DIS = VEnDis::_DISABLE);
N	 uint8_t slv0_group_data(uint8_t *const Byte = nullptr, VEnDis I2C_SLV0_GRP = VEnDis::_DISABLE);
N	 uint8_t slv0_num_bytes_read(uint8_t *const Byte = nullptr, VSlvNumBytesRead I2C_SLV0_LENG = VSlvNumBytesRead::_0_BYTES_TO_READ);
N	 
N//	 // Register 40 - I2C_SLV1_ADDR
N//    uint8_t slv1_transfer_type(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv1_phy_address(uint8_t *const Byte = nullptr, );
N//	 
N//	 // Register 41 - I2C_SLV1_REG
N//	 uint8_t slv1_reg_address_begin(uint8_t *const Byte = nullptr, );
N//	 
N//	 // Register 42 - I2C_SLV1_CTRL
N//	 uint8_t slv1_enable(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv1_swap_bytes(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv1_transaction_ctrl(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv1_determine_address(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv1_num_bytes_read(uint8_t *const Byte = nullptr, );
N	 
N//	 // Register 43 - I2C_SLV2_ADDR
N//    uint8_t slv2_transfer_type(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv2_phy_address(uint8_t *const Byte = nullptr, );
N//	 
N//    // Register 44 - I2C_SLV2_REG
N//	 uint8_t slv2_reg_address_begin(uint8_t *const Byte = nullptr, );
N//	 
N//	 // Register 45 - I2C_SLV2_CTRL
N//	 uint8_t slv2_enable(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv2_swap_bytes(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv2_transaction_ctrl(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv2_determine_address(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv2_num_bytes_read(uint8_t *const Byte = nullptr, );
N
N//	 // Register 46 - I2C_SLV3_ADDR
N//    uint8_t slv3_transfer_type(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv3_phy_address(uint8_t *const Byte = nullptr, );
N
N//	 // Register 47 - I2C_SLV3_REG
N//	 uint8_t slv3_reg_address_begin(uint8_t *const Byte = nullptr, );
N
N//	 // Register 48 - I2C_SLV3_CTRL
N//	 uint8_t slv3_enable(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv3_swap_bytes(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv3_transaction_ctrl(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv3_determine_address(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv3_num_bytes_read(uint8_t *const Byte = nullptr, );
N
N//	 // Register 49 - I2C_SLV4_ADDR
N//    uint8_t slv4_transfer_type(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv4_phy_address(uint8_t *const Byte = nullptr, );
N
N//	 // Register 50 - I2C_SLV4_REG
N//	 uint8_t slv4_reg_address_begin(uint8_t *const Byte = nullptr, );
N
N//	 // Register 51 - I2C_SLV4_DO
N//	 uint8_t slv4_data_wr(uint8_t *const Byte = nullptr, );
N
N//	 // Register 52 - I2C_SLV4_CTRL
N//	 uint8_t slv4_enable(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv4_complete_and_int(uint8_t *const Byte = nullptr, );
N//	 uint8_t slv4_transaction_ctrl(uint8_t *const Byte = nullptr, );
N//	 uint8_t num_samples_ctrl(uint8_t *const Byte = nullptr, );
N//	 
N//	 // Register 53 - I2C_SLV4_DI
N//    uint8_t slv4_data_rd(uint8_t *const Byte = nullptr, );
N
N	 // Register 54 – I2C Master Status
N	 uint8_t status_fsync_interrupt(const uint8_t Byte = 0, VStatusFlag *PASS_THROUGH = nullptr);
N	 uint8_t slv4_transfer_complete(const uint8_t Byte = 0, VStatusFlag *I2C_SLV4_DONE = nullptr);
N	 uint8_t slv_lost_arbitration(const uint8_t Byte = 0, VStatusFlag *I2C_LOST_ARB = nullptr);
N	 uint8_t slv4_rx_nack(const uint8_t Byte = 0, VStatusFlag *I2C_SLV4_NACK = nullptr);
N	 uint8_t slv3_rx_nack(const uint8_t Byte = 0, VStatusFlag *I2C_SLV3_NACK = nullptr);
N	 uint8_t slv2_rx_nack(const uint8_t Byte = 0, VStatusFlag *I2C_SLV2_NACK = nullptr);
N	 uint8_t slv1_rx_nack(const uint8_t Byte = 0, VStatusFlag *I2C_SLV1_NACK = nullptr);
N	 uint8_t slv0_rx_nack(const uint8_t Byte = 0, VStatusFlag *I2C_SLV0_NACK = nullptr);
N
N	 // Register 55 – INT Pin / Bypass Enable Configuration
N	 uint8_t int_logic_level(uint8_t *const Byte = nullptr, VLogicLevelINT ACTL = VLogicLevelINT::_ACTIVE_HIGH);
N	 uint8_t int_pin_config(uint8_t *const Byte = nullptr, VPinConfigINT OPEN = VPinConfigINT::_PUSH_PULL);
N	 uint8_t int_latch_ctrl(uint8_t *const Byte = nullptr, VLatchINT LATCH_INT_EN = VLatchINT::_PULSE_50us);
N	 uint8_t int_status_ctrl(uint8_t *const Byte = nullptr, VEnDis INT_ANYRD_2CLEAR = VEnDis::_DISABLE);
N	 uint8_t fsync_level_ctrl(uint8_t *const Byte = nullptr, VEnDis ACTL_FSYNC = VEnDis::_DISABLE);
N    uint8_t fsync_enable(uint8_t *const Byte = nullptr, VEnDis FSYNC_INT_MODE_EN = VEnDis::_DISABLE);
N	 uint8_t i2c_master_pins_ctrl(uint8_t *const Byte = nullptr, VEnDis BYPASS_EN = VEnDis::_DISABLE);
N	 uint8_t i2c_master_pins_read(const uint8_t Byte = 0, VEnDis *BYPASS_EN = nullptr);
N
N	 // Register 56 – Interrupt Enable
N    uint8_t wake_on_motion_int_ctrl(uint8_t *const Byte = nullptr, VEnDis WOM_EN = VEnDis::_DISABLE);
N    uint8_t fifo_ovrf_int_ctrl(uint8_t *const Byte = nullptr, VEnDis FIFO_OVERFLOW_EN = VEnDis::_DISABLE);
N    uint8_t fsync_int_ctrl(uint8_t *const Byte = nullptr, VEnDis FSYNC_INT_EN = VEnDis::_DISABLE);
N	 uint8_t raw_data_ready_int_ctrl(uint8_t *const Byte = nullptr, VEnDis RAW_RDY_EN = VEnDis::_DISABLE);
N
N	 // Register 58 – Interrupt Status
N	 uint8_t wake_on_motion_int_status(const uint8_t Byte = 0, VStatusFlag *WOM_INT = nullptr);
N	 uint8_t fifo_ovrf_int_status(const uint8_t Byte = 0, VStatusFlag *FIFO_OVERFLOW_INT = nullptr);
N	 uint8_t fsync_int_status(const uint8_t Byte = 0, VStatusFlag *FSYNC_INT = nullptr);
N	 uint8_t raw_data_ready_int_status(const uint8_t Byte = 0, VStatusFlag *RAW_DATA_RDY_INT = nullptr);
N
N	 // Registers 59 to 64 – Accelerometer Measurements
N	 uint8_t accel_data_x_h(){return reg_gyro_acc::ACCEL_XOUT_H;}
N	 uint8_t accel_data_x_l(){return reg_gyro_acc::ACCEL_XOUT_L;}
N	 uint8_t accel_data_y_h(){return reg_gyro_acc::ACCEL_YOUT_H;}
N	 uint8_t accel_data_y_l(){return reg_gyro_acc::ACCEL_YOUT_L;}
N	 uint8_t accel_data_z_h(){return reg_gyro_acc::ACCEL_ZOUT_H;}
N	 uint8_t accel_data_z_l(){return reg_gyro_acc::ACCEL_ZOUT_L;}
N	 
N	 // Registers 65 and 66 – Temperature Measurement
N	 uint8_t temp_data_h(){return reg_gyro_acc::TEMP_OUT_H;}
N	 uint8_t temp_data_l(){return reg_gyro_acc::TEMP_OUT_L;}
N	 
N	 // Registers 67 to 72 – Gyroscope Measurements
N	 uint8_t gyro_data_x_h(){return reg_gyro_acc::GYRO_XOUT_H;}
N	 uint8_t gyro_data_x_l(){return reg_gyro_acc::GYRO_XOUT_L;}
N	 uint8_t gyro_data_y_h(){return reg_gyro_acc::GYRO_YOUT_H;}
N	 uint8_t gyro_data_y_l(){return reg_gyro_acc::GYRO_YOUT_L;}
N	 uint8_t gyro_data_z_h(){return reg_gyro_acc::GYRO_ZOUT_H;}
N	 uint8_t gyro_data_z_l(){return reg_gyro_acc::GYRO_ZOUT_L;}
N	 
N	 // Registers 73 to 96 – External Sensor Data
N	 uint8_t ext_sens_data_0() {return reg_gyro_acc::EXT_SENS_DATA_00;}
N	 uint8_t ext_sens_data_1() {return reg_gyro_acc::EXT_SENS_DATA_01;}
N	 uint8_t ext_sens_data_2() {return reg_gyro_acc::EXT_SENS_DATA_02;}
N	 uint8_t ext_sens_data_3() {return reg_gyro_acc::EXT_SENS_DATA_03;}
N	 uint8_t ext_sens_data_4() {return reg_gyro_acc::EXT_SENS_DATA_04;}
N	 uint8_t ext_sens_data_5() {return reg_gyro_acc::EXT_SENS_DATA_05;}
N	 uint8_t ext_sens_data_6() {return reg_gyro_acc::EXT_SENS_DATA_06;}
N	 uint8_t ext_sens_data_7() {return reg_gyro_acc::EXT_SENS_DATA_07;}
N	 uint8_t ext_sens_data_8() {return reg_gyro_acc::EXT_SENS_DATA_08;}
N	 uint8_t ext_sens_data_9() {return reg_gyro_acc::EXT_SENS_DATA_09;}
N	 uint8_t ext_sens_data_10(){return reg_gyro_acc::EXT_SENS_DATA_10;}
N	 uint8_t ext_sens_data_11(){return reg_gyro_acc::EXT_SENS_DATA_11;}
N	 uint8_t ext_sens_data_12(){return reg_gyro_acc::EXT_SENS_DATA_12;}
N	 uint8_t ext_sens_data_13(){return reg_gyro_acc::EXT_SENS_DATA_13;}
N	 uint8_t ext_sens_data_14(){return reg_gyro_acc::EXT_SENS_DATA_14;}
N	 uint8_t ext_sens_data_15(){return reg_gyro_acc::EXT_SENS_DATA_15;}
N	 uint8_t ext_sens_data_17(){return reg_gyro_acc::EXT_SENS_DATA_17;}
N	 uint8_t ext_sens_data_18(){return reg_gyro_acc::EXT_SENS_DATA_18;}
N	 uint8_t ext_sens_data_19(){return reg_gyro_acc::EXT_SENS_DATA_19;}
N	 uint8_t ext_sens_data_20(){return reg_gyro_acc::EXT_SENS_DATA_20;}
N	 uint8_t ext_sens_data_21(){return reg_gyro_acc::EXT_SENS_DATA_21;}
N	 uint8_t ext_sens_data_22(){return reg_gyro_acc::EXT_SENS_DATA_22;}
N	 uint8_t ext_sens_data_23(){return reg_gyro_acc::EXT_SENS_DATA_23;}
N	 
N	 // Register 99 – I2C Slave 0 Data Out
N	 uint8_t data_out_slv0_wr(){return reg_gyro_acc::I2C_SLV0_DO;}
N	 
N	 // Register 100 – I2C Slave 1 Data Out
N	 uint8_t data_out_slv1_wr(){return reg_gyro_acc::I2C_SLV1_DO;}
N	 
N	 // Register 101 – I2C Slave 2 Data Out
N	 uint8_t data_out_slv2_wr(){return reg_gyro_acc::I2C_SLV2_DO;}
N	 
N	  // Register 102 – I2C Slave 3 Data Out
N	 uint8_t data_out_slv3_wr(){return reg_gyro_acc::I2C_SLV3_DO;}
N
N	 // Register 103 – I2C Master Delay Control
N	 uint8_t delay_shadow_ext_sens_ctrl(uint8_t *const Byte = nullptr, VEnDis DELAY_ES_SHADOW = VEnDis::_DISABLE);
N	 uint8_t slv4_dly_access_ctrl(uint8_t *const Byte = nullptr,       VEnDis I2C_SLV4_DLY_EN = VEnDis::_DISABLE);
N	 uint8_t slv3_dly_access_ctrl(uint8_t *const Byte = nullptr,       VEnDis I2C_SLV3_DLY_EN = VEnDis::_DISABLE);
N	 uint8_t slv2_dly_access_ctrl(uint8_t *const Byte = nullptr,       VEnDis I2C_SLV2_DLY_EN = VEnDis::_DISABLE);
N	 uint8_t slv1_dly_access_ctrl(uint8_t *const Byte = nullptr,       VEnDis I2C_SLV1_DLY_EN = VEnDis::_DISABLE);
N	 uint8_t slv0_dly_access_ctrl(uint8_t *const Byte = nullptr,       VEnDis I2C_SLV0_DLY_EN = VEnDis::_DISABLE);
N	 
N	 // Register 104 – Signal Path Reset
N	 uint8_t reset_gyro_signal_path(uint8_t *const Byte = nullptr,  VEnDis GYRO_RST = VEnDis::_DISABLE);
N	 uint8_t reset_accel_signal_path(uint8_t *const Byte = nullptr, VEnDis ACCEL_RST = VEnDis::_DISABLE);
N	 uint8_t reset_temp_signal_path(uint8_t *const Byte = nullptr,  VEnDis TEMP_RST = VEnDis::_DISABLE);
N	 
N	 // Register 105 – Accelerometer Interrupt Control 
N	 uint8_t accel_wake_on_motion_ctrl(uint8_t *const Byte = nullptr,  VEnDis ACCEL_INTEL_EN = VEnDis::_DISABLE);
N	 uint8_t accel_compare_samples_ctrl(uint8_t *const Byte = nullptr, VEnDis ACCEL_INTEL_MODE = VEnDis::_DISABLE);
N	 
N	 // Register 106 – User Control
N	 uint8_t fifo_mode_ctrl(uint8_t *const Byte = nullptr,            VEnDis FIFO_EN = VEnDis::_DISABLE);
N	 uint8_t i2c_master_if_module_ctrl(uint8_t *const Byte = nullptr, VI2CMasterCtrl I2C_MST_EN = VI2CMasterCtrl::_DISABLE_I2C_MASTER_MODULE);
N	 uint8_t interface_mode_ctrl(uint8_t *const Byte = nullptr,       VEnDis I2C_IF_DIS = VEnDis::_DISABLE);
N	 uint8_t reset_fifo_module(uint8_t *const Byte = nullptr,         VEnDis FIFO_RST = VEnDis::_DISABLE);
N	 uint8_t reset_i2c_master_module(uint8_t *const Byte = nullptr,   VEnDis I2C_MST_RST = VEnDis::_DISABLE);
N	 uint8_t reset_all_signal_path(uint8_t *const Byte = nullptr,     VEnDis SIG_COND_RST = VEnDis::_DISABLE);
N	 
N	 // Register 107 – Power Management 1
N	 uint8_t reset_and_restore_internal_regs(uint8_t *const Byte = nullptr, VSetReset H_RESET = VSetReset::_RESET);
N	 uint8_t sleep_ctrl(uint8_t *const Byte = nullptr,                      VSetReset SLEEP = VSetReset::_RESET);
N	 uint8_t cycle_ctrl(uint8_t *const Byte = nullptr,                      VSetReset CYCLE = VSetReset::_RESET);
N	 uint8_t gyro_standby_ctrl(uint8_t *const Byte = nullptr,               VSetReset GYRO_STANDBY = VSetReset::_RESET);
N	 uint8_t voltage_generator_ctrl(uint8_t *const Byte = nullptr,          VSetReset PD_PTAT = VSetReset::_RESET);
N	 uint8_t clock_src_choise(uint8_t *const Byte = nullptr,                VClockSrcChoise CLKSEL = VClockSrcChoise::_INTERNAL_20MHz);
N	 
N	 // Register 108 – Power Management 2
N    uint8_t accel_x_ctrl(uint8_t *const Byte = nullptr, VEnDis DISABLE_XA = VEnDis::_DISABLE );
N    uint8_t accel_y_ctrl(uint8_t *const Byte = nullptr, VEnDis DISABLE_YA = VEnDis::_DISABLE );
N    uint8_t accel_z_ctrl(uint8_t *const Byte = nullptr, VEnDis DISABLE_ZA = VEnDis::_DISABLE );
N    uint8_t gyro_x_ctrl(uint8_t *const Byte = nullptr,  VEnDis DISABLE_XG = VEnDis::_DISABLE  );
N    uint8_t gyro_y_ctrl(uint8_t *const Byte = nullptr,  VEnDis DISABLE_YG = VEnDis::_DISABLE  );
N    uint8_t gyro_z_ctrl(uint8_t *const Byte = nullptr,  VEnDis DISABLE_ZG = VEnDis::_DISABLE  );
N	 
N	 // Register 114 and 115 – FIFO Count Registers
N	 uint8_t fifo_high_bits_count(uint8_t *const Byte = nullptr, uint8_t FIFO_CNT = 0);
N	 uint8_t fifo_low_bits_count(){return reg_gyro_acc::FIFO_COUNTL;}
N	 
N	 // Register 116 – FIFO Read Write
N	 uint8_t r_w_fifo_data(){return reg_gyro_acc::FIFO_R_W;}
N	 
N	 // Register 117 – Who Am I
N    uint8_t get_who_am_i(){return reg_gyro_acc::WHO_AM_I;} // 0x71
N	 
N	 // Registers 119, 120, 122, 123, 125, 126 Accelerometer Offset Registers
N	 uint8_t accel_upper_x_offset_cancel(){return reg_gyro_acc::XA_OFFSET_H;}
N	 uint8_t accel_lower_x_offset_cancel(){return reg_gyro_acc::XA_OFFSET_L;}
N	 uint8_t accel_upper_y_offset_cancel(){return reg_gyro_acc::YA_OFFSET_H;}
N	 uint8_t accel_lower_y_offset_cancel(){return reg_gyro_acc::YA_OFFSET_L;}
N	 uint8_t accel_upper_z_offset_cancel(){return reg_gyro_acc::ZA_OFFSET_H;}
N	 uint8_t accel_lower_z_offset_cancel(){return reg_gyro_acc::ZA_OFFSET_L;}
N	 
N//----- REGISTER MAP FOR MAGNETOMETER ---------------------------------------------------------
N	 
N	 // WIA: Device ID
N	 uint8_t mag_device_id(){return reg_mag::WIA;} // 0x48
N	 
N	 // INFO: Information
N	 uint8_t mag_information(){return reg_mag::INFO;}
N	 
N	 // ST1: Status 1
N	 uint8_t mag_data_ready(const uint8_t Byte = 0,   VStatusFlag *DOR = nullptr);
N	 uint8_t mag_data_overrun(const uint8_t Byte = 0, VStatusFlag *DRDY = nullptr);
N	 
N	 // HXL to HZH: Measurement Data 
N	 uint8_t mag_lower_x_data(){return reg_mag::HXL;}
N	 uint8_t mag_higher_x_data(){return reg_mag::HXH;}
N	 uint8_t mag_lower_y_data(){return reg_mag::HYL;}
N	 uint8_t mag_higher_y_data(){return reg_mag::HYH;}
N	 uint8_t mag_lower_z_data(){return reg_mag::HZL;}
N	 uint8_t mag_higher_z_data(){return reg_mag::HZH;}
N	 
N	 // ST2: Status 2
N	 uint8_t mag_overflow(const uint8_t Byte = 0,        VStatusFlag *HOFL = nullptr);
N	 uint8_t mag_mirror_data_bit(const uint8_t Byte = 0, VStatusFlag *BITM = nullptr);
N	 
N	 // CNTL1: Control 1
N	 uint8_t mag_operation_mode_set(uint8_t *const Byte = nullptr, VMagOperationModeSet MODE = VMagOperationModeSet::_POWER_DOWN);
N	 uint8_t mag_operation_mode_read(const uint8_t Byte, VMagOperationModeSet *MODE = nullptr);
N	 uint8_t mag_output_bit_set(uint8_t *const Byte = nullptr,     VMagOutputBitSet BIT = VMagOutputBitSet::_16_BIT_OUTPUT);
N	 uint8_t mag_output_bit_read(const uint8_t Byte, VMagOutputBitSet *BIT = nullptr);
N	 
N	 // CNTL2: Control 2
N	 uint8_t mag_soft_reset_ctrl(uint8_t *const Byte = nullptr, VMagSoftResetCtrl SRST = VMagSoftResetCtrl::_RESET);
N	 
N	 // ASTC: Self-Test Control
N    uint8_t mag_self_test_ctrl(uint8_t *const Byte = nullptr, VMagSelfTestCtrl SELF = VMagSelfTestCtrl::_NORMAL);
N	 
N	 // I2CDIS: I2C Disable
N    uint8_t mag_i2c_disable(uint8_t *const Byte = nullptr); //отключить I2С интерфейс, для повторного включения - 8 раз подряд отправить старт условие
N	 
N	 // ASAX, ASAY, ASAZ: Sensitivity Adjustment values
N	 uint8_t mag_sens_adj_x(){return reg_mag::ASAX;}
N	 uint8_t mag_sens_adj_y(){return reg_mag::ASAY;}
N	 uint8_t mag_sens_adj_z(){return reg_mag::ASAZ;}
N	 
N    template<typename T_Data, typename T_Reg>                   //для ro регистров
N    void read(const uint8_t Byte, T_Data *Data, T_Reg Reg)
N    {
N      if (Data != nullptr)
N	   {
N	     *Data = static_cast<T_Data>(((T_Reg *)&Byte)->Dest);
N	   }
N    }
N  private:
N
N    template<typename T_Mode, typename T_Reg>                  //для r/w регистров
N    void operate(uint8_t *const Byte, T_Mode Mode, T_Reg Reg)
N    {
N      if (Byte != nullptr)
N		    {
N		      ((T_Reg *)Byte)->Dest = static_cast<uint8_t>(Mode);
N		    }
N	   }
N	 	
N//    void fill_in_vector(const TI2CProtocol Src[], std::vector<TI2CProtocol> &Dest); //заполняет вектор элементами массива
N//	 const TLogicLevelAD0 Level = {_HIGH};
N//-----------------------------------------------------------------------------------------------
N    
N  };
N}
N
N#endif
L 2 "Source\Ext_Dev\src\MPU-9250_acc_gyro_mag_driver_ll.cpp" 2
N
Nnamespace MPU_9250
N{
N//  constexpr TI2CProtocol _ProtocolWrOne[] = {ST, SADW, SAK, SUB, SAK, DATAM, SAK, SP}; 
N//  constexpr TI2CProtocol _ProtocolWrMul[] = {ST, SADW, SAK, SUB, SAK, DATAM, SAK, DATAM, SAK, SP}; 
N//  constexpr TI2CProtocol _ProtocolRdOne[] = {ST, SADW, SAK, SUB, SAK, SR, SADR, SAK, DATAS, NMAK, SP}; 
N//  constexpr TI2CProtocol _ProtocolRdMul[] = {ST, SADW, SAK, SUB, SAK, SR, SADR, SAK, DATAS, MAK, DATAS, NMAK, SP}; 
N
N//  void TAccGyroMagDriver_LL::fill_in_vector(const TI2CProtocol Src[], std::vector<TI2CProtocol> &Dest)
N//  {
N//    std::vector<TI2CProtocol> Temp(Src, Src + sizeof Src / sizeof Src[0]);
N//	   Dest = Temp;
N//  }
N
N  TAccGyroMagDriver_LL::TAccGyroMagDriver_LL()
N  {  	 
N//	   fill_in_vector(_ProtocolWrOne, ProtocolWrOne);
N//	   fill_in_vector(_ProtocolWrMul, ProtocolWrMul);
N//	   fill_in_vector(_ProtocolRdOne, ProtocolRdOne);
N//	   fill_in_vector(_ProtocolRdMul, ProtocolRdMul);
N  }
N
N  TAccGyroMagDriver_LL::~TAccGyroMagDriver_LL()
N  {
N  
N  }
N
N  uint8_t TAccGyroMagDriver_LL::get_acc_gyro_addr(TLogicLevelAD0 Level) const
N  {
N    constexpr uint8_t Addr[] = 
N	   {0x68, 0x69};
N    
N	   return Addr[Level];
N  }
N
N  uint8_t TAccGyroMagDriver_LL::get_mag_addr() const
N  {
N    return 0x0C;  //The slave address for the AK8963 is 0X0C or 12 decimal
N  }
N//-----------------------------------------------------------------------------------------------
N  // Registers 0 to 2 – Gyroscope Self-Test Registers 
N  
N//  uint8_t TAccGyroMagDriver_LL::get_st_x_gyro(uint8_t *const Byte, VSwitch DRDY_G)
N//  {
N//    SGyroDataReady Reg;
N////    operate(Byte, );
N//    return reg_gyro_acc::SELF_TEST_X_GYRO;
N//  }
N
N//  uint8_t TAccGyroMagDriver_LL::get_st_y_gyro(uint8_t *const Byte, )
N//  {
N////    operate(Byte, );
N//    return reg_gyro_acc::SELF_TEST_Y_GYRO;
N//  }
N
N//  uint8_t TAccGyroMagDriver_LL::get_st_z_gyro(uint8_t *const Byte, )
N//  {
N////    operate(Byte, );
N//    return reg_gyro_acc::SELF_TEST_Z_GYRO;
N//  }
N
N//  // Registers 13 to 15 – Accelerometer Self-Test Registers
N
N//  uint8_t TAccGyroMagDriver_LL::get_st_x_accel(uint8_t *const Byte, )
N//  {
N////    operate(Byte, );
N//    return reg_gyro_acc::SELF_TEST_X_ACCEL;
N//  }
N
N//  uint8_t TAccGyroMagDriver_LL::get_st_y_accel(uint8_t *const Byte, )
N//  {
N////    operate(Byte, );
N//    return reg_gyro_acc::SELF_TEST_Y_ACCEL;
N//  }
N
N//  uint8_t TAccGyroMagDriver_LL::get_st_z_accel(uint8_t *const Byte, )
N//  {
N////    operate(Byte, );
N//    return reg_gyro_acc::SELF_TEST_Z_ACCEL;
N//  } 
N  
N  //  Registers 19 to 24 – Gyro Offset Registers
N  
N//  uint8_t TAccGyroMagDriver_LL::remove_gyro_bias_x_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::XG_OFFSET_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::remove_gyro_bias_x_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::XG_OFFSET_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::remove_gyro_bias_y_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::YG_OFFSET_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::remove_gyro_bias_y_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::YG_OFFSET_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::remove_gyro_bias_z_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ZG_OFFSET_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::remove_gyro_bias_z_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ZG_OFFSET_L;
N//  }
N  
N  // Register 25 – Sample Rate Divider
N  
N//  uint8_t TAccGyroMagDriver_LL::sample_rate_divider(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::SMPLRT_DIV;
N//  }
N  
N  // Register 26 – Configuration
N  
N  uint8_t TAccGyroMagDriver_LL::fifo_mode_config(uint8_t *const Byte, VFifoModeConfig FIFO_MODE)
N  {
N    TFifoModeConfig Reg;
N	  operate(Byte, FIFO_MODE, Reg);
N    return reg_gyro_acc::CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fsync_pin_config(uint8_t *const Byte, VFsyncPinConfig EXT_SYNC_SET)
N  {
N    TFsyncPinConfig Reg;
N	  operate(Byte, EXT_SYNC_SET, Reg);
N    return reg_gyro_acc::CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::filter_gyro_temp_config(uint8_t *const Byte, VFilterGyroTempConfig DLPF_CFG)
N  {
N    TFilterGyroTempConfig Reg;
N	  operate(Byte, DLPF_CFG, Reg);
N    return reg_gyro_acc::CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::filter_gyro_temp_read(uint8_t Byte, VFilterGyroTempConfig *DLPF_CFG)
N  {
N    TFilterGyroTempConfig Reg;
N    read(Byte, DLPF_CFG, Reg);
N    return reg_gyro_acc::CONFIG;
N  }
N  
N  // Register 27 – Gyroscope Configuration
N  
N  uint8_t TAccGyroMagDriver_LL::enable_x_gyro_self_test(uint8_t *const Byte, VEnDis XGYRO_Cten)
N  {
N    TEnableXGyroSelfTest Reg;
N	 operate(Byte, XGYRO_Cten, Reg);
N    return reg_gyro_acc::GYRO_CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::enable_y_gyro_self_test(uint8_t *const Byte, VEnDis YGYRO_Cten)
N  {
N    TEnableYGyroSelfTest Reg;
N	 operate(Byte, YGYRO_Cten, Reg);
N    return reg_gyro_acc::GYRO_CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::enable_z_gyro_self_test(uint8_t *const Byte, VEnDis ZGYRO_Cten)
N  {
N    TEnableZGyroSelfTest Reg;
N	 operate(Byte, ZGYRO_Cten, Reg);
N    return reg_gyro_acc::GYRO_CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::gyro_full_scale_select(uint8_t *const Byte, VGyroFullScaleSelect GYRO_FS_SEL)
N  {
N    TGyroFullScaleSelect Reg;
N	 operate(Byte, GYRO_FS_SEL, Reg);
N    return reg_gyro_acc::GYRO_CONFIG;
N  }
N    
N  uint8_t TAccGyroMagDriver_LL::gyro_full_scale_read(const uint8_t Byte, VGyroFullScaleSelect *GYRO_FS_SEL)
N  {
N    TGyroFullScaleSelect Reg;
N    read(Byte, GYRO_FS_SEL, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::gyro_filter_choise(uint8_t *const Byte, VGyroFilterChoise Fchoice_b)
N  {
N    TGyroFilterChoise Reg;
N	 operate(Byte, Fchoice_b, Reg);
N    return reg_gyro_acc::GYRO_CONFIG;
N  }
N  
N  // Register 28 – Accelerometer Configuration
N  
N  uint8_t TAccGyroMagDriver_LL::enable_x_accel_self_test(uint8_t *const Byte, VEnDis ax_st_en)
N  {
N    TEnableXAccelSelfTest Reg;
N	 operate(Byte, ax_st_en, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::enable_y_accel_self_test(uint8_t *const Byte, VEnDis ay_st_en)
N  {
N    TEnableYAccelSelfTest Reg;
N	 operate(Byte, ay_st_en, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::enable_z_accel_self_test(uint8_t *const Byte, VEnDis az_st_en)
N  {
N    TEnableZAccelSelfTest Reg;
N	 operate(Byte, az_st_en, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::accel_full_scale_select(uint8_t *const Byte, VAccelFullScaleSelect ACCEL_FS_SEL)
N  {
N    TAccelFullScaleSelect Reg;
N	 operate(Byte, ACCEL_FS_SEL, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG;
N  }
N  
N  // Register 29 – Accelerometer Configuration 2
N  
N  uint8_t TAccGyroMagDriver_LL::accel_filter_choise(uint8_t *const Byte, VAccelFilterChoise accel_fchoice_b)
N  {
N    TAcceFilterChoise Reg;
N	 operate(Byte, accel_fchoice_b, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::set_accel_filter(uint8_t *const Byte, VSetAccelFilter A_DLPFCFG)
N  {
N    TSetAccelFilter Reg;
N	 operate(Byte, A_DLPFCFG, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::accel_filter_read(uint8_t Byte, VSetAccelFilter *A_DLPFCFG)
N  {
N    TSetAccelFilter Reg;
N	 read(Byte, A_DLPFCFG, Reg);
N    return reg_gyro_acc::ACCEL_CONFIG_2;
N  }
N   
N  // Register 30 - Low Power Accelerometer ODR Control
N  
N  uint8_t TAccGyroMagDriver_LL::set_accel_wakeup_freq(uint8_t *const Byte, VSetAccelWakeupFreq lposc_clksel)
N  {
N    TSetAccelWakeupFreq Reg;
N	 operate(Byte, lposc_clksel, Reg);
N    return reg_gyro_acc::LP_ACCEL_ODR;
N  }
N  
N  // Register 31 – Wake-on Motion Threshold
N  
N//  uint8_t TAccGyroMagDriver_LL::set_wakeon_motion_thr(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::WOM_THR;
N//  }
N  
N  // Register 35 – FIFO Enable
N  
N  uint8_t TAccGyroMagDriver_LL::write_temp_to_fifo(uint8_t *const Byte, VEnDis TEMP_OUT)
N  {
N    TWrTempToFifo Reg;
N	 operate(Byte, TEMP_OUT, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_gyro_x_to_fifo(uint8_t *const Byte, VEnDis GYRO_XOUT)
N  {
N    TWrGyroXToFifo Reg;
N	 operate(Byte, GYRO_XOUT, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_gyro_y_to_fifo(uint8_t *const Byte, VEnDis GYRO_YOUT)
N  {
N    TWrGyroYToFifo Reg;
N	 operate(Byte, GYRO_YOUT, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_gyro_z_to_fifo(uint8_t *const Byte, VEnDis GYRO_ZOUT)
N  {
N    TWrGyroZToFifo Reg;
N	 operate(Byte, GYRO_ZOUT, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_accel_to_fifo(uint8_t *const Byte, VEnDis ACCEL)
N  {
N    TWrAccelToFifo Reg;
N	 operate(Byte, ACCEL, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_slave2_to_fifo(uint8_t *const Byte, VEnDis SLV_2)
N  {
N    TWrSlave2ToFifo Reg;
N	 operate(Byte, SLV_2, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_slave1_to_fifo(uint8_t *const Byte, VEnDis SLV_1)
N  {
N    TWrSlave1ToFifo Reg;
N	 operate(Byte, SLV_1, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_slave0_to_fifo(uint8_t *const Byte, VEnDis SLV_0)
N  {
N    TWrSlave0ToFifo Reg;
N	 operate(Byte, SLV_0, Reg);
N    return reg_gyro_acc::FIFO_EN;
N  }
N  
N  // Register 36 – I2C Master Control
N  
N  uint8_t TAccGyroMagDriver_LL::multi_master_enable(uint8_t *const Byte, VEnDis MULT_MST_EN)
N  {
N    TMultiMasterEnable Reg;
N	 operate(Byte, MULT_MST_EN, Reg);
N    return reg_gyro_acc::I2C_MST_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::delay_data_ready_int(uint8_t *const Byte, VEnDis WAIT_FOR_ES)
N  {
N    TDelayDataReadyInt Reg;
N	 operate(Byte, WAIT_FOR_ES, Reg);
N    return reg_gyro_acc::I2C_MST_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::write_data_slv3_to_fifo(uint8_t *const Byte, VEnDis SLV_3_FIFO_EN)
N  {
N    TWriteDataSlv3ToFifo Reg;
N	 operate(Byte, SLV_3_FIFO_EN, Reg);
N    return reg_gyro_acc::I2C_MST_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::ctrl_slave_read_transition(uint8_t *const Byte, VEnDis I2C_MST_P_NSR)
N  {
N    TCtrlSlaveReadTransition Reg;
N	 operate(Byte, I2C_MST_P_NSR, Reg);
N    return reg_gyro_acc::I2C_MST_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::config_internal_clk(uint8_t *const Byte, VConfigInternalClk I2C_MST_CLK)
N  {
N    TCfgInternalClk Reg;
N    operate(Byte, I2C_MST_CLK, Reg);
N    return reg_gyro_acc::I2C_MST_CTRL;
N  }
N  
N  // Register 37 - I2C_SLV0_ADDR
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_direct_transfer(uint8_t *const Byte, VI2CTransferType I2C_SLV0_RNW)
N  {
N    TSlv0DirectTransfer Reg;
N	 operate(Byte, I2C_SLV0_RNW, Reg);
N    return reg_gyro_acc::I2C_SLV0_ADDR;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_phy_address(uint8_t *const Byte, const uint8_t Addr_7Bit)
N  {
N    TSlv0PhyAddress Reg;
N	 operate(Byte, Addr_7Bit, Reg);
N    return reg_gyro_acc::I2C_SLV0_ADDR;
N  }
N  
N  // Register 38 - I2C_SLV0_REG 
N  
N//  uint8_t TAccGyroMagDriver_LL::slv0_reg_address_begin(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV0_REG;
N//  }
N  
N  // Register 39 - I2C_SLV0_CTRL
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_enable(uint8_t *const Byte, VEnDis I2C_SLV0_EN)
N  {
N    TSlv0Enable Reg;
N	 operate(Byte, I2C_SLV0_EN, Reg);
N    return reg_gyro_acc::I2C_SLV0_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_swap_bytes(uint8_t *const Byte, VEnDis I2C_SLV0_BYTE_SW)
N  {
N    TSlv0SwapBytes Reg;
N	 operate(Byte, I2C_SLV0_BYTE_SW, Reg);
N    return reg_gyro_acc::I2C_SLV0_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_write_reg_enable(uint8_t *const Byte, VEnDis I2C_SLV0_REG_DIS)
N  {
N    TSlv0WriteReg Reg;
N	 operate(Byte, I2C_SLV0_REG_DIS, Reg);
N    return reg_gyro_acc::I2C_SLV0_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_group_data(uint8_t *const Byte, VEnDis I2C_SLV0_GRP)
N  {
N    TSlv0GroupData Reg;
N	 operate(Byte, I2C_SLV0_GRP, Reg);
N    return reg_gyro_acc::I2C_SLV0_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_num_bytes_read(uint8_t *const Byte, VSlvNumBytesRead I2C_SLV0_LENG)
N  {
N    TSlv0NumBytesRead Reg;
N	 operate(Byte, I2C_SLV0_LENG, Reg);
N    return reg_gyro_acc::I2C_SLV1_CTRL;
N  }
N//  
N//  // Register 40 - I2C_SLV1_ADDR
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_transfer_type(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_ADDR;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_phy_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_ADDR;
N//  }
N//  
N//  // Register 41 - I2C_SLV1_REG
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_reg_address_begin(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_REG;
N//  }
N//  
N//  // Register 42 - I2C_SLV1_CTRL
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_enable(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_swap_bytes(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_transaction_ctrl(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_determine_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv1_num_bytes_read(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_CTRL;
N//  }
N//  
N//  // Register 43 - I2C_SLV2_ADDR
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_transfer_type(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_ADDR;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_phy_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_ADDR;
N//  }
N//  
N//  // Register 44 - I2C_SLV2_REG
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_reg_address_begin(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_REG;
N//  }
N//  
N//  // Register 45 - I2C_SLV2_CTRL
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_enable(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_swap_bytes(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_transaction_ctrl(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_determine_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv2_num_bytes_read(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_CTRL;
N//  }
N//  
N//  // Register 46 - I2C_SLV3_ADDR
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_transfer_type(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_ADDR;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_phy_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_ADDR;
N//  }
N//  
N//  // Register 47 - I2C_SLV3_REG
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_reg_address_begin(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_REG;
N//  }
N//  
N//  // Register 48 - I2C_SLV3_CTRL
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_enable(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_swap_bytes(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_transaction_ctrl(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_determine_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv3_num_bytes_read(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_CTRL;
N//  }
N//  
N//  // Register 49 - I2C_SLV4_ADDR
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_transfer_type(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_ADDR;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_phy_address(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_ADDR;
N//  }
N//  
N//  // Register 50 - I2C_SLV4_REG
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_reg_address_begin(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_REG;
N//  }
N//  
N//  // Register 51 - I2C_SLV4_DO
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_data_wr(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_DO;
N//  }
N//  
N//  // Register 52 - I2C_SLV4_CTRL
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_enable(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_complete_and_int(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_transaction_ctrl(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_CTRL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::num_samples_ctrl(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_CTRL;
N//  }
N//  
N//  // Register 53 - I2C_SLV4_DI
N//  
N//  uint8_t TAccGyroMagDriver_LL::slv4_data_rd(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV4_DI;
N//  }
N//  
N  // Register 54 – I2C Master Status
N  
N  uint8_t TAccGyroMagDriver_LL::status_fsync_interrupt(const uint8_t Byte, VStatusFlag *PASS_THROUGH)
N  {
N    TStatusFsyncInterrupt Reg;
N    read(Byte, PASS_THROUGH, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv4_transfer_complete(const uint8_t Byte, VStatusFlag *I2C_SLV4_DONE)
N  {
N    TSlv4TransferComplete Reg;
N    read(Byte, I2C_SLV4_DONE, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv_lost_arbitration(const uint8_t Byte, VStatusFlag *I2C_LOST_ARB)
N  {
N    TSlvLostArbitration Reg;
N    read(Byte, I2C_LOST_ARB, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv4_rx_nack(const uint8_t Byte, VStatusFlag *I2C_SLV4_NACK)
N  {
N    TSlv4RxNack Reg;
N    read(Byte, I2C_SLV4_NACK, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv3_rx_nack(const uint8_t Byte, VStatusFlag *I2C_SLV3_NACK)
N  {
N    TSlv3RxNack Reg;
N    read(Byte, I2C_SLV3_NACK, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv2_rx_nack(const uint8_t Byte, VStatusFlag *I2C_SLV2_NACK)
N  {
N    TSlv2RxNack Reg;
N    read(Byte, I2C_SLV2_NACK, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv1_rx_nack(const uint8_t Byte, VStatusFlag *I2C_SLV1_NACK)
N  {
N    TSlv1RxNack Reg;
N    read(Byte, I2C_SLV1_NACK, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_rx_nack(const uint8_t Byte, VStatusFlag *I2C_SLV0_NACK)
N  {
N    TSlv0RxNack Reg;
N    read(Byte, I2C_SLV0_NACK, Reg);
N    return reg_gyro_acc::I2C_MST_STATUS;
N  }
N  
N  // Register 55 – INT Pin / Bypass Enable Configuration
N  
N  uint8_t TAccGyroMagDriver_LL::int_logic_level(uint8_t *const Byte, VLogicLevelINT ACTL)
N  {
N    TIntLogicLevel Reg;
N    operate(Byte, ACTL, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::int_pin_config(uint8_t *const Byte, VPinConfigINT OPEN)
N  {
N    TIntPinConfig Reg;
N    operate(Byte, OPEN, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::int_latch_ctrl(uint8_t *const Byte, VLatchINT LATCH_INT_EN)
N  {
N    TIntLatchCtrl Reg;
N    operate(Byte, LATCH_INT_EN, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::int_status_ctrl(uint8_t *const Byte, VEnDis INT_ANYRD_2CLEAR)
N  {
N    TIntStatusCtrl Reg;
N    operate(Byte, INT_ANYRD_2CLEAR, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fsync_level_ctrl(uint8_t *const Byte, VEnDis ACTL_FSYNC)
N  {
N    TFsyncLevelCtrl Reg;
N    operate(Byte, ACTL_FSYNC, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fsync_enable(uint8_t *const Byte, VEnDis FSYNC_INT_MODE_EN)
N  {
N    TFsyncEnable Reg;
N    operate(Byte, FSYNC_INT_MODE_EN, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::i2c_master_pins_ctrl(uint8_t *const Byte, VEnDis BYPASS_EN)
N  {
N    TI2CMasterPinsCtrl Reg;
N    operate(Byte, BYPASS_EN, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::i2c_master_pins_read(const uint8_t Byte, VEnDis *BYPASS_EN)
N  {
N    TI2CMasterPinsCtrl Reg;
N    read(Byte, BYPASS_EN, Reg);
N    return reg_gyro_acc::INT_PIN_CFG;
N  }
N  
N  // Register 56 – Interrupt Enable
N  
N  uint8_t TAccGyroMagDriver_LL::wake_on_motion_int_ctrl(uint8_t *const Byte, VEnDis WOM_EN)
N  {
N    TWakeOnMotionIntCtrl Reg;
N    operate(Byte, WOM_EN, Reg);
N    return reg_gyro_acc::INT_ENABLE;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fifo_ovrf_int_ctrl(uint8_t *const Byte, VEnDis FIFO_OVERFLOW_EN)
N  {
N    TFifoOvrfIntCtrl Reg;
N    operate(Byte, FIFO_OVERFLOW_EN, Reg);
N    return reg_gyro_acc::INT_ENABLE;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fsync_int_ctrl(uint8_t *const Byte, VEnDis FSYNC_INT_EN)
N  {
N    TFsyncIntCtrl Reg;
N    operate(Byte, FSYNC_INT_EN, Reg);
N    return reg_gyro_acc::INT_ENABLE;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::raw_data_ready_int_ctrl(uint8_t *const Byte, VEnDis RAW_RDY_EN)
N  {
N    TRawDataReadyIntCtrl Reg;
N    operate(Byte, RAW_RDY_EN, Reg);
N    return reg_gyro_acc::INT_ENABLE;
N  }
N  
N  // Register 58 – Interrupt Status
N  
N  uint8_t TAccGyroMagDriver_LL::wake_on_motion_int_status(const uint8_t Byte, VStatusFlag *WOM_INT)
N  {
N    TWakeOnMotionIntStatus Reg;
N    read(Byte, WOM_INT, Reg);
N    return reg_gyro_acc::INT_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fifo_ovrf_int_status(const uint8_t Byte, VStatusFlag *FIFO_OVERFLOW_INT)
N  {
N    TFifoOvrfIntStatus Reg;
N    read(Byte, FIFO_OVERFLOW_INT, Reg);
N    return reg_gyro_acc::INT_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::fsync_int_status(const uint8_t Byte, VStatusFlag *FSYNC_INT)
N  {
N    TFsyncIntStatus Reg;
N    read(Byte, FSYNC_INT, Reg);
N    return reg_gyro_acc::INT_STATUS;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::raw_data_ready_int_status(const uint8_t Byte, VStatusFlag *RAW_DATA_RDY_INT)
N  {
N    TRawDataReadyIntStatus Reg;
N    read(Byte, RAW_DATA_RDY_INT, Reg);
N    return reg_gyro_acc::INT_STATUS;
N  }
N  
N  // Registers 59 to 64 – Accelerometer Measurements
N  
N//  uint8_t TAccGyroMagDriver_LL::accel_data_x_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ACCEL_XOUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_data_x_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ACCEL_XOUT_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_data_y_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ACCEL_YOUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_data_y_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ACCEL_YOUT_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_data_z_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ACCEL_ZOUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_data_z_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ACCEL_ZOUT_L;
N//  }
N//  
N  // Registers 65 and 66 – Temperature Measurement
N  
N//  uint8_t TAccGyroMagDriver_LL::temp_data_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::TEMP_OUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::temp_data_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::TEMP_OUT_L;
N//  }
N//  
N  // Registers 67 to 72 – Gyroscope Measurements
N  
N//  uint8_t TAccGyroMagDriver_LL::gyro_data_x_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::GYRO_XOUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::gyro_data_x_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::GYRO_XOUT_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::gyro_data_y_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::GYRO_YOUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::gyro_data_y_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::GYRO_YOUT_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::gyro_data_z_h(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::GYRO_ZOUT_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::gyro_data_z_l(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::GYRO_ZOUT_L;
N//  }
N  
N  // Registers 73 to 96 – External Sensor Data
N  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_0(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_00;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_1(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_01;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_2(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_02;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_3(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_03;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_4(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_04;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_5(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_05;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_6(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_06;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_7(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_07;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_8(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_08;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_9(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_09;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_10(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_10;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_11(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_11;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_12(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_12;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_13(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_13;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_14(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_14;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_15(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_15;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_16(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_16;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_17(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_17;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_18(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_18;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_19(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_19;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_20(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_20;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_21(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_21;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_22(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_22;
N//  }
N//
N//  uint8_t TAccGyroMagDriver_LL::ext_sens_data_23(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::EXT_SENS_DATA_23;
N//  }
N  
N  // Register 99 – I2C Slave 0 Data Out
N  
N//  uint8_t TAccGyroMagDriver_LL::data_out_slv0_wr(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV0_DO;
N//  }
N//  
N//  // Register 100 – I2C Slave 1 Data Out
N//  
N//  uint8_t TAccGyroMagDriver_LL::data_out_slv1_wr(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV1_DO;
N//  }
N//  
N//  // Register 101 – I2C Slave 2 Data Out
N//  
N//  uint8_t TAccGyroMagDriver_LL::data_out_slv2_wr(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV2_DO;
N//  }
N//  
N//  // Register 102 – I2C Slave 3 Data Out
N//  
N//  uint8_t TAccGyroMagDriver_LL::data_out_slv3_wr(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::I2C_SLV3_DO;
N//  }
N  
N  // Register 103 – I2C Master Delay Control
N  
N  uint8_t TAccGyroMagDriver_LL::delay_shadow_ext_sens_ctrl(uint8_t *const Byte, VEnDis DELAY_ES_SHADOW)
N  {
N    TDelayShadowExtSense Reg;
N    operate(Byte, DELAY_ES_SHADOW, Reg);
N    return reg_gyro_acc::I2C_MST_DELAY_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv4_dly_access_ctrl(uint8_t *const Byte, VEnDis I2C_SLV4_DLY_EN)
N  {
N    TSlv4DlyAccessCtrl Reg;
N    operate(Byte, I2C_SLV4_DLY_EN, Reg);
N    return reg_gyro_acc::I2C_MST_DELAY_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv3_dly_access_ctrl(uint8_t *const Byte, VEnDis I2C_SLV3_DLY_EN)
N  {
N    TSlv3DlyAccessCtrl Reg;
N    operate(Byte, I2C_SLV3_DLY_EN, Reg);
N    return reg_gyro_acc::I2C_MST_DELAY_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv2_dly_access_ctrl(uint8_t *const Byte, VEnDis I2C_SLV2_DLY_EN)
N  {
N    TSlv2DlyAccessCtrl Reg;
N    operate(Byte, I2C_SLV2_DLY_EN, Reg);
N    return reg_gyro_acc::I2C_MST_DELAY_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv1_dly_access_ctrl(uint8_t *const Byte, VEnDis I2C_SLV1_DLY_EN)
N  {
N    TSlv1DlyAccessCtrl Reg;
N    operate(Byte, I2C_SLV1_DLY_EN, Reg);
N    return reg_gyro_acc::I2C_MST_DELAY_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::slv0_dly_access_ctrl(uint8_t *const Byte, VEnDis I2C_SLV0_DLY_EN)
N  {
N    TSlv0DlyAccessCtrl Reg;
N    operate(Byte, I2C_SLV0_DLY_EN, Reg);
N    return reg_gyro_acc::I2C_MST_DELAY_CTRL;
N  }
N  
N  // Register 104 – Signal Path Reset
N  
N  uint8_t TAccGyroMagDriver_LL::reset_gyro_signal_path(uint8_t *const Byte, VEnDis GYRO_RST)
N  {
N    TResetGyroSignalPath Reg;
N    operate(Byte, GYRO_RST, Reg);
N    return reg_gyro_acc::SIGNAL_PATH_RESET;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::reset_accel_signal_path(uint8_t *const Byte, VEnDis ACCEL_RST)
N  {
N    TResetAccelSignalPath Reg;
N    operate(Byte, ACCEL_RST, Reg);
N    return reg_gyro_acc::SIGNAL_PATH_RESET;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::reset_temp_signal_path(uint8_t *const Byte, VEnDis TEMP_RST)
N  {
N    TResetTempSignalPath Reg;
N    operate(Byte, TEMP_RST, Reg);
N    return reg_gyro_acc::SIGNAL_PATH_RESET;
N  }
N  
N  // Register 105 – Accelerometer Interrupt Control
N  
N  uint8_t TAccGyroMagDriver_LL::accel_wake_on_motion_ctrl(uint8_t *const Byte, VEnDis ACCEL_INTEL_EN)
N  {
N    TAccelWakeOnMotionCtrl Reg;
N    operate(Byte, ACCEL_INTEL_EN, Reg);
N    return reg_gyro_acc::MOT_DETECT_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::accel_compare_samples_ctrl(uint8_t *const Byte, VEnDis ACCEL_INTEL_MODE)
N  {
N    TAccelCompareSamplesCtrl Reg;
N    operate(Byte, ACCEL_INTEL_MODE, Reg);
N    return reg_gyro_acc::MOT_DETECT_CTRL;
N  }
N  
N  // Register 106 – User Control
N  
N  uint8_t TAccGyroMagDriver_LL::fifo_mode_ctrl(uint8_t *const Byte, VEnDis FIFO_EN)
N  {
N    TFifoModeCtrl Reg;
N    operate(Byte, FIFO_EN, Reg);
N    return reg_gyro_acc::USER_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::i2c_master_if_module_ctrl(uint8_t *const Byte, VI2CMasterCtrl I2C_MST_EN)
N  {
N    TI2CMasterIFModuleCtrl Reg;
N    operate(Byte, I2C_MST_EN, Reg);
N    return reg_gyro_acc::USER_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::interface_mode_ctrl(uint8_t *const Byte, VEnDis I2C_IF_DIS)
N  {
N    TInterfaceModeCtrl Reg;
N    operate(Byte, I2C_IF_DIS, Reg);
N    return reg_gyro_acc::USER_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::reset_fifo_module(uint8_t *const Byte, VEnDis FIFO_RST)
N  {
N    TResetFifoModule Reg;
N    operate(Byte, FIFO_RST, Reg);
N    return reg_gyro_acc::USER_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::reset_i2c_master_module(uint8_t *const Byte, VEnDis I2C_MST_RST)
N  {
N    TResetI2CMasterModule Reg;
N    operate(Byte, I2C_MST_RST, Reg);
N    return reg_gyro_acc::USER_CTRL;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::reset_all_signal_path(uint8_t *const Byte, VEnDis SIG_COND_RST)
N  {
N    TResetAllSignalPath Reg;
N    operate(Byte, SIG_COND_RST, Reg);
N    return reg_gyro_acc::USER_CTRL;
N  }
N  
N  // Register 107 – Power Management 1  
N  
N  uint8_t TAccGyroMagDriver_LL::reset_and_restore_internal_regs(uint8_t *const Byte, VSetReset H_RESET)
N  {
N    TResetAndRestoreInternalRegs Reg;
N    operate(Byte, H_RESET, Reg);
N    return reg_gyro_acc::PWR_MGMT_1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::sleep_ctrl(uint8_t *const Byte, VSetReset SLEEP)
N  {
N    TSleepCtrl Reg;
N    operate(Byte, SLEEP, Reg);
N    return reg_gyro_acc::PWR_MGMT_1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::cycle_ctrl(uint8_t *const Byte, VSetReset CYCLE)
N  {
N    TCycleCtrl Reg;
N    operate(Byte, CYCLE, Reg);
N    return reg_gyro_acc::PWR_MGMT_1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::gyro_standby_ctrl(uint8_t *const Byte, VSetReset GYRO_STANDBY)
N  {
N    TGyroStandbyCtrl Reg;
N    operate(Byte, GYRO_STANDBY, Reg);
N    return reg_gyro_acc::PWR_MGMT_1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::voltage_generator_ctrl(uint8_t *const Byte, VSetReset PD_PTAT)
N  {
N    TVoltageGeneratorCtrl Reg;
N    operate(Byte, PD_PTAT, Reg);
N    return reg_gyro_acc::PWR_MGMT_1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::clock_src_choise(uint8_t *const Byte, VClockSrcChoise CLKSEL)
N  {
N    TClockSrcChoise Reg;
N    operate(Byte, CLKSEL, Reg);
N    return reg_gyro_acc::PWR_MGMT_1;
N  }
N  
N  // Register 108 – Power Management 2
N  
N  uint8_t TAccGyroMagDriver_LL::accel_x_ctrl(uint8_t *const Byte, VEnDis DISABLE_XA)
N  {
N    TAccelXCtrl Reg;
N    operate(Byte, DISABLE_XA, Reg);
N    return reg_gyro_acc::PWR_MGMT_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::accel_y_ctrl(uint8_t *const Byte, VEnDis DISABLE_YA)
N  {
N    TAccelYCtrl Reg;
N    operate(Byte, DISABLE_YA, Reg);
N    return reg_gyro_acc::PWR_MGMT_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::accel_z_ctrl(uint8_t *const Byte, VEnDis DISABLE_ZA)
N  {
N    TAccelZCtrl Reg;
N    operate(Byte, DISABLE_ZA, Reg);
N    return reg_gyro_acc::PWR_MGMT_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::gyro_x_ctrl(uint8_t *const Byte, VEnDis DISABLE_XG)
N  {
N    TGyroXCtrl Reg;
N    operate(Byte, DISABLE_XG, Reg);
N    return reg_gyro_acc::PWR_MGMT_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::gyro_y_ctrl(uint8_t *const Byte, VEnDis DISABLE_YG)
N  {
N    TGyroYCtrl Reg;
N    operate(Byte, DISABLE_YG, Reg);
N    return reg_gyro_acc::PWR_MGMT_2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::gyro_z_ctrl(uint8_t *const Byte, VEnDis DISABLE_ZG)
N  {
N    TGyroZCtrl Reg;
N    operate(Byte, DISABLE_ZG, Reg);
N    return reg_gyro_acc::PWR_MGMT_2;
N  }
N  
N  // Register 114 and 115 – FIFO Count Registers
N  
N  uint8_t TAccGyroMagDriver_LL::fifo_high_bits_count(uint8_t *const Byte, uint8_t FIFO_CNT)
N  {
N    TFifoHighBits Reg;
N    operate(Byte, FIFO_CNT, Reg);
N    return reg_gyro_acc::FIFO_COUNTH;
N  }
N  
N//  uint8_t TAccGyroMagDriver_LL::fifo_low_bits_count(uint8_t *const Byte, uint8_t FIFO_CNT)
N//  {
N//     Reg;
N//    operate(Byte, FIFO_CNT, Reg);
N//    return reg_gyro_acc::FIFO_COUNTL;
N//  }
N  
N  // Register 116 – FIFO Read Write
N  
N//  uint8_t TAccGyroMagDriver_LL::r_w_fifo_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::FIFO_R_W;
N//  }
N  
N  // Register 117 – Who Am I
N  
N//  uint8_t TAccGyroMagDriver_LL::get_who_am_i(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::WHO_AM_I;
N//  } // 0x71
N  
N  // Registers 119, 120, 122, 123, 125, 126 Accelerometer Offset Registers
N  
N//  uint8_t TAccGyroMagDriver_LL::accel_upper_x_offset_cancel(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::XA_OFFSET_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_lower_x_offset_cancel(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::XA_OFFSET_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_upper_y_offset_cancel(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::YA_OFFSET_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_lower_y_offset_cancel(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::YA_OFFSET_L;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_upper_z_offset_cancel(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ZA_OFFSET_H;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::accel_lower_z_offset_cancel(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_gyro_acc::ZA_OFFSET_L;
N//  }
N  
N  // REGISTER MAP FOR MAGNETOMETER
N  
N  // WIA: Device ID
N  
N//  uint8_t TAccGyroMagDriver_LL::mag_device_id(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::WIA;
N//  } // 0x48
N//  
N//  // INFO: Information
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_information(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::INFO;
N//  }
N  
N  // ST1: Status 1
N  
N  uint8_t TAccGyroMagDriver_LL::mag_data_ready(const uint8_t Byte, VStatusFlag *DOR)
N  {
N    TDataReady Reg;
N	 read(Byte, DOR, Reg);
N    return reg_mag::ST1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::mag_data_overrun(const uint8_t Byte, VStatusFlag *DRDY)
N  {
N    TDataOverrun Reg;
N    read(Byte, DRDY, Reg);
N    return reg_mag::ST1;
N  }
N  
N// HXL to HZH: Measurement Data
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_lower_x_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::HXL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_higher_x_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::HXH;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_lower_y_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::HYL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_higher_y_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::HYH;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_lower_z_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::HZL;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_higher_z_data(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::HZH;
N//  }
N  
N  // ST2: Status 2
N  
N  uint8_t TAccGyroMagDriver_LL::mag_overflow(const uint8_t Byte, VStatusFlag *HOFL)
N  {
N	 TMagSensorOvrf Reg;
N	 read(Byte, HOFL, Reg);
N    return reg_mag::ST2;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::mag_mirror_data_bit(const uint8_t Byte, VStatusFlag *BITM)
N  {
N    TOutBitSetting Reg;
N	 read(Byte, BITM, Reg);
N    return reg_mag::ST2;
N  }
N  
N  // CNTL1: Control 1
N  
N  uint8_t TAccGyroMagDriver_LL::mag_operation_mode_set(uint8_t *const Byte, VMagOperationModeSet MODE)
N  {
N    TMagMode Reg;
N    operate(Byte, MODE, Reg);
N    return reg_mag::CNTL1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::mag_operation_mode_read(const uint8_t Byte, VMagOperationModeSet *MODE)
N  {
N    TMagMode Reg;
N    read(Byte, MODE, Reg);
N    return reg_mag::CNTL1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::mag_output_bit_set(uint8_t *const Byte, VMagOutputBitSet BIT)
N  {
N    TMagBit Reg;
N    operate(Byte, BIT, Reg);
N    return reg_mag::CNTL1;
N  }
N  
N  uint8_t TAccGyroMagDriver_LL::mag_output_bit_read(const uint8_t Byte, VMagOutputBitSet *BIT)
N  {
N    TMagBit Reg;
N    read(Byte, BIT, Reg);
N    return reg_mag::CNTL1;
N  }
N  
N  // CNTL2: Control 2
N  
N  uint8_t TAccGyroMagDriver_LL::mag_soft_reset_ctrl(uint8_t *const Byte, VMagSoftResetCtrl SRST)
N  {
N    TSoftReset Reg;
N    operate(Byte, SRST, Reg);
N    return reg_mag::CNTL2;
N  }
N  
N  // ASTC: Self-Test Control
N  
N  uint8_t TAccGyroMagDriver_LL::mag_self_test_ctrl(uint8_t *const Byte, VMagSelfTestCtrl SELF)
N  {
N    TSelfTestControl Reg;
N    operate(Byte, SELF, Reg);
N    return reg_mag::ASTC;
N  }
N  
N  // I2CDIS: I2C Disable
N  
N  uint8_t TAccGyroMagDriver_LL::mag_i2c_disable(uint8_t *const Byte)
N  {	 
N    *Byte = 0x1B;
N    return reg_mag::I2CDIS;
N  }
N  
N  // ASAX, ASAY, ASAZ: Sensitivity Adjustment values
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_sens_adj_x(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::ASAX;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_sens_adj_y(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::ASAY;
N//  }
N//  
N//  uint8_t TAccGyroMagDriver_LL::mag_sens_adj_z(uint8_t *const Byte, )
N//  {
N//    operate(Byte, );
N//    return reg_mag::ASAZ;
N//  }
N}
