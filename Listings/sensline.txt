; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\sensline.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sensline.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\sensline.crf Source\Line\src\sensline.c]
                          THUMB

                          AREA ||i.AddTime||, CODE, READONLY, ALIGN=1

                  AddTime PROC
;;;163    // Прибавляет константу к предыдущему порогу срабатывания
;;;164    void AddTime(uint16_t adconst) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;165      TIM3->CCR1+=adconst;
000004  f04f4080          MOV      r0,#0x40000000
000008  6b40              LDR      r0,[r0,#0x34]
00000a  4420              ADD      r0,r0,r4
00000c  f04f4180          MOV      r1,#0x40000000
000010  6348              STR      r0,[r1,#0x34]
;;;166      TIM_ClearFlag(TIM3,TIM_IT_CC1);  
000012  2102              MOVS     r1,#2
000014  0748              LSLS     r0,r1,#29
000016  f7fffffe          BL       TIM_ClearFlag
;;;167      TIM_ITConfig(TIM3,TIM_IT_CC1,ENABLE);  
00001a  2201              MOVS     r2,#1
00001c  2102              MOVS     r1,#2
00001e  0748              LSLS     r0,r1,#29
000020  f7fffffe          BL       TIM_ITConfig
;;;168    }
000024  bd10              POP      {r4,pc}
;;;169    
                          ENDP


                          AREA ||i.BlockST||, CODE, READONLY, ALIGN=2

                  BlockST PROC
;;;875    // Блокирует передачу байтов состояния и разрешает изменение
;;;876    void BlockST(void) {
000000  bf00              NOP      
                  |L2.2|
;;;877      while (SensConfig&PSMODE);
000002  4807              LDR      r0,|L2.32|
000004  7800              LDRB     r0,[r0,#0]  ; SensConfig
000006  f0000002          AND      r0,r0,#2
00000a  2800              CMP      r0,#0
00000c  d1f9              BNE      |L2.2|
;;;878      IN_CRITICAL();
00000e  b672              CPSID    i
;;;879      SensConfig|=NOPS;
000010  4803              LDR      r0,|L2.32|
000012  7800              LDRB     r0,[r0,#0]  ; SensConfig
000014  f0400004          ORR      r0,r0,#4
000018  4901              LDR      r1,|L2.32|
00001a  7008              STRB     r0,[r1,#0]
;;;880      OUT_CRITICAL();
00001c  b662              CPSIE    i
;;;881    }
00001e  4770              BX       lr
;;;882    
                          ENDP

                  |L2.32|
                          DCD      SensConfig

                          AREA ||i.CheckBSTr||, CODE, READONLY, ALIGN=2

                  CheckBSTr PROC
;;;930    /////////////////////////////////////////////////////////////////////////// Состояние передачи байта состояний
;;;931    uint8_t CheckBSTr(void) {
000000  4804              LDR      r0,|L3.20|
;;;932      if (SensConfig&PSMODE) return 1; else return 0;
000002  7800              LDRB     r0,[r0,#0]  ; SensConfig
000004  f0000002          AND      r0,r0,#2
000008  b108              CBZ      r0,|L3.14|
00000a  2001              MOVS     r0,#1
                  |L3.12|
;;;933    }
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0                 ;932
000010  e7fc              B        |L3.12|
;;;934    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      SensConfig

                          AREA ||i.CheckZZZ||, CODE, READONLY, ALIGN=2

                  CheckZZZ PROC
;;;520    
;;;521    void CheckZZZ(void) {
000000  b510              PUSH     {r4,lr}
;;;522      if (ZZZ&4) {
000002  480c              LDR      r0,|L4.52|
000004  7800              LDRB     r0,[r0,#0]  ; ZZZ
000006  f0000004          AND      r0,r0,#4
00000a  b140              CBZ      r0,|L4.30|
;;;523    // Прошло только 1500 мкс нуля
;;;524        EnableINT();  
00000c  f7fffffe          BL       EnableINT
;;;525        SensState=SS_P7;
000010  2027              MOVS     r0,#0x27
000012  4909              LDR      r1,|L4.56|
000014  7008              STRB     r0,[r1,#0]
;;;526        AddTime(TIME1MS);
000016  2028              MOVS     r0,#0x28
000018  f7fffffe          BL       AddTime
00001c  e008              B        |L4.48|
                  |L4.30|
;;;527      } else {
;;;528    // Уже прошло 2500 мкс нуля
;;;529        SetOut(1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       SetOut
;;;530        AddTime(TIME1_5MS);
000024  203c              MOVS     r0,#0x3c
000026  f7fffffe          BL       AddTime
;;;531        SensState=SS_P8;        
00002a  2028              MOVS     r0,#0x28
00002c  4902              LDR      r1,|L4.56|
00002e  7008              STRB     r0,[r1,#0]
                  |L4.48|
;;;532      }
;;;533    }
000030  bd10              POP      {r4,pc}
;;;534    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      ZZZ
                  |L4.56|
                          DCD      SensState

                          AREA ||i.ConfigSENS||, CODE, READONLY, ALIGN=2

                  ConfigSENS PROC
;;;188    
;;;189    void ConfigSENS(uint8_t cfgs) {
000000  b510              PUSH     {r4,lr}
000002  b0a4              SUB      sp,sp,#0x90
000004  4604              MOV      r4,r0
;;;190      RCC_ClocksTypeDef RCC_Clocks;
;;;191      TIM_OCInitTypeDef TIM_OCInitStruct;
;;;192      GPIO_InitTypeDef GPIOInitStruct;
;;;193    #ifndef NO_USE_COMP
;;;194      COMP_InitTypeDef COMPInitStruct;
;;;195    #endif
;;;196      TIM_TimeBaseInitTypeDef TIMInitStruct;
;;;197      EXTI_InitTypeDef EXTI_InitStruct;  // Прерывания
;;;198    //
;;;199    
;;;200    /*  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC,ENABLE);
;;;201      GPIOInitStruct.GPIO_Mode=GPIO_Mode_OUT;
;;;202      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
;;;203      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
;;;204      GPIOInitStruct.GPIO_Speed=GPIO_Speed_Level_2;
;;;205      GPIOInitStruct.GPIO_Pin=GPIO_Pin_14;
;;;206      GPIO_Init(GPIOC,&GPIOInitStruct);
;;;207    */
;;;208    
;;;209    
;;;210      // ЭТА ФУНКЦИЯ НЕ ОБНУЛЯЕТ БИТЫ SetCFGB(cfgs);
;;;211      SensConfig=cfgs; // Это вместо неё
000006  485b              LDR      r0,|L5.372|
000008  7004              STRB     r4,[r0,#0]
;;;212    
;;;213    #if defined(USE_COMP1_051)
;;;214    // Конфигурируем ножки компараторов
;;;215      GPIOInitStruct.GPIO_Mode=GPIO_Mode_AN;
;;;216      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
;;;217      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
;;;218      GPIOInitStruct.GPIO_Speed=GPIO_Speed_Level_2;
;;;219      GPIOInitStruct.GPIO_Pin=GPIO_Pin_1|GPIO_Pin_0;
;;;220      GPIO_Init(GPIOA,&GPIOInitStruct);
;;;221    // Конфигурируем компаратор входа линии СЕНС
;;;222      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);     
;;;223      COMP_DeInit();
;;;224      COMPInitStruct.COMP_Hysteresis=COMP_Hysteresis_Low;
;;;225      COMPInitStruct.COMP_InvertingInput=COMP_InvertingInput_IO;
;;;226      COMPInitStruct.COMP_Mode=COMP_Mode_LowPower;
;;;227      COMPInitStruct.COMP_Output=COMP_Output_None;
;;;228      COMPInitStruct.COMP_OutputPol=COMP_OutputPol_Inverted;
;;;229      COMP_Init(COMP_Selection_COMP1,&COMPInitStruct);
;;;230      COMP_Cmd(COMP_Selection_COMP1,ENABLE);
;;;231    // Конфигурируем линию PA6 как выход компаратора и вход прерывания
;;;232      GPIOInitStruct.GPIO_Mode=GPIO_Mode_AF;
;;;233      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
;;;234      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
;;;235      GPIOInitStruct.GPIO_Speed=GPIO_Speed_Level_2;
;;;236      GPIOInitStruct.GPIO_Pin=GPIO_Pin_6;
;;;237      GPIO_Init(GPIOA,&GPIOInitStruct);
;;;238      GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_7);
;;;239      SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource6);        ////// ??????????????????
;;;240    #elif defined(USE_COMP1_303)
;;;241    // Конфигурируем ножки компараторов
;;;242      GPIOInitStruct.GPIO_Mode=GPIO_Mode_AN;
;;;243      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
;;;244      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
;;;245      GPIOInitStruct.GPIO_Speed=GPIO_Speed_Level_2;
;;;246      GPIOInitStruct.GPIO_Pin=GPIO_Pin_1|GPIO_Pin_0;
;;;247      GPIO_Init(GPIOA,&GPIOInitStruct);
;;;248    // Конфигурируем компаратор входа линии СЕНС
;;;249      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);     
;;;250      COMP_DeInit(COMP_Selection_COMP1);
;;;251      COMPInitStruct.COMP_Hysteresis=COMP_Hysteresis_Low;
;;;252      COMPInitStruct.COMP_InvertingInput=COMP_InvertingInput_IO1;
;;;253      COMPInitStruct.COMP_Mode=COMP_Mode_LowPower;
;;;254      COMPInitStruct.COMP_Output=COMP_Output_None;
;;;255      COMPInitStruct.COMP_OutputPol=COMP_OutputPol_Inverted;
;;;256      COMPInitStruct.COMP_BlankingSrce=COMP_BlankingSrce_None;
;;;257      COMPInitStruct.COMP_NonInvertingInput=COMP_NonInvertingInput_IO1;
;;;258      COMP_Init(COMP_Selection_COMP1,&COMPInitStruct);
;;;259      COMP_Cmd(COMP_Selection_COMP1,ENABLE);
;;;260    // Конфигурируем линию PA6 как выход компаратора и вход прерывания
;;;261      GPIOInitStruct.GPIO_Mode=GPIO_Mode_AF;
;;;262      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
;;;263      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
;;;264      GPIOInitStruct.GPIO_Speed=GPIO_Speed_Level_2;
;;;265      GPIOInitStruct.GPIO_Pin=GPIO_Pin_6;
;;;266      GPIO_Init(INPORT,&GPIOInitStruct);
;;;267      GPIO_PinAFConfig(INPORT,EXTI_PINSOURCE,GPIO_AF_8);  // STM32F303!!!
;;;268    #elif defined(NO_USE_COMP)
;;;269      // Тут конфигурируем только прерывания
;;;270      GPIOInitStruct.GPIO_Mode=GPIO_Mode_IN;
00000a  2000              MOVS     r0,#0
00000c  f88d001c          STRB     r0,[sp,#0x1c]
;;;271      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
000010  f88d001e          STRB     r0,[sp,#0x1e]
;;;272      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
000014  f88d001f          STRB     r0,[sp,#0x1f]
;;;273      GPIOInitStruct.GPIO_Speed=PINSPEED;
000018  2002              MOVS     r0,#2
00001a  f88d001d          STRB     r0,[sp,#0x1d]
;;;274      GPIOInitStruct.GPIO_Pin=GPIO_Pin_6;
00001e  2040              MOVS     r0,#0x40
000020  9006              STR      r0,[sp,#0x18]
;;;275      GPIO_Init(INPORT,&GPIOInitStruct);
000022  a906              ADD      r1,sp,#0x18
000024  f04f4090          MOV      r0,#0x48000000
000028  f7fffffe          BL       GPIO_Init
;;;276    #else
;;;277      #error "Отконфигурировать вход - ножка или компаратор"
;;;278    #endif
;;;279    
;;;280    // Конфигурируем прерывания от входа
;;;281      SYSCFG_EXTILineConfig(EXTI_SOURCE,EXTI_PINSOURCE);  
00002c  2106              MOVS     r1,#6
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;282    // Прерывания от входа
;;;283      EXTI_InitStruct.EXTI_Line=EXTI_LINE;
000034  2040              MOVS     r0,#0x40
000036  9001              STR      r0,[sp,#4]
;;;284      EXTI_InitStruct.EXTI_Mode=EXTI_Mode_Interrupt;
000038  2000              MOVS     r0,#0
00003a  f88d0008          STRB     r0,[sp,#8]
;;;285      EXTI_InitStruct.EXTI_Trigger=EXTI_Trigger_Rising_Falling;
00003e  2010              MOVS     r0,#0x10
000040  f88d0009          STRB     r0,[sp,#9]
;;;286      EXTI_InitStruct.EXTI_LineCmd=ENABLE;
000044  2001              MOVS     r0,#1
000046  f88d000a          STRB     r0,[sp,#0xa]
;;;287      EXTI_Init(&EXTI_InitStruct);
00004a  a801              ADD      r0,sp,#4
00004c  f7fffffe          BL       EXTI_Init
;;;288    
;;;289    // Конфигурируем таймер 3
;;;290      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;291      TIM_DeInit(TIM3);
000058  f04f4080          MOV      r0,#0x40000000
00005c  f7fffffe          BL       TIM_DeInit
;;;292      TIM_InternalClockConfig(TIM3);
000060  f04f4080          MOV      r0,#0x40000000
000064  f7fffffe          BL       TIM_InternalClockConfig
;;;293    // Нужно учитывать частоту ядра. Требуется частота прибавления 40КГц
;;;294    
;;;295    	RCC_GetClocksFreq(&RCC_Clocks);
000068  a80d              ADD      r0,sp,#0x34
00006a  f7fffffe          BL       RCC_GetClocksFreq
;;;296      TIM_TimeBaseStructInit(&TIMInitStruct);
00006e  a803              ADD      r0,sp,#0xc
000070  f7fffffe          BL       TIM_TimeBaseStructInit
;;;297    #ifndef PMP201ARM
;;;298      TIMInitStruct.TIM_Prescaler=((uint32_t)RCC_Clocks.HCLK_Frequency)/(uint32_t)40000U - 1U; //CK_INT = HCLK = APB1 * 2 = 72MHz (для DKS) - не универсально!!!
000074  f6494140          MOV      r1,#0x9c40
000078  980e              LDR      r0,[sp,#0x38]
00007a  fbb0f0f1          UDIV     r0,r0,r1
00007e  1e40              SUBS     r0,r0,#1
000080  b280              UXTH     r0,r0
000082  f8ad000c          STRH     r0,[sp,#0xc]
;;;299    #else
;;;300      TIMInitStruct.TIM_Prescaler=((uint32_t)RCC_Clocks.PCLK1_Frequency)/(uint32_t)40000U- 1U;
;;;301    #endif
;;;302    
;;;303      TIMInitStruct.TIM_CounterMode=TIM_CounterMode_Up;
000086  2000              MOVS     r0,#0
000088  f8ad000e          STRH     r0,[sp,#0xe]
;;;304      TIMInitStruct.TIM_Period=0xFFFF;
00008c  f64f70ff          MOV      r0,#0xffff
000090  9004              STR      r0,[sp,#0x10]
;;;305      TIMInitStruct.TIM_ClockDivision=TIM_CKD_DIV1;
000092  2000              MOVS     r0,#0
000094  f8ad0014          STRH     r0,[sp,#0x14]
;;;306      TIM_TimeBaseInit(TIM3,&TIMInitStruct);
000098  a903              ADD      r1,sp,#0xc
00009a  f04f4080          MOV      r0,#0x40000000
00009e  f7fffffe          BL       TIM_TimeBaseInit
;;;307    // Конфигурируем второй канал сравнения - частота 1КГц
;;;308      TIM_OCInitStruct.TIM_OCMode=TIM_OCMode_Timing;
0000a2  2000              MOVS     r0,#0
0000a4  9008              STR      r0,[sp,#0x20]
;;;309      TIM_OCInitStruct.TIM_OutputState=TIM_OutputState_Disable;
0000a6  f8ad0024          STRH     r0,[sp,#0x24]
;;;310      TIM_OCInitStruct.TIM_Pulse=TIM_GetCounter(TIM3)+TIME1MS;
0000aa  f04f4080          MOV      r0,#0x40000000
0000ae  f7fffffe          BL       TIM_GetCounter
0000b2  3028              ADDS     r0,r0,#0x28
0000b4  900a              STR      r0,[sp,#0x28]
;;;311      TIM_OCInitStruct.TIM_OCPolarity=TIM_OCPolarity_High;
0000b6  2000              MOVS     r0,#0
0000b8  f8ad002c          STRH     r0,[sp,#0x2c]
;;;312      TIM_OC2Init(TIM3, &TIM_OCInitStruct);
0000bc  a908              ADD      r1,sp,#0x20
0000be  f04f4080          MOV      r0,#0x40000000
0000c2  f7fffffe          BL       TIM_OC2Init
;;;313    // Конфигурируем третий канал сравнения - против помех
;;;314      TIM_OCInitStruct.TIM_OCMode=TIM_OCMode_Timing;
0000c6  2000              MOVS     r0,#0
0000c8  9008              STR      r0,[sp,#0x20]
;;;315      TIM_OCInitStruct.TIM_OutputState=TIM_OutputState_Disable;
0000ca  f8ad0024          STRH     r0,[sp,#0x24]
;;;316      TIM_OCInitStruct.TIM_Pulse=TIM_GetCounter(TIM3);
0000ce  f04f4080          MOV      r0,#0x40000000
0000d2  f7fffffe          BL       TIM_GetCounter
0000d6  900a              STR      r0,[sp,#0x28]
;;;317      TIM_OCInitStruct.TIM_OCPolarity=TIM_OCPolarity_High;
0000d8  2000              MOVS     r0,#0
0000da  f8ad002c          STRH     r0,[sp,#0x2c]
;;;318      TIM_OC3Init(TIM3, &TIM_OCInitStruct);
0000de  a908              ADD      r1,sp,#0x20
0000e0  f04f4080          MOV      r0,#0x40000000
0000e4  f7fffffe          BL       TIM_OC3Init
;;;319    // Конфигурируем первый канал сравнения
;;;320      TIM_OCInitStruct.TIM_OCMode=TIM_OCMode_Timing;
0000e8  2000              MOVS     r0,#0
0000ea  9008              STR      r0,[sp,#0x20]
;;;321      TIM_OCInitStruct.TIM_OutputState=TIM_OutputState_Disable;
0000ec  f8ad0024          STRH     r0,[sp,#0x24]
;;;322      TIM_OCInitStruct.TIM_Pulse=TIM_GetCounter(TIM3)+TIME20MS;
0000f0  f04f4080          MOV      r0,#0x40000000
0000f4  f7fffffe          BL       TIM_GetCounter
0000f8  f5007048          ADD      r0,r0,#0x320
0000fc  900a              STR      r0,[sp,#0x28]
;;;323      TIM_OCInitStruct.TIM_OCPolarity=TIM_OCPolarity_High;
0000fe  2000              MOVS     r0,#0
000100  f8ad002c          STRH     r0,[sp,#0x2c]
;;;324      TIM_OC1Init(TIM3, &TIM_OCInitStruct);
000104  a908              ADD      r1,sp,#0x20
000106  f04f4080          MOV      r0,#0x40000000
00010a  f7fffffe          BL       TIM_OC1Init
;;;325    //
;;;326    // Конфигурируем прерывания
;;;327    // Таймер линии и системного времени
;;;328      TIM_ITConfig(TIM3,TIM_IT_CC1,ENABLE);
00010e  2201              MOVS     r2,#1
000110  2102              MOVS     r1,#2
000112  0748              LSLS     r0,r1,#29
000114  f7fffffe          BL       TIM_ITConfig
;;;329      TIM_ITConfig(TIM3,TIM_IT_CC2,ENABLE);
000118  2201              MOVS     r2,#1
00011a  2104              MOVS     r1,#4
00011c  0708              LSLS     r0,r1,#28
00011e  f7fffffe          BL       TIM_ITConfig
;;;330      TIM_ITConfig(TIM3,TIM_IT_CC3,DISABLE);
000122  2200              MOVS     r2,#0
000124  2108              MOVS     r1,#8
000126  06c8              LSLS     r0,r1,#27
000128  f7fffffe          BL       TIM_ITConfig
;;;331      NVIC_EnableIRQ(TIM3_IRQn);
00012c  201c              MOVS     r0,#0x1c
00012e  f7fffffe          BL       NVIC_EnableIRQ
;;;332    
;;;333    // Конфигурируем выходную ножку
;;;334      GPIOInitStruct.GPIO_Mode=GPIO_Mode_OUT;
000132  2001              MOVS     r0,#1
000134  f88d001c          STRB     r0,[sp,#0x1c]
;;;335      GPIOInitStruct.GPIO_OType=GPIO_OType_PP;
000138  2000              MOVS     r0,#0
00013a  f88d001e          STRB     r0,[sp,#0x1e]
;;;336      GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
00013e  f88d001f          STRB     r0,[sp,#0x1f]
;;;337      GPIOInitStruct.GPIO_Speed=PINSPEED;
000142  2002              MOVS     r0,#2
000144  f88d001d          STRB     r0,[sp,#0x1d]
;;;338      GPIOInitStruct.GPIO_Pin=OUTPIN;
000148  2020              MOVS     r0,#0x20
00014a  9006              STR      r0,[sp,#0x18]
;;;339      GPIO_Init(OUTPORT,&GPIOInitStruct);
00014c  a906              ADD      r1,sp,#0x18
00014e  f04f4090          MOV      r0,#0x48000000
000152  f7fffffe          BL       GPIO_Init
;;;340      GPIO_WriteBit(OUTPORT,OUTPIN,Bit_RESET);
000156  2200              MOVS     r2,#0
000158  2120              MOVS     r1,#0x20
00015a  f04f4090          MOV      r0,#0x48000000
00015e  f7fffffe          BL       GPIO_WriteBit
;;;341    
;;;342    // Запускаем автомат в работу  
;;;343      TIM_Cmd(TIM3,ENABLE);
000162  2101              MOVS     r1,#1
000164  0788              LSLS     r0,r1,#30
000166  f7fffffe          BL       TIM_Cmd
;;;344      NVIC_EnableIRQ(NVIC_IRQn);
00016a  2017              MOVS     r0,#0x17
00016c  f7fffffe          BL       NVIC_EnableIRQ
;;;345    }
000170  b024              ADD      sp,sp,#0x90
000172  bd10              POP      {r4,pc}
;;;346    
                          ENDP

                  |L5.372|
                          DCD      SensConfig

                          AREA ||i.DisableINT||, CODE, READONLY, ALIGN=1

                  DisableINT PROC
;;;139    // Прерывания отключены
;;;140    void DisableINT(void) { 
000000  b510              PUSH     {r4,lr}
;;;141      NVIC_DisableIRQ(NVIC_IRQn);
000002  2017              MOVS     r0,#0x17
000004  f7fffffe          BL       NVIC_DisableIRQ
;;;142    }     
000008  bd10              POP      {r4,pc}
;;;143    
                          ENDP


                          AREA ||i.DisableTIM||, CODE, READONLY, ALIGN=1

                  DisableTIM PROC
;;;152    // Запрет прерываний от таймера
;;;153    void DisableTIM(void) {
000000  b510              PUSH     {r4,lr}
;;;154      TIM_ITConfig(TIM3,TIM_IT_CC1,DISABLE);  
000002  2200              MOVS     r2,#0
000004  2102              MOVS     r1,#2
000006  0748              LSLS     r0,r1,#29
000008  f7fffffe          BL       TIM_ITConfig
;;;155    }
00000c  bd10              POP      {r4,pc}
;;;156    
                          ENDP


                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;770    // Обработчик прерывания от фронта
;;;771    void INTERRUPT_HANDLER() {
000000  b510              PUSH     {r4,lr}
;;;772      if (EXTI_GetFlagStatus(EXTI_LINE)) {
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       EXTI_GetFlagStatus
000008  2800              CMP      r0,#0
00000a  d052              BEQ      |L8.178|
;;;773        EXTI_ClearFlag(EXTI_LINE);
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       EXTI_ClearFlag
;;;774        DisableINT();    
000012  f7fffffe          BL       DisableINT
;;;775        switch (SensState) {
000016  4827              LDR      r0,|L8.180|
000018  7800              LDRB     r0,[r0,#0]  ; SensState
00001a  b318              CBZ      r0,|L8.100|
00001c  2824              CMP      r0,#0x24
00001e  d040              BEQ      |L8.162|
000020  2827              CMP      r0,#0x27
000022  d035              BEQ      |L8.144|
000024  2840              CMP      r0,#0x40
000026  d143              BNE      |L8.176|
;;;776          case (SS_SYNC):
;;;777            TIM3->CCR1=TIM3->CNT;
000028  0600              LSLS     r0,r0,#24
00002a  6a40              LDR      r0,[r0,#0x24]
00002c  f04f4180          MOV      r1,#0x40000000
000030  6348              STR      r0,[r1,#0x34]
;;;778            if (Ni<31) {
000032  4821              LDR      r0,|L8.184|
000034  7800              LDRB     r0,[r0,#0]  ; Ni
000036  281f              CMP      r0,#0x1f
000038  da05              BGE      |L8.70|
;;;779              Ni++; 
00003a  481f              LDR      r0,|L8.184|
00003c  7800              LDRB     r0,[r0,#0]  ; Ni
00003e  1c40              ADDS     r0,r0,#1
000040  491d              LDR      r1,|L8.184|
000042  7008              STRB     r0,[r1,#0]
000044  e00b              B        |L8.94|
                  |L8.70|
;;;780            } else if (Ni==31) {
000046  481c              LDR      r0,|L8.184|
000048  7800              LDRB     r0,[r0,#0]  ; Ni
00004a  281f              CMP      r0,#0x1f
00004c  d107              BNE      |L8.94|
;;;781              Ni++;
00004e  481a              LDR      r0,|L8.184|
000050  7800              LDRB     r0,[r0,#0]  ; Ni
000052  1c40              ADDS     r0,r0,#1
000054  4918              LDR      r1,|L8.184|
000056  7008              STRB     r0,[r1,#0]
;;;782              NCK=1;
000058  2001              MOVS     r0,#1
00005a  4918              LDR      r1,|L8.188|
00005c  7008              STRB     r0,[r1,#0]
                  |L8.94|
;;;783            } 
;;;784            SelectND();
00005e  f7fffffe          BL       SelectND
;;;785            break;
000062  e025              B        |L8.176|
                  |L8.100|
;;;786    // Пришел фронт сигнала
;;;787          case (SS_WAIT):
;;;788            TIM3->CCR3=TIM3->CNT+TIME0_5MS;
000064  f04f4080          MOV      r0,#0x40000000
000068  6a40              LDR      r0,[r0,#0x24]
00006a  3014              ADDS     r0,r0,#0x14
00006c  f04f4180          MOV      r1,#0x40000000
000070  63c8              STR      r0,[r1,#0x3c]
;;;789            TIM_ClearFlag(TIM3,TIM_IT_CC3);
000072  2108              MOVS     r1,#8
000074  06c8              LSLS     r0,r1,#27
000076  f7fffffe          BL       TIM_ClearFlag
;;;790            TIM_ITConfig(TIM3,TIM_IT_CC1,DISABLE);
00007a  2200              MOVS     r2,#0
00007c  2102              MOVS     r1,#2
00007e  0748              LSLS     r0,r1,#29
000080  f7fffffe          BL       TIM_ITConfig
;;;791            TIM_ITConfig(TIM3,TIM_IT_CC3,ENABLE);
000084  2201              MOVS     r2,#1
000086  2108              MOVS     r1,#8
000088  06c8              LSLS     r0,r1,#27
00008a  f7fffffe          BL       TIM_ITConfig
;;;792            break;    
00008e  e00f              B        |L8.176|
                  |L8.144|
;;;793    // Ошибочный запуск - импульс более 1.5 но менее 2.5 мс
;;;794          case (SS_P7):
;;;795            TIM3->CCR1=TIM3->CNT;
000090  f04f4080          MOV      r0,#0x40000000
000094  6a40              LDR      r0,[r0,#0x24]
000096  f04f4180          MOV      r1,#0x40000000
00009a  6348              STR      r0,[r1,#0x34]
;;;796            SelectND();
00009c  f7fffffe          BL       SelectND
;;;797            break;
0000a0  e006              B        |L8.176|
                  |L8.162|
;;;798    // Внутрибитовая синхронизация
;;;799          case (SS_P4):
;;;800            NewTime(TIME_BITSYNC);
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       NewTime
;;;801            SensState=SS_CHZZZ;
0000a8  2030              MOVS     r0,#0x30
0000aa  4902              LDR      r1,|L8.180|
0000ac  7008              STRB     r0,[r1,#0]
;;;802            break; 
0000ae  bf00              NOP      
                  |L8.176|
0000b0  bf00              NOP                            ;785
                  |L8.178|
;;;803        }
;;;804      }
;;;805    }
0000b2  bd10              POP      {r4,pc}
;;;806    
                          ENDP

                  |L8.180|
                          DCD      SensState
                  |L8.184|
                          DCD      ||Ni||
                  |L8.188|
                          DCD      NCK

                          AREA ||i.EnableINT||, CODE, READONLY, ALIGN=1

                  EnableINT PROC
;;;133    // Прерывания по любому фронту
;;;134    void EnableINT(void) { 
000000  b510              PUSH     {r4,lr}
;;;135      EXTI_ClearFlag(EXTI_LINE);
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       EXTI_ClearFlag
;;;136      NVIC_EnableIRQ(NVIC_IRQn);
000008  2017              MOVS     r0,#0x17
00000a  f7fffffe          BL       NVIC_EnableIRQ
;;;137    }     
00000e  bd10              POP      {r4,pc}
;;;138    
                          ENDP


                          AREA ||i.EnableTIM||, CODE, READONLY, ALIGN=1

                  EnableTIM PROC
;;;157    // Разрешение прерываний от таймера
;;;158    void EnableTIM(void) {
000000  b510              PUSH     {r4,lr}
;;;159      TIM_ClearFlag(TIM3,TIM_IT_CC1);  
000002  2102              MOVS     r1,#2
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       TIM_ClearFlag
;;;160      TIM_ITConfig(TIM3,TIM_IT_CC1,ENABLE);  
00000a  2201              MOVS     r2,#1
00000c  2102              MOVS     r1,#2
00000e  0748              LSLS     r0,r1,#29
000010  f7fffffe          BL       TIM_ITConfig
;;;161    }
000014  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.GetBSBuf||, CODE, READONLY, ALIGN=2

                  GetBSBuf PROC
;;;915    // Считывает первый передаваемый пакет из буфера состояний. Возвращает длину пакета или ноль если пакета нет
;;;916    uint8_t GetBSBuf(void * bsbufpnt) {
000000  b530              PUSH     {r4,r5,lr}
000002  4605              MOV      r5,r0
;;;917      uint8_t * dbf;
;;;918      uint8_t * sbf;
;;;919      uint8_t n,num;
;;;920      if (!BSPointer) return 0;
000004  480c              LDR      r0,|L11.56|
000006  6800              LDR      r0,[r0,#0]  ; BSPointer
000008  b908              CBNZ     r0,|L11.14|
00000a  2000              MOVS     r0,#0
                  |L11.12|
;;;921    // Копируем один пакет  
;;;922      dbf=bsbufpnt;
;;;923      sbf=(uint8_t*)BSPointer;
;;;924      sbf+=2;
;;;925      num=(*sbf)+1;
;;;926      for (n=0;n<num;n++) *(dbf++)=*(sbf++);
;;;927      return num-1;
;;;928    }
00000c  bd30              POP      {r4,r5,pc}
                  |L11.14|
00000e  462a              MOV      r2,r5                 ;922
000010  4809              LDR      r0,|L11.56|
000012  6801              LDR      r1,[r0,#0]            ;923  ; BSPointer
000014  1c89              ADDS     r1,r1,#2              ;924
000016  7808              LDRB     r0,[r1,#0]            ;925
000018  1c40              ADDS     r0,r0,#1              ;925
00001a  b2c4              UXTB     r4,r0                 ;925
00001c  2300              MOVS     r3,#0                 ;926
00001e  e005              B        |L11.44|
                  |L11.32|
000020  f8110b01          LDRB     r0,[r1],#1            ;926
000024  f8020b01          STRB     r0,[r2],#1            ;926
000028  1c58              ADDS     r0,r3,#1              ;926
00002a  b2c3              UXTB     r3,r0                 ;926
                  |L11.44|
00002c  42a3              CMP      r3,r4                 ;926
00002e  dbf7              BLT      |L11.32|
000030  1e60              SUBS     r0,r4,#1              ;927
000032  b2c0              UXTB     r0,r0                 ;927
000034  e7ea              B        |L11.12|
;;;929    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      BSPointer

                          AREA ||i.GetInput||, CODE, READONLY, ALIGN=1

                  GetInput PROC
;;;144    // Возвращает состояние входа
;;;145    char GetInput(void) {
000000  f04f4090          MOV      r0,#0x48000000
;;;146      return (INPORT->IDR&INPIN)?1:0;
000004  6900              LDR      r0,[r0,#0x10]
000006  f3c01080          UBFX     r0,r0,#6,#1
;;;147    }
00000a  4770              BX       lr
;;;148    
                          ENDP


                          AREA ||i.GetLstTime||, CODE, READONLY, ALIGN=1

                  GetLstTime PROC
;;;177    // Получает предыдущий момент времени
;;;178    unsigned int GetLstTime(void) {
000000  f04f4080          MOV      r0,#0x40000000
;;;179      return TIM3->CNT;
000004  6a40              LDR      r0,[r0,#0x24]
;;;180    }
000006  4770              BX       lr
;;;181    
                          ENDP


                          AREA ||i.GetNC||, CODE, READONLY, ALIGN=2

                  GetNC PROC
;;;936    
;;;937    uint8_t GetNC(void) {
000000  b672              CPSID    i
;;;938      uint8_t rez;
;;;939      IN_CRITICAL();
;;;940      if (NCK&5) {
000002  4908              LDR      r1,|L14.36|
000004  7809              LDRB     r1,[r1,#0]  ; NCK
000006  f0010105          AND      r1,r1,#5
00000a  b141              CBZ      r1,|L14.30|
;;;941        NCK=(NCK<<1)&2;
00000c  4905              LDR      r1,|L14.36|
00000e  7809              LDRB     r1,[r1,#0]  ; NCK
000010  2202              MOVS     r2,#2
000012  ea020141          AND      r1,r2,r1,LSL #1
000016  4a03              LDR      r2,|L14.36|
000018  7011              STRB     r1,[r2,#0]
;;;942        rez=1;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L14.32|
                  |L14.30|
;;;943      } else rez=0;
00001e  2000              MOVS     r0,#0
                  |L14.32|
;;;944      OUT_CRITICAL();
000020  b662              CPSIE    i
;;;945      return rez;
;;;946    }
000022  4770              BX       lr
;;;947    
                          ENDP

                  |L14.36|
                          DCD      NCK

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;1636    */
;;;1637   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1638   {
;;;1639     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L15.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1640   }
000010  4770              BX       lr
;;;1641   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NewTime||, CODE, READONLY, ALIGN=1

                  NewTime PROC
;;;170    // Устанавливает новый момент времени от текущего
;;;171    void NewTime(uint16_t adconst) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;172      TIM3->CCR1=TIM3->CNT+adconst;
000004  f04f4080          MOV      r0,#0x40000000
000008  6a40              LDR      r0,[r0,#0x24]
00000a  4420              ADD      r0,r0,r4
00000c  f04f4180          MOV      r1,#0x40000000
000010  6348              STR      r0,[r1,#0x34]
;;;173      TIM_ClearFlag(TIM3,TIM_IT_CC1);  
000012  2102              MOVS     r1,#2
000014  0748              LSLS     r0,r1,#29
000016  f7fffffe          BL       TIM_ClearFlag
;;;174      TIM_ITConfig(TIM3,TIM_IT_CC1,ENABLE);  
00001a  2201              MOVS     r2,#1
00001c  2102              MOVS     r1,#2
00001e  0748              LSLS     r0,r1,#29
000020  f7fffffe          BL       TIM_ITConfig
;;;175    }
000024  bd10              POP      {r4,pc}
;;;176    
                          ENDP


                          AREA ||i.NextBit||, CODE, READONLY, ALIGN=2

                  NextBit PROC
;;;481    // Передача следующего бита
;;;482    void NextBit(void) {
000000  b510              PUSH     {r4,lr}
;;;483      if (curbit==0) {
000002  483f              LDR      r0,|L18.256|
000004  7800              LDRB     r0,[r0,#0]  ; curbit
000006  2800              CMP      r0,#0
000008  d14e              BNE      |L18.168|
;;;484        if (curnum) {
00000a  483e              LDR      r0,|L18.260|
00000c  7800              LDRB     r0,[r0,#0]  ; curnum
00000e  2800              CMP      r0,#0
000010  d040              BEQ      |L18.148|
;;;485          if (curnum!=1) {
000012  483c              LDR      r0,|L18.260|
000014  7800              LDRB     r0,[r0,#0]  ; curnum
000016  2801              CMP      r0,#1
000018  d028              BEQ      |L18.108|
;;;486            curtrbuf++;
00001a  483b              LDR      r0,|L18.264|
00001c  6800              LDR      r0,[r0,#0]  ; curtrbuf
00001e  1c40              ADDS     r0,r0,#1
000020  4939              LDR      r1,|L18.264|
000022  6008              STR      r0,[r1,#0]  ; curtrbuf
;;;487            if (!(SensConfig&PSMODE)) {
000024  4839              LDR      r0,|L18.268|
000026  7800              LDRB     r0,[r0,#0]  ; SensConfig
000028  f0000002          AND      r0,r0,#2
00002c  b950              CBNZ     r0,|L18.68|
;;;488              if (curtrbuf>=(TrBuffer+BUFFERS_LENGTH)) curtrbuf-=BUFFERS_LENGTH;
00002e  4608              MOV      r0,r1
000030  6801              LDR      r1,[r0,#0]  ; curtrbuf
000032  4837              LDR      r0,|L18.272|
000034  4281              CMP      r1,r0
000036  d305              BCC      |L18.68|
000038  4833              LDR      r0,|L18.264|
00003a  6800              LDR      r0,[r0,#0]  ; curtrbuf
00003c  f5a07080          SUB      r0,r0,#0x100
000040  4931              LDR      r1,|L18.264|
000042  6008              STR      r0,[r1,#0]  ; curtrbuf
                  |L18.68|
;;;489            }
;;;490            curbyte=*curtrbuf;
000044  4830              LDR      r0,|L18.264|
000046  6800              LDR      r0,[r0,#0]  ; curtrbuf
000048  7800              LDRB     r0,[r0,#0]
00004a  4932              LDR      r1,|L18.276|
00004c  7008              STRB     r0,[r1,#0]
;;;491            crc+=curbyte;
00004e  4832              LDR      r0,|L18.280|
000050  7800              LDRB     r0,[r0,#0]  ; crc
000052  7809              LDRB     r1,[r1,#0]  ; curbyte
000054  4408              ADD      r0,r0,r1
000056  4930              LDR      r1,|L18.280|
000058  7008              STRB     r0,[r1,#0]
;;;492            curnum--;
00005a  482a              LDR      r0,|L18.260|
00005c  7800              LDRB     r0,[r0,#0]  ; curnum
00005e  1e40              SUBS     r0,r0,#1
000060  4928              LDR      r1,|L18.260|
000062  7008              STRB     r0,[r1,#0]
;;;493            curbit=0x80;
000064  2080              MOVS     r0,#0x80
000066  4926              LDR      r1,|L18.256|
000068  7008              STRB     r0,[r1,#0]
00006a  e01d              B        |L18.168|
                  |L18.108|
;;;494          } else {
;;;495            curbyte=crc+(crc<<4)|0x08;            
00006c  482a              LDR      r0,|L18.280|
00006e  7800              LDRB     r0,[r0,#0]  ; crc
000070  4929              LDR      r1,|L18.280|
000072  7809              LDRB     r1,[r1,#0]  ; crc
000074  eb001001          ADD      r0,r0,r1,LSL #4
000078  b2c0              UXTB     r0,r0
00007a  f0400008          ORR      r0,r0,#8
00007e  4925              LDR      r1,|L18.276|
000080  7008              STRB     r0,[r1,#0]
;;;496            curbit=0x10;
000082  2010              MOVS     r0,#0x10
000084  491e              LDR      r1,|L18.256|
000086  7008              STRB     r0,[r1,#0]
;;;497            curnum--;
000088  481e              LDR      r0,|L18.260|
00008a  7800              LDRB     r0,[r0,#0]  ; curnum
00008c  1e40              SUBS     r0,r0,#1
00008e  491d              LDR      r1,|L18.260|
000090  7008              STRB     r0,[r1,#0]
000092  e009              B        |L18.168|
                  |L18.148|
;;;498          }
;;;499        } else {
;;;500    //// Всё-всё передали, и прошла 1 мс единицы
;;;501          RemovePkg(0);
000094  2000              MOVS     r0,#0
000096  f7fffffe          BL       RemovePkg
;;;502          AddTime((uint16_t)(-TIME1MS));
00009a  f64f70d8          MOV      r0,#0xffd8
00009e  f7fffffe          BL       AddTime
;;;503          SelectND();
0000a2  f7fffffe          BL       SelectND
                  |L18.166|
;;;504          return;
;;;505        }
;;;506      }
;;;507      if (curbyte&0x80) {
;;;508        SensState=SS_PP2;
;;;509        SetOut(1);
;;;510        ZZZ<<=1;
;;;511        AddTime(TIME1MS);
;;;512      } else {
;;;513        SensState=SS_PP5;
;;;514        SetOut(0);
;;;515        AddTime(TIME0_5MS);
;;;516      }
;;;517      curbyte<<=1;
;;;518      curbit>>=1;
;;;519    }
0000a6  bd10              POP      {r4,pc}
                  |L18.168|
0000a8  481a              LDR      r0,|L18.276|
0000aa  7800              LDRB     r0,[r0,#0]            ;507  ; curbyte
0000ac  f0000080          AND      r0,r0,#0x80           ;507
0000b0  b178              CBZ      r0,|L18.210|
0000b2  2052              MOVS     r0,#0x52              ;508
0000b4  4919              LDR      r1,|L18.284|
0000b6  7008              STRB     r0,[r1,#0]            ;508
0000b8  2001              MOVS     r0,#1                 ;509
0000ba  f7fffffe          BL       SetOut
0000be  4818              LDR      r0,|L18.288|
0000c0  7800              LDRB     r0,[r0,#0]            ;510  ; ZZZ
0000c2  0640              LSLS     r0,r0,#25             ;510
0000c4  0e00              LSRS     r0,r0,#24             ;510
0000c6  4916              LDR      r1,|L18.288|
0000c8  7008              STRB     r0,[r1,#0]            ;510
0000ca  2028              MOVS     r0,#0x28              ;511
0000cc  f7fffffe          BL       AddTime
0000d0  e008              B        |L18.228|
                  |L18.210|
0000d2  2055              MOVS     r0,#0x55              ;513
0000d4  4911              LDR      r1,|L18.284|
0000d6  7008              STRB     r0,[r1,#0]            ;513
0000d8  2000              MOVS     r0,#0                 ;514
0000da  f7fffffe          BL       SetOut
0000de  2014              MOVS     r0,#0x14              ;515
0000e0  f7fffffe          BL       AddTime
                  |L18.228|
0000e4  480b              LDR      r0,|L18.276|
0000e6  7800              LDRB     r0,[r0,#0]            ;517  ; curbyte
0000e8  0640              LSLS     r0,r0,#25             ;517
0000ea  0e00              LSRS     r0,r0,#24             ;517
0000ec  4909              LDR      r1,|L18.276|
0000ee  7008              STRB     r0,[r1,#0]            ;517
0000f0  4803              LDR      r0,|L18.256|
0000f2  7800              LDRB     r0,[r0,#0]            ;518  ; curbit
0000f4  1040              ASRS     r0,r0,#1              ;518
0000f6  4902              LDR      r1,|L18.256|
0000f8  7008              STRB     r0,[r1,#0]            ;518
0000fa  bf00              NOP      
0000fc  e7d3              B        |L18.166|
;;;520    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L18.256|
                          DCD      curbit
                  |L18.260|
                          DCD      curnum
                  |L18.264|
                          DCD      curtrbuf
                  |L18.268|
                          DCD      SensConfig
                  |L18.272|
                          DCD      TrBuffer+0x100
                  |L18.276|
                          DCD      curbyte
                  |L18.280|
                          DCD      ||crc||
                  |L18.284|
                          DCD      SensState
                  |L18.288|
                          DCD      ZZZ

                          AREA ||i.RemovePkg||, CODE, READONLY, ALIGN=2

                  RemovePkg PROC
;;;458    
;;;459    void RemovePkg(char flgerr) {
000000  4a24              LDR      r2,|L19.148|
;;;460      uint8_t len;
;;;461      if (!(SensConfig&PSMODE)) {
000002  7812              LDRB     r2,[r2,#0]  ; SensConfig
000004  f0020202          AND      r2,r2,#2
000008  bb7a              CBNZ     r2,|L19.106|
;;;462        if (flgerr) {
00000a  b148              CBZ      r0,|L19.32|
;;;463    // Ошибка передачи пакета
;;;464          trnum++;
00000c  4a22              LDR      r2,|L19.152|
00000e  7812              LDRB     r2,[r2,#0]  ; trnum
000010  1c52              ADDS     r2,r2,#1
000012  4b21              LDR      r3,|L19.152|
000014  701a              STRB     r2,[r3,#0]
;;;465          if (trnum<3) return;
000016  461a              MOV      r2,r3
000018  7812              LDRB     r2,[r2,#0]  ; trnum
00001a  2a03              CMP      r2,#3
00001c  da00              BGE      |L19.32|
                  |L19.30|
;;;466        }
;;;467    // Удаление пакета
;;;468        TrBufPointerTail+=2;
;;;469        if (TrBufPointerTail>=(TrBuffer+BUFFERS_LENGTH)) TrBufPointerTail-=BUFFERS_LENGTH;
;;;470        len=*TrBufPointerTail;
;;;471        TrBufPointerTail+=(len+1);
;;;472        if (TrBufPointerTail>=(TrBuffer+BUFFERS_LENGTH)) TrBufPointerTail-=BUFFERS_LENGTH;
;;;473      } else {
;;;474    // Состояние - перематываем на следующее независимо от причины
;;;475        curBSPointer=curBSPointer+(*(curBSPointer+2))+3;
;;;476        ResetCFGB(PSMODE); 
;;;477      }
;;;478      trnum=0;
;;;479    }
00001e  4770              BX       lr
                  |L19.32|
000020  4a1e              LDR      r2,|L19.156|
000022  6812              LDR      r2,[r2,#0]            ;468  ; TrBufPointerTail
000024  1c92              ADDS     r2,r2,#2              ;468
000026  4b1d              LDR      r3,|L19.156|
000028  601a              STR      r2,[r3,#0]            ;468  ; TrBufPointerTail
00002a  461a              MOV      r2,r3                 ;469
00002c  6813              LDR      r3,[r2,#0]            ;469  ; TrBufPointerTail
00002e  4a1c              LDR      r2,|L19.160|
000030  4293              CMP      r3,r2                 ;469
000032  d305              BCC      |L19.64|
000034  4a19              LDR      r2,|L19.156|
000036  6812              LDR      r2,[r2,#0]            ;469  ; TrBufPointerTail
000038  f5a27280          SUB      r2,r2,#0x100          ;469
00003c  4b17              LDR      r3,|L19.156|
00003e  601a              STR      r2,[r3,#0]            ;469  ; TrBufPointerTail
                  |L19.64|
000040  4a16              LDR      r2,|L19.156|
000042  6812              LDR      r2,[r2,#0]            ;470  ; TrBufPointerTail
000044  7811              LDRB     r1,[r2,#0]            ;470
000046  4a15              LDR      r2,|L19.156|
000048  6813              LDR      r3,[r2,#0]            ;471  ; TrBufPointerTail
00004a  1c4a              ADDS     r2,r1,#1              ;471
00004c  441a              ADD      r2,r2,r3              ;471
00004e  4b13              LDR      r3,|L19.156|
000050  601a              STR      r2,[r3,#0]            ;471  ; TrBufPointerTail
000052  461a              MOV      r2,r3                 ;472
000054  6813              LDR      r3,[r2,#0]            ;472  ; TrBufPointerTail
000056  4a12              LDR      r2,|L19.160|
000058  4293              CMP      r3,r2                 ;472
00005a  d316              BCC      |L19.138|
00005c  4a0f              LDR      r2,|L19.156|
00005e  6812              LDR      r2,[r2,#0]            ;472  ; TrBufPointerTail
000060  f5a27280          SUB      r2,r2,#0x100          ;472
000064  4b0d              LDR      r3,|L19.156|
000066  601a              STR      r2,[r3,#0]            ;472  ; TrBufPointerTail
000068  e00f              B        |L19.138|
                  |L19.106|
00006a  e7ff              B        |L19.108|
                  |L19.108|
00006c  4a0d              LDR      r2,|L19.164|
00006e  6812              LDR      r2,[r2,#0]            ;475  ; curBSPointer
000070  7892              LDRB     r2,[r2,#2]            ;475
000072  4b0c              LDR      r3,|L19.164|
000074  681b              LDR      r3,[r3,#0]            ;475  ; curBSPointer
000076  441a              ADD      r2,r2,r3              ;475
000078  1cd2              ADDS     r2,r2,#3              ;475
00007a  4b0a              LDR      r3,|L19.164|
00007c  601a              STR      r2,[r3,#0]            ;475  ; curBSPointer
00007e  4a05              LDR      r2,|L19.148|
000080  7812              LDRB     r2,[r2,#0]            ;476  ; SensConfig
000082  f0220202          BIC      r2,r2,#2              ;476
000086  4b03              LDR      r3,|L19.148|
000088  701a              STRB     r2,[r3,#0]            ;476
                  |L19.138|
00008a  2200              MOVS     r2,#0                 ;478
00008c  4b02              LDR      r3,|L19.152|
00008e  701a              STRB     r2,[r3,#0]            ;478
000090  bf00              NOP      
000092  e7c4              B        |L19.30|
;;;480    
                          ENDP

                  |L19.148|
                          DCD      SensConfig
                  |L19.152|
                          DCD      trnum
                  |L19.156|
                          DCD      TrBufPointerTail
                  |L19.160|
                          DCD      TrBuffer+0x100
                  |L19.164|
                          DCD      curBSPointer

                          AREA ||i.SelectND||, CODE, READONLY, ALIGN=2

                  SelectND PROC
;;;420    // нарастающего фронта (это должно обеспечиваться внешними силами)
;;;421    void SelectND(void) {
000000  b510              PUSH     {r4,lr}
;;;422      EnableINT();
000002  f7fffffe          BL       EnableINT
;;;423      if (Ni>=32) {
000006  4830              LDR      r0,|L20.200|
000008  7800              LDRB     r0,[r0,#0]  ; Ni
00000a  2820              CMP      r0,#0x20
00000c  db09              BLT      |L20.34|
;;;424    // Передавать нечего, выдерживаем паузу до синхропаузы
;;;425        AddTime(TIME20MS);
00000e  f44f7048          MOV      r0,#0x320
000012  f7fffffe          BL       AddTime
;;;426        SensState=SS_WAIT;
000016  2000              MOVS     r0,#0
000018  492c              LDR      r1,|L20.204|
00001a  7008              STRB     r0,[r1,#0]
;;;427        SensD=SD_WAITSISP;
00001c  492c              LDR      r1,|L20.208|
00001e  7008              STRB     r0,[r1,#0]
000020  e050              B        |L20.196|
                  |L20.34|
;;;428      } else {
;;;429        SensState=SS_WAIT;
000022  2000              MOVS     r0,#0
000024  4929              LDR      r1,|L20.204|
000026  7008              STRB     r0,[r1,#0]
;;;430    // Смотрим, не передать ли пакет из буфера?
;;;431        if (TrBufPointerTail!=TrBufPointerHead) {
000028  482a              LDR      r0,|L20.212|
00002a  6800              LDR      r0,[r0,#0]  ; TrBufPointerTail
00002c  492a              LDR      r1,|L20.216|
00002e  6809              LDR      r1,[r1,#0]  ; TrBufPointerHead
000030  4288              CMP      r0,r1
000032  d019              BEQ      |L20.104|
;;;432          if ((*(TrBufPointerTail)==Ni)||(*(TrBufPointerTail)==0)||(SensD==SD_INDEPEND)) {
000034  4827              LDR      r0,|L20.212|
000036  6800              LDR      r0,[r0,#0]  ; TrBufPointerTail
000038  7800              LDRB     r0,[r0,#0]
00003a  4923              LDR      r1,|L20.200|
00003c  7809              LDRB     r1,[r1,#0]  ; Ni
00003e  4288              CMP      r0,r1
000040  d007              BEQ      |L20.82|
000042  4824              LDR      r0,|L20.212|
000044  6800              LDR      r0,[r0,#0]  ; TrBufPointerTail
000046  7800              LDRB     r0,[r0,#0]
000048  b118              CBZ      r0,|L20.82|
00004a  4821              LDR      r0,|L20.208|
00004c  7800              LDRB     r0,[r0,#0]  ; SensD
00004e  2802              CMP      r0,#2
000050  d10a              BNE      |L20.104|
                  |L20.82|
;;;433            ResetCFGB(PSMODE);
000052  4822              LDR      r0,|L20.220|
000054  7800              LDRB     r0,[r0,#0]  ; SensConfig
000056  f0200002          BIC      r0,r0,#2
00005a  4920              LDR      r1,|L20.220|
00005c  7008              STRB     r0,[r1,#0]
;;;434            SetWritePkg(TrBufPointerTail);
00005e  481d              LDR      r0,|L20.212|
000060  6800              LDR      r0,[r0,#0]  ; TrBufPointerTail
000062  f7fffffe          BL       SetWritePkg
                  |L20.102|
;;;435            return;
;;;436          }
;;;437        }
;;;438    // 
;;;439        if (curBSPointer&&(!(SensConfig&NOPS))) {
;;;440          if (Ni==*(curBSPointer)) {
;;;441    // Пытаемся передать очередное состояние
;;;442            SetCFGB(PSMODE);
;;;443            SetWritePkg(curBSPointer);
;;;444            return;
;;;445          }
;;;446        }
;;;447    // Остаётся генерация синхроимпульса, если разрешена
;;;448        if (SensConfig&IGENSYNC) {
;;;449          AddTime(TIME14MS);
;;;450          SensD=SD_GENSI;
;;;451        } else {
;;;452          AddTime(TIME20MS);
;;;453          SensD=SD_WAITSISP;
;;;454        }
;;;455      }
;;;456    }
000066  bd10              POP      {r4,pc}
                  |L20.104|
000068  481d              LDR      r0,|L20.224|
00006a  6800              LDR      r0,[r0,#0]            ;439  ; curBSPointer
00006c  b1b0              CBZ      r0,|L20.156|
00006e  481b              LDR      r0,|L20.220|
000070  7800              LDRB     r0,[r0,#0]            ;439  ; SensConfig
000072  f0000004          AND      r0,r0,#4              ;439
000076  b988              CBNZ     r0,|L20.156|
000078  4819              LDR      r0,|L20.224|
00007a  6800              LDR      r0,[r0,#0]            ;440  ; curBSPointer
00007c  7800              LDRB     r0,[r0,#0]            ;440
00007e  4912              LDR      r1,|L20.200|
000080  7809              LDRB     r1,[r1,#0]            ;440  ; Ni
000082  4288              CMP      r0,r1                 ;440
000084  d10a              BNE      |L20.156|
000086  4815              LDR      r0,|L20.220|
000088  7800              LDRB     r0,[r0,#0]            ;442  ; SensConfig
00008a  f0400002          ORR      r0,r0,#2              ;442
00008e  4913              LDR      r1,|L20.220|
000090  7008              STRB     r0,[r1,#0]            ;442
000092  4813              LDR      r0,|L20.224|
000094  6800              LDR      r0,[r0,#0]            ;443  ; curBSPointer
000096  f7fffffe          BL       SetWritePkg
00009a  e7e4              B        |L20.102|
                  |L20.156|
00009c  480f              LDR      r0,|L20.220|
00009e  7800              LDRB     r0,[r0,#0]            ;448  ; SensConfig
0000a0  f0000080          AND      r0,r0,#0x80           ;448
0000a4  b138              CBZ      r0,|L20.182|
0000a6  f44f7016          MOV      r0,#0x258             ;449
0000aa  f7fffffe          BL       AddTime
0000ae  2001              MOVS     r0,#1                 ;450
0000b0  4907              LDR      r1,|L20.208|
0000b2  7008              STRB     r0,[r1,#0]            ;450
0000b4  e006              B        |L20.196|
                  |L20.182|
0000b6  f44f7048          MOV      r0,#0x320             ;452
0000ba  f7fffffe          BL       AddTime
0000be  2000              MOVS     r0,#0                 ;453
0000c0  4903              LDR      r1,|L20.208|
0000c2  7008              STRB     r0,[r1,#0]            ;453
                  |L20.196|
0000c4  bf00              NOP      
0000c6  e7ce              B        |L20.102|
;;;457    
                          ENDP

                  |L20.200|
                          DCD      ||Ni||
                  |L20.204|
                          DCD      SensState
                  |L20.208|
                          DCD      SensD
                  |L20.212|
                          DCD      TrBufPointerTail
                  |L20.216|
                          DCD      TrBufPointerHead
                  |L20.220|
                          DCD      SensConfig
                  |L20.224|
                          DCD      curBSPointer

                          AREA ||i.SensGetPkg||, CODE, READONLY, ALIGN=2

                  SensGetPkg PROC
;;;809     // Получение одного пакета, возвращает длину или 0 если пакета нет
;;;810    uint8_t SensGetPkg(uint8_t * buf) {
000000  b530              PUSH     {r4,r5,lr}
000002  4603              MOV      r3,r0
;;;811      volatile uint8_t * Pnt;
;;;812      uint8_t len,n;
;;;813      IN_CRITICAL();
000004  b672              CPSID    i
;;;814      if (RdBufPointerHead==RdBufPointerTail) {
000006  481a              LDR      r0,|L21.112|
000008  6800              LDR      r0,[r0,#0]  ; RdBufPointerHead
00000a  4d1a              LDR      r5,|L21.116|
00000c  682d              LDR      r5,[r5,#0]  ; RdBufPointerTail
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L21.24|
;;;815        OUT_CRITICAL();
000012  b662              CPSIE    i
;;;816        return 0;
000014  2000              MOVS     r0,#0
                  |L21.22|
;;;817      }
;;;818      OUT_CRITICAL();
;;;819    // Считываем пакет
;;;820      Pnt=RdBufPointerTail;
;;;821      len=*Pnt;
;;;822      *(buf++)=len;
;;;823      if (len<=64) {
;;;824        for (n=0;n<len;n++) {
;;;825          Pnt++;
;;;826          if (Pnt>=(RdBuffer+BUFFERS_LENGTH)) Pnt-=BUFFERS_LENGTH;
;;;827          *(buf++)=*(Pnt);
;;;828        }
;;;829      }
;;;830      IN_CRITICAL();
;;;831      RdBufPointerTail=RdBufPointerTail+len+1;
;;;832      if (RdBufPointerTail>=(RdBuffer+BUFFERS_LENGTH)) RdBufPointerTail-=BUFFERS_LENGTH;
;;;833      OUT_CRITICAL();
;;;834      return len;
;;;835    };
000016  bd30              POP      {r4,r5,pc}
                  |L21.24|
000018  b662              CPSIE    i                     ;818
00001a  4816              LDR      r0,|L21.116|
00001c  6801              LDR      r1,[r0,#0]            ;820  ; RdBufPointerTail
00001e  780a              LDRB     r2,[r1,#0]            ;821
000020  f8032b01          STRB     r2,[r3],#1            ;822
000024  2a40              CMP      r2,#0x40              ;823
000026  dc0e              BGT      |L21.70|
000028  2400              MOVS     r4,#0                 ;824
00002a  e00a              B        |L21.66|
                  |L21.44|
00002c  1c49              ADDS     r1,r1,#1              ;825
00002e  4812              LDR      r0,|L21.120|
000030  4281              CMP      r1,r0                 ;826
000032  d301              BCC      |L21.56|
000034  f5a17180          SUB      r1,r1,#0x100          ;826
                  |L21.56|
000038  7808              LDRB     r0,[r1,#0]            ;827
00003a  f8030b01          STRB     r0,[r3],#1            ;827
00003e  1c60              ADDS     r0,r4,#1              ;824
000040  b2c4              UXTB     r4,r0                 ;824
                  |L21.66|
000042  4294              CMP      r4,r2                 ;824
000044  dbf2              BLT      |L21.44|
                  |L21.70|
000046  b672              CPSID    i                     ;830
000048  480a              LDR      r0,|L21.116|
00004a  6800              LDR      r0,[r0,#0]            ;831  ; RdBufPointerTail
00004c  4410              ADD      r0,r0,r2              ;831
00004e  1c40              ADDS     r0,r0,#1              ;831
000050  4d08              LDR      r5,|L21.116|
000052  6028              STR      r0,[r5,#0]            ;831  ; RdBufPointerTail
000054  4628              MOV      r0,r5                 ;832
000056  6805              LDR      r5,[r0,#0]            ;832  ; RdBufPointerTail
000058  4807              LDR      r0,|L21.120|
00005a  4285              CMP      r5,r0                 ;832
00005c  d305              BCC      |L21.106|
00005e  4805              LDR      r0,|L21.116|
000060  6800              LDR      r0,[r0,#0]            ;832  ; RdBufPointerTail
000062  f5a07080          SUB      r0,r0,#0x100          ;832
000066  4d03              LDR      r5,|L21.116|
000068  6028              STR      r0,[r5,#0]            ;832  ; RdBufPointerTail
                  |L21.106|
00006a  b662              CPSIE    i                     ;833
00006c  4610              MOV      r0,r2                 ;834
00006e  e7d2              B        |L21.22|
;;;836    
                          ENDP

                  |L21.112|
                          DCD      RdBufPointerHead
                  |L21.116|
                          DCD      RdBufPointerTail
                  |L21.120|
                          DCD      RdBuffer+0x100

                          AREA ||i.SensSendPkg||, CODE, READONLY, ALIGN=2

                  SensSendPkg PROC
;;;839    // iadr - эквивалентный адрес передачи. =0 если передавать немедленно, =255 если передавать от адреса пакета
;;;840    void SensSendPkg(uint8_t * buf,uint8_t iadr) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4602              MOV      r2,r0
;;;841      uint8_t n,num;
;;;842      volatile uint8_t * pnt;
;;;843      volatile uint8_t * pnt2;
;;;844      volatile uint8_t * pntps;
;;;845      uint8_t ni,ps;
;;;846      pnt=TrBufPointerHead+2;
000006  f8df80e8          LDR      r8,|L22.240|
00000a  f8d88000          LDR      r8,[r8,#0]  ; TrBufPointerHead
00000e  f1080002          ADD      r0,r8,#2
;;;847      if (pnt>=(TrBuffer+BUFFERS_LENGTH)) pnt-=BUFFERS_LENGTH;
000012  f8df80e0          LDR      r8,|L22.244|
000016  4540              CMP      r0,r8
000018  d301              BCC      |L22.30|
00001a  f5a07080          SUB      r0,r0,#0x100
                  |L22.30|
;;;848      pnt2=buf;
00001e  4614              MOV      r4,r2
;;;849      num=(*pnt2)+1;
000020  f8948000          LDRB     r8,[r4,#0]
000024  f1080801          ADD      r8,r8,#1
000028  f0080cff          AND      r12,r8,#0xff
;;;850      for (n=0;n<num;n++) {    
00002c  2600              MOVS     r6,#0
00002e  e015              B        |L22.92|
                  |L22.48|
;;;851        *(pnt++)=*(pnt2++);
000030  f8148b01          LDRB     r8,[r4],#1
000034  f8008b01          STRB     r8,[r0],#1
;;;852        if (pnt>=(TrBuffer+BUFFERS_LENGTH)) pnt-=BUFFERS_LENGTH;
000038  f8df80b8          LDR      r8,|L22.244|
00003c  4540              CMP      r0,r8
00003e  d301              BCC      |L22.68|
000040  f5a07080          SUB      r0,r0,#0x100
                  |L22.68|
;;;853        if (pnt==TrBufPointerTail) return;                        // ОТМЕНЯЕМ ПЕРЕДАЧУ
000044  f8df80b0          LDR      r8,|L22.248|
000048  f8d88000          LDR      r8,[r8,#0]  ; TrBufPointerTail
00004c  4540              CMP      r0,r8
00004e  d101              BNE      |L22.84|
                  |L22.80|
;;;854      }
;;;855    // Пакет скопировали, рассчитываем адреса и паузы
;;;856      pntps=TrBufPointerHead+1;
;;;857      if (pntps>=(TrBuffer+BUFFERS_LENGTH)) pntps-=BUFFERS_LENGTH;  
;;;858      if (iadr==0xFF) iadr=buf[1];
;;;859      if (iadr==0) {
;;;860    // Немедленная передача через 3 или 4 мс
;;;861        if (buf[2]&0x80) ps=3; else ps=4;
;;;862        ni=0;
;;;863      } else {
;;;864        ni=(iadr-1)%31+1;
;;;865        ps=(iadr-1)/31+3;
;;;866        if (!(buf[2]&0x80)) ps+=1;
;;;867      } 
;;;868      *TrBufPointerHead=ni;
;;;869      *pntps=ps;
;;;870      TrBufPointerHead=pnt;
;;;871    }
000050  e8bd87f0          POP      {r4-r10,pc}
                  |L22.84|
000054  f1060801          ADD      r8,r6,#1              ;850
000058  f00806ff          AND      r6,r8,#0xff           ;850
                  |L22.92|
00005c  4566              CMP      r6,r12                ;850
00005e  dbe7              BLT      |L22.48|
000060  f8df808c          LDR      r8,|L22.240|
000064  f8d88000          LDR      r8,[r8,#0]            ;856  ; TrBufPointerHead
000068  f1080501          ADD      r5,r8,#1              ;856
00006c  f8df8084          LDR      r8,|L22.244|
000070  4545              CMP      r5,r8                 ;857
000072  d301              BCC      |L22.120|
000074  f5a57580          SUB      r5,r5,#0x100          ;857
                  |L22.120|
000078  29ff              CMP      r1,#0xff              ;858
00007a  d100              BNE      |L22.126|
00007c  7851              LDRB     r1,[r2,#1]            ;858
                  |L22.126|
00007e  b959              CBNZ     r1,|L22.152|
000080  f8928002          LDRB     r8,[r2,#2]            ;861
000084  f0080880          AND      r8,r8,#0x80           ;861
000088  f1b80f00          CMP      r8,#0                 ;861
00008c  d001              BEQ      |L22.146|
00008e  2303              MOVS     r3,#3                 ;861
000090  e000              B        |L22.148|
                  |L22.146|
000092  2304              MOVS     r3,#4                 ;861
                  |L22.148|
000094  2700              MOVS     r7,#0                 ;862
000096  e01e              B        |L22.214|
                  |L22.152|
000098  f1a10801          SUB      r8,r1,#1              ;864
00009c  f04f091f          MOV      r9,#0x1f              ;864
0000a0  fb98faf9          SDIV     r10,r8,r9             ;864
0000a4  fb09881a          MLS      r8,r9,r10,r8          ;864
0000a8  f1080801          ADD      r8,r8,#1              ;864
0000ac  f00807ff          AND      r7,r8,#0xff           ;864
0000b0  f1a10801          SUB      r8,r1,#1              ;865
0000b4  fb98f8f9          SDIV     r8,r8,r9              ;865
0000b8  f1080803          ADD      r8,r8,#3              ;865
0000bc  f00803ff          AND      r3,r8,#0xff           ;865
0000c0  f8928002          LDRB     r8,[r2,#2]            ;866
0000c4  f0080880          AND      r8,r8,#0x80           ;866
0000c8  f1b80f00          CMP      r8,#0                 ;866
0000cc  d103              BNE      |L22.214|
0000ce  f1030801          ADD      r8,r3,#1              ;866
0000d2  f00803ff          AND      r3,r8,#0xff           ;866
                  |L22.214|
0000d6  f8df8018          LDR      r8,|L22.240|
0000da  f8d88000          LDR      r8,[r8,#0]            ;868  ; TrBufPointerHead
0000de  f8887000          STRB     r7,[r8,#0]            ;868
0000e2  702b              STRB     r3,[r5,#0]            ;869
0000e4  f8df8008          LDR      r8,|L22.240|
0000e8  f8c80000          STR      r0,[r8,#0]            ;870  ; TrBufPointerHead
0000ec  bf00              NOP      
0000ee  e7af              B        |L22.80|
;;;872    
                          ENDP

                  |L22.240|
                          DCD      TrBufPointerHead
                  |L22.244|
                          DCD      TrBuffer+0x100
                  |L22.248|
                          DCD      TrBufPointerTail

                          AREA ||i.SetBSBuf||, CODE, READONLY, ALIGN=2

                  SetBSBuf PROC
;;;910    // Устанавливает указатель на буфер состояний
;;;911    void SetBSBuf(void * bsbufpnt) {
000000  4901              LDR      r1,|L23.8|
;;;912      BSPointer=bsbufpnt;
000002  6008              STR      r0,[r1,#0]  ; BSPointer
;;;913    }
000004  4770              BX       lr
;;;914    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      BSPointer

                          AREA ||i.SetOut||, CODE, READONLY, ALIGN=1

                  SetOut PROC
;;;181    
;;;182    void SetOut(char n) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;183      GPIO_WriteBit(OUTPORT,OUTPIN,n?Bit_SET:Bit_RESET);
000004  b10c              CBZ      r4,|L24.10|
000006  2001              MOVS     r0,#1
000008  e000              B        |L24.12|
                  |L24.10|
00000a  2000              MOVS     r0,#0
                  |L24.12|
00000c  4602              MOV      r2,r0
00000e  2120              MOVS     r1,#0x20
000010  f04f4090          MOV      r0,#0x48000000
000014  f7fffffe          BL       GPIO_WriteBit
;;;184    }
000018  bd10              POP      {r4,pc}
;;;185    
                          ENDP


                          AREA ||i.SetWritePkg||, CODE, READONLY, ALIGN=2

                  SetWritePkg PROC
;;;399    
;;;400    void SetWritePkg(volatile uint8_t * buf) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;401      int tm;
;;;402      curtrbuf=buf+2;
000004  1ca0              ADDS     r0,r4,#2
000006  491c              LDR      r1,|L25.120|
000008  6008              STR      r0,[r1,#0]  ; curtrbuf
;;;403      if (!(SensConfig&PSMODE)) {
00000a  481c              LDR      r0,|L25.124|
00000c  7800              LDRB     r0,[r0,#0]  ; SensConfig
00000e  f0000002          AND      r0,r0,#2
000012  b950              CBNZ     r0,|L25.42|
;;;404        if (curtrbuf>=(TrBuffer+BUFFERS_LENGTH)) curtrbuf-=BUFFERS_LENGTH;
000014  4608              MOV      r0,r1
000016  6801              LDR      r1,[r0,#0]  ; curtrbuf
000018  4819              LDR      r0,|L25.128|
00001a  4281              CMP      r1,r0
00001c  d305              BCC      |L25.42|
00001e  4816              LDR      r0,|L25.120|
000020  6800              LDR      r0,[r0,#0]  ; curtrbuf
000022  f5a07080          SUB      r0,r0,#0x100
000026  4914              LDR      r1,|L25.120|
000028  6008              STR      r0,[r1,#0]  ; curtrbuf
                  |L25.42|
;;;405      }
;;;406      crc=0;
00002a  2000              MOVS     r0,#0
00002c  4915              LDR      r1,|L25.132|
00002e  7008              STRB     r0,[r1,#0]
;;;407      curbit=0;
000030  4915              LDR      r1,|L25.136|
000032  7008              STRB     r0,[r1,#0]
;;;408      curnum=(*curtrbuf)+1; // На единицу больше из-за CRC
000034  4810              LDR      r0,|L25.120|
000036  6800              LDR      r0,[r0,#0]  ; curtrbuf
000038  7800              LDRB     r0,[r0,#0]
00003a  1c40              ADDS     r0,r0,#1
00003c  4913              LDR      r1,|L25.140|
00003e  7008              STRB     r0,[r1,#0]
;;;409      SensD=SD_TRANSMIT;
000040  2003              MOVS     r0,#3
000042  4913              LDR      r1,|L25.144|
000044  7008              STRB     r0,[r1,#0]
;;;410      buf++;
000046  1c64              ADDS     r4,r4,#1
;;;411      if (!(SensConfig&PSMODE)) {
000048  480c              LDR      r0,|L25.124|
00004a  7800              LDRB     r0,[r0,#0]  ; SensConfig
00004c  f0000002          AND      r0,r0,#2
000050  b920              CBNZ     r0,|L25.92|
;;;412        if (buf>=(TrBuffer+BUFFERS_LENGTH)) buf-=BUFFERS_LENGTH;
000052  480b              LDR      r0,|L25.128|
000054  4284              CMP      r4,r0
000056  d301              BCC      |L25.92|
000058  f5a47480          SUB      r4,r4,#0x100
                  |L25.92|
;;;413      }
;;;414      tm=*buf;
00005c  7825              LDRB     r5,[r4,#0]
;;;415      if (tm<=3) AddTime(TIME3MS); else AddTime(TIME1MS*tm);
00005e  2d03              CMP      r5,#3
000060  dc03              BGT      |L25.106|
000062  2078              MOVS     r0,#0x78
000064  f7fffffe          BL       AddTime
000068  e005              B        |L25.118|
                  |L25.106|
00006a  eb050185          ADD      r1,r5,r5,LSL #2
00006e  04c9              LSLS     r1,r1,#19
000070  0c08              LSRS     r0,r1,#16
000072  f7fffffe          BL       AddTime
                  |L25.118|
;;;416    }
000076  bd70              POP      {r4-r6,pc}
;;;417    
                          ENDP

                  |L25.120|
                          DCD      curtrbuf
                  |L25.124|
                          DCD      SensConfig
                  |L25.128|
                          DCD      TrBuffer+0x100
                  |L25.132|
                          DCD      ||crc||
                  |L25.136|
                          DCD      curbit
                  |L25.140|
                          DCD      curnum
                  |L25.144|
                          DCD      SensD

                          AREA ||i.StopSENS||, CODE, READONLY, ALIGN=1

                  StopSENS PROC
;;;347    // Перевод аппаратной части в режим простоя
;;;348    void StopSENS(void) {
000000  b51c              PUSH     {r2-r4,lr}
;;;349    ////////////////////////////////////////////////////////////////////// vvvv
;;;350    // Добавлено для уменьшения потребления во сне
;;;351      EXTI_InitTypeDef EXTI_InitStruct;  // Прерывания
;;;352    // Прерывания от входа
;;;353      EXTI_InitStruct.EXTI_Line=EXTI_LINE;
000002  2040              MOVS     r0,#0x40
000004  9000              STR      r0,[sp,#0]
;;;354      EXTI_InitStruct.EXTI_Mode=EXTI_Mode_Interrupt;
000006  2000              MOVS     r0,#0
000008  f88d0004          STRB     r0,[sp,#4]
;;;355      EXTI_InitStruct.EXTI_Trigger=EXTI_Trigger_Rising_Falling;
00000c  2010              MOVS     r0,#0x10
00000e  f88d0005          STRB     r0,[sp,#5]
;;;356      EXTI_InitStruct.EXTI_LineCmd=DISABLE;
000012  2000              MOVS     r0,#0
000014  f88d0006          STRB     r0,[sp,#6]
;;;357      EXTI_Init(&EXTI_InitStruct);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       EXTI_Init
;;;358    ////////////////////////////////////////////////////////////////////// ^^^^
;;;359    // Отключаем алгоритм
;;;360      TIM_Cmd(TIM3,DISABLE);
00001e  2100              MOVS     r1,#0
000020  f04f4080          MOV      r0,#0x40000000
000024  f7fffffe          BL       TIM_Cmd
;;;361      NVIC_DisableIRQ(NVIC_IRQn);
000028  2017              MOVS     r0,#0x17
00002a  f7fffffe          BL       NVIC_DisableIRQ
;;;362    // Переводим выход в "ноль"
;;;363      GPIO_ResetBits(OUTPORT,OUTPIN);
00002e  2120              MOVS     r1,#0x20
000030  f04f4090          MOV      r0,#0x48000000
000034  f7fffffe          BL       GPIO_ResetBits
;;;364    // Пока всё - можно в дальнейшем поотключать периферию
;;;365    }
000038  bd1c              POP      {r2-r4,pc}
;;;366    
                          ENDP


                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;538    // Обработчик прерывания от таймера 3
;;;539    void TIM3_IRQHandler(void) {
000000  b510              PUSH     {r4,lr}
;;;540    // Внутренние метки времени
;;;541      if (TIM_GetITStatus(TIM3,TIM_IT_CC2)) {
000002  2104              MOVS     r1,#4
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b178              CBZ      r0,|L27.44|
;;;542        ssec++;
00000c  48fe              LDR      r0,|L27.1032|
00000e  6800              LDR      r0,[r0,#0]  ; ssec
000010  1c40              ADDS     r0,r0,#1
000012  49fd              LDR      r1,|L27.1032|
000014  6008              STR      r0,[r1,#0]  ; ssec
;;;543        TIM_ClearFlag(TIM3,TIM_IT_CC2);
000016  2104              MOVS     r1,#4
000018  0708              LSLS     r0,r1,#28
00001a  f7fffffe          BL       TIM_ClearFlag
;;;544        TIM3->CCR2=TIM3->CCR2+TIME1MS;
00001e  f04f4080          MOV      r0,#0x40000000
000022  6b80              LDR      r0,[r0,#0x38]
000024  3028              ADDS     r0,r0,#0x28
000026  f04f4180          MOV      r1,#0x40000000
00002a  6388              STR      r0,[r1,#0x38]
                  |L27.44|
;;;545      }
;;;546    /////////////////// ЛИНИЯ СЕНС
;;;547    // Помехоотсеивающий дополнительный таймер
;;;548      if (TIM3->DIER&TIM3->SR&0x0008) {
00002c  f04f4080          MOV      r0,#0x40000000
000030  68c0              LDR      r0,[r0,#0xc]
000032  f04f4180          MOV      r1,#0x40000000
000036  6909              LDR      r1,[r1,#0x10]
000038  4008              ANDS     r0,r0,r1
00003a  f0000008          AND      r0,r0,#8
00003e  b1f8              CBZ      r0,|L27.128|
;;;549        TIM_ITConfig(TIM3,TIM_IT_CC3,DISABLE);
000040  2200              MOVS     r2,#0
000042  2108              MOVS     r1,#8
000044  06c8              LSLS     r0,r1,#27
000046  f7fffffe          BL       TIM_ITConfig
;;;550        if (!GetInput()) {
00004a  f7fffffe          BL       GetInput
00004e  b990              CBNZ     r0,|L27.118|
;;;551    // Начинается приём нулика на входе
;;;552          SensState=SS_P1;
000050  2021              MOVS     r0,#0x21
000052  49ee              LDR      r1,|L27.1036|
000054  7008              STRB     r0,[r1,#0]
;;;553          TIM3->CCR1=TIM3->CCR3+TIME1MS;
000056  0780              LSLS     r0,r0,#30
000058  6bc0              LDR      r0,[r0,#0x3c]
00005a  3028              ADDS     r0,r0,#0x28
00005c  f04f4180          MOV      r1,#0x40000000
000060  6348              STR      r0,[r1,#0x34]
;;;554          TIM_ClearFlag(TIM3,TIM_IT_CC1);  
000062  2102              MOVS     r1,#2
000064  0748              LSLS     r0,r1,#29
000066  f7fffffe          BL       TIM_ClearFlag
;;;555          TIM_ITConfig(TIM3,TIM_IT_CC1,ENABLE);  
00006a  2201              MOVS     r2,#1
00006c  2102              MOVS     r1,#2
00006e  0748              LSLS     r0,r1,#29
000070  f7fffffe          BL       TIM_ITConfig
000074  e004              B        |L27.128|
                  |L27.118|
;;;556        } else TIM_ITConfig(TIM3,TIM_IT_CC1,ENABLE);
000076  2201              MOVS     r2,#1
000078  2102              MOVS     r1,#2
00007a  0748              LSLS     r0,r1,#29
00007c  f7fffffe          BL       TIM_ITConfig
                  |L27.128|
;;;557      }
;;;558    // Основной таймер
;;;559      if (TIM3->DIER&TIM3->SR&0x0002) {
000080  f04f4080          MOV      r0,#0x40000000
000084  68c0              LDR      r0,[r0,#0xc]
000086  f04f4180          MOV      r1,#0x40000000
00008a  6909              LDR      r1,[r1,#0x10]
00008c  4008              ANDS     r0,r0,r1
00008e  f0000002          AND      r0,r0,#2
000092  2800              CMP      r0,#0
000094  d070              BEQ      |L27.376|
;;;560        TIM3->SR=0xFFFD;  // Было &=
000096  f64f70fd          MOV      r0,#0xfffd
00009a  0781              LSLS     r1,r0,#30
00009c  6108              STR      r0,[r1,#0x10]
;;;561    // Отменяем прерывания от фронта
;;;562        DisableINT();    
00009e  f7fffffe          BL       DisableINT
;;;563    // И от помехоотсеивающего таймера
;;;564        TIM_ITConfig(TIM3,TIM_IT_CC3,DISABLE);
0000a2  2200              MOVS     r2,#0
0000a4  2108              MOVS     r1,#8
0000a6  06c8              LSLS     r0,r1,#27
0000a8  f7fffffe          BL       TIM_ITConfig
;;;565    // Обработчик прерываний по достижению метки времени
;;;566        switch (SensState) {
0000ac  48d7              LDR      r0,|L27.1036|
0000ae  7800              LDRB     r0,[r0,#0]  ; SensState
0000b0  2830              CMP      r0,#0x30
0000b2  d074              BEQ      |L27.414|
0000b4  dc0f              BGT      |L27.214|
0000b6  2823              CMP      r0,#0x23
0000b8  d072              BEQ      |L27.416|
0000ba  dc05              BGT      |L27.200|
0000bc  b1e0              CBZ      r0,|L27.248|
0000be  2821              CMP      r0,#0x21
0000c0  d06f              BEQ      |L27.418|
0000c2  2822              CMP      r0,#0x22
                  |L27.196|
0000c4  d16e              BNE      |L27.420|
0000c6  e0bd              B        |L27.580|
                  |L27.200|
0000c8  2824              CMP      r0,#0x24
0000ca  d06c              BEQ      |L27.422|
0000cc  2827              CMP      r0,#0x27
0000ce  d06b              BEQ      |L27.424|
0000d0  2828              CMP      r0,#0x28
0000d2  d1f7              BNE      |L27.196|
0000d4  e0ea              B        |L27.684|
                  |L27.214|
0000d6  2853              CMP      r0,#0x53
0000d8  d067              BEQ      |L27.426|
0000da  dc06              BGT      |L27.234|
0000dc  2840              CMP      r0,#0x40
0000de  d072              BEQ      |L27.454|
0000e0  2851              CMP      r0,#0x51
0000e2  d071              BEQ      |L27.456|
0000e4  2852              CMP      r0,#0x52
0000e6  d1ed              BNE      |L27.196|
0000e8  e1c4              B        |L27.1140|
                  |L27.234|
0000ea  2854              CMP      r0,#0x54
0000ec  d06d              BEQ      |L27.458|
0000ee  2855              CMP      r0,#0x55
0000f0  d06c              BEQ      |L27.460|
0000f2  2856              CMP      r0,#0x56
0000f4  d1e6              BNE      |L27.196|
0000f6  e21b              B        |L27.1328|
                  |L27.248|
;;;567          case (SS_WAIT):
;;;568    // Выбор действия
;;;569            switch (SensD) {
0000f8  48c5              LDR      r0,|L27.1040|
0000fa  7800              LDRB     r0,[r0,#0]  ; SensD
0000fc  b178              CBZ      r0,|L27.286|
0000fe  2801              CMP      r0,#1
000100  d043              BEQ      |L27.394|
000102  2802              CMP      r0,#2
000104  d052              BEQ      |L27.428|
000106  2803              CMP      r0,#3
000108  d158              BNE      |L27.444|
;;;570              case (SD_TRANSMIT):
;;;571    // Передача
;;;572                SensState=SS_PP1;
00010a  2051              MOVS     r0,#0x51
00010c  49bf              LDR      r1,|L27.1036|
00010e  7008              STRB     r0,[r1,#0]
;;;573                SetOut(1);
000110  2001              MOVS     r0,#1
000112  f7fffffe          BL       SetOut
;;;574                AddTime(TIME1MS);            
000116  2028              MOVS     r0,#0x28
000118  f7fffffe          BL       AddTime
;;;575                break;
00011c  e051              B        |L27.450|
                  |L27.286|
;;;576              case (SD_WAITSISP):
;;;577    // Подготовка данных к новому синхроциклу
;;;578                EnableINT();
00011e  f7fffffe          BL       EnableINT
;;;579                Ni=0;
000122  2000              MOVS     r0,#0
000124  49bb              LDR      r1,|L27.1044|
000126  7008              STRB     r0,[r1,#0]
;;;580                if (BSPointer) {
000128  48bb              LDR      r0,|L27.1048|
00012a  6800              LDR      r0,[r0,#0]  ; BSPointer
00012c  b120              CBZ      r0,|L27.312|
;;;581                  curBSPointer=BSPointer;
00012e  48ba              LDR      r0,|L27.1048|
000130  6800              LDR      r0,[r0,#0]  ; BSPointer
000132  49ba              LDR      r1,|L27.1052|
000134  6008              STR      r0,[r1,#0]  ; curBSPointer
000136  e005              B        |L27.324|
                  |L27.312|
;;;582                } else ResetCFGB(CANTRPS);
000138  48b9              LDR      r0,|L27.1056|
00013a  7800              LDRB     r0,[r0,#0]  ; SensConfig
00013c  f0200001          BIC      r0,r0,#1
000140  49b7              LDR      r1,|L27.1056|
000142  7008              STRB     r0,[r1,#0]
                  |L27.324|
;;;583                if (NCK==0) NCK=4; else NCK=NCK&0x05;   
000144  48b7              LDR      r0,|L27.1060|
000146  7800              LDRB     r0,[r0,#0]  ; NCK
000148  b918              CBNZ     r0,|L27.338|
00014a  2004              MOVS     r0,#4
00014c  49b5              LDR      r1,|L27.1060|
00014e  7008              STRB     r0,[r1,#0]
000150  e005              B        |L27.350|
                  |L27.338|
000152  48b4              LDR      r0,|L27.1060|
000154  7800              LDRB     r0,[r0,#0]  ; NCK
000156  f0000005          AND      r0,r0,#5
00015a  49b2              LDR      r1,|L27.1060|
00015c  7008              STRB     r0,[r1,#0]
                  |L27.350|
;;;584                if (SensConfig&IGENSYNC) {  // Генерирует синхроимпульсы
00015e  48b0              LDR      r0,|L27.1056|
000160  7800              LDRB     r0,[r0,#0]  ; SensConfig
000162  f0000080          AND      r0,r0,#0x80
000166  b140              CBZ      r0,|L27.378|
;;;585                  NewTime(TIME30MS-TIME20MS);
000168  f44f70c8          MOV      r0,#0x190
00016c  f7fffffe          BL       NewTime
;;;586                  SensD=SD_GENSI;
000170  2001              MOVS     r0,#1
000172  49a7              LDR      r1,|L27.1040|
000174  7008              STRB     r0,[r1,#0]
000176  e007              B        |L27.392|
                  |L27.376|
000178  e1eb              B        |L27.1362|
                  |L27.378|
;;;587                } else {                // Не генерирует синхроимпульсы
;;;588                  NewTime(TIME50MS-TIME20MS);  
00017a  f44f6096          MOV      r0,#0x4b0
00017e  f7fffffe          BL       NewTime
;;;589                  SensD=SD_INDEPEND;
000182  2002              MOVS     r0,#2
000184  49a2              LDR      r1,|L27.1040|
000186  7008              STRB     r0,[r1,#0]
                  |L27.392|
;;;590                }
;;;591                break;
000188  e01b              B        |L27.450|
                  |L27.394|
;;;592              case (SD_GENSI):
;;;593                SensState=SS_P8;
00018a  2028              MOVS     r0,#0x28
00018c  499f              LDR      r1,|L27.1036|
00018e  7008              STRB     r0,[r1,#0]
;;;594                SetOut(1);
000190  2001              MOVS     r0,#1
000192  f7fffffe          BL       SetOut
;;;595                AddTime(TIME4MS);
000196  20a0              MOVS     r0,#0xa0
000198  f7fffffe          BL       AddTime
;;;596                break;
00019c  e011              B        |L27.450|
                  |L27.414|
00019e  e092              B        |L27.710|
                  |L27.416|
0001a0  e066              B        |L27.624|
                  |L27.418|
0001a2  e014              B        |L27.462|
                  |L27.420|
0001a4  e1d4              B        |L27.1360|
                  |L27.422|
0001a6  e06c              B        |L27.642|
                  |L27.424|
0001a8  e074              B        |L27.660|
                  |L27.426|
0001aa  e16d              B        |L27.1160|
                  |L27.428|
;;;597    // Независимый режим
;;;598              case (SD_INDEPEND):
;;;599                Ni=0;
0001ac  2000              MOVS     r0,#0
0001ae  4999              LDR      r1,|L27.1044|
0001b0  7008              STRB     r0,[r1,#0]
;;;600                SelectND();
0001b2  f7fffffe          BL       SelectND
;;;601                EnableINT();
0001b6  f7fffffe          BL       EnableINT
;;;602                break;    
0001ba  e002              B        |L27.450|
                  |L27.444|
;;;603              default:            // Аварийная ветвь, сюда попадать не должно
;;;604                EnableINT();
0001bc  f7fffffe          BL       EnableINT
;;;605                break;
0001c0  bf00              NOP      
                  |L27.450|
0001c2  bf00              NOP                            ;575
;;;606            }
;;;607            break;
0001c4  e1c4              B        |L27.1360|
                  |L27.454|
0001c6  e148              B        |L27.1114|
                  |L27.456|
0001c8  e14d              B        |L27.1126|
                  |L27.458|
0001ca  e150              B        |L27.1134|
                  |L27.460|
0001cc  e17d              B        |L27.1226|
                  |L27.462|
;;;608    //
;;;609          case (SS_P1):
;;;610    // Переходим в П3
;;;611              SensState=SS_P3;
0001ce  2023              MOVS     r0,#0x23
0001d0  498e              LDR      r1,|L27.1036|
0001d2  7008              STRB     r0,[r1,#0]
;;;612              AddTime(TIME_TOP3);
0001d4  2008              MOVS     r0,#8
0001d6  f7fffffe          BL       AddTime
;;;613    // Стартовый бит
;;;614              currdbuf=RdBufPointerHead+1;           
0001da  4893              LDR      r0,|L27.1064|
0001dc  6800              LDR      r0,[r0,#0]  ; RdBufPointerHead
0001de  1c40              ADDS     r0,r0,#1
0001e0  4992              LDR      r1,|L27.1068|
0001e2  6008              STR      r0,[r1,#0]  ; currdbuf
;;;615              if (currdbuf>=(RdBuffer+BUFFERS_LENGTH)) {
0001e4  4608              MOV      r0,r1
0001e6  6801              LDR      r1,[r0,#0]  ; currdbuf
0001e8  4891              LDR      r0,|L27.1072|
0001ea  4281              CMP      r1,r0
0001ec  d305              BCC      |L27.506|
;;;616    // Да, нужно переместиться в начало буфера
;;;617                currdbuf-=BUFFERS_LENGTH;
0001ee  488f              LDR      r0,|L27.1068|
0001f0  6800              LDR      r0,[r0,#0]  ; currdbuf
0001f2  f5a07080          SUB      r0,r0,#0x100
0001f6  498d              LDR      r1,|L27.1068|
0001f8  6008              STR      r0,[r1,#0]  ; currdbuf
                  |L27.506|
;;;618              }
;;;619              if (currdbuf==RdBufPointerTail) {
0001fa  488c              LDR      r0,|L27.1068|
0001fc  6800              LDR      r0,[r0,#0]  ; currdbuf
0001fe  498d              LDR      r1,|L27.1076|
000200  6809              LDR      r1,[r1,#0]  ; RdBufPointerTail
000202  4288              CMP      r0,r1
000204  d106              BNE      |L27.532|
;;;620                SensConfig|=EMPTYRX; 
000206  4886              LDR      r0,|L27.1056|
000208  7800              LDRB     r0,[r0,#0]  ; SensConfig
00020a  f0400040          ORR      r0,r0,#0x40
00020e  4984              LDR      r1,|L27.1056|
000210  7008              STRB     r0,[r1,#0]
000212  e008              B        |L27.550|
                  |L27.532|
;;;621              } else {
;;;622                bytecnt=0;
000214  2000              MOVS     r0,#0
000216  4988              LDR      r1,|L27.1080|
000218  7008              STRB     r0,[r1,#0]
;;;623                SensConfig&=~EMPTYRX; 
00021a  4881              LDR      r0,|L27.1056|
00021c  7800              LDRB     r0,[r0,#0]  ; SensConfig
00021e  f0200040          BIC      r0,r0,#0x40
000222  497f              LDR      r1,|L27.1056|
000224  7008              STRB     r0,[r1,#0]
                  |L27.550|
;;;624              }
;;;625              crc=0;
000226  2000              MOVS     r0,#0
000228  4984              LDR      r1,|L27.1084|
00022a  7008              STRB     r0,[r1,#0]
;;;626              curbit=1;
00022c  2001              MOVS     r0,#1
00022e  4984              LDR      r1,|L27.1088|
000230  7008              STRB     r0,[r1,#0]
;;;627              ZZZ=(GetInput()?1:0);
000232  f7fffffe          BL       GetInput
000236  b108              CBZ      r0,|L27.572|
000238  2001              MOVS     r0,#1
00023a  e000              B        |L27.574|
                  |L27.572|
00023c  2000              MOVS     r0,#0
                  |L27.574|
00023e  4981              LDR      r1,|L27.1092|
000240  7008              STRB     r0,[r1,#0]
;;;628            break;
000242  e185              B        |L27.1360|
                  |L27.580|
;;;629    // 
;;;630          case (SS_P2):
;;;631            ZZZ<<=1;
000244  487f              LDR      r0,|L27.1092|
000246  7800              LDRB     r0,[r0,#0]  ; ZZZ
000248  0640              LSLS     r0,r0,#25
00024a  0e00              LSRS     r0,r0,#24
00024c  497d              LDR      r1,|L27.1092|
00024e  7008              STRB     r0,[r1,#0]
;;;632            if (GetInput()) ZZZ|=1;
000250  f7fffffe          BL       GetInput
000254  b128              CBZ      r0,|L27.610|
000256  487b              LDR      r0,|L27.1092|
000258  7800              LDRB     r0,[r0,#0]  ; ZZZ
00025a  f0400001          ORR      r0,r0,#1
00025e  4979              LDR      r1,|L27.1092|
000260  7008              STRB     r0,[r1,#0]
                  |L27.610|
;;;633            SensState=SS_P3;
000262  2023              MOVS     r0,#0x23
000264  4969              LDR      r1,|L27.1036|
000266  7008              STRB     r0,[r1,#0]
;;;634            AddTime(TIME_TOP3);
000268  2008              MOVS     r0,#8
00026a  f7fffffe          BL       AddTime
;;;635            break;
00026e  e16f              B        |L27.1360|
                  |L27.624|
;;;636    //
;;;637          case (SS_P3):
;;;638            SensState=SS_P4;
000270  2024              MOVS     r0,#0x24
000272  4966              LDR      r1,|L27.1036|
000274  7008              STRB     r0,[r1,#0]
;;;639            EnableINT();
000276  f7fffffe          BL       EnableINT
;;;640            AddTime(TIME_WAITSYNC);
00027a  201c              MOVS     r0,#0x1c
00027c  f7fffffe          BL       AddTime
;;;641            break;
000280  e166              B        |L27.1360|
                  |L27.642|
;;;642    //
;;;643          case (SS_P4):
;;;644            SensState=SS_CHZZZ;
000282  2030              MOVS     r0,#0x30
000284  4961              LDR      r1,|L27.1036|
000286  7008              STRB     r0,[r1,#0]
;;;645            DisableINT();
000288  f7fffffe          BL       DisableINT
;;;646            AddTime(TIME0_25MS);
00028c  200a              MOVS     r0,#0xa
00028e  f7fffffe          BL       AddTime
;;;647            break;
000292  e15d              B        |L27.1360|
                  |L27.660|
;;;648    //
;;;649          case (SS_P7):
;;;650            SetOut(1);
000294  2001              MOVS     r0,#1
000296  f7fffffe          BL       SetOut
;;;651            AddTime(TIME1_5MS);
00029a  203c              MOVS     r0,#0x3c
00029c  f7fffffe          BL       AddTime
;;;652            DisableINT();
0002a0  f7fffffe          BL       DisableINT
;;;653            SensState=SS_P8;
0002a4  2028              MOVS     r0,#0x28
0002a6  4959              LDR      r1,|L27.1036|
0002a8  7008              STRB     r0,[r1,#0]
;;;654            break;
0002aa  e151              B        |L27.1360|
                  |L27.684|
;;;655    //
;;;656          case (SS_P8):
;;;657            EnableINT();
0002ac  f7fffffe          BL       EnableINT
;;;658            SensState=SS_SYNC;
0002b0  2040              MOVS     r0,#0x40
0002b2  4956              LDR      r1,|L27.1036|
0002b4  7008              STRB     r0,[r1,#0]
;;;659            SetOut(0);
0002b6  2000              MOVS     r0,#0
0002b8  f7fffffe          BL       SetOut
;;;660            NewTime(TIME20MS);
0002bc  f44f7048          MOV      r0,#0x320
0002c0  f7fffffe          BL       NewTime
;;;661            break;
0002c4  e144              B        |L27.1360|
                  |L27.710|
;;;662    //
;;;663          case (SS_CHZZZ):        // Обработка полученных полубайтов
;;;664            ZZZ<<=1;
0002c6  485f              LDR      r0,|L27.1092|
0002c8  7800              LDRB     r0,[r0,#0]  ; ZZZ
0002ca  0640              LSLS     r0,r0,#25
0002cc  0e00              LSRS     r0,r0,#24
0002ce  495d              LDR      r1,|L27.1092|
0002d0  7008              STRB     r0,[r1,#0]
;;;665            if (GetInput()) ZZZ|=1;
0002d2  f7fffffe          BL       GetInput
0002d6  b128              CBZ      r0,|L27.740|
0002d8  485a              LDR      r0,|L27.1092|
0002da  7800              LDRB     r0,[r0,#0]  ; ZZZ
0002dc  f0400001          ORR      r0,r0,#1
0002e0  4958              LDR      r1,|L27.1092|
0002e2  7008              STRB     r0,[r1,#0]
                  |L27.740|
;;;666            switch (ZZZ&3) {
0002e4  4857              LDR      r0,|L27.1092|
0002e6  7800              LDRB     r0,[r0,#0]  ; ZZZ
0002e8  f0000003          AND      r0,r0,#3
0002ec  b130              CBZ      r0,|L27.764|
0002ee  2801              CMP      r0,#1
0002f0  d007              BEQ      |L27.770|
0002f2  2802              CMP      r0,#2
0002f4  d006              BEQ      |L27.772|
0002f6  2803              CMP      r0,#3
0002f8  d102              BNE      |L27.768|
0002fa  e055              B        |L27.936|
                  |L27.764|
;;;667              case (0):           // Двойной ноль - ошибка или СИ
;;;668                CheckZZZ();
0002fc  f7fffffe          BL       CheckZZZ
                  |L27.768|
;;;669                break;
000300  e0a9              B        |L27.1110|
                  |L27.770|
;;;670    // Прием очередного бита
;;;671              case (1):
;;;672              case (2):
000302  bf00              NOP      
                  |L27.772|
;;;673                curbyte<<=1;
000304  4850              LDR      r0,|L27.1096|
000306  7800              LDRB     r0,[r0,#0]  ; curbyte
000308  0640              LSLS     r0,r0,#25
00030a  0e00              LSRS     r0,r0,#24
00030c  494e              LDR      r1,|L27.1096|
00030e  7008              STRB     r0,[r1,#0]
;;;674                if (ZZZ&1) curbyte|=1;
000310  484c              LDR      r0,|L27.1092|
000312  7800              LDRB     r0,[r0,#0]  ; ZZZ
000314  f0000001          AND      r0,r0,#1
000318  b120              CBZ      r0,|L27.804|
00031a  4608              MOV      r0,r1
00031c  7800              LDRB     r0,[r0,#0]  ; curbyte
00031e  f0400001          ORR      r0,r0,#1
000322  7008              STRB     r0,[r1,#0]
                  |L27.804|
;;;675                curbit<<=1;
000324  4846              LDR      r0,|L27.1088|
000326  7800              LDRB     r0,[r0,#0]  ; curbit
000328  0640              LSLS     r0,r0,#25
00032a  0e00              LSRS     r0,r0,#24
00032c  4944              LDR      r1,|L27.1088|
00032e  7008              STRB     r0,[r1,#0]
;;;676                if (!curbit) {
000330  4608              MOV      r0,r1
000332  7800              LDRB     r0,[r0,#0]  ; curbit
000334  bb88              CBNZ     r0,|L27.922|
;;;677                  curbit=1;
000336  2001              MOVS     r0,#1
000338  7008              STRB     r0,[r1,#0]
;;;678                  if (currdbuf==RdBufPointerTail) SensConfig|=EMPTYRX;
00033a  483c              LDR      r0,|L27.1068|
00033c  6800              LDR      r0,[r0,#0]  ; currdbuf
00033e  493d              LDR      r1,|L27.1076|
000340  6809              LDR      r1,[r1,#0]  ; RdBufPointerTail
000342  4288              CMP      r0,r1
000344  d105              BNE      |L27.850|
000346  4836              LDR      r0,|L27.1056|
000348  7800              LDRB     r0,[r0,#0]  ; SensConfig
00034a  f0400040          ORR      r0,r0,#0x40
00034e  4934              LDR      r1,|L27.1056|
000350  7008              STRB     r0,[r1,#0]
                  |L27.850|
;;;679                  if (!(SensConfig&EMPTYRX)) {
000352  4833              LDR      r0,|L27.1056|
000354  7800              LDRB     r0,[r0,#0]  ; SensConfig
000356  f0000040          AND      r0,r0,#0x40
00035a  b9f0              CBNZ     r0,|L27.922|
;;;680                    *(currdbuf++)=curbyte;
00035c  483a              LDR      r0,|L27.1096|
00035e  7800              LDRB     r0,[r0,#0]  ; curbyte
000360  4932              LDR      r1,|L27.1068|
000362  6809              LDR      r1,[r1,#0]  ; currdbuf
000364  7008              STRB     r0,[r1,#0]
000366  4831              LDR      r0,|L27.1068|
000368  6800              LDR      r0,[r0,#0]  ; currdbuf
00036a  1c40              ADDS     r0,r0,#1
00036c  492f              LDR      r1,|L27.1068|
00036e  6008              STR      r0,[r1,#0]  ; currdbuf
;;;681                    if (currdbuf==(RdBuffer+BUFFERS_LENGTH)) currdbuf=RdBuffer;
000370  4608              MOV      r0,r1
000372  6801              LDR      r1,[r0,#0]  ; currdbuf
000374  482e              LDR      r0,|L27.1072|
000376  4281              CMP      r1,r0
000378  d103              BNE      |L27.898|
00037a  f5a07080          SUB      r0,r0,#0x100
00037e  492b              LDR      r1,|L27.1068|
000380  6008              STR      r0,[r1,#0]  ; currdbuf
                  |L27.898|
;;;682                    crc+=curbyte;
000382  482e              LDR      r0,|L27.1084|
000384  7800              LDRB     r0,[r0,#0]  ; crc
000386  4930              LDR      r1,|L27.1096|
000388  7809              LDRB     r1,[r1,#0]  ; curbyte
00038a  4408              ADD      r0,r0,r1
00038c  492b              LDR      r1,|L27.1084|
00038e  7008              STRB     r0,[r1,#0]
;;;683                    bytecnt++;
000390  4829              LDR      r0,|L27.1080|
000392  7800              LDRB     r0,[r0,#0]  ; bytecnt
000394  1c40              ADDS     r0,r0,#1
000396  4928              LDR      r1,|L27.1080|
000398  7008              STRB     r0,[r1,#0]
                  |L27.922|
;;;684                  }
;;;685                }
;;;686    // Возврат в точку начала приема очередного бита
;;;687                AddTime(TIME1MS);
00039a  2028              MOVS     r0,#0x28
00039c  f7fffffe          BL       AddTime
;;;688                SensState=SS_P2;
0003a0  2022              MOVS     r0,#0x22
0003a2  491a              LDR      r1,|L27.1036|
0003a4  7008              STRB     r0,[r1,#0]
;;;689                break;
0003a6  e056              B        |L27.1110|
                  |L27.936|
;;;690              case (3):           // Принята стоповая комбинация
;;;691                if ((curbit==0x20)&&(curbyte&1)&&!(SensConfig&EMPTYRX)) {
0003a8  4825              LDR      r0,|L27.1088|
0003aa  7800              LDRB     r0,[r0,#0]  ; curbit
0003ac  2820              CMP      r0,#0x20
0003ae  d128              BNE      |L27.1026|
0003b0  4825              LDR      r0,|L27.1096|
0003b2  7800              LDRB     r0,[r0,#0]  ; curbyte
0003b4  f0000001          AND      r0,r0,#1
0003b8  b318              CBZ      r0,|L27.1026|
0003ba  4819              LDR      r0,|L27.1056|
0003bc  7800              LDRB     r0,[r0,#0]  ; SensConfig
0003be  f0000040          AND      r0,r0,#0x40
0003c2  b9f0              CBNZ     r0,|L27.1026|
;;;692    // Длина пакета разумная
;;;693                  curbyte>>=1;
0003c4  4820              LDR      r0,|L27.1096|
0003c6  7800              LDRB     r0,[r0,#0]  ; curbyte
0003c8  1040              ASRS     r0,r0,#1
0003ca  491f              LDR      r1,|L27.1096|
0003cc  7008              STRB     r0,[r1,#0]
;;;694                  crc=(crc+(crc>>4))&0x0F;
0003ce  481b              LDR      r0,|L27.1084|
0003d0  7800              LDRB     r0,[r0,#0]  ; crc
0003d2  491a              LDR      r1,|L27.1084|
0003d4  7809              LDRB     r1,[r1,#0]  ; crc
0003d6  eb001021          ADD      r0,r0,r1,ASR #4
0003da  f000000f          AND      r0,r0,#0xf
0003de  4917              LDR      r1,|L27.1084|
0003e0  7008              STRB     r0,[r1,#0]
;;;695                  if ((curbyte&0x0F)==crc) {
0003e2  4819              LDR      r0,|L27.1096|
0003e4  7800              LDRB     r0,[r0,#0]  ; curbyte
0003e6  f000000f          AND      r0,r0,#0xf
0003ea  7809              LDRB     r1,[r1,#0]  ; crc
0003ec  4288              CMP      r0,r1
0003ee  d108              BNE      |L27.1026|
;;;696    // Пакет верный
;;;697                    *RdBufPointerHead=bytecnt;
0003f0  4811              LDR      r0,|L27.1080|
0003f2  7800              LDRB     r0,[r0,#0]  ; bytecnt
0003f4  490c              LDR      r1,|L27.1064|
0003f6  6809              LDR      r1,[r1,#0]  ; RdBufPointerHead
0003f8  7008              STRB     r0,[r1,#0]
;;;698                    RdBufPointerHead=currdbuf;
0003fa  480c              LDR      r0,|L27.1068|
0003fc  6800              LDR      r0,[r0,#0]  ; currdbuf
0003fe  490a              LDR      r1,|L27.1064|
000400  6008              STR      r0,[r1,#0]  ; RdBufPointerHead
                  |L27.1026|
;;;699                  }
;;;700                }
;;;701    // Возвращаемся к ожиданию действия
;;;702                AddTime((uint16_t)(-TIME2_5MS));
000402  f64f709c          MOV      r0,#0xff9c
000406  e021              B        |L27.1100|
                  |L27.1032|
                          DCD      ssec
                  |L27.1036|
                          DCD      SensState
                  |L27.1040|
                          DCD      SensD
                  |L27.1044|
                          DCD      ||Ni||
                  |L27.1048|
                          DCD      BSPointer
                  |L27.1052|
                          DCD      curBSPointer
                  |L27.1056|
                          DCD      SensConfig
                  |L27.1060|
                          DCD      NCK
                  |L27.1064|
                          DCD      RdBufPointerHead
                  |L27.1068|
                          DCD      currdbuf
                  |L27.1072|
                          DCD      RdBuffer+0x100
                  |L27.1076|
                          DCD      RdBufPointerTail
                  |L27.1080|
                          DCD      bytecnt
                  |L27.1084|
                          DCD      ||crc||
                  |L27.1088|
                          DCD      curbit
                  |L27.1092|
                          DCD      ZZZ
                  |L27.1096|
                          DCD      curbyte
                  |L27.1100|
00044c  f7fffffe          BL       AddTime
;;;703                SelectND();
000450  f7fffffe          BL       SelectND
;;;704                break;
000454  bf00              NOP      
                  |L27.1110|
000456  bf00              NOP                            ;669
;;;705            }
;;;706            break;
000458  e07a              B        |L27.1360|
                  |L27.1114|
;;;707          case (SS_SYNC):
;;;708            Ni=0;
00045a  2000              MOVS     r0,#0
00045c  493d              LDR      r1,|L27.1364|
00045e  7008              STRB     r0,[r1,#0]
;;;709            SelectND();
000460  f7fffffe          BL       SelectND
;;;710            break;
000464  e074              B        |L27.1360|
                  |L27.1126|
;;;711    /////////////////////////////////////////////////// Передающая часть
;;;712          case (SS_PP1):
;;;713            ZZZ=0x06;
000466  2006              MOVS     r0,#6
000468  493b              LDR      r1,|L27.1368|
00046a  7008              STRB     r0,[r1,#0]
;;;714          case (SS_PP4):
00046c  bf00              NOP      
                  |L27.1134|
;;;715            NextBit();
00046e  f7fffffe          BL       NextBit
;;;716            break;
000472  e06d              B        |L27.1360|
                  |L27.1140|
;;;717          case (SS_PP2):
;;;718            SetOut(0);
000474  2000              MOVS     r0,#0
000476  f7fffffe          BL       SetOut
;;;719            AddTime(TIME0_5MS);
00047a  2014              MOVS     r0,#0x14
00047c  f7fffffe          BL       AddTime
;;;720            SensState=SS_PP3;
000480  2053              MOVS     r0,#0x53
000482  4936              LDR      r1,|L27.1372|
000484  7008              STRB     r0,[r1,#0]
;;;721            break;   
000486  e063              B        |L27.1360|
                  |L27.1160|
;;;722          case (SS_PP3):
;;;723            if (GetInput()) {
000488  f7fffffe          BL       GetInput
00048c  b188              CBZ      r0,|L27.1202|
;;;724              ZZZ<<=1;
00048e  4832              LDR      r0,|L27.1368|
000490  7800              LDRB     r0,[r0,#0]  ; ZZZ
000492  0640              LSLS     r0,r0,#25
000494  0e00              LSRS     r0,r0,#24
000496  4930              LDR      r1,|L27.1368|
000498  7008              STRB     r0,[r1,#0]
;;;725              ZZZ|=0x01;
00049a  4608              MOV      r0,r1
00049c  7800              LDRB     r0,[r0,#0]  ; ZZZ
00049e  f0400001          ORR      r0,r0,#1
0004a2  7008              STRB     r0,[r1,#0]
;;;726              SensState=SS_PP4;
0004a4  2054              MOVS     r0,#0x54
0004a6  492d              LDR      r1,|L27.1372|
0004a8  7008              STRB     r0,[r1,#0]
;;;727              AddTime(TIME0_5MS);
0004aa  2014              MOVS     r0,#0x14
0004ac  f7fffffe          BL       AddTime
0004b0  e00a              B        |L27.1224|
                  |L27.1202|
;;;728            } else {
;;;729    // Ошибочка
;;;730              RemovePkg(1);
0004b2  2001              MOVS     r0,#1
0004b4  f7fffffe          BL       RemovePkg
;;;731              ZZZ<<=1;
0004b8  4827              LDR      r0,|L27.1368|
0004ba  7800              LDRB     r0,[r0,#0]  ; ZZZ
0004bc  0640              LSLS     r0,r0,#25
0004be  0e00              LSRS     r0,r0,#24
0004c0  4925              LDR      r1,|L27.1368|
0004c2  7008              STRB     r0,[r1,#0]
;;;732              CheckZZZ();
0004c4  f7fffffe          BL       CheckZZZ
                  |L27.1224|
;;;733            }     
;;;734            break;
0004c8  e042              B        |L27.1360|
                  |L27.1226|
;;;735          case (SS_PP5):
;;;736            if (GetInput()) {
0004ca  f7fffffe          BL       GetInput
0004ce  b188              CBZ      r0,|L27.1268|
;;;737              ZZZ<<=1;
0004d0  4821              LDR      r0,|L27.1368|
0004d2  7800              LDRB     r0,[r0,#0]  ; ZZZ
0004d4  0640              LSLS     r0,r0,#25
0004d6  0e00              LSRS     r0,r0,#24
0004d8  491f              LDR      r1,|L27.1368|
0004da  7008              STRB     r0,[r1,#0]
;;;738              ZZZ|=0x01;
0004dc  4608              MOV      r0,r1
0004de  7800              LDRB     r0,[r0,#0]  ; ZZZ
0004e0  f0400001          ORR      r0,r0,#1
0004e4  7008              STRB     r0,[r1,#0]
;;;739              SensState=SS_PP6;
0004e6  2056              MOVS     r0,#0x56
0004e8  491c              LDR      r1,|L27.1372|
0004ea  7008              STRB     r0,[r1,#0]
;;;740              AddTime(TIME0_5MS);
0004ec  2014              MOVS     r0,#0x14
0004ee  f7fffffe          BL       AddTime
0004f2  e01c              B        |L27.1326|
                  |L27.1268|
;;;741            } else {
;;;742              ZZZ<<=1;
0004f4  4818              LDR      r0,|L27.1368|
0004f6  7800              LDRB     r0,[r0,#0]  ; ZZZ
0004f8  0640              LSLS     r0,r0,#25
0004fa  0e00              LSRS     r0,r0,#24
0004fc  4916              LDR      r1,|L27.1368|
0004fe  7008              STRB     r0,[r1,#0]
;;;743    // Текущий квант д.б. 1 а он 0
;;;744    // Это первый квант бита, поэтому предыдущие два кванта могут быть 01 или 10, но не 00
;;;745    // Поэтому перехода в поддержку СИ быть не может
;;;746    // Нужно только выбрать время T
;;;747              if (ZZZ&2) {
000500  4608              MOV      r0,r1
000502  7800              LDRB     r0,[r0,#0]  ; ZZZ
000504  f0000002          AND      r0,r0,#2
000508  b118              CBZ      r0,|L27.1298|
;;;748    // Прошло 500 мс нуля
;;;749                AddTime(TIME2MS);
00050a  2050              MOVS     r0,#0x50
00050c  f7fffffe          BL       AddTime
000510  e002              B        |L27.1304|
                  |L27.1298|
;;;750              } else {
;;;751    // Прошло 1500 мс нуля
;;;752                AddTime(TIME1MS);
000512  2028              MOVS     r0,#0x28
000514  f7fffffe          BL       AddTime
                  |L27.1304|
;;;753              }
;;;754              RemovePkg(1);
000518  2001              MOVS     r0,#1
00051a  f7fffffe          BL       RemovePkg
;;;755              SensState=SS_P7;
00051e  2027              MOVS     r0,#0x27
000520  490e              LDR      r1,|L27.1372|
000522  7008              STRB     r0,[r1,#0]
;;;756              EnableINT();          
000524  f7fffffe          BL       EnableINT
;;;757              SetOut(0);
000528  2000              MOVS     r0,#0
00052a  f7fffffe          BL       SetOut
                  |L27.1326|
;;;758            }     
;;;759            break;
00052e  e00f              B        |L27.1360|
                  |L27.1328|
;;;760          case (SS_PP6):
;;;761            SetOut(1);
000530  2001              MOVS     r0,#1
000532  f7fffffe          BL       SetOut
;;;762            ZZZ<<=1;
000536  4808              LDR      r0,|L27.1368|
000538  7800              LDRB     r0,[r0,#0]  ; ZZZ
00053a  0640              LSLS     r0,r0,#25
00053c  0e00              LSRS     r0,r0,#24
00053e  4906              LDR      r1,|L27.1368|
000540  7008              STRB     r0,[r1,#0]
;;;763            SensState=SS_PP4;
000542  2054              MOVS     r0,#0x54
000544  4905              LDR      r1,|L27.1372|
000546  7008              STRB     r0,[r1,#0]
;;;764            AddTime(TIME1MS);
000548  2028              MOVS     r0,#0x28
00054a  f7fffffe          BL       AddTime
;;;765            break;
00054e  bf00              NOP      
                  |L27.1360|
000550  bf00              NOP                            ;607
                  |L27.1362|
;;;766        }
;;;767      }
;;;768    };
000552  bd10              POP      {r4,pc}
;;;769    
                          ENDP

                  |L27.1364|
                          DCD      ||Ni||
                  |L27.1368|
                          DCD      ZZZ
                  |L27.1372|
                          DCD      SensState

                          AREA ||i.UnblockST||, CODE, READONLY, ALIGN=2

                  UnblockST PROC
;;;883    // Разблокирует передачу байтов состояния
;;;884    void UnblockST(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;885    // Пересчитываем адреса и паузы
;;;886      volatile uint8_t * bsp;
;;;887      uint8_t adr,ni,ps;
;;;888      bsp=BSPointer;
000002  4c14              LDR      r4,|L28.84|
000004  6820              LDR      r0,[r4,#0]  ; BSPointer
;;;889      if (bsp) {
000006  b1d8              CBZ      r0,|L28.64|
;;;890        for (;;) {
000008  bf00              NOP      
                  |L28.10|
;;;891          adr=*(bsp+3);
00000a  78c1              LDRB     r1,[r0,#3]
;;;892          if (adr) {
00000c  b179              CBZ      r1,|L28.46|
;;;893            ni=(adr-1)%31+1;
00000e  1e4c              SUBS     r4,r1,#1
000010  251f              MOVS     r5,#0x1f
000012  fb94f6f5          SDIV     r6,r4,r5
000016  fb054416          MLS      r4,r5,r6,r4
00001a  1c64              ADDS     r4,r4,#1
00001c  b2e2              UXTB     r2,r4
;;;894            ps=(adr-1)/31+4;
00001e  1e4c              SUBS     r4,r1,#1
000020  fb94f4f5          SDIV     r4,r4,r5
000024  1d24              ADDS     r4,r4,#4
000026  b2e3              UXTB     r3,r4
;;;895            *bsp=ni;
000028  7002              STRB     r2,[r0,#0]
;;;896            *(bsp+1)=ps;
00002a  7043              STRB     r3,[r0,#1]
00002c  e003              B        |L28.54|
                  |L28.46|
;;;897          } else {
;;;898            *bsp=0;
00002e  2400              MOVS     r4,#0
000030  7004              STRB     r4,[r0,#0]
;;;899            *(bsp+1)=0;
000032  7044              STRB     r4,[r0,#1]
;;;900            break;
000034  e003              B        |L28.62|
                  |L28.54|
;;;901          }
;;;902          bsp+=(*(bsp+2)+3);
000036  7884              LDRB     r4,[r0,#2]
000038  1ce4              ADDS     r4,r4,#3
00003a  4420              ADD      r0,r0,r4
00003c  e7e5              B        |L28.10|
                  |L28.62|
00003e  bf00              NOP                            ;900
                  |L28.64|
;;;903        }
;;;904      }
;;;905      IN_CRITICAL();
000040  b672              CPSID    i
;;;906      SensConfig&=~NOPS;
000042  4c05              LDR      r4,|L28.88|
000044  7824              LDRB     r4,[r4,#0]  ; SensConfig
000046  f0240404          BIC      r4,r4,#4
00004a  4d03              LDR      r5,|L28.88|
00004c  702c              STRB     r4,[r5,#0]
;;;907      OUT_CRITICAL();
00004e  b662              CPSIE    i
;;;908    }
000050  bd70              POP      {r4-r6,pc}
;;;909    
                          ENDP

000052  0000              DCW      0x0000
                  |L28.84|
                          DCD      BSPointer
                  |L28.88|
                          DCD      SensConfig

                          AREA ||i.getssec||, CODE, READONLY, ALIGN=2

                  getssec PROC
;;;368    // Функции работы со временем
;;;369    uint32_t getssec() {
000000  b672              CPSID    i
;;;370      uint32_t rez;
;;;371      IN_CRITICAL();
;;;372      rez=ssec;
000002  4902              LDR      r1,|L29.12|
000004  6808              LDR      r0,[r1,#0]  ; ssec
;;;373      OUT_CRITICAL();
000006  b662              CPSIE    i
;;;374      return rez;
;;;375    };      
000008  4770              BX       lr
;;;376    
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      ssec

                          AREA ||i.tdlt||, CODE, READONLY, ALIGN=2

                  tdlt PROC
;;;386    // Разница веремн
;;;387    uint32_t tdlt(uint32_t time) {
000000  4601              MOV      r1,r0
;;;388      uint32_t t;
;;;389      IN_CRITICAL();
000002  b672              CPSID    i
;;;390      t=ssec;
000004  4804              LDR      r0,|L30.24|
000006  6802              LDR      r2,[r0,#0]  ; ssec
;;;391      OUT_CRITICAL();
000008  b662              CPSIE    i
;;;392      if (time>t) {
00000a  4291              CMP      r1,r2
00000c  d902              BLS      |L30.20|
;;;393        return (~time)+t;
00000e  43c8              MVNS     r0,r1
000010  4410              ADD      r0,r0,r2
                  |L30.18|
;;;394      } else return (t-time);
;;;395    }
000012  4770              BX       lr
                  |L30.20|
000014  1a50              SUBS     r0,r2,r1              ;394
000016  e7fc              B        |L30.18|
;;;396    
                          ENDP

                  |L30.24|
                          DCD      ssec

                          AREA ||i.zgetssec||, CODE, READONLY, ALIGN=2

                  zgetssec PROC
;;;376    
;;;377    uint32_t zgetssec() {
000000  b672              CPSID    i
;;;378      uint32_t rez;
;;;379      IN_CRITICAL();
;;;380      rez=ssec;
000002  4903              LDR      r1,|L31.16|
000004  6808              LDR      r0,[r1,#0]  ; ssec
;;;381      OUT_CRITICAL();
000006  b662              CPSIE    i
;;;382      if (rez==0) rez--;
000008  b900              CBNZ     r0,|L31.12|
00000a  1e40              SUBS     r0,r0,#1
                  |L31.12|
;;;383      return rez;
;;;384    };      
00000c  4770              BX       lr
;;;385    
                          ENDP

00000e  0000              DCW      0x0000
                  |L31.16|
                          DCD      ssec

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  TrBuffer
                          %        256
                  RdBuffer
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CHANNEL_OFFSET_TAB
000000  081c3044          DCB      0x08,0x1c,0x30,0x44
000004  586c80            DCB      0x58,0x6c,0x80
                  OFFSET_TAB_CCMRx
000007  00                DCB      0x00
000008  00000004          DCB      0x00,0x00,0x00,0x04
00000c  04043c3c          DCB      0x04,0x04,0x3c,0x3c
                  SHIFT_TAB_OCxx
000010  00000800          DCB      0x00,0x00,0x08,0x00
000014  00000800          DCB      0x00,0x00,0x08,0x00
000018  08                DCB      0x08
                  SHIFT_TAB_ICxx
000019  000008            DCB      0x00,0x00,0x08
00001c  00000008          DCB      0x00,0x00,0x00,0x08
000020  0000              DCB      0x00,0x00
                  SHIFT_TAB_CCxP
000022  0002              DCB      0x00,0x02
000024  0406080a          DCB      0x04,0x06,0x08,0x0a
000028  0c1014            DCB      0x0c,0x10,0x14
                  SHIFT_TAB_OISx
00002b  00                DCB      0x00
00002c  01020304          DCB      0x01,0x02,0x03,0x04
000030  0506080a          DCB      0x05,0x06,0x08,0x0a

                          AREA ||.data||, DATA, ALIGN=2

                  SensState
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ssec
                          DCD      0x00000000
                  SensD
000008  00                DCB      0x00
                  SensConfig
000009  00                DCB      0x00
                  ||Ni||
00000a  00                DCB      0x00
                  NCK
00000b  00                DCB      0x00
                  BSPointer
                          DCD      0x00000000
                  curBSPointer
                          DCD      0x00000000
                  TrBufPointerTail
                          DCD      TrBuffer
                  TrBufPointerHead
                          DCD      TrBuffer
                  curtrbuf
                          DCD      0x00000000
                  curnum
000020  00                DCB      0x00
                  trnum
000021  00                DCB      0x00
                  ||crc||
000022  00                DCB      0x00
                  curbyte
000023  00                DCB      0x00
                  curbit
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  currdbuf
                          DCD      0x00000000
                  ZZZ
00002c  00                DCB      0x00
                  bytecnt
00002d  000000            DCB      0x00,0x00,0x00
                  RdBufPointerTail
                          DCD      RdBuffer
                  RdBufPointerHead
                          DCD      RdBuffer

;*** Start embedded assembler ***

#line 1 "Source\\Line\\src\\sensline.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_sensline_c_c79285f7____REV16|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___10_sensline_c_c79285f7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_sensline_c_c79285f7____REVSH|
#line 402
|__asm___10_sensline_c_c79285f7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_sensline_c_c79285f7____RRX|
#line 587
|__asm___10_sensline_c_c79285f7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
