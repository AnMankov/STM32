L 1 "Source\Ext_Dev\src\AT45\AT45DB321D_driver_hl.cpp"
N#include <algorithm>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\algorithm" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * algorithm - declarations and inline definitions of the Standard
N *              Library algorithms
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ALGORITHM_INCLUDED
N#define _RWSTD_ALGORITHM_INCLUDED
N
N#include <memory>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * memory - declarations for the Standard Library memory implementation
N *
N * $Id$ 
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/ 
N
N#ifndef _RWSTD_MEMORY_INCLUDED
N#define _RWSTD_MEMORY_INCLUDED
N
N#include <new>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 1
N/*
N * C++ Library file new
N * Copyright 1993-2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N/* Edison Design Group, 1992-2013. */
N/*
Nnew -- Include file for C++ default operator new (see ARM 12.5).
N*/
N
N#ifndef __NEW_STDH
N#define __NEW_STDH
N#ifndef __STDDEF_H
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS ::std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 201112L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::ptrdiff_t;
N      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X      #if !0L || (1L && 201103L <= 201103L)
N        using ::std::max_align_t;
N      #endif
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 21 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif  /* ifndef __STDDEF_H */
N#ifndef __NEW
N#define __NEW
N#define __ARMCLIB_VERSION 5060019
N
N#ifndef __EXCEPTION_INCLUDED
N#include <exception>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\exception" 1
N/*
N * C++ Library file exception
N * Copyright 2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __EXCEPTION_INCLUDED
N#define __EXCEPTION_INCLUDED
N#define __ARMCLIB_VERSION 5060019
N
N/* Edison Design Group, 1995-2005. */
N/*
Nexception -- Include file for exception handling (see 18.6)
N*/
N
Nnamespace std {
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class exception {
N  public:
N    exception() throw();
N    exception(const exception&) throw();
N    exception& operator=(const exception&) throw();
N    virtual ~exception() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_exception : public exception {
N  public:
N    bad_exception() throw();
N    bad_exception(const bad_exception&) throw();
N    bad_exception& operator=(const bad_exception&) throw();
N    virtual ~bad_exception() throw();
N    virtual const char* what() const throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*terminate_handler)();
N  extern terminate_handler set_terminate(terminate_handler) throw();
N
N  typedef void (*unexpected_handler)();
N  extern unexpected_handler set_unexpected(unexpected_handler) throw();
N
N  void terminate();
N  void unexpected();
N
N  extern bool uncaught_exception() throw();
N
N}  /* namespace std */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __EXCEPTION_INCLUDED */
N
L 28 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif /* __EXCEPTION_INCLUDED */
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
Nnamespace std {
N#endif /* if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__ */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef unsigned long size_t;   /* see <stddef.h> */
N#else
N  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class bad_alloc : public exception {
N  public:
N    bad_alloc() throw();
N    bad_alloc(const bad_alloc&) throw();
N    bad_alloc& operator=(const bad_alloc&) throw();
N    virtual ~bad_alloc() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_array_new_length : public bad_alloc {
N  public:
N    bad_array_new_length() throw();
N    virtual ~bad_array_new_length() throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*new_handler)();
N  new_handler set_new_handler(new_handler) throw();
N  struct nothrow_t { };
N  // Declaration of object nothrow to permit the use of the placement new
N  // syntax: new (nothrow) T;
N  extern const nothrow_t nothrow;
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
N}  /* namespace std */
N#endif /* __EDG_RUNTIME_USES_NAMESPACES || __clang__ */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N/* Normal operator new. */
Nvoid *operator new(std::size_t) throw(std::bad_alloc);
N
N/* Normal operator delete. */
Nvoid operator delete(void*) throw ();
N
N/* Nothrow version of operator new. */
Nvoid *operator new(std::size_t, const std::nothrow_t&) throw();
N
N/* Nothrow version of operator delete. */
Nvoid operator delete(void*, const std::nothrow_t&) throw();
N
N/* Placement new. */
Ninline void *operator new(std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement delete. */
Ninline void operator delete(void*, void*) throw() { /* nothing */ }
N
N
N/* Array new. */
Nvoid *operator new[](std::size_t) throw(std::bad_alloc);
N
N/* Array delete. */
Nvoid operator delete[](void*) throw ();
N
N/* Placement array new. */
Ninline void *operator new[](std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement array delete. */
Ninline void operator delete[](void*, void*) throw() { /* nothing */ }
N
N/* Nothrow version of array new. */
Nvoid *operator new[](std::size_t,
N                     const std::nothrow_t&) throw();
N
N/* Nothrow version of array delete. */
Nvoid operator delete[](void*,
N                       const std::nothrow_t&) throw();
N
N#endif /*__NEW */
N/* End of new */
N
N#endif /*__NEW_STDH */
L 49 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <utility>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\utility" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * utility - Declarations for the Standard Library utility classes
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_UTILITY_INCLUDED
N#define _RWSTD_UTILITY_INCLUDED
N
N#include <rw/_defs.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 1
N/***************************************************************************
N *
N * _defs.h - Common macro definitions to be included by every library file
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_DEFS_H_INCLUDED
N#define _RWSTD_DEFS_H_INCLUDED
N
N#include <rw/_config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 1
N/***************************************************************************
N *
N * _config.h - Compiler and C library configuration definitions
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2000 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_CONFIG_H_INCLUDED
N#define _RWSTD_CONFIG_H_INCLUDED
N
N// Always use the auto-generated config file for ARM Compilers
N#include <rw/config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/config.h" 1
N/* Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved. */
N/* Copyright (c) 2002 ARM Ltd. All Rights Reserved.                        */
N#ifndef __RW_CONFIG_H_INCLUDED
N#define __RW_CONFIG_H_INCLUDED
N
N#define _RWSTD_NO_NATIVE_IO // Rogue Wave global config options
N#define _RWSTD_NO_CONST_FLT_ROUNDS // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_EXCEPTIONS // auto config
N#else
N#endif
N#define _RWSTD_NO_FILENO // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_FUNCTION_TRY_BLOCK // auto config
N#endif
N#define _RWSTD_NO_IEEEFP_H_REQUIRED // auto config
N#define _RWSTD_LLONG_PRINTF_PREFIX "ll"
N#define _RWSTD_NO_LRAND48 // auto config
N#define _RWSTD_NO_MATH_EXCEPTION // auto config
N#define _RWSTD_NO_MBSTATE_COMPARE // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_NEW_THROWS // auto config
N#else
N#endif
N#define _RWSTD_NO_NL_TYPES_H // auto config
N#define _RWSTD_NO_SSIZE_T // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_UNCAUGHT_EXCEPTION // auto config
N#else
N#endif
N#define _RWSTD_WINT_T int
N
N#endif /* __RW_CONFIG_H_INCLUDED */
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 2
N
N// Library version number
N// 
N#define _RWSTD_VER 0x02020300
N//                    | | | |
N//                   AABBCCDD
N//                    | | | |
N//                    | | | +--- DD = Point release or "patch" release. 
N//                    | | |      Left D-digit is reserved for alpha releases
N//                    | | |      and right D-digit for beta releases
N//                    | | |      
N//                    | | +----- CC = Maintenance number
N//                    | +------- BB = Minor Release number
N//                    +--------- AA = Major Release number
N
N/*********************************************************************
N *                OVERRIDES FOR CONFIGURATION MACROS                 *
N *********************************************************************/
N
N/********************** ARM armcc **************************************/
N
N/* If implicit includes are switched off, include the file.cc explicitly */
N#ifndef __IMPLICIT_INCLUDE
S#  define _RWSTD_COMPILE_INSTANTIATE
N#endif /* __IMPLICIT_INCLUDE */
N#if __TARGET_ARCH_AARCH64
S#  define _RWSTD_NO_LONG_DOUBLE 1
N#endif /* __TARGET_ARCH_AARCH64 */
N
N/********************** EDG eccp *************************************/
N
N// NOTE: the __EDG__ macro is #defined by most edg-based compilers
N
N#if defined (__EDG__) && !defined (__DECCXX)
X#if 1L && !0L
N#  define _RWSTD_NO_DEPRECATED_C_HEADERS
N#  undef _RWSTD_NO_NEW_HEADER
N#  undef _RWSTD_NO_LIBC_IN_STD
N
N#  ifdef _RWSTD_MULTI_THREAD
S     // std::uncaught_exception() not thread-safe
S     // in the vanilla front-end (demo)
S#    define _RWSTD_NO_UNCAUGHT_EXCEPTION
N#  endif   // _RWSTD_MULTI_THREAD
N#endif   // __EDG__
N
N/********************** gcc ******************************************/
N
N/* armcc supports __attribute__ */
N#define _RWSTD_GNUC_ATTRIBUTE(attr)   __attribute__ (attr)
N
N/********************** Threads ***************************************/
N
N#ifdef _RWSTD_DCE_THREADS
S#  define _RWSTD_NO_STATIC_MUTEX_INIT
N#endif   // _RWSTD_DCE_THREADS
N
N/********************** Miscellaneous *********************************/
N
N// g++ cannot inline functions that take a variable number of arguments
N// or functions that contain static (local) variables
N#if !defined (__GNUG__) || __GNUG__ > 2 || __GNUG_MINOR__ > 96
X#if !0L || __GNUG__ > 2 || __GNUG_MINOR__ > 96
N#  define _INLINE_VARARGS      inline
N#  if !defined (__HP_aCC) || __HP_aCC > 012100
X#  if !0L || __HP_aCC > 012100
N     // working around a known aCC 1.21 bug
N#    define _INLINE_WITH_STATICS inline
N#  endif   // !__HP_aCC || __HP_aCC > 012100
N#endif   // !__GNUG__ || __GNUG__ > 2 || __GNUG_MINOR__ > 96
N
N#ifdef _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
S   // static mutex initialization depends on the compiler's (and the
S   // linker's in gcc's case) ability to correctly handle explicitly
S   // initialized static members of class templates
S#  ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S#    define _RWSTD_NO_STATIC_MUTEX_INIT
S#  endif
N#endif   // _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
N
N/********************** Environment *********************************/
N
N/*
N * Most (but not all) non-unix systems convert new line to carriage
N * return / line feed on output:
N */
N#if defined (__OS2__) || defined (_WIN32) || defined (_WIN64)
X#if 0L || 0L || 0L
S#  define _RWSTD_CRLF_CONVENTION
N#endif
N
N
N// define wherever atomic instructions are not provided
N// affects the size of string reference (i.e., is binary incompatible)
N#if    !defined (__DECCXX)                           \
N    && !(defined (__i386__) && defined (__GNUG__))   \
N    && !defined (_WIN32) && !defined (_WIN64)
X#if    !0L                               && !(0L && 0L)       && !0L && !0L
N#  ifndef _RWSTD_NO_TEST_AND_SET
N#    define _RWSTD_NO_TEST_AND_SET
N#  endif   // _RWSTD_NO_TEST_AND_SET
N#endif   // !_WIN32 && !(__i386__ && __GNUG__)
N
N
N#ifdef _RWSTD_NO_WCHAR_T
S#  ifndef _RWSTD_NO_NATIVE_WCHAR_T /* may be defined in config.h */
S#    define _RWSTD_NO_NATIVE_WCHAR_T 1
S#  endif
N#endif
N
N
N#ifndef _RWSTD_NO_STL_SPECIALIZATION
N// #ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
N// disable partial specialization for void* of STL sequences
N#  define _RWSTD_NO_STL_SPECIALIZATION
N// #endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N#endif   // _RWSTD_NO_STL_SPECIALIZATION
N
N// 
N// Macro for path to the ANSI 'C' headers 
N// Must be set specifically for each platform when the
N// C++ wrappers for 'C' headers are used.
N//
N#define _RWSTD_ANSIC(x) </usr/include/x>
N
N// define unless already specified
N#ifndef _RWSTD_LDBL_PRINTF_PREFIX
N#  define _RWSTD_LDBL_PRINTF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_PRINTF_PREFIX
N
N#ifndef _RWSTD_LDBL_SCANF_PREFIX
N#  define _RWSTD_LDBL_SCANF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_SCANF_PREFIX
N
N
N/********************** Library Option Dependencies *************************/
N
N/*
N * The following macro sets the default size of file stream internal buffers
N */
N
N#ifndef _RWSTD_DEFAULT_BUFSIZE         // specified on command line?
N#  define _RWSTD_DEFAULT_BUFSIZE   512
N#endif
N
N#ifndef _RWSTD_NO_LONG_LONG
N   #if defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__) && !defined(__clang__)
X   #if 1L && !0L && !0L
N     /* strict armcc has '__int64' */
N     #define _RWSTD_LONG_LONG __int64
N   #endif
N   /* armclang and non-strict armcc allow 'long long' in system headers */
N   // Win32/64 #defines _RWSTD_LONG_LONG to __int64
N#  ifndef _RWSTD_LONG_LONG
S#    define _RWSTD_LONG_LONG long long
N#  endif   // _RWSTD_LONG_LONG
N#endif   // _RWSTD_NO_LONG_LONG
N
N
N// disable all extensions in strict ANSI mode
N#ifdef _RWSTD_STRICT_ANSI
S#  define _RWSTD_NO_EXT_FILEBUF
S#  define _RWSTD_NO_EXT_VECTOR_BOOL_REF_OPS
S#  define _RWSTD_NO_EXT_LOCALE
S#  define _RWSTD_NO_EXT_DEEP_STRING_COPY
S   // no support for exceptions derived from ios_base::failure
S#  define _RWSTD_NO_EXT_FAILURE
S   // no support for writing out integral values in base 2
S#  define _RWSTD_NO_EXT_BIN_IO
S   // no support for optional mt-locking in iostreams
S#  define _RWSTD_NO_EXT_REENTRANT_IO
S   // allocator<const T> not possible
S#  define _RWSTD_NO_EXT_CONST_ALLOCATOR
S   // no definitions provided for missing operator new or delete
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
S   // void std::count<>() not provided (except when necessary)
S#  define _RWSTD_NO_EXT_VOID_COUNT
S   // void std::distance<>()  not provided
S#  define _RWSTD_NO_EXT_VOID_DISTANCE
N#endif   // _RWSTD_STRICT_ANSI
N
N   // macros that are enabled in library source files
N#ifdef _RWSTD_LIB_SRC
S   // don't instantiate templates in library source code
S   //  (but see _RWSTD_INSTANTIATE_TEMPLATES macro below) 
S#  define _RWSTD_NO_TEMPLATE_DEFINITIONS
S   // don't provide definitions of operator new in library 
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _RWSTD_LIB_SRC
N
N#if _MSC_VER <= 1300
N   // msvc60 expects a definition to be provided for all variants
N   // of operator new/delete that are declared. This means that either
N   // the operators must be defined - preventing redefinition in user code -
N   // or that they must be undeclared - preventing them from being called
N   // directly in user code. We have chosen the former option.
N#  undef _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _MSC_VER
N
N#ifdef _RWSTD_INSTANTIATE_TEMPLATES
S   // instantiate templates (this macro appears in instance.cpp)
S#  undef _RWSTD_NO_TEMPLATE_DEFINITIONS
N#endif
N
N
N#endif   // _RWSTD_CONFIG_H_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 2
N
N
N// provide definitions for C++ versions of standard C headers
N// if a header is not available its name is #defined to the name of
N// this file (it's harmless and avoids polluting code with
N// tons of ugly platform-specific #ifdefs)
N#ifndef _RWSTD_NO_NEW_HEADER
N
N#  define _RWSTD_CASSERT   <cassert>
N#  define _RWSTD_CCTYPE    <cctype>
N#  define _RWSTD_CERRNO    <cerrno>
N#  define _RWSTD_CFLOAT    <cfloat>
N#  define _RWSTD_CISO646   <ciso646>
N#  define _RWSTD_CLIMITS   <climits>
N#  define _RWSTD_CLOCALE   <clocale>
N#  define _RWSTD_CMATH     <cmath>
N#  define _RWSTD_CSETJMP   <csetjmp>
N#  define _RWSTD_CSIGNAL   <csignal>
N#  define _RWSTD_CSTDARG   <cstdarg>
N#  define _RWSTD_CSTDDEF   <cstddef>
N#  define _RWSTD_CSTDIO    <cstdio>
N#  define _RWSTD_CSTDLIB   <cstdlib>
N#  define _RWSTD_CSTRING   <cstring>
N#  define _RWSTD_CTIME     <ctime>
N
N#  ifndef _RWSTD_NO_WCHAR_H
N#    define _RWSTD_CWCHAR  <cwchar>
N#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCHAR_H
N
N#  ifndef _RWSTD_NO_WCTYPE_H
N#    define _RWSTD_CWCTYPE <cwctype>
N#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCTYPE_H
N
N#else   // if defined (_RWSTD_NO_NEW_HEADER)
S
S#  define _RWSTD_CASSERT   <assert.h>
S#  define _RWSTD_CCTYPE    <ctype.h>
S#  define _RWSTD_CERRNO    <errno.h>
S#  define _RWSTD_CFLOAT    <float.h>
S#  define _RWSTD_CISO646   <iso646.h>
S#  define _RWSTD_CLIMITS   <limits.h>
S#  define _RWSTD_CLOCALE   <locale.h>
S#  define _RWSTD_CMATH     <math.h>
S#  define _RWSTD_CSETJMP   <setjmp.h>
S#  define _RWSTD_CSIGNAL   <signal.h>
S#  define _RWSTD_CSTDARG   <stdarg.h>
S#  define _RWSTD_CSTDDEF   <stddef.h>
S#  define _RWSTD_CSTDIO    <stdio.h>
S#  define _RWSTD_CSTDLIB   <stdlib.h>
S#  define _RWSTD_CSTRING   <string.h>
S#  define _RWSTD_CTIME     <time.h>
S
S#  ifndef _RWSTD_NO_WCHAR_H
S#    define _RWSTD_CWCHAR  <wchar.h>
S#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCHAR_H
S
S#  ifndef _RWSTD_NO_WCTYPE_H
S#    define _RWSTD_CWCTYPE <wctype.h>
S#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCTYPE_H
S
N#endif   // _RWSTD_NO_NEW_HEADER
N
N
N#if defined(_WIN64)
X#if 0L
S#  define _RWSTD_SYS_TYPES_H <basetsd.h>
S#elif defined(_WIN32)
X#elif 0L
S#  define _RWSTD_SYS_TYPES_H <rw/_defs.h>
N#else
N#  define _RWSTD_SYS_TYPES_H <sys/types.h>
N#endif   // _WIN32
N
N
N#ifdef _RWSTD_REQUIRES_IEEEFP
S// non-standard file required on Some platforms (e.g., Siemens) for <limits>
S#  define _RWSTD_IEEEFP <ieeefp.h>
N#else
N#  define _RWSTD_IEEEFP <rw/_defs.h>
N#endif
N
N
N// provide default #definitions of ANSI C library headers
N#if !defined (_RWSTD_NO_ASSERT_H) && !defined (_RWSTD_ANSI_C_ASSERT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ASSERT_H "/usr/include/assert.h"
N#endif
N#if !defined (_RWSTD_NO_CTYPE_H) && !defined (_RWSTD_ANSI_C_CTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_CTYPE_H "/usr/include/ctype.h"
N#endif
N#if !defined (_RWSTD_NO_ERRNO_H) && !defined (_RWSTD_ANSI_C_ERRNO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ERRNO_H "/usr/include/errno.h"
N#endif
N#if !defined (_RWSTD_NO_FLOAT_H) && !defined (_RWSTD_ANSI_C_FLOAT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_FLOAT_H "/usr/include/float.h"
N#endif
N#if !defined (_RWSTD_NO_ISO646_H) && !defined (_RWSTD_ANSI_C_ISO646_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ISO646_H "/usr/include/iso646.h"
N#endif
N#if !defined (_RWSTD_NO_LIMITS_H) && !defined (_RWSTD_ANSI_C_LIMITS_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LIMITS_H "/usr/include/limits.h"
N#endif
N#if !defined (_RWSTD_NO_LOCALE_H) && !defined (_RWSTD_ANSI_C_LOCALE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LOCALE_H "/usr/include/locale.h"
N#endif
N#if !defined (_RWSTD_NO_MATH_H) && !defined (_RWSTD_ANSI_C_MATH_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_MATH_H "/usr/include/math.h"
N#endif
N#if !defined (_RWSTD_NO_SETJMP_H) && !defined (_RWSTD_ANSI_C_SETJMP_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SETJMP_H "/usr/include/setjmp.h"
N#endif
N#if !defined (_RWSTD_NO_SIGNAL_H) && !defined (_RWSTD_ANSI_C_SIGNAL_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SIGNAL_H "/usr/include/signal.h"
N#endif
N#if !defined (_RWSTD_NO_STDARG_H) && !defined (_RWSTD_ANSI_C_STDARG_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDARG_H "/usr/include/stdarg.h"
N#endif
N#if !defined (_RWSTD_NO_STDDEF_H) && !defined (_RWSTD_ANSI_C_STDDEF_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDDEF_H "/usr/include/stddef.h"
N#endif
N#if !defined (_RWSTD_NO_STDIO_H) && !defined (_RWSTD_ANSI_C_STDIO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDIO_H "/usr/include/stdio.h"
N#endif
N#if !defined (_RWSTD_NO_STDLIB_H) && !defined (_RWSTD_ANSI_C_STDLIB_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDLIB_H "/usr/include/stdlib.h"
N#endif
N#if !defined (_RWSTD_NO_STRING_H) && !defined (_RWSTD_ANSI_C_STRING_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STRING_H "/usr/include/string.h"
N#endif
N#if !defined (_RWSTD_NO_TIME_H) && !defined (_RWSTD_ANSI_C_TIME_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_TIME_H "/usr/include/time.h"
N#endif
N#if !defined (_RWSTD_NO_WCHAR_H) && !defined (_RWSTD_ANSI_C_WCHAR_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCHAR_H "/usr/include/wchar.h"
N#endif
N#if !defined (_RWSTD_NO_WCTYPE_H) && !defined (_RWSTD_ANSI_C_WCTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCTYPE_H "/usr/include/wctype.h"
N#endif
N
N
N// Macro for determining the number of bits in a word.
N// Used by vector<bool>.
N//
N#define _RWSTD_WORD_BIT (int(CHAR_BIT*sizeof(unsigned int)))
N
N
N//
N// These macros tune the speed vs. space optimization of container
N// performance with regard to allocation of memory. These have been tuned
N// with speed efficiency as a primary conern. Space efficiency was
N// considered, but was secondary. (refer to Onyx QA Entry #4920)
N//
N// The ratio parameter must be above one for an amortized constant time
N// algorithm.  Lowering the ratio will lower rapidity and improve space
N// efficiency. This effect will be most noticable when working with
N// containers of few elements (few being less than 32 for the general case)
N// If your use case is with containers that typically have many elements
N// lowering the ratio will have less effect on rapidity.
N//
N// The minimum elements parameter refers to minimum amount of additional
N// capcity requested (in number of elements) when more memory is needed.
N// Rapidity with containers of few elements will be affected most noticably
N// as this amount this is lowered.
N//
N// For strings, the specializations on char and wchar_t were seen as an
N// exploitable common case, and have their own more specialized template
N// function overloads in the string header.  These are tweakable here
N// with the STRING version of these macros.
N//
N#if !defined(_RWSTD_MINIMUM_NEW_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_NEW_CAPACITY _RWSTD_C::size_t (32)
N#endif
N#if !defined(_RWSTD_NEW_CAPACITY_RATIO)
X#if !0L
N   // using long doubles to eliminate bogus warnings on g++ 2.95.2/sparc
N   // (-W -O2/3 only): warning: overflow on truncation to integer
N   //#  define _RWSTD_NEW_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_CAPACITY(x) ((x) + ((x) >> 1) + ((x) >> 3)) // 'x * 1.625'
N#endif
N#if !defined(_RWSTD_MINIMUM_STRING_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_STRING_CAPACITY _RWSTD_C::size_t (128)
N#endif
N#if !defined(_RWSTD_STRING_CAPACITY_RATIO)
X#if !0L
N   //#  define _RWSTD_STRING_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_STRING_CAPACITY(x) _RWSTD_INCREASE_CAPACITY(x)
N#endif
N
N
N// set up Win32/64 DLL export/import directives
N// _DLL - defined by the compiler when either -MD or -MDd is used
N// RWDLL - defined for all Rogue Wave products to be built as shared libs
N// _RWSHARED - defined for stdlib to be built/used as a shared lib
N#if    (defined (_WIN32) || defined (_WIN64)) \
N    && (defined (RWDLL) || defined (_RWSHARED))
X#if    (0L || 0L)     && (0L || 0L)
S#  ifdef _RWBUILD_std
S     // building a shared lib, export names
S#    define _RWSTD_EXPORT   __declspec (dllexport)
S#  else
S     // using a shared lib, import names
S#    define _RWSTD_EXPORT   __declspec (dllimport)
S#  endif
S
S   // disable warnings:
S   // C4251: class needs to have dll-interface to be used by cliens
S   // C4275: non dll-interface class used as base for dll-interface class
S#  pragma warning (disable: 4251)
S#  pragma warning (disable: 4275)
N#else
N// disable Windows hacks
N#  define _RWSTD_EXPORT
N#endif
N
N
N// The member variable string::npos is required to be static to allow its
N// use in constant expressions.  For compilers that do not support static
N// intialization an enumeration is used.  This workaround is not available
N// on LLP64 architectures however, where enums are 32 bit.  In this case it
N// we don't have a workaround to support the use of npos in constant
N// expressions, the macro _RWSTD_NPOS must be used instead
N#if defined(_RWSTD_LLP64_ARCHITECTURE) && defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if 0L && 0L
S#  define _RWSTD_NPOS _RWSTD_C::size_t(-1)
N#else
N#  define _RWSTD_NPOS string::npos
N#endif
N
N
N/*
N** Miscellaneous workarounds.
N*/
N
N#ifdef _RWSTD_NO_BOOL
S#  ifdef _RWSTD_MSVC_BOOL_WARNING
S#    pragma warning ( disable : 4237 )
S#  endif
S
S   typedef int     bool;
S
S#  ifndef true
S#    define true    1
S#  endif
S
S#  ifndef false
S#    define false   0
S#  endif
N#endif // _RWSTD_NO_BOOL
N
N
N#ifndef _RWSTD_NO_TYPENAME
N#  define _TYPENAME typename
N#else
S#  define _TYPENAME
N#endif
N
N#if defined (SNI) || defined (__SUNPRO_CC) && __SUNPRO_CC <= 0x520
X#if 0L || 0L && __SUNPRO_CC <= 0x520
S#  define _TYPENAME_CTOR
N#else
N#  define _TYPENAME_CTOR _TYPENAME
N#endif
N
N#ifndef _RWSTD_NO_EXPLICIT
N#  define _EXPLICIT explicit
N#else
S#  define _EXPLICIT
N#endif
N
N
N#ifndef _RWSTD_NO_MUTABLE
N#  define _MUTABLE mutable
N#else
S#  define _MUTABLE
N#endif
N
N
N//
N// Macro for forming or omitting default template arguments in constructors
N//
N
N#ifndef _RWSTD_NO_DEFAULT_TEMPLATE_ARGS
N#  define _RWSTD_DEFAULT_ARG(n) = n
N#else
S#  define _RWSTD_DEFAULT_ARG(n)
N#endif
N
N
N// MSVC version 12.00.xxxx (and perhaps prior) can't parse template
N// re-declarations if the previous declaration contains two or more
N// default template parameters (go figure)
N#if defined (_MSC_VER) && _MSC_VER <= 1300
X#if 0L && _MSC_VER <= 1300
S#  define _RWSTD_REDECLARED_DEFAULT(arg)   = arg
N#else   // if !(!defined (_MSC_VER) || (_MSC_VER <= 1300))
N#  define _RWSTD_REDECLARED_DEFAULT(ignore)
N#endif   // !defined (_MSC_VER) || (_MSC_VER <= 1300)
N
N
N//
N// Macro for forming or ommitting default template parameters.
N//
N#ifndef _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N#  define _RWSTD_SIMPLE_DEFAULT(a)  = a
N#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N#    define _RWSTD_COMPLEX_DEFAULT(a)  = a
N#  else
S#    define _RWSTD_COMPLEX_DEFAULT(a)
N#  endif
N#else   // if defined (_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES)
S#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#  endif
S#  define _RWSTD_SIMPLE_DEFAULT(a)
S#  define _RWSTD_COMPLEX_DEFAULT(a)
S#  ifndef _RWSTD_NO_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_DEFAULT_TEMPLATES
S#  endif
N#endif   // _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N
N
N// Macro for casting, using either the "old" method
N// or the new C++ cast system
N#ifdef _RWSTD_NO_STATIC_CAST
S#  define _RWSTD_STATIC_CAST(x, y)      ((x)y)
S#  define _RWSTD_REINTERPRET_CAST(x, y) ((x)y)
S#  define _RWSTD_CONST_CAST(x, y)       ((x)y)
N#else
N#  define _RWSTD_STATIC_CAST(x, y)      static_cast< x >(y)
N#  define _RWSTD_REINTERPRET_CAST(x, y) reinterpret_cast< x >(y)
N#  define _RWSTD_CONST_CAST(x, y)       const_cast< x >(y)
N#endif   // _RWSTD_NO_STATIC_CAST
N
N//
N// Macros for the new template specialization syntax
N//
N
N#ifdef _RWSTD_NO_NEW_FUNC_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_FUNCTION
N#else
N#  define _RWSTD_SPECIALIZED_FUNCTION template<>
N#endif
N
N#ifdef _RWSTD_NO_NEW_CLASS_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_CLASS
N#else
N#  define _RWSTD_SPECIALIZED_CLASS template<>
N#endif
N
N// for compilers or environments that do not support namespaces
N#ifndef _RWSTD_NO_NAMESPACE
N#  define _RWSTD_NAMESPACE_BEGIN(name)    namespace name {
N#  define _RWSTD_NAMESPACE_END            }
N
N#  define _USING(name)                    using name
N
N#  ifdef _MSC_VER
S#    define _STD                       ::std
S#    define _STD_RW                    ::std
S#    define _RW                        ::__rw
N#  else
N#    define _STD                       std
N#    define _STD_RW                    std
N#    define _RW                        __rw
N#  endif
N
N#else   // if defined (_RWSTD_NO_NAMESPACE)
S#  define _RWSTD_NAMESPACE_BEGIN(ignore)
S#  define _RWSTD_NAMESPACE_END
S
S#  define _USING(ignore)              typedef void __rw_unused_typedef
S
S#  define _STD
S#  define _STD_RW
S#  define _RW
N#endif   // _RWSTD_NO_NAMESPACE
N
N//
N// for compilers that don't like specialized friends
N// such as operator== in template classes
N//
N#ifdef _RWSTD_NO_SPECIALIZED_FRIEND
S#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
S#  else   // if !defined (__TURBOC__)
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   name
S#  endif   // __TURBOC__
N#else   // if defined (_RWSTD_NO_SPECIALIZED_FRIEND)
N#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
N#  else   // if !defined (__TURBOC__)
N     // the space between `name' and `<>' is necessary
N     // to prevent ..._FRIEND (operator<) from expanding into operator<<>
N     // (only the GNU preprocessor inserts a space)
N#    define _RWSTD_SPECIALIZED_FRIEND(name)   name <>
N#  endif  // __TURBOC__
N#endif   // _RWSTD_NO_SPECIALIZED_FRIEND
N
N
N//
N// If compiler supports member and default templates then it support
N// the _RWSTD_ALLLOCATOR
N//
N#if    !defined(_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) \
N    && !defined(_RWSTD_NO_MEM_CLASS_TEMPLATES)
X#if    !0L     && !0L     && !0L
N#  define _RWSTD_ALLOCATOR
N#endif
N
N
N#define _RWSTD_MB_CUR_MAX 16  //???  Need to find absolute maximum for this
N
N
N// helper macros for token pasting
N#define _RWSTD_DO_PASTE(a, b)   a ## b
N#define _RWSTD_PASTE(a, b)      _RWSTD_DO_PASTE (a, b)
N
N#ifdef _RWSTD_MULTI_THREAD
S// synchronizes access by all objects holding the same mutex
S#  define _RWSTD_MT_GUARD(mutex)  \
S          _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
X#  define _RWSTD_MT_GUARD(mutex)            _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
S
S// synchronizes access by all threads
S#  define _RWSTD_MT_STATIC_GUARD(name)        \
S          static _RW::__rw_mutex name; \
S          _RWSTD_MT_GUARD (name)
X#  define _RWSTD_MT_STATIC_GUARD(name)                  static _RW::__rw_mutex name;           _RWSTD_MT_GUARD (name)
S
S// synchronizes access by all objects of the same type
S#  define _RWSTD_MT_CLASS_GUARD(name, type) \
S          _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
X#  define _RWSTD_MT_CLASS_GUARD(name, type)           _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
S
S#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex) \
S          _RW::__rw_atomic_preincrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex)           _RW::__rw_atomic_preincrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex) \
S          _RW::__rw_atomic_predecrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex)           _RW::__rw_atomic_predecrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_SWAP(x, y, mutex) \
S          _RW::__rw_atomic_exchange  (x, y, mutex)
X#  define _RWSTD_ATOMIC_SWAP(x, y, mutex)           _RW::__rw_atomic_exchange  (x, y, mutex)
S
S#  ifndef _RWSTD_NO_EXT_REENTRANT_IO
S// conditional swap used in iostreams
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            ((this->flags () & _RWSTD_IOS_NOLOCK) ?      \
S                _RW::__rw_ordinary_exchange  (x, y)      \
S             :  _RW::__rw_atomic_exchange  (x, y, mutex))
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       ((this->flags () & _RWSTD_IOS_NOLOCK) ?                      _RW::__rw_ordinary_exchange  (x, y)                   :  _RW::__rw_atomic_exchange  (x, y, mutex))
S
S#  else
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            _RWSTD_ATOMIC_SWAP(x, y, mutex)
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       _RWSTD_ATOMIC_SWAP(x, y, mutex)
S#  endif    // _RWSTD_NO_EXT_REENTRANT_IO
S
N#else   // if !defined _RWSTD_MULTI_THREAD
N
N#  define _RWSTD_MT_GUARD(ignore)                   ((void)0)
N#  define _RWSTD_MT_STATIC_GUARD(name)              _RWSTD_MT_GUARD (name)
N#  define _RWSTD_MT_CLASS_GUARD(name, ignore)       _RWSTD_MT_GUARD (name)
N
N#  define _RWSTD_ATOMIC_PREINCREMENT(x, ignore)     ++(x)
N#  define _RWSTD_ATOMIC_PREDECREMENT(x, ignore)     --(x)
N#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)  \
N          _RW::__rw_atomic_exchange ((x), (y), false)
X#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)            _RW::__rw_atomic_exchange ((x), (y), false)
N
N#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)  \
N          _RW::__rw_ordinary_exchange ((x), (y))
X#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)            _RW::__rw_ordinary_exchange ((x), (y))
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N// macro for qualifying C library names in the std namespace
N#ifndef _RWSTD_NO_LIBC_IN_STD
N# define _RWSTD_C std
N#else
S# define _RWSTD_C
N#endif
N
N#define _RWSTD_INVALID_FILE_DESC -1
N#define _RWSTD_INVALID_FILE_PTR   0
N
N#ifndef _RWSTD_NO_NATIVE_IO
S# define _RWSTD_INVALID_FILE     -1
S# define _RWSTD_INVALID_OPENMODE -1
N#else
N# define _RWSTD_INVALID_FILE      (FILE*)0
N# define _RWSTD_INVALID_OPENMODE  0
N#endif // _RWSTD_NO_NATIVE_IO
N
N
N// std::ios_base static const data members' values
N#define _RWSTD_IOS_BOOLALPHA    0x00001
N#define _RWSTD_IOS_DEC          0x00002
N#define _RWSTD_IOS_FIXED        0x00004
N#define _RWSTD_IOS_HEX          0x00008
N#define _RWSTD_IOS_INTERNAL     0x00010
N#define _RWSTD_IOS_LEFT         0x00020
N#define _RWSTD_IOS_OCT          0x00040
N#define _RWSTD_IOS_RIGHT        0x00080
N#define _RWSTD_IOS_SCIENTIFIC   0x00100
N#define _RWSTD_IOS_SHOWBASE     0x00200
N#define _RWSTD_IOS_SHOWPOINT    0x00400
N#define _RWSTD_IOS_SHOWPOS      0x00800
N#define _RWSTD_IOS_SKIPWS       0x01000
N#define _RWSTD_IOS_UNITBUF      0x02000
N#define _RWSTD_IOS_UPPERCASE    0x04000
N#define _RWSTD_IOS_BIN          0x08000
N// NOLOCK[BUF] used rather than LOCK[BUF] to maintain functional compatibility
N// with release 2.2 (which was always safe when these bits were cleared)
N#define _RWSTD_IOS_NOLOCK       0x10000
N#define _RWSTD_IOS_NOLOCKBUF    0x20000
N
N#define _RWSTD_IOS_FLOATFIELD   _RWSTD_IOS_FIXED | _RWSTD_IOS_SCIENTIFIC
N
N#define _RWSTD_IOS_ADJUSTFIELD    \
N        (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
X#define _RWSTD_IOS_ADJUSTFIELD            (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
N
N#ifndef _RWSTD_NO_EXT_BIN_IO
N#  define _RWSTD_IOS_BASEFIELD    \
N          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
N#else
S#  define _RWSTD_IOS_BASEFIELD    \
S          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
N#endif   // _RWSTD_NO_EXT_BIN_IO
N
N
N#define _RWSTD_IOS_GOODBIT       0x00
N#define _RWSTD_IOS_BADBIT        0x01
N#define _RWSTD_IOS_EOFBIT        0x02
N#define _RWSTD_IOS_FAILBIT       0x04
N
N#define _RWSTD_IOS_APP           0x01
N#define _RWSTD_IOS_BINARY        0x02
N#define _RWSTD_IOS_IN            0x04
N#define _RWSTD_IOS_OUT           0x08
N#define _RWSTD_IOS_TRUNC         0x10
N#define _RWSTD_IOS_ATE           0x20
N
N#ifndef _RWSTD_STRICT_ANSI
N#  define _RWSTD_IOS_NOCREATE    0x40
N#  define _RWSTD_IOS_NOREPLACE   0x80
N#else
S#  define _RWSTD_IOS_NOCREATE    0
S#  define _RWSTD_IOS_NOREPLACE   0
N#endif
N
N#define _RWSTD_IOS_MASK                         \
N        (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY   \
N         | _RWSTD_IOS_IN | _RWSTD_IOS_OUT       \
N         | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE    \
N         | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
X#define _RWSTD_IOS_MASK                                 (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY            | _RWSTD_IOS_IN | _RWSTD_IOS_OUT                | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE             | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
N
N
N#if    !defined (_RWSTD_NO_STATIC_IOSTREAM_INIT)  \
N    && !defined (_RWSTD_NO_IOSTREAM_OBJECT_REFS)
X#if    !0L      && !0L
N   // standard iostream objects are references
N#  define _RWSTD_IOSTREAM_OBJECT(name)   &name
N#else
S   // standard iostream objects are declared to be real objects
S   // they may be implemented as real objects of the same type
S   // that get destroyed during program lifetime or as objects
S   // of some POD type that do not get destroyed at all
S#  define _RWSTD_IOSTREAM_OBJECT(name)   name
N#endif   //  _RWSTD_NO_STATIC_IOSTREAM_INIT && !_RWSTD_NO_IOSTREAM_OBJECT_REFS
N
N
N// exceptions can be completely disabled (bodies of catch blocks are still
N// compiled but will be removed by the optimizing stage of the compiler)
N// this approach reveals any errors even if _RWSTD_NO_EXCEPTIONS is #defined
N#ifndef _RWSTD_NO_EXCEPTIONS
S#  define _TRY           try
S#  define _CATCH(ex)     catch (ex)
S#  define _CATCH_T(ex)   catch (ex)
S#  define _THROW(ex)     throw ex
S#  define _RETHROW       throw
N#else   // if defined (_RWSTD_NO_EXCEPTIONS)
N#  define _TRY
N#  define _CATCH(ignore)   while (0)
N#  define _CATCH_T(type)   for (type; 0;) 
N#  define _THROW(ignore)   ((void)0)
N#  define _RETHROW         ((void)0)
N#endif   // _RWSTD_NO_EXCEPTIONS
N
N
N// for compilers that can't handle standard allocators we provide four
N// workarounds: _RWSTD_REBIND, used in place of _Allocator::rebind, allows
N// containers to use the same allocator for different data types
N// _RWSTD_ALLOC_TYPE is required to "rebind", or rather wrap,  the user
N// supplied non-conforming allocator in allocator_interface so that the
N// container need not be aware of the allocator's special properties (namely
N// the fact that the allocator allocates in terms of bytes rather than
N// elemements)
N//
N// _RWSTD_VALUE_ALLOC creates a temporary allocator_interface wrapper
N// from the given parameter (usually *this) when allocating values in
N// the sequence containers with non-conforming allocators.
N// _RWSTD_VALUE_ALLOC_CAST casts the given container to a reference to
N// a value allocator, allowing access to inherited allocator members
N// outside of the class.  For non-conforming compilers, this macro is
N// equivalent to _RWSTD_VALUE_ALLOC.
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `to' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifdef _RWSTD_ALLOCATOR
N#  define _RWSTD_REBIND(from, to) \
N          _TYPENAME from::template rebind < to >::other
X#  define _RWSTD_REBIND(from, to)           _TYPENAME from::template rebind < to >::other
N#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   _Allocator
N#  define _RWSTD_VALUE_ALLOC(ignore, call)            allocator_type::call
N#  define _RWSTD_VALUE_ALLOC_CAST(rvalue) \
N          _RWSTD_STATIC_CAST (allocator_type&, rvalue)
X#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)           _RWSTD_STATIC_CAST (allocator_type&, rvalue)
N#else   // if !defined (_RWSTD_ALLOCATOR)
S#  define _RWSTD_REBIND(from, to) \
S          _STD_RW::allocator_interface < from, to >
X#  define _RWSTD_REBIND(from, to)           _STD_RW::allocator_interface < from, to >
S#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   \
S          _RWSTD_REBIND (_Allocator, _ValueType)
X#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)             _RWSTD_REBIND (_Allocator, _ValueType)
S#  define _RWSTD_VALUE_ALLOC(type, call)      type(*this).call
S#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)     _C_value_alloc_type(rvalue)
N#endif   // _RWSTD_ALLOCATOR
N
N
N// for compilers that can't deal with template functions parametrized
N// on the function's return type (as opposed to function arguments)
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `type' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N#  define _STD_USE_FACET(type, arg)    _STD::use_facet < type >(arg)
N#  define _USE_FACET(type, arg)        use_facet < type >(arg)
N#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer < type >(size)
N#else   // if defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
S#  define _STD_USE_FACET(type, arg)    _STD::use_facet (arg, (type*)(0))
S#  define _USE_FACET(type, arg)        use_facet (arg, (type*)(0))
S#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer (size, (type*)0)
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N#ifndef _RWSTD_NO_NONCLASS_ARROW_RETURN
N   // expected signature: "_TypeT* operator->()"
N   // and/or:             "const _TypeT* operator->() const"
N#  define _RWSTD_OPERATOR_ARROW(signature) signature { return &**this; }
N#else
S#  define _RWSTD_OPERATOR_ARROW(ignore)
N#endif   // _RWSTD_NO_NONCLASS_ARROW_RETURN
N
N
N// to prevent warnings about unused arguments
N#define _RWSTD_UNUSED(arg)   ((void)&arg)
N
N
N// allows all externs to be declared/defined only in headers
N// and defined just by first #defining _RWSTD_DEFINE_EXTERNS
N// and then #including the header in a .cpp file
N#ifndef _RWSTD_DEFINE_EXTERNS
N#  define _RWSTD_EXTERN(decl, ignore)   extern decl
N#else
S#  define _RWSTD_EXTERN(decl, value)    extern decl = value
N#endif   // _RWSTD_DEFINE_EXTERNS
N
N
N// allows static const integral or enum class members to be initialized
N// inside the class and defined (w/o being initialized) outside
N// of the class (as required by 9.4.2, p4)
N#if !defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if !0L
N#  define _RWSTD_STATIC_CONST(type, init)    static const type init
N#  define _RWSTD_DEFINE_STATIC_CONST(decl)   decl
N#else
S#  define _RWSTD_STATIC_CONST(ignore, init)  enum { init }
S#  define _RWSTD_DEFINE_STATIC_CONST(ignore)
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N// Selection of vendor dependent "format" string argument to wcsftime()
N#ifndef _RWSTD_NO_WCSFTIME
N   // 7.24.5.1 of C99 - wcsftime()'s 3rd arg is const wchar* [restrict]
N   //                   HP-UX 11 (and perhaps others) still uses const char*
N#  ifndef _RWSTD_NO_WCSFTIME_WCHAR_T_FMAT
N#     define _RWSTD_FMT_TYPE(arg)  const wchar_t* arg
N#     define _RWSTD_FMT_ASSGN(str) L##str
N#  else
S#     define _RWSTD_FMT_TYPE(arg)  const char* arg
S#     define _RWSTD_FMT_ASSGN(str) str
N#  endif
N#else   // if defined (_RWSTD_NO_WCSFTIME)
S#  define _RWSTD_FMT_TYPE(arg)     const char* arg
S#  define _RWSTD_FMT_ASSGN(str)    str
N#endif // _RWSTD_NO_WCSFTIME
N
N
N// _Iterator typedefs
N// (note that you must use a semi-colon at the end of this macro)
N#define _RWSTD_ITERATOR_TYPES(_Iterator)                               \
N     typedef _TYPENAME _Iterator::difference_type difference_type;     \
N     typedef _TYPENAME _Iterator::value_type value_type;               \
N     typedef _TYPENAME _Iterator::pointer pointer;                     \
N     typedef _TYPENAME _Iterator::reference reference;                 \
N     typedef _TYPENAME _Iterator::iterator_category iterator_category
X#define _RWSTD_ITERATOR_TYPES(_Iterator)                                    typedef _TYPENAME _Iterator::difference_type difference_type;          typedef _TYPENAME _Iterator::value_type value_type;                    typedef _TYPENAME _Iterator::pointer pointer;                          typedef _TYPENAME _Iterator::reference reference;                      typedef _TYPENAME _Iterator::iterator_category iterator_category
N
N// helpers making working w/o iterator_traits transparent
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_VALUE_TYPE(iterT) \
N       (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
X#  define _RWSTD_VALUE_TYPE(iterT)        (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
N#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
N       (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
N#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore) \
N       _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
X#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore)        _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S#  define _RWSTD_VALUE_TYPE(iterT) __value_type ((iterT*)0)
S   // assume default ctor is defined and accessible
S#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
S       _STD::__distance_type (iterT ())
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          _STD::__distance_type (iterT ())
S   // macro cannot use the default ctor to construct a temporary
S   // with the type of the first argument since the default ctor
S   // may not exist or be accessible (e.g., istream_iterator<>)
S#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter) \
S       _STD::__iterator_category (iter)
X#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter)        _STD::__iterator_category (iter)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// Use -D_RWSTDDEBUG to compile a version of the libraries to debug
N// the user's code.  This will perform pre- and post-condition checks
N// upon entering routines, but will be larger and run more slowly.
N// This option affects the binary compatibility of generated code.
N
N
N#if defined(RWDEBUG) && !defined(_RWSTDDEBUG)
X#if 0L && !0L
S#  define _RWSTDDEBUG 1
N#endif
N
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_ASSERT(expr)                                                \
S     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__, \
S                                                __PRETTY_FUNCTION__))
X#  define _RWSTD_ASSERT(expr)                                                     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__,                                                 __PRETTY_FUNCTION__))
N#else   //  if !defined (_RWSTDDEBUG)
N#  define _RWSTD_ASSERT(ignore)         ((void)0)
N#endif   // _RWSTDDEBUG
N
N// compile-time assertion - asserts constant expressions during
N// compilation with no runtime overhead; failed assertions are reported
N// as compilation errors
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
Ntemplate <bool __b>
Nstruct __rw_compile_assert;
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_compile_assert<true> { enum { _C_ok }; };
N
N#define _RWSTD_COMPILE_ASSERT(const_expr) \
N        ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
X#define _RWSTD_COMPILE_ASSERT(const_expr)         ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
N
N// called for failed assertions
Nvoid _RWSTD_EXPORT
Xvoid 
N__rw_assert_fail (const char *__expr,
N                       const char *__file, int __line, const char *__func);
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#  define _RWSTD_STR(x)       #x
N#  define _RWSTD_STRSTR(x)    _RWSTD_STR(x)
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, __PRETTY_FUNCTION__
S#  define _RWSTD_FILE_LINE   __MODULE__ ":" _RWSTD_STRSTR (__LINE__)
N#else
N#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, ""
N#  define _RWSTD_FILE_LINE   ""
N#endif
N
N/* at least some of the _RWSTD_REQUIRES are needed for conformance */
N#  define _RWSTD_REQUIRES(pred, args)   (pred) ? (void)0 : _RW::__rw_throw args
N
N// function exception specification
N#if    !defined (_RWSTD_NO_EXCEPTIONS) \
N    && !defined (_RWSTD_NO_EXCEPTION_SPECIFICATION)
X#if    !1L     && !0L
S   // type_id_list is a possibly empty parenthesized list
S   //of comma-separated type-id's
S#  define _THROWS(type_id_list)   throw type_id_list
N#else   // if _RWSTD_NO_EXCEPTIONS || _RWSTD_NO_EXCEPTION_SPECIFICATION
N#  define _THROWS(ignore)
N#endif   // !_RWSTD_NO_EXCEPTIONS && !_RWSTD_NO_EXCEPTION_SPECIFICATION
N
N
N// for convenience
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _DISTANCE(first, last, ignore) _STD_RW::distance (first, last)
N#else
S#  define _DISTANCE(first, last, type) _RW::__rw_distance (first, last, type())
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// pointers to the incomplete types declared below are used
N// to disambiguate calls to template member functions
N// bodies provided only to work around an HP aCC 3.14.10 bug
Ntemplate <bool __b>
Nstruct __rw_select { };
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_select<true> { };
N
N#define _RWSTD_DISPATCH_INT(yes) const _RW::__rw_select < yes >*
N#define _RWSTD_DISPATCH(iter) \
N        ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
X#define _RWSTD_DISPATCH(iter)         ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#if defined (__IBMCPP__) && __IBMCPP <= 500
X#if 0L && __IBMCPP <= 500
S
S// working around an xlC 5.0 bug
S_USING (__rw::__rw_select);
S
N#endif
N
N
N// select appropriate C multibyte conversion function based on
N// whether "restartable" functions are available.
N
N
N#ifndef _RWSTD_NO_MBRTOWC
N   // reentrant versions return size_t - see 7.24.6.3.2 of C99
N#  define _RWSTD_MBTOWC(to, from, size, state) mbrtowc (to, from, size, state)
N#elif !defined (_RWSTD_NO_MBTOWC)
S   // non-reentrant versions return int - see 7.20.7.2 of C99
S#  define _RWSTD_MBTOWC(to, from, size, ignore_state) \
S          _RWSTD_C::size_t (mbtowc(to, from, size))
X#  define _RWSTD_MBTOWC(to, from, size, ignore_state)           _RWSTD_C::size_t (mbtowc(to, from, size))
S#else
S   // mbtowc not supported
S#  define _RWSTD_MBTOWC(ign1, ign2, ign3, ign4) _RWSTD_C::size_t (-1)
N#endif   // _RWSTD_NO_MBRTOWC
N
N#ifndef _RWSTD_NO_WCRTOMB
N#  define _RWSTD_WCTOMB(to, from, state)       wcrtomb (to, from, state)
N#else   // if defined (_RWSTD_NO_WCRTOMB)
S#  define _RWSTD_WCTOMB(to, from, ignore_state) \
S          _RWSTD_C::size_t (wctomb (to, from))
X#  define _RWSTD_WCTOMB(to, from, ignore_state)           _RWSTD_C::size_t (wctomb (to, from))
N#endif   // _RWSTD_NO_WCRTOMB
N
N
N// unsafe when underlying libc doesn't support mbsinit
N// as described in 7.24.6.3.1 of C99
N#ifndef _RWSTD_NO_MBSINIT
N# if defined(SNI) && defined(_RWSTD_STRICT_ANSI)
X# if 0L && 0L
S#  define _MBSINIT(ps)   __SNI::mbsinit (ps)
N# else
N#  define _MBSINIT(ps)   mbsinit (ps)
N# endif
N#else   // if defined (_RWSTD_NO_MBSINIT)
S#  define _MBSINIT(ps)   (0 == (ps))
N#endif   // _RWSTD_NO_MBSINIT
N
N
N// enable only in debug mode and only id partial class specialization
N// is supported; prevent multiple definition of _RWSTD_NO_DEBUG_ITER
N#if    defined(_RWSTDDEBUG) && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_DEBUG_ITER) && !defined (SNI)
X#if    0L && !0L     && !0L && !0L
S#  define _RWSTD_ASSERT_RANGE(first, last) \
S      _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
X#  define _RWSTD_ASSERT_RANGE(first, last)       _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
S#  define _RWSTD_ASSERT_IN_RANGE(it, first, last) \
S      _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
X#  define _RWSTD_ASSERT_IN_RANGE(it, first, last)       _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
S#  define _RWSTD_ASSERT_DEREF(it) \
S      _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
X#  define _RWSTD_ASSERT_DEREF(it)       _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
N#else
N#  ifndef _RWSTD_NO_DEBUG_ITER
N#    define  _RWSTD_NO_DEBUG_ITER
N#  endif   // _RWSTD_NO_DEBUG_ITER
N
N#  define _RWSTD_ASSERT_RANGE(ign1, ign2)          ((void)0)
N#  define _RWSTD_ASSERT_IN_RANGE(ign1, ign2, ign3) ((void)0)
N#  define _RWSTD_ASSERT_DEREF(ignore)              ((void)0)
N#endif   // _RWSTDDEBUG && !_RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// convenience macro to get the "real" iterator embedded in __rw_debug_iter<>
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  define _ITER_BASE(it)   ((it).base ())
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N#  define _ITER_BASE(it)   (it)
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N// will use the deduced native type rather than the typedef to prevent
N// conflicts caused by inconsistent definition of wint_t (gcc 2.95.2/AIX)
N#ifndef _RWSTD_WINT_T
S   // hardcode if wint_t is not available in <wchar.h>
S   // used by std::traits and std::basic_[i|o]stream
S#  define _RWSTD_WINT_T int
N#endif   // _RWSTD_WINT_T
N
N
N// used by std::traits and std::basic_[i|o]stream,
N// required to be int by 21.1.3.1, p2
N#define _RWSTD_INT_T int
N
N
N// ssize_t is defined by POSIX.1
N#ifndef _RWSTD_SSIZE_T
N#  ifdef _WIN64
S#    define _RWSTD_SSIZE_T SSIZE_T
N#  else
N#    define _RWSTD_SSIZE_T long
N#  endif
N#endif
N
N
N#if defined(SNI)
X#if 0L
S#  define _RWSTD_USING_SNI(name) _USING(__SNI::name)
S#  if defined(_RWSTD_STRICT_ANSI)
S#    define fileno(p)       (int) ((p)->_file)
S#  endif
N#else
N#  define _RWSTD_USING_SNI(ignore)    typedef void __rw_unused_typedef
N#endif
N
N
N#ifndef _RWSTD_TMPBUF_SIZE
N#  define _RWSTD_TMPBUF_SIZE 4096
N#endif
N
N#ifndef _RWSTD_NO_STRTOLL
N#  define _STRTOLL           strtoll
N#else
S   // libc has no strtoll, use strtol instead
S#  define _STRTOLL           (_RWSTD_LONG_LONG)strtol
N#endif   // _RWSTD_NO_STRTOLL
N
N
N#ifndef _RWSTD_NO_STRTOULL
N#  define _STRTOULL          strtoull
N#else
S   // libc has no strtoull, use strtoul instead
S#  define _STRTOULL          (unsigned _RWSTD_LONG_LONG)strtoul
N#endif   // _RWSTD_NO_STRTOULL
N
N
N#if     defined (_RWSTD_INSTANTIATE_TEMPLATES)       \
N    && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N    && !defined (_RWSTD_NO_INSTANTIATE)
X#if     0L           && !0L       && !0L
S#  define _RWSTD_INSTANTIATE_1(arg)          template arg
S#  define _RWSTD_INSTANTIATE_2(a1, a2)       template a1, a2
S#  define _RWSTD_INSTANTIATE_3(a1, a2, a3)   template a1, a2, a3
N#else
N#  if    defined (_MSC_VER)                          \
N      && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION) \
N      && !defined (_RWSTD_NO_INSTANTIATE)
X#  if    0L                                && !0L       && !0L
S     // disable warning C4231: nonstandard extension used :
S     //         'extern' before template explicit instantiation
S#    pragma warning (disable: 4231)
S#    define _RWSTD_INSTANTIATE_1(arg)        extern template arg
S#    define _RWSTD_INSTANTIATE_2(a1, a2)     extern template a1, a2
S#    define _RWSTD_INSTANTIATE_3(a1, a2, a3) extern template a1, a2, a3
N#  else
N#    define _RWSTD_INSTANTIATE_1(ignore)           \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_1(ignore)                       typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_2(ign1, ign2)       \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_2(ign1, ign2)                   typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3) \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3)             typedef void __rw_unused_typedef
N#  endif
N#endif   // _RWSTD_INSTANTIATE_TEMPLATES
N
N
N#ifndef _RWSTD_NO_UNCAUGHT_EXCEPTION
S#  define _UNCAUGHT_EXCEPTION()   uncaught_exception()
N#else   // if defined (_RWSTD_NO_UNCAUGHT_EXCEPTION)
N#  define _UNCAUGHT_EXCEPTION()   true
N#endif   // _RWSTD_NO_UNCAUGHT_EXCEPTION
N
N// allows for efficient compilation without implicit inclusion; only
N// specializations explicitly instantiated in the library are available
N#if     defined _RWSTD_COMPILE_INSTANTIATE               \
N    && (   !defined (_RWSTD_NO_TEMPLATE_DEFINITIONS)     \
N        ||  defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_IMPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_INSTANTIATE))
X#if     0L                   && (   !0L             ||  0L           ||  0L           ||  0L)
S#  define _RWSTD_DEFINE_TEMPLATE(name)     !(_RWSTD_NO_ ## name ## _DEFINITION)
N#else
N#  define _RWSTD_DEFINE_TEMPLATE(ignore)   0
N#endif
N
N
N// introduce namespace std so that "using namespace std;" always works
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#ifndef _RWSTD_NO_NAMESPACE
N#ifdef __EDG_IMPLICIT_USING_STD 
S/* Implicitly include a using directive for the STD namespace when this */ 
S/* preprocessing flag is TRUE. */ 
Susing namespace ::std; 
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */ 
N#endif /* _RWSTD_NO_NAMESPACE */
N
N#endif   // _RWSTD_DEFS_H_INCLUDED
N
L 47 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\utility" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
N// rel_ops contents not available if namespaces are disabled
N// to avoid ambiguities with other overloaded operators
N
N_RWSTD_NAMESPACE_BEGIN (rel_ops)
Xnamespace rel_ops {
N
N
Ntemplate <class _TypeT>
Ninline bool operator!= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator> (const _TypeT& __x, const _TypeT& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class _TypeT>
Ninline bool operator<= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__y < __x);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator>= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // rel_ops
X}   
N
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.2.2
Ntemplate <class _TypeT, class _TypeU>
Nstruct pair
N{
N    typedef _TypeT first_type;
N    typedef _TypeU second_type;
N
N    first_type  first;
N    second_type second;
N
N    pair (const first_type &__x, const second_type &__y)
N        : first (__x), second (__y) { }
N
N    pair ()
N#ifndef _RWSTD_NO_EMPTY_MEM_INITIALIZER
N        : first (/* lwg issue 265 */), second () { }
N#else
S        : first (first_type ()), second (second_type ()) { }
N#endif   // _RWSTD_NO_EMPTY_MEM_INITIALIZER
N
N    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeX, class _TypeY>
N    pair (const pair <_TypeX, _TypeY> &__rhs) 
N        : first (__rhs.first), second (__rhs.second) { }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N};
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __x.first == __y.first && __x.second == __y.second; 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x == __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return    __x.first < __y.first
N           || (!(__y.first < __x.first) && __x.second < __y.second); 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __y < __x;
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x < __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__y < __x);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline pair<_TypeT, _TypeU>
Nmake_pair (const _TypeT &__x, const _TypeU &__y)
N{
N    return pair<_TypeT, _TypeU>(__x, __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_UTILITY_INCLUDED
N
L 50 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N
N#include <rw/_iterbase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 1
N/***************************************************************************
N *
N * _iterbase.h - Definitions of iterator primitives
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERBASE_H_INCLUDED
N#define _RWSTD_ITERBASE_H_INCLUDED
N
N#include <rw/_defs.h>
N#include _RWSTD_CSTDDEF
X#include <cstddef>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstddef" 1
N/*
N * C++ header for C header stddef.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N
N#ifndef __cstddef
N#define __cstddef
N#define __ARMCLIB_VERSION 5060019
N
N  #define __STDDEF_NO_EXPORTS 1
N  #include <stddef.h>
N  #undef __STDDEF_NO_EXPORTS
N
N  #undef __stddef_h  // later inclusion of stddef.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstddef */
N
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 24.3.1 - Iterator traits
Ntemplate <class _Iterator>
Nstruct iterator_traits
N{
N    typedef _TYPENAME _Iterator::value_type        value_type;
X    typedef typename _Iterator::value_type        value_type;
N    typedef _TYPENAME _Iterator::difference_type   difference_type;
X    typedef typename _Iterator::difference_type   difference_type;
N    typedef _TYPENAME _Iterator::pointer           pointer;
X    typedef typename _Iterator::pointer           pointer;
N    typedef _TYPENAME _Iterator::reference         reference;
X    typedef typename _Iterator::reference         reference;
N    typedef _TYPENAME _Iterator::iterator_category iterator_category;
X    typedef typename _Iterator::iterator_category iterator_category;
N};
N
N
N// 24.3.3 - Standard iterator tags
Nstruct input_iterator_tag { };
Nstruct output_iterator_tag { };
Nstruct forward_iterator_tag : public input_iterator_tag { };
Nstruct bidirectional_iterator_tag : public forward_iterator_tag { };
Nstruct random_access_iterator_tag : public bidirectional_iterator_tag { };
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<_TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef value_type*                pointer;
N    typedef value_type&                reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<const _TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef const value_type*          pointer;
N    typedef const value_type&          reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.2 - Basic iterator
Ntemplate <class _Category, class _TypeT,  
N          class _Distance _RWSTD_SIMPLE_DEFAULT (ptrdiff_t), 
X          class _Distance = ptrdiff_t, 
N          class _Pointer _RWSTD_SIMPLE_DEFAULT (_TypeT*), 
X          class _Pointer = _TypeT*, 
N          class _Reference _RWSTD_SIMPLE_DEFAULT (_TypeT&)>
X          class _Reference = _TypeT& >
Nstruct iterator
N{
N    typedef _TypeT     value_type;
N    typedef _Distance  difference_type;
N    typedef _Pointer   pointer;
N    typedef _Reference reference;
N    typedef _Category  iterator_category;
N};
N
N
N// returns the category of an iterator
Ntemplate <class _TypeT>
Ninline random_access_iterator_tag __iterator_category (const _TypeT*)
N{
N    return random_access_iterator_tag ();
N}
N
N
Ntemplate <class _Category, class _TypeT, class _Distance, 
N          class _Pointer, class _Reference> 
Ninline _Category
N__iterator_category (const iterator<_Category, _TypeT,
N                                    _Distance, _Pointer, _Reference>&)
N{
N    typedef _TYPENAME iterator<_Category, _TypeT, _Distance, _TypeT*,
X    typedef typename iterator<_Category, _TypeT, _Distance, _TypeT*,
N                               _TypeT&>::iterator_category _IterCategory;
N
N    return _IterCategory ();
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_input_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_bidirectional_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_random_access_iterator (_Tag)
N{
N    return false;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_input_iterator (input_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_random_access_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::value_type*
Xinline typename iterator_traits<_Iterator>::value_type*
N__value_type (const _Iterator*)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _TypeT*
S__value_type (const iterator<_Category, _TypeT, _Distance,
S                             _Pointer, _Reference>*)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline _TypeT* __value_type (const _TypeT* const*)
S{
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::difference_type*
Xinline typename iterator_traits<_Iterator>::difference_type*
N__distance_type (_Iterator)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _Distance* 
S__distance_type (iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline ptrdiff_t* __distance_type (const _TypeT*)
S{ 
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.4 - Iterator operations
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __advance (_InputIterator &__it, _Distance __n, input_iterator_tag)
N{
N    _RWSTD_ASSERT (__n == 0 || __n > 0);
X    ((void)0);
N
N    while (__n > 0) {
N        --__n;
N        ++__it;
N    }
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __advance (_ForwardIterator &__it, _Distance __n,
N                       forward_iterator_tag)
N{
N    __advance (__it, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __advance (_BidirectionalIterator &__it, _Distance __n, 
N                       bidirectional_iterator_tag)
N{
N    if (__n > 0)
N        __advance (__it, __n, input_iterator_tag ());
N    else
N        while (__n) {
N            ++__n;
N            --__it;
N        }
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __advance (_RandomAccessIterator& __it, _Distance __n, 
N                       random_access_iterator_tag)
N{
N    __it += __n;
N}
N
N
N// 24.3.4, p2
Ntemplate <class _InputIterator, class _Distance>
Ninline void advance (_InputIterator& __it, _Distance __n)
N{
N    __advance (__it, __n, _RWSTD_ITERATOR_CATEGORY (_InputIterator, __it));
X    __advance (__it, __n, typename std::iterator_traits< _InputIterator > ::iterator_category ());
N}
N
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __distance (const _InputIterator &__first,
N                        const _InputIterator &__last,
N                        _Distance            &__n,
N                        input_iterator_tag)
N{
N    for (_InputIterator __it = __first; __it != __last; ++__it)
N        ++__n;
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __distance (const _ForwardIterator &__first,
N                        const _ForwardIterator &__last,
N                        _Distance              &__n,
N                        forward_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __distance (const _BidirectionalIterator &__first,
N                        const _BidirectionalIterator &__last, 
N                        _Distance                    &__n,
N                        bidirectional_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __distance (const _RandomAccessIterator &__first,
N                        const _RandomAccessIterator &__last, 
N                        _Distance                   &__n,
N                        random_access_iterator_tag)
N{
N    __n = __last - __first;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// 24.3.4, p4
Ntemplate <class _ForwardIterator>
Ninline _TYPENAME iterator_traits<_ForwardIterator>::difference_type
Xinline typename iterator_traits<_ForwardIterator>::difference_type
Ndistance (const _ForwardIterator &__first, const _ForwardIterator &__last)
N{
N    _TYPENAME iterator_traits<_ForwardIterator>::difference_type __n = 0;
X    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;
N
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N
N    return __n;
N}
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_EXT_VOID_DISTANCE
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void distance (const _ForwardIterator &__first,
N                      const _ForwardIterator &__last,
N                      _Distance              &__n)
N{
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N}
N
N#endif   // _RWSTD_NO_EXT_VOID_DISTANCE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_distance: Same purpose as 3-parameter distance function, but
N// with return value.
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline _Distance
N__rw_distance (const _ForwardIterator &__first,
N               const _ForwardIterator &__last,
N               _Distance               __n)
N{
N    _STD::__distance (__first, __last, __n,
X    std::__distance (__first, __last, __n,
N                      _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                      typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N    return __n;
N}
N
N
N_RWSTD_NAMESPACE_END // __rw
X} 
N
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// __rw_debug_iter - iterator adapter with debugging support
S// _Iterator is either iterator or const_iterator; if the latter,
S// _MutableIterator should be iterator to allow for implicit
S// conversions from non-const (mutable) to const_iterator objects
S
S
Stemplate <class _Container, class _Iterator, class _MutableIterator>
Sclass __rw_debug_iter
S{
S    typedef _Container                                container_type;
S    typedef _Iterator                                 iterator_type;
S    typedef _STD::iterator_traits<iterator_type>      traits_type;
S
Spublic:
S
S    typedef _TYPENAME traits_type::value_type         value_type;
S    typedef _TYPENAME traits_type::difference_type    difference_type;
S    typedef _TYPENAME traits_type::reference          reference;
S    typedef _TYPENAME traits_type::pointer            pointer;
S    typedef _TYPENAME traits_type::iterator_category  iterator_category;
S
S    typedef __rw_debug_iter <container_type, _MutableIterator,
S                             _MutableIterator>        _C_mutable_iterator;
S
S    __rw_debug_iter (): _C_cont (0) { }
S
S    __rw_debug_iter (const container_type &__cont, const iterator_type &__it)
S        : _C_iter (__it), _C_cont (&__cont) { }
S
S    // no copy ctor other than the one below is defined
S    // will use a compiler generated one if _Iterator != _MutableIterator
S    __rw_debug_iter (const _C_mutable_iterator &__rhs)
S        : _C_iter (__rhs._C_iter), _C_cont (__rhs._C_cont) { }
S
S    __rw_debug_iter& operator= (const __rw_debug_iter &__rhs) {
S        if (this != &__rhs) {
S            _C_iter = __rhs._C_iter;
S            _C_cont = __rhs._C_cont;
S        }
S        return *this;
S    }
S
S    reference operator* () const {
S        _RWSTD_ASSERT (_C_is_dereferenceable ());
S        return *_C_iter;
S    }
S
S    reference operator[] (difference_type __n) const {
S        _RWSTD_ASSERT ((*this + __n)._C_is_dereferenceable ());
S        return _C_iter [__n];
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator-> () const);
S
S    __rw_debug_iter& operator++ () {
S        _RWSTD_ASSERT (!_C_is_end ());
S        return ++_C_iter, *this;
S    }
S
S    __rw_debug_iter& operator-- () {
S        _RWSTD_ASSERT (!_C_is_begin ());
S        return --_C_iter, *this;
S    }
S
S    __rw_debug_iter operator++ (int) {
S        __rw_debug_iter __tmp = *this;
S        return ++*this, __tmp;
S    }
S
S    __rw_debug_iter operator-- (int) {
S        __rw_debug_iter __tmp = *this;
S        return --*this, __tmp;
S    }
S
S    __rw_debug_iter& operator+= (difference_type __n) {
S        _C_iter += __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter& operator-= (difference_type __n) {
S        _C_iter -= __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter operator+ (difference_type __n) const {
S        return __rw_debug_iter (*this) += __n;
S    }
S
S    __rw_debug_iter operator- (difference_type __n) const {
S        return __rw_debug_iter (*this) -= __n;
S    }
S
S    bool _C_is_begin () const {
S        return _C_cont && _C_cont->begin () == *this;
S    }
S
S    bool _C_is_end () const {
S        return _C_cont && _C_cont->end () == *this;
S    }
S
S    bool _C_is_dereferenceable () const {
S        return !_C_is_end ();
S    }
S
S    bool _C_valid_range (const __rw_debug_iter &__it) const {
S        return _C_cont && _C_cont == __it._C_cont;
S    }
S
S    const iterator_type& base () const {
S        return _C_iter;
S    }
S
S    iterator_type& base () {
S        return _C_iter;
S    }
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S
S    // operators are templatized to assure const/non-const symmetry
S
S    template <class _Iter>
S    difference_type
S    operator- (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        _RWSTD_ASSERT (_C_cont && _C_cont == __rhs._C_cont);
S        return _C_iter - __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator== (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter == __rhs._C_iter;
S    }
S    
S    template <class _Iter>
S    bool
S    operator< (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter < __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator!= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter != __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator<= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter <= __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator> (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter > __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator>= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter >= __rhs._C_iter;
S    }
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S    iterator_type         _C_iter;   // wrapped iterator
S    const container_type *_C_cont;   // associated container
S};
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
S
S#ifndef _RWSTD_NO_NONDEDUCED_CONTEXT
S# define _RWSTD_CONT_DIFF_TYPE _TYPENAME _Cont::difference_type 
S#else
S# define _RWSTD_CONT_DIFF_TYPE ptrdiff_t 
S#endif
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> 
Soperator+ (_RWSTD_CONT_DIFF_TYPE                               __n,
S           const _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> &__x)
S{
S    return __x + __n;
S}
S
S#undef _RWSTD_CONT_DIFF_TYPE 
S
S
S#ifdef _RWSTD_NO_MEMBER_TEMPLATES
S
S// with no support for member templates namespace-scope (non-member)
S// operators must be used - these will cause ambiguities with those
S// in std::rel_ops if the latter are found during lookup
S
S
S
S// _Iter1 may differ from _Iter2 if the function operands are const
S// and non-const iterators, respectively (allows symmetry)
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline _TYPENAME _Cont::difference_type
Soperator- (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter - __y._C_iter;
S}
S    
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator== (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __x._C_iter == __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator< (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter < __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator!= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x == __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator<= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__y < __x);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator>= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x < __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator> (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __y < __x;
S}
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S_RWSTD_NAMESPACE_END   // std
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S
S#define _RWSTD_DEBUG_ITER(cont, it, mutit) __rw_debug_iter< cont, it, mutit >
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_valid_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S                  const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return __first._C_cont && __first._C_cont == __last._C_cont;
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_valid_range (const _Iterator &, const _Iterator &)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_in_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return    __rw_valid_range (__first, __it)
S           && __rw_valid_range (__it, __last);
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_in_range (const _Iterator&, const _Iterator&, const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_dereferenceable (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it)
S{
S    return __it._C_is_dereferenceable ();
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_dereferenceable (const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _TypeT>
Sinline bool
S__rw_dereferenceable (const _TypeT *__ptr)
S{
S    return 0 != __ptr;
S}
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#undef _RWSTD_DEBUG_ITER
S
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#endif   // _RWSTD_ITERBASE_H_INCLUDED
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <rw/_mutex.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 1
N/***************************************************************************
N *
N * _mutex.h - Definitions of classes and inline functions providing MT safety
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************
N *
N * There are two mutex classes:
N *
N * __rw::__rw_mutex_base - a POD-type class with no ctor or dtor (POSIX
N * and Solaris threads only) suitable for mutex objects with static storage
N * duration. On POSIX threads, these objects are fully constructed at static
N * initialization time and initialized via assignment by 
N * PTHREAD_MUTEX_INITIALIZER, while on Solaris threads they do not need to be
N * initialized at all. On platforms such as Win32/64 that do not support static
N * initialization this class does define a ctor that initializes the object
N * by the appropriate thread library call.
N *
N * __rw::__rw_mutex - a non-POD-type class derived from __rw::__rw_mutex_base
N * with explicitly defined ctor and dtor suitable for mutex member variables.
N * On platforms such as Win32/64 that do not support static initialization this
N * class does not define its own ctor and dtor and simply defers the
N * initialization and destruction to its base.
N *
N * __rw::__rw_static_mutex<> - a POD-type class template, defined on
N * platforms such as POSIX or Solaris threads that support static
N * initialization of mutexes, containing a single public static data member
N * of the __rw::__rw_mutex_base class. The static member object is returned
N * from the factory function template __rw::__rw_get_static_mutex<>().
N *
N * On platforms such as Win32/64 that do not support static initialization
N * of mutex objects the factory template function
N * __rw::__rw_get_static_mutex<>() defines and dynamically initializes
N * a static local reference to an object of the __rw::__rw_mutex_base class.
N * The dynamic initialization is done in an MT-safe way (i.e., such that
N * exactly one initialization of the mutex object is guaranteed). On Win32/64
N * this is accomplished by making use of the InterlockedIncrement() API call,
N * everywhere else there exists a small potential for a race condition and
N * the risk of the object being initialized multiple times. The reference is
N * initialized to refer to a properly aligned static data buffer to prevent
N * the destruction of the actual object at program termination, and the object
N * itself is constructed in this buffer space via a call to placement new.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MUTEX_H_INCLUDED
N#define _RWSTD_MUTEX_H_INCLUDED
N
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTRING
X#include <cstring>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 1
N/*
N * C++ header for C header string.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstring
N#define __cstring
N#define __ARMCLIB_VERSION 5060019
N
N  #define __STRING_NO_EXPORTS 1
N  #include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Nextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
Nextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Nextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
N    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Sextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strchr(char * __s, int __c)
N    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
N    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strrchr(char * __s, int __c)
N    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strstr(char * __s1, const char * __s2)
N    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
N    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 2
N  #undef __STRING_NO_EXPORTS
N
N  #undef __string_h  // later inclusion of string.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstring */
N
L 78 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 2
N
N#ifdef _RWSTD_MULTI_THREAD
S
S
S#include <rw/_exception.h>
S
S
S#if defined (_RWSTD_SOLARIS_THREADS)  // assuming Solaris 2.1 or greater
S
S// SunOS 5.7 Threads Library:
S//   "A statically  allocated  mutex does  not  need to be explicitly
S//   initialized; by default, a statically allocated mutex is initialized
S//   with  all  zeros and its scope is set to be within the calling
S//   process."
S
S#  include <synch.h>
S#  include <thread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      mutex_init (&mutex, USYNC_THREAD, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                mutex_t
S
S#elif defined (_RWSTD_POSIX_D10_THREADS)
S
S// LinuxThreads man page:
S//   "Variables of type pthread_mutex_t can also be initialized
S//    statically, using the constants  PTHREAD_MUTEX_INITIALIZER
S//    (for fast mutexes), PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
S//    (for recursive mutexes), and PTHREAD_ERRORCHECK_MUTEX_INI-
S//    TIALIZER_NP (for error checking mutexes)."
S//    ...
S//    "Attempting to initialize an already initialized mutex results
S//    in undefined behavior."
S
S#  include <pthread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      pthread_mutex_init (&mutex, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S#elif defined (_RWSTD_DCE_THREADS)
S
S#  if defined (_RWSTD_NO_DCE_PTHREAD_H)
S#    include <pthread.h>
S#  else
S#    include <dce/pthread.h>
S#  endif
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          pthread_mutex_init (&mutex, pthread_mutexattr_default)
X#  define _RWSTD_MUTEX_INIT(mutex)           pthread_mutex_init (&mutex, pthread_mutexattr_default)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S// DCE doesn't seem to support static mutex initialization
S#  include <new>
S
S#elif defined (_WIN32) || defined (_WIN64)
S
S#  ifdef _RWSTD_NO_FWD_DECLARATIONS
S
S#    include <windows.h>
S#    define _RWSTD_MUTEX_T _RTL_CRITICAL_SECTION
S
S#  else   // if defined (_RWSTD_NO_FWD_DECLARATIONS)
S
S   // avoid #including this header...
S   // #  include <windows.h>
S
Sextern "C" {
S
S// but rather declare these globals here
Sstruct _RTL_CRITICAL_SECTION;
S
S__declspec (dllimport) void __stdcall
SInitializeCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SEnterCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SLeaveCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SDeleteCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) long __stdcall
SInterlockedIncrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedDecrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedExchange (long*, long);
S
S}   // extern "C"
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// fake critical section type
Sunion __rw_critical_section {
S    long _C_pad;   // force alignment
S    char _C_buf [24 /* == sizeof (_RTL_CRITICAL_SECTION) */];
S};
S
S#    define _RWSTD_MUTEX_T _RW::__rw_critical_section
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S#  endif   // _RWSTD_NO_FWD_DECLARATIONS
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Win32/64 throws non-C++ exceptions rather than returning error status
S// from some system calls like most other operating systems do
S
Sinline int __rw_mutex_init (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        InitializeCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_destroy (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        DeleteCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_lock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        EnterCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_unlock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        LeaveCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
S#  define _RWSTD_MUTEX_INIT(mutex)      \
S   __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_INIT(mutex)         __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_DESTROY(mutex)   \
S   __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_DESTROY(mutex)      __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_LOCK(mutex)      \
S   __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_LOCK(mutex)         __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    \
S   __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_UNLOCK(mutex)       __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#elif defined (__OS2__)
S
S#  define INCL_DOSSEMAPHORES
S
S#  include <os2.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
X#  define _RWSTD_MUTEX_INIT(mutex)           DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   DosCloseMutexSem (mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex) \
S          DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
X#  define _RWSTD_MUTEX_LOCK(mutex)           DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    DosReleaseMutexSem (mutex)
S#  define _RWSTD_MUTEX_T                HMTX
S
S#else
S#  error unknown thread environment
S#endif
S
S
S#if defined (__DECCXX)
S   // get declarations of __ATOMIC_XXX intrinsics
S
S#  include <machine/builtins.h>
S
S#endif   // __DECXX
S
S
S#if defined (__GNUG__) && defined (__osf__)
S   // prevent g++ warnings about missing initializers
S   // see <pthread.h> for explanation of _PTHREAD_NOMETER_STATIC
S#  ifndef _PTHREAD_NOMETER_STATIC
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER \
S            { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA, \
S              0, 0, 0, 0, 0, 0 }
X#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER             { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA,               0, 0, 0, 0, 0, 0 }
S#  else   // if defined (_PTHREAD_NOMETER_STATIC)
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER
S            { 0, _PTHREAD_MVALID | _PTHREAD_MVF_STA, 0, 0, 0, 0, 0, 0 }
S#  endif   // _PTHREAD_NOMETER_STATIC
S#elif defined (__GNUG__) && defined (__sgi__)
S   // prevent g++ warnings about a partly bracketed initializer
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }
S#else
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
S#endif
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// a using declaration (rather than a directive)
S// used to work around yet another MSVC 6.0 bug
S_USING (std::exception);
S
Sclass __rw_thread_error : public exception
S{
Spublic:
S    __rw_thread_error () _THROWS (())
S    : exception () { }
S
S    virtual const char* what () const _THROWS (()) {
S        return "thread synchronization error";
S    }
S};                            
S
S
S// POD type with no user-defined ctor or dtor facilitates static
S// initialization of mutex objects with static storage duration
S// (important during library initialziation time)
Sclass _RWSTD_EXPORT __rw_mutex_base
S{
Spublic:
S
S    void _C_acquire () {
S#if !defined (__HP_aCC) || __HP_aCC > 32700
S        if (0 != _RWSTD_MUTEX_LOCK (_C_mutex))
S            _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR,
S                             "synchronization error");
S#else
S        // working around an HP aCC 3.27 bug JAGac88738
S        _RWSTD_MUTEX_LOCK (_C_mutex);
S#endif   // !defined (__HP_aCC) || __HP_aCC > 32700
S    }
S
S    void _C_release ();
S
S#ifdef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    // static initialization not an option, define ctor and dtor
S    // and make member mutex private
S
S    __rw_mutex_base ();
S
S    ~__rw_mutex_base ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex_base (const __rw_mutex_base&);
S    __rw_mutex_base& operator= (const __rw_mutex_base&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S    _RWSTD_MUTEX_T _C_mutex;   // the real thing
S};
S
S
Sinline void __rw_mutex_base::_C_release ()
S{
S    // we should NOT throw from here as _C_release will typically be called
S    // during the destruction of local objects such as __rw_guard (perhaps
S    // due to another exception)
S    _RWSTD_MUTEX_UNLOCK (_C_mutex);
S}
S
S
S// non-POD type, always initializes mutex data member via a function call
Sclass  _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
S{
Spublic:
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    __rw_mutex ();
S
S    ~__rw_mutex ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex (const __rw_mutex&);
S    __rw_mutex& operator= (const __rw_mutex&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S};
S
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S// helper factory class - static member is guranteed to be constructed
S// during static initialization; objects of this POD class are not
S// destroyed during program termination (important to allow them
S// to be used in dtors of other objects with static storage duration)
Stemplate <class _TypeT>
Sstruct __rw_static_mutex
S{
S    static __rw_mutex_base _C_mutex;
S};
S
S
Stemplate <class _TypeT>
S__rw_mutex_base __rw_static_mutex<_TypeT>::_C_mutex
S
S#ifdef _RWSTD_POSIX_D10_THREADS
S
S    = { _RWSTD_PTHREAD_MUTEX_INITIALIZER }
S
S#endif   // _RWSTD_POSIX_D10_THREADS
S        ;
S
S// explicitly instantiated to work around a g++ 2.95.2 bug on COFF systems
S// (such as IBM AIX or DEC OSF1) where it "forgets" to do so implicitly for
S// explicitly initialized static data members
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<int>);
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<size_t>);
S
S
Sinline __rw_mutex::__rw_mutex ()
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::__rw_mutex_base ()
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{ 
S    if (0 != _RWSTD_MUTEX_INIT (_C_mutex))
S        _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR, "synchronization error");
S}
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Sinline __rw_mutex::~__rw_mutex () 
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::~__rw_mutex_base () 
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{
S    _RWSTD_MUTEX_DESTROY (_C_mutex);
S}
S
S
S// mutex factory function avoids problematic initialization dependencies
S// introduced by definitions of mutexes with static storage duration
S// instead of defining a static mutex member that may not be initialized
S// before first use, a non-local class may either declare a unique type
S// (enum or class) or use itself as this type, and call this template
S// function with a ptr to that type to obtain an initialized mutex object
S// that is the same for each unique type passed to the function
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Stemplate <class _TypeT>
Sinline
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S{
S    // POD mutex already initialized during static initialization
S    return __rw_static_mutex<_TypeT>::_C_mutex;
S}
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
S#ifdef _INLINE_WITH_STATICS
S
Stemplate <class _TypeT>
S_INLINE_WITH_STATICS
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#else    // if !defined (_INLINE_WITH_STATICS)
S
Stemplate <class _TypeT>
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#endif   // _INLINE_WITH_STATICS
S
S{
S    // allocate properly aligned memory for static mutex (necessary
S    // to prevent static local mutex from being destroyed during
S    // program termination)
S    union __mutex_buf_t {
S        long double __pad;   // force alignment (must be first)
S        char        __buf [sizeof (__rw_mutex_base)];
S    };
S
S    // using a named union to work around a bug in HP aCC 3.14.10 (JAGad03246)
S    static __mutex_buf_t __mutex_buf;
S
S    // initialize mutex reference to refer to the static buffer space
S    __rw_mutex_base &__mutex =
S        _RWSTD_REINTERPRET_CAST (__rw_mutex_base&, __mutex_buf);
S
S    // keep track of number of mutex initialization attempts
S    // although `init' may reach a value greater than 1, `mutex'
S    // will (should) never be multiply initialized
S
S    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
S    // sorry: semantics of inline function static data are wrong (you'll wind
S    // up with multiple copies)
S    static volatile long __cntr /* = 0 */;   // initialization counter
S
S#if defined (_WIN32) || defined (_WIN64)
S    // MT safe
S    if (0 == __cntr && 1 == InterlockedIncrement ((long*)&__cntr))
S#else
S    // not so safe (volatile should help)
S    if (0 == __cntr && 1 == ++__cntr)
S#endif   // _WIN32
S
S    {
S        // manually initialize `mutex' via a call to placement new
S        new (&__mutex) __rw_mutex_base ();
S
S        // indicate that `mutex' has been fully initialized
S        // (unlikely that we'll have more than 1000 threads)
S        __cntr += 1000;
S    }
S    else
S        // busywait until `mutex' has been completely initialized
S        while (__cntr < 1000);
S
S    return __mutex;
S}
S
S#endif   //_RWSTD_NO_STATIC_MUTEX_INIT
S
S
S// clean up
S#undef _RWSTD_MUTEX_LOCK
S#undef _RWSTD_MUTEX_UNLOCK
S#undef _RWSTD_MUTEX_T
S
S
S// allows safe use of a mutex in the presence of exceptions
Sclass __rw_guard
S{
S    __rw_mutex_base *_C_mutex;
S
S    // undefined
S    __rw_guard& operator= (const __rw_guard&);
S    
Spublic:
S
S    __rw_guard (__rw_guard &__rhs)
S        : _C_mutex (__rhs._C_mutex) {
S        __rhs._C_mutex = 0;
S    }
S
S    __rw_guard (__rw_mutex_base &__mutex): _C_mutex (&__mutex) {
S        _C_mutex->_C_acquire ();
S    }
S
S    __rw_guard (__rw_mutex_base *__mutex): _C_mutex (__mutex) {
S        if (_C_mutex)
S            _C_mutex->_C_acquire ();
S    }
S
S    ~__rw_guard () {
S        if (_C_mutex)
S            _C_mutex->_C_release ();
S    }
S
S    __rw_mutex_base* _C_set (__rw_mutex_base *__mutex) {
S        __rw_mutex_base *__tmp = _C_mutex;
S        return _C_mutex = __mutex, __tmp;
S    }
S};
S
S
S// base class for obects required to guarantee some degree of MT safety
Sstruct _RWSTD_EXPORT __rw_synchronized
S{
S    __rw_mutex _C_mutex;
S
S    void _C_lock () {
S        _C_mutex._C_acquire ();
S    }
S
S    void _C_unlock () {
S        _C_mutex._C_release ();
S    }
S
S    __rw_guard _C_guard () {
S        __rw_guard __guard (_C_mutex);
S        return __guard;
S    }
S};
S
S
S// helper functions for atomic value [in|de]crement and exchange
S// the functions are atomic with respect to each other as long as
S// they are passed the same mutex by the callers
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return ++__t;
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return --__t;
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u,
S                             __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    _TypeT __tmp = __t;
S    __t = __u;
S    return __tmp;
S}
S
S
S// for use on class statics or on namespace-scope variables
S// the unused argument is only here so that all functions can be
S// called from the same set of macros
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_preincrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_predecrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
S{
S    return __rw_atomic_exchange (__t, __u,
S                                 __rw_get_static_mutex ((_TypeT*)0));
S}
S
S/********************** DEC CXX **************************************/
S
S#if defined (__DECCXX) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// __ATOMIC_[DE|IN]CREMENT_[LONG|QUAD] and __ATOMIC_EXCH_[LONG|QUAD] are
S// intrinsic functions declared in <machine/builtins.h> that atomically
S// modify their argument and return its original value (__ATOMIC_XXX_LONG
S// is misnamed -- it actually operates on an int, not a long)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_LONG (&__x);
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_QUAD (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    return __ATOMIC_DECREMENT_LONG (&__x) - 1;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return __ATOMIC_DECREMENT_QUAD (&__x) - 1;
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    return __ATOMIC_EXCH_LONG (&__x, __y);
S}
S
S
Sinline
Sunsigned __rw_atomic_exchange (unsigned &__x, unsigned __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned&, __x),
S                                 _RWSTD_STATIC_CAST (int, __y), false);
S}
S
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return __ATOMIC_EXCH_QUAD (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S/********************** gcc/i86 **************************************/
S
S#elif defined (__i386__) && defined (__GNUG__)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; addl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; subl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S/********************** WIN 32/64 ************************************/
S
S#elif defined (_WIN32) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// Interlocked[In|De]crement functions atomically modify their argument
S// and return the new value
S
S// InterlockedExchange atomically sets the value pointed to by the first
S// argument to that of the second argument and returns the original value
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return InterlockedIncrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return InterlockedDecrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return InterlockedExchange (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S#endif   // _WIN64
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_preincrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_predecrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y,
S                                   __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y,
S                              __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   __mutex));
S}
S
S#endif   // _WIN64
S
S#endif   // _WIN32
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
N#else   // if !defined (_RWSTD_MULTI_THREAD)
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// atomic in a single-threaded environment
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N
N// dummy classes used as a base class in single-threaded environments
N
Nstruct __rw_mutex_base
N{
N    void _C_acquire () { }
N
N    void _C_release () { }
N};
N
N
Nstruct _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
Xstruct  __rw_mutex: public __rw_mutex_base
N{
N};
N
N
Nstruct __rw_guard
N{
N    __rw_guard (__rw_mutex_base&) { }
N
N    __rw_guard (__rw_mutex_base*) { }
N
N    __rw_mutex_base* _C_set (__rw_mutex_base*) {
N        return 0;
N    }
N};
N
N
Nstruct __rw_synchronized
N{
N    // static so that it takes up no room
N    static __rw_mutex _C_mutex;
N
N    void _C_lock () { }
N
N    void _C_unlock () { }
N
N    __rw_guard _C_guard () {
N        return __rw_guard (_C_mutex);
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// available in all environments (ST and MT), used along with
N// __rw_atomic_exchange<>() from conditional expressions in iostreams
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_ordinary_exchange (_TypeT &__t, const _TypeU &__u)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MUTEX_H_INCLUDED
N
L 53 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// [de]allocate storage (in bytes)
N_RWSTD_EXPORT void* __rw_allocate (_RWSTD_C::size_t, int = 0);
X void* __rw_allocate (std::size_t, int = 0);
N_RWSTD_EXPORT void  __rw_deallocate (void*, _RWSTD_C::size_t, int = 0);
X void  __rw_deallocate (void*, std::size_t, int = 0);
N
N// this function returns a suggested new capacity for a container needing
N// more room; see stddefs.h for an explanation of these macro parameters;
N// the _Container template parameter allows more specialized overloads
N// for customization
Ntemplate <class _Container>
Ninline _RWSTD_C::size_t __rw_new_capacity (_RWSTD_C::size_t __size, const _Container*)
Xinline std::size_t __rw_new_capacity (std::size_t __size, const _Container*)
N{
N    _RWSTD_C::size_t __cap = _RWSTD_STATIC_CAST (_RWSTD_C::size_t,
N                                       _RWSTD_INCREASE_CAPACITY(__size)
N                                       /*__size * _RWSTD_NEW_CAPACITY_RATIO*/);
X    std::size_t __cap = static_cast< std::size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));
N    return (__size += _RWSTD_MINIMUM_NEW_CAPACITY) > __cap ? __size : __cap;
X    return (__size += std::size_t (32)) > __cap ? __size : __cap;
N}
N
N
Ntemplate <class _TypeT>
Ninline void __rw_destroy (_TypeT &__ref)
N{
N    __ref.~_TypeT ();
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_construct (_TypeT* __p, const _TypeU& __val)
N{
N    new (__p) _TypeT (__val);
N}
N
N
Ntemplate <class _ForwardIterator> 
Nvoid __rw_destroy (_ForwardIterator __first, _ForwardIterator __last)
N{
N    for (; __first != __last; ++__first)
N        __rw_destroy (*__first);
N}
N
N
N#ifndef _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N// for compilers that don't optimize "empty" loops
Ntemplate <class _TypeT> 
Ninline void __rw_destroy (_TypeT**, _TypeT**)
N{ }
N
N#endif   // _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _TypeT> class
Nallocator;
N
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nclass allocator<void>
N{
Npublic:
N    typedef void*       pointer;
N    typedef const void* const_pointer;
N    typedef void        value_type;
N   
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N#endif /* _RWSTD_ALLOCATOR */
N    
N};
N
N
Ntemplate <class _TypeT>
Nclass allocator
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef _TypeT              value_type;
N    typedef value_type*         pointer;
N    typedef const value_type*   const_pointer;
N    typedef value_type&         reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator&
N    operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N    pointer address (reference __x) const { 
N        return &__x; 
N    }
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) {
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (pointer __p, size_type __n)
N#else
S    void deallocate (void* __p, size_type __n)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (__p, __n);
X        __rw::__rw_deallocate (__p, __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return size_type (~0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (pointer __p, const_reference __val) {
N        _RW::__rw_construct (__p, __val);
X        __rw::__rw_construct (__p, __val);
N    }
N    
N    void destroy (pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (*__p);
X        __rw::__rw_destroy (*__p);
N    }
N};
N
N
N#if    !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_EXT_CONST_ALLOCATOR)
X#if    !0L     && !0L
N
N// extension: allocates/constructs/destroys const elements
N
Ntemplate <class _TypeT>
Nclass allocator<const _TypeT>
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef const _TypeT        value_type;
N    typedef const value_type*   pointer;
N    typedef const value_type*   const_pointer;
N    typedef const value_type&   reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator& operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    allocator& operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    const_pointer
N    allocate (size_type __n, allocator<void>::const_pointer = 0) { 
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (const_pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< const_pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (const_pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (const_pointer __p, size_type __n /* elements */)
N#else
S    void deallocate (const void* __p, size_type __n /* bytes */)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (_RWSTD_CONST_CAST (_TypeT*, __p), __n);
X        __rw::__rw_deallocate (const_cast< _TypeT* >(__p), __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return ~size_type (0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (const_pointer __p, const_reference __val) {
N        _RW::__rw_construct (_RWSTD_CONST_CAST (_TypeT*, __p), __val);
X        __rw::__rw_construct (const_cast< _TypeT* >(__p), __val);
N    }
N    
N    void destroy (const_pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (_RWSTD_CONST_CAST (_TypeT&, *__p));
X        __rw::__rw_destroy (const_cast< _TypeT& >(*__p));
N    }
N};
N
N#endif   // !_RWSTD_NO_CLASS_PARTIAL_SPEC && !_RWSTD_NO_EXT_CONST_ALLOCATOR)
N
N
N// allocator_interface provides all types and typed functions.  Memory
N// allocated as raw bytes using the class provided by the Allocator
N// template parameter.  allocator_interface casts appropriately.
N//
N// Multiple allocator_interface objects can attach to a single 
N// allocator, thus allowing one allocator to allocate all storage
N// for a container, regardless of how many types are involved.
N//
N// The only real restriction is that pointer and reference are
N// hard coded as _TypeT* and _TypeT&.  Partial specialization would 
N// get around this.
N//
N#ifndef _RWSTD_ALLOCATOR
S
Stemplate <class _Allocator, class _TypeT>
Sclass allocator_interface 
S{
Spublic:
S    typedef _Allocator                                allocator_type;
S    typedef _TypeT                                    value_type;
S    typedef value_type*                               pointer;
S    typedef const value_type*                         const_pointer;
S    typedef value_type&                               reference;
S    typedef const value_type&                         const_reference;
S    typedef _TYPENAME allocator_type::size_type       size_type;
S    typedef _TYPENAME allocator_type::difference_type difference_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface()  _THROWS (())  { }
S
S    allocator_interface (const allocator_type &__alloc)  _THROWS (())
S    : _C_alloc (__alloc) { }
S
S    operator allocator_type& () {
S        return _C_alloc;
S    }
S
S    pointer address (reference __x) { 
S        return &__x;
S    }
S  
S    size_type max_size () const { 
S        return _C_alloc.max_size () / sizeof (value_type);
S    }
S
S    pointer allocate (size_type __n, const void* __p = 0) {
S        //using c-style cast to perform reinterpret-cast & const-cast in 1 step
S        return (pointer)_C_alloc.allocate (__n * sizeof (value_type),
S                                           (pointer) __p );
S    }
S
S    void deallocate (pointer __p, size_type __n) {
S        _C_alloc.deallocate (__p, __n);
S    }
S
S    void construct (pointer __p, const_reference __val) const {
S        _RW::__rw_construct(__p, __val);
S    }
S
S    void destroy (pointer __p) const {
S        _RWSTD_ASSERT (0 != __p);
S        _RW::__rw_destroy (*__p);
S    }
S};
S
S
S_RWSTD_SPECIALIZED_CLASS
Sclass allocator_interface<allocator<void>, void> 
S{
Spublic:
S    typedef allocator<void> allocator_type;
S    typedef void*           pointer;
S    typedef const void*     const_pointer;      
S    typedef void            value_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface () _THROWS (()) { }
S
S    allocator_interface (const allocator<void>& __rhs) _THROWS (())
S    : _C_alloc (__rhs) { }
S
S};
S
S
Stemplate <class _TypeT, class _TypeU, class _TypeV, class _TypeW>
Sinline bool
Soperator== (const allocator_interface<_TypeT, _TypeU>&, 
S            const allocator_interface<_TypeV, _TypeW>&) _THROWS (())
S{
S    return true;
S}
S
N#endif  // _RWSTD_ALLOCATOR
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  _THROWS (())
Xoperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const allocator<_TypeT>& __x,
N            const allocator<_TypeU>& __y)  _THROWS (())
X            const allocator<_TypeU>& __y)  
N{
N    return !(__x == __y);
N}
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.4.2
Ntemplate <class _OutputIterator, class _TypeT>
Nclass raw_storage_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
N    _OutputIterator _C_iter;
Npublic:
N
N    // for completeness and genericity
N    typedef _OutputIterator iterator_type;
N
N    // 20.4.2, p2
N    _EXPLICIT raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
X    explicit raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
N
N    // 20.4.2, p3
N    raw_storage_iterator& operator* () {
N        return *this;
N    }
N
N    // 20.4.2, p4
N    raw_storage_iterator& operator= (const _TypeT& __rhs) {
N        ::new (&(*_C_iter)) _TypeT (__rhs);
N        return *this;
N    }
N
N    // 20.4.2, p6
N    raw_storage_iterator& operator++ () {
N        ++_C_iter;
N        return *this;
N    }
N
N    // 20.4.2, p7
N    raw_storage_iterator operator++ (int) {
N        raw_storage_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_indestructible specializations should be objects with static
N// storage duration that must "survive" all other static objects and that
N// do not need to be destroyed; this is a POD
Ntemplate <class _TypeT>
Nclass __rw_indestructible
N{
N    union _C_data_t {
N        char        _C_data;      // data to back _TypeT up with 
N        long double _C_padding;   // make sure data is suitably aligned
N    };
N
N    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };
N
N    _C_data_t _C_data [_C_n];     // raw storage for an object of _TypeT
N
Npublic:
N    typedef _TypeT            value_type;
N    typedef value_type&       reference;
N    typedef const value_type& const_reference;
N    typedef value_type*       pointer;
N    typedef const value_type* const_pointer;
N
N    // no ctor to allow static POD initialization (3.6.2, p1)
N
N    // allow this to be used as a an obejct of another type
N    operator reference () {
N        return _RWSTD_REINTERPRET_CAST (reference, *_C_data);
X        return reinterpret_cast< reference >(*_C_data);
N    }
N
N    operator const_reference () const {
N        return _RWSTD_REINTERPRET_CAST (const_reference, *_C_data);
X        return reinterpret_cast< const_reference >(*_C_data);
N    }
N
N    // calls a conversion operator above
N    pointer operator& () {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (reference, *this);
N
N        return &(reference)*this;
N    }
N    
N    // calls a conversion operator above
N    const_pointer operator& () const {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (const_reference, *this);
N
N        return &(const_reference)*this;
N    }
N};
N
N
N#ifdef _INLINE_WITH_STATICS
N
N_INLINE_WITH_STATICS _RWSTD_EXPORT char* __rw_get_static_buf ()
Xinline  char* __rw_get_static_buf ()
N{
N    typedef char _CharBuf [_RWSTD_TMPBUF_SIZE + 1];
X    typedef char _CharBuf [4096 + 1];
N
N    // use `indestructible' to guarantee proper buffer alignment
N    static __rw_indestructible<_CharBuf> __buffer;
N
N    return _RWSTD_STATIC_CAST (char*, __buffer);
X    return static_cast< char* >(__buffer);
N}
N
N
N// [de]allocates a previously allocated temporary buffer
N// the constant _RWSTD_TMPBUF_SIZE controls the size of a static buffer
N// if request for area larger than _RWSTD_TMPBUF_SIZE comes in,
N// space is allocated dynamically, otherwise the static buffer is used
N// return value meaningful only if __n != 0
N_INLINE_WITH_STATICS _RWSTD_EXPORT _STD::pair<void*, _RWSTD_C::size_t>
Xinline  std::pair<void*, std::size_t>
N__rw_reallocate_temp_buffer (void *__p, _RWSTD_C::size_t __size)
X__rw_reallocate_temp_buffer (void *__p, std::size_t __size)
N{
N    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
N    // sorry: semantics of inline function static data are wrong (you'll wind
N    // up with multiple copies)
N
N    static unsigned long __busy /* = 0 */;   // > 0 when buffer in use
N
N    unsigned long __cntr = _RWSTD_ATOMIC_PREINCREMENT (__busy, false);
X    unsigned long __cntr = ++(__busy);
N
N    static char *__buffer = __rw_get_static_buf ();
N
N    if (__p == (void*)__buffer) {
N        __p    = 0;
N        __size = 0;
N
N        // returning buffer, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else
N        ::operator delete (__p);
N
N    if (__size == 0) {
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else if (__size > _RWSTD_TMPBUF_SIZE || __cntr > 1) {
X    else if (__size > 4096 || __cntr > 1) {
N        _TRY {
X         {
N            __p = ::operator new (__size);
N        }
N        _CATCH (...) {
X        while (0) {
N            __p    = 0;
N            __size = 0;
N        }
N
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else {
N        __p = __buffer;
N
N        // buffer used, usage counter stays non-zero
N    }
N
N    return _STD::pair<void*, _RWSTD_C::size_t>(__p, __size);
X    return std::pair<void*, std::size_t>(__p, __size);
N}
N
N#else   // if !defined (_INLINE_WITH_STATICS)
S
S_STD::pair<void*, _RWSTD_C::size_t> _RWSTD_EXPORT
S__rw_reallocate_temp_buffer (void*, _RWSTD_C::size_t);
S
N#endif   // _INLINE_WITH_STATICS
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 20.4.3 only specifies a get_temporary_buffer<>() that takes a ptrdiff_t.
N// We overload on all types so that signed integral types other than ptrdiff_t
N// can be used. This is important in getting algorithms to compile with
N// user-defined iterators (not derived from iterator<...>) whose difference
N// type is something other than ptrdiff_t.
N
N// having this overload is important in some cases for compilers that
N// do not support partial class specialization (and where as a consequence
N// iterator_traits<> isn't available)
Ntemplate <class _TypeT, class _Distance>
Ninline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
N{
N    pair<void*, size_t> __pair =
N        _RW::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
X        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
N
N    return make_pair (_RWSTD_STATIC_CAST (_TypeT*, __pair.first),
X    return make_pair (static_cast< _TypeT* >(__pair . first),
N                      _Distance (__pair.second / sizeof (_TypeT)));
N}
N
N
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N// 20.4.3, p1
Ntemplate <class _TypeT>
Ninline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
N{
N    return get_temporary_buffer (__n, (_TypeT*)0);
N}
N
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N// 20.4.3, p3
Ntemplate <class _TypeT>
Ninline void return_temporary_buffer (_TypeT *__p)
N{
N    _RW::__rw_reallocate_temp_buffer (__p, 0);
X    __rw::__rw_reallocate_temp_buffer (__p, 0);
N}
N
N
N// 20.4.4.1
Ntemplate <class _InputIterator, class _ForwardIterator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            _RW::__rw_construct (&*__res, *__first);
X            __rw::__rw_construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __res);
X        __rw::__rw_destroy (__start, __res);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _InputIterator, class _ForwardIterator, class _Allocator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res,
N                                     _Allocator&      __alloc)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            __alloc.construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __res; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.4.2
Ntemplate <class _ForwardIterator, class _TypeT>
Ninline
Nvoid uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
N                         const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N// 20.4.4.3
Ntemplate <class _ForwardIterator, class _Size, class _TypeT>
Ninline
Nvoid uninitialized_fill_n (_ForwardIterator __first, _Size __n,
N                           const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
Ninline
Nvoid uninitialized_fill_n (_ForwardIter __first, _Size __n,
N                           const _TypeT& __x, _Allocator& __alloc)
N{
N    _ForwardIter __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            __alloc.construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __first; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N#else   // if !defined (_RWSTD_ALLOCATOR)
S
S// Specializations for non-standard allocators.  When vector calls
S// uninitialized_{copy,fill_n} with non-standard allocator, a temporary
S// instance of allocator_interface is passed to these functions.  Since
S// C++ forbids temporaries to be passed as non-const references, we
S// use these specializations to pass a const reference (and we can force
S// allocator_interface members construct & destroy to be const).
S
Stemplate <class _InputIterator, class _ForwardIterator,
S          class _Allocator, class _TypeT>
Sinline _ForwardIterator
Suninitialized_copy (_InputIterator   __first,
S                    _InputIterator   __last,
S                    _ForwardIterator __res,
S                    const allocator_interface<_Allocator, _TypeT>& __alloc)
S{
S    _ForwardIterator __start = __res;
S
S    _TRY {
S        for (; __first != __last; ++__first, ++__res)
S            __alloc.construct (&*__res, *__first);
S    }
S    _CATCH (...) {
S        for (; __start != __res; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S
S    return __res;
S}
S
Stemplate <class _ForwardIter, class _Size,
S          class _TypeT, class _Allocator, class _TypeU>
Sinline void
Suninitialized_fill_n (_ForwardIter __first, _Size __n,
S                      const _TypeT& __x,
S                      const allocator_interface<_Allocator, _TypeU>& __alloc)
S{
S    _ForwardIter __start = __first;
S
S    _TRY {
S        for (; __n; --__n, ++__first)
S            __alloc.construct (&*__first, __x);
S    }
S    _CATCH (...) {
S        for (; __start != __first; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S}
S
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.5 - Template class auto_ptr
N
Ntemplate<class _TypeT>
Nclass auto_ptr;
N
N
N// 20.4.5, p2 (defined outside of auto_ptr<> according to the proposed
N// resolution of lwg issue 127)
Ntemplate <class _TypeT>
Nclass auto_ptr_ref 
N{
Npublic:
N    auto_ptr<_TypeT>& _C_ptr;
N
N    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
N};
N
N
Ntemplate<class _TypeT>
Nclass auto_ptr
N{
Npublic:
N    typedef _TypeT element_type;
N
N    _EXPLICIT auto_ptr (element_type* __p = 0) _THROWS (())
X    explicit auto_ptr (element_type* __p = 0) 
N     : _C_ptr (__p) { }
N
N    auto_ptr (auto_ptr& __rhs) _THROWS (())
X    auto_ptr (auto_ptr& __rhs) 
N     : _C_ptr (__rhs.release ()) { }
N
N    auto_ptr& operator= (auto_ptr& __rhs) _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr& __rhs)  { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N    // follows lwg issue 127
N    auto_ptr&
N    operator= (auto_ptr_ref<element_type> __rhs) _THROWS (()) {
X    operator= (auto_ptr_ref<element_type> __rhs)  {
N        reset (__rhs._C_ptr.release ());
N        return *this;
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeU>
N    operator auto_ptr_ref<_TypeU>() _THROWS (()) {
X    operator auto_ptr_ref<_TypeU>()  {
N        return auto_ptr_ref<_TypeU>(*this);
N    }
N
N    template <class _TypeU> 
N    operator auto_ptr<_TypeU>() _THROWS (()) {
X    operator auto_ptr<_TypeU>()  {
N        return auto_ptr<_TypeU>(release ());
N    }
N
N    template <class _TypeU>
N    auto_ptr (auto_ptr<_TypeU>& __rhs) _THROWS (())
X    auto_ptr (auto_ptr<_TypeU>& __rhs) 
N    : _C_ptr (__rhs.release ()) { }
N
N    template <class _TypeU>
N    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)  _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)   { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    ~auto_ptr () _THROWS (()) {
X    ~auto_ptr ()  {
N        delete _C_ptr;
N    }
N
N    element_type* get () const _THROWS (()) {
X    element_type* get () const  {
N        return _C_ptr;
N    }
N
N    element_type& operator* () const _THROWS (()) {
X    element_type& operator* () const  {
N        _RWSTD_ASSERT (0 != get ());
X        ((void)0);
N        return *get (); 
N    }
N
N    _RWSTD_OPERATOR_ARROW (
N        element_type* operator-> () const _THROWS (()))
X    element_type* operator-> () const { return & * *this; }
N
N    element_type* release () _THROWS (()) { 
X    element_type* release ()  { 
N        element_type* __tmp = _C_ptr;
N        _C_ptr = 0;
N        return __tmp; 
N    }
N
N    void reset (element_type* __p = 0) _THROWS (()) { 
X    void reset (element_type* __p = 0)  { 
N        if (_C_ptr != __p) {
N            delete _C_ptr;
N            _C_ptr = __p;
N        }
N    }
N
N    auto_ptr (auto_ptr_ref<element_type> __r) _THROWS (())
X    auto_ptr (auto_ptr_ref<element_type> __r) 
N    : _C_ptr (__r._C_ptr.release ()) { }
N
Nprivate:
N    element_type* _C_ptr;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_MEMORY_INCLUDED
N
L 50 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\algorithm" 2
N#include <utility>
N
N#include <rw/_iterbase.h>
N#include <rw/_algobase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_algobase.h" 1
N/***************************************************************************
N *
N * _algobase.h - Declarations and inline definitions of frequently used
N *               C++ Standard Library algorithms
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ALGOBASE_H_INCLUDED
N#define _RWSTD_ALGOBASE_H_INCLUDED
N
N#include <utility>   // for pair
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  include <rw/_iterbase.h>
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#undef max
N#undef min
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.3.7, p1
Ntemplate <class _TypeT>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
N{
N    return __b < __a ? __b : __a;
N}
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__b, __a) ? __b : __a;
N}
N
N
N// 25.3.7, p3
Ntemplate <class _TypeT>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
N{
N    return  __a < __b ? __b : __a;
N}
N
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__a, __b) ? __b : __a;
N}
N
N
N// 25.2.1, p1
Ntemplate <class _InputIter, class _OutputIter>
Ninline _OutputIter
Ncopy (_InputIter __first, _InputIter __last, _OutputIter __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first,++__res)
N        *__res = *__first;
N    return __res;
N}
N
N
N// 25.2.1, p5
Ntemplate <class _BidirIter1, class _BidirIter2>
Ninline _BidirIter2
Ncopy_backward (_BidirIter1 __first, _BidirIter1 __last, _BidirIter2 __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    while (__first != __last)
N        *--__res = *--__last;
N    return __res;
N}
N
N
N// 25.2.5
Ntemplate <class _FwdIter, class _TypeT>
Ninline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last; ++__first)
N        *__first = __value;
N}
N
N
Ntemplate <class _OutputIter, class _Size, class _TypeT>
Ninline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
N{
N    for (;__n > 0;--__n, ++__first)
N        *__first = __value;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// `less than' qusi-function object - used by algorithms for code reuse
Ntemplate <class _TypeT>
Nstruct __rw_lt
N{
N    bool operator() (const _TypeT &__lhs, const _TypeT &__rhs) const {
N        return __lhs < __rhs;
N    }
N};
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_LESS(iterT) \
N     _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
X#  define _RWSTD_LESS(iterT)      _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
N
N#else   // if defined (_RWSTD_NO_PARTIAL_CLASS_SPEC)
S
S#  define _RWSTD_LESS(iterT) \
S     _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
X#  define _RWSTD_LESS(iterT)      _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
S
Stemplate <class _TypeT>
S__rw_lt<_TypeT> __rw_make_lt (const _TypeT*)
S{
S    return __rw_lt<_TypeT>();
S}
S
N#endif   // _RWSTD_NO_PARTIAL_CLASS_SPEC
N
N
N// swaps values of 2 (possibly distinct) types
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_swap (_TypeT& __a, _TypeU& __b)
N{
N    // _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.2.2, p1
Ntemplate <class _TypeT>
Ninline void swap (_TypeT& __a, _TypeT& __b)
N{
N    // LWG issue 227 - _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N// 25.2.2, p7
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
N{
N    // std::iterator_traits<_FwdIter[12]>::value_type must satisfy
N    // both Assignable and CopyConstructible
N    _RW::__rw_swap (*__a, *__b);
X    __rw::__rw_swap (*__a, *__b);
N}
N
N
N// 25.1.7 - Mismatch
Ntemplate <class _InputIter1, class _InputIter2>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && *__first1 == *__first2) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1,
N          _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && __pred (*__first1, *__first2)) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
N// 25.1.8 - Equal
Ntemplate <class _InputIter1, class _InputIter2>
Ninline bool
Nequal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    return __last1 == _STD::mismatch (__first1, __last1, __first2).first;
X    return __last1 == std::mismatch (__first1, __last1, __first2).first;
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline bool equal (_InputIter1 __first1, _InputIter1 __last1,
N                   _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    return __last1 == _STD::mismatch (__first1, __last1,
X    return __last1 == std::mismatch (__first1, __last1,
N                                      __first2, __pred).first;
N}
N
N
N// 25.3.8 - Lexicographical Comparison
Ntemplate <class _InputIter1, class _InputIter2>
Nbool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
N                              _InputIter2 __first2, _InputIter2 __last2);
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _Compare>
Nbool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
N                             _InputIter2 __first2, _InputIter2 __last2,
N                             _Compare __comp);
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <rw/_algobase.cc>
N#endif
N
N
N#endif   // _RWSTD_ALGOBASE_H_INCLUDED
N
L 54 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\algorithm" 2
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTDLIB
X#include <cstdlib>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdlib" 1
N/*
N * C++ header for C header stdlib.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstdlib
N#define __cstdlib
N#define __ARMCLIB_VERSION 5060019
N
N  #define __STDLIB_NO_EXPORTS 1
N  #include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS ::std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S   /* unconditional in non-strict C for consistency of debug info */
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
S  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 1L && 1L 
N    /* atexit that takes a ptr to a function with C++ linkage 
N     * but not in GNU mode  
N     */
N    typedef void (* __C_exitfuncptr)();
N    extern "C++"
N    inline int atexit(void (* __func)()) {
N      return atexit((__C_exitfuncptr)__func);
N    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 1L && 1L
N    /* bsearch that takes a ptr to a function with C++ linkage 
N     * but not in GNU mode
N     */
N    typedef int (* __C_compareprocptr)(const void *, const void *);
N    extern "C++"
N    void *bsearch(const void * __key, const void * __base,
N              size_t __nmemb, size_t __size,
N              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N    extern "C++"
N    inline void *bsearch(const void * __key, const void * __base,
N              size_t __nmemb, size_t __size,
N              int (* __compar)(const void *, const void *)) {
N      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
N    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 1L && 1L
N    /* qsort that takes a ptr to a function with C++ linkage 
N     * but not in GNU mode
N     */    
N    extern "C++"
N    void qsort(void * __base, size_t __nmemb, size_t __size,
N               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N    extern "C++"
N    inline void qsort(void * __base, size_t __nmemb, size_t __size,
N                      int (* __compar)(const void *, const void *)) {
N      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
N    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) ldiv_t div(long int __numer, long int __denom) {
N       return ldiv(__numer, __denom);
N   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) long long abs(long long x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) lldiv_t div(long long __numer, long long __denom) {
N       return lldiv(__numer, __denom);
N   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
N    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
N    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdlib" 2
N  #undef __STDLIB_NO_EXPORTS
N
N  #undef __stdlib_h  // later inclusion of stdlib.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstdlib */
N
L 57 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\algorithm" 2
N
N
N#ifdef _INLINE_RECURSIVE
S#  define _INLINE inline
N#else
N#  define _INLINE
N#endif
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.1 - Non-modifying sequence operations [lib.alg.nonmodifying]
N
N// 25.1.1 - For Each [lib.alg.foreach]
Ntemplate <class _InputIter, class _Function>
Ninline _Function
Nfor_each (_InputIter __first, _InputIter __last, _Function __f)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last; ++__first)
N        __f (*__first);
N    return __f;
N}
N
N
N// 25.1.2 - Find [lib.alg.find]
N
Ntemplate <class _InputIter, class _TypeT>
Ninline _InputIter
Nfind (_InputIter __first, _InputIter __last, const _TypeT& __value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    while (!(__first == __last) && !(*__first == __value)) 
N        ++__first;
N    return __first;
N}
N
N
Ntemplate <class _InputIter, class _Predicate>
Ninline _InputIter
Nfind_if (_InputIter __first, _InputIter __last, _Predicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    while (__first != __last && !__pred (*__first))
N        ++__first;
N    return __first;
N}
N
N
N// helpers to work around the lack of iterator_traits
Ntemplate <class _FwdIter1, class _FwdIter2, class _Distance>
N_FwdIter1 __find_end (_FwdIter1, _FwdIter1, _FwdIter2, _FwdIter2, _Distance*);
N
Ntemplate <class _FwdIter1, class _FwdIter2, 
N          class _BinaryPredicate, class _Distance>
N_FwdIter1 __find_end (_FwdIter1, _FwdIter1, _FwdIter2, _FwdIter2,
N                      _BinaryPredicate, _Distance*);
N
N
N// 25.1.3 - Find End [lib.alg.find.end]
N
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline _FwdIter1 find_end (_FwdIter1 __first1, _FwdIter1 __last1,
N                           _FwdIter2 __first2, _FwdIter2 __last2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first2, __last2);
X    ((void)0);
N
N    return __find_end (__first1, __last1, __first2, __last2,
N                       _RWSTD_DIFFERENCE_TYPE (_FwdIter1));
X                       (typename std::iterator_traits< _FwdIter1 > ::difference_type*)0);
N}
N
N
Ntemplate <class _FwdIter1, class _FwdIter2, class _BinaryPredicate>
N_FwdIter1 find_end (_FwdIter1 __first1, _FwdIter1 __last1,
N                    _FwdIter2 __first2, _FwdIter2 __last2,
N                    _BinaryPredicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first2, __last2);
X    ((void)0);
N
N    return __find_end (__first1,__last1,__first2,__last2,
N                       __pred, _RWSTD_DIFFERENCE_TYPE (_FwdIter1));
X                       __pred, (typename std::iterator_traits< _FwdIter1 > ::difference_type*)0);
N}
N
N// 25.1.4 - Find First [lib.alg.find.first.of]
N
Ntemplate <class _FwdIter1, class _FwdIter2>
N_FwdIter1 find_first_of (_FwdIter1, _FwdIter1, _FwdIter2, _FwdIter2);
N
Ntemplate <class _FwdIter1, class _FwdIter2, class _BinaryPred>
N_FwdIter1 find_first_of (_FwdIter1,_FwdIter1, _FwdIter2, _FwdIter2,
N                         _BinaryPred);
N
N
N// 25.1.5 - Adjacent Find [lib.alg.adjacent.find]
N
Ntemplate <class _FwdIter>
N_FwdIter adjacent_find (_FwdIter, _FwdIter);
N
Ntemplate <class _FwdIter, class _BinaryPredicate>
N_FwdIter adjacent_find (_FwdIter, _FwdIter, _BinaryPredicate);
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// 25.1.6 - Count [lib.alg.count]
N
Ntemplate <class _InputIter, class _TypeT>
Ninline _TYPENAME iterator_traits<_InputIter>::difference_type
Xinline typename iterator_traits<_InputIter>::difference_type
Ncount (_InputIter __first, _InputIter __last, const _TypeT& __value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    _TYPENAME iterator_traits<_InputIter>::difference_type __n = 0;
X    typename iterator_traits<_InputIter>::difference_type __n = 0;
N    for (; __first != __last; ++__first)
N        if (*__first == __value)
N            ++__n;
N    return __n;
N}
N
N
Ntemplate <class _InputIter, class _Predicate>
Ninline _TYPENAME iterator_traits<_InputIter>::difference_type
Xinline typename iterator_traits<_InputIter>::difference_type
Ncount_if (_InputIter __first, _InputIter __last, _Predicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    _TYPENAME iterator_traits<_InputIter>::difference_type __n = 0;
X    typename iterator_traits<_InputIter>::difference_type __n = 0;
N    for (;__first != __last; ++__first)
N        if (__pred (*__first))
N            ++__n;
N    return __n;
N}
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// provided as a backward-compatibility extension (or as a workaround)
N#if    !defined (_RWSTD_NO_EXT_VOID_COUNT)    \
N    || defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if    !0L        || 0L
N
Ntemplate <class _InputIter, class _TypeT, class _Size>
Ninline void count (_InputIter __first, _InputIter __last,
N                   const _TypeT& __value, _Size& __n)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last;++__first) 
N        if (*__first == __value)
N            ++__n;
N}
N
N
Ntemplate <class _InputIter, class _Predicate, class _Size>
Ninline void count_if (_InputIter __first, _InputIter __last,
N                      _Predicate __pred, _Size& __n)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last;++__first)
N        if (__pred (*__first))
N            ++__n;
N}
N
N#endif   // !_RWSTD_NO_EXT_VOID_COUNT || _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 25.1.7 - Mismatch [lib.mismatch]
N// 25.1.8 - Equal [lib.alg.equal]
N// defined in <rw/_algobase.h>
N
N
N// helpers to work around the lack of iterator_traits
Ntemplate <class _FwdIter1, class _FwdIter2, class _Distance1, class _Distance2>
N_FwdIter1 __search (_FwdIter1, _FwdIter1, _FwdIter2, _FwdIter2,
N                    _Distance1*, _Distance2*);
N
Ntemplate <class _FwdIter1, class _FwdIter2,
N          class _BinaryPredicate, class Distance1, class Distance2>
N_FwdIter1 __search (_FwdIter1, _FwdIter1, _FwdIter2, _FwdIter2,
N                    _BinaryPredicate, Distance1*, Distance2*);
N
N// 25.1.9 - Search [lib.alg.search]
N
N// 25.1.9, p1
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline _FwdIter1 search (_FwdIter1 __first1, _FwdIter1 __last1,
N                         _FwdIter2 __first2, _FwdIter2 __last2)
N{
N    return __search (__first1, __last1, __first2, __last2,
N                     _RWSTD_DIFFERENCE_TYPE (_FwdIter1),
X                     (typename std::iterator_traits< _FwdIter1 > ::difference_type*)0,
N                     _RWSTD_DIFFERENCE_TYPE (_FwdIter2));
X                     (typename std::iterator_traits< _FwdIter2 > ::difference_type*)0);
N}
N
N
Ntemplate <class _FwdIter1, class _FwdIter2, class _BinaryPredicate>
Ninline _FwdIter1 search (_FwdIter1 __first1,_FwdIter1 __last1,
N                         _FwdIter2 __first2,_FwdIter2 __last2,
N                         _BinaryPredicate __pred)
N{
N    return __search (__first1, __last1, __first2, __last2, __pred,
N                     _RWSTD_DIFFERENCE_TYPE (_FwdIter1),
X                     (typename std::iterator_traits< _FwdIter1 > ::difference_type*)0,
N                     _RWSTD_DIFFERENCE_TYPE (_FwdIter2));
X                     (typename std::iterator_traits< _FwdIter2 > ::difference_type*)0);
N}
N
N
N// helper to work around the lack of iterator_traits
Ntemplate <class _FwdIter, class _Distance, class _Size, class _TypeT>
N_FwdIter __search_n (_FwdIter, _FwdIter, _Distance*, _Size, const _TypeT&);
N 
Ntemplate <class _FwdIter, class _Distance, class _Size, class _TypeT,
N          class _BinaryPredicate>
N_FwdIter __search_n (_FwdIter, _FwdIter, _Distance*, _Size,
N                     const _TypeT&, _BinaryPredicate);
N
N// 25.1.9, p4
Ntemplate <class _FwdIter, class _Size, class _TypeT>
Ninline _FwdIter search_n (_FwdIter __first, _FwdIter __last,
N                          _Size __count, const _TypeT& __value)
N{
N    if (__count) 
N        return __search_n (__first, __last, _RWSTD_DIFFERENCE_TYPE (_FwdIter),
X        return __search_n (__first, __last, (typename std::iterator_traits< _FwdIter > ::difference_type*)0,
N                           __count, __value);
N    return __first;
N}
N
N
Ntemplate <class _FwdIter, class _Size, class _TypeT, class _BinaryPredicate>
Ninline _FwdIter search_n (_FwdIter __first, _FwdIter __last,
N                          _Size __count, const _TypeT& __value,
N                          _BinaryPredicate __pred)
N{
N    if (__count) 
N        return __search_n (__first, __last,
N                           _RWSTD_DIFFERENCE_TYPE (_FwdIter),
X                           (typename std::iterator_traits< _FwdIter > ::difference_type*)0,
N                           __count,__value, __pred);
N    return __first;
N}
N
N
N// 25.2 - Mutating sequence operations [lib.alg.modifying,operations]
N
N// 25.2.1 - Copy [lib.alg.copy]
N// 25.2.2, p1 swap
N// defined in <rw/_algobase.h>
N
N// 25.2.2, p3
Ntemplate <class _FwdIter1, class _FwdIter2>
N_FwdIter2 swap_ranges (_FwdIter1, _FwdIter1, _FwdIter2);
N
N// 25.2.3 - Transform [lib.alg.transform]
Ntemplate <class _InputIter, class _OutputIter, class _UnaryOperation>
N_OutputIter transform (_InputIter, _InputIter, _OutputIter, _UnaryOperation);
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter,
N          class _BinaryOperation>
N_OutputIter transform (_InputIter1, _InputIter1, _InputIter2, _OutputIter,
N                       _BinaryOperation);
N
N// 25.2.4 - Replace [lib.alg.replace]
Ntemplate <class _FwdIter, class _TypeT>
Nvoid replace (_FwdIter, _FwdIter, const _TypeT&, const _TypeT&);
N
Ntemplate <class _FwdIter, class _Predicate, class _TypeT>
Nvoid replace_if (_FwdIter, _FwdIter, _Predicate, const _TypeT&);
N
Ntemplate <class _InputIter, class _OutputIter, class _TypeT>
N_OutputIter replace_copy (_InputIter, _InputIter, _OutputIter,
N                          const _TypeT&, const _TypeT&);
N
Ntemplate <class _Iter, class _OutputIter, class _Predicate, class _TypeT>
N_OutputIter replace_copy_if (_Iter, _Iter, _OutputIter, _Predicate,
N                             const _TypeT&);
N
N// 25.2.5 - Fill [lib.alg.fill]
N// defined in <rw/_algobase.h>
N
N// 25.2.6 - Generate [lib.alg.generate]
N
Ntemplate <class _FwdIter, class _Generator>
Nvoid generate (_FwdIter, _FwdIter, _Generator);
N
Ntemplate <class _OutputIter, class _Size, class _Generator>
Nvoid generate_n (_OutputIter, _Size, _Generator);
N
N// 25.2.7 - Remove [lib.alg.remove]
Ntemplate <class _InputIter, class _OutputIter, class _TypeT>
N_OutputIter remove_copy (_InputIter, _InputIter, _OutputIter,
N                         const _TypeT&);
N
Ntemplate <class _InputIter, class _OutputIter, class _Predicate>
N_OutputIter remove_copy_if (_InputIter, _InputIter, _OutputIter, _Predicate);
N
N
Ntemplate <class _FwdIter, class _TypeT>
Ninline _FwdIter
Nremove (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    __first = _STD::find (__first, __last, __value);
X    __first = std::find (__first, __last, __value);
N    _FwdIter __next = __first;
N    return __first == __last ?
N        __first : _STD::remove_copy (++__next, __last, __first, __value);
X        __first : std::remove_copy (++__next, __last, __first, __value);
N}
N
N
Ntemplate <class _FwdIter, class _Predicate>
Ninline _FwdIter remove_if (_FwdIter __first, _FwdIter __last, _Predicate __pred)
N{
N    __first = _STD::find_if (__first, __last, __pred);
X    __first = std::find_if (__first, __last, __pred);
N    _FwdIter __next = __first;
N    return __first == __last ?
N        __first : _STD::remove_copy_if (++__next, __last, __first, __pred);
X        __first : std::remove_copy_if (++__next, __last, __first, __pred);
N}
N
N
Ntemplate <class _InputIter, class _FwdIter>
N_FwdIter __unique_copy (_InputIter, _InputIter, _FwdIter, forward_iterator_tag);
N
N
Ntemplate <class _InputIter, class _BidirIter>
Ninline _BidirIter
N__unique_copy (_InputIter __first, _InputIter __last, _BidirIter __res, 
N               bidirectional_iterator_tag)
N{
N    return __unique_copy (__first, __last, __res, forward_iterator_tag ());
N}
N
N
Ntemplate <class _InputIter, class _RandomAccessIter>
Ninline _RandomAccessIter
N__unique_copy (_InputIter __first, _InputIter __last,
N               _RandomAccessIter __res, random_access_iterator_tag)
N{
N    return __unique_copy (__first, __last, __res, forward_iterator_tag ());
N}
N
Ntemplate <class _InputIter, class _OutputIter, class _TypeT>
N_OutputIter __unique_copy (_InputIter, _InputIter, _OutputIter, _TypeT*);
N
N
Ntemplate <class _InputIter, class _OutputIter>
Ninline _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
N                                  _OutputIter __res, output_iterator_tag)
N{
N    return __unique_copy (__first, __last, __res,
N                          _RWSTD_VALUE_TYPE (_InputIter));
X                          (typename std::iterator_traits< _InputIter > ::value_type*)0);
N}
N
N
Ntemplate <class _InputIter, class _OutputIter>
Ninline _OutputIter
Nunique_copy (_InputIter __first, _InputIter __last, _OutputIter __res)
N{
N    return __first == __last ? __res :
N        __unique_copy (__first, __last, __res,
N                       _RWSTD_ITERATOR_CATEGORY (_OutputIter, __res));
X                       typename std::iterator_traits< _OutputIter > ::iterator_category ());
N}
N
N
Ntemplate <class _InputIter, class _FwdIter, class _BinaryPredicate>
N_FwdIter __unique_copy (_InputIter, _InputIter, _FwdIter, _BinaryPredicate,
N                        forward_iterator_tag);
N
N
Ntemplate <class _InputIter, class _BidirIter, class _BinaryPredicate>
Ninline _BidirIter
N__unique_copy (_InputIter __first, _InputIter __last, _BidirIter __res, 
N               _BinaryPredicate __pred, bidirectional_iterator_tag)
N{
N    return __unique_copy (__first, __last, __res, __pred,
N                          forward_iterator_tag ());
N}
N
N
Ntemplate <class _InputIter, class _RandomAccessIter, class _BinaryPredicate>
Ninline _RandomAccessIter
N__unique_copy (_InputIter __first, _InputIter __last, _RandomAccessIter __res, 
N               _BinaryPredicate __pred, random_access_iterator_tag)
N{
N    return __unique_copy (__first, __last, __res, __pred, 
N                          forward_iterator_tag ());
N}
N
N
Ntemplate <class _InputIter, class _OutputIter, class _BinaryPredicate,
N          class _TypeT>
N_OutputIter __unique_copy (_InputIter, _InputIter, _OutputIter,
N                           _BinaryPredicate, _TypeT*);
N
Ntemplate <class _InputIter, class _OutputIter, class _BinaryPredicate>
Ninline _OutputIter
N__unique_copy (_InputIter __first, _InputIter __last, _OutputIter __res,
N               _BinaryPredicate __pred, output_iterator_tag)
N{
N    return __unique_copy (__first, __last, __res, __pred,
N                          _RWSTD_VALUE_TYPE (_InputIter));
X                          (typename std::iterator_traits< _InputIter > ::value_type*)0);
N}
N
N
Ntemplate <class _InputIter, class _OutputIter, class _BinaryPredicate>
Ninline _OutputIter
Nunique_copy (_InputIter __first, _InputIter __last, _OutputIter __res,
N             _BinaryPredicate __pred)
N{
N      return __first == __last ? __res :
N          __unique_copy (__first, __last, __res, __pred,
N                         _RWSTD_ITERATOR_CATEGORY (_OutputIter, __res));
X                         typename std::iterator_traits< _OutputIter > ::iterator_category ());
N}
N
N
Ntemplate <class _FwdIter>
Ninline _FwdIter unique (_FwdIter __first, _FwdIter __last)
N{
N    __first = _STD::adjacent_find (__first, __last);
X    __first = std::adjacent_find (__first, __last);
N    return _STD::unique_copy (__first, __last, __first);
X    return std::unique_copy (__first, __last, __first);
N}
N
N
Ntemplate <class _FwdIter, class _BinaryPredicate>
Ninline _FwdIter unique (_FwdIter __first, _FwdIter __last,
N                        _BinaryPredicate __pred)
N{
N    __first = _STD::adjacent_find (__first, __last, __pred);
X    __first = std::adjacent_find (__first, __last, __pred);
N    return _STD::unique_copy (__first, __last, __first, __pred);
X    return std::unique_copy (__first, __last, __first, __pred);
N}
N
N
Ntemplate <class _BidirIter>
Nvoid __reverse (_BidirIter, _BidirIter, bidirectional_iterator_tag);
N
N
Ntemplate <class _RandomAccessIter>
Nvoid __reverse (_RandomAccessIter __first, _RandomAccessIter __last,
N                random_access_iterator_tag);
N
N
Ntemplate <class _BidirIter>
Ninline void reverse (_BidirIter __first, _BidirIter __last)
N{
N    __reverse (__first, __last, _RWSTD_ITERATOR_CATEGORY (_BidirIter, __first));
X    __reverse (__first, __last, typename std::iterator_traits< _BidirIter > ::iterator_category ());
N}
N
N
Ntemplate <class _BidirIter, class _OutputIter>
N_OutputIter reverse_copy (_BidirIter, _BidirIter, _OutputIter);
N
N
Ntemplate <class _FwdIter, class _Distance>
Nvoid __rotate (_FwdIter, _FwdIter, _FwdIter, _Distance*, forward_iterator_tag);
N
N
Ntemplate <class _BidirIter, class _Distance>
Ninline void
N__rotate (_BidirIter __first, _BidirIter __middle, _BidirIter __last,
N          _Distance*, bidirectional_iterator_tag)
N{
N    _STD::reverse (__first, __middle);
X    std::reverse (__first, __middle);
N    _STD::reverse (__middle, __last);
X    std::reverse (__middle, __last);
N    _STD::reverse (__first, __last);
X    std::reverse (__first, __last);
N}
N
N
Ntemplate <class _EuclideanRingElement>
N_EuclideanRingElement __gcd (_EuclideanRingElement, _EuclideanRingElement);
N
N
Ntemplate <class _RandomAccessIter, class _Distance, class _TypeT>
Nvoid __rotate_cycle (_RandomAccessIter, _RandomAccessIter, _RandomAccessIter,
N                     _Distance, _TypeT*);
N
N
Ntemplate <class _RandomAccessIter, class _Distance>
Nvoid __rotate (_RandomAccessIter, _RandomAccessIter, _RandomAccessIter,
N               _Distance*, random_access_iterator_tag);
N
N
Ntemplate <class _FwdIter>
Ninline void rotate (_FwdIter __first, _FwdIter __middle, _FwdIter __last)
N{
N    if (!(__first == __middle || __middle == __last))
N        __rotate (__first, __middle, __last,
N                  _RWSTD_DIFFERENCE_TYPE (_FwdIter),
X                  (typename std::iterator_traits< _FwdIter > ::difference_type*)0,
N                  _RWSTD_ITERATOR_CATEGORY (_FwdIter, __first));
X                  typename std::iterator_traits< _FwdIter > ::iterator_category ());
N}
N
N
Ntemplate <class _FwdIter, class _OutputIter>
Ninline _OutputIter
Nrotate_copy (_FwdIter __first, _FwdIter __middle, _FwdIter __last,
N             _OutputIter __res)
N{
N    if (__first == __last) return __res;
N    _FwdIter __mod(__first);
N    advance(__mod, distance(__first, __middle) % distance(__first, __last));
N    return _STD::copy(__first, __mod, _STD::copy(__mod, __last, __res));
X    return std::copy(__first, __mod, std::copy(__mod, __last, __res));
N}
N
N
Ntemplate <class _RandomAccessIter, class _Distance>
Nvoid __random_shuffle (_RandomAccessIter, _RandomAccessIter, _Distance*);
N
N
Ntemplate <class _RandomAccessIter>
Ninline void random_shuffle (_RandomAccessIter __first,
N                            _RandomAccessIter __last)
N{
N    __random_shuffle (__first, __last,
N                      _RWSTD_DIFFERENCE_TYPE (_RandomAccessIter));
X                      (typename std::iterator_traits< _RandomAccessIter > ::difference_type*)0);
N}
N
N
Ntemplate <class _RandomAccessIter, class _RandomNumberGenerator>
Nvoid random_shuffle (_RandomAccessIter, _RandomAccessIter,
N                     _RandomNumberGenerator&);
N
N
Ntemplate <class _BidirIter, class _Predicate>
N_BidirIter partition (_BidirIter, _BidirIter, _Predicate);
N
N
Ntemplate <class _BidirIter, class _Predicate, class _Distance>
N_BidirIter
N__inplace_stable_partition (_BidirIter, _BidirIter, _Predicate, _Distance);
N
N
Ntemplate <class _BidirIter, class _Pointer, class _Predicate,
N          class _Distance, class _TypeT>
N_BidirIter
N__stable_partition_adaptive (_BidirIter, _BidirIter, _Predicate, _Distance,
N                             _Pointer, _Distance, _Distance&, _TypeT*);
N
Ntemplate <class _BidirIter, class _Predicate, class _TypeT, class _Distance>
N_BidirIter __stable_partition (_BidirIter, _BidirIter, _Predicate,
N                               _TypeT*, _Distance*);
N
Ntemplate <class _BidirIter, class _Predicate>
Ninline _BidirIter
Nstable_partition (_BidirIter __first, _BidirIter __last, _Predicate __pred)
N{
N    return __stable_partition (__first, __last, __pred,
N                               _RWSTD_VALUE_TYPE (_BidirIter),
X                               (typename std::iterator_traits< _BidirIter > ::value_type*)0,
N                               _RWSTD_DIFFERENCE_TYPE (_BidirIter));
X                               (typename std::iterator_traits< _BidirIter > ::difference_type*)0);
N}
N
N
N// 25.3.1 - Sorting [lib.alg.sort]
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare>
N_RandomAccessIter
N__unguarded_partition (_RandomAccessIter, _RandomAccessIter,
N                       _TypeT, _Compare);
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare>
Nvoid __quick_sort_loop_aux (_RandomAccessIter, _RandomAccessIter,
N                            _TypeT*, _Compare);
N
N
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void
N__quick_sort_loop (_RandomAccessIter __first, _RandomAccessIter __last,
N                   _Compare __comp)
N{
N    __quick_sort_loop_aux (__first, __last,
N                           _RWSTD_VALUE_TYPE (_RandomAccessIter), __comp);
X                           (typename std::iterator_traits< _RandomAccessIter > ::value_type*)0, __comp);
N}
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare>
Nvoid __unguarded_linear_insert (_RandomAccessIter, _TypeT, _Compare);
N
N
Ntemplate <class _RandomAccessIter, class _TypeT>
Ninline void __linear_insert (_RandomAccessIter __first, 
N                             _RandomAccessIter __last, _TypeT*)
N{
N    _TypeT __value = *__last;
N    if (__value < *__first) {
N        _STD::copy_backward (__first, __last, __last + 1);
X        std::copy_backward (__first, __last, __last + 1);
N        *__first = __value;
N    }
N    else
N        __unguarded_linear_insert (__last, __value);
N}
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare>
Ninline void
N__linear_insert (_RandomAccessIter __first, _RandomAccessIter __last, _TypeT*,
N                 _Compare __comp)
N{
N    _TypeT __value = *__last;
N    if (__comp (__value, *__first)) {
N        _STD::copy_backward (__first, __last, __last + 1);
X        std::copy_backward (__first, __last, __last + 1);
N        *__first = __value;
N    }
N    else
N        __unguarded_linear_insert(__last, __value, __comp);
N}
N
Ntemplate <class _RandomAccessIter, class _Compare>
Nvoid __insertion_sort (_RandomAccessIter, _RandomAccessIter, _Compare);
N
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void
N__unguarded_insertion_sort (_RandomAccessIter __first, _RandomAccessIter __last,
N                            _Compare __comp)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (_RandomAccessIter __i = __first; __i != __last; ++__i)
N        __unguarded_linear_insert (__i, *__i, __comp);
N}
N
N
Ntemplate <class _RandomAccessIter, class _Distance, class _Compare>
Nvoid __introsort_loop (_RandomAccessIter, _RandomAccessIter,
N                       _Distance, _Compare);
N
Ntemplate <class _RandomAccessIter, class _Compare>
Nvoid __final_insertion_sort (_RandomAccessIter, _RandomAccessIter, _Compare);
N
N
N// 25.3.1.1
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void
Nsort (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
N{
N    if (!(__first == __last))  {
N        // introsort guarantees O(N * log(N)) in the worst case
N        __introsort_loop (__first, __last, __last - __first, __comp);
N        __final_insertion_sort (__first, __last, __comp);
N    }
N}
N
N
Ntemplate <class _RandomAccessIter>
Ninline void sort (_RandomAccessIter __first, _RandomAccessIter __last)
N{
N    _STD::sort (__first, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::sort (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
Ntemplate <class _BidirIter, class _Distance, class _Compare>
Nvoid __merge_without_buffer (_BidirIter, _BidirIter, _BidirIter,
N                             _Distance, _Distance, _Compare);
N
Ntemplate <class _RandomAccessIter, class _Compare>
N_INLINE void
X void
N__inplace_stable_sort (_RandomAccessIter __first, _RandomAccessIter __last,
N                       _Compare __comp)
N{
N    if (__last - __first < 15)
N        __insertion_sort (__first, __last, __comp);
N    else {
N        _RandomAccessIter __middle = __first + (__last - __first) / 2;
N        __inplace_stable_sort (__first, __middle, __comp);
N        __inplace_stable_sort (__middle, __last, __comp);
N        __merge_without_buffer (__first, __middle, __last,
N                                __middle - __first, __last - __middle, __comp);
N    }
N}
N
N
Ntemplate <class _RandomAccessIter1, class _RandomAccessIter2,
N          class _Distance, class _Compare>
Nvoid __merge_sort_loop (_RandomAccessIter1, _RandomAccessIter1, 
N                        _RandomAccessIter2, _Distance, _Compare);
N
Ntemplate <class _RandomAccessIter, class _Distance, class _Compare>
Nvoid __chunk_insertion_sort (_RandomAccessIter, _RandomAccessIter, _Distance,
N                             _Compare);
N
Ntemplate <class _RandomAccessIter, class _Pointer, class _Distance,
N          class _TypeT, class _Compare>
Nvoid __merge_sort_with_buffer (_RandomAccessIter, _RandomAccessIter,
N                               _Pointer, _Distance*, _TypeT*, _Compare);
N
Ntemplate <class _RandomAccessIter, class _Pointer, class _Distance,
N          class _TypeT, class _Compare>
Nvoid __stable_sort_adaptive (_RandomAccessIter, _RandomAccessIter,
N                             _Pointer, _Distance, _TypeT*, _Compare);
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Distance,
N          class _Compare>
Ninline void
N__stable_sort (_RandomAccessIter __first, _RandomAccessIter __last,
N               _TypeT*, _Distance*, _Compare __comp)
N{
N    // call an extension of get_temporary_buffer<>() in case partial class
N    // specialization (and iterator_traits<>) isn't supported by compiler
N    pair<_TypeT*, _Distance> __p =
N        _STD::get_temporary_buffer (_Distance (__last - __first), (_TypeT*)0);
X        std::get_temporary_buffer (_Distance (__last - __first), (_TypeT*)0);
N
N    if (__p.first == 0)
N        __inplace_stable_sort (__first, __last, __comp);
N    else {
N        _Distance __len = min (_Distance (__p.second),
N                               _Distance (__last - __first));
N        _STD::copy (__first, __first + __len,
X        std::copy (__first, __first + __len,
N                       raw_storage_iterator<_TypeT*, _TypeT>(__p.first));
N
N        __stable_sort_adaptive (__first, __last, __p.first, __p.second,
N                                (_TypeT*)0, __comp);
N
N        _RW::__rw_destroy (__p.first, __p.first + __len);
X        __rw::__rw_destroy (__p.first, __p.first + __len);
N
N        _STD::return_temporary_buffer (__p.first);
X        std::return_temporary_buffer (__p.first);
N    }
N}
N
N
N// 25.3.1.2
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void stable_sort (_RandomAccessIter __first, _RandomAccessIter __last,
N                         _Compare __comp)
N{
N    if (!(__first == __last))
N        __stable_sort (__first, __last,
N                       _RWSTD_VALUE_TYPE (_RandomAccessIter),
X                       (typename std::iterator_traits< _RandomAccessIter > ::value_type*)0,
N                       _RWSTD_DIFFERENCE_TYPE (_RandomAccessIter), __comp);
X                       (typename std::iterator_traits< _RandomAccessIter > ::difference_type*)0, __comp);
N}
N
N
Ntemplate <class _RandomAccessIter>
Ninline void stable_sort (_RandomAccessIter __first, _RandomAccessIter __last)
N{
N    _STD::stable_sort (__first, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::stable_sort (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
N// helper to work around the lack of iterator_traits
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare>
Nvoid __partial_sort (_RandomAccessIter, _RandomAccessIter,
N                     _RandomAccessIter, _TypeT*, _Compare);
N
N// 25.3.1.3
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void partial_sort (_RandomAccessIter __first,
N                          _RandomAccessIter __middle,
N                          _RandomAccessIter __last, _Compare __comp)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first, __middle);
X    ((void)0);
N
N    if (!(__first == __middle))
N        __partial_sort (__first, __middle, __last,
N                        _RWSTD_VALUE_TYPE(_RandomAccessIter),
X                        (typename std::iterator_traits< _RandomAccessIter > ::value_type*)0,
N                        __comp);
N}
N
Ntemplate <class _RandomAccessIter>
Ninline void
Npartial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
N              _RandomAccessIter __last)
N{
N    _STD::partial_sort (__first, __middle, __last,
X    std::partial_sort (__first, __middle, __last,
N                        _RWSTD_LESS (_RandomAccessIter));
X                        __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
N// helper to work around the lack of iterator_traits
Ntemplate <class _InputIter, class _RandomAccessIter, class _Compare,
N          class _Distance, class _TypeT>
N_RandomAccessIter
N__partial_sort_copy (_InputIter, _InputIter,
N                     _RandomAccessIter, _RandomAccessIter,
N                     _Compare, _Distance*, _TypeT*);
N
N
N// 25.3.1.4
Ntemplate <class _InputIter, class _RandomAccessIter, class _Compare>
Ninline _RandomAccessIter
Npartial_sort_copy (_InputIter __first, _InputIter __last,
N                   _RandomAccessIter __res_first,
N                   _RandomAccessIter __res_last, _Compare __comp)
N{
N    return __first == __last ? __res_first :
N        __partial_sort_copy (__first, __last, __res_first, __res_last, __comp,
N                             _RWSTD_DIFFERENCE_TYPE (_RandomAccessIter),
X                             (typename std::iterator_traits< _RandomAccessIter > ::difference_type*)0,
N                             _RWSTD_VALUE_TYPE (_RandomAccessIter));
X                             (typename std::iterator_traits< _RandomAccessIter > ::value_type*)0);
N}
N
N
Ntemplate <class _InputIter, class _RandomAccessIter>
Ninline _RandomAccessIter
Npartial_sort_copy (_InputIter __first1, _InputIter __last1,
N                   _RandomAccessIter __first2, _RandomAccessIter __last2)
N{
N    return _STD::partial_sort_copy (__first1, __last1, __first2, __last2,
X    return std::partial_sort_copy (__first1, __last1, __first2, __last2,
N                                    _RWSTD_LESS (_InputIter));
X                                    __rw::__rw_lt<typename std::iterator_traits< _InputIter > ::value_type>());
N}
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare>
Nvoid __nth_element (_RandomAccessIter, _RandomAccessIter,
N                    _RandomAccessIter, _TypeT*, _Compare);
N
N// 25.3.2 - Nth element [lib.alg.nth.element]
N
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
N                         _RandomAccessIter __last, _Compare __comp)
N{
N    if (!(__first == __last))
N        __nth_element (__first, __nth, __last,
N                       _RWSTD_VALUE_TYPE (_RandomAccessIter), __comp);
X                       (typename std::iterator_traits< _RandomAccessIter > ::value_type*)0, __comp);
N}
N
Ntemplate <class _RandomAccessIter>
Ninline void nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
N                         _RandomAccessIter __last)
N{
N    _STD::nth_element (__first, __nth, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::nth_element (__first, __nth, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
N// 25.3.3 - Binary search [lib.alg.binary.search]
N
Ntemplate <class _FwdIter, class _TypeT, class _Compare, class _Distance>
N_FwdIter __lower_bound (_FwdIter, _FwdIter, const _TypeT&, _Compare,
N                        _Distance*, forward_iterator_tag);
N
N
Ntemplate <class _FwdIter, class _TypeT, class _Compare, class _Distance>
Ninline _FwdIter
N__lower_bound (_FwdIter __first, _FwdIter __last,
N               const _TypeT& __value, _Compare __comp, _Distance*,
N               bidirectional_iterator_tag)
N{
N    return __lower_bound (__first, __last, __value, __comp,
N                          (_Distance*)0, forward_iterator_tag ());
N}
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare,
N          class _Distance>
N_RandomAccessIter __lower_bound (_RandomAccessIter, _RandomAccessIter,
N                                 const _TypeT&, _Compare, _Distance*,
N                                 random_access_iterator_tag);
N
N// 25.3.3.1
Ntemplate <class _FwdIter, class _TypeT, class _Compare>
Ninline _FwdIter lower_bound (_FwdIter __first,_FwdIter __last,
N                             const _TypeT& __value, _Compare __comp)
N{
N    return __lower_bound (__first, __last, __value, __comp,
N                          _RWSTD_DIFFERENCE_TYPE (_FwdIter),
X                          (typename std::iterator_traits< _FwdIter > ::difference_type*)0,
N                          _RWSTD_ITERATOR_CATEGORY (_FwdIter, __first));
X                          typename std::iterator_traits< _FwdIter > ::iterator_category ());
N}
N
N
Ntemplate <class _FwdIter, class _TypeT>
Ninline _FwdIter
Nlower_bound (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    return _STD::lower_bound (__first, __last, __value,
X    return std::lower_bound (__first, __last, __value,
N                              _RWSTD_LESS (_FwdIter));
X                              __rw::__rw_lt<typename std::iterator_traits< _FwdIter > ::value_type>());
N}
N
N
Ntemplate <class _FwdIter, class _TypeT, class _Compare, class _Distance>
N_FwdIter __upper_bound (_FwdIter, _FwdIter, const _TypeT&, _Compare,
N                        _Distance*, forward_iterator_tag);
N
N
Ntemplate <class _FwdIter, class _TypeT, class _Compare, class _Distance>
Ninline _FwdIter
N__upper_bound (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
N               _Compare __comp, _Distance*, bidirectional_iterator_tag)
N{
N    return __upper_bound (__first, __last, __value, __comp,
N                          (_Distance*)0, forward_iterator_tag ());
N}
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare,
N          class _Distance>
N_RandomAccessIter __upper_bound (_RandomAccessIter, _RandomAccessIter,
N                                 const _TypeT&, _Compare, _Distance*,
N                                 random_access_iterator_tag);
N
N// 25.3.3.2
Ntemplate <class _FwdIter, class _TypeT, class _Compare>
Ninline _FwdIter
Nupper_bound (_FwdIter __first,_FwdIter __last,
N             const _TypeT& __value, _Compare __comp)
N{
N    return __upper_bound (__first, __last, __value, __comp,
N                          _RWSTD_DIFFERENCE_TYPE (_FwdIter),
X                          (typename std::iterator_traits< _FwdIter > ::difference_type*)0,
N                          _RWSTD_ITERATOR_CATEGORY (_FwdIter, __first));
X                          typename std::iterator_traits< _FwdIter > ::iterator_category ());
N}
N
N
Ntemplate <class _FwdIter, class _TypeT>
Ninline _FwdIter
Nupper_bound (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    return _STD::upper_bound (__first, __last, __value,
X    return std::upper_bound (__first, __last, __value,
N                              _RWSTD_LESS (_FwdIter));
X                              __rw::__rw_lt<typename std::iterator_traits< _FwdIter > ::value_type>());
N}
N
N
Ntemplate <class _FwdIter, class _TypeT, class _Compare, class _Distance>
Npair<_FwdIter, _FwdIter>
N__equal_range (_FwdIter, _FwdIter, const _TypeT&,
N               _Compare, _Distance*, forward_iterator_tag);
N
N
Ntemplate <class _FwdIter, class _TypeT, class _Compare, class _Distance>
Ninline pair<_FwdIter, _FwdIter>
N__equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
N               _Compare __comp, _Distance*, bidirectional_iterator_tag)
N{
N    return __equal_range (__first, __last, __value, __comp,
N                          (_Distance*)0, forward_iterator_tag());
N}
N
N
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare,
N          class _Distance>
Npair<_RandomAccessIter, _RandomAccessIter>
N__equal_range (_RandomAccessIter, _RandomAccessIter,
N               const _TypeT&, _Compare, _Distance*, random_access_iterator_tag);
N
N
N// 25.3.3.3
Ntemplate <class _FwdIter, class _TypeT, class _Compare>
Ninline pair<_FwdIter, _FwdIter>
Nequal_range (_FwdIter __first, _FwdIter __last,
N             const _TypeT& __value, _Compare __comp)
N{
N    return __equal_range (__first, __last, __value, __comp,
N                          _RWSTD_DIFFERENCE_TYPE (_FwdIter),
X                          (typename std::iterator_traits< _FwdIter > ::difference_type*)0,
N                          _RWSTD_ITERATOR_CATEGORY (_FwdIter, __first));
X                          typename std::iterator_traits< _FwdIter > ::iterator_category ());
N}
N
Ntemplate <class _FwdIter, class _TypeT>
Ninline pair<_FwdIter, _FwdIter>
Nequal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    return _STD::equal_range (__first, __last, __value,
X    return std::equal_range (__first, __last, __value,
N                              _RWSTD_LESS (_FwdIter));
X                              __rw::__rw_lt<typename std::iterator_traits< _FwdIter > ::value_type>());
N}
N
N
N// 25.3.3.4
Ntemplate <class _FwdIter, class _TypeT, class _Compare>
Ninline bool binary_search (_FwdIter __first, _FwdIter __last,
N                           const _TypeT& __value, _Compare __comp)
N{
N    _FwdIter __i = _STD::lower_bound (__first, __last, __value, __comp);
X    _FwdIter __i = std::lower_bound (__first, __last, __value, __comp);
N    return __i != __last && !__comp(__value, *__i);
N}
N
N
Ntemplate <class _FwdIter, class _TypeT>
Ninline bool
Nbinary_search (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    return _STD::binary_search (__first, __last, __value,
X    return std::binary_search (__first, __last, __value,
N                                _RWSTD_LESS (_FwdIter));
X                                __rw::__rw_lt<typename std::iterator_traits< _FwdIter > ::value_type>());
N}
N
N
N// 25.3.4 - Merge [lib.alg.merge]
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter,
N          class _Compare>
N_OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
N                   _InputIter2 __first2, _InputIter2 __last2,
N                   _OutputIter __res, _Compare __comp);
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter>
N_OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
N                   _InputIter2 __first2, _InputIter2 __last2,
N                   _OutputIter __res)
N{
N    return _STD::merge (__first1, __last1, __first2, __last2, __res,
X    return std::merge (__first1, __last1, __first2, __last2, __res,
N                        _RWSTD_LESS (_InputIter1));
X                        __rw::__rw_lt<typename std::iterator_traits< _InputIter1 > ::value_type>());
N}
N
N
Ntemplate <class _BidirIter1, class _BidirIter2, class _BidirIter3,
N          class _Compare>
N_BidirIter3
N__merge_backward (_BidirIter1, _BidirIter1, _BidirIter2, _BidirIter2,
N                  _BidirIter3, _Compare);
N
Ntemplate <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
N          class _Compare>
Nvoid __merge_adaptive (_BidirIter, _BidirIter, _BidirIter,
N                       _Distance, _Distance, _Pointer, _Distance, _TypeT*,
N                       _Compare);
N
Ntemplate <class _BidirIter, class _Distance, class _TypeT, class _Compare>
Nvoid __inplace_merge (_BidirIter, _BidirIter, _BidirIter,
N                      _Distance*, _TypeT*, _Compare);
N
N// 25.3.4, p6
Ntemplate <class _BidirIter, class _Compare>
Ninline void
Ninplace_merge (_BidirIter __first, _BidirIter __middle, _BidirIter __last,
N               _Compare __comp)
N{
N    if (!(__first == __middle || __middle == __last))
N        __inplace_merge (__first, __middle, __last,
N                         _RWSTD_DIFFERENCE_TYPE (_BidirIter),
X                         (typename std::iterator_traits< _BidirIter > ::difference_type*)0,
N                         _RWSTD_VALUE_TYPE (_BidirIter), __comp);
X                         (typename std::iterator_traits< _BidirIter > ::value_type*)0, __comp);
N}
N
N
N
N// 25.3.4, p6
Ntemplate <class _BidirIter>
Ninline void
Ninplace_merge (_BidirIter __first, _BidirIter __middle, _BidirIter __last)
N{
N    _STD::inplace_merge (__first, __middle, __last, _RWSTD_LESS (_BidirIter));
X    std::inplace_merge (__first, __middle, __last, __rw::__rw_lt<typename std::iterator_traits< _BidirIter > ::value_type>());
N}
N
N// 25.3.5 - Set operations on sorted structures
N
N// 25.3.5.1
Ntemplate <class _InputIter1, class _InputIter2, class _Compare>
Nbool includes (_InputIter1, _InputIter1, _InputIter2, _InputIter2, _Compare);
N
Ntemplate <class _InputIter1, class _InputIter2>
Ninline bool includes (_InputIter1 __first1, _InputIter1 __last1,
N                      _InputIter2 __first2, _InputIter2 __last2)
N{
N    return _STD::includes (__first1, __last1, __first2, __last2,
X    return std::includes (__first1, __last1, __first2, __last2,
N                           _RWSTD_LESS (_InputIter1));
X                           __rw::__rw_lt<typename std::iterator_traits< _InputIter1 > ::value_type>());
N}
N
N
N// 25.3.5.2
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter,
N          class _Compare>
N_OutputIter
Nset_union (_InputIter1, _InputIter1, _InputIter2, _InputIter2,
N           _OutputIter, _Compare);
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter>
Ninline _OutputIter
Nset_union (_InputIter1 __first1, _InputIter1 __last1,
N           _InputIter2 __first2, _InputIter2 __last2, _OutputIter __res)
N{
N    return _STD::set_union (__first1, __last1, __first2, __last2, __res,
X    return std::set_union (__first1, __last1, __first2, __last2, __res,
N                            _RWSTD_LESS (_InputIter1));
X                            __rw::__rw_lt<typename std::iterator_traits< _InputIter1 > ::value_type>());
N}
N
N
N// 25.3.5.3
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter,
N          class _Compare>
N_OutputIter
Nset_intersection (_InputIter1, _InputIter1, _InputIter2, _InputIter2,
N                  _OutputIter, _Compare);
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter>
Ninline _OutputIter
Nset_intersection (_InputIter1 __first1, _InputIter1 __last1,
N                  _InputIter2 __first2, _InputIter2 __last2, _OutputIter __res)
N{
N    return _STD::set_intersection (__first1, __last1, __first2, __last2,
X    return std::set_intersection (__first1, __last1, __first2, __last2,
N                                   __res, _RWSTD_LESS (_InputIter1));
X                                   __res, __rw::__rw_lt<typename std::iterator_traits< _InputIter1 > ::value_type>());
N}
N
N
N// 25.3.5.4
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter, 
N          class _Compare>
N_OutputIter
Nset_difference (_InputIter1, _InputIter1, _InputIter2, _InputIter2, 
N                _OutputIter, _Compare);
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter>
Ninline _OutputIter
Nset_difference (_InputIter1 __first1, _InputIter1 __last1,
N                _InputIter2 __first2, _InputIter2 __last2, _OutputIter __res)
N{
N    return _STD::set_difference (__first1, __last1, __first2, __last2,
X    return std::set_difference (__first1, __last1, __first2, __last2,
N                                 __res, _RWSTD_LESS (_InputIter1));
X                                 __res, __rw::__rw_lt<typename std::iterator_traits< _InputIter1 > ::value_type>());
N}
N
N
N// 25.3.5.5
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter,
N          class _Compare>
N_OutputIter
Nset_symmetric_difference (_InputIter1, _InputIter1, _InputIter2, _InputIter2,
N                          _OutputIter, _Compare);
N
Ntemplate <class _InputIter1, class _InputIter2, class _OutputIter>
Ninline _OutputIter
Nset_symmetric_difference (_InputIter1 __first1, _InputIter1 __last1,
N                          _InputIter2 __first2, _InputIter2 __last2,
N                          _OutputIter __res)
N{
N    return _STD::set_symmetric_difference (__first1, __last1,
X    return std::set_symmetric_difference (__first1, __last1,
N                                           __first2, __last2,
N                                           __res, _RWSTD_LESS (_InputIter1));
X                                           __res, __rw::__rw_lt<typename std::iterator_traits< _InputIter1 > ::value_type>());
N}
N
N
N// 25.3.6 - Heap operations
N
N// helper to work around the lack of iterator_traits
Ntemplate <class _RandomAccessIter, class _Distance, class _TypeT,
N          class _Compare>
Nvoid __push_heap (_RandomAccessIter, _Distance, _Distance, _TypeT, _Compare);
N
N
Ntemplate <class _RandomAccessIter, class _Distance, class _Compare>
Ninline void
N__push_heap (_RandomAccessIter __first, _RandomAccessIter __last,
N             _Distance*, _Compare __comp)
N{
N    __push_heap (__first, _Distance (__last - __first),
N                 _Distance (), *__last, __comp);
N}
N
N// 25.3.6.1
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void push_heap (_RandomAccessIter __first, _RandomAccessIter __last,
N                       _Compare __comp)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    if (!(__first == __last))
N        __push_heap (__first, --__last,
N                     _RWSTD_DIFFERENCE_TYPE (_RandomAccessIter), __comp);
X                     (typename std::iterator_traits< _RandomAccessIter > ::difference_type*)0, __comp);
N}
N
N
N// 25.3.6.1
Ntemplate <class _RandomAccessIter>
Ninline void push_heap (_RandomAccessIter __first, _RandomAccessIter __last)
N{
N    _STD::push_heap (__first, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::push_heap (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
Ntemplate <class _RandomAccessIter, class _Distance, class _TypeT,
N          class _Compare>
Nvoid __adjust_heap (_RandomAccessIter, _Distance, _Distance, _TypeT, _Compare);
N
N
N// helper to work around the lack of iterator_traits
Ntemplate <class _RandomAccessIter, class _TypeT, class _Compare,
N          class _Distance>
Ninline void
N__pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
N            _RandomAccessIter __res, _TypeT __val, _Compare __cmp, _Distance*)
N{
N    *__res = *__first;
N    __adjust_heap (__first, _Distance (),
N                   _Distance (__last - __first), __val, __cmp);
N}
N
N
N// 25.3.6.2
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void
Npop_heap (_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    if (!(__first == __last)) {
N        --__last;
N        __pop_heap (__first, __last, __last, *__last, __comp,
N                    _RWSTD_DIFFERENCE_TYPE (_RandomAccessIter));
X                    (typename std::iterator_traits< _RandomAccessIter > ::difference_type*)0);
N    }
N}
N
N
N// 25.3.6.2
Ntemplate <class _RandomAccessIter>
Ninline void pop_heap (_RandomAccessIter __first, _RandomAccessIter __last)
N{
N    _STD::pop_heap (__first, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::pop_heap (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
Ntemplate <class _RandomAccessIter, class _Compare, class _TypeT,
N          class _Distance>
Nvoid __make_heap (_RandomAccessIter, _RandomAccessIter,
N                  _Compare, _TypeT*, _Distance*);
N
N
N// 25.3.6.3
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
N                       _Compare __comp)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    if (!(__last - __first < 2))
N        __make_heap (__first, __last, __comp,
N                     _RWSTD_VALUE_TYPE (_RandomAccessIter),
X                     (typename std::iterator_traits< _RandomAccessIter > ::value_type*)0,
N                     _RWSTD_DIFFERENCE_TYPE (_RandomAccessIter));
X                     (typename std::iterator_traits< _RandomAccessIter > ::difference_type*)0);
N}
N
N
N// 25.3.6.3
Ntemplate <class _RandomAccessIter>
Ninline void make_heap (_RandomAccessIter __first, _RandomAccessIter __last)
N{
N    _STD::make_heap (__first, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::make_heap (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
N// 25.3.6.4
Ntemplate <class _RandomAccessIter, class _Compare>
Ninline void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last,
N                       _Compare __comp)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __last - __first > 1; --__last)
N        _STD::pop_heap (__first, __last, __comp);
X        std::pop_heap (__first, __last, __comp);
N}
N
N
N// 25.3.6.4
Ntemplate <class _RandomAccessIter>
Ninline void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last)
N{
N    _STD::sort_heap (__first, __last, _RWSTD_LESS (_RandomAccessIter));
X    std::sort_heap (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _RandomAccessIter > ::value_type>());
N}
N
N
N// 25.3.7 - Minimum and maximum
N
N// 25.3.7, p7
Ntemplate <class _FwdIter, class _Compare>
N_FwdIter min_element (_FwdIter, _FwdIter, _Compare);
N
Ntemplate <class _FwdIter>
Ninline _FwdIter min_element (_FwdIter __first, _FwdIter __last)
N{
N    return _STD::min_element (__first, __last, _RWSTD_LESS (_FwdIter));
X    return std::min_element (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _FwdIter > ::value_type>());
N}
N
N
N// 25.3.7, p9
Ntemplate <class _FwdIter, class _Compare>
N_FwdIter max_element (_FwdIter, _FwdIter, _Compare);
N
N
Ntemplate <class _FwdIter>
Ninline _FwdIter max_element (_FwdIter __first, _FwdIter __last)
N{
N    return _STD::max_element (__first, __last, _RWSTD_LESS (_FwdIter));
X    return std::max_element (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _FwdIter > ::value_type>());
N}
N
N
N// 25.3.9 - Permutation generators [lib.alg.permutation.generators]
N
N// 25.3.9, p1
Ntemplate <class _BidirIter, class _Compare>
Nbool next_permutation (_BidirIter, _BidirIter, _Compare);
N
Ntemplate <class _BidirIter>
Ninline bool next_permutation (_BidirIter __first, _BidirIter __last)
N{
N    return _STD::next_permutation (__first, __last, _RWSTD_LESS (_BidirIter));
X    return std::next_permutation (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _BidirIter > ::value_type>());
N}
N
N
N// 25.3.9, p3
Ntemplate <class _BidirIter, class _Compare>
Nbool prev_permutation (_BidirIter, _BidirIter, _Compare);
N
Ntemplate <class _BidirIter>
Ninline bool prev_permutation (_BidirIter __first, _BidirIter __last)
N{
N    return _STD::prev_permutation (__first, __last, _RWSTD_LESS (_BidirIter));
X    return std::prev_permutation (__first, __last, __rw::__rw_lt<typename std::iterator_traits< _BidirIter > ::value_type>());
N}
N
N
N//
N// Modifying sequence operations.
N//
N  
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline _FwdIter2
Nswap_ranges (_FwdIter1 __first1, _FwdIter1 __last1, _FwdIter2 __first2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    for (; __first1 != __last1; ++__first1, ++__first2)
N        _STD::iter_swap (__first1, __first2);
X        std::iter_swap (__first1, __first2);
N    return __first2;
N}
N
N
Ntemplate <class _InputIter, class _OutputIter, class _UnaryOperation>
Ninline _OutputIter
Ntransform (_InputIter __first, _InputIter __last, _OutputIter __res,
N           _UnaryOperation __unary_op)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__res, ++__first)
N        *__res = __unary_op (*__first);
N    return __res;
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2,
N          class _OutputIter, class _BinaryOperation>
Ninline _OutputIter
Ntransform (_InputIter1 __first1, _InputIter1 __last1,
N           _InputIter2 __first2, _OutputIter __res,
N           _BinaryOperation __binary_op)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    for (; __first1 != __last1; ++__res, ++__first1, ++__first2)
N        *__res = __binary_op (*__first1, *__first2);
N    return __res;
N}
N
N
Ntemplate <class _FwdIter, class _TypeT>
Ninline void replace (_FwdIter __first, _FwdIter __last,
N                     const _TypeT& __old_value, const _TypeT& __new_value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first) 
N        if (*__first == __old_value)
N            *__first = __new_value;
N}
N
N
Ntemplate <class _FwdIter, class _Predicate, class _TypeT>
Ninline void replace_if (_FwdIter __first, _FwdIter __last,
N                        _Predicate __pred, const _TypeT& __new_value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            *__first = __new_value;
N}
N
N
Ntemplate <class _InputIter, class _OutputIter, class _TypeT>
Ninline _OutputIter
Nreplace_copy (_InputIter __first, _InputIter __last, _OutputIter __res,
N              const _TypeT& __old_value, const _TypeT& __new_value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last; ++__first, ++__res)
N        *__res = *__first == __old_value ? __new_value : *__first;
N    return __res;
N}
N
N
Ntemplate <class _FwdIter, class _Generator>
Ninline void generate (_FwdIter __first, _FwdIter __last, _Generator __gen)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first)
N        *__first = __gen ();
N}
N
N
Ntemplate <class _OutputIter, class _Size, class _Generator>
Ninline void generate_n (_OutputIter __first, _Size __n, _Generator __gen)
N{
N    for (; __n > 0;--__n, ++__first)
N        *__first = __gen ();
N}
N
N
Ntemplate <class _BidirIter>
Ninline void __reverse (_BidirIter __first, _BidirIter __last, 
N                       bidirectional_iterator_tag)
N{
N    // Complexity: exactly (last - first) / 2 calls to std::iter_swap<>()
N    for (; __first != __last && __first != --__last; ++__first)
N        _STD::iter_swap (__first, __last);
X        std::iter_swap (__first, __last);
N}
N
N
Ntemplate <class _RandomAccessIter>
Ninline void __reverse (_RandomAccessIter __first, _RandomAccessIter __last,
N                       random_access_iterator_tag)
N{
N    // Complexity: exactly (last - first) / 2 calls to std::iter_swap<>()
N    if (__first != __last)
N        for (; __first < --__last; ++__first)
N            _STD::iter_swap (__first, __last);
X            std::iter_swap (__first, __last);
N}
N
N
Ntemplate <class _BidirIter, class _OutputIter>
Ninline _OutputIter
Nreverse_copy (_BidirIter __first, _BidirIter __last, _OutputIter __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__res)
N        *__res = *--__last;
N    return __res;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#undef _INLINE
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <algorithm.cc>
N#endif
N
N
N#endif   // _RWSTD_ALGORITHM_INCLUDED
N
L 2 "Source\Ext_Dev\src\AT45\AT45DB321D_driver_hl.cpp" 2
N
C "Source\Ext_Dev\src\AT45\AT45DB321D_driver_hl.cpp" 3 34 cannot open source input file "AT45DB321D_driver_hl.h": No such file or directory
N#include "AT45DB321D_driver_hl.h"
