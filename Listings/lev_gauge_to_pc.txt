; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\lev_gauge_to_pc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\lev_gauge_to_pc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I.\Source\Ext_Dev\inc\AT45 -I.\Objects -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\lev_gauge_to_pc.crf Source\Tasks\src\lev_gauge_to_pc.cpp]
                          THUMB

                          AREA ||i.DMA1_Channel1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Channel1_IRQHandler PROC
;;;1087   
;;;1088   extern "C" void DMA1_Channel1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1089   {
;;;1090     if ( LL_DMA_IsActiveFlag_TC1( DMA1 ) )             //проверка флага transfer complete
000002  bf00              NOP      
000004  4816              LDR      r0,|L1.96|
000006  6800              LDR      r0,[r0,#0]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b338              CBZ      r0,|L1.94|
;;;1091     {
;;;1092       LL_DMA_ClearFlag_TC1( DMA1 );
00000e  bf00              NOP      
000010  2002              MOVS     r0,#2
000012  4913              LDR      r1,|L1.96|
000014  6048              STR      r0,[r1,#4]
000016  bf00              NOP      
;;;1093       LL_DMA_DisableChannel( DMA1, LL_DMA_CHANNEL_1 );
000018  4608              MOV      r0,r1
00001a  2101              MOVS     r1,#1
00001c  1e4a              SUBS     r2,r1,#1
00001e  4b11              LDR      r3,|L1.100|
000020  5c9a              LDRB     r2,[r3,r2]
000022  5882              LDR      r2,[r0,r2]
000024  f0220301          BIC      r3,r2,#1
000028  1e4a              SUBS     r2,r1,#1
00002a  4c0e              LDR      r4,|L1.100|
00002c  5ca2              LDRB     r2,[r4,r2]
00002e  5083              STR      r3,[r0,r2]
000030  bf00              NOP      
;;;1094   
;;;1095   	  DmaAdcHigherPriorityTaskWoken = pdFALSE;
000032  2000              MOVS     r0,#0
000034  490c              LDR      r1,|L1.104|
000036  6008              STR      r0,[r1,#0]  ; DmaAdcHigherPriorityTaskWoken
;;;1096   	  if ( xSemaphoreGiveFromISR( DmaAdcMeas_CompSem, &DmaAdcHigherPriorityTaskWoken ) == pdFAIL ) //отправить семафор окончания записи
000038  480c              LDR      r0,|L1.108|
00003a  6800              LDR      r0,[r0,#0]  ; DmaAdcMeas_CompSem
00003c  f7fffffe          BL       xQueueGiveFromISR
;;;1097       {
;;;1098         //семафор уже был доступен, т.е. ранее отдан другой задачей или прерыванием
;;;1099         //RelFour.toggle();      
;;;1100       }  
;;;1101   	  if ( DmaAdcHigherPriorityTaskWoken == pdTRUE )
000040  4809              LDR      r0,|L1.104|
000042  6800              LDR      r0,[r0,#0]  ; DmaAdcHigherPriorityTaskWoken
000044  2801              CMP      r0,#1
000046  d10a              BNE      |L1.94|
;;;1102   	  {   
;;;1103         portYIELD_FROM_ISR( DmaAdcHigherPriorityTaskWoken ); //принудительное переключение контекста для разблокировки задачи - обработчика
000048  4807              LDR      r0,|L1.104|
00004a  6800              LDR      r0,[r0,#0]  ; DmaAdcHigherPriorityTaskWoken
00004c  b138              CBZ      r0,|L1.94|
00004e  f04f5080          MOV      r0,#0x10000000
000052  4907              LDR      r1,|L1.112|
000054  6008              STR      r0,[r1,#0]
000056  f3bf8f4f          DSB      
00005a  f3bf8f6f          ISB      
                  |L1.94|
;;;1104   	  }
;;;1105     }
;;;1106   }
00005e  bd10              POP      {r4,pc}
                          ENDP

                  |L1.96|
                          DCD      0x40020000
                  |L1.100|
                          DCD      CHANNEL_OFFSET_TAB
                  |L1.104|
                          DCD      DmaAdcHigherPriorityTaskWoken
                  |L1.108|
                          DCD      DmaAdcMeas_CompSem
                  |L1.112|
                          DCD      0xe000ed04

                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI15_10_IRQHandler PROC
;;;1062   
;;;1063   extern "C" void EXTI15_10_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1064   {
;;;1065   //    Do.closed();
;;;1066   //  RelFour.on();
;;;1067   //		RelThree.on();
;;;1068     if ( LL_EXTI_IsActiveFlag_0_31( ExchngToPC.Adc.Exti.Line ) )
000002  4914              LDR      r1,|L2.84|
000004  6c89              LDR      r1,[r1,#0x48]  ; ExchngToPC
000006  6d88              LDR      r0,[r1,#0x58]
000008  4913              LDR      r1,|L2.88|
00000a  6809              LDR      r1,[r1,#0]
00000c  4001              ANDS     r1,r1,r0
00000e  4281              CMP      r1,r0
000010  d101              BNE      |L2.22|
000012  2101              MOVS     r1,#1
000014  e000              B        |L2.24|
                  |L2.22|
000016  2100              MOVS     r1,#0
                  |L2.24|
000018  b1d9              CBZ      r1,|L2.82|
;;;1069     {
;;;1070       LL_EXTI_ClearFlag_0_31( ExchngToPC.Adc.Exti.Line  );
00001a  490e              LDR      r1,|L2.84|
00001c  6c89              LDR      r1,[r1,#0x48]  ; ExchngToPC
00001e  6d88              LDR      r0,[r1,#0x58]
000020  490d              LDR      r1,|L2.88|
000022  6008              STR      r0,[r1,#0]
000024  bf00              NOP      
;;;1071   	 
;;;1072   	  Int1HigherPriorityTaskWoken = pdFALSE;
000026  2000              MOVS     r0,#0
000028  490c              LDR      r1,|L2.92|
00002a  6008              STR      r0,[r1,#0]  ; Int1HigherPriorityTaskWoken
;;;1073   //    RelFour.on();
;;;1074   	  if ( xSemaphoreGiveFromISR( DiffExti_TrigSem, &Int1HigherPriorityTaskWoken ) == pdFAIL ) //отправить семафор окончания записи
00002c  480c              LDR      r0,|L2.96|
00002e  6800              LDR      r0,[r0,#0]  ; DiffExti_TrigSem
000030  f7fffffe          BL       xQueueGiveFromISR
;;;1075       {
;;;1076         //семафор уже был доступен, т.е. ранее отдан другой задачей или прерыванием
;;;1077         //RelFour.toggle();      
;;;1078       }  
;;;1079   	  if ( Int1HigherPriorityTaskWoken == pdTRUE )
000034  4809              LDR      r0,|L2.92|
000036  6800              LDR      r0,[r0,#0]  ; Int1HigherPriorityTaskWoken
000038  2801              CMP      r0,#1
00003a  d10a              BNE      |L2.82|
;;;1080   	  {
;;;1081       
;;;1082          portYIELD_FROM_ISR( Int1HigherPriorityTaskWoken ); //принудительное переключение контекста для разблокировки задачи - обработчика
00003c  4807              LDR      r0,|L2.92|
00003e  6800              LDR      r0,[r0,#0]  ; Int1HigherPriorityTaskWoken
000040  b138              CBZ      r0,|L2.82|
000042  f04f5080          MOV      r0,#0x10000000
000046  4907              LDR      r1,|L2.100|
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
                  |L2.82|
;;;1083   	  }
;;;1084     }
;;;1085   //  Do.open();
;;;1086   }
000052  bd10              POP      {r4,pc}
;;;1087   
                          ENDP

                  |L2.84|
                          DCD      ExchngToPC
                  |L2.88|
                          DCD      0x40010414
                  |L2.92|
                          DCD      Int1HigherPriorityTaskWoken
                  |L2.96|
                          DCD      DiffExti_TrigSem
                  |L2.100|
                          DCD      0xe000ed04

                          AREA ||i.TIM1_BRK_TIM15_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_BRK_TIM15_IRQHandler PROC
;;;1035   
;;;1036   extern "C" void TIM1_BRK_TIM15_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1037   {
;;;1038     if (
000002  bf00              NOP      
000004  4817              LDR      r0,|L3.100|
000006  6900              LDR      r0,[r0,#0x10]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b348              CBZ      r0,|L3.98|
;;;1039         LL_TIM_IsActiveFlag_CC1( TIM15 )
;;;1040         &&
;;;1041         LL_TIM_IsEnabledIT_CC1( TIM15 )
00000e  bf00              NOP      
000010  4814              LDR      r0,|L3.100|
000012  68c0              LDR      r0,[r0,#0xc]
000014  f3c00040          UBFX     r0,r0,#1,#1
000018  b318              CBZ      r0,|L3.98|
;;;1042        )
;;;1043     {
;;;1044       LL_TIM_ClearFlag_CC1( TIM15 );
00001a  bf00              NOP      
00001c  f06f0002          MVN      r0,#2
000020  4910              LDR      r1,|L3.100|
000022  6108              STR      r0,[r1,#0x10]
000024  bf00              NOP      
;;;1045   //    Led.free_toggle();
;;;1046       
;;;1047       if ( ExchngToPC.get_upd_demand_flag() == true )
000026  4810              LDR      r0,|L3.104|
000028  f7fffffe          BL       _ZN11TExchngToPC19get_upd_demand_flagEv ; TExchngToPC::get_upd_demand_flag()
00002c  b1c8              CBZ      r0,|L3.98|
;;;1048       {
;;;1049         ExchngToPC.set_upd_demand_flag( false );
00002e  2100              MOVS     r1,#0
000030  480d              LDR      r0,|L3.104|
000032  f7fffffe          BL       _ZN11TExchngToPC19set_upd_demand_flagEb ; TExchngToPC::set_upd_demand_flag(bool)
;;;1050         TmrHigherPriorityTaskWoken = pdFALSE;
000036  2000              MOVS     r0,#0
000038  490c              LDR      r1,|L3.108|
00003a  6008              STR      r0,[r1,#0]  ; TmrHigherPriorityTaskWoken
;;;1051         if ( xSemaphoreGiveFromISR( Tmr_TrigSem, &TmrHigherPriorityTaskWoken ) == pdFAIL ) //отправить семафор окончания записи
00003c  480c              LDR      r0,|L3.112|
00003e  6800              LDR      r0,[r0,#0]  ; Tmr_TrigSem
000040  f7fffffe          BL       xQueueGiveFromISR
;;;1052         {
;;;1053           //семафор уже был доступен, т.е. ранее отдан другой задачей или прерыванием
;;;1054         }
;;;1055         if ( TmrHigherPriorityTaskWoken == pdPASS )
000044  4809              LDR      r0,|L3.108|
000046  6800              LDR      r0,[r0,#0]  ; TmrHigherPriorityTaskWoken
000048  2801              CMP      r0,#1
00004a  d10a              BNE      |L3.98|
;;;1056         {
;;;1057            portYIELD_FROM_ISR(TmrHigherPriorityTaskWoken);  //принудительное переключение контекста для разблокировки задачи - обработчика
00004c  4807              LDR      r0,|L3.108|
00004e  6800              LDR      r0,[r0,#0]  ; TmrHigherPriorityTaskWoken
000050  b138              CBZ      r0,|L3.98|
000052  f04f5080          MOV      r0,#0x10000000
000056  4907              LDR      r1,|L3.116|
000058  6008              STR      r0,[r1,#0]
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
                  |L3.98|
;;;1058         } 
;;;1059       }
;;;1060     }
;;;1061   }
000062  bd10              POP      {r4,pc}
;;;1062   
                          ENDP

                  |L3.100|
                          DCD      0x40014000
                  |L3.104|
                          DCD      ExchngToPC
                  |L3.108|
                          DCD      TmrHigherPriorityTaskWoken
                  |L3.112|
                          DCD      Tmr_TrigSem
                  |L3.116|
                          DCD      0xe000ed04

                          AREA ||i._Z15lev_gauge_to_pcPv||, CODE, READONLY, ALIGN=2

                  _Z15lev_gauge_to_pcPv PROC ; lev_gauge_to_pc(void*)
;;;966    //----- Задача RTOS -----------------------------------------------------------------------
;;;967    void lev_gauge_to_pc( void *Params ) //обмен уровнемера с ПК
000000  b0ac              SUB      sp,sp,#0xb0
;;;968    {
;;;969      constexpr uint16_t START_DLY_MS = 100U;
000002  bf00              NOP      
;;;970      
;;;971      vTaskDelay( pdMS_TO_TICKS( START_DLY_MS ) );
000004  2064              MOVS     r0,#0x64
000006  f7fffffe          BL       vTaskDelay
;;;972      UCG1.init();
00000a  483c              LDR      r0,|L4.252|
00000c  f7fffffe          BL       _ZN4TLed4initEv ; TLed::init()
;;;973      UCG1.on();
000010  483a              LDR      r0,|L4.252|
000012  f7fffffe          BL       _ZN4TLed2onEv ; TLed::on()
;;;974      
;;;975      typedef void (TExchngToPC::*TFnct)( TExchngToPC::TParamHandle * );
;;;976      
;;;977      struct TCmdHandler
;;;978      {
;;;979        TExchngToPC::TParamHandle *ParamHandle;
;;;980        TFnct rxHandler;                        //обработчик приема
;;;981        TFnct txHandler;                        //обработчик передачи
;;;982      };
;;;983    
;;;984      TCmdHandler CmdHandler[] =
000016  22a0              MOVS     r2,#0xa0
000018  4939              LDR      r1,|L4.256|
00001a  a804              ADD      r0,sp,#0x10
00001c  f7fffffe          BL       __aeabi_memcpy4
;;;985      {
;;;986        { &ParamHandle[0], &TExchngToPC::rx_set_freg       , &TExchngToPC::tx_set_freg       }, //SET_FREG
;;;987        { &ParamHandle[1], &TExchngToPC::rx_set_duty_cycle , &TExchngToPC::tx_set_duty_cycle }, //SET_DUTY_CYCLE
;;;988        { &ParamHandle[2], &TExchngToPC::rx_set_pos_pot_1  , &TExchngToPC::tx_set_pos_pot_1  }, //SET_POS_POT_1
;;;989        { &ParamHandle[3], &TExchngToPC::rx_set_pos_pot_2  , &TExchngToPC::tx_set_pos_pot_2  }, //SET_POS_POT_2
;;;990        { &ParamHandle[4], nullptr                         , &TExchngToPC::tx_test           }, //TEST
;;;991        { &ParamHandle[5], &TExchngToPC::rx_start_adc      , &TExchngToPC::tx_adc            }, //START_ADC
;;;992        { &ParamHandle[6], &TExchngToPC::rx_cmp_capture    , &TExchngToPC::tx_cmp_capture    }, //CMP_CAPTURE
;;;993        { &ParamHandle[7], &TExchngToPC::rx_diff_capture   , &TExchngToPC::tx_diff_capture   }, //DIFF_CAPTURE
;;;994      };
;;;995      
;;;996      AD8402.init();
000020  4838              LDR      r0,|L4.260|
000022  f7fffffe          BL       _ZN8T_AD84024initEv ; T_AD8402::init()
;;;997      ExchngToPC.pin_clk_config();
000026  4838              LDR      r0,|L4.264|
000028  f7fffffe          BL       _ZN6TUsart14pin_clk_configEv ; TUsart::pin_clk_config()
;;;998      ExchngToPC.hw_init();
00002c  2100              MOVS     r1,#0
00002e  4836              LDR      r0,|L4.264|
000030  f7fffffe          BL       _ZN6TUsart7hw_initEh ; TUsart::hw_init(unsigned char)
;;;999      
;;;1000     ExchngToPC.init_tmr_freg();
000034  4834              LDR      r0,|L4.264|
000036  f7fffffe          BL       _ZN11TExchngToPC13init_tmr_fregEv ; TExchngToPC::init_tmr_freg()
;;;1001     ExchngToPC.init_tmr_cmp();
00003a  4833              LDR      r0,|L4.264|
00003c  f7fffffe          BL       _ZN11TExchngToPC12init_tmr_cmpEv ; TExchngToPC::init_tmr_cmp()
;;;1002     ExchngToPC.init_tmr_diff();
000040  4831              LDR      r0,|L4.264|
000042  f7fffffe          BL       _ZN11TExchngToPC13init_tmr_diffEv ; TExchngToPC::init_tmr_diff()
;;;1003     ExchngToPC.init_adc();
000046  4830              LDR      r0,|L4.264|
000048  f7fffffe          BL       _ZN11TExchngToPC8init_adcEv ; TExchngToPC::init_adc()
;;;1004     ExchngToPC.init_dma();
00004c  482e              LDR      r0,|L4.264|
00004e  f7fffffe          BL       _ZN11TExchngToPC8init_dmaEv ; TExchngToPC::init_dma()
;;;1005      
;;;1006     for ( ;; )
000052  bf00              NOP      
                  |L4.84|
;;;1007     {  
;;;1008   //    ExchngToPC.rx_start_adc( &ParamHandle[ PC_CMD::START_ADC ] );
;;;1009      
;;;1010       ExchngToPC.parse_pkt();                                   //ожидание валидного пакета
000054  482c              LDR      r0,|L4.264|
000056  f7fffffe          BL       _ZN10TExtMaster9parse_pktEv ; TExtMaster::parse_pkt()
;;;1011       for ( auto &item : CmdHandler )
00005a  af04              ADD      r7,sp,#0x10
00005c  463d              MOV      r5,r7
00005e  f10700a0          ADD      r0,r7,#0xa0
000062  9003              STR      r0,[sp,#0xc]
000064  e046              B        |L4.244|
                  |L4.102|
000066  462c              MOV      r4,r5
;;;1012       {
;;;1013         TExchngToPC::TData Data = ExchngToPC.get_data();
000068  4927              LDR      r1,|L4.264|
00006a  a801              ADD      r0,sp,#4
00006c  f7fffffe          BL       _ZN10TExtMaster8get_dataEv ; TExtMaster::get_data()
;;;1014   
;;;1015         if ( item.ParamHandle->Cmd == Data.Cmd )
000070  6820              LDR      r0,[r4,#0]
000072  7800              LDRB     r0,[r0,#0]
000074  f89d1004          LDRB     r1,[sp,#4]
000078  4288              CMP      r0,r1
00007a  d13a              BNE      |L4.242|
;;;1016         {
;;;1017           if ( item.rxHandler != nullptr )
00007c  6860              LDR      r0,[r4,#4]
00007e  b940              CBNZ     r0,|L4.146|
000080  2000              MOVS     r0,#0
000082  4280              CMP      r0,r0
000084  d103              BNE      |L4.142|
000086  7a20              LDRB     r0,[r4,#8]
000088  f0000001          AND      r0,r0,#1
00008c  b1e0              CBZ      r0,|L4.200|
                  |L4.142|
00008e  68a0              LDR      r0,[r4,#8]
000090  b1d0              CBZ      r0,|L4.200|
                  |L4.146|
;;;1018           {
;;;1019             item.ParamHandle->RxVal = Data.ParamVal;
000092  f8dd0005          LDR      r0,[sp,#5]
000096  6821              LDR      r1,[r4,#0]
000098  6048              STR      r0,[r1,#4]
;;;1020             ( ExchngToPC.*item.rxHandler )( item.ParamHandle );
00009a  491b              LDR      r1,|L4.264|
00009c  68a0              LDR      r0,[r4,#8]
00009e  eb010960          ADD      r9,r1,r0,ASR #1
0000a2  7a20              LDRB     r0,[r4,#8]
0000a4  f0000001          AND      r0,r0,#1
0000a8  b908              CBNZ     r0,|L4.174|
0000aa  6860              LDR      r0,[r4,#4]
0000ac  e006              B        |L4.188|
                  |L4.174|
0000ae  f8d90000          LDR      r0,[r9,#0]
0000b2  6861              LDR      r1,[r4,#4]
0000b4  eb000a01          ADD      r10,r0,r1
0000b8  f8da0000          LDR      r0,[r10,#0]
                  |L4.188|
0000bc  9000              STR      r0,[sp,#0]
0000be  4648              MOV      r0,r9
0000c0  6821              LDR      r1,[r4,#0]
0000c2  9a00              LDR      r2,[sp,#0]
0000c4  4790              BLX      r2
;;;1021           }
0000c6  bf00              NOP      
                  |L4.200|
;;;1022           
;;;1023           ( ExchngToPC.*item.txHandler )( item.ParamHandle );
0000c8  490f              LDR      r1,|L4.264|
0000ca  6920              LDR      r0,[r4,#0x10]
0000cc  eb010660          ADD      r6,r1,r0,ASR #1
0000d0  7c20              LDRB     r0,[r4,#0x10]
0000d2  f0000001          AND      r0,r0,#1
0000d6  b908              CBNZ     r0,|L4.220|
0000d8  68e0              LDR      r0,[r4,#0xc]
0000da  e005              B        |L4.232|
                  |L4.220|
0000dc  6830              LDR      r0,[r6,#0]
0000de  68e1              LDR      r1,[r4,#0xc]
0000e0  eb000801          ADD      r8,r0,r1
0000e4  f8d80000          LDR      r0,[r8,#0]
                  |L4.232|
0000e8  4683              MOV      r11,r0
0000ea  4630              MOV      r0,r6
0000ec  6821              LDR      r1,[r4,#0]
0000ee  47d8              BLX      r11
;;;1024   
;;;1025           break;
0000f0  e003              B        |L4.250|
                  |L4.242|
;;;1026         }
;;;1027       };
0000f2  3514              ADDS     r5,r5,#0x14
                  |L4.244|
0000f4  9803              LDR      r0,[sp,#0xc]
0000f6  4285              CMP      r5,r0
0000f8  d1b5              BNE      |L4.102|
                  |L4.250|
0000fa  e7ab              B        |L4.84|
;;;1028       
;;;1029      //если команда в принятом пакете не была найдена, то ответ не отправляется
;;;1030       
;;;1031   //    vTaskDelay( pdMS_TO_TICKS( 2U ) );
;;;1032     }  
;;;1033   }
;;;1034   //----- //Задача RTOS ---------------------------------------------------------------------
                          ENDP

                  |L4.252|
                          DCD      UCG1
                  |L4.256|
                          DCD      ||.constdata||+0x4c
                  |L4.260|
                          DCD      AD8402
                  |L4.264|
                          DCD      ExchngToPC

                          AREA ||i._ZN11TExchngToPC11rx_set_fregEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC11rx_set_fregEPNS_12TParamHandleE PROC ; TExchngToPC::rx_set_freg(TExchngToPC::TParamHandle*)
;;;617    //----- Обработчики приема -------------------------------------------------------------------------------------
;;;618    void TExchngToPC::rx_set_freg( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;619    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;620      ctrl_pwm( ParamHandle );
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN11TExchngToPC8ctrl_pwmEPNS_12TParamHandleE ; TExchngToPC::ctrl_pwm(TExchngToPC::TParamHandle*)
;;;621    }
00000e  bd70              POP      {r4-r6,pc}
;;;622    
                          ENDP


                          AREA ||i._ZN11TExchngToPC11tx_set_fregEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC11tx_set_fregEPNS_12TParamHandleE PROC ; TExchngToPC::tx_set_freg(TExchngToPC::TParamHandle*)
;;;809    //----- Обработчики передачи -----------------------------------------------------------------------------------
;;;810    void TExchngToPC::tx_set_freg( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;811    {  
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;812      tx_data(
000006  7d22              LDRB     r2,[r4,#0x14]
000008  2303              MOVS     r3,#3
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;813              ParamHandle->SetVal.Addr,
;;;814              ParamHandle->SetVal.BytesQty,
;;;815              TWrapTxSign::__ALL_WRAP_TX
;;;816             );
;;;817    }
000012  bd70              POP      {r4-r6,pc}
;;;818    
                          ENDP


                          AREA ||i._ZN11TExchngToPC12init_tmr_cmpEv||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC12init_tmr_cmpEv PROC ; TExchngToPC::init_tmr_cmp()
;;;237    
;;;238    void TExchngToPC::init_tmr_cmp()
000000  b510              PUSH     {r4,lr}
;;;239    {
000002  4604              MOV      r4,r0
;;;240      TmrCmp.Pin.en_clk   ( TmrCmp.Pin.ClkPortMask );       //тактирование GPIO, к которому подключен выход таймера
000004  6c22              LDR      r2,[r4,#0x40]
000006  e9d2010a          LDRD     r0,r1,[r2,#0x28]
00000a  4788              BLX      r1
;;;241      TmrCmp.Clk.en_periph( TmrCmp.Clk.PeriphMask );        //тактирование таймера
00000c  6c22              LDR      r2,[r4,#0x40]
00000e  e9d21004          LDRD     r1,r0,[r2,#0x10]
000012  4788              BLX      r1
;;;242    
;;;243      //настройка вывода CMP
;;;244      LL_GPIO_SetPinMode( 
000014  6c22              LDR      r2,[r4,#0x40]
000016  e9d20108          LDRD     r0,r1,[r2,#0x20]
00001a  2202              MOVS     r2,#2
00001c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinMode(GPIO_TypeDef*, unsigned, unsigned)
;;;245                         TmrCmp.Pin.Gpio,
;;;246                         TmrCmp.Pin.Nbr,
;;;247                         LL_GPIO_MODE_ALTERNATE
;;;248                        );
;;;249      LL_GPIO_SetPinSpeed(
000020  6c22              LDR      r2,[r4,#0x40]
000022  e9d20108          LDRD     r0,r1,[r2,#0x20]
000026  2202              MOVS     r2,#2
000028  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinSpeed(GPIO_TypeDef*, unsigned, unsigned)
;;;250                          TmrCmp.Pin.Gpio,
;;;251                          TmrCmp.Pin.Nbr,
;;;252                          LL_GPIO_SPEED_FREQ_HIGH
;;;253                         );
;;;254      LL_GPIO_SetPinPull(
00002c  6c22              LDR      r2,[r4,#0x40]
00002e  e9d20108          LDRD     r0,r1,[r2,#0x20]
000032  2200              MOVS     r2,#0
000034  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinPull(GPIO_TypeDef*, unsigned, unsigned)
;;;255                         TmrCmp.Pin.Gpio,
;;;256                         TmrCmp.Pin.Nbr,
;;;257                         LL_GPIO_PULL_NO
;;;258                        );
;;;259      LL_GPIO_SetAFPin_0_7(
000038  6c23              LDR      r3,[r4,#0x40]
00003a  6b1a              LDR      r2,[r3,#0x30]
00003c  e9d30108          LDRD     r0,r1,[r3,#0x20]
000040  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_GPIO_SetAFPin_0_7EP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetAFPin_0_7(GPIO_TypeDef*, unsigned, unsigned)
;;;260                            TmrCmp.Pin.Gpio,
;;;261                            TmrCmp.Pin.Nbr,
;;;262                            TmrCmp.Pin.AlternateMask        //TIM2_CH2
;;;263                           );
;;;264    
;;;265      LL_TIM_SetSlaveMode(
000044  6c21              LDR      r1,[r4,#0x40]
000046  6808              LDR      r0,[r1,#0]
000048  2100              MOVS     r1,#0
00004a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetSlaveMode(TIM_TypeDef*, unsigned)
;;;266                          TmrCmp.Nbr,
;;;267                          LL_TIM_SLAVEMODE_DISABLED
;;;268                         );
;;;269    
;;;270    //  TPwm Pwm = cnt_pwm();
;;;271    
;;;272      LL_TIM_SetPrescaler( TmrCmp.Nbr, 0U );
00004e  6c21              LDR      r1,[r4,#0x40]
000050  6808              LDR      r0,[r1,#0]
000052  2100              MOVS     r1,#0
000054  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetPrescaler(TIM_TypeDef*, unsigned)
;;;273      LL_TIM_EnableARRPreload( TmrCmp.Nbr );
000058  6c21              LDR      r1,[r4,#0x40]
00005a  6808              LDR      r0,[r1,#0]
00005c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableARRPreloadEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableARRPreload(TIM_TypeDef*)
;;;274    
;;;275      LL_TIM_SetAutoReload(
000060  6c22              LDR      r2,[r4,#0x40]
000062  68d1              LDR      r1,[r2,#0xc]
000064  6810              LDR      r0,[r2,#0]
000066  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetAutoReload(TIM_TypeDef*, unsigned)
;;;276                           TmrCmp.Nbr,
;;;277                           TmrCmp.ARR_MAX
;;;278                          );
;;;279      LL_TIM_IC_SetActiveInput(                              //канал конфигурируется как вход и 
00006a  6c22              LDR      r2,[r4,#0x40]
00006c  6891              LDR      r1,[r2,#8]
00006e  6810              LDR      r0,[r2,#0]
000070  f44f3280          MOV      r2,#0x10000
000074  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_TIM_IC_SetActiveInputEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetActiveInput(TIM_TypeDef*, unsigned, unsigned)
;;;280                               TmrCmp.Nbr,                   //CCR1 становится read-only
;;;281                               TmrCmp.Ch,
;;;282                               LL_TIM_ACTIVEINPUT_DIRECTTI   
;;;283                              );
;;;284      LL_TIM_IC_SetFilter(
000078  6c22              LDR      r2,[r4,#0x40]
00007a  6891              LDR      r1,[r2,#8]
00007c  6810              LDR      r0,[r2,#0]
00007e  f44f1280          MOV      r2,#0x100000
000082  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_IC_SetFilterEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetFilter(TIM_TypeDef*, unsigned, unsigned)
;;;285                          TmrCmp.Nbr,
;;;286                          TmrCmp.Ch,
;;;287                          LL_TIM_IC_FILTER_FDIV1_N2
;;;288                         );
;;;289      LL_TIM_IC_SetPolarity(
000086  6c22              LDR      r2,[r4,#0x40]
000088  6891              LDR      r1,[r2,#8]
00008a  6810              LDR      r0,[r2,#0]
00008c  2200              MOVS     r2,#0
00008e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_IC_SetPolarityEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetPolarity(TIM_TypeDef*, unsigned, unsigned)
;;;290                            TmrCmp.Nbr,
;;;291                            TmrCmp.Ch,
;;;292                            LL_TIM_IC_POLARITY_RISING
;;;293                           );
;;;294      LL_TIM_IC_SetPrescaler(
000092  6c22              LDR      r2,[r4,#0x40]
000094  6891              LDR      r1,[r2,#8]
000096  6810              LDR      r0,[r2,#0]
000098  2200              MOVS     r2,#0
00009a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_IC_SetPrescalerEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetPrescaler(TIM_TypeDef*, unsigned, unsigned)
;;;295                             TmrCmp.Nbr,                     //захват на каждом валидном переходе, т.е. предделитель отключен
;;;296                             TmrCmp.Ch,                      //предделитель сбрасывается как только CCxE=0 в регистре CCER (захват отключается)
;;;297                             LL_TIM_ICPSC_DIV1
;;;298                            );
;;;299      LL_TIM_CC_EnableChannel(
00009e  6c22              LDR      r2,[r4,#0x40]
0000a0  6891              LDR      r1,[r2,#8]
0000a2  6810              LDR      r0,[r2,#0]
0000a4  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_CC_EnableChannel(TIM_TypeDef*, unsigned)
;;;300                              TmrCmp.Nbr,
;;;301                              TmrCmp.Ch
;;;302                             );
;;;303      
;;;304    
;;;305    //  LL_TIM_EnableCounter( TmrCmp.Nbr );
;;;306    //  LL_TIM_EnableAllOutputs( TmrCmp.Nbr );
;;;307    }
0000a8  bd10              POP      {r4,pc}
;;;308    
                          ENDP


                          AREA ||i._ZN11TExchngToPC12rx_start_adcEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC12rx_start_adcEPNS_12TParamHandleE PROC ; TExchngToPC::rx_start_adc(TExchngToPC::TParamHandle*)
;;;641    
;;;642    void TExchngToPC::rx_start_adc( TExchngToPC::TParamHandle *ParamHandle )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;643    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;644      ParamHandle->RxVal = chk_range( ParamHandle->RxVal, ParamHandle->Range );
000008  edd50a01          VLDR     s1,[r5,#4]
00000c  eeb00a60          VMOV.F32 s0,s1
000010  f1050108          ADD      r1,r5,#8
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       _ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE ; TExchngToPC::chk_range(float, const TExchngToPC::TRange&)
00001a  ed850a01          VSTR     s0,[r5,#4]
;;;645    //  ParamHandle->RxVal = TX_SIZE;
;;;646    
;;;647      uint16_t DataQty   = ParamHandle->RxVal;
00001e  ed950a01          VLDR     s0,[r5,#4]
000022  eebc0ac0          VCVT.U32.F32 s0,s0
000026  ee100a10          VMOV     r0,s0
00002a  b286              UXTH     r6,r0
;;;648      
;;;649        UCG1.off(); //на время оцифровки пробросить сигнал с генератора
00002c  4870              LDR      r0,|L8.496|
00002e  f7fffffe          BL       _ZN4TLed3offEv ; TLed::off()
;;;650        
;;;651        init_diff_exti( Adc.Exti.Trigger );                                         //инициализация вывода DIFF, предназначенного для запуска преобразования АЦП
000032  6ca0              LDR      r0,[r4,#0x48]
000034  6e01              LDR      r1,[r0,#0x60]
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       _ZN11TExchngToPC14init_diff_extiEj ; TExchngToPC::init_diff_exti(unsigned)
;;;652        xSemaphoreTake( DiffExti_TrigSem, portMAX_DELAY );                          //ожидание заднего фронта на DIFF
00003c  2300              MOVS     r3,#0
00003e  1e5a              SUBS     r2,r3,#1
000040  4619              MOV      r1,r3
000042  486c              LDR      r0,|L8.500|
000044  6800              LDR      r0,[r0,#0]  ; DiffExti_TrigSem
000046  f7fffffe          BL       xQueueGenericReceive
;;;653          deinit_diff_exti();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       _ZN11TExchngToPC16deinit_diff_extiEv ; TExchngToPC::deinit_diff_exti()
;;;654        
;;;655        //оцифровка до получения количества выборок == принятому значению в параметре
;;;656        en_adc();
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       _ZN11TExchngToPC6en_adcEv ; TExchngToPC::en_adc()
;;;657        en_dma_with_adc( DataQty );
000056  4631              MOV      r1,r6
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       _ZN11TExchngToPC15en_dma_with_adcEt ; TExchngToPC::en_dma_with_adc(unsigned short)
;;;658        /*
;;;659        *  Биты управления кроме DIFSEL, ADCAL, ADEN можно записывать только если АЦП включен
;;;660        */
;;;661        //выбор общего числа преобразований в регулярной группе
;;;662        //каждому номеру преобразования можно поставить в соответствие свой номер канала АЦП
;;;663        //SQR-регистры не должны быть модифицированы когда происходят регулярные преобразования
;;;664        
;;;665        //остановить регулярные преобразования - при установке ADSTP текущее продолжающееся преобразование обрывается \
;;;666          с частичным отбрасыванием результата ( DR регистр не обновляется в текущем преобразовании )
;;;667        LL_ADC_REG_StopConversion( Adc.Nbr );
00005e  6ca1              LDR      r1,[r4,#0x48]
000060  6808              LDR      r0,[r1,#0]
000062  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_StopConversion(ADC_TypeDef*)
;;;668        do {} while( LL_ADC_REG_IsStopConversionOngoing( Adc.Nbr ) == true );
000066  bf00              NOP      
                  |L8.104|
000068  6ca1              LDR      r1,[r4,#0x48]
00006a  6808              LDR      r0,[r1,#0]
00006c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef*)
000070  2801              CMP      r0,#1
000072  d0f9              BEQ      |L8.104|
;;;669        do {} while( LL_ADC_REG_IsConversionOngoing( Adc.Nbr ) == true );
000074  bf00              NOP      
                  |L8.118|
000076  6ca1              LDR      r1,[r4,#0x48]
000078  6808              LDR      r0,[r1,#0]
00007a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsConversionOngoing(ADC_TypeDef*)
00007e  2801              CMP      r0,#1
000080  d0f9              BEQ      |L8.118|
;;;670        
;;;671        LL_ADC_REG_SetSequencerLength( Adc.Nbr, LL_ADC_REG_SEQ_SCAN_DISABLE );
000082  6ca2              LDR      r2,[r4,#0x48]
000084  2100              MOVS     r1,#0
000086  6810              LDR      r0,[r2,#0]
000088  6b02              LDR      r2,[r0,#0x30]
00008a  f022020f          BIC      r2,r2,#0xf
00008e  430a              ORRS     r2,r2,r1
000090  6302              STR      r2,[r0,#0x30]
000092  bf00              NOP      
;;;672        LL_ADC_REG_SetSequencerRanks( Adc.Nbr, LL_ADC_REG_RANK_1, Adc.Ch );
000094  6ca3              LDR      r3,[r4,#0x48]
000096  2006              MOVS     r0,#6
000098  68da              LDR      r2,[r3,#0xc]
00009a  6819              LDR      r1,[r3,#0]
00009c  2700              MOVS     r7,#0
00009e  f44f7c40          MOV      r12,#0x300
0000a2  fa9cfcac          RBIT     r12,r12
0000a6  fabcfc8c          CLZ      r12,r12
0000aa  fa27f70c          LSR      r7,r7,r12
0000ae  f1010c30          ADD      r12,r1,#0x30
0000b2  eb0c0387          ADD      r3,r12,r7,LSL #2
0000b6  f04f0c1f          MOV      r12,#0x1f
0000ba  fa0cfc00          LSL      r12,r12,r0
0000be  681f              LDR      r7,[r3,#0]
0000c0  ea27070c          BIC      r7,r7,r12
0000c4  f3c26c84          UBFX     r12,r2,#26,#5
0000c8  fa0cfc00          LSL      r12,r12,r0
0000cc  ea47070c          ORR      r7,r7,r12
0000d0  601f              STR      r7,[r3,#0]
0000d2  bf00              NOP      
;;;673        
;;;674        //перед запуском преобразования АЦП нужно установить непосредственную связь между источником напряжения (на входе АЦП) и \
;;;675          встроенным конденсатором выборки АЦП. \
;;;676          это время выборки должно быть достаточным для источника напряжения чтобы зарядить встроенные конденсаторы до \
;;;677          уровня входного напряжения. \
;;;678          Internal sample and hold capacitor: Cadc = 5pF ( DS11453 Rev 3 )
;;;679        //время выборки каждого канала программируется битами SMP в регистре SMPR1.
;;;680        //вычисление общего времени преобразования : \
;;;681          Tconv = Sampling time + 12.5 ADC clock cycles
;;;682        
;;;683        //I/O analog switches voltage booster - описание того что делать когда Vdda становится слишком низким
;;;684        LL_ADC_REG_SetOverrun( Adc.Nbr, LL_ADC_REG_OVR_DATA_OVERWRITTEN );
0000d4  6ca2              LDR      r2,[r4,#0x48]
0000d6  f44f5180          MOV      r1,#0x1000
0000da  6810              LDR      r0,[r2,#0]
0000dc  68c2              LDR      r2,[r0,#0xc]
0000de  f4225280          BIC      r2,r2,#0x1000
0000e2  430a              ORRS     r2,r2,r1
0000e4  60c2              STR      r2,[r0,#0xc]
0000e6  bf00              NOP      
;;;685        
;;;686        
;;;687        
;;;688        LL_ADC_SetChannelSamplingTime( Adc.Nbr, Adc.Ch, LL_ADC_SAMPLINGTIME_2CYCLES_5 ); //установка времени выборки канала. \
0000e8  6ca3              LDR      r3,[r4,#0x48]
0000ea  2200              MOVS     r2,#0
0000ec  6819              LDR      r1,[r3,#0]
0000ee  68d8              LDR      r0,[r3,#0xc]
0000f0  f0007700          AND      r7,r0,#0x2000000
0000f4  f04f7c00          MOV      r12,#0x2000000
0000f8  fa9cfcac          RBIT     r12,r12
0000fc  fabcfc8c          CLZ      r12,r12
000100  fa27f70c          LSR      r7,r7,r12
000104  f1010c14          ADD      r12,r1,#0x14
000108  eb0c0387          ADD      r3,r12,r7,LSL #2
00010c  f0007cf8          AND      r12,r0,#0x1f00000
000110  f04f78f8          MOV      r8,#0x1f00000
000114  fa98f8a8          RBIT     r8,r8
000118  fab8f888          CLZ      r8,r8
00011c  fa2cfc08          LSR      r12,r12,r8
000120  f04f0807          MOV      r8,#7
000124  fa08f80c          LSL      r8,r8,r12
000128  681f              LDR      r7,[r3,#0]
00012a  ea270708          BIC      r7,r7,r8
00012e  f0007cf8          AND      r12,r0,#0x1f00000
000132  f04f78f8          MOV      r8,#0x1f00000
000136  fa98f8a8          RBIT     r8,r8
00013a  fab8f888          CLZ      r8,r8
00013e  fa2cfc08          LSR      r12,r12,r8
000142  fa02fc0c          LSL      r12,r2,r12
000146  ea47070c          ORR      r7,r7,r12
00014a  601f              STR      r7,[r3,#0]
00014c  bf00              NOP      
;;;689                                                                                           во время выборки биты выбора канала не должны изменяться
;;;690        LL_ADC_REG_SetContinuousMode( Adc.Nbr, LL_ADC_REG_CONV_CONTINUOUS ); //запрещено включать вместе прерывистый и непрерывный режимы работы
00014e  6ca2              LDR      r2,[r4,#0x48]
000150  f44f5100          MOV      r1,#0x2000
000154  6810              LDR      r0,[r2,#0]
000156  68c2              LDR      r2,[r0,#0xc]
000158  f4225200          BIC      r2,r2,#0x2000
00015c  430a              ORRS     r2,r2,r1
00015e  60c2              STR      r2,[r0,#0xc]
000160  bf00              NOP      
;;;691        LL_ADC_REG_SetTriggerSource( Adc.Nbr, LL_ADC_REG_TRIG_SOFTWARE );    //источник запуска группы регулярных преобразований    
000162  6ca2              LDR      r2,[r4,#0x48]
000164  2100              MOVS     r1,#0
000166  6810              LDR      r0,[r2,#0]
000168  68c2              LDR      r2,[r0,#0xc]
00016a  f422627c          BIC      r2,r2,#0xfc0
00016e  430a              ORRS     r2,r2,r1
000170  60c2              STR      r2,[r0,#0xc]
000172  bf00              NOP      
;;;692        //возможно выполнить более быстрое преобразование снижением разрешения АЦП
;;;693        LL_ADC_SetResolution( Adc.Nbr, LL_ADC_RESOLUTION_8B );               //время одного преобразования (Fadc=8MHz, RES=8bits) =  1,375us
000174  6ca2              LDR      r2,[r4,#0x48]
000176  2110              MOVS     r1,#0x10
000178  6810              LDR      r0,[r2,#0]
00017a  68c2              LDR      r2,[r0,#0xc]
00017c  f0220218          BIC      r2,r2,#0x18
000180  430a              ORRS     r2,r2,r1
000182  60c2              STR      r2,[r0,#0xc]
000184  bf00              NOP      
;;;694        
;;;695        LL_ADC_SetDataAlignment( Adc.Nbr, LL_ADC_DATA_ALIGN_RIGHT );         //выравнивание данных   
000186  6ca2              LDR      r2,[r4,#0x48]
000188  2100              MOVS     r1,#0
00018a  6810              LDR      r0,[r2,#0]
00018c  68c2              LDR      r2,[r0,#0xc]
00018e  f0220220          BIC      r2,r2,#0x20
000192  430a              ORRS     r2,r2,r1
000194  60c2              STR      r2,[r0,#0xc]
000196  bf00              NOP      
;;;696        LL_ADC_REG_StartConversion( Adc.Nbr );                               //запуск группы регулярных преобразований АЦП \
000198  6ca1              LDR      r1,[r4,#0x48]
00019a  6808              LDR      r0,[r1,#0]
00019c  6881              LDR      r1,[r0,#8]
00019e  4a16              LDR      r2,|L8.504|
0001a0  4011              ANDS     r1,r1,r2
0001a2  1d09              ADDS     r1,r1,#4
0001a4  6081              STR      r1,[r0,#8]
0001a6  bf00              NOP      
;;;697                                                                               т.к. был выбран программный триггер, то преобразование запускается немедленно
;;;698        
;;;699        
;;;700        xSemaphoreTake( DmaAdcMeas_CompSem, portMAX_DELAY );                 //ожидание завершения работы DMA с ADC
0001a8  2300              MOVS     r3,#0
0001aa  1e5a              SUBS     r2,r3,#1
0001ac  4619              MOV      r1,r3
0001ae  4813              LDR      r0,|L8.508|
0001b0  6800              LDR      r0,[r0,#0]  ; DmaAdcMeas_CompSem
0001b2  f7fffffe          BL       xQueueGenericReceive
;;;701        
;;;702    //    for ( uint16_t Ctr = 0U; Ctr < DataQty ; ++Ctr )
;;;703    //    {
;;;704    //      do {} while ( LL_ADC_IsActiveFlag_EOC( Adc.Nbr ) == false );
;;;705    //      
;;;706    //      Data[ Ctr ] = LL_ADC_REG_ReadConversionData8( Adc.Nbr );
;;;707    ////      Data[ Ctr ] = ( Ctr % 2 ) ? 77
;;;708    ////                                : 55;
;;;709    //      
;;;710    ////      LL_ADC_ClearFlag_EOC( Adc.Nbr );
;;;711    //    }
;;;712        
;;;713        //устанавливается бит ADSTP => продолжающееся регулярное преобразование обрывается с частичной потерей результата. \
;;;714          по завершении процедуры биты ADSTP/ADSTART (для регулярного преобразования) сбрасываются аппаратно и программа \
;;;715          должна опрашивать ADSTART пока этот бит не сбросится что даст понять что АЦП полностью остановлен.
;;;716        LL_ADC_REG_StopConversion( Adc.Nbr ); 
0001b6  6ca1              LDR      r1,[r4,#0x48]
0001b8  6808              LDR      r0,[r1,#0]
0001ba  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_StopConversion(ADC_TypeDef*)
;;;717        do {} while ( LL_ADC_REG_IsStopConversionOngoing( Adc.Nbr ) == true ); //опрос ADSTP
0001be  bf00              NOP      
                  |L8.448|
0001c0  6ca1              LDR      r1,[r4,#0x48]
0001c2  6808              LDR      r0,[r1,#0]
0001c4  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef*)
0001c8  2801              CMP      r0,#1
0001ca  d0f9              BEQ      |L8.448|
;;;718        do {} while ( LL_ADC_REG_IsConversionOngoing( Adc.Nbr ) == true );     //опрос ADSTART
0001cc  bf00              NOP      
                  |L8.462|
0001ce  6ca1              LDR      r1,[r4,#0x48]
0001d0  6808              LDR      r0,[r1,#0]
0001d2  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsConversionOngoing(ADC_TypeDef*)
0001d6  2801              CMP      r0,#1
0001d8  d0f9              BEQ      |L8.462|
;;;719            
;;;720        dis_adc();
0001da  4620              MOV      r0,r4
0001dc  f7fffffe          BL       _ZN11TExchngToPC7dis_adcEv ; TExchngToPC::dis_adc()
;;;721        dis_dma_with_adc();    
0001e0  4620              MOV      r0,r4
0001e2  f7fffffe          BL       _ZN11TExchngToPC16dis_dma_with_adcEv ; TExchngToPC::dis_dma_with_adc()
;;;722        
;;;723        UCG1.on();
0001e6  4802              LDR      r0,|L8.496|
0001e8  f7fffffe          BL       _ZN4TLed2onEv ; TLed::on()
;;;724    }
0001ec  e8bd81f0          POP      {r4-r8,pc}
;;;725    
                          ENDP

                  |L8.496|
                          DCD      UCG1
                  |L8.500|
                          DCD      DiffExti_TrigSem
                  |L8.504|
                          DCD      0x7fffffc0
                  |L8.508|
                          DCD      DmaAdcMeas_CompSem

                          AREA ||i._ZN11TExchngToPC13init_tmr_diffEv||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC13init_tmr_diffEv PROC ; TExchngToPC::init_tmr_diff()
;;;308    
;;;309    void TExchngToPC::init_tmr_diff()
000000  b510              PUSH     {r4,lr}
;;;310    {
000002  4604              MOV      r4,r0
;;;311      TmrDiff.Pin.en_clk   ( TmrDiff.Pin.ClkPortMask );       //тактирование GPIO, к которому подключен выход таймера
000004  6c62              LDR      r2,[r4,#0x44]
000006  e9d2010a          LDRD     r0,r1,[r2,#0x28]
00000a  4788              BLX      r1
;;;312      TmrDiff.Clk.en_periph( TmrDiff.Clk.PeriphMask );        //тактирование таймера
00000c  6c62              LDR      r2,[r4,#0x44]
00000e  e9d21004          LDRD     r1,r0,[r2,#0x10]
000012  4788              BLX      r1
;;;313    
;;;314      //настройка вывода CMP
;;;315      LL_GPIO_SetPinMode( 
000014  6c62              LDR      r2,[r4,#0x44]
000016  e9d20108          LDRD     r0,r1,[r2,#0x20]
00001a  2202              MOVS     r2,#2
00001c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinMode(GPIO_TypeDef*, unsigned, unsigned)
;;;316                         TmrDiff.Pin.Gpio,
;;;317                         TmrDiff.Pin.Nbr,
;;;318                         LL_GPIO_MODE_ALTERNATE
;;;319                        );
;;;320      LL_GPIO_SetPinSpeed(
000020  6c62              LDR      r2,[r4,#0x44]
000022  e9d20108          LDRD     r0,r1,[r2,#0x20]
000026  2202              MOVS     r2,#2
000028  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinSpeed(GPIO_TypeDef*, unsigned, unsigned)
;;;321                          TmrDiff.Pin.Gpio,
;;;322                          TmrDiff.Pin.Nbr,
;;;323                          LL_GPIO_SPEED_FREQ_HIGH
;;;324                         );
;;;325      LL_GPIO_SetPinPull(
00002c  6c62              LDR      r2,[r4,#0x44]
00002e  e9d20108          LDRD     r0,r1,[r2,#0x20]
000032  2200              MOVS     r2,#0
000034  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinPull(GPIO_TypeDef*, unsigned, unsigned)
;;;326                         TmrDiff.Pin.Gpio,
;;;327                         TmrDiff.Pin.Nbr,
;;;328                         LL_GPIO_PULL_NO
;;;329                        );
;;;330      LL_GPIO_SetAFPin_0_7(
000038  6c63              LDR      r3,[r4,#0x44]
00003a  6b1a              LDR      r2,[r3,#0x30]
00003c  e9d30108          LDRD     r0,r1,[r3,#0x20]
000040  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_GPIO_SetAFPin_0_7EP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetAFPin_0_7(GPIO_TypeDef*, unsigned, unsigned)
;;;331                            TmrDiff.Pin.Gpio,
;;;332                            TmrDiff.Pin.Nbr,
;;;333                            TmrDiff.Pin.AlternateMask        //TIM2_CH2
;;;334                           );
;;;335    
;;;336      LL_TIM_SetSlaveMode(
000044  6c61              LDR      r1,[r4,#0x44]
000046  6808              LDR      r0,[r1,#0]
000048  2100              MOVS     r1,#0
00004a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetSlaveMode(TIM_TypeDef*, unsigned)
;;;337                          TmrDiff.Nbr,
;;;338                          LL_TIM_SLAVEMODE_DISABLED
;;;339                         );
;;;340    
;;;341    //  TPwm Pwm = cnt_pwm();
;;;342    
;;;343      LL_TIM_SetPrescaler( TmrDiff.Nbr, 0U );
00004e  6c61              LDR      r1,[r4,#0x44]
000050  6808              LDR      r0,[r1,#0]
000052  2100              MOVS     r1,#0
000054  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetPrescaler(TIM_TypeDef*, unsigned)
;;;344    //  LL_TIM_EnableARRPreload( TmrDiff.Nbr );
;;;345      LL_TIM_DisableARRPreload( TmrDiff.Nbr );
000058  6c61              LDR      r1,[r4,#0x44]
00005a  6808              LDR      r0,[r1,#0]
00005c  6801              LDR      r1,[r0,#0]
00005e  f0210180          BIC      r1,r1,#0x80
000062  6001              STR      r1,[r0,#0]
000064  bf00              NOP      
;;;346      LL_TIM_SetAutoReload(
000066  6c62              LDR      r2,[r4,#0x44]
000068  68d1              LDR      r1,[r2,#0xc]
00006a  6810              LDR      r0,[r2,#0]
00006c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetAutoReload(TIM_TypeDef*, unsigned)
;;;347                           TmrDiff.Nbr,
;;;348                           TmrDiff.ARR_MAX
;;;349                          );
;;;350      LL_TIM_IC_SetActiveInput(                              //канал конфигурируется как вход и 
000070  6c62              LDR      r2,[r4,#0x44]
000072  6891              LDR      r1,[r2,#8]
000074  6810              LDR      r0,[r2,#0]
000076  f44f3280          MOV      r2,#0x10000
00007a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_TIM_IC_SetActiveInputEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetActiveInput(TIM_TypeDef*, unsigned, unsigned)
;;;351                               TmrDiff.Nbr,                   //CCR1 становится read-only
;;;352                               TmrDiff.Ch,
;;;353                               LL_TIM_ACTIVEINPUT_DIRECTTI   
;;;354                              );
;;;355      LL_TIM_IC_SetFilter(
00007e  6c62              LDR      r2,[r4,#0x44]
000080  6891              LDR      r1,[r2,#8]
000082  6810              LDR      r0,[r2,#0]
000084  f44f1280          MOV      r2,#0x100000
000088  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_IC_SetFilterEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetFilter(TIM_TypeDef*, unsigned, unsigned)
;;;356                          TmrDiff.Nbr,
;;;357                          TmrDiff.Ch,
;;;358                          LL_TIM_IC_FILTER_FDIV1_N2
;;;359                         );
;;;360      LL_TIM_IC_SetPolarity(
00008c  6c62              LDR      r2,[r4,#0x44]
00008e  6891              LDR      r1,[r2,#8]
000090  6810              LDR      r0,[r2,#0]
000092  2200              MOVS     r2,#0
000094  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_IC_SetPolarityEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetPolarity(TIM_TypeDef*, unsigned, unsigned)
;;;361                            TmrDiff.Nbr,
;;;362                            TmrDiff.Ch,
;;;363                            LL_TIM_IC_POLARITY_RISING
;;;364                           );
;;;365      LL_TIM_IC_SetPrescaler(
000098  6c62              LDR      r2,[r4,#0x44]
00009a  6891              LDR      r1,[r2,#8]
00009c  6810              LDR      r0,[r2,#0]
00009e  2200              MOVS     r2,#0
0000a0  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_IC_SetPrescalerEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetPrescaler(TIM_TypeDef*, unsigned, unsigned)
;;;366                             TmrDiff.Nbr,                     //захват на каждом валидном переходе, т.е. предделитель отключен
;;;367                             TmrDiff.Ch,                      //предделитель сбрасывается как только CCxE=0 в регистре CCER (захват отключается)
;;;368                             LL_TIM_ICPSC_DIV1
;;;369                            );
;;;370      LL_TIM_CC_EnableChannel(
0000a4  6c62              LDR      r2,[r4,#0x44]
0000a6  6891              LDR      r1,[r2,#8]
0000a8  6810              LDR      r0,[r2,#0]
0000aa  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_CC_EnableChannel(TIM_TypeDef*, unsigned)
;;;371                              TmrDiff.Nbr,
;;;372                              TmrDiff.Ch
;;;373                             );
;;;374    }
0000ae  bd10              POP      {r4,pc}
;;;375    
                          ENDP


                          AREA ||i._ZN11TExchngToPC13init_tmr_fregEv||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC13init_tmr_fregEv PROC ; TExchngToPC::init_tmr_freg()
;;;145    
;;;146    void TExchngToPC::init_tmr_freg()
000000  b57c              PUSH     {r2-r6,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148      TmrFreg.Pin.en_clk( TmrFreg.Pin.ClkPortMask );   //тактирование GPIO, к которому подключен выход таймера
000004  6be2              LDR      r2,[r4,#0x3c]
000006  e9d2010a          LDRD     r0,r1,[r2,#0x28]
00000a  4788              BLX      r1
;;;149      TmrFreg.Clk.en_periph( TmrFreg.Clk.PeriphMask ); //тактирование таймера
00000c  6be2              LDR      r2,[r4,#0x3c]
00000e  e9d21004          LDRD     r1,r0,[r2,#0x10]
000012  4788              BLX      r1
;;;150    
;;;151      //настройка вывода FREG
;;;152      LL_GPIO_SetPinMode( 
000014  6be2              LDR      r2,[r4,#0x3c]
000016  e9d20108          LDRD     r0,r1,[r2,#0x20]
00001a  2202              MOVS     r2,#2
00001c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinMode(GPIO_TypeDef*, unsigned, unsigned)
;;;153                         TmrFreg.Pin.Gpio,
;;;154                         TmrFreg.Pin.Nbr,
;;;155                         LL_GPIO_MODE_ALTERNATE
;;;156                        );
;;;157      LL_GPIO_SetPinSpeed(
000020  6be2              LDR      r2,[r4,#0x3c]
000022  e9d20108          LDRD     r0,r1,[r2,#0x20]
000026  2201              MOVS     r2,#1
000028  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinSpeed(GPIO_TypeDef*, unsigned, unsigned)
;;;158                          TmrFreg.Pin.Gpio,
;;;159                          TmrFreg.Pin.Nbr,
;;;160                          LL_GPIO_SPEED_FREQ_MEDIUM
;;;161                         );
;;;162      LL_GPIO_SetPinPull(
00002c  6be2              LDR      r2,[r4,#0x3c]
00002e  e9d20108          LDRD     r0,r1,[r2,#0x20]
000032  2200              MOVS     r2,#0
000034  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinPull(GPIO_TypeDef*, unsigned, unsigned)
;;;163                         TmrFreg.Pin.Gpio,
;;;164                         TmrFreg.Pin.Nbr,
;;;165                         LL_GPIO_PULL_NO
;;;166                        );
;;;167      LL_GPIO_SetAFPin_8_15(
000038  6be3              LDR      r3,[r4,#0x3c]
00003a  6b1a              LDR      r2,[r3,#0x30]
00003c  e9d30108          LDRD     r0,r1,[r3,#0x20]
000040  6a43              LDR      r3,[r0,#0x24]
000042  0a0d              LSRS     r5,r1,#8
000044  fa95f5a5          RBIT     r5,r5
000048  fab5f585          CLZ      r5,r5
00004c  00ae              LSLS     r6,r5,#2
00004e  250f              MOVS     r5,#0xf
000050  40b5              LSLS     r5,r5,r6
000052  43ab              BICS     r3,r3,r5
000054  0a0d              LSRS     r5,r1,#8
000056  fa95f5a5          RBIT     r5,r5
00005a  fab5f585          CLZ      r5,r5
00005e  00ad              LSLS     r5,r5,#2
000060  fa02f505          LSL      r5,r2,r5
000064  432b              ORRS     r3,r3,r5
000066  6243              STR      r3,[r0,#0x24]
000068  bf00              NOP      
;;;168                            TmrFreg.Pin.Gpio,
;;;169                            TmrFreg.Pin.Nbr,
;;;170                            TmrFreg.Pin.AlternateMask        //TIM15_CH1
;;;171                           );
;;;172    
;;;173      LL_TIM_SetSlaveMode(
00006a  6be1              LDR      r1,[r4,#0x3c]
00006c  6808              LDR      r0,[r1,#0]
00006e  2100              MOVS     r1,#0
000070  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetSlaveMode(TIM_TypeDef*, unsigned)
;;;174                          TmrFreg.Nbr,
;;;175                          LL_TIM_SLAVEMODE_DISABLED
;;;176                         );
;;;177    
;;;178      TPwm Pwm = cnt_pwm();
000074  4621              MOV      r1,r4
000076  4668              MOV      r0,sp
000078  f7fffffe          BL       _ZN11TExchngToPC7cnt_pwmEv ; TExchngToPC::cnt_pwm()
;;;179    
;;;180      LL_TIM_SetPrescaler( TmrFreg.Nbr, Pwm.PSC );
00007c  f8bd1002          LDRH     r1,[sp,#2]
000080  6be2              LDR      r2,[r4,#0x3c]
000082  6810              LDR      r0,[r2,#0]
000084  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetPrescaler(TIM_TypeDef*, unsigned)
;;;181      LL_TIM_EnableARRPreload( TmrFreg.Nbr );
000088  6be1              LDR      r1,[r4,#0x3c]
00008a  6808              LDR      r0,[r1,#0]
00008c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableARRPreloadEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableARRPreload(TIM_TypeDef*)
;;;182    //  LL_TIM_DisableARRPreload( TmrFreg.Nbr );
;;;183      LL_TIM_SetAutoReload(
000090  f8bd1000          LDRH     r1,[sp,#0]
000094  6be2              LDR      r2,[r4,#0x3c]
000096  6810              LDR      r0,[r2,#0]
000098  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetAutoReload(TIM_TypeDef*, unsigned)
;;;184                           TmrFreg.Nbr,
;;;185                           Pwm.ARR
;;;186                          );
;;;187    
;;;188      //ШИМ-режим выбирается независимо для каждого канала
;;;189      LL_TIM_OC_ConfigOutput(
00009c  6be2              LDR      r2,[r4,#0x3c]
00009e  6891              LDR      r1,[r2,#8]
0000a0  6810              LDR      r0,[r2,#0]
0000a2  2200              MOVS     r2,#0
0000a4  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_OC_ConfigOutputEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_ConfigOutput(TIM_TypeDef*, unsigned, unsigned)
;;;190                             TmrFreg.Nbr,
;;;191                             TmrFreg.Ch,
;;;192                             LL_TIM_OCPOLARITY_HIGH
;;;193                            );
;;;194      LL_TIM_OC_SetMode(
0000a8  6be2              LDR      r2,[r4,#0x3c]
0000aa  6891              LDR      r1,[r2,#8]
0000ac  6810              LDR      r0,[r2,#0]
0000ae  2260              MOVS     r2,#0x60
0000b0  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_OC_SetModeEP11TIM_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_SetMode(TIM_TypeDef*, unsigned, unsigned)
;;;195                        TmrFreg.Nbr,
;;;196                        TmrFreg.Ch,
;;;197                        LL_TIM_OCMODE_PWM1
;;;198                       );
;;;199      LL_TIM_OC_EnablePreload(
0000b4  6be2              LDR      r2,[r4,#0x3c]
0000b6  6891              LDR      r1,[r2,#8]
0000b8  6810              LDR      r0,[r2,#0]
0000ba  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_EnablePreloadEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_EnablePreload(TIM_TypeDef*, unsigned)
;;;200                              TmrFreg.Nbr,
;;;201                              TmrFreg.Ch
;;;202                             );
;;;203    
;;;204      LL_TIM_OC_SetCompareCH1(
0000be  f8bd1004          LDRH     r1,[sp,#4]
0000c2  6be2              LDR      r2,[r4,#0x3c]
0000c4  6810              LDR      r0,[r2,#0]
0000c6  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_SetCompareCH1EP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_SetCompareCH1(TIM_TypeDef*, unsigned)
;;;205                              TmrFreg.Nbr,
;;;206                              Pwm.CCR
;;;207                             );
;;;208      LL_TIM_CC_EnableChannel(TmrFreg.Nbr, TmrFreg.Ch);
0000ca  6be2              LDR      r2,[r4,#0x3c]
0000cc  6891              LDR      r1,[r2,#8]
0000ce  6810              LDR      r0,[r2,#0]
0000d0  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_CC_EnableChannel(TIM_TypeDef*, unsigned)
;;;209    
;;;210      //Preload-регистры включены => \
;;;211        необходимо программно сгенерировать событие UEV \
;;;212        для записи значений в рабочие (shadow) регистры   
;;;213      //Бит UG сбрасывается автоматически аппаратно
;;;214      LL_TIM_GenerateEvent_UPDATE( TmrFreg.Nbr );
0000d4  6be1              LDR      r1,[r4,#0x3c]
0000d6  6808              LDR      r0,[r1,#0]
0000d8  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF27LL_TIM_GenerateEvent_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef*)
;;;215    
;;;216    //  //настройка прерывания вывода LED для подсчета зондирующих импульсов
;;;217    //  Hw[_NBR].Led.EnableITСС(Hw[_NBR].TIMx);
;;;218      LL_TIM_EnableIT_CC1( TmrFreg.Nbr );
0000dc  6be1              LDR      r1,[r4,#0x3c]
0000de  6808              LDR      r0,[r1,#0]
0000e0  68c1              LDR      r1,[r0,#0xc]
0000e2  f0410102          ORR      r1,r1,#2
0000e6  60c1              STR      r1,[r0,#0xc]
0000e8  bf00              NOP      
;;;219    
;;;220    //  //настройка NVIC 
;;;221    //  NVIC_SetPriority(Hw[_NBR].IRQn, 1);
;;;222    //  NVIC_EnableIRQ(Hw[_NBR].IRQn);
;;;223    
;;;224        // Настройка NVIC
;;;225      NVIC_SetPriority(
0000ea  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv ; [local to lev_gauge_to_pc_cpp]::NVIC_GetPriorityGrouping()
0000ee  4606              MOV      r6,r0
0000f0  2200              MOVS     r2,#0
0000f2  2105              MOVS     r1,#5
0000f4  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj ; [local to lev_gauge_to_pc_cpp]::NVIC_EncodePriority(unsigned, unsigned, unsigned)
0000f8  4605              MOV      r5,r0
0000fa  6be1              LDR      r1,[r4,#0x3c]
0000fc  f9910004          LDRSB    r0,[r1,#4]
000100  4629              MOV      r1,r5
000102  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej ; [local to lev_gauge_to_pc_cpp]::NVIC_SetPriority(IRQn_Type, unsigned)
;;;226                       TmrFreg.IRQ,
;;;227                       NVIC_EncodePriority( NVIC_GetPriorityGrouping(), 5, 0 )
;;;228                      );                                                       //обработчик вызывает API функцию RTOS => приоритет д.б. \
;;;229                                                                                 логически ниже или равен, но численно больше или равен,\
;;;230                                                                                 установленному  в макросе \
;;;231                                                                                 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
;;;232      NVIC_EnableIRQ( TIM1_BRK_TIM15_IRQn );
000106  2018              MOVS     r0,#0x18
000108  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type ; [local to lev_gauge_to_pc_cpp]::NVIC_EnableIRQ(IRQn_Type)
;;;233    
;;;234      LL_TIM_EnableCounter( TmrFreg.Nbr );
00010c  6be1              LDR      r1,[r4,#0x3c]
00010e  6808              LDR      r0,[r1,#0]
000110  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableCounter(TIM_TypeDef*)
;;;235      LL_TIM_EnableAllOutputs( TmrFreg.Nbr );
000114  6be1              LDR      r1,[r4,#0x3c]
000116  6808              LDR      r0,[r1,#0]
000118  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableAllOutputsEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableAllOutputs(TIM_TypeDef*)
;;;236    }
00011c  bd7c              POP      {r2-r6,pc}
;;;237    
                          ENDP


                          AREA ||i._ZN11TExchngToPC13set_diff_freqEt||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC13set_diff_freqEt PROC ; TExchngToPC::set_diff_freq(unsigned short)
;;;375    
;;;376    void TExchngToPC::set_diff_freq( uint16_t Divider )
000000  b570              PUSH     {r4-r6,lr}
;;;377    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;378      if ( Divider != 0U )
000006  b124              CBZ      r4,|L11.18|
;;;379      {
;;;380        LL_TIM_SetPrescaler( TmrDiff.Nbr, Divider - 1U );
000008  1e61              SUBS     r1,r4,#1
00000a  6c6a              LDR      r2,[r5,#0x44]
00000c  6810              LDR      r0,[r2,#0]
00000e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetPrescaler(TIM_TypeDef*, unsigned)
                  |L11.18|
;;;381      }  
;;;382    }
000012  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP


                          AREA ||i._ZN11TExchngToPC14init_diff_extiEj||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC14init_diff_extiEj PROC ; TExchngToPC::init_diff_exti(unsigned)
;;;533    
;;;534    void TExchngToPC::init_diff_exti( uint32_t Trigger )
000000  b5f0              PUSH     {r4-r7,lr}
;;;535    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;536      Adc.DIFF.en_clk( Adc.DIFF.ClkPortMask );                              //включение тактирования GPIO для вывода внешнего прерывания
000008  6ca2              LDR      r2,[r4,#0x48]
00000a  e9d20111          LDRD     r0,r1,[r2,#0x44]
00000e  4788              BLX      r1
;;;537      Adc.Exti.en_syscfg_clk( Adc.Exti.SysCfgMask );                        //включение тактирования SYSCFG
000010  6ca2              LDR      r2,[r4,#0x48]
000012  e9d2101a          LDRD     r1,r0,[r2,#0x68]
000016  4788              BLX      r1
;;;538                                                                            
;;;539      LL_GPIO_InitTypeDef GPIO_InitStruct;                                  //сконфигурировать вывод порта как вход (п. 8.3.8 RM0394 Rev 4)
;;;540      do
000018  bf00              NOP      
                  |L12.26|
;;;541      {
;;;542        GPIO_InitStruct.Pin  = Adc.DIFF.Nbr;
00001a  6ca0              LDR      r0,[r4,#0x48]
00001c  6c00              LDR      r0,[r0,#0x40]
00001e  9003              STR      r0,[sp,#0xc]
;;;543        GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
000020  2000              MOVS     r0,#0
000022  9004              STR      r0,[sp,#0x10]
;;;544        GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
000024  9007              STR      r0,[sp,#0x1c]
;;;545      } while ( SUCCESS != LL_GPIO_Init( Adc.DIFF.Gpio, &GPIO_InitStruct ) );
000026  6ca1              LDR      r1,[r4,#0x48]
000028  6bc8              LDR      r0,[r1,#0x3c]
00002a  a903              ADD      r1,sp,#0xc
00002c  f7fffffe          BL       LL_GPIO_Init
000030  2800              CMP      r0,#0
000032  d1f2              BNE      |L12.26|
;;;546      
;;;547      /*
;;;548       * System configuration controller (SYSCFG)
;;;549       * В том числе управляет соединением линии внешнего прерывания EXTI к GPIO
;;;550       */
;;;551      if ( Adc.Exti.SysCfgPort != LL_SYSCFG_GetEXTISource( Adc.Exti.SysCfgLine ) ) //проверка соединения линии внешнего прерывания EXTI к порту
000034  6ca1              LDR      r1,[r4,#0x48]
000036  6d48              LDR      r0,[r1,#0x54]
000038  4927              LDR      r1,|L12.216|
00003a  b2c2              UXTB     r2,r0
00003c  f8511022          LDR      r1,[r1,r2,LSL #2]
000040  ea014110          AND      r1,r1,r0,LSR #16
000044  0c02              LSRS     r2,r0,#16
000046  fa92f2a2          RBIT     r2,r2
00004a  fab2f282          CLZ      r2,r2
00004e  40d1              LSRS     r1,r1,r2
000050  6ca0              LDR      r0,[r4,#0x48]
000052  6d00              LDR      r0,[r0,#0x50]
000054  4281              CMP      r1,r0
000056  d016              BEQ      |L12.134|
;;;552      {
;;;553        LL_SYSCFG_SetEXTISource( Adc.Exti.SysCfgPort, Adc.Exti.SysCfgLine ); //настроить EXTI в SYSCFG
000058  6ca2              LDR      r2,[r4,#0x48]
00005a  e9d21014          LDRD     r1,r0,[r2,#0x50]
00005e  4a1e              LDR      r2,|L12.216|
000060  b2c3              UXTB     r3,r0
000062  f8522023          LDR      r2,[r2,r3,LSL #2]
000066  ea224210          BIC      r2,r2,r0,LSR #16
00006a  0c03              LSRS     r3,r0,#16
00006c  fa93f3a3          RBIT     r3,r3
000070  fab3f383          CLZ      r3,r3
000074  fa01f303          LSL      r3,r1,r3
000078  431a              ORRS     r2,r2,r3
00007a  4b17              LDR      r3,|L12.216|
00007c  b2c6              UXTB     r6,r0
00007e  f8432026          STR      r2,[r3,r6,LSL #2]
000082  bf00              NOP      
000084  bf00              NOP      
                  |L12.134|
;;;554      }
;;;555      
;;;556      /*
;;;557      * Cконфигурировать линию как источник прерывания:
;;;558      *   сконфигурировать бит маски в регистре EXTI_IMR - по умолч. все линии замаскированы
;;;559      *	  сконфигурировать биты Trigger Selection (EXTI_RTSR и EXTI_FTSR)
;;;560      *	  сконфигурировать биты разрешения и маски, которые управляют NVIC IRQ каналом, отображенным на EXTI, так чтобы прерываниие с одной из линий EXTI могло быть корректно подтверждено
;;;561       */
;;;562      LL_EXTI_InitTypeDef EXTI_InitStruct;
;;;563      do
000086  bf00              NOP      
                  |L12.136|
;;;564      {
;;;565        EXTI_InitStruct.Line_0_31   = Adc.Exti.Line;
000088  6ca0              LDR      r0,[r4,#0x48]
00008a  6d80              LDR      r0,[r0,#0x58]
00008c  9000              STR      r0,[sp,#0]
;;;566        EXTI_InitStruct.LineCommand = ENABLE; //новое состояние выбранных EXTI линий
00008e  2001              MOVS     r0,#1
000090  f88d0008          STRB     r0,[sp,#8]
;;;567        EXTI_InitStruct.Mode        = Adc.Exti.Mode;
000094  6ca0              LDR      r0,[r4,#0x48]
000096  f890005c          LDRB     r0,[r0,#0x5c]
00009a  f88d0009          STRB     r0,[sp,#9]
;;;568    //    EXTI_InitStruct.Trigger     = Adc.Exti.Trigger;
;;;569        EXTI_InitStruct.Trigger     = Trigger;
00009e  b2e8              UXTB     r0,r5
0000a0  f88d000a          STRB     r0,[sp,#0xa]
;;;570      } while ( SUCCESS != LL_EXTI_Init( &EXTI_InitStruct ) );
0000a4  4668              MOV      r0,sp
0000a6  f7fffffe          BL       LL_EXTI_Init
0000aa  2800              CMP      r0,#0
0000ac  d1ec              BNE      |L12.136|
;;;571    
;;;572    //  // Настройка NVIC
;;;573      NVIC_SetPriority( Adc.Exti.IRQ, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 3, 0) ); //обработчик вызывает API функцию RTOS => приоритет д.б. логически ниже,
0000ae  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv ; [local to lev_gauge_to_pc_cpp]::NVIC_GetPriorityGrouping()
0000b2  4607              MOV      r7,r0
0000b4  2200              MOVS     r2,#0
0000b6  2103              MOVS     r1,#3
0000b8  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj ; [local to lev_gauge_to_pc_cpp]::NVIC_EncodePriority(unsigned, unsigned, unsigned)
0000bc  4606              MOV      r6,r0
0000be  6ca1              LDR      r1,[r4,#0x48]
0000c0  f9910064          LDRSB    r0,[r1,#0x64]
0000c4  4631              MOV      r1,r6
0000c6  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej ; [local to lev_gauge_to_pc_cpp]::NVIC_SetPriority(IRQn_Type, unsigned)
;;;574                                                                                               //но численно больше, установленного в макросе configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  
;;;575                                                                                               //3 - максимальный уровень приоритета в программе ввиду важности своевременной обработки INT'a от микросхемы
;;;576      NVIC_EnableIRQ(Adc.Exti.IRQ);
0000ca  6ca1              LDR      r1,[r4,#0x48]
0000cc  f9910064          LDRSB    r0,[r1,#0x64]
0000d0  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type ; [local to lev_gauge_to_pc_cpp]::NVIC_EnableIRQ(IRQn_Type)
;;;577    }
0000d4  b009              ADD      sp,sp,#0x24
0000d6  bdf0              POP      {r4-r7,pc}
;;;578    
                          ENDP

                  |L12.216|
                          DCD      0x40010008

                          AREA ||i._ZN11TExchngToPC14rx_cmp_captureEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC14rx_cmp_captureEPNS_12TParamHandleE PROC ; TExchngToPC::rx_cmp_capture(TExchngToPC::TParamHandle*)
;;;725    
;;;726    void TExchngToPC::rx_cmp_capture( TExchngToPC::TParamHandle *ParamHandle )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;727    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;728      constexpr uint16_t MAX_N_CAP = 1000U;
000008  f44f777a          MOV      r7,#0x3e8
;;;729      uint16_t nCap = 0U;          //текущее количество захваченных значений
00000c  2600              MOVS     r6,#0
;;;730      
;;;731      init_diff_exti( LL_EXTI_TRIGGER_FALLING );                                  //инициализация вывода DIFF, предназначенного для запуска захвата
00000e  2102              MOVS     r1,#2
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _ZN11TExchngToPC14init_diff_extiEj ; TExchngToPC::init_diff_exti(unsigned)
;;;732      xSemaphoreTake( DiffExti_TrigSem, portMAX_DELAY );                          //ожидание заднего фронта на DIFF
000016  2300              MOVS     r3,#0
000018  1e5a              SUBS     r2,r3,#1
00001a  4619              MOV      r1,r3
00001c  4815              LDR      r0,|L13.116|
00001e  6800              LDR      r0,[r0,#0]  ; DiffExti_TrigSem
000020  f7fffffe          BL       xQueueGenericReceive
;;;733        deinit_diff_exti();
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZN11TExchngToPC16deinit_diff_extiEv ; TExchngToPC::deinit_diff_exti()
;;;734        UCG1.off();                                                               //на время захвата пробросить сигнал с генератора     
00002a  4813              LDR      r0,|L13.120|
00002c  f7fffffe          BL       _ZN4TLed3offEv ; TLed::off()
;;;735    //    init_diff_exti( LL_EXTI_TRIGGER_RISING );                                 //инициализация вывода DIFF, предназначенного для прекращения захвата
;;;736        
;;;737        uint32_t *pTmrCmp = reinterpret_cast< uint32_t * >( Data );
000030  f8df8048          LDR      r8,|L13.124|
;;;738        
;;;739        LL_TIM_SetCounter( TmrCmp.Nbr, 0U );
000034  6c21              LDR      r1,[r4,#0x40]
000036  6808              LDR      r0,[r1,#0]
000038  2100              MOVS     r1,#0
00003a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_SetCounterEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetCounter(TIM_TypeDef*, unsigned)
;;;740        LL_TIM_EnableCounter( TmrCmp.Nbr );
00003e  6c21              LDR      r1,[r4,#0x40]
000040  6808              LDR      r0,[r1,#0]
000042  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableCounter(TIM_TypeDef*)
;;;741        LL_TIM_EnableAllOutputs( TmrCmp.Nbr );
000046  6c21              LDR      r1,[r4,#0x40]
000048  6808              LDR      r0,[r1,#0]
00004a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableAllOutputsEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableAllOutputs(TIM_TypeDef*)
;;;742    //    do
;;;743    //    {
;;;744    //      if ( LL_TIM_IsActiveFlag_CC2( TmrCmp.Nbr ) == true )
;;;745    //      {
;;;746    //        pTmrCmp[ nCap++ ] = LL_TIM_IC_GetCaptureCH2( TmrCmp.Nbr );
;;;747    //      }
;;;748    //    } while (
;;;749    //             nCap < MAX_N_CAP
;;;750    //             &&
;;;751    //             xSemaphoreTake( DiffExti_TrigSem, 0U ) == pdFAIL
;;;752    //            );
;;;753    
;;;754        LL_TIM_DisableCounter( TmrCmp.Nbr );
00004e  6c21              LDR      r1,[r4,#0x40]
000050  6808              LDR      r0,[r1,#0]
000052  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_DisableCounterEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_DisableCounter(TIM_TypeDef*)
;;;755        deinit_diff_exti();
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       _ZN11TExchngToPC16deinit_diff_extiEv ; TExchngToPC::deinit_diff_exti()
;;;756        UCG1.on();
00005c  4806              LDR      r0,|L13.120|
00005e  f7fffffe          BL       _ZN4TLed2onEv ; TLed::on()
;;;757        
;;;758        ParamHandle->RxVal = nCap * 4U;
000062  00b0              LSLS     r0,r6,#2
000064  ee000a10          VMOV     s0,r0
000068  eeb80a40          VCVT.F32.U32 s0,s0
00006c  ed850a01          VSTR     s0,[r5,#4]
;;;759    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;760    
                          ENDP

                  |L13.116|
                          DCD      DiffExti_TrigSem
                  |L13.120|
                          DCD      UCG1
                  |L13.124|
                          DCD      Data

                          AREA ||i._ZN11TExchngToPC14tx_cmp_captureEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC14tx_cmp_captureEPNS_12TParamHandleE PROC ; TExchngToPC::tx_cmp_capture(TExchngToPC::TParamHandle*)
;;;873    
;;;874    void TExchngToPC::tx_cmp_capture( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;875    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;876      tx_data(
000006  2301              MOVS     r3,#1
000008  2200              MOVS     r2,#0
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;877              ParamHandle->SetVal.Addr,
;;;878              0U,
;;;879              TWrapTxSign::__START_WRAP_TX
;;;880             );
;;;881      tx_data(
000012  ed940a01          VLDR     s0,[r4,#4]
000016  eebc0ac0          VCVT.U32.F32 s0,s0
00001a  ee100a10          VMOV     r0,s0
00001e  b282              UXTH     r2,r0
000020  2300              MOVS     r3,#0
000022  4628              MOV      r0,r5
000024  6921              LDR      r1,[r4,#0x10]
000026  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;882              ParamHandle->SetVal.Addr,
;;;883              ParamHandle->RxVal,
;;;884              TWrapTxSign::__NO_WRAP_TX
;;;885             );
;;;886      tx_data(
00002a  2302              MOVS     r3,#2
00002c  2200              MOVS     r2,#0
00002e  4628              MOV      r0,r5
000030  6921              LDR      r1,[r4,#0x10]
000032  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;887              ParamHandle->SetVal.Addr,
;;;888              0U,
;;;889              TWrapTxSign::__FINISH_WRAP_TX
;;;890             );
;;;891    }
000036  bd70              POP      {r4-r6,pc}
;;;892    
                          ENDP


                          AREA ||i._ZN11TExchngToPC15en_dma_with_adcEt||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC15en_dma_with_adcEt PROC ; TExchngToPC::en_dma_with_adc(unsigned short)
;;;480    
;;;481    void TExchngToPC::en_dma_with_adc( uint16_t DataQty )
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4603              MOV      r3,r0
;;;483    	LL_DMA_SetDataLength(
000004  4c19              LDR      r4,|L15.108|
000006  6820              LDR      r0,[r4,#0]  ; DmaAdc
000008  6922              LDR      r2,[r4,#0x10]  ; DmaAdc
00000a  1e54              SUBS     r4,r2,#1
00000c  4d18              LDR      r5,|L15.112|
00000e  5d2c              LDRB     r4,[r5,r4]
000010  4404              ADD      r4,r4,r0
000012  6864              LDR      r4,[r4,#4]
000014  f36f040f          BFC      r4,#0,#16
000018  430c              ORRS     r4,r4,r1
00001a  1e55              SUBS     r5,r2,#1
00001c  4e14              LDR      r6,|L15.112|
00001e  5d75              LDRB     r5,[r6,r5]
000020  4405              ADD      r5,r5,r0
000022  606c              STR      r4,[r5,#4]
000024  bf00              NOP      
;;;484                           DmaAdc.Periph.Nbr,
;;;485                           DmaAdc.Ch.Nbr,
;;;486                           DataQty
;;;487                          );  
;;;488      LL_DMA_EnableIT_TC(
000026  4c11              LDR      r4,|L15.108|
000028  6820              LDR      r0,[r4,#0]  ; DmaAdc
00002a  6922              LDR      r2,[r4,#0x10]  ; DmaAdc
00002c  1e54              SUBS     r4,r2,#1
00002e  4635              MOV      r5,r6
000030  5d2c              LDRB     r4,[r5,r4]
000032  5904              LDR      r4,[r0,r4]
000034  f0440502          ORR      r5,r4,#2
000038  1e54              SUBS     r4,r2,#1
00003a  5d34              LDRB     r4,[r6,r4]
00003c  5105              STR      r5,[r0,r4]
00003e  bf00              NOP      
;;;489                         DmaAdc.Periph.Nbr, 
;;;490                         DmaAdc.Ch.Nbr 
;;;491                        );                                                   //Transfer complete interrupt
;;;492    
;;;493      LL_USART_EnableDMAReq_RX( HW.If );                                     //включение DMA режима для приема через USART
000040  685a              LDR      r2,[r3,#4]
000042  6810              LDR      r0,[r2,#0]
000044  6882              LDR      r2,[r0,#8]
000046  f0420240          ORR      r2,r2,#0x40
00004a  6082              STR      r2,[r0,#8]
00004c  bf00              NOP      
;;;494      LL_DMA_EnableChannel( DmaAdc.Periph.Nbr, DmaAdc.Ch.Nbr );              //активация DMA канала \
00004e  4c07              LDR      r4,|L15.108|
000050  6820              LDR      r0,[r4,#0]  ; DmaAdc
000052  6922              LDR      r2,[r4,#0x10]  ; DmaAdc
000054  1e54              SUBS     r4,r2,#1
000056  4635              MOV      r5,r6
000058  5d2c              LDRB     r4,[r5,r4]
00005a  5904              LDR      r4,[r0,r4]
00005c  f0440501          ORR      r5,r4,#1
000060  1e54              SUBS     r4,r2,#1
000062  5d34              LDRB     r4,[r6,r4]
000064  5105              STR      r5,[r0,r4]
000066  bf00              NOP      
;;;495                                                                               канал включен => канал контроллера DMA может \
;;;496                                                                               обработать запрос от периферии, \
;;;497    	                                                                         подключенной к этому каналу
;;;498    }
000068  bd70              POP      {r4-r6,pc}
;;;499    
                          ENDP

00006a  0000              DCW      0x0000
                  |L15.108|
                          DCD      DmaAdc
                  |L15.112|
                          DCD      CHANNEL_OFFSET_TAB

                          AREA ||i._ZN11TExchngToPC15rx_diff_captureEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC15rx_diff_captureEPNS_12TParamHandleE PROC ; TExchngToPC::rx_diff_capture(TExchngToPC::TParamHandle*)
;;;760    
;;;761    void TExchngToPC::rx_diff_capture( TExchngToPC::TParamHandle *ParamHandle )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;762    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;763      set_diff_freq( ParamHandle->RxVal );
000008  ed950a01          VLDR     s0,[r5,#4]
00000c  eebc0ac0          VCVT.U32.F32 s0,s0
000010  ee100a10          VMOV     r0,s0
000014  b281              UXTH     r1,r0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _ZN11TExchngToPC13set_diff_freqEt ; TExchngToPC::set_diff_freq(unsigned short)
;;;764      
;;;765      constexpr uint16_t MAX_N_CAP = 100U;
00001c  2764              MOVS     r7,#0x64
;;;766      
;;;767    //  UCG1.off();                                                               //на время захвата пробросить сигнал с генератора
;;;768      
;;;769      uint16_t *pTmrDiff = reinterpret_cast< uint16_t * >( Data );
00001e  4e2c              LDR      r6,|L16.208|
;;;770      
;;;771      LL_TIM_GenerateEvent_UPDATE( TmrDiff.Nbr );
000020  6c61              LDR      r1,[r4,#0x44]
000022  6808              LDR      r0,[r1,#0]
000024  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF27LL_TIM_GenerateEvent_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef*)
;;;772      LL_TIM_ClearFlag_UPDATE( TmrDiff.Nbr );
000028  6c61              LDR      r1,[r4,#0x44]
00002a  6808              LDR      r0,[r1,#0]
00002c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_ClearFlag_UPDATE(TIM_TypeDef*)
;;;773      LL_TIM_EnableCounter( TmrDiff.Nbr );
000030  6c61              LDR      r1,[r4,#0x44]
000032  6808              LDR      r0,[r1,#0]
000034  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableCounter(TIM_TypeDef*)
;;;774      LL_TIM_SetCounter( TmrDiff.Nbr, 0U );
000038  6c61              LDR      r1,[r4,#0x44]
00003a  6808              LDR      r0,[r1,#0]
00003c  2100              MOVS     r1,#0
00003e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_SetCounterEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetCounter(TIM_TypeDef*, unsigned)
;;;775      LL_TIM_ClearFlag_UPDATE( TmrDiff.Nbr );
000042  6c61              LDR      r1,[r4,#0x44]
000044  6808              LDR      r0,[r1,#0]
000046  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_ClearFlag_UPDATE(TIM_TypeDef*)
;;;776      
;;;777      if ( LL_TIM_IsActiveFlag_UPDATE( TmrDiff.Nbr ) == true )
00004a  6c61              LDR      r1,[r4,#0x44]
00004c  6808              LDR      r0,[r1,#0]
00004e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef*)
000052  2801              CMP      r0,#1
000054  d101              BNE      |L16.90|
;;;778      {
;;;779        UIF = true;
000056  491f              LDR      r1,|L16.212|
000058  7008              STRB     r0,[r1,#0]
                  |L16.90|
;;;780      }
;;;781      
;;;782    //  LL_TIM_EnableAllOutputs( TmrDiff.Nbr );
;;;783      do
00005a  bf00              NOP      
                  |L16.92|
;;;784      {
;;;785        if ( LL_TIM_IsActiveFlag_CC3( TmrDiff.Nbr ) == true )
00005c  6c61              LDR      r1,[r4,#0x44]
00005e  6808              LDR      r0,[r1,#0]
000060  6901              LDR      r1,[r0,#0x10]
000062  f3c101c0          UBFX     r1,r1,#3,#1
000066  b151              CBZ      r1,|L16.126|
;;;786        {
;;;787          pTmrDiff[ nCapDiff++ ] = LL_TIM_IC_GetCaptureCH3( TmrDiff.Nbr );
000068  6c61              LDR      r1,[r4,#0x44]
00006a  6808              LDR      r0,[r1,#0]
00006c  6bc1              LDR      r1,[r0,#0x3c]
00006e  481a              LDR      r0,|L16.216|
000070  8802              LDRH     r2,[r0,#0]  ; nCapDiff
000072  8800              LDRH     r0,[r0,#0]  ; nCapDiff
000074  1c40              ADDS     r0,r0,#1
000076  4b18              LDR      r3,|L16.216|
000078  8018              STRH     r0,[r3,#0]
00007a  f8261012          STRH     r1,[r6,r2,LSL #1]
                  |L16.126|
;;;788        }
;;;789      } while (
;;;790               nCapDiff < MAX_N_CAP
00007e  4816              LDR      r0,|L16.216|
000080  8800              LDRH     r0,[r0,#0]  ; nCapDiff
000082  2864              CMP      r0,#0x64
000084  da05              BGE      |L16.146|
;;;791               &&
;;;792               LL_TIM_IsActiveFlag_UPDATE( TmrDiff.Nbr ) == false //нет переполнения таймера
000086  6c61              LDR      r1,[r4,#0x44]
000088  6808              LDR      r0,[r1,#0]
00008a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef*)
00008e  2800              CMP      r0,#0
000090  d0e4              BEQ      |L16.92|
                  |L16.146|
;;;793              );
;;;794      
;;;795      if ( LL_TIM_IsActiveFlag_UPDATE( TmrDiff.Nbr ) == true )
000092  6c61              LDR      r1,[r4,#0x44]
000094  6808              LDR      r0,[r1,#0]
000096  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef*)
00009a  2801              CMP      r0,#1
00009c  d101              BNE      |L16.162|
;;;796      {
;;;797        UIF = true;
00009e  490d              LDR      r1,|L16.212|
0000a0  7008              STRB     r0,[r1,#0]
                  |L16.162|
;;;798      }
;;;799      LL_TIM_ClearFlag_UPDATE( TmrDiff.Nbr );
0000a2  6c61              LDR      r1,[r4,#0x44]
0000a4  6808              LDR      r0,[r1,#0]
0000a6  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_ClearFlag_UPDATE(TIM_TypeDef*)
;;;800      LL_TIM_DisableCounter( TmrDiff.Nbr );
0000aa  6c61              LDR      r1,[r4,#0x44]
0000ac  6808              LDR      r0,[r1,#0]
0000ae  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_DisableCounterEP11TIM_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_TIM_DisableCounter(TIM_TypeDef*)
;;;801      deinit_diff_exti();
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       _ZN11TExchngToPC16deinit_diff_extiEv ; TExchngToPC::deinit_diff_exti()
;;;802    //  UCG1.on();
;;;803      
;;;804      ParamHandle->RxVal = nCapDiff * 2U;
0000b8  4807              LDR      r0,|L16.216|
0000ba  8800              LDRH     r0,[r0,#0]  ; nCapDiff
0000bc  0040              LSLS     r0,r0,#1
0000be  ee000a10          VMOV     s0,r0
0000c2  eeb80a40          VCVT.F32.U32 s0,s0
0000c6  ed850a01          VSTR     s0,[r5,#4]
;;;805    }
0000ca  e8bd81f0          POP      {r4-r8,pc}
;;;806    //----- //Обработчики приема -----------------------------------------------------------------------------------
                          ENDP

0000ce  0000              DCW      0x0000
                  |L16.208|
                          DCD      Data
                  |L16.212|
                          DCD      UIF
                  |L16.216|
                          DCD      nCapDiff

                          AREA ||i._ZN11TExchngToPC15tx_diff_captureEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC15tx_diff_captureEPNS_12TParamHandleE PROC ; TExchngToPC::tx_diff_capture(TExchngToPC::TParamHandle*)
;;;892    
;;;893    void TExchngToPC::tx_diff_capture( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;894    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;895      tx_data(
000006  2301              MOVS     r3,#1
000008  2200              MOVS     r2,#0
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;896              ParamHandle->SetVal.Addr,
;;;897              0U,
;;;898              TWrapTxSign::__START_WRAP_TX
;;;899             );
;;;900      tx_data(
000012  ed940a01          VLDR     s0,[r4,#4]
000016  eebc0ac0          VCVT.U32.F32 s0,s0
00001a  ee100a10          VMOV     r0,s0
00001e  b282              UXTH     r2,r0
000020  2300              MOVS     r3,#0
000022  4628              MOV      r0,r5
000024  6921              LDR      r1,[r4,#0x10]
000026  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;901              ParamHandle->SetVal.Addr,
;;;902              ParamHandle->RxVal,
;;;903              TWrapTxSign::__NO_WRAP_TX
;;;904             );
;;;905      tx_data(
00002a  2302              MOVS     r3,#2
00002c  2200              MOVS     r2,#0
00002e  4628              MOV      r0,r5
000030  6921              LDR      r1,[r4,#0x10]
000032  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;906              ParamHandle->SetVal.Addr,
;;;907              0U,
;;;908              TWrapTxSign::__FINISH_WRAP_TX
;;;909             );
;;;910    }
000036  bd70              POP      {r4-r6,pc}
;;;911    //----- //Обработчики передачи ---------------------------------------------------------------------------------
                          ENDP


                          AREA ||i._ZN11TExchngToPC16deinit_diff_extiEv||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC16deinit_diff_extiEv PROC ; TExchngToPC::deinit_diff_exti()
;;;578    
;;;579    void TExchngToPC::deinit_diff_exti()
000000  b510              PUSH     {r4,lr}
;;;580    {
000002  4604              MOV      r4,r0
;;;581    //  LL_GPIO_DeInit( Adc.DIFF.Gpio ); //регистры GPIO возвращаются к значениям по умолчанию
;;;582      LL_EXTI_DeInit();
000004  f7fffffe          BL       LL_EXTI_DeInit
;;;583    }
000008  bd10              POP      {r4,pc}
;;;584    
                          ENDP


                          AREA ||i._ZN11TExchngToPC16dis_dma_with_adcEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC16dis_dma_with_adcEv PROC ; TExchngToPC::dis_dma_with_adc()
;;;499    
;;;500    void TExchngToPC::dis_dma_with_adc()
000000  b530              PUSH     {r4,r5,lr}
;;;501    {
000002  4602              MOV      r2,r0
;;;502    	LL_DMA_DisableIT_TC(
000004  4b07              LDR      r3,|L19.36|
000006  6818              LDR      r0,[r3,#0]  ; DmaAdc
000008  6919              LDR      r1,[r3,#0x10]  ; DmaAdc
00000a  1e4b              SUBS     r3,r1,#1
00000c  4c06              LDR      r4,|L19.40|
00000e  5ce3              LDRB     r3,[r4,r3]
000010  58c3              LDR      r3,[r0,r3]
000012  f0230402          BIC      r4,r3,#2
000016  1e4b              SUBS     r3,r1,#1
000018  4d03              LDR      r5,|L19.40|
00001a  5ceb              LDRB     r3,[r5,r3]
00001c  50c4              STR      r4,[r0,r3]
00001e  bf00              NOP      
;;;503                          DmaAdc.Periph.Nbr, 
;;;504                          DmaAdc.Ch.Nbr 
;;;505                         );                                                  //Transfer complete interrupt
;;;506    }
000020  bd30              POP      {r4,r5,pc}
;;;507    
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      DmaAdc
                  |L19.40|
                          DCD      CHANNEL_OFFSET_TAB

                          AREA ||i._ZN11TExchngToPC16rx_set_pos_pot_1EPNS_12TParamHandleE||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC16rx_set_pos_pot_1EPNS_12TParamHandleE PROC ; TExchngToPC::rx_set_pos_pot_1(TExchngToPC::TParamHandle*)
;;;627    
;;;628    void TExchngToPC::rx_set_pos_pot_1( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;629    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;630      ParamHandle->RxVal = chk_range( ParamHandle->RxVal, ParamHandle->Range );
000006  edd40a01          VLDR     s1,[r4,#4]
00000a  eeb00a60          VMOV.F32 s0,s1
00000e  f1040108          ADD      r1,r4,#8
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE ; TExchngToPC::chk_range(float, const TExchngToPC::TRange&)
000018  ed840a01          VSTR     s0,[r4,#4]
;;;631      *ParamHandle->SetVal.Addr = ( uint8_t )ParamHandle->RxVal;
00001c  ed940a01          VLDR     s0,[r4,#4]
000020  eebc0ac0          VCVT.U32.F32 s0,s0
000024  ee100a10          VMOV     r0,s0
000028  6921              LDR      r1,[r4,#0x10]
00002a  7008              STRB     r0,[r1,#0]
;;;632      AD8402.set_code( ParamHandle->RxVal, T_AD8402::TChannel::__ONE );
00002c  ed940a01          VLDR     s0,[r4,#4]
000030  eebc0ac0          VCVT.U32.F32 s0,s0
000034  ee100a10          VMOV     r0,s0
000038  b2c1              UXTB     r1,r0
00003a  2200              MOVS     r2,#0
00003c  4801              LDR      r0,|L20.68|
00003e  f7fffffe          BL       _ZN8T_AD84028set_codeEhNS_8TChannelE ; T_AD8402::set_code(unsigned char, T_AD8402::TChannel)
;;;633    }
000042  bd70              POP      {r4-r6,pc}
;;;634    
                          ENDP

                  |L20.68|
                          DCD      AD8402

                          AREA ||i._ZN11TExchngToPC16rx_set_pos_pot_2EPNS_12TParamHandleE||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC16rx_set_pos_pot_2EPNS_12TParamHandleE PROC ; TExchngToPC::rx_set_pos_pot_2(TExchngToPC::TParamHandle*)
;;;634    
;;;635    void TExchngToPC::rx_set_pos_pot_2( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;636    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;637      ParamHandle->RxVal = chk_range( ParamHandle->RxVal, ParamHandle->Range );
000006  edd40a01          VLDR     s1,[r4,#4]
00000a  eeb00a60          VMOV.F32 s0,s1
00000e  f1040108          ADD      r1,r4,#8
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE ; TExchngToPC::chk_range(float, const TExchngToPC::TRange&)
000018  ed840a01          VSTR     s0,[r4,#4]
;;;638      *ParamHandle->SetVal.Addr = ( uint8_t )ParamHandle->RxVal;
00001c  ed940a01          VLDR     s0,[r4,#4]
000020  eebc0ac0          VCVT.U32.F32 s0,s0
000024  ee100a10          VMOV     r0,s0
000028  6921              LDR      r1,[r4,#0x10]
00002a  7008              STRB     r0,[r1,#0]
;;;639      AD8402.set_code( ParamHandle->RxVal, T_AD8402::TChannel::__TWO );
00002c  ed940a01          VLDR     s0,[r4,#4]
000030  eebc0ac0          VCVT.U32.F32 s0,s0
000034  ee100a10          VMOV     r0,s0
000038  b2c1              UXTB     r1,r0
00003a  2202              MOVS     r2,#2
00003c  4801              LDR      r0,|L21.68|
00003e  f7fffffe          BL       _ZN8T_AD84028set_codeEhNS_8TChannelE ; T_AD8402::set_code(unsigned char, T_AD8402::TChannel)
;;;640    }
000042  bd70              POP      {r4-r6,pc}
;;;641    
                          ENDP

                  |L21.68|
                          DCD      AD8402

                          AREA ||i._ZN11TExchngToPC16tx_set_pos_pot_1EPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC16tx_set_pos_pot_1EPNS_12TParamHandleE PROC ; TExchngToPC::tx_set_pos_pot_1(TExchngToPC::TParamHandle*)
;;;827    
;;;828    void TExchngToPC::tx_set_pos_pot_1( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;829    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;830      tx_data(
000006  7d22              LDRB     r2,[r4,#0x14]
000008  2303              MOVS     r3,#3
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;831              ParamHandle->SetVal.Addr,
;;;832              ParamHandle->SetVal.BytesQty,
;;;833              TWrapTxSign::__ALL_WRAP_TX
;;;834             );
;;;835    }
000012  bd70              POP      {r4-r6,pc}
;;;836    
                          ENDP


                          AREA ||i._ZN11TExchngToPC16tx_set_pos_pot_2EPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC16tx_set_pos_pot_2EPNS_12TParamHandleE PROC ; TExchngToPC::tx_set_pos_pot_2(TExchngToPC::TParamHandle*)
;;;836    
;;;837    void TExchngToPC::tx_set_pos_pot_2( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;838    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;839      tx_data(
000006  7d22              LDRB     r2,[r4,#0x14]
000008  2303              MOVS     r3,#3
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;840              ParamHandle->SetVal.Addr,
;;;841              ParamHandle->SetVal.BytesQty,
;;;842              TWrapTxSign::__ALL_WRAP_TX
;;;843             );
;;;844    }
000012  bd70              POP      {r4-r6,pc}
;;;845    
                          ENDP


                          AREA ||i._ZN11TExchngToPC17rx_set_duty_cycleEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC17rx_set_duty_cycleEPNS_12TParamHandleE PROC ; TExchngToPC::rx_set_duty_cycle(TExchngToPC::TParamHandle*)
;;;622    
;;;623    void TExchngToPC::rx_set_duty_cycle( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;624    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;625      ctrl_pwm( ParamHandle );
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN11TExchngToPC8ctrl_pwmEPNS_12TParamHandleE ; TExchngToPC::ctrl_pwm(TExchngToPC::TParamHandle*)
;;;626    }
00000e  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP


                          AREA ||i._ZN11TExchngToPC17tx_set_duty_cycleEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC17tx_set_duty_cycleEPNS_12TParamHandleE PROC ; TExchngToPC::tx_set_duty_cycle(TExchngToPC::TParamHandle*)
;;;818    
;;;819    void TExchngToPC::tx_set_duty_cycle( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;820    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;821      tx_data(
000006  7d22              LDRB     r2,[r4,#0x14]
000008  2303              MOVS     r3,#3
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;822              ParamHandle->SetVal.Addr,
;;;823              ParamHandle->SetVal.BytesQty,
;;;824              TWrapTxSign::__ALL_WRAP_TX
;;;825             );
;;;826    }
000012  bd70              POP      {r4-r6,pc}
;;;827    
                          ENDP


                          AREA ||i._ZN11TExchngToPC19get_upd_demand_flagEv||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC19get_upd_demand_flagEv PROC ; TExchngToPC::get_upd_demand_flag()
;;;944    
;;;945    bool TExchngToPC::get_upd_demand_flag()
000000  4601              MOV      r1,r0
;;;946    {
;;;947      bool Flag = false;
000002  2000              MOVS     r0,#0
;;;948      
;;;949      __disable_irq();
000004  b672              CPSID    i
;;;950        Flag = UpdDemandFlag;
000006  f891004c          LDRB     r0,[r1,#0x4c]
;;;951      __enable_irq();
00000a  b662              CPSIE    i
;;;952      
;;;953      return Flag;
;;;954    }
00000c  4770              BX       lr
;;;955    
                          ENDP


                          AREA ||i._ZN11TExchngToPC19set_upd_demand_flagEb||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC19set_upd_demand_flagEb PROC ; TExchngToPC::set_upd_demand_flag(bool)
;;;955    
;;;956    void TExchngToPC::set_upd_demand_flag( bool Flag )
000000  b672              CPSID    i
;;;957    {
;;;958      __disable_irq();
;;;959        UpdDemandFlag = Flag;
000002  f880104c          STRB     r1,[r0,#0x4c]
;;;960      __enable_irq();
000006  b662              CPSIE    i
;;;961    }
000008  4770              BX       lr
;;;962    
                          ENDP


                          AREA ||i._ZN11TExchngToPC5iserrEf||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC5iserrEf PROC ; TExchngToPC::iserr(float)
;;;932    
;;;933    bool TExchngToPC::iserr( const float Val )
000000  b501              PUSH     {r0,lr}
;;;934    {
000002  ed2d0b02          VPUSH    {d0}
000006  4601              MOV      r1,r0
;;;935    	if ( (*(__packed uint32_t*)&Val ) == 0xFFFFFFFF )
000008  9800              LDR      r0,[sp,#0]
00000a  1c40              ADDS     r0,r0,#1
00000c  b908              CBNZ     r0,|L28.18|
;;;936      {
;;;937        return true;
00000e  2001              MOVS     r0,#1
                  |L28.16|
;;;938      }
;;;939      else
;;;940      {
;;;941        return false;
;;;942      }
;;;943    }
000010  bd0e              POP      {r1-r3,pc}
                  |L28.18|
000012  2000              MOVS     r0,#0                 ;941
000014  e7fc              B        |L28.16|
;;;944    
                          ENDP


                          AREA ||i._ZN11TExchngToPC6en_adcEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC6en_adcEv PROC ; TExchngToPC::en_adc()
;;;584    
;;;585    void TExchngToPC::en_adc()
000000  b510              PUSH     {r4,lr}
;;;586    {
000002  4604              MOV      r4,r0
;;;587      LL_ADC_ClearFlag_ADRDY( Adc.Nbr );
000004  6ca1              LDR      r1,[r4,#0x48]
000006  6808              LDR      r0,[r1,#0]
000008  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_ADC_ClearFlag_ADRDYEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_ClearFlag_ADRDY(ADC_TypeDef*)
;;;588      LL_ADC_Enable( Adc.Nbr );                             //бит ADEN не может быть установлен при ADCAL = 1 и в течение \
00000c  6ca1              LDR      r1,[r4,#0x48]
00000e  6808              LDR      r0,[r1,#0]
000010  6881              LDR      r1,[r0,#8]
000012  4a08              LDR      r2,|L29.52|
000014  4011              ANDS     r1,r1,r2
000016  1c49              ADDS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
00001a  bf00              NOP      
;;;589                                                              4 тактов АЦП после аппаратного сброса бита ADCAL ( окончание калибровки )
;;;590      if ( LL_ADC_IsActiveFlag_ADRDY( Adc.Nbr )  == true )
00001c  6ca1              LDR      r1,[r4,#0x48]
00001e  6808              LDR      r0,[r1,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0010101          AND      r1,r1,#1
000026  b119              CBZ      r1,|L29.48|
;;;591      {
;;;592        LL_ADC_ClearFlag_ADRDY( Adc.Nbr );
000028  6ca1              LDR      r1,[r4,#0x48]
00002a  6808              LDR      r0,[r1,#0]
00002c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_ADC_ClearFlag_ADRDYEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_ClearFlag_ADRDY(ADC_TypeDef*)
                  |L29.48|
;;;593      }
;;;594    }
000030  bd10              POP      {r4,pc}
;;;595    
                          ENDP

000032  0000              DCW      0x0000
                  |L29.52|
                          DCD      0x7fffffc0

                          AREA ||i._ZN11TExchngToPC6tx_adcEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC6tx_adcEPNS_12TParamHandleE PROC ; TExchngToPC::tx_adc(TExchngToPC::TParamHandle*)
;;;854    
;;;855    void TExchngToPC::tx_adc( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;856    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;857      tx_data(
000006  2301              MOVS     r3,#1
000008  2200              MOVS     r2,#0
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;858              ParamHandle->SetVal.Addr,
;;;859              0U,
;;;860              TWrapTxSign::__START_WRAP_TX
;;;861             );
;;;862      tx_data(
000012  ed940a01          VLDR     s0,[r4,#4]
000016  eebc0ac0          VCVT.U32.F32 s0,s0
00001a  ee100a10          VMOV     r0,s0
00001e  b282              UXTH     r2,r0
000020  2300              MOVS     r3,#0
000022  4628              MOV      r0,r5
000024  6921              LDR      r1,[r4,#0x10]
000026  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;863              ParamHandle->SetVal.Addr,
;;;864              ParamHandle->RxVal,
;;;865              TWrapTxSign::__NO_WRAP_TX
;;;866             );
;;;867      tx_data(
00002a  2302              MOVS     r3,#2
00002c  2200              MOVS     r2,#0
00002e  4628              MOV      r0,r5
000030  6921              LDR      r1,[r4,#0x10]
000032  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;868              ParamHandle->SetVal.Addr,
;;;869              0U,
;;;870              TWrapTxSign::__FINISH_WRAP_TX
;;;871             );
;;;872    }
000036  bd70              POP      {r4-r6,pc}
;;;873    
                          ENDP


                          AREA ||i._ZN11TExchngToPC7adc_calEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC7adc_calEv PROC ; TExchngToPC::adc_cal()
;;;507    
;;;508    void TExchngToPC::adc_cal()
000000  b510              PUSH     {r4,lr}
;;;509    {
000002  4604              MOV      r4,r0
;;;510      if ( LL_ADC_IsEnabled( Adc.Nbr ) == true )
000004  6ca1              LDR      r1,[r4,#0x48]
000006  6808              LDR      r0,[r1,#0]
000008  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsEnabled(ADC_TypeDef*)
00000c  2801              CMP      r0,#1
00000e  d111              BNE      |L31.52|
;;;511      {
;;;512        LL_ADC_Disable( Adc.Nbr );
000010  6ca1              LDR      r1,[r4,#0x48]
000012  6808              LDR      r0,[r1,#0]
000014  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14LL_ADC_DisableEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_Disable(ADC_TypeDef*)
;;;513        
;;;514        do {} while ( LL_ADC_IsDisableOngoing( Adc.Nbr ) == true );
000018  bf00              NOP      
                  |L31.26|
00001a  6ca1              LDR      r1,[r4,#0x48]
00001c  6808              LDR      r0,[r1,#0]
00001e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_ADC_IsDisableOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsDisableOngoing(ADC_TypeDef*)
000022  2801              CMP      r0,#1
000024  d0f9              BEQ      |L31.26|
;;;515        do {} while ( LL_ADC_IsEnabled( Adc.Nbr ) == true );
000026  bf00              NOP      
                  |L31.40|
000028  6ca1              LDR      r1,[r4,#0x48]
00002a  6808              LDR      r0,[r1,#0]
00002c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsEnabled(ADC_TypeDef*)
000030  2801              CMP      r0,#1
000032  d0f9              BEQ      |L31.40|
                  |L31.52|
;;;516      }  
;;;517      
;;;518    //  LL_ADC_SetCommonClock( Adc.Nbr, LL_ADC_CLOCK_SYNC_PCLK_DIV1,  );
;;;519      
;;;520      LL_ADC_StartCalibration( Adc.Nbr, LL_ADC_SINGLE_ENDED ); //ADCALDIF определяет к какому режиму входа применяется калибровка
000034  6ca2              LDR      r2,[r4,#0x48]
000036  217f              MOVS     r1,#0x7f
000038  6810              LDR      r0,[r2,#0]
00003a  6882              LDR      r2,[r0,#8]
00003c  4b0d              LDR      r3,|L31.116|
00003e  401a              ANDS     r2,r2,r3
000040  07cb              LSLS     r3,r1,#31
000042  431a              ORRS     r2,r2,r3
000044  6082              STR      r2,[r0,#8]
000046  bf00              NOP      
;;;521                                                               //калибровочный коэффициент для преобразования однопроводного входа отличается от дифференциального
;;;522      
;;;523      do {} while ( LL_ADC_IsCalibrationOnGoing( Adc.Nbr ) == true );
000048  bf00              NOP      
                  |L31.74|
00004a  6ca1              LDR      r1,[r4,#0x48]
00004c  6808              LDR      r0,[r1,#0]
00004e  6881              LDR      r1,[r0,#8]
000050  0fc9              LSRS     r1,r1,#31
000052  2900              CMP      r1,#0
000054  d1f9              BNE      |L31.74|
;;;524      
;;;525      /*
;;;526      * Когда АЦП отключается ( ADEN = 0 ) на длительное время, необходимо сделать новый цикл калибровки
;;;527      * Перекалибровка нужна при сбросе питания АЦП ( Пр. вход в STANDBY или VBAT режим )
;;;528      * Калибровочный коэффициент может быть сохранен для дальнейшей перезаписи при старте следующей работы с АЦП
;;;529      * Перезапись можно делать при включенном АЦП ( ADEN = 1 ), но он не должен быть в процессе преобразования ( т.е ADSTART д.б. = 0 )   
;;;530      */
;;;531      AdcCalibFactorS = LL_ADC_GetCalibrationFactor( Adc.Nbr, LL_ADC_SINGLE_ENDED );
000056  6ca2              LDR      r2,[r4,#0x48]
000058  207f              MOVS     r0,#0x7f
00005a  6811              LDR      r1,[r2,#0]
00005c  f8d120b4          LDR      r2,[r1,#0xb4]
000060  4002              ANDS     r2,r2,r0
000062  fa90f3a0          RBIT     r3,r0
000066  fab3f383          CLZ      r3,r3
00006a  40da              LSRS     r2,r2,r3
00006c  f8842054          STRB     r2,[r4,#0x54]
;;;532    }
000070  bd10              POP      {r4,pc}
;;;533    
                          ENDP

000072  0000              DCW      0x0000
                  |L31.116|
                          DCD      0x3fffffc0

                          AREA ||i._ZN11TExchngToPC7cnt_pwmEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC7cnt_pwmEv PROC ; TExchngToPC::cnt_pwm()
;;;87     
;;;88     TExchngToPC::TPwm TExchngToPC::cnt_pwm()
000000  b530              PUSH     {r4,r5,lr}
;;;89     {
000002  ed2d8b04          VPUSH    {d8-d9}
000006  b087              SUB      sp,sp,#0x1c
000008  4605              MOV      r5,r0
00000a  460c              MOV      r4,r1
;;;90       TPwm Pwm{ 0U, 0U, 0U };
00000c  2000              MOVS     r0,#0
00000e  9005              STR      r0,[sp,#0x14]
000010  9006              STR      r0,[sp,#0x18]
;;;91       
;;;92       LL_RCC_ClocksTypeDef RCC_Clocks;
;;;93       LL_RCC_GetSystemClocksFreq( &RCC_Clocks );
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       LL_RCC_GetSystemClocksFreq
;;;94     
;;;95       float Freq = ParamHandle[0].RxVal;                                      //требуемая частота ( математическое округление, т.к усечение дробной части )
000018  484e              LDR      r0,|L32.340|
00001a  ed900a01          VLDR     s0,[r0,#4]
00001e  eeb08a40          VMOV.F32 s16,s0
;;;96       Tx_Freq_hz = Freq;                                                      //реально установленное значение частоты
000022  ed848a0c          VSTR     s16,[r4,#0x30]
;;;97       float Arr  = TmrFreg.ARR_MAX;                                            
000026  6be0              LDR      r0,[r4,#0x3c]
000028  ed900a03          VLDR     s0,[r0,#0xc]
00002c  eeb80a40          VCVT.F32.U32 s0,s0
000030  eef08a40          VMOV.F32 s17,s0
;;;98       TmrFreq    = ( (uint32_t)Arr + 1U ) * Freq;                          
000034  eebc0ae8          VCVT.U32.F32 s0,s17
000038  ee100a10          VMOV     r0,s0
00003c  1c40              ADDS     r0,r0,#1
00003e  ee000a10          VMOV     s0,r0
000042  eeb80a40          VCVT.F32.U32 s0,s0
000046  ee200a08          VMUL.F32 s0,s0,s16
00004a  eebc0ac0          VCVT.U32.F32 s0,s0
00004e  ed840a14          VSTR     s0,[r4,#0x50]
;;;99                                                                               
;;;100      if ( TmrFreq >= RCC_Clocks.PCLK2_Frequency )                             
000052  6d20              LDR      r0,[r4,#0x50]
000054  9904              LDR      r1,[sp,#0x10]
000056  4288              CMP      r0,r1
000058  d311              BCC      |L32.126|
;;;101      {
;;;102        TmrFreq = RCC_Clocks.PCLK2_Frequency;
00005a  9804              LDR      r0,[sp,#0x10]
00005c  6520              STR      r0,[r4,#0x50]
;;;103        Pwm.PSC = 0U;
00005e  2000              MOVS     r0,#0
000060  f8ad0016          STRH     r0,[sp,#0x16]
;;;104        Arr     = TmrFreq / Freq - 1.f;
000064  ed940a14          VLDR     s0,[r4,#0x50]
000068  eeb80a40          VCVT.F32.U32 s0,s0
00006c  eec00a08          VDIV.F32 s1,s0,s16
000070  eeb70a00          VMOV.F32 s0,#1.00000000
000074  ee300ac0          VSUB.F32 s0,s1,s0
000078  eef08a40          VMOV.F32 s17,s0
00007c  e028              B        |L32.208|
                  |L32.126|
;;;105      }
;;;106      else
;;;107      {
;;;108        do
00007e  bf00              NOP      
                  |L32.128|
;;;109        {
;;;110          uint16_t Presc = ++Pwm.PSC;
000080  f8bd1016          LDRH     r1,[sp,#0x16]
000084  1c49              ADDS     r1,r1,#1
000086  b289              UXTH     r1,r1
000088  f8ad1016          STRH     r1,[sp,#0x16]
00008c  4608              MOV      r0,r1
;;;111          ++Presc;
00008e  1c41              ADDS     r1,r0,#1
000090  b288              UXTH     r0,r1
;;;112          TmrFreq        = ( RCC_Clocks.PCLK2_Frequency + Presc / 2 ) / Presc;
000092  4601              MOV      r1,r0
000094  eb0072d1          ADD      r2,r0,r1,LSR #31
000098  9b04              LDR      r3,[sp,#0x10]
00009a  eb030262          ADD      r2,r3,r2,ASR #1
00009e  fbb2f2f0          UDIV     r2,r2,r0
0000a2  6522              STR      r2,[r4,#0x50]
;;;113          Arr            = TmrFreq / Freq - 1.f;
0000a4  ed940a14          VLDR     s0,[r4,#0x50]
0000a8  eef80a40          VCVT.F32.U32 s1,s0
0000ac  ee800a88          VDIV.F32 s0,s1,s16
0000b0  eef70a00          VMOV.F32 s1,#1.00000000
0000b4  ee300a60          VSUB.F32 s0,s0,s1
0000b8  eef08a40          VMOV.F32 s17,s0
;;;114        } while ( Arr > TmrFreg.ARR_MAX );    
0000bc  6be0              LDR      r0,[r4,#0x3c]
0000be  ed900a03          VLDR     s0,[r0,#0xc]
0000c2  eeb80a40          VCVT.F32.U32 s0,s0
0000c6  eeb40ae8          VCMPE.F32 s0,s17
0000ca  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ce  d3d7              BCC      |L32.128|
                  |L32.208|
;;;115      }
;;;116       
;;;117      Pwm.ARR = Arr + 0.5f;
0000d0  eeb60a00          VMOV.F32 s0,#0.50000000
0000d4  ee380a80          VADD.F32 s0,s17,s0
0000d8  eebc0ac0          VCVT.U32.F32 s0,s0
0000dc  ee100a10          VMOV     r0,s0
0000e0  b280              UXTH     r0,r0
0000e2  f8ad0014          STRH     r0,[sp,#0x14]
;;;118                                                                               
;;;119      float DC = ParamHandle[1].RxVal / 100.f;                                //беспроцентная величина [ 0..1 ]
0000e6  481b              LDR      r0,|L32.340|
0000e8  ed900a07          VLDR     s0,[r0,#0x1c]
0000ec  eddf0a1a          VLDR     s1,|L32.344|
0000f0  ee809a20          VDIV.F32 s18,s0,s1
;;;120      Pwm.CCR  = ( TmrFreq / Freq ) * DC + 0.5f;
0000f4  ed940a14          VLDR     s0,[r4,#0x50]
0000f8  eeb80a40          VCVT.F32.U32 s0,s0
0000fc  eec00a08          VDIV.F32 s1,s0,s16
000100  eeb60a00          VMOV.F32 s0,#0.50000000
000104  ee000a89          VMLA.F32 s0,s1,s18
000108  eebc0ac0          VCVT.U32.F32 s0,s0
00010c  ee100a10          VMOV     r0,s0
000110  b280              UXTH     r0,r0
000112  f8ad0018          STRH     r0,[sp,#0x18]
;;;121      
;;;122      
;;;123      Tx_DutyCycle_pc = ( Pwm.CCR * 100.f * Tx_Freq_hz ) / TmrFreq;           //реально установленное значение коэффициента заполнения
000116  f8bd0018          LDRH     r0,[sp,#0x18]
00011a  ee000a10          VMOV     s0,r0
00011e  eeb80a40          VCVT.F32.U32 s0,s0
000122  eddf0a0d          VLDR     s1,|L32.344|
000126  ee200a20          VMUL.F32 s0,s0,s1
00012a  edd40a0c          VLDR     s1,[r4,#0x30]
00012e  ee600a20          VMUL.F32 s1,s0,s1
000132  ed940a14          VLDR     s0,[r4,#0x50]
000136  eeb80a40          VCVT.F32.U32 s0,s0
00013a  ee801a80          VDIV.F32 s2,s1,s0
00013e  ed841a0d          VSTR     s2,[r4,#0x34]
;;;124      
;;;125      return Pwm;
000142  9805              LDR      r0,[sp,#0x14]
000144  6028              STR      r0,[r5,#0]
000146  f8bd0018          LDRH     r0,[sp,#0x18]
00014a  80a8              STRH     r0,[r5,#4]
;;;126    }
00014c  b007              ADD      sp,sp,#0x1c
00014e  ecbd8b04          VPOP     {d8-d9}
000152  bd30              POP      {r4,r5,pc}
;;;127    
                          ENDP

                  |L32.340|
                          DCD      ParamHandle
                  |L32.344|
000158  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i._ZN11TExchngToPC7dis_adcEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC7dis_adcEv PROC ; TExchngToPC::dis_adc()
;;;595    
;;;596    void TExchngToPC::dis_adc()
000000  b510              PUSH     {r4,lr}
;;;597    {
000002  4604              MOV      r4,r0
;;;598      if ( LL_ADC_REG_IsConversionOngoing( Adc.Nbr ) == true )
000004  6ca1              LDR      r1,[r4,#0x48]
000006  6808              LDR      r0,[r1,#0]
000008  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsConversionOngoing(ADC_TypeDef*)
00000c  2801              CMP      r0,#1
00000e  d10a              BNE      |L33.38|
;;;599      {
;;;600        //есть продолжающееся преобразование АЦП из регулярной группы
;;;601        LL_ADC_REG_StopConversion( Adc.Nbr );
000010  6ca1              LDR      r1,[r4,#0x48]
000012  6808              LDR      r0,[r1,#0]
000014  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_StopConversion(ADC_TypeDef*)
;;;602        do {} while( LL_ADC_REG_IsStopConversionOngoing( Adc.Nbr ) == true );
000018  bf00              NOP      
                  |L33.26|
00001a  6ca1              LDR      r1,[r4,#0x48]
00001c  6808              LDR      r0,[r1,#0]
00001e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef*)
000022  2801              CMP      r0,#1
000024  d0f9              BEQ      |L33.26|
                  |L33.38|
;;;603      }
;;;604    
;;;605      if ( LL_ADC_INJ_IsConversionOngoing( Adc.Nbr ) == true )
000026  6ca1              LDR      r1,[r4,#0x48]
000028  6808              LDR      r0,[r1,#0]
00002a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_INJ_IsConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef*)
00002e  2801              CMP      r0,#1
000030  d10f              BNE      |L33.82|
;;;606      {
;;;607        //есть продолжающееся преобразование АЦП из инжектированной группы
;;;608        LL_ADC_INJ_StopConversion( Adc.Nbr );
000032  6ca1              LDR      r1,[r4,#0x48]
000034  6808              LDR      r0,[r1,#0]
000036  6881              LDR      r1,[r0,#8]
000038  4a0f              LDR      r2,|L33.120|
00003a  4011              ANDS     r1,r1,r2
00003c  f0410120          ORR      r1,r1,#0x20
000040  6081              STR      r1,[r0,#8]
000042  bf00              NOP      
;;;609        do {} while( LL_ADC_INJ_IsConversionOngoing( Adc.Nbr ) == true );
000044  bf00              NOP      
                  |L33.70|
000046  6ca1              LDR      r1,[r4,#0x48]
000048  6808              LDR      r0,[r1,#0]
00004a  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_INJ_IsConversionOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef*)
00004e  2801              CMP      r0,#1
000050  d0f9              BEQ      |L33.70|
                  |L33.82|
;;;610      }
;;;611      
;;;612      LL_ADC_Disable( Adc.Nbr );
000052  6ca1              LDR      r1,[r4,#0x48]
000054  6808              LDR      r0,[r1,#0]
000056  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14LL_ADC_DisableEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_Disable(ADC_TypeDef*)
;;;613      do {} while ( LL_ADC_IsEnabled( Adc.Nbr ) == true );
00005a  bf00              NOP      
                  |L33.92|
00005c  6ca1              LDR      r1,[r4,#0x48]
00005e  6808              LDR      r0,[r1,#0]
000060  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsEnabled(ADC_TypeDef*)
000064  2801              CMP      r0,#1
000066  d0f9              BEQ      |L33.92|
;;;614      do {} while ( LL_ADC_IsDisableOngoing( Adc.Nbr ) == true );
000068  bf00              NOP      
                  |L33.106|
00006a  6ca1              LDR      r1,[r4,#0x48]
00006c  6808              LDR      r0,[r1,#0]
00006e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_ADC_IsDisableOngoingEP11ADC_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsDisableOngoing(ADC_TypeDef*)
000072  2801              CMP      r0,#1
000074  d0f9              BEQ      |L33.106|
;;;615    }
000076  bd10              POP      {r4,pc}
;;;616      
                          ENDP

                  |L33.120|
                          DCD      0x7fffffc0

                          AREA ||i._ZN11TExchngToPC7set_pwmERKNS_4TPwmE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC7set_pwmERKNS_4TPwmE PROC ; TExchngToPC::set_pwm(const TExchngToPC::TPwm&)
;;;127    
;;;128    void TExchngToPC::set_pwm( const TPwm &Pwm )
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;130      LL_TIM_SetPrescaler    ( TmrFreg.Nbr, Pwm.PSC );
000006  8869              LDRH     r1,[r5,#2]
000008  6be2              LDR      r2,[r4,#0x3c]
00000a  6810              LDR      r0,[r2,#0]
00000c  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetPrescaler(TIM_TypeDef*, unsigned)
;;;131      LL_TIM_SetAutoReload   ( TmrFreg.Nbr, Pwm.ARR );
000010  8829              LDRH     r1,[r5,#0]
000012  6be2              LDR      r2,[r4,#0x3c]
000014  6810              LDR      r0,[r2,#0]
000016  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetAutoReload(TIM_TypeDef*, unsigned)
;;;132      LL_TIM_OC_SetCompareCH1( TmrFreg.Nbr, Pwm.CCR );
00001a  88a9              LDRH     r1,[r5,#4]
00001c  6be2              LDR      r2,[r4,#0x3c]
00001e  6810              LDR      r0,[r2,#0]
000020  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_SetCompareCH1EP11TIM_TypeDefj ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_SetCompareCH1(TIM_TypeDef*, unsigned)
;;;133    }
000024  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i._ZN11TExchngToPC7tx_testEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC7tx_testEPNS_12TParamHandleE PROC ; TExchngToPC::tx_test(TExchngToPC::TParamHandle*)
;;;845    
;;;846    void TExchngToPC::tx_test( TExchngToPC::TParamHandle *ParamHandle )
000000  b570              PUSH     {r4-r6,lr}
;;;847    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;848      tx_data(
000006  7d22              LDRB     r2,[r4,#0x14]
000008  2303              MOVS     r3,#3
00000a  4628              MOV      r0,r5
00000c  6921              LDR      r1,[r4,#0x10]
00000e  f7fffffe          BL       _ZN10TExtMaster7tx_dataEPKhtNS_11TWrapTxSignE ; TExtMaster::tx_data(const unsigned char*, unsigned short, TExtMaster::TWrapTxSign)
;;;849              ParamHandle->SetVal.Addr,
;;;850              ParamHandle->SetVal.BytesQty,
;;;851              TWrapTxSign::__ALL_WRAP_TX
;;;852             );
;;;853    }
000012  bd70              POP      {r4-r6,pc}
;;;854    
                          ENDP


                          AREA ||i._ZN11TExchngToPC8ctrl_pwmEPNS_12TParamHandleE||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC8ctrl_pwmEPNS_12TParamHandleE PROC ; TExchngToPC::ctrl_pwm(TExchngToPC::TParamHandle*)
;;;134    
;;;135    void TExchngToPC::ctrl_pwm( TExchngToPC::TParamHandle *ParamHandle )
000000  b57c              PUSH     {r2-r6,lr}
;;;136    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;137      ParamHandle->RxVal = chk_range( ParamHandle->RxVal, ParamHandle->Range );
000006  edd40a01          VLDR     s1,[r4,#4]
00000a  eeb00a60          VMOV.F32 s0,s1
00000e  f1040108          ADD      r1,r4,#8
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE ; TExchngToPC::chk_range(float, const TExchngToPC::TRange&)
000018  ed840a01          VSTR     s0,[r4,#4]
;;;138    
;;;139      set_upd_demand_flag( true );
00001c  2101              MOVS     r1,#1
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       _ZN11TExchngToPC19set_upd_demand_flagEb ; TExchngToPC::set_upd_demand_flag(bool)
;;;140      xSemaphoreTake( Tmr_TrigSem, portMAX_DELAY );
000024  2300              MOVS     r3,#0
000026  1e5a              SUBS     r2,r3,#1
000028  4619              MOV      r1,r3
00002a  4806              LDR      r0,|L36.68|
00002c  6800              LDR      r0,[r0,#0]  ; Tmr_TrigSem
00002e  f7fffffe          BL       xQueueGenericReceive
;;;141      
;;;142        TPwm Pwm = cnt_pwm();
000032  4629              MOV      r1,r5
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       _ZN11TExchngToPC7cnt_pwmEv ; TExchngToPC::cnt_pwm()
;;;143        set_pwm( Pwm );       //для сохранения максимальной разрядности необходимо модифицировать все параметры таймера \                            
00003a  4669              MOV      r1,sp
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       _ZN11TExchngToPC7set_pwmERKNS_4TPwmE ; TExchngToPC::set_pwm(const TExchngToPC::TPwm&)
;;;144    }
000042  bd7c              POP      {r2-r6,pc}
;;;145    
                          ENDP

                  |L36.68|
                          DCD      Tmr_TrigSem

                          AREA ||i._ZN11TExchngToPC8init_adcEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC8init_adcEv PROC ; TExchngToPC::init_adc()
;;;383    
;;;384    void TExchngToPC::init_adc()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;385    {                                                                        
000004  4604              MOV      r4,r0
;;;386      Adc.Pin.en_clk( Adc.Pin.ClkPortMask );                                //тактирование GPIO, к которому подключен вход АЦП
000006  6ca2              LDR      r2,[r4,#0x48]
000008  e9d2010c          LDRD     r0,r1,[r2,#0x30]
00000c  4788              BLX      r1
;;;387      Adc.Clk.en_periph( Adc.Clk.PeriphMask );                              //тактирование АЦП
00000e  6ca2              LDR      r2,[r4,#0x48]
000010  e9d21004          LDRD     r1,r0,[r2,#0x10]
000014  4788              BLX      r1
;;;388      Adc.sel_clk_src( Adc.SrcMask );                                       //выбор источника тактирования АЦП ( !!! по сбросу "No clock selected" )
000016  6ca2              LDR      r2,[r4,#0x48]
000018  e9d21008          LDRD     r1,r0,[r2,#0x20]
00001c  4788              BLX      r1
;;;389    
;;;390      LL_GPIO_SetPinMode( Adc.Pin.Gpio, Adc.Pin.Nbr, LL_GPIO_MODE_ANALOG );
00001e  6ca2              LDR      r2,[r4,#0x48]
000020  e9d2010a          LDRD     r0,r1,[r2,#0x28]
000024  2203              MOVS     r2,#3
000026  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinMode(GPIO_TypeDef*, unsigned, unsigned)
;;;391      
;;;392      /*
;;;393      *  АЦП по умолчанию в глубоко отключенном режиме
;;;394      */
;;;395      LL_ADC_DisableDeepPowerDown( Adc.Nbr );                               //выход из глубоко отключенного режима
00002a  6ca1              LDR      r1,[r4,#0x48]
00002c  6808              LDR      r0,[r1,#0]
00002e  6881              LDR      r1,[r0,#8]
000030  4a18              LDR      r2,|L37.148|
000032  4011              ANDS     r1,r1,r2
000034  6081              STR      r1,[r0,#8]
000036  bf00              NOP      
;;;396      LL_ADC_EnableInternalRegulator( Adc.Nbr );                            //включить внутренний регулятор напряжения АЦП
000038  6ca1              LDR      r1,[r4,#0x48]
00003a  6808              LDR      r0,[r1,#0]
00003c  6881              LDR      r1,[r0,#8]
00003e  4a16              LDR      r2,|L37.152|
000040  4011              ANDS     r1,r1,r2
000042  f0415180          ORR      r1,r1,#0x10000000
000046  6081              STR      r1,[r0,#8]
000048  bf00              NOP      
;;;397       
;;;398      vTaskDelay( pdMS_TO_TICKS( 100U ) );                                  //программа должная ждать время включения регулятора напряжения для АЦП. TADCVREG_STUP = 20мкс (макс.)
00004a  2064              MOVS     r0,#0x64
00004c  f7fffffe          BL       vTaskDelay
;;;399      
;;;400      LL_ADC_SetChannelSingleDiff( Adc.Nbr, Adc.Ch, LL_ADC_SINGLE_ENDED );  //конфигурация канала как single-ended, выполняется только при ADEN=0
000050  6ca3              LDR      r3,[r4,#0x48]
000052  227f              MOVS     r2,#0x7f
000054  68d9              LDR      r1,[r3,#0xc]
000056  6818              LDR      r0,[r3,#0]
000058  f8d030b0          LDR      r3,[r0,#0xb0]
00005c  f3c10512          UBFX     r5,r1,#0,#19
000060  43ab              BICS     r3,r3,r5
000062  f3c10512          UBFX     r5,r1,#0,#19
000066  f0020720          AND      r7,r2,#0x20
00006a  4e0c              LDR      r6,|L37.156|
00006c  40be              LSLS     r6,r6,r7
00006e  4035              ANDS     r5,r5,r6
000070  432b              ORRS     r3,r3,r5
000072  f8c030b0          STR      r3,[r0,#0xb0]
000076  bf00              NOP      
;;;401        
;;;402      adc_cal();
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       _ZN11TExchngToPC7adc_calEv ; TExchngToPC::adc_cal()
;;;403      
;;;404      LL_ADC_REG_SetDMATransfer( Adc.Nbr, LL_ADC_REG_DMA_TRANSFER_LIMITED );
00007e  6ca2              LDR      r2,[r4,#0x48]
000080  2101              MOVS     r1,#1
000082  6810              LDR      r0,[r2,#0]
000084  68c2              LDR      r2,[r0,#0xc]
000086  f0220203          BIC      r2,r2,#3
00008a  430a              ORRS     r2,r2,r1
00008c  60c2              STR      r2,[r0,#0xc]
00008e  bf00              NOP      
;;;405    }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;406    
                          ENDP

                  |L37.148|
                          DCD      0x5fffffc0
                  |L37.152|
                          DCD      0x7fffffc0
                  |L37.156|
                          DCD      0x0007ffff

                          AREA ||i._ZN11TExchngToPC8init_dmaEv||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPC8init_dmaEv PROC ; TExchngToPC::init_dma()
;;;406    
;;;407    void TExchngToPC::init_dma()
000000  b570              PUSH     {r4-r6,lr}
;;;408    {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;409    //  const TDmaAdc DmaAdc =
;;;410    //  {
;;;411    //    { 
;;;412    //     DMA1,
;;;413    //     LL_AHB1_GRP1_EnableClock,
;;;414    //     LL_AHB1_GRP1_PERIPH_DMA1,
;;;415    //     LL_DMA_ClearFlag_TC1
;;;416    //    },
;;;417    //    { LL_DMA_CHANNEL_1, DMA1_Channel1_IRQn },                       //RxChannel
;;;418    //  };
;;;419    
;;;420    //  struct TChannelSets
;;;421    //  {
;;;422    //    uint32_t PeriphAddr;
;;;423    //    uint32_t MemAddr;
;;;424    //    uint32_t Direction;
;;;425    //    uint32_t Mode;
;;;426    //    uint32_t NbData;
;;;427    //  };
;;;428    
;;;429    //struct TChannelSets
;;;430    //{
;;;431    //  uint32_t PeriphAddr;
;;;432    //  uint32_t MemAddr;
;;;433    //  uint32_t Direction;
;;;434    //  uint32_t Mode;
;;;435    //  uint32_t NbData;
;;;436    //};
;;;437      TChannelSets AdcCh =
000006  2214              MOVS     r2,#0x14
000008  491f              LDR      r1,|L38.136|
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       __aeabi_memcpy4
000010  6ca0              LDR      r0,[r4,#0x48]
000012  6800              LDR      r0,[r0,#0]
000014  3040              ADDS     r0,r0,#0x40
000016  900b              STR      r0,[sp,#0x2c]
;;;438      {
;;;439        ( uint32_t )&Adc.Nbr->DR,
;;;440        (uint32_t)Data,
;;;441        LL_DMA_DIRECTION_PERIPH_TO_MEMORY,
;;;442        LL_DMA_MODE_NORMAL,
;;;443        TX_SIZE,
;;;444      };
;;;445      
;;;446      DmaAdc.Periph.en_clk( DmaAdc.Periph.ClkMask );
000018  4a1c              LDR      r2,|L38.140|
00001a  6890              LDR      r0,[r2,#8]  ; DmaAdc
00001c  6851              LDR      r1,[r2,#4]  ; DmaAdc
00001e  4788              BLX      r1
;;;447      
;;;448      LL_DMA_InitTypeDef DMA_Init;
;;;449      
;;;450    	DMA_Init.PeriphOrM2MSrcAddress  = AdcCh.PeriphAddr;          //базовый адрес источника
000020  980b              LDR      r0,[sp,#0x2c]
000022  9000              STR      r0,[sp,#0]
;;;451    	DMA_Init.MemoryOrM2MDstAddress  = AdcCh.MemAddr;             //базовый адрес места назначения
000024  980c              LDR      r0,[sp,#0x30]
000026  9001              STR      r0,[sp,#4]
;;;452    	DMA_Init.Direction              = AdcCh.Direction;           //направление трансфера
000028  980d              LDR      r0,[sp,#0x34]
00002a  9002              STR      r0,[sp,#8]
;;;453    	DMA_Init.Mode                   = AdcCh.Mode;                //режим работы DMA (нормальный или кольцевой)
00002c  980e              LDR      r0,[sp,#0x38]
00002e  9003              STR      r0,[sp,#0xc]
;;;454    	DMA_Init.PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT; //инкремент блоков источника данных (периферии или ОЗУ)
000030  2000              MOVS     r0,#0
000032  9004              STR      r0,[sp,#0x10]
;;;455    	DMA_Init.MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_INCREMENT;   //инкремент блоков места назначения данных (периферии или ОЗУ)
000034  2080              MOVS     r0,#0x80
000036  9005              STR      r0,[sp,#0x14]
;;;456    	DMA_Init.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;    //выравнивание данных источника данных (периферии или ОЗУ)
000038  2000              MOVS     r0,#0
00003a  9006              STR      r0,[sp,#0x18]
;;;457    	DMA_Init.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;    //выравнивание данных места назначения данных (периферии или ОЗУ)
00003c  9007              STR      r0,[sp,#0x1c]
;;;458    	DMA_Init.NbData                 = AdcCh.NbData;              //количество блоков данных для обмена - перезаписывается под актуальный буфер
00003e  980f              LDR      r0,[sp,#0x3c]
000040  9008              STR      r0,[sp,#0x20]
;;;459    	DMA_Init.PeriphRequest          = LL_DMA_REQUEST_0;          //запрос периферии
000042  2000              MOVS     r0,#0
000044  9009              STR      r0,[sp,#0x24]
;;;460    	DMA_Init.Priority               = LL_DMA_PRIORITY_VERYHIGH;  //приоритет DMA канала
000046  f44f5040          MOV      r0,#0x3000
00004a  900a              STR      r0,[sp,#0x28]
;;;461      
;;;462      do { } while ( 
00004c  bf00              NOP      
                  |L38.78|
;;;463                    LL_DMA_Init(
00004e  4a0f              LDR      r2,|L38.140|
000050  6911              LDR      r1,[r2,#0x10]  ; DmaAdc
000052  6810              LDR      r0,[r2,#0]  ; DmaAdc
000054  466a              MOV      r2,sp
000056  f7fffffe          BL       LL_DMA_Init
00005a  2800              CMP      r0,#0
00005c  d1f7              BNE      |L38.78|
;;;464                                DmaAdc.Periph.Nbr,
;;;465                                DmaAdc.Ch.Nbr,
;;;466                                &DMA_Init
;;;467                               ) != SUCCESS           
;;;468                   );
;;;469    
;;;470      //настройка NVIC
;;;471      NVIC_SetPriority( 
00005e  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv ; [local to lev_gauge_to_pc_cpp]::NVIC_GetPriorityGrouping()
000062  4606              MOV      r6,r0
000064  2200              MOVS     r2,#0
000066  2105              MOVS     r1,#5
000068  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj ; [local to lev_gauge_to_pc_cpp]::NVIC_EncodePriority(unsigned, unsigned, unsigned)
00006c  4605              MOV      r5,r0
00006e  4907              LDR      r1,|L38.140|
000070  f9910014          LDRSB    r0,[r1,#0x14]
000074  4629              MOV      r1,r5
000076  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej ; [local to lev_gauge_to_pc_cpp]::NVIC_SetPriority(IRQn_Type, unsigned)
;;;472                       DmaAdc.Ch.IRQ, 
;;;473                       NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 5, 0) 
;;;474                      );                                                     //5 - максимальный уровень приоритета для прерывания \
;;;475                                                                               из которого можно вызывать API функции FreeRTOS 
;;;476      NVIC_EnableIRQ( DmaAdc.Ch.IRQ );                                       //прерывания при считывании данных ADC
00007a  4904              LDR      r1,|L38.140|
00007c  f9910014          LDRSB    r0,[r1,#0x14]
000080  f7fffffe          BL       _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type ; [local to lev_gauge_to_pc_cpp]::NVIC_EnableIRQ(IRQn_Type)
;;;477      
;;;478        
;;;479    }
000084  b010              ADD      sp,sp,#0x40
000086  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  |L38.136|
                          DCD      ||.constdata||+0xec
                  |L38.140|
                          DCD      DmaAdc

                          AREA ||i._ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE PROC ; TExchngToPC::chk_range(float, const TExchngToPC::TRange&)
;;;913    
;;;914    float TExchngToPC::chk_range( float Val, const TRange &Range )
000000  b530              PUSH     {r4,r5,lr}
;;;915    {
000002  4605              MOV      r5,r0
000004  eef00a40          VMOV.F32 s1,s0
000008  460c              MOV      r4,r1
;;;916      if (
00000a  eeb00a60          VMOV.F32 s0,s1
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       _ZN11TExchngToPC5iserrEf ; TExchngToPC::iserr(float)
000014  b930              CBNZ     r0,|L39.36|
;;;917          iserr( Val )
;;;918          ||
;;;919          Val < Range.Min
000016  ed940a00          VLDR     s0,[r4,#0]
00001a  eeb40ae0          VCMPE.F32 s0,s1
00001e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000022  dd02              BLE      |L39.42|
                  |L39.36|
;;;920         )
;;;921      {
;;;922        return Range.Min;
000024  ed940a00          VLDR     s0,[r4,#0]
                  |L39.40|
;;;923      }
;;;924      
;;;925      if ( Val > Range.Max )
;;;926      {
;;;927        return Range.Max;
;;;928      }
;;;929      
;;;930      return Val;
;;;931    }
000028  bd30              POP      {r4,r5,pc}
                  |L39.42|
00002a  ed940a01          VLDR     s0,[r4,#4]            ;925
00002e  eeb40ae0          VCMPE.F32 s0,s1                 ;925
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;925
000036  d202              BCS      |L39.62|
000038  ed940a01          VLDR     s0,[r4,#4]            ;927
00003c  e7f4              B        |L39.40|
                  |L39.62|
00003e  eeb00a60          VMOV.F32 s0,s1                 ;930
000042  e7f1              B        |L39.40|
;;;932    
                          ENDP


                          AREA ||i._ZN11TExchngToPCC1ERK9TUsart_HWRK7TTmr_HWS5_S5_RK7TAdc_HW||, CODE, READONLY, ALIGN=2

                  _ZN11TExchngToPCC2ERK9TUsart_HWRK7TTmr_HWS5_S5_RK7TAdc_HW                  ; Alternate entry point ; TExchngToPC::TExchngToPC__sub_object(const TUsart_HW&, const TTmr_HW&, const TTmr_HW&, const TTmr_HW&, const TAdc_HW&)
                  _ZN11TExchngToPCC1ERK9TUsart_HWRK7TTmr_HWS5_S5_RK7TAdc_HW PROC ; TExchngToPC::TExchngToPC(const TUsart_HW&, const TTmr_HW&, const TTmr_HW&, const TTmr_HW&, const TAdc_HW&)
;;;57     //----- Реализация класса TExchngToPC -----------------------------------------------------
;;;58     TExchngToPC::TExchngToPC(
;;;59                              const TUsart_HW &_Usart_HW,
;;;60                              const TTmr_HW   &_TmrFreg_HW,
;;;61                              const TTmr_HW   &_TmrCmp_HW,
;;;62                              const TTmr_HW   &_TmrDiff_HW,
;;;63                              const TAdc_HW   &_Adc_HW
;;;64                             )
;;;65     :
;;;66     TExtMaster( _Usart_HW ),
;;;67     Tx_Freq_hz( 0.f ),
;;;68     Tx_DutyCycle_pc( 0.f ),
;;;69     Tx_PosPot_1( 0U ),
;;;70     Tx_PosPot_2( 0U ),
;;;71     Tx_Test( 0U ),
;;;72     TmrFreg( _TmrFreg_HW ),
;;;73     TmrCmp( _TmrCmp_HW ),
;;;74     TmrDiff( _TmrDiff_HW ),
;;;75     Adc( _Adc_HW ),
;;;76     UpdDemandFlag( false ),
;;;77     TmrFreq( 100000U ),
;;;78     AdcCalibFactorS( 0U )
;;;79     {
;;;80     
;;;81     }
;;;82     
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
000010  4639              MOV      r1,r7
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _ZN10TExtMasterC1ERK9TUsart_HW ; TExtMaster::TExtMaster(const TUsart_HW&)
000018  4604              MOV      r4,r0
00001a  ed9f0a0e          VLDR     s0,|L40.84|
00001e  3438              ADDS     r4,r4,#0x38
000020  ed040a02          VSTR     s0,[r4,#-8]
000024  ed9f0a0b          VLDR     s0,|L40.84|
000028  ed040a01          VSTR     s0,[r4,#-4]
00002c  2000              MOVS     r0,#0
00002e  7020              STRB     r0,[r4,#0]
000030  7060              STRB     r0,[r4,#1]
000032  70a0              STRB     r0,[r4,#2]
000034  6065              STR      r5,[r4,#4]
000036  60a6              STR      r6,[r4,#8]
000038  f8c4800c          STR      r8,[r4,#0xc]
00003c  f8c49010          STR      r9,[r4,#0x10]
000040  7520              STRB     r0,[r4,#0x14]
000042  4805              LDR      r0,|L40.88|
000044  61a0              STR      r0,[r4,#0x18]
000046  2000              MOVS     r0,#0
000048  7720              STRB     r0,[r4,#0x1c]
00004a  3c38              SUBS     r4,r4,#0x38
00004c  4620              MOV      r0,r4
00004e  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

000052  0000              DCW      0x0000
                  |L40.84|
000054  00000000          DCFS     0x00000000 ; 0
                  |L40.88|
                          DCD      0x000186a0

                          AREA ||i._ZN11TExchngToPCD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN11TExchngToPCD2Ev                  ; Alternate entry point ; TExchngToPC::~TExchngToPC__sub_object()
                  _ZN11TExchngToPCD1Ev PROC ; TExchngToPC::~TExchngToPC()
;;;82     
;;;83     TExchngToPC::~TExchngToPC()
;;;84     {
;;;85     
;;;86     }
;;;87     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _ZN10TExtMasterD1Ev ; TExtMaster::~TExtMaster()
00000a  4604              MOV      r4,r0
00000c  4620              MOV      r0,r4
00000e  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14LL_ADC_DisableEP11ADC_TypeDef||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14LL_ADC_DisableEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_Disable(ADC_TypeDef*)
;;;6030     */
;;;6031   __STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;6032   {
;;;6033     /* Note: Write register with some additional bits forced to state reset     */
;;;6034     /*       instead of modifying only the selected bit for this function,      */
;;;6035     /*       to not interfere with bits with HW property "rs".                  */
;;;6036     MODIFY_REG(ADCx->CR,
000002  4a02              LDR      r2,|L42.12|
000004  4011              ANDS     r1,r1,r2
000006  1c89              ADDS     r1,r1,#2
000008  6081              STR      r1,[r0,#8]
;;;6037                ADC_CR_BITS_PROPERTY_RS,
;;;6038                ADC_CR_ADDIS);
;;;6039   }
00000a  4770              BX       lr
;;;6040   
                          ENDP

                  |L42.12|
                          DCD      0x7fffffc0

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type PROC ; [local to lev_gauge_to_pc_cpp]::NVIC_EnableIRQ(IRQn_Type)
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsEnabled(ADC_TypeDef*)
;;;6049     */
;;;6050   __STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
000000  4601              MOV      r1,r0
;;;6051   {
;;;6052     return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN));
000002  6888              LDR      r0,[r1,#8]
000004  f0000001          AND      r0,r0,#1
;;;6053   }
000008  4770              BX       lr
;;;6054   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej PROC ; [local to lev_gauge_to_pc_cpp]::NVIC_SetPriority(IRQn_Type, unsigned)
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L45.22|
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  070a              LSLS     r2,r1,#28
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L45.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L45.30|
                  |L45.22|
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  070a              LSLS     r2,r1,#28
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L45.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L45.30|
;;;1707     }
;;;1708   }
00001e  bd10              POP      {r4,pc}
;;;1709   
                          ENDP

                  |L45.32|
                          DCD      0xe000ed18
                  |L45.36|
                          DCD      0xe000e400

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_OC_SetModeEP11TIM_TypeDefjj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_OC_SetModeEP11TIM_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_SetMode(TIM_TypeDef*, unsigned, unsigned)
;;;2104     */
;;;2105   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2106   {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;2107     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000006  2901              CMP      r1,#1
000008  d101              BNE      |L46.14|
00000a  2500              MOVS     r5,#0
00000c  e020              B        |L46.80|
                  |L46.14|
00000e  2904              CMP      r1,#4
000010  d101              BNE      |L46.22|
000012  2501              MOVS     r5,#1
000014  e01c              B        |L46.80|
                  |L46.22|
000016  2910              CMP      r1,#0x10
000018  d101              BNE      |L46.30|
00001a  2502              MOVS     r5,#2
00001c  e018              B        |L46.80|
                  |L46.30|
00001e  2940              CMP      r1,#0x40
000020  d101              BNE      |L46.38|
000022  2503              MOVS     r5,#3
000024  e014              B        |L46.80|
                  |L46.38|
000026  f5b17f80          CMP      r1,#0x100
00002a  d101              BNE      |L46.48|
00002c  2504              MOVS     r5,#4
00002e  e00f              B        |L46.80|
                  |L46.48|
000030  f5b16f80          CMP      r1,#0x400
000034  d101              BNE      |L46.58|
000036  2505              MOVS     r5,#5
000038  e00a              B        |L46.80|
                  |L46.58|
00003a  f5b15f80          CMP      r1,#0x1000
00003e  d101              BNE      |L46.68|
000040  2506              MOVS     r5,#6
000042  e005              B        |L46.80|
                  |L46.68|
000044  f5b13f80          CMP      r1,#0x10000
000048  d101              BNE      |L46.78|
00004a  2507              MOVS     r5,#7
00004c  e000              B        |L46.80|
                  |L46.78|
00004e  2508              MOVS     r5,#8
                  |L46.80|
000050  4628              MOV      r0,r5
;;;2108     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
000052  4d09              LDR      r5,|L46.120|
000054  5c2e              LDRB     r6,[r5,r0]
000056  f1030518          ADD      r5,r3,#0x18
00005a  1972              ADDS     r2,r6,r5
;;;2109     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
00005c  4e07              LDR      r6,|L46.124|
00005e  5c37              LDRB     r7,[r6,r0]
000060  4e07              LDR      r6,|L46.128|
000062  40be              LSLS     r6,r6,r7
000064  6815              LDR      r5,[r2,#0]
000066  43b5              BICS     r5,r5,r6
000068  4e04              LDR      r6,|L46.124|
00006a  5c36              LDRB     r6,[r6,r0]
00006c  fa04f606          LSL      r6,r4,r6
000070  4335              ORRS     r5,r5,r6
000072  6015              STR      r5,[r2,#0]
;;;2110   }
000074  bdf0              POP      {r4-r7,pc}
;;;2111   
                          ENDP

000076  0000              DCW      0x0000
                  |L46.120|
                          DCD      OFFSET_TAB_CCMRx
                  |L46.124|
                          DCD      SHIFT_TAB_OCxx
                  |L46.128|
                          DCD      0x00010073

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_SetCounterEP11TIM_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_SetCounterEP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetCounter(TIM_TypeDef*, unsigned)
;;;1696     */
;;;1697   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;1698   {
;;;1699     WRITE_REG(TIMx->CNT, Counter);
;;;1700   }
000002  4770              BX       lr
;;;1701   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinMode(GPIO_TypeDef*, unsigned, unsigned)
;;;293      */
;;;294    __STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
000000  b530              PUSH     {r4,r5,lr}
;;;295    {
;;;296      MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
000002  6803              LDR      r3,[r0,#0]
000004  fa91f4a1          RBIT     r4,r1
000008  fab4f484          CLZ      r4,r4
00000c  0065              LSLS     r5,r4,#1
00000e  2403              MOVS     r4,#3
000010  40ac              LSLS     r4,r4,r5
000012  43a3              BICS     r3,r3,r4
000014  fa91f4a1          RBIT     r4,r1
000018  fab4f484          CLZ      r4,r4
00001c  0064              LSLS     r4,r4,#1
00001e  fa02f404          LSL      r4,r2,r4
000022  4323              ORRS     r3,r3,r4
000024  6003              STR      r3,[r0,#0]
;;;297    }
000026  bd30              POP      {r4,r5,pc}
;;;298    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinPull(GPIO_TypeDef*, unsigned, unsigned)
;;;504      */
;;;505    __STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
000000  b530              PUSH     {r4,r5,lr}
;;;506    {
;;;507      MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
000002  68c3              LDR      r3,[r0,#0xc]
000004  fa91f4a1          RBIT     r4,r1
000008  fab4f484          CLZ      r4,r4
00000c  0065              LSLS     r5,r4,#1
00000e  2403              MOVS     r4,#3
000010  40ac              LSLS     r4,r4,r5
000012  43a3              BICS     r3,r3,r4
000014  fa91f4a1          RBIT     r4,r1
000018  fab4f484          CLZ      r4,r4
00001c  0064              LSLS     r4,r4,#1
00001e  fa02f404          LSL      r4,r2,r4
000022  4323              ORRS     r3,r3,r4
000024  60c3              STR      r3,[r0,#0xc]
;;;508    }
000026  bd30              POP      {r4,r5,pc}
;;;509    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetPinSpeed(GPIO_TypeDef*, unsigned, unsigned)
;;;433      */
;;;434    __STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
000000  b530              PUSH     {r4,r5,lr}
;;;435    {
;;;436      MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U)),
000002  6883              LDR      r3,[r0,#8]
000004  fa91f4a1          RBIT     r4,r1
000008  fab4f484          CLZ      r4,r4
00000c  0065              LSLS     r5,r4,#1
00000e  2403              MOVS     r4,#3
000010  40ac              LSLS     r4,r4,r5
000012  43a3              BICS     r3,r3,r4
000014  fa91f4a1          RBIT     r4,r1
000018  fab4f484          CLZ      r4,r4
00001c  0064              LSLS     r4,r4,#1
00001e  fa02f404          LSL      r4,r2,r4
000022  4323              ORRS     r3,r3,r4
000024  6083              STR      r3,[r0,#8]
;;;437                 (Speed << (POSITION_VAL(Pin) * 2U)));
;;;438    }
000026  bd30              POP      {r4,r5,pc}
;;;439    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_IC_SetFilterEP11TIM_TypeDefjj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_IC_SetFilterEP11TIM_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetFilter(TIM_TypeDef*, unsigned, unsigned)
;;;2928     */
;;;2929   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2930   {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;2931     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000006  2901              CMP      r1,#1
000008  d101              BNE      |L51.14|
00000a  2500              MOVS     r5,#0
00000c  e020              B        |L51.80|
                  |L51.14|
00000e  2904              CMP      r1,#4
000010  d101              BNE      |L51.22|
000012  2501              MOVS     r5,#1
000014  e01c              B        |L51.80|
                  |L51.22|
000016  2910              CMP      r1,#0x10
000018  d101              BNE      |L51.30|
00001a  2502              MOVS     r5,#2
00001c  e018              B        |L51.80|
                  |L51.30|
00001e  2940              CMP      r1,#0x40
000020  d101              BNE      |L51.38|
000022  2503              MOVS     r5,#3
000024  e014              B        |L51.80|
                  |L51.38|
000026  f5b17f80          CMP      r1,#0x100
00002a  d101              BNE      |L51.48|
00002c  2504              MOVS     r5,#4
00002e  e00f              B        |L51.80|
                  |L51.48|
000030  f5b16f80          CMP      r1,#0x400
000034  d101              BNE      |L51.58|
000036  2505              MOVS     r5,#5
000038  e00a              B        |L51.80|
                  |L51.58|
00003a  f5b15f80          CMP      r1,#0x1000
00003e  d101              BNE      |L51.68|
000040  2506              MOVS     r5,#6
000042  e005              B        |L51.80|
                  |L51.68|
000044  f5b13f80          CMP      r1,#0x10000
000048  d101              BNE      |L51.78|
00004a  2507              MOVS     r5,#7
00004c  e000              B        |L51.80|
                  |L51.78|
00004e  2508              MOVS     r5,#8
                  |L51.80|
000050  4628              MOV      r0,r5
;;;2932     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
000052  4d09              LDR      r5,|L51.120|
000054  5c2e              LDRB     r6,[r5,r0]
000056  f1030518          ADD      r5,r3,#0x18
00005a  1972              ADDS     r2,r6,r5
;;;2933     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
00005c  4e07              LDR      r6,|L51.124|
00005e  5c37              LDRB     r7,[r6,r0]
000060  26f0              MOVS     r6,#0xf0
000062  40be              LSLS     r6,r6,r7
000064  6815              LDR      r5,[r2,#0]
000066  43b5              BICS     r5,r5,r6
000068  0c26              LSRS     r6,r4,#16
00006a  4f04              LDR      r7,|L51.124|
00006c  5c3f              LDRB     r7,[r7,r0]
00006e  40be              LSLS     r6,r6,r7
000070  4335              ORRS     r5,r5,r6
000072  6015              STR      r5,[r2,#0]
;;;2934   }
000074  bdf0              POP      {r4-r7,pc}
;;;2935   
                          ENDP

000076  0000              DCW      0x0000
                  |L51.120|
                          DCD      OFFSET_TAB_CCMRx
                  |L51.124|
                          DCD      SHIFT_TAB_ICxx

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetPrescaler(TIM_TypeDef*, unsigned)
;;;1738     */
;;;1739   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
000000  6281              STR      r1,[r0,#0x28]
;;;1740   {
;;;1741     WRITE_REG(TIMx->PSC, Prescaler);
;;;1742   }
000002  4770              BX       lr
;;;1743   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetSlaveMode(TIM_TypeDef*, unsigned)
;;;3293     */
;;;3294   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
000000  6882              LDR      r2,[r0,#8]
;;;3295   {
;;;3296     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
000002  4b02              LDR      r3,|L53.12|
000004  401a              ANDS     r2,r2,r3
000006  430a              ORRS     r2,r2,r1
000008  6082              STR      r2,[r0,#8]
;;;3297   }
00000a  4770              BX       lr
;;;3298   
                          ENDP

                  |L53.12|
                          DCD      0xfffefff8

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj PROC ; [local to lev_gauge_to_pc_cpp]::NVIC_EncodePriority(unsigned, unsigned, unsigned)
;;;1744    */
;;;1745   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1746   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1747     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
000006  f0030107          AND      r1,r3,#7
;;;1748     uint32_t PreemptPriorityBits;
;;;1749     uint32_t SubPriorityBits;
;;;1750   
;;;1751     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
00000a  f1c10007          RSB      r0,r1,#7
00000e  2804              CMP      r0,#4
000010  d901              BLS      |L54.22|
000012  2004              MOVS     r0,#4
000014  e001              B        |L54.26|
                  |L54.22|
000016  f1c10007          RSB      r0,r1,#7
                  |L54.26|
00001a  4606              MOV      r6,r0
;;;1752     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
00001c  1d08              ADDS     r0,r1,#4
00001e  2807              CMP      r0,#7
000020  d201              BCS      |L54.38|
000022  2000              MOVS     r0,#0
000024  e000              B        |L54.40|
                  |L54.38|
000026  1ec8              SUBS     r0,r1,#3
                  |L54.40|
000028  4605              MOV      r5,r0
;;;1753   
;;;1754     return (
00002a  2001              MOVS     r0,#1
00002c  40b0              LSLS     r0,r0,r6
00002e  1e40              SUBS     r0,r0,#1
000030  4020              ANDS     r0,r0,r4
000032  40a8              LSLS     r0,r0,r5
000034  2701              MOVS     r7,#1
000036  40af              LSLS     r7,r7,r5
000038  1e7f              SUBS     r7,r7,#1
00003a  4017              ANDS     r7,r7,r2
00003c  4338              ORRS     r0,r0,r7
;;;1755              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1756              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1757            );
;;;1758   }
00003e  bdf0              POP      {r4-r7,pc}
;;;1759   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_DMA_ClearFlag_TC1EP11DMA_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_DMA_ClearFlag_TC1EP11DMA_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_DMA_ClearFlag_TC1(DMA_TypeDef*)
;;;2036     */
;;;2037   __STATIC_INLINE void LL_DMA_ClearFlag_TC1(DMA_TypeDef *DMAx)
000000  2102              MOVS     r1,#2
;;;2038   {
;;;2039     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF1);
000002  6041              STR      r1,[r0,#4]
;;;2040   }
000004  4770              BX       lr
;;;2041   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_GPIO_SetAFPin_0_7EP12GPIO_TypeDefjj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_GPIO_SetAFPin_0_7EP12GPIO_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_GPIO_SetAFPin_0_7(GPIO_TypeDef*, unsigned, unsigned)
;;;576      */
;;;577    __STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
000000  b530              PUSH     {r4,r5,lr}
;;;578    {
;;;579      MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
000002  6a03              LDR      r3,[r0,#0x20]
000004  fa91f4a1          RBIT     r4,r1
000008  fab4f484          CLZ      r4,r4
00000c  00a5              LSLS     r5,r4,#2
00000e  240f              MOVS     r4,#0xf
000010  40ac              LSLS     r4,r4,r5
000012  43a3              BICS     r3,r3,r4
000014  fa91f4a1          RBIT     r4,r1
000018  fab4f484          CLZ      r4,r4
00001c  00a4              LSLS     r4,r4,#2
00001e  fa02f404          LSL      r4,r2,r4
000022  4323              ORRS     r3,r3,r4
000024  6203              STR      r3,[r0,#0x20]
;;;580                 (Alternate << (POSITION_VAL(Pin) * 4U)));
;;;581    }
000026  bd30              POP      {r4,r5,pc}
;;;582    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableCounter(TIM_TypeDef*)
;;;1454     */
;;;1455   __STATIC_INLINE void LL_TIM_EnableCounter(TIM_TypeDef *TIMx)
000000  6801              LDR      r1,[r0,#0]
;;;1456   {
;;;1457     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
000002  f0410101          ORR      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;1458   }
000008  4770              BX       lr
;;;1459   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_SetAutoReload(TIM_TypeDef*, unsigned)
;;;1765     */
;;;1766   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;1767   {
;;;1768     WRITE_REG(TIMx->ARR, AutoReload);
;;;1769   }
000002  4770              BX       lr
;;;1770   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_DisableCounterEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_DisableCounterEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_DisableCounter(TIM_TypeDef*)
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_DisableCounter(TIM_TypeDef *TIMx)
000000  6801              LDR      r1,[r0,#0]
;;;1467   {
;;;1468     CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;1469   }
000008  4770              BX       lr
;;;1470   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_IC_SetPolarityEP11TIM_TypeDefjj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_IC_SetPolarityEP11TIM_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetPolarity(TIM_TypeDef*, unsigned, unsigned)
;;;2994     */
;;;2995   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
000000  b570              PUSH     {r4-r6,lr}
;;;2996   {
;;;2997     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000002  2901              CMP      r1,#1
000004  d101              BNE      |L60.10|
000006  2400              MOVS     r4,#0
000008  e020              B        |L60.76|
                  |L60.10|
00000a  2904              CMP      r1,#4
00000c  d101              BNE      |L60.18|
00000e  2401              MOVS     r4,#1
000010  e01c              B        |L60.76|
                  |L60.18|
000012  2910              CMP      r1,#0x10
000014  d101              BNE      |L60.26|
000016  2402              MOVS     r4,#2
000018  e018              B        |L60.76|
                  |L60.26|
00001a  2940              CMP      r1,#0x40
00001c  d101              BNE      |L60.34|
00001e  2403              MOVS     r4,#3
000020  e014              B        |L60.76|
                  |L60.34|
000022  f5b17f80          CMP      r1,#0x100
000026  d101              BNE      |L60.44|
000028  2404              MOVS     r4,#4
00002a  e00f              B        |L60.76|
                  |L60.44|
00002c  f5b16f80          CMP      r1,#0x400
000030  d101              BNE      |L60.54|
000032  2405              MOVS     r4,#5
000034  e00a              B        |L60.76|
                  |L60.54|
000036  f5b15f80          CMP      r1,#0x1000
00003a  d101              BNE      |L60.64|
00003c  2406              MOVS     r4,#6
00003e  e005              B        |L60.76|
                  |L60.64|
000040  f5b13f80          CMP      r1,#0x10000
000044  d101              BNE      |L60.74|
000046  2407              MOVS     r4,#7
000048  e000              B        |L60.76|
                  |L60.74|
00004a  2408              MOVS     r4,#8
                  |L60.76|
00004c  4623              MOV      r3,r4
;;;2998     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
00004e  6a04              LDR      r4,[r0,#0x20]
000050  4d05              LDR      r5,|L60.104|
000052  5cee              LDRB     r6,[r5,r3]
000054  250a              MOVS     r5,#0xa
000056  40b5              LSLS     r5,r5,r6
000058  43ac              BICS     r4,r4,r5
00005a  4d03              LDR      r5,|L60.104|
00005c  5ced              LDRB     r5,[r5,r3]
00005e  fa02f505          LSL      r5,r2,r5
000062  432c              ORRS     r4,r4,r5
000064  6204              STR      r4,[r0,#0x20]
;;;2999                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;3000   }
000066  bd70              POP      {r4-r6,pc}
;;;3001   
                          ENDP

                  |L60.104|
                          DCD      SHIFT_TAB_CCxP

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_ADC_ClearFlag_ADRDYEP11ADC_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_ADC_ClearFlag_ADRDYEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_ClearFlag_ADRDY(ADC_TypeDef*)
;;;6665     */
;;;6666   __STATIC_INLINE void LL_ADC_ClearFlag_ADRDY(ADC_TypeDef *ADCx)
000000  2101              MOVS     r1,#1
;;;6667   {
;;;6668     WRITE_REG(ADCx->ISR, LL_ADC_FLAG_ADRDY);
000002  6001              STR      r1,[r0,#0]
;;;6669   }
000004  4770              BX       lr
;;;6670   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_IC_SetPrescalerEP11TIM_TypeDefjj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_IC_SetPrescalerEP11TIM_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetPrescaler(TIM_TypeDef*, unsigned, unsigned)
;;;2865     */
;;;2866   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2867   {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;2868     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000006  2901              CMP      r1,#1
000008  d101              BNE      |L62.14|
00000a  2500              MOVS     r5,#0
00000c  e020              B        |L62.80|
                  |L62.14|
00000e  2904              CMP      r1,#4
000010  d101              BNE      |L62.22|
000012  2501              MOVS     r5,#1
000014  e01c              B        |L62.80|
                  |L62.22|
000016  2910              CMP      r1,#0x10
000018  d101              BNE      |L62.30|
00001a  2502              MOVS     r5,#2
00001c  e018              B        |L62.80|
                  |L62.30|
00001e  2940              CMP      r1,#0x40
000020  d101              BNE      |L62.38|
000022  2503              MOVS     r5,#3
000024  e014              B        |L62.80|
                  |L62.38|
000026  f5b17f80          CMP      r1,#0x100
00002a  d101              BNE      |L62.48|
00002c  2504              MOVS     r5,#4
00002e  e00f              B        |L62.80|
                  |L62.48|
000030  f5b16f80          CMP      r1,#0x400
000034  d101              BNE      |L62.58|
000036  2505              MOVS     r5,#5
000038  e00a              B        |L62.80|
                  |L62.58|
00003a  f5b15f80          CMP      r1,#0x1000
00003e  d101              BNE      |L62.68|
000040  2506              MOVS     r5,#6
000042  e005              B        |L62.80|
                  |L62.68|
000044  f5b13f80          CMP      r1,#0x10000
000048  d101              BNE      |L62.78|
00004a  2507              MOVS     r5,#7
00004c  e000              B        |L62.80|
                  |L62.78|
00004e  2508              MOVS     r5,#8
                  |L62.80|
000050  4628              MOV      r0,r5
;;;2869     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
000052  4d09              LDR      r5,|L62.120|
000054  5c2e              LDRB     r6,[r5,r0]
000056  f1030518          ADD      r5,r3,#0x18
00005a  1972              ADDS     r2,r6,r5
;;;2870     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
00005c  4e07              LDR      r6,|L62.124|
00005e  5c37              LDRB     r7,[r6,r0]
000060  260c              MOVS     r6,#0xc
000062  40be              LSLS     r6,r6,r7
000064  6815              LDR      r5,[r2,#0]
000066  43b5              BICS     r5,r5,r6
000068  0c26              LSRS     r6,r4,#16
00006a  4f04              LDR      r7,|L62.124|
00006c  5c3f              LDRB     r7,[r7,r0]
00006e  40be              LSLS     r6,r6,r7
000070  4335              ORRS     r5,r5,r6
000072  6015              STR      r5,[r2,#0]
;;;2871   }
000074  bdf0              POP      {r4-r7,pc}
;;;2872   
                          ENDP

000076  0000              DCW      0x0000
                  |L62.120|
                          DCD      OFFSET_TAB_CCMRx
                  |L62.124|
                          DCD      SHIFT_TAB_ICxx

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_OC_ConfigOutputEP11TIM_TypeDefjj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_OC_ConfigOutputEP11TIM_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_ConfigOutput(TIM_TypeDef*, unsigned, unsigned)
;;;2059     */
;;;2060   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2061   {
000002  4613              MOV      r3,r2
;;;2062     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000004  2901              CMP      r1,#1
000006  d101              BNE      |L63.12|
000008  2500              MOVS     r5,#0
00000a  e020              B        |L63.78|
                  |L63.12|
00000c  2904              CMP      r1,#4
00000e  d101              BNE      |L63.20|
000010  2501              MOVS     r5,#1
000012  e01c              B        |L63.78|
                  |L63.20|
000014  2910              CMP      r1,#0x10
000016  d101              BNE      |L63.28|
000018  2502              MOVS     r5,#2
00001a  e018              B        |L63.78|
                  |L63.28|
00001c  2940              CMP      r1,#0x40
00001e  d101              BNE      |L63.36|
000020  2503              MOVS     r5,#3
000022  e014              B        |L63.78|
                  |L63.36|
000024  f5b17f80          CMP      r1,#0x100
000028  d101              BNE      |L63.46|
00002a  2504              MOVS     r5,#4
00002c  e00f              B        |L63.78|
                  |L63.46|
00002e  f5b16f80          CMP      r1,#0x400
000032  d101              BNE      |L63.56|
000034  2505              MOVS     r5,#5
000036  e00a              B        |L63.78|
                  |L63.56|
000038  f5b15f80          CMP      r1,#0x1000
00003c  d101              BNE      |L63.66|
00003e  2506              MOVS     r5,#6
000040  e005              B        |L63.78|
                  |L63.66|
000042  f5b13f80          CMP      r1,#0x10000
000046  d101              BNE      |L63.76|
000048  2507              MOVS     r5,#7
00004a  e000              B        |L63.78|
                  |L63.76|
00004c  2508              MOVS     r5,#8
                  |L63.78|
00004e  462a              MOV      r2,r5
;;;2063     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
000050  4d13              LDR      r5,|L63.160|
000052  5cae              LDRB     r6,[r5,r2]
000054  f1000518          ADD      r5,r0,#0x18
000058  1974              ADDS     r4,r6,r5
;;;2064     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
00005a  4e12              LDR      r6,|L63.164|
00005c  5cb7              LDRB     r7,[r6,r2]
00005e  2603              MOVS     r6,#3
000060  40be              LSLS     r6,r6,r7
000062  6825              LDR      r5,[r4,#0]
000064  43b5              BICS     r5,r5,r6
000066  6025              STR      r5,[r4,#0]
;;;2065     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
000068  6a05              LDR      r5,[r0,#0x20]
00006a  4e0f              LDR      r6,|L63.168|
00006c  5cb7              LDRB     r7,[r6,r2]
00006e  2602              MOVS     r6,#2
000070  40be              LSLS     r6,r6,r7
000072  43b5              BICS     r5,r5,r6
000074  f0030602          AND      r6,r3,#2
000078  4f0b              LDR      r7,|L63.168|
00007a  5cbf              LDRB     r7,[r7,r2]
00007c  40be              LSLS     r6,r6,r7
00007e  4335              ORRS     r5,r5,r6
000080  6205              STR      r5,[r0,#0x20]
;;;2066                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;2067     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
000082  6845              LDR      r5,[r0,#4]
000084  4e09              LDR      r6,|L63.172|
000086  5cb7              LDRB     r7,[r6,r2]
000088  f44f7680          MOV      r6,#0x100
00008c  40be              LSLS     r6,r6,r7
00008e  43b5              BICS     r5,r5,r6
000090  f4037680          AND      r6,r3,#0x100
000094  4f05              LDR      r7,|L63.172|
000096  5cbf              LDRB     r7,[r7,r2]
000098  40be              LSLS     r6,r6,r7
00009a  4335              ORRS     r5,r5,r6
00009c  6045              STR      r5,[r0,#4]
;;;2068                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;2069   }
00009e  bdf0              POP      {r4-r7,pc}
;;;2070   
                          ENDP

                  |L63.160|
                          DCD      OFFSET_TAB_CCMRx
                  |L63.164|
                          DCD      SHIFT_TAB_OCxx
                  |L63.168|
                          DCD      SHIFT_TAB_CCxP
                  |L63.172|
                          DCD      SHIFT_TAB_OISx

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_ADC_IsDisableOngoingEP11ADC_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_ADC_IsDisableOngoingEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_IsDisableOngoing(ADC_TypeDef*)
;;;6060     */
;;;6061   __STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(ADC_TypeDef *ADCx)
000000  4601              MOV      r1,r0
;;;6062   {
;;;6063     return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS));
000002  6888              LDR      r0,[r1,#8]
000004  f3c00040          UBFX     r0,r0,#1,#1
;;;6064   }
000008  4770              BX       lr
;;;6065   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_CC_EnableChannel(TIM_TypeDef*, unsigned)
;;;1956     */
;;;1957   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
000000  6a02              LDR      r2,[r0,#0x20]
;;;1958   {
;;;1959     SET_BIT(TIMx->CCER, Channels);
000002  430a              ORRS     r2,r2,r1
000004  6202              STR      r2,[r0,#0x20]
;;;1960   }
000006  4770              BX       lr
;;;1961   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_ClearFlag_UPDATE(TIM_TypeDef*)
;;;4026     */
;;;4027   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
000000  f06f0101          MVN      r1,#1
;;;4028   {
;;;4029     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
000004  6101              STR      r1,[r0,#0x10]
;;;4030   }
000006  4770              BX       lr
;;;4031   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableARRPreloadEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableARRPreloadEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableARRPreload(TIM_TypeDef*)
;;;1625     */
;;;1626   __STATIC_INLINE void LL_TIM_EnableARRPreload(TIM_TypeDef *TIMx)
000000  6801              LDR      r1,[r0,#0]
;;;1627   {
;;;1628     SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;1629   }
000008  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableAllOutputsEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableAllOutputsEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_EnableAllOutputs(TIM_TypeDef*)
;;;3614     */
;;;3615   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
000000  6c41              LDR      r1,[r0,#0x44]
;;;3616   {
;;;3617     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
000002  f4414100          ORR      r1,r1,#0x8000
000006  6441              STR      r1,[r0,#0x44]
;;;3618   }
000008  4770              BX       lr
;;;3619   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_EnablePreloadEP11TIM_TypeDefj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_EnablePreloadEP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_EnablePreload(TIM_TypeDef*, unsigned)
;;;2381     */
;;;2382   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2383   {
000002  4602              MOV      r2,r0
;;;2384     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000004  2901              CMP      r1,#1
000006  d101              BNE      |L69.12|
000008  2400              MOVS     r4,#0
00000a  e020              B        |L69.78|
                  |L69.12|
00000c  2904              CMP      r1,#4
00000e  d101              BNE      |L69.20|
000010  2401              MOVS     r4,#1
000012  e01c              B        |L69.78|
                  |L69.20|
000014  2910              CMP      r1,#0x10
000016  d101              BNE      |L69.28|
000018  2402              MOVS     r4,#2
00001a  e018              B        |L69.78|
                  |L69.28|
00001c  2940              CMP      r1,#0x40
00001e  d101              BNE      |L69.36|
000020  2403              MOVS     r4,#3
000022  e014              B        |L69.78|
                  |L69.36|
000024  f5b17f80          CMP      r1,#0x100
000028  d101              BNE      |L69.46|
00002a  2404              MOVS     r4,#4
00002c  e00f              B        |L69.78|
                  |L69.46|
00002e  f5b16f80          CMP      r1,#0x400
000032  d101              BNE      |L69.56|
000034  2405              MOVS     r4,#5
000036  e00a              B        |L69.78|
                  |L69.56|
000038  f5b15f80          CMP      r1,#0x1000
00003c  d101              BNE      |L69.66|
00003e  2406              MOVS     r4,#6
000040  e005              B        |L69.78|
                  |L69.66|
000042  f5b13f80          CMP      r1,#0x10000
000046  d101              BNE      |L69.76|
000048  2407              MOVS     r4,#7
00004a  e000              B        |L69.78|
                  |L69.76|
00004c  2408              MOVS     r4,#8
                  |L69.78|
00004e  4623              MOV      r3,r4
;;;2385     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
000050  4c06              LDR      r4,|L69.108|
000052  5ce5              LDRB     r5,[r4,r3]
000054  f1020418          ADD      r4,r2,#0x18
000058  1928              ADDS     r0,r5,r4
;;;2386     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
00005a  4d05              LDR      r5,|L69.112|
00005c  5cee              LDRB     r6,[r5,r3]
00005e  2508              MOVS     r5,#8
000060  40b5              LSLS     r5,r5,r6
000062  6804              LDR      r4,[r0,#0]
000064  432c              ORRS     r4,r4,r5
000066  6004              STR      r4,[r0,#0]
;;;2387   }
000068  bd70              POP      {r4-r6,pc}
;;;2388   
                          ENDP

00006a  0000              DCW      0x0000
                  |L69.108|
                          DCD      OFFSET_TAB_CCMRx
                  |L69.112|
                          DCD      SHIFT_TAB_OCxx

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_SetCompareCH1EP11TIM_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_SetCompareCH1EP11TIM_TypeDefj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_OC_SetCompareCH1(TIM_TypeDef*, unsigned)
;;;2551     */
;;;2552   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
000000  6341              STR      r1,[r0,#0x34]
;;;2553   {
;;;2554     WRITE_REG(TIMx->CCR1, CompareValue);
;;;2555   }
000002  4770              BX       lr
;;;2556   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_AHB1_GRP1_EnableClockEj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_AHB1_GRP1_EnableClockEj PROC ; [local to lev_gauge_to_pc_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
;;;341    */
;;;342    __STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
000000  b508              PUSH     {r3,lr}
;;;343    {
;;;344      __IO uint32_t tmpreg;
;;;345      SET_BIT(RCC->AHB1ENR, Periphs);
000002  4905              LDR      r1,|L71.24|
000004  6c89              LDR      r1,[r1,#0x48]
000006  4301              ORRS     r1,r1,r0
000008  4a03              LDR      r2,|L71.24|
00000a  6491              STR      r1,[r2,#0x48]
;;;346      /* Delay after an RCC peripheral clock enabling */
;;;347      tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
00000c  4611              MOV      r1,r2
00000e  6c89              LDR      r1,[r1,#0x48]
000010  4001              ANDS     r1,r1,r0
000012  9100              STR      r1,[sp,#0]
;;;348      (void)tmpreg;
000014  bf00              NOP      
;;;349    }
000016  bd08              POP      {r3,pc}
;;;350    
                          ENDP

                  |L71.24|
                          DCD      0x40021000

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_TIM_IC_SetActiveInputEP11TIM_TypeDefjj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_TIM_IC_SetActiveInputEP11TIM_TypeDefjj PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IC_SetActiveInput(TIM_TypeDef*, unsigned, unsigned)
;;;2815     */
;;;2816   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2817   {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;2818     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000006  2901              CMP      r1,#1
000008  d101              BNE      |L72.14|
00000a  2500              MOVS     r5,#0
00000c  e020              B        |L72.80|
                  |L72.14|
00000e  2904              CMP      r1,#4
000010  d101              BNE      |L72.22|
000012  2501              MOVS     r5,#1
000014  e01c              B        |L72.80|
                  |L72.22|
000016  2910              CMP      r1,#0x10
000018  d101              BNE      |L72.30|
00001a  2502              MOVS     r5,#2
00001c  e018              B        |L72.80|
                  |L72.30|
00001e  2940              CMP      r1,#0x40
000020  d101              BNE      |L72.38|
000022  2503              MOVS     r5,#3
000024  e014              B        |L72.80|
                  |L72.38|
000026  f5b17f80          CMP      r1,#0x100
00002a  d101              BNE      |L72.48|
00002c  2504              MOVS     r5,#4
00002e  e00f              B        |L72.80|
                  |L72.48|
000030  f5b16f80          CMP      r1,#0x400
000034  d101              BNE      |L72.58|
000036  2505              MOVS     r5,#5
000038  e00a              B        |L72.80|
                  |L72.58|
00003a  f5b15f80          CMP      r1,#0x1000
00003e  d101              BNE      |L72.68|
000040  2506              MOVS     r5,#6
000042  e005              B        |L72.80|
                  |L72.68|
000044  f5b13f80          CMP      r1,#0x10000
000048  d101              BNE      |L72.78|
00004a  2507              MOVS     r5,#7
00004c  e000              B        |L72.80|
                  |L72.78|
00004e  2508              MOVS     r5,#8
                  |L72.80|
000050  4628              MOV      r0,r5
;;;2819     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
000052  4d09              LDR      r5,|L72.120|
000054  5c2e              LDRB     r6,[r5,r0]
000056  f1030518          ADD      r5,r3,#0x18
00005a  1972              ADDS     r2,r6,r5
;;;2820     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
00005c  4e07              LDR      r6,|L72.124|
00005e  5c37              LDRB     r7,[r6,r0]
000060  2603              MOVS     r6,#3
000062  40be              LSLS     r6,r6,r7
000064  6815              LDR      r5,[r2,#0]
000066  43b5              BICS     r5,r5,r6
000068  0c26              LSRS     r6,r4,#16
00006a  4f04              LDR      r7,|L72.124|
00006c  5c3f              LDRB     r7,[r7,r0]
00006e  40be              LSLS     r6,r6,r7
000070  4335              ORRS     r5,r5,r6
000072  6015              STR      r5,[r2,#0]
;;;2821   }
000074  bdf0              POP      {r4-r7,pc}
;;;2822   
                          ENDP

000076  0000              DCW      0x0000
                  |L72.120|
                          DCD      OFFSET_TAB_CCMRx
                  |L72.124|
                          DCD      SHIFT_TAB_ICxx

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv PROC ; [local to lev_gauge_to_pc_cpp]::NVIC_GetPriorityGrouping()
;;;1614    */
;;;1615   __STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L73.12|
;;;1616   {
;;;1617     return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;1618   }
000008  4770              BX       lr
;;;1619   
                          ENDP

00000a  0000              DCW      0x0000
                  |L73.12|
                          DCD      0xe000ed0c

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_StopConversion(ADC_TypeDef*)
;;;6155     */
;;;6156   __STATIC_INLINE void LL_ADC_REG_StopConversion(ADC_TypeDef *ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;6157   {
;;;6158     /* Note: Write register with some additional bits forced to state reset     */
;;;6159     /*       instead of modifying only the selected bit for this function,      */
;;;6160     /*       to not interfere with bits with HW property "rs".                  */
;;;6161     MODIFY_REG(ADCx->CR,
000002  4a03              LDR      r2,|L74.16|
000004  4011              ANDS     r1,r1,r2
000006  f0410110          ORR      r1,r1,#0x10
00000a  6081              STR      r1,[r0,#8]
;;;6162                ADC_CR_BITS_PROPERTY_RS,
;;;6163                ADC_CR_ADSTP);
;;;6164   }
00000c  4770              BX       lr
;;;6165   
                          ENDP

00000e  0000              DCW      0x0000
                  |L74.16|
                          DCD      0x7fffffc0

                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef*)
;;;4037     */
;;;4038   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
000000  4601              MOV      r1,r0
;;;4039   {
;;;4040     return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
000002  6908              LDR      r0,[r1,#0x10]
000004  f0000001          AND      r0,r0,#1
;;;4041   }
000008  4770              BX       lr
;;;4042   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF27LL_TIM_GenerateEvent_UPDATEEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF27LL_TIM_GenerateEvent_UPDATEEP11TIM_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef*)
;;;4894     */
;;;4895   __STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
000000  6941              LDR      r1,[r0,#0x14]
;;;4896   {
;;;4897     SET_BIT(TIMx->EGR, TIM_EGR_UG);
000002  f0410101          ORR      r1,r1,#1
000006  6141              STR      r1,[r0,#0x14]
;;;4898   }
000008  4770              BX       lr
;;;4899   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_INJ_IsConversionOngoingEP11ADC_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_INJ_IsConversionOngoingEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef*)
;;;6354     */
;;;6355   __STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
000000  4601              MOV      r1,r0
;;;6356   {
;;;6357     return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART));
000002  6888              LDR      r0,[r1,#8]
000004  f3c000c0          UBFX     r0,r0,#3,#1
;;;6358   }
000008  4770              BX       lr
;;;6359   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsConversionOngoing(ADC_TypeDef*)
;;;6171     */
;;;6172   __STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
000000  4601              MOV      r1,r0
;;;6173   {
;;;6174     return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
000002  6888              LDR      r0,[r1,#8]
000004  f3c00080          UBFX     r0,r0,#2,#1
;;;6175   }
000008  4770              BX       lr
;;;6176   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef PROC ; [local to lev_gauge_to_pc_cpp]::LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef*)
;;;6182     */
;;;6183   __STATIC_INLINE uint32_t LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef *ADCx)
000000  4601              MOV      r1,r0
;;;6184   {
;;;6185     return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTP) == (ADC_CR_ADSTP));
000002  6888              LDR      r0,[r1,#8]
000004  f3c01000          UBFX     r0,r0,#4,#1
;;;6186   }
000008  4770              BX       lr
;;;6187   
                          ENDP


                          AREA ||i.__sti___19_lev_gauge_to_pc_cpp_UIF||, CODE, READONLY, ALIGN=2

                  __sti___19_lev_gauge_to_pc_cpp_UIF PROC
000000  b51c              PUSH     {r2-r4,lr}
000002  4808              LDR      r0,|L80.36|
000004  4908              LDR      r1,|L80.40|
000006  4b09              LDR      r3,|L80.44|
000008  4a09              LDR      r2,|L80.48|
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  4909              LDR      r1,|L80.52|
000010  4809              LDR      r0,|L80.56|
000012  f7fffffe          BL       _ZN11TExchngToPCC1ERK9TUsart_HWRK7TTmr_HWS5_S5_RK7TAdc_HW ; TExchngToPC::TExchngToPC(const TUsart_HW&, const TTmr_HW&, const TTmr_HW&, const TTmr_HW&, const TAdc_HW&)
000016  4604              MOV      r4,r0
000018  4a08              LDR      r2,|L80.60|
00001a  4909              LDR      r1,|L80.64|
00001c  f7fffffe          BL       __aeabi_atexit
000020  bd1c              POP      {r2-r4,pc}
                          ENDP

000022  0000              DCW      0x0000
                  |L80.36|
                          DCD      Adc_HW
                  |L80.40|
                          DCD      TmrDiff_HW
                  |L80.44|
                          DCD      TmrCmp_HW
                  |L80.48|
                          DCD      TmrFreg_HW
                  |L80.52|
                          DCD      UsartExt_HW
                  |L80.56|
                          DCD      ExchngToPC
                  |L80.60|
                          DCD      __dso_handle
                  |L80.64|
                          DCD      _ZN11TExchngToPCD1Ev ; TExchngToPC::~TExchngToPC()

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16NVIC_SetPriorityE9IRQn_Typej||
                          DCD      0x00000001

                          AREA ||area_number.82||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.82||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19NVIC_EncodePriorityEjjj||
                          DCD      0x00000001

                          AREA ||area_number.83||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_DMA_ClearFlag_TC1EP11DMA_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.83||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_DMA_ClearFlag_TC1EP11DMA_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.84||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_TIM_IC_SetActiveInputEP11TIM_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.84||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_TIM_IC_SetActiveInputEP11TIM_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.85||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_IC_SetPrescalerEP11TIM_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.85||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_IC_SetPrescalerEP11TIM_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.86||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_IC_SetFilterEP11TIM_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.86||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_IC_SetFilterEP11TIM_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.87||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_IC_SetPolarityEP11TIM_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.87||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_IC_SetPolarityEP11TIM_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.88||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.88||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinModeEP12GPIO_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.89||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.89||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_GPIO_SetPinSpeedEP12GPIO_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.90||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.90||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF18LL_GPIO_SetPinPullEP12GPIO_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.91||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_GPIO_SetAFPin_0_7EP12GPIO_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.91||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_GPIO_SetAFPin_0_7EP12GPIO_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.92||, LINKORDER=||i._ZN11TExchngToPC8init_dmaEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.92||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC8init_dmaEv||
                          DCD      0x00000001

                          AREA ||area_number.93||, LINKORDER=||i._ZN11TExchngToPC7adc_calEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.93||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC7adc_calEv||
                          DCD      0x00000001

                          AREA ||area_number.94||, LINKORDER=||i._ZN11TExchngToPC8init_adcEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.94||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC8init_adcEv||
                          DCD      0x00000001

                          AREA ||area_number.95||, LINKORDER=||i._ZN11TExchngToPC13init_tmr_diffEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.95||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC13init_tmr_diffEv||
                          DCD      0x00000001

                          AREA ||area_number.96||, LINKORDER=||i._ZN11TExchngToPC12init_tmr_cmpEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.96||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC12init_tmr_cmpEv||
                          DCD      0x00000001

                          AREA ||area_number.97||, LINKORDER=||i._ZN11TExchngToPC7cnt_pwmEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.97||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC7cnt_pwmEv||
                          DCD      0x00000001

                          AREA ||area_number.98||, LINKORDER=||i._ZN11TExchngToPC13init_tmr_fregEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.98||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC13init_tmr_fregEv||
                          DCD      0x00000001

                          AREA ||area_number.99||, LINKORDER=||i._Z15lev_gauge_to_pcPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.99||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z15lev_gauge_to_pcPv||
                          DCD      0x00000001

                          AREA ||area_number.100||, LINKORDER=||i._ZN11TExchngToPC19set_upd_demand_flagEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.100||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC19set_upd_demand_flagEb||
                          DCD      0x00000001

                          AREA ||area_number.101||, LINKORDER=||i._ZN11TExchngToPC19get_upd_demand_flagEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.101||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC19get_upd_demand_flagEv||
                          DCD      0x00000001

                          AREA ||area_number.102||, LINKORDER=||i.TIM1_BRK_TIM15_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.102||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.TIM1_BRK_TIM15_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.103||, LINKORDER=||i.EXTI15_10_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.103||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.EXTI15_10_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.104||, LINKORDER=||i.DMA1_Channel1_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.104||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.DMA1_Channel1_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.105||, LINKORDER=||i._ZN11TExchngToPCC1ERK9TUsart_HWRK7TTmr_HWS5_S5_RK7TAdc_HW||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.105||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPCC1ERK9TUsart_HWRK7TTmr_HWS5_S5_RK7TAdc_HW||
                          DCD      0x00000001

                          AREA ||area_number.106||, LINKORDER=||i._ZN11TExchngToPCD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.106||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPCD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.107||, LINKORDER=||i._ZN11TExchngToPC7set_pwmERKNS_4TPwmE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.107||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC7set_pwmERKNS_4TPwmE||
                          DCD      0x00000001

                          AREA ||area_number.108||, LINKORDER=||i._ZN11TExchngToPC5iserrEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.108||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC5iserrEf||
                          DCD      0x00000001

                          AREA ||area_number.109||, LINKORDER=||i._ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.109||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC9chk_rangeEfRKNS_6TRangeE||
                          DCD      0x00000001

                          AREA ||area_number.110||, LINKORDER=||i._ZN11TExchngToPC8ctrl_pwmEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.110||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC8ctrl_pwmEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.111||, LINKORDER=||i._ZN11TExchngToPC11rx_set_fregEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.111||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC11rx_set_fregEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.112||, LINKORDER=||i._ZN11TExchngToPC17rx_set_duty_cycleEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.112||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC17rx_set_duty_cycleEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.113||, LINKORDER=||i._ZN11TExchngToPC16rx_set_pos_pot_1EPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.113||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC16rx_set_pos_pot_1EPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.114||, LINKORDER=||i._ZN11TExchngToPC16rx_set_pos_pot_2EPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.114||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC16rx_set_pos_pot_2EPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.115||, LINKORDER=||i._ZN11TExchngToPC16dis_dma_with_adcEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.115||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC16dis_dma_with_adcEv||
                          DCD      0x00000001

                          AREA ||area_number.116||, LINKORDER=||i._ZN11TExchngToPC7dis_adcEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.116||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC7dis_adcEv||
                          DCD      0x00000001

                          AREA ||area_number.117||, LINKORDER=||i._ZN11TExchngToPC15en_dma_with_adcEt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.117||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC15en_dma_with_adcEt||
                          DCD      0x00000001

                          AREA ||area_number.118||, LINKORDER=||i._ZN11TExchngToPC6en_adcEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.118||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC6en_adcEv||
                          DCD      0x00000001

                          AREA ||area_number.119||, LINKORDER=||i._ZN11TExchngToPC16deinit_diff_extiEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.119||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC16deinit_diff_extiEv||
                          DCD      0x00000001

                          AREA ||area_number.120||, LINKORDER=||i._ZN11TExchngToPC14init_diff_extiEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.120||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC14init_diff_extiEj||
                          DCD      0x00000001

                          AREA ||area_number.121||, LINKORDER=||i._ZN11TExchngToPC12rx_start_adcEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.121||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC12rx_start_adcEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.122||, LINKORDER=||i._ZN11TExchngToPC14rx_cmp_captureEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.122||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC14rx_cmp_captureEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.123||, LINKORDER=||i._ZN11TExchngToPC13set_diff_freqEt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.123||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC13set_diff_freqEt||
                          DCD      0x00000001

                          AREA ||area_number.124||, LINKORDER=||i._ZN11TExchngToPC15rx_diff_captureEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.124||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC15rx_diff_captureEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.125||, LINKORDER=||i._ZN11TExchngToPC11tx_set_fregEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.125||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC11tx_set_fregEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.126||, LINKORDER=||i._ZN11TExchngToPC17tx_set_duty_cycleEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.126||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC17tx_set_duty_cycleEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.127||, LINKORDER=||i._ZN11TExchngToPC16tx_set_pos_pot_1EPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.127||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC16tx_set_pos_pot_1EPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.128||, LINKORDER=||i._ZN11TExchngToPC16tx_set_pos_pot_2EPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.128||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC16tx_set_pos_pot_2EPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.129||, LINKORDER=||i._ZN11TExchngToPC7tx_testEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.129||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC7tx_testEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.130||, LINKORDER=||i._ZN11TExchngToPC6tx_adcEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.130||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC6tx_adcEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.131||, LINKORDER=||i._ZN11TExchngToPC14tx_cmp_captureEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.131||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC14tx_cmp_captureEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.132||, LINKORDER=||i._ZN11TExchngToPC15tx_diff_captureEPNS_12TParamHandleE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.132||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN11TExchngToPC15tx_diff_captureEPNS_12TParamHandleE||
                          DCD      0x00000001

                          AREA ||area_number.133||, LINKORDER=||i.__sti___19_lev_gauge_to_pc_cpp_UIF||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.133||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___19_lev_gauge_to_pc_cpp_UIF||
                          DCD      0x00000001

                          AREA ||area_number.134||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.134||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24NVIC_GetPriorityGroupingEv||
                          DCD      0x00000001

                          AREA ||area_number.135||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.135||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14NVIC_EnableIRQE9IRQn_Type||
                          DCD      0x00000001

                          AREA ||area_number.136||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_AHB1_GRP1_EnableClockEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.136||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_AHB1_GRP1_EnableClockEj||
                          DCD      0x00000001

                          AREA ||area_number.137||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.137||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_EnableCounterEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.138||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_DisableCounterEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.138||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF21LL_TIM_DisableCounterEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.139||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableARRPreloadEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.139||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableARRPreloadEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.140||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_SetCounterEP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.140||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_SetCounterEP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.141||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.141||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetPrescalerEP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.142||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.142||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_TIM_SetAutoReloadEP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.143||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.143||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_CC_EnableChannelEP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.144||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_OC_ConfigOutputEP11TIM_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.144||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_TIM_OC_ConfigOutputEP11TIM_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.145||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_OC_SetModeEP11TIM_TypeDefjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.145||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF17LL_TIM_OC_SetModeEP11TIM_TypeDefjj||
                          DCD      0x00000001

                          AREA ||area_number.146||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_EnablePreloadEP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.146||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_EnablePreloadEP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.147||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_SetCompareCH1EP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.147||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_OC_SetCompareCH1EP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.148||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.148||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF19LL_TIM_SetSlaveModeEP11TIM_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.149||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableAllOutputsEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.149||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_EnableAllOutputsEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.150||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.150||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.151||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.151||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF26LL_TIM_IsActiveFlag_UPDATEEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.152||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF27LL_TIM_GenerateEvent_UPDATEEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.152||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF27LL_TIM_GenerateEvent_UPDATEEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.153||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14LL_ADC_DisableEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.153||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF14LL_ADC_DisableEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.154||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.154||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF16LL_ADC_IsEnabledEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.155||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_ADC_IsDisableOngoingEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.155||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF23LL_ADC_IsDisableOngoingEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.156||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.156||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF25LL_ADC_REG_StopConversionEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.157||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.157||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_REG_IsConversionOngoingEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.158||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.158||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF34LL_ADC_REG_IsStopConversionOngoingEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.159||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_INJ_IsConversionOngoingEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.159||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF30LL_ADC_INJ_IsConversionOngoingEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.160||, LINKORDER=||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_ADC_ClearFlag_ADRDYEP11ADC_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.160||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF22LL_ADC_ClearFlag_ADRDYEP11ADC_TypeDef||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Data
                          %        30000
                  ExchngToPC
                          %        88

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  CHANNEL_OFFSET_TAB
000000  081c3044          DCB      0x08,0x1c,0x30,0x44
000004  586c80            DCB      0x58,0x6c,0x80
                  OFFSET_TAB_CCMRx
000007  00                DCB      0x00
000008  00000004          DCB      0x00,0x00,0x00,0x04
00000c  04043c3c          DCB      0x04,0x04,0x3c,0x3c
                  SHIFT_TAB_OCxx
000010  00000800          DCB      0x00,0x00,0x08,0x00
000014  00000800          DCB      0x00,0x00,0x08,0x00
000018  08                DCB      0x08
                  SHIFT_TAB_ICxx
000019  000008            DCB      0x00,0x00,0x08
00001c  00000008          DCB      0x00,0x00,0x00,0x08
000020  0000              DCB      0x00,0x00
                  SHIFT_TAB_CCxP
000022  0002              DCB      0x00,0x02
000024  0406080a          DCB      0x04,0x06,0x08,0x0a
000028  0c1014            DCB      0x0c,0x10,0x14
                  SHIFT_TAB_OISx
00002b  00                DCB      0x00
00002c  01020304          DCB      0x01,0x02,0x03,0x04
000030  0506080a          DCB      0x05,0x06,0x08,0x0a
                  DmaAdc
                          DCD      0x40020000
                          DCD      _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF24LL_AHB1_GRP1_EnableClockEj ; [local to lev_gauge_to_pc_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
                          DCD      0x00000001
                          DCD      _ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF20LL_DMA_ClearFlag_TC1EP11DMA_TypeDef ; [local to lev_gauge_to_pc_cpp]::LL_DMA_ClearFlag_TC1(DMA_TypeDef*)
                          DCD      0x00000001
000048  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      ParamHandle
                          DCD      _ZN11TExchngToPC11rx_set_fregEPNS_12TParamHandleE ; TExchngToPC::rx_set_freg(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC11tx_set_fregEPNS_12TParamHandleE ; TExchngToPC::tx_set_freg(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0x18
                          DCD      _ZN11TExchngToPC17rx_set_duty_cycleEPNS_12TParamHandleE ; TExchngToPC::rx_set_duty_cycle(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC17tx_set_duty_cycleEPNS_12TParamHandleE ; TExchngToPC::tx_set_duty_cycle(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0x30
                          DCD      _ZN11TExchngToPC16rx_set_pos_pot_1EPNS_12TParamHandleE ; TExchngToPC::rx_set_pos_pot_1(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC16tx_set_pos_pot_1EPNS_12TParamHandleE ; TExchngToPC::tx_set_pos_pot_1(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0x48
                          DCD      _ZN11TExchngToPC16rx_set_pos_pot_2EPNS_12TParamHandleE ; TExchngToPC::rx_set_pos_pot_2(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC16tx_set_pos_pot_2EPNS_12TParamHandleE ; TExchngToPC::tx_set_pos_pot_2(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0x60
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC7tx_testEPNS_12TParamHandleE ; TExchngToPC::tx_test(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0x78
                          DCD      _ZN11TExchngToPC12rx_start_adcEPNS_12TParamHandleE ; TExchngToPC::rx_start_adc(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC6tx_adcEPNS_12TParamHandleE ; TExchngToPC::tx_adc(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0x90
                          DCD      _ZN11TExchngToPC14rx_cmp_captureEPNS_12TParamHandleE ; TExchngToPC::rx_cmp_capture(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC14tx_cmp_captureEPNS_12TParamHandleE ; TExchngToPC::tx_cmp_capture(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      ParamHandle+0xa8
                          DCD      _ZN11TExchngToPC15rx_diff_captureEPNS_12TParamHandleE ; TExchngToPC::rx_diff_capture(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      _ZN11TExchngToPC15tx_diff_captureEPNS_12TParamHandleE ; TExchngToPC::tx_diff_capture(TExchngToPC::TParamHandle*)
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      Data
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00007530

                          AREA ||.data||, DATA, ALIGN=2

                  TmrHigherPriorityTaskWoken
                          DCD      0x00000000
                  Int1HigherPriorityTaskWoken
                          DCD      0x00000000
                  DmaAdcHigherPriorityTaskWoken
                          DCD      0x00000000
                  TmpParam
                          DCD      0x00000000
                  UIF
000010  0000              DCB      0x00,0x00
                  nCapDiff
000012  0000              DCW      0x0000
                  ParamHandle
000014  66000000          DCB      0x66,0x00,0x00,0x00
000018  43af0000          DCFS     0x43af0000 ; 350
00001c  41200000          DCFS     0x41200000 ; 10
000020  447a0000          DCFS     0x447a0000 ; 1000
                          DCD      ExchngToPC+0x30
000028  04000000          DCB      0x04,0x00,0x00,0x00
00002c  44000000          DCB      0x44,0x00,0x00,0x00
000030  41200000          DCFS     0x41200000 ; 10
000034  00000000          DCFS     0x00000000 ; 0
000038  42c80000          DCFS     0x42c80000 ; 100
                          DCD      ExchngToPC+0x34
000040  04000000          DCB      0x04,0x00,0x00,0x00
000044  50000000          DCB      0x50,0x00,0x00,0x00
000048  00000000          DCFS     0x00000000 ; 0
00004c  00000000          DCFS     0x00000000 ; 0
000050  437f0000          DCFS     0x437f0000 ; 255
                          DCD      ExchngToPC+0x38
000058  01000000          DCB      0x01,0x00,0x00,0x00
00005c  70000000          DCB      0x70,0x00,0x00,0x00
000060  00000000          DCFS     0x00000000 ; 0
000064  00000000          DCFS     0x00000000 ; 0
000068  437f0000          DCFS     0x437f0000 ; 255
                          DCD      ExchngToPC+0x39
000070  01000000          DCB      0x01,0x00,0x00,0x00
000074  54000000          DCB      0x54,0x00,0x00,0x00
000078  00000000          DCFS     0x00000000 ; 0
00007c  00800000          DCFS     0x00800000 ; 1.1754943508222875e-38
000080  7f7fffff          DCFS     0x7f7fffff ; 3.4028234663852886e+38
                          DCD      ExchngToPC+0x3a
000088  01000000          DCB      0x01,0x00,0x00,0x00
00008c  41000000          DCB      0x41,0x00,0x00,0x00
000090  00000000          DCFS     0x00000000 ; 0
000094  3f800000          DCFS     0x3f800000 ; 1
000098  46ea6000          DCFS     0x46ea6000 ; 30000
                          DCD      Data
0000a0  00000000          DCB      0x00,0x00,0x00,0x00
0000a4  43000000          DCB      0x43,0x00,0x00,0x00
0000a8  00000000          DCFS     0x00000000 ; 0
0000ac  00800000          DCFS     0x00800000 ; 1.1754943508222875e-38
0000b0  7f7fffff          DCFS     0x7f7fffff ; 3.4028234663852886e+38
                          DCD      ExchngToPC+0x3a
0000b8  01000000          DCB      0x01,0x00,0x00,0x00
0000bc  64000000          DCB      0x64,0x00,0x00,0x00
0000c0  00000000          DCFS     0x00000000 ; 0
0000c4  3f800000          DCFS     0x3f800000 ; 1
0000c8  47800000          DCFS     0x47800000 ; 65536
                          DCD      ExchngToPC+0x3a
0000d0  01000000          DCB      0x01,0x00,0x00,0x00

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___19_lev_gauge_to_pc_cpp_UIF

;*** Start embedded assembler ***

#line 1 "Source\\Tasks\\src\\lev_gauge_to_pc.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_lev_gauge_to_pc_cpp_UIF___ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF7__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___19_lev_gauge_to_pc_cpp_UIF___ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF7__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_lev_gauge_to_pc_cpp_UIF___ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF7__REVSHEi|
#line 402
|__asm___19_lev_gauge_to_pc_cpp_UIF___ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF7__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_lev_gauge_to_pc_cpp_UIF___ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF5__RRXEj|
#line 587
|__asm___19_lev_gauge_to_pc_cpp_UIF___ZN36_INTERNAL_19_lev_gauge_to_pc_cpp_UIF5__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
