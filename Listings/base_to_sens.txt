; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\base_to_sens.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\base_to_sens.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\base_to_sens.crf Source\Tasks\src\base_to_sens.cpp]
                          THUMB

                          AREA ||i._Z12base_to_sensPv||, CODE, READONLY, ALIGN=2

                  _Z12base_to_sensPv PROC ; base_to_sens(void*)
;;;22     //----- Задача RTOS -------------------------------------------------------------------------------------------------
;;;23     void base_to_sens( void *Params ) //обмен базы с датчиком; только для базы; запросы от базы к датчику
000000  b08e              SUB      sp,sp,#0x38
;;;24     {
;;;25       constexpr uint16_t DLY_MS = 5U;
000002  bf00              NOP      
;;;26     
;;;27       if ( Model.get_dev_type() != TModel::TDevType::_BASE )
000004  4830              LDR      r0,|L1.200|
000006  f7fffffe          BL       _ZN6TModel12get_dev_typeEv ; TModel::get_dev_type()
00000a  b128              CBZ      r0,|L1.24|
;;;28       {
;;;29         for ( ;; )
00000c  bf00              NOP      
                  |L1.14|
;;;30         {
;;;31           vTaskDelay( pdMS_TO_TICKS( DLY_MS * 200U ) );
00000e  f44f707a          MOV      r0,#0x3e8
000012  f7fffffe          BL       vTaskDelay
000016  e7fa              B        |L1.14|
                  |L1.24|
;;;32         }
;;;33       }
;;;34     
;;;35       BaseToSens.StrIx = static_cast<uint8_t>( Model.get_dev_type() );
000018  482b              LDR      r0,|L1.200|
00001a  f7fffffe          BL       _ZN6TModel12get_dev_typeEv ; TModel::get_dev_type()
00001e  492b              LDR      r1,|L1.204|
000020  f8810227          STRB     r0,[r1,#0x227]
;;;36       BaseToSens.pin_clk_config();
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       _ZN6TUsart14pin_clk_configEv ; TUsart::pin_clk_config()
;;;37     
;;;38       //в объекте до аппаратной инициализации настройки по умолчанию
;;;39       //для обмена БАЗА<->ДАТЧИК, настройки usart неизменны
;;;40       BaseToSens.set_addr( TModbusApp::BASE_TO_SENS_MB_ADDR );
00002a  218f              MOVS     r1,#0x8f
00002c  4827              LDR      r0,|L1.204|
00002e  f7fffffe          BL       _ZN11TModbusLink8set_addrEh ; TModbusLink::set_addr(unsigned char)
;;;41       
;;;42       TModbusApp::TSets IfSets{ 
000032  4a27              LDR      r2,|L1.208|
000034  e9d21000          LDRD     r1,r0,[r2,#0]
000038  6892              LDR      r2,[r2,#8]  ; <Data1>
00003a  e9cd020c          STRD     r0,r2,[sp,#0x30]
00003e  910b              STR      r1,[sp,#0x2c]
;;;43                                TModbusApp::TBaudRate::_115200, 
;;;44                                TModbusApp::TParity::_EVEN, 
;;;45                                TModbusApp::TStops::_STOPBITS_1
;;;46                               };
;;;47       
;;;48       BaseToSens.set_sets( IfSets ); //usart отключается, переинициализируется и включается
000040  a90b              ADD      r1,sp,#0x2c
000042  4822              LDR      r0,|L1.204|
000044  f7fffffe          BL       _ZN6TUsart8set_setsERKNS_5TSetsE ; TUsart::set_sets(const TUsart::TSets&)
;;;49       
;;;50     //  BaseToSens.hw_init( TModbusLink::_1_5_CH_BITS_NBR );
;;;51       BaseToSens.init_dma();
000048  4820              LDR      r0,|L1.204|
00004a  f7fffffe          BL       _ZN11TModbusLink8init_dmaEv ; TModbusLink::init_dma()
;;;52       
;;;53       xTimerStart( PdTmr, 0U );
00004e  f7fffffe          BL       xTaskGetTickCount
000052  4604              MOV      r4,r0
000054  2000              MOVS     r0,#0
000056  4603              MOV      r3,r0
000058  4622              MOV      r2,r4
00005a  2101              MOVS     r1,#1
00005c  9000              STR      r0,[sp,#0]
00005e  481d              LDR      r0,|L1.212|
000060  6800              LDR      r0,[r0,#0]  ; PdTmr
000062  f7fffffe          BL       xTimerGenericCommand
;;;54       
;;;55       for ( ;; )
000066  bf00              NOP      
                  |L1.104|
;;;56       {
;;;57         
;;;58         //опрос семафоров \
;;;59           от результата опроса зависит запрос, который необходимо сформировать.
;;;60         //последовательность выдачи семафоров всегда одинакова: \
;;;61           1. семафор запуска измерений - DevSensStartSem \
;;;62           2. семафор считывания данных по окончании измерений DevSensResSem
;;;63         
;;;64         typedef void (*TFnct)();
;;;65         
;;;66         struct TReq
;;;67         {
;;;68           SemaphoreHandle_t *Sem;
;;;69           TFnct Fnct;
;;;70         };
;;;71         
;;;72         TReq Req[] =
000068  2220              MOVS     r2,#0x20
00006a  4919              LDR      r1,|L1.208|
00006c  310c              ADDS     r1,r1,#0xc
00006e  a803              ADD      r0,sp,#0xc
000070  f7fffffe          BL       __aeabi_memcpy4
;;;73         {
;;;74           {
;;;75             &DevSensStartSem,
;;;76             acc_rdy,
;;;77           },
;;;78           {
;;;79             &DevSensResSem,
;;;80             read_meas,
;;;81           },
;;;82           {
;;;83             &PdSem,
;;;84             pd_poll,
;;;85           },
;;;86           {
;;;87             &SensWrAxisRotateSem,
;;;88             wr_axis_rotate,
;;;89           },
;;;90         };
;;;91         
;;;92         for ( auto item : Req )
000074  ad03              ADD      r5,sp,#0xc
000076  462c              MOV      r4,r5
000078  f1050620          ADD      r6,r5,#0x20
00007c  e01d              B        |L1.186|
                  |L1.126|
00007e  e9d40100          LDRD     r0,r1,[r4,#0]
000082  e9cd0101          STRD     r0,r1,[sp,#4]
;;;93         {
;;;94           if ( xSemaphoreTake( *item.Sem, 0U ) == pdPASS )
000086  9901              LDR      r1,[sp,#4]
000088  2300              MOVS     r3,#0
00008a  461a              MOV      r2,r3
00008c  6808              LDR      r0,[r1,#0]
00008e  4619              MOV      r1,r3
000090  f7fffffe          BL       xQueueGenericReceive
000094  2801              CMP      r0,#1
000096  d10f              BNE      |L1.184|
;;;95           {
;;;96             item.Fnct();
000098  9802              LDR      r0,[sp,#8]
00009a  4780              BLX      r0
;;;97           
;;;98             BaseToSens.State = TModbusApp::TState::__IDLE;    
00009c  2000              MOVS     r0,#0
00009e  490b              LDR      r1,|L1.204|
0000a0  f8810230          STRB     r0,[r1,#0x230]
;;;99             
;;;100            do
0000a4  bf00              NOP      
                  |L1.166|
;;;101            {
;;;102              BaseToSens.fsm();
0000a6  4809              LDR      r0,|L1.204|
0000a8  f7fffffe          BL       _ZN10TModbusApp3fsmEv ; TModbusApp::fsm()
;;;103            } while ( BaseToSens.State != TModbusApp::TState::__IDLE );
0000ac  4807              LDR      r0,|L1.204|
0000ae  f8900230          LDRB     r0,[r0,#0x230]  ; BaseToSens
0000b2  2800              CMP      r0,#0
0000b4  d1f7              BNE      |L1.166|
;;;104            
;;;105            break;
0000b6  e002              B        |L1.190|
                  |L1.184|
0000b8  3408              ADDS     r4,r4,#8
                  |L1.186|
0000ba  42b4              CMP      r4,r6
0000bc  d1df              BNE      |L1.126|
                  |L1.190|
0000be  bf00              NOP      
;;;106          }
;;;107        }
;;;108        
;;;109        vTaskDelay( pdMS_TO_TICKS( DLY_MS ) );  
0000c0  2005              MOVS     r0,#5
0000c2  f7fffffe          BL       vTaskDelay
;;;110      }
0000c6  e7cf              B        |L1.104|
;;;111    }
;;;112    //\---- Задача RTOS -------------------------------------------------------------------------------------------------
                          ENDP

                  |L1.200|
                          DCD      Model
                  |L1.204|
                          DCD      BaseToSens
                  |L1.208|
                          DCD      ||.constdata||
                  |L1.212|
                          DCD      PdTmr

                          AREA ||i._Z6pd_tmrPv||, CODE, READONLY, ALIGN=1

                  _Z6pd_tmrPv PROC ; pd_tmr(void*)
;;;343      Параметры: 115200, 8E1, 4, 1016 (float)
;;;344    void pd_tmr( TimerHandle_t xTimer ) //обработка таймера кодового переключателя
000000  4770              BX       lr
;;;345    {
;;;346    //  xSemaphoreGive(PdSem);
;;;347    }
                          ENDP


                          AREA ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba6814wr_axis_rotateEv||, CODE, READONLY, ALIGN=2

                  _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba6814wr_axis_rotateEv PROC ; [local to base_to_sens_cpp]::wr_axis_rotate()
;;;113    
;;;114    static void wr_axis_rotate()
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;115    {
;;;116      //формирование запроса на запись регистра
;;;117      auto beg = &BaseToSens.PduHandler->Buf[ 0 ];
000004  4831              LDR      r0,|L3.204|
000006  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
00000a  f8d09000          LDR      r9,[r0,#0]
;;;118    	auto end = &BaseToSens.PduHandler->Buf[ BaseToSens.PduHandler->BUF_SIZE ];
00000e  482f              LDR      r0,|L3.204|
000010  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
000014  6800              LDR      r0,[r0,#0]
000016  492d              LDR      r1,|L3.204|
000018  f8d11238          LDR      r1,[r1,#0x238]  ; BaseToSens
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001601          ADD      r6,r0,r1,LSL #4
;;;119      
;;;120    //  Do.open();
;;;121      
;;;122      TModbusApp::TPDU *PDU =
000022  4648              MOV      r0,r9
000024  4631              MOV      r1,r6
000026  e000              B        |L3.42|
                  |L3.40|
000028  3010              ADDS     r0,r0,#0x10
                  |L3.42|
00002a  4288              CMP      r0,r1
00002c  d019              BEQ      |L3.98|
00002e  e9d02702          LDRD     r2,r7,[r0,#8]
000032  e9d03500          LDRD     r3,r5,[r0,#0]
000036  e9cd2702          STRD     r2,r7,[sp,#8]
00003a  e9cd3500          STRD     r3,r5,[sp,#0]
;;;123      std::find_if( beg, end, []( TModbusApp::TPDU item ){
;;;124        return ( item.Fnct == &TModbusApp::my_write_sens_axis_rotate );
00003e  4b24              LDR      r3,|L3.208|
000040  9a02              LDR      r2,[sp,#8]
000042  429a              CMP      r2,r3
000044  d10a              BNE      |L3.92|
000046  461a              MOV      r2,r3
000048  b922              CBNZ     r2,|L3.84|
00004a  f89d200c          LDRB     r2,[sp,#0xc]
00004e  f0020201          AND      r2,r2,#1
000052  b10a              CBZ      r2,|L3.88|
                  |L3.84|
000054  9a03              LDR      r2,[sp,#0xc]
000056  b90a              CBNZ     r2,|L3.92|
                  |L3.88|
000058  2201              MOVS     r2,#1
00005a  e000              B        |L3.94|
                  |L3.92|
00005c  2200              MOVS     r2,#0
                  |L3.94|
00005e  2a00              CMP      r2,#0
000060  d0e2              BEQ      |L3.40|
                  |L3.98|
000062  4604              MOV      r4,r0                 ;122
;;;125      } );
;;;126      
;;;127      if ( PDU == end )
000064  42b4              CMP      r4,r6
000066  d02e              BEQ      |L3.198|
;;;128      {
;;;129      
;;;130      }
;;;131      else
;;;132      {
;;;133        //Пакет запроса, функция 6    
;;;134        __packed struct TBase
;;;135        {
;;;136          uint8_t Addr;
;;;137          uint8_t FnctCode;
;;;138          TModbusApp::THalfWordParse RegAddr;
;;;139          TModbusApp::THalfWordParse NewVal;
;;;140        };
;;;141        
;;;142        __packed struct TReqWrSingleReg
;;;143        {
;;;144          TBase Base;
;;;145          uint16_t Crc;
;;;146        };
;;;147        
;;;148        TReqWrSingleReg *ReqPkt         = reinterpret_cast<TReqWrSingleReg *>(BaseToSens.TxBuf);
000068  4d1a              LDR      r5,|L3.212|
;;;149        ReqPkt->Base.Addr               = BaseToSens.get_addr();
00006a  4818              LDR      r0,|L3.204|
00006c  f7fffffe          BL       _ZN11TModbusLink8get_addrEv ; TModbusLink::get_addr()
000070  7028              STRB     r0,[r5,#0]
;;;150        ReqPkt->Base.FnctCode           = PDU->FnctNbr;
000072  7820              LDRB     r0,[r4,#0]
000074  7068              STRB     r0,[r5,#1]
;;;151        ReqPkt->Base.RegAddr.Segment.Lo = (( TModbusApp::TLittleEndian *)&PDU->RegAddr)->Segment.Lo;
000076  78a1              LDRB     r1,[r4,#2]
000078  70e9              STRB     r1,[r5,#3]
;;;152        ReqPkt->Base.RegAddr.Segment.Hi = (( TModbusApp::TLittleEndian *)&PDU->RegAddr)->Segment.Hi;
00007a  78e0              LDRB     r0,[r4,#3]
00007c  70a8              STRB     r0,[r5,#2]
;;;153         
;;;154        int16_t Data = 0; //признак передачи
00007e  2000              MOVS     r0,#0
000080  9003              STR      r0,[sp,#0xc]
;;;155        
;;;156        ( BaseToSens.*(PDU->Fnct) )( reinterpret_cast<uint32_t>(&Data) );
000082  f5057092          ADD      r0,r5,#0x124
000086  68e1              LDR      r1,[r4,#0xc]
000088  eb000761          ADD      r7,r0,r1,ASR #1
00008c  7b20              LDRB     r0,[r4,#0xc]
00008e  f0000001          AND      r0,r0,#1
000092  b908              CBNZ     r0,|L3.152|
000094  68a0              LDR      r0,[r4,#8]
000096  e005              B        |L3.164|
                  |L3.152|
000098  6838              LDR      r0,[r7,#0]
00009a  68a1              LDR      r1,[r4,#8]
00009c  eb000801          ADD      r8,r0,r1
0000a0  f8d80000          LDR      r0,[r8,#0]
                  |L3.164|
0000a4  4682              MOV      r10,r0
0000a6  a903              ADD      r1,sp,#0xc
0000a8  4638              MOV      r0,r7
0000aa  47d0              BLX      r10
;;;157        ReqPkt->Base.NewVal.Val = Data;
0000ac  f8bd000c          LDRH     r0,[sp,#0xc]
0000b0  80a8              STRH     r0,[r5,#4]
;;;158        ReqPkt->Crc             = CRC16( BaseToSens.TxBuf, sizeof ( TBase ) );
0000b2  2106              MOVS     r1,#6
0000b4  4807              LDR      r0,|L3.212|
0000b6  f7fffffe          BL       CRC16
0000ba  80e8              STRH     r0,[r5,#6]
;;;159        
;;;160        BaseToSens.start_transmit( sizeof ( TReqWrSingleReg ) );
0000bc  2108              MOVS     r1,#8
0000be  4803              LDR      r0,|L3.204|
0000c0  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
;;;161    //    Do.closed();
;;;162      }
0000c4  bf00              NOP      
                  |L3.198|
;;;163    }
0000c6  e8bd87ff          POP      {r0-r10,pc}
;;;164    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L3.204|
                          DCD      BaseToSens
                  |L3.208|
                          DCD      _ZN12TDevHandlers25my_write_sens_axis_rotateEj ; TDevHandlers::my_write_sens_axis_rotate(unsigned)
                  |L3.212|
                          DCD      BaseToSens+0x114

                          AREA ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687acc_rdyEv||, CODE, READONLY, ALIGN=2

                  _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687acc_rdyEv PROC ; [local to base_to_sens_cpp]::acc_rdy()
;;;164    
;;;165    static void acc_rdy()
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;166    {
;;;167      //формирование запроса на запуск измерений
;;;168      auto beg = &BaseToSens.PduHandler->Buf[ 0 ];
000004  4831              LDR      r0,|L4.204|
000006  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
00000a  f8d09000          LDR      r9,[r0,#0]
;;;169    	auto end = &BaseToSens.PduHandler->Buf[ BaseToSens.PduHandler->BUF_SIZE ];
00000e  482f              LDR      r0,|L4.204|
000010  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
000014  6800              LDR      r0,[r0,#0]
000016  492d              LDR      r1,|L4.204|
000018  f8d11238          LDR      r1,[r1,#0x238]  ; BaseToSens
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001601          ADD      r6,r0,r1,LSL #4
;;;170      
;;;171    //  Do.open();
;;;172      
;;;173      TModbusApp::TPDU *PDU =
000022  4648              MOV      r0,r9
000024  4631              MOV      r1,r6
000026  e000              B        |L4.42|
                  |L4.40|
000028  3010              ADDS     r0,r0,#0x10
                  |L4.42|
00002a  4288              CMP      r0,r1
00002c  d019              BEQ      |L4.98|
00002e  e9d02702          LDRD     r2,r7,[r0,#8]
000032  e9d03500          LDRD     r3,r5,[r0,#0]
000036  e9cd2702          STRD     r2,r7,[sp,#8]
00003a  e9cd3500          STRD     r3,r5,[sp,#0]
;;;174      std::find_if( beg, end, []( TModbusApp::TPDU item ){
;;;175        return ( item.Fnct == &TModbusApp::my_write_start_meas_cmd );
00003e  4b24              LDR      r3,|L4.208|
000040  9a02              LDR      r2,[sp,#8]
000042  429a              CMP      r2,r3
000044  d10a              BNE      |L4.92|
000046  461a              MOV      r2,r3
000048  b922              CBNZ     r2,|L4.84|
00004a  f89d200c          LDRB     r2,[sp,#0xc]
00004e  f0020201          AND      r2,r2,#1
000052  b10a              CBZ      r2,|L4.88|
                  |L4.84|
000054  9a03              LDR      r2,[sp,#0xc]
000056  b90a              CBNZ     r2,|L4.92|
                  |L4.88|
000058  2201              MOVS     r2,#1
00005a  e000              B        |L4.94|
                  |L4.92|
00005c  2200              MOVS     r2,#0
                  |L4.94|
00005e  2a00              CMP      r2,#0
000060  d0e2              BEQ      |L4.40|
                  |L4.98|
000062  4604              MOV      r4,r0                 ;173
;;;176      } );
;;;177      
;;;178      if ( PDU == end )
000064  42b4              CMP      r4,r6
000066  d02e              BEQ      |L4.198|
;;;179      {
;;;180      
;;;181      }
;;;182      else
;;;183      {
;;;184        //Пакет запроса, функция 5    
;;;185        __packed struct TBase
;;;186        {
;;;187          uint8_t Addr;
;;;188          uint8_t FnctCode;
;;;189          TModbusApp::THalfWordParse RegAddr;
;;;190          TModbusApp::THalfWordParse NewState;
;;;191        };
;;;192        
;;;193        __packed struct TReqWrSingleCoil
;;;194        {
;;;195          TBase Base;
;;;196          uint16_t Crc;
;;;197        };
;;;198        
;;;199        TReqWrSingleCoil *ReqPkt        = reinterpret_cast<TReqWrSingleCoil *>(BaseToSens.TxBuf);
000068  4d1a              LDR      r5,|L4.212|
;;;200        ReqPkt->Base.Addr               = BaseToSens.get_addr();
00006a  4818              LDR      r0,|L4.204|
00006c  f7fffffe          BL       _ZN11TModbusLink8get_addrEv ; TModbusLink::get_addr()
000070  7028              STRB     r0,[r5,#0]
;;;201        ReqPkt->Base.FnctCode           = PDU->FnctNbr;
000072  7820              LDRB     r0,[r4,#0]
000074  7068              STRB     r0,[r5,#1]
;;;202        ReqPkt->Base.RegAddr.Segment.Lo = (( TModbusApp::TLittleEndian *)&PDU->RegAddr)->Segment.Lo;
000076  78a1              LDRB     r1,[r4,#2]
000078  70e9              STRB     r1,[r5,#3]
;;;203        ReqPkt->Base.RegAddr.Segment.Hi = (( TModbusApp::TLittleEndian *)&PDU->RegAddr)->Segment.Hi;
00007a  78e0              LDRB     r0,[r4,#3]
00007c  70a8              STRB     r0,[r5,#2]
;;;204         
;;;205        int16_t Data = 0; //признак передачи
00007e  2000              MOVS     r0,#0
000080  9003              STR      r0,[sp,#0xc]
;;;206        
;;;207        ( BaseToSens.*(PDU->Fnct) )( reinterpret_cast<uint32_t>(&Data) );
000082  f5057092          ADD      r0,r5,#0x124
000086  68e1              LDR      r1,[r4,#0xc]
000088  eb000761          ADD      r7,r0,r1,ASR #1
00008c  7b20              LDRB     r0,[r4,#0xc]
00008e  f0000001          AND      r0,r0,#1
000092  b908              CBNZ     r0,|L4.152|
000094  68a0              LDR      r0,[r4,#8]
000096  e005              B        |L4.164|
                  |L4.152|
000098  6838              LDR      r0,[r7,#0]
00009a  68a1              LDR      r1,[r4,#8]
00009c  eb000801          ADD      r8,r0,r1
0000a0  f8d80000          LDR      r0,[r8,#0]
                  |L4.164|
0000a4  4682              MOV      r10,r0
0000a6  a903              ADD      r1,sp,#0xc
0000a8  4638              MOV      r0,r7
0000aa  47d0              BLX      r10
;;;208        ReqPkt->Base.NewState.Val = Data;
0000ac  f8bd000c          LDRH     r0,[sp,#0xc]
0000b0  80a8              STRH     r0,[r5,#4]
;;;209        ReqPkt->Crc               = CRC16( BaseToSens.TxBuf, sizeof ( TBase ) );
0000b2  2106              MOVS     r1,#6
0000b4  4807              LDR      r0,|L4.212|
0000b6  f7fffffe          BL       CRC16
0000ba  80e8              STRH     r0,[r5,#6]
;;;210        
;;;211        BaseToSens.start_transmit( sizeof ( TReqWrSingleCoil ) );
0000bc  2108              MOVS     r1,#8
0000be  4803              LDR      r0,|L4.204|
0000c0  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
;;;212    //    Do.closed();
;;;213      }
0000c4  bf00              NOP      
                  |L4.198|
;;;214    }
0000c6  e8bd87ff          POP      {r0-r10,pc}
;;;215    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L4.204|
                          DCD      BaseToSens
                  |L4.208|
                          DCD      _ZN12TDevHandlers23my_write_start_meas_cmdEj ; TDevHandlers::my_write_start_meas_cmd(unsigned)
                  |L4.212|
                          DCD      BaseToSens+0x114

                          AREA ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687pd_pollEv||, CODE, READONLY, ALIGN=2

                  _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687pd_pollEv PROC ; [local to base_to_sens_cpp]::pd_poll()
;;;278    
;;;279    static void pd_poll()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;280    {
000004  b088              SUB      sp,sp,#0x20
;;;281      //формирование запроса считывания данных по окончании измерений
;;;282      auto beg = &BaseToSens.PduHandler->Buf[ 0 ];
000006  4834              LDR      r0,|L5.216|
000008  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
00000c  6807              LDR      r7,[r0,#0]
;;;283    	auto end = &BaseToSens.PduHandler->Buf[ BaseToSens.PduHandler->BUF_SIZE ];
00000e  4832              LDR      r0,|L5.216|
000010  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
000014  6800              LDR      r0,[r0,#0]
000016  4930              LDR      r1,|L5.216|
000018  f8d11238          LDR      r1,[r1,#0x238]  ; BaseToSens
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001601          ADD      r6,r0,r1,LSL #4
;;;284    
;;;285      //поиск первого элемента массива с функцией 3
;;;286      //в массиве по которому осуществляется поиск, адреса регистров должны быть соседними, \
;;;287        сами элементы массива также должны быть соседними
;;;288      TModbusApp::TPDU *PDU =
000022  4638              MOV      r0,r7
000024  4631              MOV      r1,r6
000026  e000              B        |L5.42|
                  |L5.40|
000028  3010              ADDS     r0,r0,#0x10
                  |L5.42|
00002a  4288              CMP      r0,r1
00002c  d00d              BEQ      |L5.74|
00002e  e890101c          LDM      r0,{r2-r4,r12}
000032  ad04              ADD      r5,sp,#0x10
000034  e8a5101c          STM      r5!,{r2-r4,r12}
;;;289      std::find_if( beg, end, []( TModbusApp::TPDU item ){
;;;290        return ( item.FnctNbr == TModbusApp::TMbFnct::__READ_HOLDING_REGISTERS );
000038  f89d2010          LDRB     r2,[sp,#0x10]
00003c  2a03              CMP      r2,#3
00003e  d101              BNE      |L5.68|
000040  2201              MOVS     r2,#1
000042  e000              B        |L5.70|
                  |L5.68|
000044  2200              MOVS     r2,#0
                  |L5.70|
000046  2a00              CMP      r2,#0
000048  d0ee              BEQ      |L5.40|
                  |L5.74|
00004a  4605              MOV      r5,r0                 ;288
;;;291      } );
;;;292      
;;;293      if ( PDU == end )
00004c  42b5              CMP      r5,r6
00004e  d040              BEQ      |L5.210|
;;;294      {
;;;295    
;;;296      }
;;;297      else
;;;298      {
;;;299        //регистр/ы с требуемой функцией существуют/ет
;;;300        //необходимо найти их количество    
;;;301        uint16_t RegsQty = 0U;
000050  2000              MOVS     r0,#0
000052  9006              STR      r0,[sp,#0x18]
;;;302        std::for_each( beg, end, [ &RegsQty ]( TModbusApp::TPDU item ) {
000054  4638              MOV      r0,r7
000056  4631              MOV      r1,r6
000058  aa06              ADD      r2,sp,#0x18
00005a  9207              STR      r2,[sp,#0x1c]
00005c  9204              STR      r2,[sp,#0x10]
00005e  e012              B        |L5.134|
                  |L5.96|
000060  e890100c          LDM      r0,{r2,r3,r12}
000064  f8d0800c          LDR      r8,[r0,#0xc]
000068  e88d100c          STM      sp,{r2,r3,r12}
00006c  f8cd800c          STR      r8,[sp,#0xc]
;;;303          if ( item.FnctNbr == TModbusApp::TMbFnct::__READ_HOLDING_REGISTERS )
000070  f89d2000          LDRB     r2,[sp,#0]
000074  2a03              CMP      r2,#3
000076  d104              BNE      |L5.130|
;;;304          {
;;;305            ++RegsQty;
000078  9a04              LDR      r2,[sp,#0x10]
00007a  8812              LDRH     r2,[r2,#0]
00007c  1c52              ADDS     r2,r2,#1
00007e  9b04              LDR      r3,[sp,#0x10]
000080  801a              STRH     r2,[r3,#0]
                  |L5.130|
;;;306          }
;;;307        } );  
000082  bf00              NOP      
000084  3010              ADDS     r0,r0,#0x10
                  |L5.134|
000086  4288              CMP      r0,r1
000088  d1ea              BNE      |L5.96|
00008a  9a04              LDR      r2,[sp,#0x10]         ;302
00008c  9205              STR      r2,[sp,#0x14]         ;302
;;;308      
;;;309        //Пакет запроса, функция 3
;;;310        
;;;311        __packed struct TBase
;;;312        {
;;;313          uint8_t Addr;
;;;314          uint8_t FnctCode;
;;;315          TModbusApp::THalfWordParse StartRegAddr;
;;;316          TModbusApp::THalfWordParse RegsQty;
;;;317        };
;;;318        
;;;319        __packed struct TReqRdInputRegs
;;;320        {
;;;321          TBase Base;
;;;322          uint16_t Crc;
;;;323        };
;;;324    
;;;325        TReqRdInputRegs *ReqPkt              = reinterpret_cast<TReqRdInputRegs *>(BaseToSens.TxBuf);
00008e  4c13              LDR      r4,|L5.220|
;;;326        ReqPkt->Base.Addr                    = 4U;
000090  2004              MOVS     r0,#4
000092  7020              STRB     r0,[r4,#0]
;;;327        ReqPkt->Base.FnctCode                = PDU->FnctNbr;
000094  7828              LDRB     r0,[r5,#0]
000096  7060              STRB     r0,[r4,#1]
;;;328        BaseToSens.m3RegInfo.StartAddr        = PDU->RegAddr;
000098  8868              LDRH     r0,[r5,#2]
00009a  490f              LDR      r1,|L5.216|
00009c  f8a10256          STRH     r0,[r1,#0x256]
;;;329        BaseToSens.m3RegInfo.Qty              = RegsQty;
0000a0  f8bd1018          LDRH     r1,[sp,#0x18]
0000a4  480c              LDR      r0,|L5.216|
0000a6  f8a01258          STRH     r1,[r0,#0x258]
;;;330        
;;;331        ReqPkt->Base.StartRegAddr.Segment.Lo = (( TModbusApp::TLittleEndian * )&PDU->RegAddr)->Segment.Lo;
0000aa  78a9              LDRB     r1,[r5,#2]
0000ac  70e1              STRB     r1,[r4,#3]
;;;332        ReqPkt->Base.StartRegAddr.Segment.Hi = (( TModbusApp::TLittleEndian * )&PDU->RegAddr)->Segment.Hi;
0000ae  78e8              LDRB     r0,[r5,#3]
0000b0  70a0              STRB     r0,[r4,#2]
;;;333        ReqPkt->Base.RegsQty.Segment.Lo      = (( TModbusApp::TLittleEndian * )&RegsQty)->Segment.Lo;
0000b2  f89d1018          LDRB     r1,[sp,#0x18]
0000b6  7161              STRB     r1,[r4,#5]
;;;334        ReqPkt->Base.RegsQty.Segment.Hi      = (( TModbusApp::TLittleEndian * )&RegsQty)->Segment.Hi;
0000b8  f89d0019          LDRB     r0,[sp,#0x19]
0000bc  7120              STRB     r0,[r4,#4]
;;;335        
;;;336        ReqPkt->Crc                          = CRC16( BaseToSens.TxBuf, sizeof ( TBase ) );
0000be  2106              MOVS     r1,#6
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       CRC16
0000c6  80e0              STRH     r0,[r4,#6]
;;;337    
;;;338        BaseToSens.start_transmit( sizeof ( TReqRdInputRegs ) );
0000c8  2108              MOVS     r1,#8
0000ca  4803              LDR      r0,|L5.216|
0000cc  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
;;;339      }
0000d0  bf00              NOP      
                  |L5.210|
;;;340    }
0000d2  b008              ADD      sp,sp,#0x20
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;341    
                          ENDP

                  |L5.216|
                          DCD      BaseToSens
                  |L5.220|
                          DCD      BaseToSens+0x114

                          AREA ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba689read_measEv||, CODE, READONLY, ALIGN=2

                  _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba689read_measEv PROC ; [local to base_to_sens_cpp]::read_meas()
;;;215    
;;;216    static void read_meas()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;217    {
000004  b088              SUB      sp,sp,#0x20
;;;218      //формирование запроса считывания данных по окончании измерений
;;;219      auto beg = &BaseToSens.PduHandler->Buf[ 0 ];
000006  4835              LDR      r0,|L6.220|
000008  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
00000c  6807              LDR      r7,[r0,#0]
;;;220    	auto end = &BaseToSens.PduHandler->Buf[ BaseToSens.PduHandler->BUF_SIZE ];
00000e  4833              LDR      r0,|L6.220|
000010  f8d00238          LDR      r0,[r0,#0x238]  ; BaseToSens
000014  6800              LDR      r0,[r0,#0]
000016  4931              LDR      r1,|L6.220|
000018  f8d11238          LDR      r1,[r1,#0x238]  ; BaseToSens
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001601          ADD      r6,r0,r1,LSL #4
;;;221    
;;;222      //поиск первого элемента массива с функцией 4
;;;223      //в массиве по которому осуществляется поиск, адреса регистров должны быть соседними, \
;;;224        сами элементы массива также должны быть соседними
;;;225      TModbusApp::TPDU *PDU =
000022  4638              MOV      r0,r7
000024  4631              MOV      r1,r6
000026  e000              B        |L6.42|
                  |L6.40|
000028  3010              ADDS     r0,r0,#0x10
                  |L6.42|
00002a  4288              CMP      r0,r1
00002c  d00d              BEQ      |L6.74|
00002e  e890101c          LDM      r0,{r2-r4,r12}
000032  ad04              ADD      r5,sp,#0x10
000034  e8a5101c          STM      r5!,{r2-r4,r12}
;;;226      std::find_if( beg, end, []( TModbusApp::TPDU item ){
;;;227        return ( item.FnctNbr == TModbusApp::TMbFnct::__READ_INPUT_REGISTERS );
000038  f89d2010          LDRB     r2,[sp,#0x10]
00003c  2a04              CMP      r2,#4
00003e  d101              BNE      |L6.68|
000040  2201              MOVS     r2,#1
000042  e000              B        |L6.70|
                  |L6.68|
000044  2200              MOVS     r2,#0
                  |L6.70|
000046  2a00              CMP      r2,#0
000048  d0ee              BEQ      |L6.40|
                  |L6.74|
00004a  4605              MOV      r5,r0                 ;225
;;;228      } );
;;;229      
;;;230      if ( PDU == end )
00004c  42b5              CMP      r5,r6
00004e  d042              BEQ      |L6.214|
;;;231      {
;;;232    
;;;233      }
;;;234      else
;;;235      {
;;;236        //регистр/ы с требуемой функцией существуют/ет
;;;237        //необходимо найти их количество    
;;;238        uint16_t RegsQty = 0U;
000050  2000              MOVS     r0,#0
000052  9006              STR      r0,[sp,#0x18]
;;;239        std::for_each( beg, end, [ &RegsQty ]( TModbusApp::TPDU item ) {
000054  4638              MOV      r0,r7
000056  4631              MOV      r1,r6
000058  aa06              ADD      r2,sp,#0x18
00005a  9207              STR      r2,[sp,#0x1c]
00005c  9204              STR      r2,[sp,#0x10]
00005e  e012              B        |L6.134|
                  |L6.96|
000060  e890100c          LDM      r0,{r2,r3,r12}
000064  f8d0800c          LDR      r8,[r0,#0xc]
000068  e88d100c          STM      sp,{r2,r3,r12}
00006c  f8cd800c          STR      r8,[sp,#0xc]
;;;240          if ( item.FnctNbr == TModbusApp::TMbFnct::__READ_INPUT_REGISTERS )
000070  f89d2000          LDRB     r2,[sp,#0]
000074  2a04              CMP      r2,#4
000076  d104              BNE      |L6.130|
;;;241          {
;;;242            ++RegsQty;
000078  9a04              LDR      r2,[sp,#0x10]
00007a  8812              LDRH     r2,[r2,#0]
00007c  1c52              ADDS     r2,r2,#1
00007e  9b04              LDR      r3,[sp,#0x10]
000080  801a              STRH     r2,[r3,#0]
                  |L6.130|
;;;243          }
;;;244        } );  
000082  bf00              NOP      
000084  3010              ADDS     r0,r0,#0x10
                  |L6.134|
000086  4288              CMP      r0,r1
000088  d1ea              BNE      |L6.96|
00008a  9a04              LDR      r2,[sp,#0x10]         ;239
00008c  9205              STR      r2,[sp,#0x14]         ;239
;;;245      
;;;246        //Пакет запроса, функция 4
;;;247        
;;;248        __packed struct TBase
;;;249        {
;;;250          uint8_t Addr;
;;;251          uint8_t FnctCode;
;;;252          TModbusApp::THalfWordParse StartRegAddr;
;;;253          TModbusApp::THalfWordParse RegsQty;
;;;254        };
;;;255        
;;;256        __packed struct TReqRdInputRegs
;;;257        {
;;;258          TBase Base;
;;;259          uint16_t Crc;
;;;260        };
;;;261    
;;;262        TReqRdInputRegs *ReqPkt              = reinterpret_cast<TReqRdInputRegs *>(BaseToSens.TxBuf);
00008e  4c14              LDR      r4,|L6.224|
;;;263        ReqPkt->Base.Addr                    = BaseToSens.get_addr();
000090  4812              LDR      r0,|L6.220|
000092  f7fffffe          BL       _ZN11TModbusLink8get_addrEv ; TModbusLink::get_addr()
000096  7020              STRB     r0,[r4,#0]
;;;264        ReqPkt->Base.FnctCode                = PDU->FnctNbr;
000098  7828              LDRB     r0,[r5,#0]
00009a  7060              STRB     r0,[r4,#1]
;;;265        BaseToSens.m4RegInfo.StartAddr        = PDU->RegAddr;
00009c  8868              LDRH     r0,[r5,#2]
00009e  490f              LDR      r1,|L6.220|
0000a0  f8a1025a          STRH     r0,[r1,#0x25a]
;;;266        BaseToSens.m4RegInfo.Qty              = RegsQty;
0000a4  f8bd1018          LDRH     r1,[sp,#0x18]
0000a8  480c              LDR      r0,|L6.220|
0000aa  f8a0125c          STRH     r1,[r0,#0x25c]
;;;267        
;;;268        ReqPkt->Base.StartRegAddr.Segment.Lo = (( TModbusApp::TLittleEndian * )&PDU->RegAddr)->Segment.Lo;
0000ae  78a9              LDRB     r1,[r5,#2]
0000b0  70e1              STRB     r1,[r4,#3]
;;;269        ReqPkt->Base.StartRegAddr.Segment.Hi = (( TModbusApp::TLittleEndian * )&PDU->RegAddr)->Segment.Hi;
0000b2  78e8              LDRB     r0,[r5,#3]
0000b4  70a0              STRB     r0,[r4,#2]
;;;270        ReqPkt->Base.RegsQty.Segment.Lo      = (( TModbusApp::TLittleEndian * )&RegsQty)->Segment.Lo;
0000b6  f89d1018          LDRB     r1,[sp,#0x18]
0000ba  7161              STRB     r1,[r4,#5]
;;;271        ReqPkt->Base.RegsQty.Segment.Hi      = (( TModbusApp::TLittleEndian * )&RegsQty)->Segment.Hi;
0000bc  f89d0019          LDRB     r0,[sp,#0x19]
0000c0  7120              STRB     r0,[r4,#4]
;;;272        
;;;273        ReqPkt->Crc                          = CRC16( BaseToSens.TxBuf, sizeof ( TBase ) );
0000c2  2106              MOVS     r1,#6
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       CRC16
0000ca  80e0              STRH     r0,[r4,#6]
;;;274    
;;;275        BaseToSens.start_transmit( sizeof ( TReqRdInputRegs ) );
0000cc  2108              MOVS     r1,#8
0000ce  4803              LDR      r0,|L6.220|
0000d0  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
;;;276      }
0000d4  bf00              NOP      
                  |L6.214|
;;;277    }
0000d6  b008              ADD      sp,sp,#0x20
0000d8  e8bd81f0          POP      {r4-r8,pc}
;;;278    
                          ENDP

                  |L6.220|
                          DCD      BaseToSens
                  |L6.224|
                          DCD      BaseToSens+0x114

                          AREA ||i.__sti___16_base_to_sens_cpp_e027ba68||, CODE, READONLY, ALIGN=2

                  __sti___16_base_to_sens_cpp_e027ba68 PROC
000000  b51c              PUSH     {r2-r4,lr}
000002  4808              LDR      r0,|L7.36|
000004  4908              LDR      r1,|L7.40|
000006  4b09              LDR      r3,|L7.44|
000008  2200              MOVS     r2,#0
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  4908              LDR      r1,|L7.48|
000010  4808              LDR      r0,|L7.52|
000012  f7fffffe          BL       _ZN10TModbusAppC1ERK9TUsart_HWN11TModbusLink9TProcTypeEPN12TDevHandlers11TPduHandlerEPPvS9_ ; TModbusApp::TModbusApp(const TUsart_HW&, TModbusLink::TProcType, TDevHandlers::TPduHandler*, void**, void**)
000016  4604              MOV      r4,r0
000018  4a07              LDR      r2,|L7.56|
00001a  4908              LDR      r1,|L7.60|
00001c  f7fffffe          BL       __aeabi_atexit
000020  bd1c              POP      {r2-r4,pc}
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      MasterCommErrSem
                  |L7.40|
                          DCD      MasterRtoTrigSem
                  |L7.44|
                          DCD      BaseToSensPduHandler
                  |L7.48|
                          DCD      UsartInt_HW
                  |L7.52|
                          DCD      BaseToSens
                  |L7.56|
                          DCD      __dso_handle
                  |L7.60|
                          DCD      _ZN10TModbusAppD1Ev ; TModbusApp::~TModbusApp()

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z12base_to_sensPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z12base_to_sensPv||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba6814wr_axis_rotateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba6814wr_axis_rotateEv||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687acc_rdyEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687acc_rdyEv||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba689read_measEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba689read_measEv||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687pd_pollEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687pd_pollEv||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._Z6pd_tmrPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z6pd_tmrPv||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i.__sti___16_base_to_sens_cpp_e027ba68||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___16_base_to_sens_cpp_e027ba68||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  BaseToSens
                          %        608

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x0001c200
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      DevSensStartSem
                          DCD      _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687acc_rdyEv ; [local to base_to_sens_cpp]::acc_rdy()
                          DCD      DevSensResSem
                          DCD      _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba689read_measEv ; [local to base_to_sens_cpp]::read_meas()
                          DCD      PdSem
                          DCD      _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687pd_pollEv ; [local to base_to_sens_cpp]::pd_poll()
                          DCD      SensWrAxisRotateSem
                          DCD      _ZN38_INTERNAL_16_base_to_sens_cpp_e027ba6814wr_axis_rotateEv ; [local to base_to_sens_cpp]::wr_axis_rotate()

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___16_base_to_sens_cpp_e027ba68

;*** Start embedded assembler ***

#line 1 "Source\\Tasks\\src\\base_to_sens.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_base_to_sens_cpp_e027ba68___ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___16_base_to_sens_cpp_e027ba68___ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_base_to_sens_cpp_e027ba68___ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687__REVSHEi|
#line 402
|__asm___16_base_to_sens_cpp_e027ba68___ZN38_INTERNAL_16_base_to_sens_cpp_e027ba687__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_base_to_sens_cpp_e027ba68___ZN38_INTERNAL_16_base_to_sens_cpp_e027ba685__RRXEj|
#line 587
|__asm___16_base_to_sens_cpp_e027ba68___ZN38_INTERNAL_16_base_to_sens_cpp_e027ba685__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
