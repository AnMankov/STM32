; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\flash_driver.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\flash_driver.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I.\Source\Ext_Dev\inc\AT45 -I.\Objects -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\flash_driver.crf Source\MCU_Drivers\src\Flash_driver.cpp]
                          THUMB

                          AREA ||i.FLASH_IRQHandler||, CODE, READONLY, ALIGN=2

                  FLASH_IRQHandler PROC
;;;325    //******************************************************************************
;;;326    extern "C" void FLASH_IRQHandler( void )
000000  4802              LDR      r0,|L1.12|
;;;327    {
;;;328      volatile static uint8_t Ctr = 0;
;;;329      Ctr++;
000002  7800              LDRB     r0,[r0,#0]  ; _ZZ16FLASH_IRQHandlerE3Ctr
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L1.12|
000008  7008              STRB     r0,[r1,#0]
;;;330    }
00000a  4770              BX       lr
;;;331    
                          ENDP

                  |L1.12|
                          DCD      _ZZ16FLASH_IRQHandlerE3Ctr ; FLASH_IRQHandler::Ctr

                          AREA ||i.TIM6_DAC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM6_DAC_IRQHandler PROC
;;;331    
;;;332    extern "C" void TIM6_DAC_IRQHandler(void)
000000  bf00              NOP      
000002  480a              LDR      r0,|L2.44|
000004  6900              LDR      r0,[r0,#0x10]
000006  f0000001          AND      r0,r0,#1
;;;333    {
;;;334      if ( LL_TIM_IsActiveFlag_UPDATE( TIM6 ) )
00000a  b170              CBZ      r0,|L2.42|
;;;335      {
;;;336        FlashTmrTrig = true;
00000c  2001              MOVS     r0,#1
00000e  4908              LDR      r1,|L2.48|
000010  7008              STRB     r0,[r1,#0]
;;;337        ++FlashErrCtr;
000012  4808              LDR      r0,|L2.52|
000014  7800              LDRB     r0,[r0,#0]  ; FlashErrCtr
000016  1c40              ADDS     r0,r0,#1
000018  4906              LDR      r1,|L2.52|
00001a  7008              STRB     r0,[r1,#0]
;;;338        LL_TIM_ClearFlag_UPDATE( TIM6 ); // Clear the update interrupt flag (UIF)
00001c  bf00              NOP      
00001e  f06f0001          MVN      r0,#1
000022  4902              LDR      r1,|L2.44|
000024  6108              STR      r0,[r1,#0x10]
000026  bf00              NOP      
000028  bf00              NOP      
                  |L2.42|
;;;339      }
;;;340    }
00002a  4770              BX       lr
                          ENDP

                  |L2.44|
                          DCD      0x40001000
                  |L2.48|
                          DCD      FlashTmrTrig
                  |L2.52|
                          DCD      FlashErrCtr

                          AREA ||i._ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b423LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b423LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef PROC ; [local to Flash_driver_cpp]::LL_TIM_ClearFlag_UPDATE(TIM_TypeDef*)
;;;4026     */
;;;4027   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
000000  f06f0101          MVN      r1,#1
;;;4028   {
;;;4029     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
000004  6101              STR      r1,[r0,#0x10]
;;;4030   }
000006  4770              BX       lr
;;;4031   
                          ENDP


                          AREA ||i._ZN6TFlash10write_dataEPKh||, CODE, READONLY, ALIGN=2

                  _ZN6TFlash10write_dataEPKh PROC ; TFlash::write_data(const unsigned char*)
;;;94     
;;;95     void TFlash::write_data( const uint8_t *Src )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;97       do {} while( FLASH_GetStatus() == FLASH_BUSY );
000008  bf00              NOP      
                  |L4.10|
00000a  f7fffffe          BL       _Z15FLASH_GetStatusv ; FLASH_GetStatus()
00000e  2801              CMP      r0,#1
000010  d0fb              BEQ      |L4.10|
;;;98       
;;;99       bool ProgStatus = false;
000012  2600              MOVS     r6,#0
;;;100      uint32_t Addr = DATA_START_ADDR + PAGE_SIZE * DataPageCtr++;
000014  7821              LDRB     r1,[r4,#0]
000016  1c48              ADDS     r0,r1,#1
000018  7020              STRB     r0,[r4,#0]
00001a  480a              LDR      r0,|L4.68|
00001c  1402              ASRS     r2,r0,#16
00001e  fb120501          SMLABB   r5,r2,r1,r0
;;;101      do
000022  bf00              NOP      
                  |L4.36|
;;;102      {
;;;103    		
;;;104    		erase_page( Addr );
000024  4629              MOV      r1,r5
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       _ZNK6TFlash10erase_pageEj ; TFlash::erase_page(unsigned) const
;;;105        ProgStatus = write_page( Src, PAGE_SIZE, Addr );
00002c  462b              MOV      r3,r5
00002e  f44f6200          MOV      r2,#0x800
000032  4639              MOV      r1,r7
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       _ZNK6TFlash10write_pageEPKhtj ; TFlash::write_page(const unsigned char*, unsigned short, unsigned) const
00003a  4606              MOV      r6,r0
;;;106      } while ( ProgStatus != true );
00003c  2e00              CMP      r6,#0
00003e  d0f1              BEQ      |L4.36|
;;;107    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;108    
                          ENDP

                  |L4.68|
                          DCD      0x0800e000

                          AREA ||i._ZN6TFlash10write_setsEPKht||, CODE, READONLY, ALIGN=2

                  _ZN6TFlash10write_setsEPKht PROC ; TFlash::write_sets(const unsigned char*, unsigned short)
;;;82     
;;;83     void TFlash::write_sets( const uint8_t *Src, uint16_t BytesQty )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;85       do {} while( FLASH_GetStatus() == FLASH_BUSY );
00000a  bf00              NOP      
                  |L5.12|
00000c  f7fffffe          BL       _Z15FLASH_GetStatusv ; FLASH_GetStatus()
000010  2801              CMP      r0,#1
000012  d0fb              BEQ      |L5.12|
;;;86       
;;;87       bool ProgStatus = false;
000014  2400              MOVS     r4,#0
;;;88       do
000016  bf00              NOP      
                  |L5.24|
;;;89       {
;;;90         erase_page( FLASH_USER_START_ADDR );
000018  4907              LDR      r1,|L5.56|
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       _ZNK6TFlash10erase_pageEj ; TFlash::erase_page(unsigned) const
;;;91         ProgStatus = write_page( Src, BytesQty, FLASH_USER_START_ADDR );
000020  4b05              LDR      r3,|L5.56|
000022  463a              MOV      r2,r7
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       _ZNK6TFlash10write_pageEPKhtj ; TFlash::write_page(const unsigned char*, unsigned short, unsigned) const
00002c  4604              MOV      r4,r0
;;;92       } while ( ProgStatus != true );
00002e  2c00              CMP      r4,#0
000030  d0f2              BEQ      |L5.24|
;;;93     }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;94     
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      ||Image$$SETS_ROM$$Base||

                          AREA ||i._ZN6TFlash8get_setsEPht||, CODE, READONLY, ALIGN=2

                  _ZN6TFlash8get_setsEPht PROC ; TFlash::get_sets(unsigned char*, unsigned short)
;;;30     
;;;31     void TFlash::get_sets( uint8_t *Dest, uint16_t BytesQty )
000000  b5f0              PUSH     {r4-r7,lr}
;;;32     {
000002  4607              MOV      r7,r0
000004  460b              MOV      r3,r1
;;;33       auto Beg = reinterpret_cast<uint8_t *>( FLASH_USER_START_ADDR );
000006  4d08              LDR      r5,|L6.40|
;;;34       auto End = reinterpret_cast<uint8_t *>( FLASH_USER_START_ADDR ) + BytesQty;
000008  4628              MOV      r0,r5
00000a  1886              ADDS     r6,r0,r2
;;;35       
;;;36       std::copy( Beg, End, Dest );
00000c  4628              MOV      r0,r5
00000e  4634              MOV      r4,r6
000010  4619              MOV      r1,r3
000012  e005              B        |L6.32|
                  |L6.20|
000014  f890c000          LDRB     r12,[r0,#0]
000018  f881c000          STRB     r12,[r1,#0]
00001c  1c40              ADDS     r0,r0,#1
00001e  1c49              ADDS     r1,r1,#1
                  |L6.32|
000020  42a0              CMP      r0,r4
000022  d1f7              BNE      |L6.20|
000024  bf00              NOP      
;;;37     }
000026  bdf0              POP      {r4-r7,pc}
;;;38     
                          ENDP

                  |L6.40|
                          DCD      ||Image$$SETS_ROM$$Base||

                          AREA ||i._ZN6TFlash8init_tmrEv||, CODE, READONLY, ALIGN=2

                  _ZN6TFlash8init_tmrEv PROC ; TFlash::init_tmr()
;;;283    
;;;284    void TFlash::init_tmr()
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;285    {    
000004  b08d              SUB      sp,sp,#0x34
000006  4604              MOV      r4,r0
;;;286        LL_TIM_InitTypeDef TIM_InitStruct;
;;;287    
;;;288    //  ----- Включить тактирование таймера ---------------------------------
;;;289        LL_APB1_GRP1_EnableClock( LL_APB1_GRP1_PERIPH_TIM6 );
000008  2010              MOVS     r0,#0x10
00000a  4951              LDR      r1,|L7.336|
00000c  6d89              LDR      r1,[r1,#0x58]
00000e  4301              ORRS     r1,r1,r0
000010  4a4f              LDR      r2,|L7.336|
000012  6591              STR      r1,[r2,#0x58]
000014  4611              MOV      r1,r2
000016  6d89              LDR      r1,[r1,#0x58]
000018  4001              ANDS     r1,r1,r0
00001a  9101              STR      r1,[sp,#4]
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;290    
;;;291        LL_RCC_ClocksTypeDef RCC_Clocks;
;;;292        LL_RCC_GetSystemClocksFreq(&RCC_Clocks);
000020  a804              ADD      r0,sp,#0x10
000022  f7fffffe          BL       LL_RCC_GetSystemClocksFreq
;;;293    //    RCC_Clocks.PCLK1_Frequency
;;;294    
;;;295        constexpr uint32_t F_CNT             = 2000U; //частота работы счетчика таймера, Гц
000026  f44f66fa          MOV      r6,#0x7d0
;;;296        constexpr uint32_t F_TIMER           = 100U;  //частота работы таймера, Гц
00002a  2764              MOVS     r7,#0x64
;;;297        uint16_t PRESCALER_VALUE             = (RCC_Clocks.PCLK1_Frequency + (F_CNT / 2U)) / F_CNT - 1U;
00002c  9806              LDR      r0,[sp,#0x18]
00002e  f500707a          ADD      r0,r0,#0x3e8
000032  4631              MOV      r1,r6
000034  fbb0f0f1          UDIV     r0,r0,r1
000038  1e40              SUBS     r0,r0,#1
00003a  b285              UXTH     r5,r0
;;;298        constexpr uint32_t AUTORELOAD_VALUE  = (F_CNT + (F_TIMER / 2U)) / F_TIMER - 1U;
00003c  2013              MOVS     r0,#0x13
00003e  9003              STR      r0,[sp,#0xc]
;;;299        constexpr uint32_t START_TIMER_VALUE = 0x00;
000040  2000              MOVS     r0,#0
000042  9002              STR      r0,[sp,#8]
;;;300    
;;;301    //  ----- Инициализация таймера -----------------------------------------
;;;302        TIM_InitStruct.Prescaler     = PRESCALER_VALUE;
000044  f8ad5020          STRH     r5,[sp,#0x20]
;;;303        TIM_InitStruct.CounterMode   = LL_TIM_COUNTERMODE_UP;
000048  9009              STR      r0,[sp,#0x24]
;;;304        TIM_InitStruct.Autoreload    = AUTORELOAD_VALUE;
00004a  2013              MOVS     r0,#0x13
00004c  900a              STR      r0,[sp,#0x28]
;;;305        TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00004e  2000              MOVS     r0,#0
000050  900b              STR      r0,[sp,#0x2c]
;;;306    //    TIM_InitStruct.RepetitionCounter = ;
;;;307    
;;;308        LL_TIM_Init(Tmr, &TIM_InitStruct);                            // Configure the TIMx time base unit
000052  a908              ADD      r1,sp,#0x20
000054  6860              LDR      r0,[r4,#4]
000056  f7fffffe          BL       LL_TIM_Init
;;;309        LL_TIM_ClearFlag_UPDATE(Tmr);
00005a  6860              LDR      r0,[r4,#4]
00005c  f7fffffe          BL       _ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b423LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef ; [local to Flash_driver_cpp]::LL_TIM_ClearFlag_UPDATE(TIM_TypeDef*)
;;;310    
;;;311    //    LL_TIM_DisableUpdateEvent(MAIN_TIMER);                        // Enable update event generation 
;;;312        LL_TIM_SetUpdateSource(Tmr, LL_TIM_UPDATESOURCE_COUNTER);     // Set update event source  
000060  2104              MOVS     r1,#4
000062  6860              LDR      r0,[r4,#4]
000064  6802              LDR      r2,[r0,#0]
000066  f0220204          BIC      r2,r2,#4
00006a  430a              ORRS     r2,r2,r1
00006c  6002              STR      r2,[r0,#0]
00006e  bf00              NOP      
;;;313        LL_TIM_SetOnePulseMode(Tmr, LL_TIM_ONEPULSEMODE_REPETITIVE);  // Set one pulse mode
000070  2100              MOVS     r1,#0
000072  6860              LDR      r0,[r4,#4]
000074  6802              LDR      r2,[r0,#0]
000076  f0220208          BIC      r2,r2,#8
00007a  430a              ORRS     r2,r2,r1
00007c  6002              STR      r2,[r0,#0]
00007e  bf00              NOP      
;;;314        LL_TIM_SetCounterMode(Tmr, LL_TIM_COUNTERMODE_UP);            // Set the timer counter counting mode
000080  6860              LDR      r0,[r4,#4]
000082  6802              LDR      r2,[r0,#0]
000084  f0220270          BIC      r2,r2,#0x70
000088  430a              ORRS     r2,r2,r1
00008a  6002              STR      r2,[r0,#0]
00008c  bf00              NOP      
;;;315        LL_TIM_DisableARRPreload(Tmr);                                // Enable auto-reload (ARR) preload
00008e  6860              LDR      r0,[r4,#4]
000090  6801              LDR      r1,[r0,#0]
000092  f0210180          BIC      r1,r1,#0x80
000096  6001              STR      r1,[r0,#0]
000098  bf00              NOP      
;;;316        LL_TIM_SetCounter(Tmr, START_TIMER_VALUE);                    // Set the counter value
00009a  2100              MOVS     r1,#0
00009c  6860              LDR      r0,[r4,#4]
00009e  6241              STR      r1,[r0,#0x24]
0000a0  bf00              NOP      
;;;317    
;;;318        //настройка NVIC
;;;319        NVIC_SetPriority(TIM6_DAC_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 5, 0));  // 5 - максимальный уровень приоритета для прерывания из которого можно вызывать API функции FreeRTOS 
0000a2  2136              MOVS     r1,#0x36
0000a4  4b2b              LDR      r3,|L7.340|
0000a6  681b              LDR      r3,[r3,#0]
0000a8  f3c32002          UBFX     r0,r3,#8,#3
0000ac  f04f0c05          MOV      r12,#5
0000b0  f04f0800          MOV      r8,#0
0000b4  4603              MOV      r3,r0
0000b6  f1c30b07          RSB      r11,r3,#7
0000ba  f1bb0f04          CMP      r11,#4
0000be  d902              BLS      |L7.198|
0000c0  f04f0b04          MOV      r11,#4
0000c4  e001              B        |L7.202|
                  |L7.198|
0000c6  f1c30b07          RSB      r11,r3,#7
                  |L7.202|
0000ca  46da              MOV      r10,r11
0000cc  f1030b04          ADD      r11,r3,#4
0000d0  f1bb0f07          CMP      r11,#7
0000d4  d202              BCS      |L7.220|
0000d6  f04f0b00          MOV      r11,#0
0000da  e001              B        |L7.224|
                  |L7.220|
0000dc  f1a30b03          SUB      r11,r3,#3
                  |L7.224|
0000e0  46d9              MOV      r9,r11
0000e2  f04f0b01          MOV      r11,#1
0000e6  fa0bfb0a          LSL      r11,r11,r10
0000ea  f1ab0b01          SUB      r11,r11,#1
0000ee  ea0b0b0c          AND      r11,r11,r12
0000f2  fa0bfb09          LSL      r11,r11,r9
0000f6  f04f0e01          MOV      lr,#1
0000fa  fa0efe09          LSL      lr,lr,r9
0000fe  f1ae0e01          SUB      lr,lr,#1
000102  ea0e0e08          AND      lr,lr,r8
000106  ea4b020e          ORR      r2,r11,lr
00010a  bf00              NOP      
00010c  2900              CMP      r1,#0
00010e  da0a              BGE      |L7.294|
000110  0710              LSLS     r0,r2,#28
000112  ea4f6c10          LSR      r12,r0,#24
000116  480f              LDR      r0,|L7.340|
000118  300c              ADDS     r0,r0,#0xc
00011a  f001030f          AND      r3,r1,#0xf
00011e  1f1b              SUBS     r3,r3,#4
000120  f800c003          STRB     r12,[r0,r3]
000124  e003              B        |L7.302|
                  |L7.294|
000126  0710              LSLS     r0,r2,#28
000128  0e03              LSRS     r3,r0,#24
00012a  480b              LDR      r0,|L7.344|
00012c  5443              STRB     r3,[r0,r1]
                  |L7.302|
00012e  bf00              NOP      
;;;320        NVIC_EnableIRQ(TIM6_DAC_IRQn);
000130  2036              MOVS     r0,#0x36
000132  f000021f          AND      r2,r0,#0x1f
000136  2101              MOVS     r1,#1
000138  4091              LSLS     r1,r1,r2
00013a  0942              LSRS     r2,r0,#5
00013c  0092              LSLS     r2,r2,#2
00013e  f10222e0          ADD      r2,r2,#0xe000e000
000142  f8c21100          STR      r1,[r2,#0x100]
000146  bf00              NOP      
;;;321    }
000148  b00d              ADD      sp,sp,#0x34
00014a  e8bd8ff0          POP      {r4-r11,pc}
;;;322    
                          ENDP

00014e  0000              DCW      0x0000
                  |L7.336|
                          DCD      0x40021000
                  |L7.340|
                          DCD      0xe000ed0c
                  |L7.344|
                          DCD      0xe000e400

                          AREA ||i._ZN6TFlashC1Ev||, CODE, READONLY, ALIGN=2

                  _ZN6TFlashC2Ev                  ; Alternate entry point ; TFlash::TFlash__sub_object()
                  _ZN6TFlashC1Ev PROC ; TFlash::TFlash()
;;;16     
;;;17     TFlash::TFlash()
;;;18     :
;;;19     Tmr( TIM6 ),
;;;20     DataPageCtr( 0U )
;;;21     {
;;;22     //  rdp_ob();
;;;23       init_tmr();
;;;24     }
;;;25     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  2000              MOVS     r0,#0
000006  7020              STRB     r0,[r4,#0]
000008  4803              LDR      r0,|L8.24|
00000a  6060              STR      r0,[r4,#4]
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       _ZN6TFlash8init_tmrEv ; TFlash::init_tmr()
000012  4620              MOV      r0,r4
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      0x40001000

                          AREA ||i._ZN6TFlashD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN6TFlashD2Ev                  ; Alternate entry point ; TFlash::~TFlash__sub_object()
                  _ZN6TFlashD1Ev PROC ; TFlash::~TFlash()
;;;25     
;;;26     TFlash::~TFlash()
;;;27     {
;;;28     
;;;29     }
;;;30     
000000  4770              BX       lr
                          ENDP


                          AREA ||i._ZNK6TFlash10erase_pageEj||, CODE, READONLY, ALIGN=2

                  _ZNK6TFlash10erase_pageEj PROC ; TFlash::erase_page(unsigned) const
;;;113    */
;;;114    void TFlash::erase_page( uint32_t Addr ) const
000000  b570              PUSH     {r4-r6,lr}
;;;115    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;116      //проверка Flash на незанятость должна быть сделана ранее
;;;117      FLASH_Unlock(); //разблокировка Flash для включения доступа к регистру управления Flash
000006  f7fffffe          BL       _Z12FLASH_Unlockv ; FLASH_Unlock()
;;;118    
;;;119      clear_all_error(); //сброс всех установленных флагов ошибок программирования
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       _ZNK6TFlash15clear_all_errorEv ; TFlash::clear_all_error() const
;;;120    
;;;121      uint32_t PAGE_NBR = ( Addr - FLASH_BASE ) / PAGE_SIZE; //номер страницы
000010  f1a46000          SUB      r0,r4,#0x8000000
000014  0ac6              LSRS     r6,r0,#11
;;;122      
;;;123      FLASH->CR |= FLASH_CR_PER;
000016  4810              LDR      r0,|L10.88|
000018  6940              LDR      r0,[r0,#0x14]
00001a  f0400002          ORR      r0,r0,#2
00001e  490e              LDR      r1,|L10.88|
000020  6148              STR      r0,[r1,#0x14]
;;;124    //  FLASH->CR = FLASH->CR & ~FLASH_CR_PNB | ( FLASH_USER_PAGE_NBR << FLASH_CR_PNB_Pos );
;;;125      FLASH->CR = FLASH->CR & ~FLASH_CR_PNB | ( PAGE_NBR << FLASH_CR_PNB_Pos );
000022  4608              MOV      r0,r1
000024  6940              LDR      r0,[r0,#0x14]
000026  f42060ff          BIC      r0,r0,#0x7f8
00002a  ea4000c6          ORR      r0,r0,r6,LSL #3
00002e  6148              STR      r0,[r1,#0x14]
;;;126    
;;;127      FLASH->CR |= FLASH_CR_STRT; //запуск стирания, автоматически включается HSI16
000030  4608              MOV      r0,r1
000032  6940              LDR      r0,[r0,#0x14]
000034  f4403080          ORR      r0,r0,#0x10000
000038  6148              STR      r0,[r1,#0x14]
;;;128      
;;;129      do {} while( FLASH_GetStatus() == FLASH_BUSY ); //вместе с BSY автоматически сбрасывается STRT и отключается HSI16
00003a  bf00              NOP      
                  |L10.60|
00003c  f7fffffe          BL       _Z15FLASH_GetStatusv ; FLASH_GetStatus()
000040  2801              CMP      r0,#1
000042  d0fb              BEQ      |L10.60|
;;;130      FLASH->CR &= ~FLASH_CR_PER;
000044  4804              LDR      r0,|L10.88|
000046  6940              LDR      r0,[r0,#0x14]
000048  f0200002          BIC      r0,r0,#2
00004c  4902              LDR      r1,|L10.88|
00004e  6148              STR      r0,[r1,#0x14]
;;;131    
;;;132      FLASH_Lock(); //Блокировка Flash для отключения доступа к регистру управления Flash \
000050  f7fffffe          BL       _Z10FLASH_Lockv ; FLASH_Lock()
;;;133                      (Рекомендуется для защиты Flash от нежелательных операций)
;;;134    }
000054  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP

000056  0000              DCW      0x0000
                  |L10.88|
                          DCD      0x40022000

                          AREA ||i._ZNK6TFlash10write_pageEPKhtj||, CODE, READONLY, ALIGN=1

                  _ZNK6TFlash10write_pageEPKhtj PROC ; TFlash::write_page(const unsigned char*, unsigned short, unsigned) const
;;;135    
;;;136    bool TFlash::write_page( const uint8_t *Src, uint16_t BytesQty, uint32_t Addr ) const
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;137    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;138      bool CurProgStatus = false;
00000c  f04f0900          MOV      r9,#0
;;;139      //проверка Flash на незанятость должна быть сделана ранее
;;;140      FLASH_Unlock(); //разблокировка Flash для включения доступа к регистру управления Flash
000010  f7fffffe          BL       _Z12FLASH_Unlockv ; FLASH_Unlock()
;;;141      
;;;142      /* Запись во Flash
;;;143       * Область определяется FLASH_USER_START_ADDR и FLASH_USER_END_ADDR
;;;144      */ 
;;;145      uint32_t CurFlashAddr = Addr;
000014  4626              MOV      r6,r4
;;;146      uint32_t EndFlashAddr = Addr + BytesQty;
000016  eb040a05          ADD      r10,r4,r5
;;;147        
;;;148      //запись настроек
;;;149      CurProgStatus = prog( ( const uint32_t * )Src, CurFlashAddr, EndFlashAddr );
00001a  4653              MOV      r3,r10
00001c  4632              MOV      r2,r6
00001e  4641              MOV      r1,r8
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       _ZNK6TFlash4progEPKjjj ; TFlash::prog(const unsigned*, unsigned, unsigned) const
000026  4681              MOV      r9,r0
;;;150      
;;;151      FLASH_Lock(); //Блокировка Flash для отключения доступа к регистру управления Flash \
000028  f7fffffe          BL       _Z10FLASH_Lockv ; FLASH_Lock()
;;;152                      (Рекомендуется для защиты Flash от нежелательных операций)
;;;153                      
;;;154      return CurProgStatus;
00002c  4648              MOV      r0,r9
;;;155    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;156    
                          ENDP


                          AREA ||i._ZNK6TFlash15clear_all_errorEv||, CODE, READONLY, ALIGN=2

                  _ZNK6TFlash15clear_all_errorEv PROC ; TFlash::clear_all_error() const
;;;255    
;;;256    void TFlash::clear_all_error() const
000000  4903              LDR      r1,|L12.16|
;;;257    {
;;;258      FLASH->SR |= FLASH_SR_OPTVERR | //сброс всех установленных флагов ошибок программирования
000002  6909              LDR      r1,[r1,#0x10]
000004  f24c32fb          MOV      r2,#0xc3fb
000008  4311              ORRS     r1,r1,r2
00000a  4a01              LDR      r2,|L12.16|
00000c  6111              STR      r1,[r2,#0x10]
;;;259                   FLASH_SR_RDERR   |
;;;260                   FLASH_SR_FASTERR |
;;;261                   FLASH_SR_MISERR  |
;;;262                   FLASH_SR_PGSERR  |
;;;263                   FLASH_SR_SIZERR  |
;;;264                   FLASH_SR_PGAERR  |
;;;265                   FLASH_SR_WRPERR  |
;;;266                   FLASH_SR_PROGERR |
;;;267                   FLASH_SR_OPERR   |
;;;268                   FLASH_SR_EOP;
;;;269    }
00000e  4770              BX       lr
;;;270    
                          ENDP

                  |L12.16|
                          DCD      0x40022000

                          AREA ||i._ZNK6TFlash4progEPKjjj||, CODE, READONLY, ALIGN=2

                  _ZNK6TFlash4progEPKjjj PROC ; TFlash::prog(const unsigned*, unsigned, unsigned) const
;;;156    
;;;157    bool TFlash::prog( const uint32_t *pData, uint32_t StartAddr, const uint32_t EndAddr ) const
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;158    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;159      
;;;160      //проверка Flash на незанятость должна быть сделана ранее
;;;161      bool CurProgStatus = true;
00000c  f04f0801          MOV      r8,#1
;;;162    
;;;163      FLASH->CR |= FLASH_CR_EOPIE;
000010  4823              LDR      r0,|L13.160|
000012  6940              LDR      r0,[r0,#0x14]
000014  f0407080          ORR      r0,r0,#0x1000000
000018  4921              LDR      r1,|L13.160|
00001a  6148              STR      r0,[r1,#0x14]
;;;164    
;;;165      while ( StartAddr < EndAddr )
00001c  e030              B        |L13.128|
                  |L13.30|
;;;166      {
;;;167        clear_all_error();
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       _ZNK6TFlash15clear_all_errorEv ; TFlash::clear_all_error() const
;;;168        __disable_irq;
;;;169        __disable_fault_irq();
000024  b671              CPSID    f
;;;170        FLASH->CR |= FLASH_CR_PG;
000026  481e              LDR      r0,|L13.160|
000028  6940              LDR      r0,[r0,#0x14]
00002a  f0400001          ORR      r0,r0,#1
00002e  491c              LDR      r1,|L13.160|
000030  6148              STR      r0,[r1,#0x14]
;;;171        
;;;172        *((__IO uint32_t *)StartAddr)++ = *pData++;
000032  cd01              LDM      r5!,{r0}
000034  c401              STM      r4!,{r0}
;;;173        *((__IO uint32_t *)StartAddr)++ = *pData++;
000036  cd01              LDM      r5!,{r0}
000038  c401              STM      r4!,{r0}
;;;174        
;;;175        do {} while( FLASH_GetStatus() == FLASH_BUSY );
00003a  bf00              NOP      
                  |L13.60|
00003c  f7fffffe          BL       _Z15FLASH_GetStatusv ; FLASH_GetStatus()
000040  2801              CMP      r0,#1
000042  d0fb              BEQ      |L13.60|
;;;176        __enable_irq;
;;;177        __enable_fault_irq();
000044  b661              CPSIE    f
;;;178        
;;;179        start_tmr();
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       _ZNK6TFlash9start_tmrEv ; TFlash::start_tmr() const
;;;180        do 
00004c  bf00              NOP      
                  |L13.78|
;;;181        {
;;;182          if ( FlashTmrTrig == true ) //если время на прошивку элемента Flash истекло
00004e  4815              LDR      r0,|L13.164|
000050  7800              LDRB     r0,[r0,#0]  ; FlashTmrTrig
000052  2801              CMP      r0,#1
000054  d104              BNE      |L13.96|
;;;183          {
;;;184            FlashTmrTrig  = false;
000056  2000              MOVS     r0,#0
000058  4912              LDR      r1,|L13.164|
00005a  7008              STRB     r0,[r1,#0]
;;;185            CurProgStatus = false;
00005c  4680              MOV      r8,r0
;;;186            break;
00005e  e005              B        |L13.108|
                  |L13.96|
;;;187          }    
;;;188        } while( !(FLASH->SR & FLASH_SR_EOP) );   //операция программирования прошла успешно
000060  480f              LDR      r0,|L13.160|
000062  6900              LDR      r0,[r0,#0x10]
000064  f0000001          AND      r0,r0,#1
000068  2800              CMP      r0,#0
00006a  d0f0              BEQ      |L13.78|
                  |L13.108|
00006c  bf00              NOP                            ;186
;;;189        FLASH->SR |= FLASH_SR_EOP;                    //сброс флага End of operation
00006e  480c              LDR      r0,|L13.160|
000070  6900              LDR      r0,[r0,#0x10]
000072  f0400001          ORR      r0,r0,#1
000076  490a              LDR      r1,|L13.160|
000078  6108              STR      r0,[r1,#0x10]
;;;190        stop_tmr();
00007a  4638              MOV      r0,r7
00007c  f7fffffe          BL       _ZNK6TFlash8stop_tmrEv ; TFlash::stop_tmr() const
                  |L13.128|
000080  42b4              CMP      r4,r6                 ;165
000082  d3cc              BCC      |L13.30|
;;;191        
;;;192    //    StartAddr += sizeof(*pData);
;;;193      }
;;;194      FLASH->CR &= ~FLASH_CR_PG;
000084  4806              LDR      r0,|L13.160|
000086  6940              LDR      r0,[r0,#0x14]
000088  f0200001          BIC      r0,r0,#1
00008c  4904              LDR      r1,|L13.160|
00008e  6148              STR      r0,[r1,#0x14]
;;;195      
;;;196      FLASH->CR &= ~FLASH_CR_EOPIE;
000090  4608              MOV      r0,r1
000092  6940              LDR      r0,[r0,#0x14]
000094  f0207080          BIC      r0,r0,#0x1000000
000098  6148              STR      r0,[r1,#0x14]
;;;197      
;;;198      
;;;199      return CurProgStatus;
00009a  4640              MOV      r0,r8
;;;200    
;;;201    
;;;202      
;;;203    //  //проверка Flash на незанятость должна быть сделана ранее
;;;204    //  bool CurProgStatus = true;
;;;205    
;;;206    //  FLASH->CR |= FLASH_CR_FSTPG;
;;;207    //  
;;;208    //  clear_all_error();
;;;209    // __disable_fault_irq();  
;;;210    
;;;211    //  while ( StartAddr < EndAddr )
;;;212    //  {
;;;213    //    
;;;214    //    *((__IO uint32_t *)StartAddr)++ = *pData++;
;;;215    //    *((__IO uint32_t *)StartAddr)++ = *pData++;
;;;216    //    
;;;217    
;;;218    //    
;;;219    ////    StartAddr += sizeof(*pData);
;;;220    //  }
;;;221    
;;;222    //  __enable_fault_irq(); 
;;;223    //  
;;;224    //  
;;;225    //  start_tmr();
;;;226    //  do {} while( FLASH_GetStatus() == FLASH_BUSY );
;;;227    
;;;228    //    
;;;229    //  do 
;;;230    //  {
;;;231    //    if ( FlashTmrTrig == true ) //если время на прошивку элемента Flash истекло
;;;232    //    {
;;;233    //      FlashTmrTrig  = false;
;;;234    //      CurProgStatus = false;
;;;235    //      break;
;;;236    //    }    
;;;237    //  } while( !(FLASH->SR & FLASH_SR_EOP) );   //операция программирования прошла успешно
;;;238    //  
;;;239    //  
;;;240    //  FLASH->SR |= FLASH_SR_EOP;                    //сброс флага End of operation
;;;241    //  stop_tmr();
;;;242    //  
;;;243    //  FLASH->CR &= ~FLASH_CR_PG;
;;;244    //  
;;;245    //  FLASH->CR &= ~FLASH_CR_EOPIE;
;;;246    //  
;;;247    //  
;;;248    //  return CurProgStatus;
;;;249    
;;;250    
;;;251    
;;;252    
;;;253    
;;;254    }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;255    
                          ENDP

                  |L13.160|
                          DCD      0x40022000
                  |L13.164|
                          DCD      FlashTmrTrig

                          AREA ||i._ZNK6TFlash6rdp_obEv||, CODE, READONLY, ALIGN=2

                  _ZNK6TFlash6rdp_obEv PROC ; TFlash::rdp_ob() const
;;;57      ***************************************************/
;;;58     void TFlash::rdp_ob() const
000000  b570              PUSH     {r4-r6,lr}
;;;59     {
000002  4605              MOV      r5,r0
;;;60       do {} while( FLASH_GetStatus() == FLASH_BUSY );
000004  bf00              NOP      
                  |L14.6|
000006  f7fffffe          BL       _Z15FLASH_GetStatusv ; FLASH_GetStatus()
00000a  2801              CMP      r0,#1
00000c  d0fb              BEQ      |L14.6|
;;;61     
;;;62       TOptr *Optr = (TOptr *)&FLASH->OPTR;
00000e  4c0c              LDR      r4,|L14.64|
;;;63     
;;;64       if ( Optr->RDP == TRdpVal::OB_RDP_Level_0 ) //если защита от считывания не установлена
000010  7820              LDRB     r0,[r4,#0]
000012  28aa              CMP      r0,#0xaa
000014  d112              BNE      |L14.60|
;;;65       {
;;;66         /* Установить защиту от считывания
;;;67          */
;;;68         FLASH_Unlock();                                                      //разблокировка FPEC
000016  f7fffffe          BL       _Z12FLASH_Unlockv ; FLASH_Unlock()
;;;69         FLASH_OB_Unlock();                                                   //авторизация программирования OB
00001a  f7fffffe          BL       _Z15FLASH_OB_Unlockv ; FLASH_OB_Unlock()
;;;70     
;;;71         Optr->RDP = TRdpVal::OB_RDP_Level_1;
00001e  20bb              MOVS     r0,#0xbb
000020  7020              STRB     r0,[r4,#0]
;;;72         
;;;73         FLASH->CR |= FLASH_CR_OPTSTRT;                                       //запуск работы опций
000022  4807              LDR      r0,|L14.64|
000024  3820              SUBS     r0,r0,#0x20
000026  6940              LDR      r0,[r0,#0x14]
000028  f4403000          ORR      r0,r0,#0x20000
00002c  4904              LDR      r1,|L14.64|
00002e  3920              SUBS     r1,r1,#0x20
000030  6148              STR      r0,[r1,#0x14]
;;;74         
;;;75         do {} while(FLASH_GetStatus() == FLASH_BUSY);
000032  bf00              NOP      
                  |L14.52|
000034  f7fffffe          BL       _Z15FLASH_GetStatusv ; FLASH_GetStatus()
000038  2801              CMP      r0,#1
00003a  d0fb              BEQ      |L14.52|
                  |L14.60|
;;;76       }
;;;77     }
00003c  bd70              POP      {r4-r6,pc}
;;;78     
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      0x40022020

                          AREA ||i._ZNK6TFlash8stop_tmrEv||, CODE, READONLY, ALIGN=1

                  _ZNK6TFlash8stop_tmrEv PROC ; TFlash::stop_tmr() const
;;;276                                      
;;;277    void TFlash::stop_tmr() const           
000000  6841              LDR      r1,[r0,#4]
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
00000a  bf00              NOP      
;;;278    {                                 
;;;279      LL_TIM_DisableIT_UPDATE( Tmr ); // Disable update interrupt
;;;280      LL_TIM_DisableCounter( Tmr );
00000c  6841              LDR      r1,[r0,#4]
00000e  680a              LDR      r2,[r1,#0]
000010  f0220201          BIC      r2,r2,#1
000014  600a              STR      r2,[r1,#0]
000016  bf00              NOP      
;;;281    }
000018  4770              BX       lr
;;;282    
                          ENDP


                          AREA ||i._ZNK6TFlash9start_tmrEv||, CODE, READONLY, ALIGN=1

                  _ZNK6TFlash9start_tmrEv PROC ; TFlash::start_tmr() const
;;;270    
;;;271    void TFlash::start_tmr() const
000000  6841              LDR      r1,[r0,#4]
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
00000a  bf00              NOP      
;;;272    {
;;;273      LL_TIM_EnableIT_UPDATE( Tmr );  // Enable update interrupt
;;;274      LL_TIM_EnableCounter( Tmr );    // Enable timer counter
00000c  6841              LDR      r1,[r0,#4]
00000e  680a              LDR      r2,[r1,#0]
000010  f0420201          ORR      r2,r2,#1
000014  600a              STR      r2,[r1,#0]
000016  bf00              NOP      
;;;275    }                                 
000018  4770              BX       lr
;;;276                                      
                          ENDP


                          AREA ||i.__sti___16_Flash_driver_cpp_d50a58b4||, CODE, READONLY, ALIGN=2

                  __sti___16_Flash_driver_cpp_d50a58b4 PROC
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L17.20|
000004  f7fffffe          BL       _ZN6TFlashC1Ev ; TFlash::TFlash()
000008  4604              MOV      r4,r0
00000a  4a03              LDR      r2,|L17.24|
00000c  4903              LDR      r1,|L17.28|
00000e  f7fffffe          BL       __aeabi_atexit
000012  bd10              POP      {r4,pc}
                          ENDP

                  |L17.20|
                          DCD      Flash
                  |L17.24|
                          DCD      __dso_handle
                  |L17.28|
                          DCD      _ZN6TFlashD1Ev ; TFlash::~TFlash()

                          AREA ||.ARM.exidx||, LINKORDER=||i.FLASH_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.FLASH_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i.TIM6_DAC_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.TIM6_DAC_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._ZN6TFlash8init_tmrEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TFlash8init_tmrEv||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._ZN6TFlashC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TFlashC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._ZN6TFlashD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TFlashD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i._ZN6TFlash8get_setsEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TFlash8get_setsEPht||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i._ZNK6TFlash8stop_tmrEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash8stop_tmrEv||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i._ZNK6TFlash9start_tmrEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash9start_tmrEv||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i._ZNK6TFlash15clear_all_errorEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash15clear_all_errorEv||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i._ZNK6TFlash4progEPKjjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash4progEPKjjj||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i._ZNK6TFlash10write_pageEPKhtj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash10write_pageEPKhtj||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i._ZNK6TFlash10erase_pageEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash10erase_pageEj||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i._ZN6TFlash10write_setsEPKht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TFlash10write_setsEPKht||
                          DCD      0x00000001

                          AREA ||area_number.31||, LINKORDER=||i._ZN6TFlash10write_dataEPKh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TFlash10write_dataEPKh||
                          DCD      0x00000001

                          AREA ||area_number.32||, LINKORDER=||i._ZNK6TFlash6rdp_obEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TFlash6rdp_obEv||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i.__sti___16_Flash_driver_cpp_d50a58b4||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___16_Flash_driver_cpp_d50a58b4||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b423LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b423LL_TIM_ClearFlag_UPDATEEP11TIM_TypeDef||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  FlashErrCtr
000000  00                DCB      0x00
                  FlashTmrTrig
000001  000000            DCB      0x00,0x00,0x00
                  Flash
                          %        8
                  _ZZ16FLASH_IRQHandlerE3Ctr ; FLASH_IRQHandler::Ctr
00000c  00                DCB      0x00

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___16_Flash_driver_cpp_d50a58b4

;*** Start embedded assembler ***

#line 1 "Source\\MCU_Drivers\\src\\Flash_driver.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_Flash_driver_cpp_d50a58b4___ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b47__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___16_Flash_driver_cpp_d50a58b4___ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b47__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_Flash_driver_cpp_d50a58b4___ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b47__REVSHEi|
#line 402
|__asm___16_Flash_driver_cpp_d50a58b4___ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b47__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_Flash_driver_cpp_d50a58b4___ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b45__RRXEj|
#line 587
|__asm___16_Flash_driver_cpp_d50a58b4___ZN38_INTERNAL_16_Flash_driver_cpp_d50a58b45__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
