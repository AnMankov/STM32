L 1 "Source\Tasks\src\settings.cpp"
N
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF inline
N#elif defined __GNUC__ || defined _USE_STATIC_INLINE
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
S#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
N      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
N      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
N      namespace std {
N#       define __CLIBNS ::std::
N        extern "C" {
N#   else
S#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 1L && ((!0L || 1L) || 0L)
N  extern "C++" {
N    inline int (fpclassify)(double __x) { return fpclassify(__x); }
X    inline int (fpclassify)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_fpclassifyf(__x) : __ARM_fpclassify(__x)); }
N    inline bool (isfinite)(double __x) { return isfinite(__x); }
X    inline bool (isfinite)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isfinitef(__x) : __ARM_isfinite(__x)); }
N    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
X    inline bool (isgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x20000000)); }
N    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
X    inline bool (isgreaterequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x30000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0x30000000) == 0x20000000)); }
N    inline bool (isinf)(double __x) { return isinf(__x); }
X    inline bool (isinf)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isinff(__x) : __ARM_isinf(__x)); }
N    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
X    inline bool (isless)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x80000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x80000000)); }
N    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
X    inline bool (islessequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xc0000000) != 0) : ((__ARM_dcmp4((__x), (__y)) & 0xc0000000) != 0)); }
N    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
X    inline bool (islessgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? __ARM_islessgreaterf((__x), (__y)) : __ARM_islessgreater((__x), (__y))); }
N    inline bool (isnan)(double __x) { return isnan(__x); }
X    inline bool (isnan)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnanf(__x) : __ARM_isnan(__x)); }
N    inline bool (isnormal)(double __x) { return isnormal(__x); }
X    inline bool (isnormal)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnormalf(__x) : __ARM_isnormal(__x)); }
N    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
X    inline bool (isunordered)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x10000000) == 0x10000000) : ((__ARM_dcmp4((__x), (__y)) & 0x10000000) == 0x10000000)); }
N
N  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 1L && !0L
N  extern "C++" {
N    inline float abs(float __x)   { return fabsf(__x); }
N    inline float acos(float __x)  { return acosf(__x); }
N    inline float asin(float __x)  { return asinf(__x); }
N    inline float atan(float __x)  { return atanf(__x); }
N    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
N    inline float ceil(float __x)  { return ceilf(__x); }
N    inline float cos(float __x)   { return cosf(__x); }
N    inline float cosh(float __x)  { return coshf(__x); }
N    inline float exp(float __x)   { return expf(__x); }
N    inline float fabs(float __x)  { return fabsf(__x); }
N    inline float floor(float __x) { return floorf(__x); }
N    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
N    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
N    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
N    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
N    inline float log(float __x)   { return logf(__x); }
N    inline float log10(float __x) { return log10f(__x); }
N    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
N    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
N    inline float pow(float __x, float __y)      { return powf(__x,__y); }
N    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
N    inline float sin(float __x)   { return sinf(__x); }
N    inline float sinh(float __x)  { return sinhf(__x); }
N    inline float sqrt(float __x)  { return sqrtf(__x); }
N    inline float _sqrt(float __x) { return _sqrtf(__x); }
N    inline float tan(float __x)   { return tanf(__x); }
N    inline float tanh(float __x)  { return tanhf(__x); }
N
N    inline double abs(double __x) { return fabs(__x); }
N    inline double pow(double __x, int __y)
N                { return pow(__x, (double) __y); }
N
N#ifdef __HAVE_LONGDOUBLE
N    inline long double abs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double acos(long double __x)
N                { return (long double)acosl(__x); }
N    inline long double asin(long double __x)
N                { return (long double)asinl(__x); }
N    inline long double atan(long double __x)
N                { return (long double)atanl(__x); }
N    inline long double atan2(long double __y, long double __x)
N                { return (long double)atan2l(__y, __x); }
N    inline long double ceil(long double __x)
N                { return (long double)ceill( __x); }
N    inline long double cos(long double __x)
N                { return (long double)cosl(__x); }
N    inline long double cosh(long double __x)
N                { return (long double)coshl(__x); }
N    inline long double exp(long double __x)
N                { return (long double)expl(__x); }
N    inline long double fabs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double floor(long double __x)
N                { return (long double)floorl(__x); }
N    inline long double fmod(long double __x, long double __y)
N                { return (long double)fmodl(__x, __y); }
N    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
N    inline long double frexp(long double __x, int* __p)
N                { return (long double)frexpl(__x, __p); }
N    inline long double ldexp(long double __x, int __exp)
N                { return (long double)ldexpl(__x, __exp); }
N    inline long double log(long double __x)
N                { return (long double)logl(__x); }
N    inline long double log10(long double __x)
N                { return (long double)log10l(__x); }
N    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
N    inline long double modf(long double __x, long double* __p)
N                { return (long double)modfl(__x, __p); }
N    inline long double pow(long double __x, long double __y)
N                { return (long double)powl(__x, __y); }
N    inline long double pow(long double __x, int __y)
N                { return (long double)powl(__x, __y); }
N    inline long double sin(long double __x)
N                { return (long double)sinl(__x); }
N    inline long double sinh(long double __x)
N                { return (long double)sinhl(__x); }
N    inline long double sqrt(long double __x)
N                { return (long double)sqrtl(__x); }
N    inline long double _sqrt(long double __x)
N                { return (long double)_sqrt((double) __x); }
N    inline long double tan(long double __x)
N                { return (long double)tanl(__x); }
N    inline long double tanh(long double __x)
N                { return (long double)tanhl(__x); }
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N    inline float acosh(float __x) { return acoshf(__x); }
N    inline float asinh(float __x) { return asinhf(__x); }
N    inline float atanh(float __x) { return atanhf(__x); }
N    inline float cbrt(float __x) { return cbrtf(__x); }
N    inline float erf(float __x) { return erff(__x); }
N    inline float erfc(float __x) { return erfcf(__x); }
N    inline float expm1(float __x) { return expm1f(__x); }
N    inline float log1p(float __x) { return log1pf(__x); }
N    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
N    inline float lgamma(float __x) { return lgammaf(__x); }
N    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
N    inline float rint(float __x) { return rintf(__x); }
N#endif
N
N#ifdef __USE_C99_MATH
N    inline float exp2(float __x) { return exp2f(__x); }
N    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
N    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
N    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
N    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
N    inline float log2(float __x) { return log2f(__x); }
N    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
X    inline __declspec(__nothrow) long lrint(float __x) { return lrintf(__x); }
N    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
X    inline __declspec(__nothrow) long long llrint(float __x) { return llrintf(__x); }
N    inline _ARMABI long lround(float __x) { return lroundf(__x); }
X    inline __declspec(__nothrow) long lround(float __x) { return lroundf(__x); }
N    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
X    inline __declspec(__nothrow) long long llround(float __x) { return llroundf(__x); }
N    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
X    inline __declspec(__nothrow) __attribute__((const)) float nearbyint(float __x) { return nearbyintf(__x); }
N    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
N    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
X    inline __declspec(__nothrow) __attribute__((const)) float round(float __x) { return roundf(__x); }
N    inline float tgamma(float __x) { return tgammaf(__x); }
N    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
X    inline __declspec(__nothrow) __attribute__((const)) float trunc(float __x) { return truncf(__x); }
N
N    inline int (fpclassify)(float __x) { return fpclassify(__x); }
X    inline int (fpclassify)(float __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_fpclassifyf(__x) : __ARM_fpclassify(__x)); }
N    inline bool (isfinite)(float __x) { return isfinite(__x); }
X    inline bool (isfinite)(float __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isfinitef(__x) : __ARM_isfinite(__x)); }
N    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
X    inline bool (isgreater)(float __x, float __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x20000000)); }
N    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
X    inline bool (isgreaterequal)(float __x, float __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x30000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0x30000000) == 0x20000000)); }
N    inline bool (isinf)(float __x) { return isinf(__x); }
X    inline bool (isinf)(float __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isinff(__x) : __ARM_isinf(__x)); }
N    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
X    inline bool (isless)(float __x, float __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x80000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x80000000)); }
N    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
X    inline bool (islessequal)(float __x, float __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xc0000000) != 0) : ((__ARM_dcmp4((__x), (__y)) & 0xc0000000) != 0)); }
N    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
X    inline bool (islessgreater)(float __x, float __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? __ARM_islessgreaterf((__x), (__y)) : __ARM_islessgreater((__x), (__y))); }
N    inline bool (isnan)(float __x) { return isnan(__x); }
X    inline bool (isnan)(float __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnanf(__x) : __ARM_isnan(__x)); }
N    inline bool (isnormal)(float __x) { return isnormal(__x); }
X    inline bool (isnormal)(float __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnormalf(__x) : __ARM_isnormal(__x)); }
N    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
X    inline bool (isunordered)(float __x, float __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x10000000) == 0x10000000) : ((__ARM_dcmp4((__x), (__y)) & 0x10000000) == 0x10000000)); }
N
N#ifdef __HAVE_LONGDOUBLE
N    inline long double acosh(long double __x) { return acoshl(__x); }
N    inline long double asinh(long double __x) { return asinhl(__x); }
N    inline long double atanh(long double __x) { return atanhl(__x); }
N    inline long double cbrt(long double __x) { return cbrtl(__x); }
N    inline long double erf(long double __x) { return erfl(__x); }
N    inline long double erfc(long double __x) { return erfcl(__x); }
N    inline long double expm1(long double __x) { return expm1l(__x); }
N    inline long double log1p(long double __x) { return log1pl(__x); }
N    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
N    inline long double lgamma(long double __x) { return lgammal(__x); }
N    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
N    inline long double rint(long double __x) { return rintl(__x); }
N    inline long double exp2(long double __x) { return exp2l(__x); }
N    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
N    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
N    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
N    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
N    inline long double log2(long double __x) { return log2l(__x); }
N    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
X    inline __declspec(__nothrow) long lrint(long double __x) { return lrintl(__x); }
N    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
X    inline __declspec(__nothrow) long long llrint(long double __x) { return llrintl(__x); }
N    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
X    inline __declspec(__nothrow) long lround(long double __x) { return lroundl(__x); }
N    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
X    inline __declspec(__nothrow) long long llround(long double __x) { return llroundl(__x); }
N    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
X    inline __declspec(__nothrow) __attribute__((const)) long double nearbyint(long double __x) { return nearbyintl(__x); }
N    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
N    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
X    inline __declspec(__nothrow) __attribute__((const)) long double round(long double __x) { return roundl(__x); }
N    inline long double tgamma(long double __x) { return tgammal(__x); }
N    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
X    inline __declspec(__nothrow) __attribute__((const)) long double trunc(long double __x) { return truncl(__x); }
N    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
X    inline int (fpclassify)(long double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_fpclassifyf(__x) : __ARM_fpclassify(__x)); }
N    inline bool (isfinite)(long double __x) { return isfinite(__x); }
X    inline bool (isfinite)(long double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isfinitef(__x) : __ARM_isfinite(__x)); }
N    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
X    inline bool (isgreater)(long double __x, long double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x20000000)); }
N    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
X    inline bool (isgreaterequal)(long double __x, long double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x30000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0x30000000) == 0x20000000)); }
N    inline bool (isinf)(long double __x) { return isinf(__x); }
X    inline bool (isinf)(long double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isinff(__x) : __ARM_isinf(__x)); }
N    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
X    inline bool (isless)(long double __x, long double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x80000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x80000000)); }
N    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
X    inline bool (islessequal)(long double __x, long double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xc0000000) != 0) : ((__ARM_dcmp4((__x), (__y)) & 0xc0000000) != 0)); }
N    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
X    inline bool (islessgreater)(long double __x, long double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? __ARM_islessgreaterf((__x), (__y)) : __ARM_islessgreater((__x), (__y))); }
N    inline bool (isnan)(long double __x) { return isnan(__x); }
X    inline bool (isnan)(long double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnanf(__x) : __ARM_isnan(__x)); }
N    inline bool (isnormal)(long double __x) { return isnormal(__x); }
X    inline bool (isnormal)(long double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnormalf(__x) : __ARM_isnormal(__x)); }
N    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
X    inline bool (isunordered)(long double __x, long double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x10000000) == 0x10000000) : ((__ARM_dcmp4((__x), (__y)) & 0x10000000) == 0x10000000)); }
N#endif
N
N#undef fpclassify
N#undef isfinite
N#undef isgreater
N#undef isgreaterequal
N#undef isinf
N#undef isless
N#undef islessequal
N#undef islessgreater
N#undef isnan
N#undef isnormal
N#undef isunordered
N
N#endif
N
N  }
N#endif
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 1L && !0L
N    using ::std::__use_accurate_range_reduction;
N    #ifndef __ARMCOMPILER_LIBCXX
N      using ::std::abs;
N    #endif
N    using ::std::acos;
N    using ::std::asin;
N    using ::std::atan2;
N    using ::std::atan;
N    using ::std::ceil;
N    using ::std::cos;
N    using ::std::cosh;
N    using ::std::exp;
N    using ::std::fabs;
N    using ::std::floor;
N    using ::std::fmod;
N    using ::std::frexp;
N    using ::std::ldexp;
N    using ::std::log10;
N    using ::std::log;
N    using ::std::modf;
N    using ::std::pow;
N    using ::std::sin;
N    using ::std::sinh;
N    using ::std::sqrt;
N    using ::std::_sqrt;
N    using ::std::_sqrtf;
N    using ::std::tan;
N    using ::std::tanh;
N    using ::std::_fabsf;
N    /* C99 float and long double versions in already-C89-reserved namespace */
N    using ::std::acosf;
N    using ::std::acosl;
N    using ::std::asinf;
N    using ::std::asinl;
N    using ::std::atan2f;
N    using ::std::atan2l;
N    using ::std::atanf;
N    using ::std::atanl;
N    using ::std::ceilf;
N    using ::std::ceill;
N    using ::std::cosf;
N    using ::std::coshf;
N    using ::std::coshl;
N    using ::std::cosl;
N    using ::std::expf;
N    using ::std::expl;
N    using ::std::fabsf;
N    using ::std::fabsl;
N    using ::std::floorf;
N    using ::std::floorl;
N    using ::std::fmodf;
N    using ::std::fmodl;
N    using ::std::frexpf;
N    using ::std::frexpl;
N    using ::std::ldexpf;
N    using ::std::ldexpl;
N    using ::std::log10f;
N    using ::std::log10l;
N    using ::std::logf;
N    using ::std::logl;
N    using ::std::modff;
N    using ::std::modfl;
N    using ::std::powf;
N    using ::std::powl;
N    using ::std::sinf;
N    using ::std::sinhf;
N    using ::std::sinhl;
N    using ::std::sinl;
N    using ::std::sqrtf;
N    using ::std::sqrtl;
N    using ::std::tanf;
N    using ::std::tanhf;
N    using ::std::tanhl;
N    using ::std::tanl;
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 1L
N      /* C99 additions which for historical reasons appear in non-strict mode */
N      using ::std::acosh;
N      using ::std::asinh;
N      using ::std::atanh;
N      using ::std::cbrt;
N      using ::std::copysign;
N      using ::std::copysignf;
N      using ::std::erf;
N      using ::std::erfc;
N      using ::std::expm1;
N      using ::std::hypot;
N      using ::std::ilogb;
N      using ::std::ilogbf;
N      using ::std::ilogbl;
N      using ::std::lgamma;
N      using ::std::log1p;
N      using ::std::logb;
N      using ::std::logbf;
N      using ::std::logbl;
N      using ::std::nextafter;
N      using ::std::nextafterf;
N      using ::std::nextafterl;
N      using ::std::nexttoward;
N      using ::std::nexttowardf;
N      using ::std::nexttowardl;
N      using ::std::remainder;
N      using ::std::rint;
N      using ::std::scalbln;
N      using ::std::scalblnf;
N      using ::std::scalblnl;
N      using ::std::scalbn;
N      using ::std::scalbnf;
N      using ::std::scalbnl;
N      using ::std::math_errhandling;
N      using ::std::acoshf;
N      using ::std::acoshl;
N      using ::std::asinhf;
N      using ::std::asinhl;
N      using ::std::atanhf;
N      using ::std::atanhl;
N      using ::std::copysignl;
N      using ::std::cbrtf;
N      using ::std::cbrtl;
N      using ::std::erff;
N      using ::std::erfl;
N      using ::std::erfcf;
N      using ::std::erfcl;
N      using ::std::expm1f;
N      using ::std::expm1l;
N      using ::std::log1pf;
N      using ::std::log1pl;
N      using ::std::hypotf;
N      using ::std::hypotl;
N      using ::std::lgammaf;
N      using ::std::lgammal;
N      using ::std::remainderf;
N      using ::std::remainderl;
N      using ::std::rintf;
N      using ::std::rintl;
N      /* New in C99. */
N      using ::std::float_t;
N      using ::std::double_t;
N    #endif
N    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X    #if (0L && !0L) || 1L
N      /* Functions new in C99. */
N      using ::std::exp2;
N      using ::std::exp2f;
N      using ::std::exp2l;
N      using ::std::fdim;
N      using ::std::fdimf;
N      using ::std::fdiml;
N      using ::std::fma;
N      using ::std::fmaf;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::fmal;
N#endif
N      using ::std::fmax;
N      using ::std::fmaxf;
N      using ::std::fmaxl;
N      using ::std::fmin;
N      using ::std::fminf;
N      using ::std::fminl;
N      using ::std::log2;
N      using ::std::log2f;
N      using ::std::log2l;
N      using ::std::lrint;
N      using ::std::lrintf;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::lrintl;
N#endif
N      using ::std::llrint;
N      using ::std::llrintf;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::llrintl;
N#endif
N      using ::std::lround;
N      using ::std::lroundf;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::lroundl;
N#endif
N      using ::std::llround;
N      using ::std::llroundf;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::llroundl;
N#endif
N      using ::std::nan;
N      using ::std::nanf;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::nanl;
N#endif
N      using ::std::nearbyint;
N      using ::std::nearbyintf;
N      using ::std::nearbyintl;
N      using ::std::remquo;
N      using ::std::remquof;
N#ifdef __HAVE_LONGDOUBLE
N      using ::std::remquol;
N#endif
N      using ::std::round;
N      using ::std::roundf;
N      using ::std::roundl;
N      using ::std::tgamma;
N      using ::std::tgammaf;
N      using ::std::tgammal;
N      using ::std::trunc;
N      using ::std::truncf;
N      using ::std::truncl;
N    #endif
N
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 1L
N      using ::std::fpclassify;
N      using ::std::isfinite;
N      using ::std::isgreater;
N      using ::std::isgreaterequal;
N      using ::std::isinf;
N      using ::std::isless;
N      using ::std::islessequal;
N      using ::std::islessgreater;
N      using ::std::isnan;
N      using ::std::isnormal;
N      using ::std::isunordered;
N    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 3 "Source\Tasks\src\settings.cpp" 2
N
N#include "settings.h"
L 1 ".\Source\Tasks\inc\settings.h" 1
N#ifndef __SETTINGS_H
N#define __SETTINGS_H
N
N#pragma anon_unions
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.2.1 */
S
S    /* minimum values of exact-width signed integer types */
S#define INT8_MIN                   -128
S#define INT16_MIN                -32768
S#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
S#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
S
S    /* maximum values of exact-width signed integer types */
S#define INT8_MAX                    127
S#define INT16_MAX                 32767
S#define INT32_MAX            2147483647
S#define INT64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of exact-width unsigned integer types */
S#define UINT8_MAX                   255
S#define UINT16_MAX                65535
S#define UINT32_MAX           4294967295u
S#define UINT64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.2 */
S
S    /* minimum values of minimum-width signed integer types */
S#define INT_LEAST8_MIN                   -128
S#define INT_LEAST16_MIN                -32768
S#define INT_LEAST32_MIN          (~0x7fffffff)
S#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of minimum-width signed integer types */
S#define INT_LEAST8_MAX                    127
S#define INT_LEAST16_MAX                 32767
S#define INT_LEAST32_MAX            2147483647
S#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of minimum-width unsigned integer types */
S#define UINT_LEAST8_MAX                   255
S#define UINT_LEAST16_MAX                65535
S#define UINT_LEAST32_MAX           4294967295u
S#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.3 */
S
S    /* minimum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MIN           (~0x7fffffff)
S#define INT_FAST16_MIN          (~0x7fffffff)
S#define INT_FAST32_MIN          (~0x7fffffff)
S#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MAX             2147483647
S#define INT_FAST16_MAX            2147483647
S#define INT_FAST32_MAX            2147483647
S#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of fastest minimum-width unsigned integer types */
S#define UINT_FAST8_MAX            4294967295u
S#define UINT_FAST16_MAX           4294967295u
S#define UINT_FAST32_MAX           4294967295u
S#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.4 */
S
S    /* minimum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MIN INT64_MIN
S#else
S#define INTPTR_MIN INT32_MIN
S#endif
S
S    /* maximum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MAX INT64_MAX
S#else
S#define INTPTR_MAX INT32_MAX
S#endif
S
S    /* maximum value of pointer-holding unsigned integer type */
S#if __sizeof_ptr == 8
S#define UINTPTR_MAX UINT64_MAX
S#else
S#define UINTPTR_MAX UINT32_MAX
S#endif
S
S    /* 7.18.2.5 */
S
S    /* minimum value of greatest-width signed integer type */
S#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
S
S    /* maximum value of greatest-width signed integer type */
S#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
S
S    /* maximum value of greatest-width unsigned integer type */
S#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
S
S    /* 7.18.3 */
S
S    /* limits of ptrdiff_t */
S#if __sizeof_ptr == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
S#else
S#define PTRDIFF_MIN INT32_MIN
S#define PTRDIFF_MAX INT32_MAX
S#endif
S
S    /* limits of sig_atomic_t */
S#define SIG_ATOMIC_MIN (~0x7fffffff)
S#define SIG_ATOMIC_MAX   2147483647
S
S    /* limit of size_t */
S#if __sizeof_ptr == 8
S#define SIZE_MAX UINT64_MAX
S#else
S#define SIZE_MAX UINT32_MAX
S#endif
S
S    /* limits of wchar_t */
S    /* NB we have to undef and redef because they're defined in both
S     * stdint.h and wchar.h */
S#undef WCHAR_MIN
S#undef WCHAR_MAX
S
S#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
S#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
S#endif
S
S    /* limits of wint_t */
S#define WINT_MIN (~0x7fffffff)
S#define WINT_MAX 2147483647
S
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.4.1 macros for minimum-width integer constants */
S#define INT8_C(x)   (x)
S#define INT16_C(x)  (x)
S#define INT32_C(x)  (x)
S#define INT64_C(x)  __INT64_C(x)
S
S#define UINT8_C(x)  (x ## u)
S#define UINT16_C(x) (x ## u)
S#define UINT32_C(x) (x ## u)
S#define UINT64_C(x) __UINT64_C(x)
S
S    /* 7.18.4.2 macros for greatest-width integer constants */
S#define INTMAX_C(x)  __ESCAPE__(x ## ll)
S#define UINTMAX_C(x) __ESCAPE__(x ## ull)
S
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDINT_NO_EXPORTS
N      using ::std::int8_t;
N      using ::std::int16_t;
N      using ::std::int32_t;
N      using ::std::int64_t;
N      using ::std::uint8_t;
N      using ::std::uint16_t;
N      using ::std::uint32_t;
N      using ::std::uint64_t;
N      using ::std::int_least8_t;
N      using ::std::int_least16_t;
N      using ::std::int_least32_t;
N      using ::std::int_least64_t;
N      using ::std::uint_least8_t;
N      using ::std::uint_least16_t;
N      using ::std::uint_least32_t;
N      using ::std::uint_least64_t;
N      using ::std::int_fast8_t;
N      using ::std::int_fast16_t;
N      using ::std::int_fast32_t;
N      using ::std::int_fast64_t;
N      using ::std::uint_fast8_t;
N      using ::std::uint_fast16_t;
N      using ::std::uint_fast32_t;
N      using ::std::uint_fast64_t;
N      using ::std::intptr_t;
N      using ::std::uintptr_t;
N      using ::std::intmax_t;
N      using ::std::uintmax_t;
N    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 7 ".\Source\Tasks\inc\settings.h" 2
N
N#include "sens_types.h"
L 1 ".\Source\Line\inc\sens_types.h" 1
N#ifndef __SENS_TYPES_H
N#define __SENS_TYPES_H
N
N/*   ,      
N*/
N
N#include <stdint.h>
N
N////// 
N#define OPT_UART 0x80	//  UART
N#define SAVEDATA 0x20   //     
N#define SAVETC   0x10	//   
N
N////       
N//typedef __packed struct
N//{
N//	uint16_t TC;			//  ,   
N//	int16_t TCst;			//   ,  1/10  
N//	uint16_t AC[11]; 	//    
N//} TPTTab;
N
N////   
N//typedef __packed struct
N//{
N//	float P0;      //  
N//	float Pdlt;    //  	
N//	TPTTab pt[10];	//   
N//} TTCTab;
N
Ntypedef enum
N{
N  _N_OPENED = 0, //
N  _N_CLOSED = 1, //
N  
N  _N_MAX    = _N_CLOSED + 1,
N} TContact;
N
Ntypedef enum
N{
N  __BASE         = 0U,
N  __OTHER_MASTER = 1U, 
N} TInterconn;
N
Ntypedef __packed struct
N{
N  uint8_t Thr;            //   
N  uint8_t Hyst;           //
N  int8_t  Bias;           //
N  uint8_t AxisRotate;     //   (  ) /  (  )
N  uint8_t SensAxisRotate; //   (  ) /   (  )
N  int8_t  RollBiasAngle;  // 
N  int8_t  PitchBiasAngle; // 
N} TDevSets;
N
Ntypedef __packed union TBits
N{
N  __packed struct
N  {
W ".\Source\Line\inc\sens_types.h" 59 28 bit field cannot contain all values of the enumerated type
N    TContact   Normal    : 1; //0 - ; 1 - 
N    TInterconn Interconn : 1; //   (     )
N    uint8_t    Reserved1 : 6;   
N  } Item;
N  uint8_t Byte;
N} TBits;
N
Ntypedef __packed struct
N{
N  TBits   Bits;
N  uint8_t Reserved2;
N  uint8_t Reserved3;
N} T_ADPBITS;
N
Ntypedef __packed struct
N{
N  uint8_t MBAddr; // Modbus
N  uint8_t USpeed; // 
N  uint8_t UPar;   //    
N} TIf;
N
Ntypedef __packed struct 
N{
N/* 
N*/
N  uint8_t Addr;        //    
N  float   PswAdmin;    // 
N  float   PswSuper;    // 
N  
N/*  
N*/
N  TDevSets DevSets;    //        1 
N  T_ADPBITS AdpBits;
N  
N/*  
N*/
N  TIf If;
N} MySettings;
N
N// 
Ntypedef struct 
N{
N/* 
N*/
N  float HC1_Angle;       //,    
N  float HC2_Angle;       //,    
N  float SysStatus;       //
N  float PTemper;         //    
N
N/*   
N*/
N  float srab;            // ,  	EPRM
N  uint32_t errcode;      //   ERRCODE
N  
N} CurData;
N
Ntypedef struct
N{
N  uint8_t Len;
N  uint8_t Addr;
N  uint8_t Cmd;	 
N} TPre;                  //       
N
Ntypedef struct
N{
N  TPre    Pre;
N  uint8_t CalCmd; //  
N} TDataReq;
N
Ntypedef struct
N{
N  TPre Pre;
N  uint8_t Res; //  
N  uint8_t CalCmd; //  
N} TDataAns;
N
Nenum TCalResult
N{
N  _DENY       = 0x00, //  
N  _SLOW       = 0x55, //  
N  _SUCCESS    = 0x5A, // 
N  _PARAMS_REQ = 0x20  //   
N};
N
Nenum TPntFlag
N{
N  _FAILURE     =   0, //  
N  _PERFORMING  =  85, // 
N  _DONE        =  90, //
N  _NO_CMD_EXEC =  99, //      
N  _IMPOSSIBLE  = 255, // 
N  _REQ         =   7, //  
N  _INTERM      =   1, // 
N  _UNKNOWN     =   8  //!        
N};
N
Nenum TCalCmd
N{
N  _PLATFORM_CAL = 0x01,
N  _HC_1_CAL     = 0x02,
N  _HC_2_CAL     = 0x03  
N};
N
Nextern MySettings HardDSt;
Nextern MySettings DSt;
Nextern const MySettings DefDSt;
N
Nextern CurData cdt;
N
Nextern uint8_t MainFlags;
N
Nvoid SetMainFlag(uint8_t Flag); //  " "
N
N#endif
L 9 ".\Source\Tasks\inc\settings.h" 2
N
Nnamespace CONSTS
N{
N  constexpr int16_t MIN_DEV_ANGLE        = -80;
N  constexpr int16_t MAX_DEV_ANGLE        = 260;
N                                         
N  constexpr int16_t MAX_BASE_ANGLE       =  70; //  ,    
N  constexpr int16_t MIN_BASE_ANGLE       = -70; //  ,    
N  constexpr int16_t HYST_BASE_ANGLE      =  10;
N                                         
N  constexpr int16_t THR_ERR_OPEN_ANGLE   = -15;
N  constexpr int16_t HYST_ERR_OPEN_ANGLE  =   5;
N  
N  constexpr int16_t THR_SENS_OPEN_ANGLE  =  70;
N  constexpr int16_t HYST_SENS_OPEN_ANGLE =  10;
N  
N  constexpr float   DAMP_COEFF           =   2.0f;
N}
N
N
Nclass TSettings
N{
Npublic:
N  
N  enum TLedMode : uint8_t
N  {
N    __CONST_OFF = 0,
N    __CONST_ON  = 1,
N    __BLINK_1_S = 2,
N  };
N
N  enum TPress : uint8_t
N  {
N    __RELEASE                 = 0, // 
N    __START_HOLD              = 1, //    (   )
N    __HOLD_EQ_OR_MORE_1_SEC   = 2, //  1 
N    __HOLD_EQ_OR_MORE_3_5_SEC = 3, //  3,5 
N    __RELEASE_LESS_1_SEC      = 4, //    <= 1  ( )
N    __RELEASE_LESS_3_5_SEC    = 5, //    > 1 ,  <= 3,5  ( )
N    __RELEASE_MORE_3_5_SEC    = 6, //    > 3,5  ( )
N    
N    __MAX_PRESS               = __RELEASE_MORE_3_5_SEC + 1U,
N  };
N	
N  enum TAccess : uint8_t
N  {
N    __USER       = 0U,
N    __ADMIN      = 1U,
N    __SUPER      = 2U,
N    
N    __ACCESS_MAX = __SUPER + 1U,
N  };
N
N  enum TAxisRotate : uint8_t
N  {
N    __0_DEG      = 0,
N    __90_DEG     = 1,
N    __180_DEG    = 2,
N    __270_DEG    = 3,
N    
N    __MAX_ROTATE = __270_DEG + 1,
N  };
N
N  enum TDevType : uint8_t
N  {
N    _BASE      = 0, //  (    )
N    _HC        = 1, //   (     )
N    _UNDEFINED = 2, //     (. )
N
N		_MAX       = _HC + 1,
N  };
N
N  enum TConnect : bool
N  {
N    _NOT = 0,
N    _YES = 1,
N  };
N
N  enum TPosErr : bool
N  {
N    _POS_ERR = 0,
N    _POS_OK  = 1,
N  };
N  
N  enum THC : bool
N  {
N    _CLOSED = 0,
N    _OPENED = 1,
N    
N    _HC_MAX = _OPENED + 1,
N  };
N  
N  enum TCalibProcess : uint8_t
N  {
N    __DENY            = 10U, //  
N    __PERFORMING      = 85U, // 
N    __PERFORMED       = 90U, //
N    __NEVER_PERFORMED = 99U, //     
N  };
N	
N	enum TCalib : bool
N	{
N	  __UNCALIBRATED = 0U,
N		__CALIBRATED   = 1U,
N	};
N	
N	enum TMainState : bool
N	{
N		__ERR = 0U,
N	  __OK  = 1U,
N	};
N	
N	__packed union TState
N	{
N    __packed struct
N    {
W ".\Source\Tasks\inc\settings.h" 125 34 bit field cannot contain all values of the enumerated type
N      THC        HC            : 1; //  ( 0-; 1- )                            (  -   ; \
N                                                                                                              -  )
X      THC        HC            : 1; 
N      TPosErr    HC_PosErr     : 1; //  ( 0- ; 1-   )
N      TPosErr    Base_PosErr   : 1; //  ( 0- ; 1-   )        (    )
N      TConnect   Connect       : 1; //     ( 0-; 1- )                         (    )
N      TCalib     AccCalib      : 1; //   ,    ( 0- ; 1- )
N      TCalib     HC_AccCalib   : 1; //    ( 0- ; 1- ) (   )
N      TMainState HC_Mems       : 1; //    ( 0-- ; 1- )
N      TMainState Base_Mems     : 1; //    ( 0-- ; 1- )
N    };
N    uint8_t Total;
N	};
N
N  enum TValidSign : bool
N  {
N    __INVALID = 0U,
N    __VALID   = 1U,
N  };
N  
N  enum TMeas : bool
N  {
N    __STOP_MEAS  = 0U,
N    __START_MEAS = 1U,
N  };
N  
N  __packed union TCommunicate
N  {
N    uint8_t Val;
N    __packed struct
N    {
N      TValidSign SampleValidSign : 1; //    ( 0 - invalid; 1 - valid )
N      TMeas StartMeasCmd         : 1; //         
N      uint8_t Reserved           : 6;
N    };
N  };
N  
N  __packed struct TSens
N  {
N    uint8_t    CodeSw;          //      (    )
N    uint16_t   ProgNbr;         //    (    )
N    int16_t    Angle;           //   (    )
N    TValidSign SampleValidSign; //    ( 0 - invalid; 1 - valid )
N//    uint8_t    AxisRotate;      // 
N    uint8_t    BufAxisRotate;   //  
N    int8_t     RollBiasAngle;   //    (  )
N    int8_t     PitchBiasAngle;  //    (  )
N  };
N
N  __packed struct TDevData
N  {
N    uint8_t       CodeSw;           //    ,    
N    TSens         Sens;             // ,    
N	  float         OpenAngle;        // , (   )
N		TState        State;            //               
N		int16_t       MyAngle;          //  
N    int8_t        RawRoll;          //  
N    int8_t        RawPitch;         //  
N    float         AccelZ;           //   Z
N    TCalibProcess CalibProcess;     //   
N    uint32_t      CalibPositionCtr; //  
N    float         CalibParameter;   // 
N    uint8_t       TransactSign;     //     
N		TAccess       Access;           //    
N    const void   *AuthorizeItemPtr; //  
N    TCommunicate  Communicate;      //    
N    float         PdPressure;       //    ()
N  };
N  
N  enum TIsFlashProg : uint8_t
N  {
N    _PROGRAMMED   = 0x00,
N    _UNPROGRAMMED = 0xFF,
N  };
N
N  enum TIsAccCalib : uint8_t
N  {
N    _ACC_CALIBRATED   = 0x00,
N    _ACC_UNCALIBRATED = 0xFF,
N  };
N  
N  enum TBootModeFlag : uint16_t
N  {
N    __WORK_MODE = 0xFFFF,
N    __BOOT_MODE = 0xA55A,
N  };
N
N  __packed struct TAccelData
N  {
N    float X;                    //     X
N    float Y;                    //     Y
N    float Z;                    //     Z
N  };                            
N                                
N  __packed struct TAccCalData            
N  {
N    TAccelData  Offset;         //    g
N    TAccelData  Gain;           //Scale Factor  
N  };
N
N  __packed struct TFlashData //,   Flash- 
N  {
N    TBootModeFlag BootModeFlag; //   
N    TIsFlashProg  IsFlashProg;  //  Flash   ( 0x00 - ; 0xFF -   )
N    TIsAccCalib   IsAccCalib;   //   ( 0x00 - ;      0xFF -   )
N    MySettings    AllSets;      //  
N    TAccCalData   AccCalData;   //  
N  };
N
N  struct TRange
N  {
N    int16_t Min;
N    int16_t Max;
N  };
N
Npublic:
N  TSettings();
N  ~TSettings();
N
N  void chk_dev( MySettings & );
N//  void chk_if(
N//              uint8_t BaudRateNbr,
N//              uint8_t ParityAndStopsNbr
N//             );
N             
N  bool chk_thr( int16_t ) const;              //     
N  bool chk_hyst( int16_t ) const;             //      
N  bool chk_bias( int16_t ) const;             //    
N  bool chk_axis_rotate( int16_t ) const;      //   
N  bool chk_roll_bias_angle( int16_t ) const;  //  
N  bool chk_pitch_bias_angle( int16_t ) const; //  
N  bool chk_mb_addr( int16_t ) const;          // Modbus-
N  bool chk_u_baud_rate( int16_t ) const;      //      USART
N  bool chk_u_par( int16_t ) const;            //   -      USART
N  bool chk_calib( int16_t ) const;            //  
N  bool chk_access( int16_t ) const;           //    
Nprotected:
N  const TRange  __THR;              //       
N  const TRange  __HYST;             //        
N  const TRange  __BIAS;             //      
N  const TRange  __AXIS_ROTATE;      //    
N  const TRange  __ROLL_BIAS_ANGLE;  //     
N  const TRange  __PITCH_BIAS_ANGLE; //     
N  const int16_t __LOW_DIF;          //      ""
N  const TRange  __MB_ADDR;          //   Modbus-
N  const TRange  __U_SPEED;          //        USART
N  const TRange  __U_PAR;            //     -      USART
N  const TRange  __CALIB;            //    
N  const TRange  __ACCESS;           //     
Nprivate:
N
N  template< typename T >
N  bool chk_param( const TRange &Range, T Param ) const //true =>     
N  {
N    return (
N            Param >= Range.Min
N            &&
N            Param <= Range.Max
N           );
N  }
N
N};
N
N#endif //__SETTINGS_H
L 5 "Source\Tasks\src\settings.cpp" 2
N#include "main.h"
L 1 ".\Source\Main\inc\main.h" 1
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MAIN_H
N#define __MAIN_H
N
N//#pragma anon_unions
N
N  /* Includes ------------------------------------------------------------------*/
N//#include <bitset>
N
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
S    #define bool _Bool
S    #define true 1
S    #define false 0
N  #else
N    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
N    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 11 ".\Source\Main\inc\main.h" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS ::std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S   /* unconditional in non-strict C for consistency of debug info */
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
S  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 1L && 1L 
N    /* atexit that takes a ptr to a function with C++ linkage 
N     * but not in GNU mode  
N     */
N    typedef void (* __C_exitfuncptr)();
N    extern "C++"
N    inline int atexit(void (* __func)()) {
N      return atexit((__C_exitfuncptr)__func);
N    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 1L && 1L
N    /* bsearch that takes a ptr to a function with C++ linkage 
N     * but not in GNU mode
N     */
N    typedef int (* __C_compareprocptr)(const void *, const void *);
N    extern "C++"
N    void *bsearch(const void * __key, const void * __base,
N              size_t __nmemb, size_t __size,
N              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N    extern "C++"
N    inline void *bsearch(const void * __key, const void * __base,
N              size_t __nmemb, size_t __size,
N              int (* __compar)(const void *, const void *)) {
N      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
N    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 1L && 1L
N    /* qsort that takes a ptr to a function with C++ linkage 
N     * but not in GNU mode
N     */    
N    extern "C++"
N    void qsort(void * __base, size_t __nmemb, size_t __size,
N               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N    extern "C++"
N    inline void qsort(void * __base, size_t __nmemb, size_t __size,
N                      int (* __compar)(const void *, const void *)) {
N      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
N    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) ldiv_t div(long int __numer, long int __denom) {
N       return ldiv(__numer, __denom);
N   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) long long abs(long long x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) lldiv_t div(long long __numer, long long __denom) {
N       return lldiv(__numer, __denom);
N   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
N    #ifndef __STDLIB_NO_EXPORTS
N      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X      #if !0L || 1
N        using ::std::atoll;
N        using ::std::lldiv_t;
N      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
N      using ::std::div_t;
N      using ::std::ldiv_t;
N      using ::std::atof;
N      using ::std::atoi;
N      using ::std::atol;
N      using ::std::strtod;
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
N      using ::std::strtof;
N      using ::std::strtold;
N#endif
N      using ::std::strtol;
N      using ::std::strtoul;
N      using ::std::strtoll;
N      using ::std::strtoull;
N      using ::std::rand;
N      using ::std::srand;
N      using ::std::_rand_state;
N      using ::std::_rand_r;
N      using ::std::_srand_r;
N      using ::std::_ANSI_rand_state;
N      using ::std::_ANSI_rand_r;
N      using ::std::_ANSI_srand_r;
N      using ::std::calloc;
N      using ::std::free;
N      using ::std::malloc;
N      using ::std::realloc;
N#if !defined(__STRICT_ANSI__)
X#if !0L
N      using ::std::posix_memalign;
N#endif
N      using ::std::__heapprt;
N      using ::std::__heapstats;
N      using ::std::__heapvalid;
N      using ::std::abort;
N      using ::std::atexit;
N      using ::std::exit;
N      using ::std::_Exit;
N      using ::std::getenv;
N      using ::std::system;
N      using ::std::bsearch;
N      using ::std::qsort;
N      using ::std::abs;
N      using ::std::div;
N      using ::std::labs;
N      using ::std::ldiv;
N      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X      #if !0L || 1
N        using ::std::llabs;
N        using ::std::lldiv;
N      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N      using ::std::__sdiv32by16;
N      using ::std::__udiv32by16;
N      using ::std::__sdiv64by32;
N      using ::std::__rt_sdiv32by16;
N      using ::std::__rt_udiv32by16;
N      using ::std::__rt_sdiv64by32;
N#endif
N      using ::std::__fp_status;
N      using ::std::mblen;
N      using ::std::mbtowc;
N      using ::std::wctomb;
N      using ::std::mbstowcs;
N      using ::std::wcstombs;
N      using ::std::__use_realtime_heap;
N      using ::std::__use_realtime_division;
N      using ::std::__use_two_region_memory;
N      using ::std::__use_no_heap;
N      using ::std::__use_no_heap_region;
N      using ::std::__C_library_version_string;
N      using ::std::__C_library_version_number;
N      using ::std::size_t;
N      using ::std::__aeabi_MB_CUR_MAX;
N    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 12 ".\Source\Main\inc\main.h" 2
N#include <stdint.h>
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
N      namespace std {
N      #define __CLIBNS ::std::
N        extern "C" {
N    #else /* ndef __cplusplus */
S      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 1L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !1L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (1L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !1L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
N    inline int getchar() { return getc(stdin); }
X    inline int getchar() { return getc((& ::std:: __stdin)); }
N#else
S    #define getchar() getc(stdin)
S    extern _ARMABI int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
N    inline int putchar(int __c) { return putc(__c, stdout); }
X    inline int putchar(int __c) { return putc(__c, (& ::std:: __stdout)); }
N#else
S    #define putchar(c) putc(c, stdout)
S    extern _ARMABI int (putchar)(int /*c*/);
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 1L && !0L
N    using ::std::size_t;
N    using ::std::fpos_t;
N    using ::std::FILE;
N    using ::std::remove;
N    using ::std::rename;
N    using ::std::tmpfile;
N    using ::std::tmpnam;
N    using ::std::fclose;
N    using ::std::fflush;
N    using ::std::fopen;
N    using ::std::freopen;
N    using ::std::setbuf;
N    using ::std::setvbuf;
N    using ::std::fprintf;
N    using ::std::_fprintf;
N    using ::std::printf;
N    using ::std::_printf;
N    using ::std::sprintf;
N    using ::std::_sprintf;
N    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N      using ::std::snprintf;
N      using ::std::vsnprintf;
N      using ::std::vfscanf;
N      using ::std::vscanf;
N      using ::std::vsscanf;
N    #endif
N    using ::std::_snprintf;
N    using ::std::_vsnprintf;
N#if !defined(__STRICT_ANSI__)
X#if !0L
N    using ::std::asprintf;
N    using ::std::vasprintf;
N#endif
N    using ::std::__ARM_asprintf;
N    using ::std::__ARM_vasprintf;
N    using ::std::__ARM_vsnprintf;
N    using ::std::__ARM_snprintf;
N    using ::std::__ARM_vsscanf;
N    using ::std::fscanf;
N    using ::std::_fscanf;
N    using ::std::scanf;
N    using ::std::_scanf;
N    using ::std::sscanf;
N    using ::std::_sscanf;
N    using ::std::_vfscanf;
N    using ::std::_vscanf;
N    using ::std::_vsscanf;
N    using ::std::vprintf;
N    using ::std::_vprintf;
N    using ::std::vfprintf;
N    using ::std::_vfprintf;
N    using ::std::vsprintf;
N    using ::std::_vsprintf;
N    using ::std::fgetc;
N    using ::std::fgets;
N    using ::std::fputc;
N    using ::std::fputs;
N    using ::std::getc;
N    using ::std::getchar;
N    using ::std::gets;
N    using ::std::putc;
N    using ::std::putchar;
N    using ::std::puts;
N    using ::std::ungetc;
N    using ::std::fread;
N    using ::std::__fread_bytes_avail;
N    using ::std::fwrite;
N    using ::std::fgetpos;
N    using ::std::fseek;
N    using ::std::fsetpos;
N    using ::std::ftell;
N    using ::std::rewind;
N    using ::std::clearerr;
N    using ::std::feof;
N    using ::std::ferror;
N    using ::std::perror;
N    using ::std::_fisatty;
N    using ::std::__use_no_semihosting_swi;
N    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 14 ".\Source\Main\inc\main.h" 2
N#include <math.h>
N
N//#include "data_types.h"  //    
N
N//#include "USART_driver.h"
N//#include "CAN_driver.h"
N//#include "motion_tl.h"
N#include "relay.h"
L 1 ".\Source\Ext_Dev\inc\relay.h" 1
N#ifndef _RELAY_H 
N#define _RELAY_H
N
N#include "lib.h"
L 1 ".\Source\Main\inc\lib.h" 1
N#ifndef __LIB_H
N#define __LIB_H
N
N
N//----- Low-layer API --------------------------------------------------------------------------
N#include "stm32l4xx_ll_usart.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_usart.h
N  * @author  MCD Application Team
N  * @brief   Header file of USART LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_USART_H
N#define __STM32L4xx_LL_USART_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
L 1 ".\Source\Core\inc\stm32l4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32L4xx Device Peripheral Access Layer Header File.
N  *
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The STM32L4xx device used in the target application
N  *              - To use or not the peripherals drivers in application code(i.e.
N  *                code will be based on direct access to peripherals registers
N  *                rather than drivers API), this option is controlled by
N  *                "#define USE_HAL_DRIVER"
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32l4xx
N  * @{
N  */
N
N#ifndef __STM32L4xx_H
N#define __STM32L4xx_H
N
N#ifdef __cplusplus
N extern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N
N/**
N  * @brief STM32 Family
N  */
N#if !defined (STM32L4)
X#if !0L
N#define STM32L4
N#endif /* STM32L4 */
N
N/* Uncomment the line below according to the target STM32L4 device used in your
N   application
N  */
N
N#if !defined (STM32L412xx) && !defined (STM32L422xx) && \
N    !defined (STM32L431xx) && !defined (STM32L432xx) && !defined (STM32L433xx) && !defined (STM32L442xx) && !defined (STM32L443xx) && \
N    !defined (STM32L451xx) && !defined (STM32L452xx) && !defined (STM32L462xx) && \
N    !defined (STM32L471xx) && !defined (STM32L475xx) && !defined (STM32L476xx) && !defined (STM32L485xx) && !defined (STM32L486xx) && \
N    !defined (STM32L496xx) && !defined (STM32L4A6xx) && \
N    !defined (STM32L4R5xx) && !defined (STM32L4R7xx) && !defined (STM32L4R9xx) && !defined (STM32L4S5xx) && !defined (STM32L4S7xx) && !defined (STM32L4S9xx)
X#if !0L && !0L &&     !1L && !0L && !0L && !0L && !0L &&     !0L && !0L && !0L &&     !0L && !0L && !0L && !0L && !0L &&     !0L && !0L &&     !0L && !0L && !0L && !0L && !0L && !0L
S  /* #define STM32L412xx */   /*!< STM32L412xx Devices */
S  /* #define STM32L422xx */   /*!< STM32L422xx Devices */
S  /* #define STM32L431xx */   /*!< STM32L431xx Devices */
S  /* #define STM32L432xx */   /*!< STM32L432xx Devices */
S  /* #define STM32L433xx */   /*!< STM32L433xx Devices */
S  /* #define STM32L442xx */   /*!< STM32L442xx Devices */
S  /* #define STM32L443xx */   /*!< STM32L443xx Devices */
S  /* #define STM32L451xx */   /*!< STM32L451xx Devices */
S  /* #define STM32L452xx */   /*!< STM32L452xx Devices */
S  /* #define STM32L462xx */   /*!< STM32L462xx Devices */
S  /* #define STM32L471xx */   /*!< STM32L471xx Devices */
S  /* #define STM32L475xx */   /*!< STM32L475xx Devices */
S  /* #define STM32L476xx */   /*!< STM32L476xx Devices */
S  /* #define STM32L485xx */   /*!< STM32L485xx Devices */
S  /* #define STM32L486xx */   /*!< STM32L486xx Devices */
S  /* #define STM32L496xx */   /*!< STM32L496xx Devices */
S  /* #define STM32L4A6xx */   /*!< STM32L4A6xx Devices */
S  /* #define STM32L4R5xx */   /*!< STM32L4R5xx Devices */
S  /* #define STM32L4R7xx */   /*!< STM32L4R7xx Devices */
S  /* #define STM32L4R9xx */   /*!< STM32L4R9xx Devices */
S  /* #define STM32L4S5xx */   /*!< STM32L4S5xx Devices */
S  /* #define STM32L4S7xx */   /*!< STM32L4S7xx Devices */
S  /* #define STM32L4S9xx */   /*!< STM32L4S9xx Devices */
N#endif
N
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N#if !defined  (USE_HAL_DRIVER)
X#if !0L
N/**
N * @brief Comment the line below if you will not use the peripherals drivers.
N   In this case, these drivers will not be included and the application code will
N   be based on direct access to peripherals registers
N   */
N  /*#define USE_HAL_DRIVER */
N#endif /* USE_HAL_DRIVER */
N
N/**
N  * @brief CMSIS Device version number
N  */
N#define __STM32L4_CMSIS_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __STM32L4_CMSIS_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
N#define __STM32L4_CMSIS_VERSION_SUB2   (0x01) /*!< [15:8]  sub2 version */
N#define __STM32L4_CMSIS_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
N#define __STM32L4_CMSIS_VERSION        ((__STM32L4_CMSIS_VERSION_MAIN << 24)\
N                                       |(__STM32L4_CMSIS_VERSION_SUB1 << 16)\
N                                       |(__STM32L4_CMSIS_VERSION_SUB2 << 8 )\
N                                       |(__STM32L4_CMSIS_VERSION_RC))
X#define __STM32L4_CMSIS_VERSION        ((__STM32L4_CMSIS_VERSION_MAIN << 24)                                       |(__STM32L4_CMSIS_VERSION_SUB1 << 16)                                       |(__STM32L4_CMSIS_VERSION_SUB2 << 8 )                                       |(__STM32L4_CMSIS_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Device_Included
N  * @{
N  */
N
N#if defined(STM32L412xx)
X#if 0L
S  #include "stm32l412xx.h"
S#elif defined(STM32L422xx)
X#elif 0L
S  #include "stm32l422xx.h"
N#elif defined(STM32L431xx)
X#elif 1L
N  #include "stm32l431xx.h"
L 1 ".\Source\Core\inc\stm32l431xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l431xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32L431xx Device Peripheral Access Layer Header File.
N  *
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup stm32l431xx
N  * @{
N  */
N
N#ifndef __STM32L431xx_H
N#define __STM32L431xx_H
N
N#ifdef __cplusplus
N extern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N  * @brief Configuration of the Cortex-M4 Processor and Core Peripherals
N   */
N#define __CM4_REV                 0x0001  /*!< Cortex-M4 revision r0p1                       */
N#define __MPU_PRESENT             1       /*!< STM32L4XX provides an MPU                     */
N#define __NVIC_PRIO_BITS          4       /*!< STM32L4XX uses 4 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0       /*!< Set to 1 if different SysTick Config is used  */
N#define __FPU_PRESENT             1       /*!< FPU present                                   */
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_interrupt_number_definition
N  * @{
N  */
N
N/**
N * @brief STM32L4XX Interrupt Number Definition, according to the selected device
N *        in @ref Library_configuration_section
N */
Ntypedef enum
N{
N/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Cortex-M4 Non Maskable Interrupt                                */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M4 Hard Fault Interrupt                                  */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
N/******  STM32 specific Interrupt Numbers **********************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
N  PVD_PVM_IRQn                = 1,      /*!< PVD/PVM1/PVM2/PVM3/PVM4 through EXTI Line detection Interrupts    */
N  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
N  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                                   */
N  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                                   */
N  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                                   */
N  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                                   */
N  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                                   */
N  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                                   */
N  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                                   */
N  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                             */
N  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
N  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
N  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
N  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
N  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break interrupt and TIM15 global interrupt                   */
N  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM16 global interrupt                  */
N  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt                            */
N  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
N  SDMMC1_IRQn                 = 49,     /*!< SDMMC1 global Interrupt                                           */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
N  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
N  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
N  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                                   */
N  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                                   */
N  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                                   */
N  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                                   */
N  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                                   */
N  COMP_IRQn                   = 64,     /*!< COMP1 and COMP2 Interrupts                                        */
N  LPTIM1_IRQn                 = 65,     /*!< LP TIM1 interrupt                                                 */
N  LPTIM2_IRQn                 = 66,     /*!< LP TIM2 interrupt                                                 */
N  DMA2_Channel6_IRQn          = 68,     /*!< DMA2 Channel 6 global interrupt                                   */
N  DMA2_Channel7_IRQn          = 69,     /*!< DMA2 Channel 7 global interrupt                                   */
N  LPUART1_IRQn                = 70,     /*!< LP UART1 interrupt                                                */
N  QUADSPI_IRQn                = 71,     /*!< Quad SPI global interrupt                                         */
N  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
N  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
N  SAI1_IRQn                   = 74,     /*!< Serial Audio Interface 1 global interrupt                         */
N  SWPMI1_IRQn                 = 76,     /*!< Serial Wire Interface 1 global interrupt                          */
N  TSC_IRQn                    = 77,     /*!< Touch Sense Controller global interrupt                           */
N  RNG_IRQn                    = 80,     /*!< RNG global interrupt                                              */
N  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
N  CRS_IRQn                    = 82      /*!< CRS global interrupt                                              */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm4.h"             /* Cortex-M4 processor and core peripherals */
L 1 ".\Source\Core\inc\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x04U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1U)
X    #if (1 == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 ".\Source\Core\inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 ".\Source\Core\inc\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x04U) == 0x04U) || ((0x04U) == 0x07U)
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x04U) >= 0x04U)   
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 ".\Source\Core\inc\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 211 ".\Source\Core\inc\core_cm4.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 ".\Source\Core\inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 212 ".\Source\Core\inc\core_cm4.h" 2
N#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
L 1 ".\Source\Core\inc\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 213 ".\Source\Core\inc\core_cm4.h" 2
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
N  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 4)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 4)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 4)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 4)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 4) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 166 ".\Source\Core\inc\stm32l431xx.h" 2
N#include "system_stm32l4xx.h"
L 1 ".\Source\Core\inc\system_stm32l4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32l4xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS Cortex-M4 Device System Source File for STM32L4xx devices.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32l4xx_system
N  * @{
N  */
N
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32L4XX_H
N#define __SYSTEM_STM32L4XX_H
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/** @addtogroup STM32L4xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32L4xx_System_Exported_Variables
N  * @{
N  */
N  /* The SystemCoreClock variable is updated in three ways:
N      1) by calling CMSIS function SystemCoreClockUpdate()
N      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
N      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
N         Note: If you use this function to configure the system clock; then there
N               is no need to call the 2 first functions listed above, since SystemCoreClock
N               variable is updated automatically.
N  */
Nextern uint32_t SystemCoreClock;            /*!< System Clock Frequency (Core Clock) */
N
Nextern const uint8_t  AHBPrescTable[16];    /*!< AHB prescalers table values */
Nextern const uint8_t  APBPrescTable[8];     /*!< APB prescalers table values */
Nextern const uint32_t MSIRangeTable[12];    /*!< MSI ranges table values     */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32L4xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32L4xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32L4xx_System_Exported_Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /*__SYSTEM_STM32L4XX_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 167 ".\Source\Core\inc\stm32l431xx.h" 2
N#include <stdint.h>
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */
N
N/**
N  * @brief Analog to Digital Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< ADC interrupt and status register,             Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< ADC interrupt enable register,                 Address offset: 0x04 */
X  volatile uint32_t IER;           
N  __IO uint32_t CR;           /*!< ADC control register,                          Address offset: 0x08 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR;         /*!< ADC configuration register 1,                  Address offset: 0x0C */
X  volatile uint32_t CFGR;          
N  __IO uint32_t CFGR2;        /*!< ADC configuration register 2,                  Address offset: 0x10 */
X  volatile uint32_t CFGR2;         
N  __IO uint32_t SMPR1;        /*!< ADC sampling time register 1,                  Address offset: 0x14 */
X  volatile uint32_t SMPR1;         
N  __IO uint32_t SMPR2;        /*!< ADC sampling time register 2,                  Address offset: 0x18 */
X  volatile uint32_t SMPR2;         
N       uint32_t RESERVED1;    /*!< Reserved,                                                      0x1C */
N  __IO uint32_t TR1;          /*!< ADC analog watchdog 1 threshold register,      Address offset: 0x20 */
X  volatile uint32_t TR1;           
N  __IO uint32_t TR2;          /*!< ADC analog watchdog 2 threshold register,      Address offset: 0x24 */
X  volatile uint32_t TR2;           
N  __IO uint32_t TR3;          /*!< ADC analog watchdog 3 threshold register,      Address offset: 0x28 */
X  volatile uint32_t TR3;           
N       uint32_t RESERVED2;    /*!< Reserved,                                                      0x2C */
N  __IO uint32_t SQR1;         /*!< ADC group regular sequencer register 1,        Address offset: 0x30 */
X  volatile uint32_t SQR1;          
N  __IO uint32_t SQR2;         /*!< ADC group regular sequencer register 2,        Address offset: 0x34 */
X  volatile uint32_t SQR2;          
N  __IO uint32_t SQR3;         /*!< ADC group regular sequencer register 3,        Address offset: 0x38 */
X  volatile uint32_t SQR3;          
N  __IO uint32_t SQR4;         /*!< ADC group regular sequencer register 4,        Address offset: 0x3C */
X  volatile uint32_t SQR4;          
N  __IO uint32_t DR;           /*!< ADC group regular data register,               Address offset: 0x40 */
X  volatile uint32_t DR;            
N       uint32_t RESERVED3;    /*!< Reserved,                                                      0x44 */
N       uint32_t RESERVED4;    /*!< Reserved,                                                      0x48 */
N  __IO uint32_t JSQR;         /*!< ADC group injected sequencer register,         Address offset: 0x4C */
X  volatile uint32_t JSQR;          
N       uint32_t RESERVED5[4]; /*!< Reserved,                                               0x50 - 0x5C */
N  __IO uint32_t OFR1;         /*!< ADC offset register 1,                         Address offset: 0x60 */
X  volatile uint32_t OFR1;          
N  __IO uint32_t OFR2;         /*!< ADC offset register 2,                         Address offset: 0x64 */
X  volatile uint32_t OFR2;          
N  __IO uint32_t OFR3;         /*!< ADC offset register 3,                         Address offset: 0x68 */
X  volatile uint32_t OFR3;          
N  __IO uint32_t OFR4;         /*!< ADC offset register 4,                         Address offset: 0x6C */
X  volatile uint32_t OFR4;          
N       uint32_t RESERVED6[4]; /*!< Reserved,                                               0x70 - 0x7C */
N  __IO uint32_t JDR1;         /*!< ADC group injected rank 1 data register,       Address offset: 0x80 */
X  volatile uint32_t JDR1;          
N  __IO uint32_t JDR2;         /*!< ADC group injected rank 2 data register,       Address offset: 0x84 */
X  volatile uint32_t JDR2;          
N  __IO uint32_t JDR3;         /*!< ADC group injected rank 3 data register,       Address offset: 0x88 */
X  volatile uint32_t JDR3;          
N  __IO uint32_t JDR4;         /*!< ADC group injected rank 4 data register,       Address offset: 0x8C */
X  volatile uint32_t JDR4;          
N       uint32_t RESERVED7[4]; /*!< Reserved,                                             0x090 - 0x09C */
N  __IO uint32_t AWD2CR;       /*!< ADC analog watchdog 1 configuration register,  Address offset: 0xA0 */
X  volatile uint32_t AWD2CR;        
N  __IO uint32_t AWD3CR;       /*!< ADC analog watchdog 3 Configuration Register,  Address offset: 0xA4 */
X  volatile uint32_t AWD3CR;        
N       uint32_t RESERVED8;    /*!< Reserved,                                                     0x0A8 */
N       uint32_t RESERVED9;    /*!< Reserved,                                                     0x0AC */
N  __IO uint32_t DIFSEL;       /*!< ADC differential mode selection register,      Address offset: 0xB0 */
X  volatile uint32_t DIFSEL;        
N  __IO uint32_t CALFACT;      /*!< ADC calibration factors,                       Address offset: 0xB4 */
X  volatile uint32_t CALFACT;       
N
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  uint32_t      RESERVED1;    /*!< Reserved,                                      Address offset: ADC1 base address + 0x300 */
N  uint32_t      RESERVED2;    /*!< Reserved,                                      Address offset: ADC1 base address + 0x304 */
N  __IO uint32_t CCR;          /*!< ADC common configuration register,             Address offset: ADC1 base address + 0x308 */
X  volatile uint32_t CCR;           
N  uint32_t      RESERVED3;    /*!< Reserved,                                      Address offset: ADC1 base address + 0x30C */
N} ADC_Common_TypeDef;
N
N
N/**
N  * @brief Controller Area Network TxMailBox
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
X  volatile uint32_t TIR;   
N  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
X  volatile uint32_t TDTR;  
N  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
X  volatile uint32_t TDLR;  
N  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
X  volatile uint32_t TDHR;  
N} CAN_TxMailBox_TypeDef;
N
N/**
N  * @brief Controller Area Network FIFOMailBox
N  */
N
Ntypedef struct
N{
N  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
X  volatile uint32_t RIR;   
N  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
X  volatile uint32_t RDTR;  
N  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
X  volatile uint32_t RDLR;  
N  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
X  volatile uint32_t RDHR;  
N} CAN_FIFOMailBox_TypeDef;
N
N/**
N  * @brief Controller Area Network FilterRegister
N  */
N
Ntypedef struct
N{
N  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR1;  
N  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR2;  
N} CAN_FilterRegister_TypeDef;
N
N/**
N  * @brief Controller Area Network
N  */
N
Ntypedef struct
N{
N  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
X  volatile uint32_t              MCR;                  
N  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
X  volatile uint32_t              MSR;                  
N  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
X  volatile uint32_t              TSR;                  
N  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
X  volatile uint32_t              RF0R;                 
N  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
X  volatile uint32_t              RF1R;                 
N  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
X  volatile uint32_t              IER;                  
N  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
X  volatile uint32_t              ESR;                  
N  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
X  volatile uint32_t              BTR;                  
N  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
N  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
N  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
N  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
N  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
X  volatile uint32_t              FMR;                  
N  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
X  volatile uint32_t              FM1R;                 
N  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
N  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
X  volatile uint32_t              FS1R;                 
N  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
N  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
X  volatile uint32_t              FFA1R;                
N  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
N  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
X  volatile uint32_t              FA1R;                 
N  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */
N  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
N} CAN_TypeDef;
N
N
N/**
N  * @brief Comparator
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< COMP control and status register, Address offset: 0x00 */
X  volatile uint32_t CSR;          
N} COMP_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< COMP control and status register, used for bits common to several COMP instances, Address offset: 0x00 */
X  volatile uint32_t CSR;          
N} COMP_Common_TypeDef;
N
N/**
N  * @brief CRC calculation unit
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t DR;           
N  __IO uint8_t  IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X  volatile uint8_t  IDR;          
N  uint8_t       RESERVED0;   /*!< Reserved,                                                    0x05 */
N  uint16_t      RESERVED1;   /*!< Reserved,                                                    0x06 */
N  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */
X  volatile uint32_t CR;           
N  uint32_t      RESERVED2;   /*!< Reserved,                                                    0x0C */
N  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X  volatile uint32_t INIT;         
N  __IO uint32_t POL;         /*!< CRC polynomial register,                     Address offset: 0x14 */
X  volatile uint32_t POL;          
N} CRC_TypeDef;
N
N/**
N  * @brief Clock Recovery System
N  */
Ntypedef struct
N{
N__IO uint32_t CR;            /*!< CRS ccontrol register,              Address offset: 0x00 */
Xvolatile uint32_t CR;             
N__IO uint32_t CFGR;          /*!< CRS configuration register,         Address offset: 0x04 */
Xvolatile uint32_t CFGR;           
N__IO uint32_t ISR;           /*!< CRS interrupt and status register,  Address offset: 0x08 */
Xvolatile uint32_t ISR;            
N__IO uint32_t ICR;           /*!< CRS interrupt flag clear register,  Address offset: 0x0C */
Xvolatile uint32_t ICR;            
N} CRS_TypeDef;
N
N/**
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< DAC control register,                                    Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t SWTRIGR;     /*!< DAC software trigger register,                           Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;      
N  __IO uint32_t DHR12R1;     /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
X  volatile uint32_t DHR12R1;      
N  __IO uint32_t DHR12L1;     /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
X  volatile uint32_t DHR12L1;      
N  __IO uint32_t DHR8R1;      /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
X  volatile uint32_t DHR8R1;       
N  __IO uint32_t DHR12R2;     /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
X  volatile uint32_t DHR12R2;      
N  __IO uint32_t DHR12L2;     /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
X  volatile uint32_t DHR12L2;      
N  __IO uint32_t DHR8R2;      /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
X  volatile uint32_t DHR8R2;       
N  __IO uint32_t DHR12RD;     /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
X  volatile uint32_t DHR12RD;      
N  __IO uint32_t DHR12LD;     /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
X  volatile uint32_t DHR12LD;      
N  __IO uint32_t DHR8RD;      /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
X  volatile uint32_t DHR8RD;       
N  __IO uint32_t DOR1;        /*!< DAC channel1 data output register,                       Address offset: 0x2C */
X  volatile uint32_t DOR1;         
N  __IO uint32_t DOR2;        /*!< DAC channel2 data output register,                       Address offset: 0x30 */
X  volatile uint32_t DOR2;         
N  __IO uint32_t SR;          /*!< DAC status register,                                     Address offset: 0x34 */
X  volatile uint32_t SR;           
N  __IO uint32_t CCR;         /*!< DAC calibration control register,                        Address offset: 0x38 */
X  volatile uint32_t CCR;          
N  __IO uint32_t MCR;         /*!< DAC mode control register,                               Address offset: 0x3C */
X  volatile uint32_t MCR;          
N  __IO uint32_t SHSR1;       /*!< DAC Sample and Hold sample time register 1,              Address offset: 0x40 */
X  volatile uint32_t SHSR1;        
N  __IO uint32_t SHSR2;       /*!< DAC Sample and Hold sample time register 2,              Address offset: 0x44 */
X  volatile uint32_t SHSR2;        
N  __IO uint32_t SHHR;        /*!< DAC Sample and Hold hold time register,                  Address offset: 0x48 */
X  volatile uint32_t SHHR;         
N  __IO uint32_t SHRR;        /*!< DAC Sample and Hold refresh time register,               Address offset: 0x4C */
X  volatile uint32_t SHRR;         
N} DAC_TypeDef;
N
N
N/**
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;      /*!< MCU device ID code,                 Address offset: 0x00 */
X  volatile uint32_t IDCODE;       
N  __IO uint32_t CR;          /*!< Debug MCU configuration register,   Address offset: 0x04 */
X  volatile uint32_t CR;           
N  __IO uint32_t APB1FZR1;    /*!< Debug MCU APB1 freeze register 1,   Address offset: 0x08 */
X  volatile uint32_t APB1FZR1;     
N  __IO uint32_t APB1FZR2;    /*!< Debug MCU APB1 freeze register 2,   Address offset: 0x0C */
X  volatile uint32_t APB1FZR2;     
N  __IO uint32_t APB2FZ;      /*!< Debug MCU APB2 freeze register,     Address offset: 0x10 */
X  volatile uint32_t APB2FZ;       
N} DBGMCU_TypeDef;
N
N
N/**
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;         /*!< DMA channel x configuration register        */
X  volatile uint32_t CCR;          
N  __IO uint32_t CNDTR;       /*!< DMA channel x number of data register       */
X  volatile uint32_t CNDTR;        
N  __IO uint32_t CPAR;        /*!< DMA channel x peripheral address register   */
X  volatile uint32_t CPAR;         
N  __IO uint32_t CMAR;        /*!< DMA channel x memory address register       */
X  volatile uint32_t CMAR;         
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;         /*!< DMA interrupt status register,                 Address offset: 0x00 */
X  volatile uint32_t ISR;          
N  __IO uint32_t IFCR;        /*!< DMA interrupt flag clear register,             Address offset: 0x04 */
X  volatile uint32_t IFCR;         
N} DMA_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSELR;       /*!< DMA channel selection register              */
X  volatile uint32_t CSELR;        
N} DMA_Request_TypeDef;
N
N/* Legacy define */
N#define DMA_request_TypeDef  DMA_Request_TypeDef
N
N
N/**
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR1;        /*!< EXTI Interrupt mask register 1,             Address offset: 0x00 */
X  volatile uint32_t IMR1;         
N  __IO uint32_t EMR1;        /*!< EXTI Event mask register 1,                 Address offset: 0x04 */
X  volatile uint32_t EMR1;         
N  __IO uint32_t RTSR1;       /*!< EXTI Rising trigger selection register 1,   Address offset: 0x08 */
X  volatile uint32_t RTSR1;        
N  __IO uint32_t FTSR1;       /*!< EXTI Falling trigger selection register 1,  Address offset: 0x0C */
X  volatile uint32_t FTSR1;        
N  __IO uint32_t SWIER1;      /*!< EXTI Software interrupt event register 1,   Address offset: 0x10 */
X  volatile uint32_t SWIER1;       
N  __IO uint32_t PR1;         /*!< EXTI Pending register 1,                    Address offset: 0x14 */
X  volatile uint32_t PR1;          
N  uint32_t      RESERVED1;   /*!< Reserved, 0x18                                                   */
N  uint32_t      RESERVED2;   /*!< Reserved, 0x1C                                                   */
N  __IO uint32_t IMR2;        /*!< EXTI Interrupt mask register 2,             Address offset: 0x20 */
X  volatile uint32_t IMR2;         
N  __IO uint32_t EMR2;        /*!< EXTI Event mask register 2,                 Address offset: 0x24 */
X  volatile uint32_t EMR2;         
N  __IO uint32_t RTSR2;       /*!< EXTI Rising trigger selection register 2,   Address offset: 0x28 */
X  volatile uint32_t RTSR2;        
N  __IO uint32_t FTSR2;       /*!< EXTI Falling trigger selection register 2,  Address offset: 0x2C */
X  volatile uint32_t FTSR2;        
N  __IO uint32_t SWIER2;      /*!< EXTI Software interrupt event register 2,   Address offset: 0x30 */
X  volatile uint32_t SWIER2;       
N  __IO uint32_t PR2;         /*!< EXTI Pending register 2,                    Address offset: 0x34 */
X  volatile uint32_t PR2;          
N} EXTI_TypeDef;
N
N
N/**
N  * @brief Firewall
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSSA;        /*!< Code Segment Start Address register,              Address offset: 0x00 */
X  volatile uint32_t CSSA;         
N  __IO uint32_t CSL;         /*!< Code Segment Length register,                      Address offset: 0x04 */
X  volatile uint32_t CSL;          
N  __IO uint32_t NVDSSA;      /*!< NON volatile data Segment Start Address register,  Address offset: 0x08 */
X  volatile uint32_t NVDSSA;       
N  __IO uint32_t NVDSL;       /*!< NON volatile data Segment Length register,         Address offset: 0x0C */
X  volatile uint32_t NVDSL;        
N  __IO uint32_t VDSSA ;      /*!< Volatile data Segment Start Address register,      Address offset: 0x10 */
X  volatile uint32_t VDSSA ;       
N  __IO uint32_t VDSL ;       /*!< Volatile data Segment Length register,             Address offset: 0x14 */
X  volatile uint32_t VDSL ;        
N  uint32_t      RESERVED1;   /*!< Reserved1,                                         Address offset: 0x18 */
N  uint32_t      RESERVED2;   /*!< Reserved2,                                         Address offset: 0x1C */
N  __IO uint32_t CR ;         /*!< Configuration  register,                           Address offset: 0x20 */
X  volatile uint32_t CR ;          
N} FIREWALL_TypeDef;
N
N
N/**
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;              /*!< FLASH access control register,            Address offset: 0x00 */
X  volatile uint32_t ACR;               
N  __IO uint32_t PDKEYR;           /*!< FLASH power down key register,            Address offset: 0x04 */
X  volatile uint32_t PDKEYR;            
N  __IO uint32_t KEYR;             /*!< FLASH key register,                       Address offset: 0x08 */
X  volatile uint32_t KEYR;              
N  __IO uint32_t OPTKEYR;          /*!< FLASH option key register,                Address offset: 0x0C */
X  volatile uint32_t OPTKEYR;           
N  __IO uint32_t SR;               /*!< FLASH status register,                    Address offset: 0x10 */
X  volatile uint32_t SR;                
N  __IO uint32_t CR;               /*!< FLASH control register,                   Address offset: 0x14 */
X  volatile uint32_t CR;                
N  __IO uint32_t ECCR;             /*!< FLASH ECC register,                       Address offset: 0x18 */
X  volatile uint32_t ECCR;              
N  __IO uint32_t RESERVED1;        /*!< Reserved1,                                Address offset: 0x1C */
X  volatile uint32_t RESERVED1;         
N  __IO uint32_t OPTR;             /*!< FLASH option register,                    Address offset: 0x20 */
X  volatile uint32_t OPTR;              
N  __IO uint32_t PCROP1SR;         /*!< FLASH bank1 PCROP start address register, Address offset: 0x24 */
X  volatile uint32_t PCROP1SR;          
N  __IO uint32_t PCROP1ER;         /*!< FLASH bank1 PCROP end address register,   Address offset: 0x28 */
X  volatile uint32_t PCROP1ER;          
N  __IO uint32_t WRP1AR;           /*!< FLASH bank1 WRP area A address register,  Address offset: 0x2C */
X  volatile uint32_t WRP1AR;            
N  __IO uint32_t WRP1BR;           /*!< FLASH bank1 WRP area B address register,  Address offset: 0x30 */
X  volatile uint32_t WRP1BR;            
N} FLASH_TypeDef;
N
N
N
N/**
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;       /*!< GPIO port mode register,               Address offset: 0x00      */
X  volatile uint32_t MODER;        
N  __IO uint32_t OTYPER;      /*!< GPIO port output type register,        Address offset: 0x04      */
X  volatile uint32_t OTYPER;       
N  __IO uint32_t OSPEEDR;     /*!< GPIO port output speed register,       Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;      
N  __IO uint32_t PUPDR;       /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
X  volatile uint32_t PUPDR;        
N  __IO uint32_t IDR;         /*!< GPIO port input data register,         Address offset: 0x10      */
X  volatile uint32_t IDR;          
N  __IO uint32_t ODR;         /*!< GPIO port output data register,        Address offset: 0x14      */
X  volatile uint32_t ODR;          
N  __IO uint32_t BSRR;        /*!< GPIO port bit set/reset  register,     Address offset: 0x18      */
X  volatile uint32_t BSRR;         
N  __IO uint32_t LCKR;        /*!< GPIO port configuration lock register, Address offset: 0x1C      */
X  volatile uint32_t LCKR;         
N  __IO uint32_t AFR[2];      /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];       
N  __IO uint32_t BRR;         /*!< GPIO Bit Reset register,               Address offset: 0x28      */
X  volatile uint32_t BRR;          
N
N} GPIO_TypeDef;
N
N
N/**
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< I2C Control register 1,            Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< I2C Control register 2,            Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t OAR1;        /*!< I2C Own address 1 register,        Address offset: 0x08 */
X  volatile uint32_t OAR1;         
N  __IO uint32_t OAR2;        /*!< I2C Own address 2 register,        Address offset: 0x0C */
X  volatile uint32_t OAR2;         
N  __IO uint32_t TIMINGR;     /*!< I2C Timing register,               Address offset: 0x10 */
X  volatile uint32_t TIMINGR;      
N  __IO uint32_t TIMEOUTR;    /*!< I2C Timeout register,              Address offset: 0x14 */
X  volatile uint32_t TIMEOUTR;     
N  __IO uint32_t ISR;         /*!< I2C Interrupt and status register, Address offset: 0x18 */
X  volatile uint32_t ISR;          
N  __IO uint32_t ICR;         /*!< I2C Interrupt clear register,      Address offset: 0x1C */
X  volatile uint32_t ICR;          
N  __IO uint32_t PECR;        /*!< I2C PEC register,                  Address offset: 0x20 */
X  volatile uint32_t PECR;         
N  __IO uint32_t RXDR;        /*!< I2C Receive data register,         Address offset: 0x24 */
X  volatile uint32_t RXDR;         
N  __IO uint32_t TXDR;        /*!< I2C Transmit data register,        Address offset: 0x28 */
X  volatile uint32_t TXDR;         
N} I2C_TypeDef;
N
N/**
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;          /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;           
N  __IO uint32_t PR;          /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;           
N  __IO uint32_t RLR;         /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;          
N  __IO uint32_t SR;          /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;           
N  __IO uint32_t WINR;        /*!< IWDG Window register,    Address offset: 0x10 */
X  volatile uint32_t WINR;         
N} IWDG_TypeDef;
N
N/**
N  * @brief LPTIMER
N  */
Ntypedef struct
N{
N  __IO uint32_t ISR;         /*!< LPTIM Interrupt and Status register,                Address offset: 0x00 */
X  volatile uint32_t ISR;          
N  __IO uint32_t ICR;         /*!< LPTIM Interrupt Clear register,                     Address offset: 0x04 */
X  volatile uint32_t ICR;          
N  __IO uint32_t IER;         /*!< LPTIM Interrupt Enable register,                    Address offset: 0x08 */
X  volatile uint32_t IER;          
N  __IO uint32_t CFGR;        /*!< LPTIM Configuration register,                       Address offset: 0x0C */
X  volatile uint32_t CFGR;         
N  __IO uint32_t CR;          /*!< LPTIM Control register,                             Address offset: 0x10 */
X  volatile uint32_t CR;           
N  __IO uint32_t CMP;         /*!< LPTIM Compare register,                             Address offset: 0x14 */
X  volatile uint32_t CMP;          
N  __IO uint32_t ARR;         /*!< LPTIM Autoreload register,                          Address offset: 0x18 */
X  volatile uint32_t ARR;          
N  __IO uint32_t CNT;         /*!< LPTIM Counter register,                             Address offset: 0x1C */
X  volatile uint32_t CNT;          
N  __IO uint32_t OR;          /*!< LPTIM Option register,                              Address offset: 0x20 */
X  volatile uint32_t OR;           
N} LPTIM_TypeDef;
N
N/**
N  * @brief Operational Amplifier (OPAMP)
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< OPAMP control/status register,                     Address offset: 0x00 */
X  volatile uint32_t CSR;          
N  __IO uint32_t OTR;         /*!< OPAMP offset trimming register for normal mode,    Address offset: 0x04 */
X  volatile uint32_t OTR;          
N  __IO uint32_t LPOTR;       /*!< OPAMP offset trimming register for low power mode, Address offset: 0x08 */
X  volatile uint32_t LPOTR;        
N} OPAMP_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< OPAMP control/status register, used for bits common to several OPAMP instances, Address offset: 0x00 */
X  volatile uint32_t CSR;          
N} OPAMP_Common_TypeDef;
N
N/**
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;   /*!< PWR power control register 1,        Address offset: 0x00 */
X  volatile uint32_t CR1;    
N  __IO uint32_t CR2;   /*!< PWR power control register 2,        Address offset: 0x04 */
X  volatile uint32_t CR2;    
N  __IO uint32_t CR3;   /*!< PWR power control register 3,        Address offset: 0x08 */
X  volatile uint32_t CR3;    
N  __IO uint32_t CR4;   /*!< PWR power control register 4,        Address offset: 0x0C */
X  volatile uint32_t CR4;    
N  __IO uint32_t SR1;   /*!< PWR power status register 1,         Address offset: 0x10 */
X  volatile uint32_t SR1;    
N  __IO uint32_t SR2;   /*!< PWR power status register 2,         Address offset: 0x14 */
X  volatile uint32_t SR2;    
N  __IO uint32_t SCR;   /*!< PWR power status reset register,     Address offset: 0x18 */
X  volatile uint32_t SCR;    
N  uint32_t RESERVED;   /*!< Reserved,                            Address offset: 0x1C */
N  __IO uint32_t PUCRA; /*!< Pull_up control register of portA,   Address offset: 0x20 */
X  volatile uint32_t PUCRA;  
N  __IO uint32_t PDCRA; /*!< Pull_Down control register of portA, Address offset: 0x24 */
X  volatile uint32_t PDCRA;  
N  __IO uint32_t PUCRB; /*!< Pull_up control register of portB,   Address offset: 0x28 */
X  volatile uint32_t PUCRB;  
N  __IO uint32_t PDCRB; /*!< Pull_Down control register of portB, Address offset: 0x2C */
X  volatile uint32_t PDCRB;  
N  __IO uint32_t PUCRC; /*!< Pull_up control register of portC,   Address offset: 0x30 */
X  volatile uint32_t PUCRC;  
N  __IO uint32_t PDCRC; /*!< Pull_Down control register of portC, Address offset: 0x34 */
X  volatile uint32_t PDCRC;  
N  __IO uint32_t PUCRD; /*!< Pull_up control register of portD,   Address offset: 0x38 */
X  volatile uint32_t PUCRD;  
N  __IO uint32_t PDCRD; /*!< Pull_Down control register of portD, Address offset: 0x3C */
X  volatile uint32_t PDCRD;  
N  __IO uint32_t PUCRE; /*!< Pull_up control register of portE,   Address offset: 0x40 */
X  volatile uint32_t PUCRE;  
N  __IO uint32_t PDCRE; /*!< Pull_Down control register of portE, Address offset: 0x44 */
X  volatile uint32_t PDCRE;  
N  uint32_t RESERVED1;  /*!< Reserved,                            Address offset: 0x48 */
N  uint32_t RESERVED2;  /*!< Reserved,                            Address offset: 0x4C */
N  uint32_t RESERVED3;  /*!< Reserved,                            Address offset: 0x50 */
N  uint32_t RESERVED4;  /*!< Reserved,                            Address offset: 0x54 */
N  __IO uint32_t PUCRH; /*!< Pull_up control register of portH,   Address offset: 0x58 */
X  volatile uint32_t PUCRH;  
N  __IO uint32_t PDCRH; /*!< Pull_Down control register of portH, Address offset: 0x5C */
X  volatile uint32_t PDCRH;  
N} PWR_TypeDef;
N
N
N/**
N  * @brief QUAD Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< QUADSPI Control register,                           Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t DCR;         /*!< QUADSPI Device Configuration register,              Address offset: 0x04 */
X  volatile uint32_t DCR;          
N  __IO uint32_t SR;          /*!< QUADSPI Status register,                            Address offset: 0x08 */
X  volatile uint32_t SR;           
N  __IO uint32_t FCR;         /*!< QUADSPI Flag Clear register,                        Address offset: 0x0C */
X  volatile uint32_t FCR;          
N  __IO uint32_t DLR;         /*!< QUADSPI Data Length register,                       Address offset: 0x10 */
X  volatile uint32_t DLR;          
N  __IO uint32_t CCR;         /*!< QUADSPI Communication Configuration register,       Address offset: 0x14 */
X  volatile uint32_t CCR;          
N  __IO uint32_t AR;          /*!< QUADSPI Address register,                           Address offset: 0x18 */
X  volatile uint32_t AR;           
N  __IO uint32_t ABR;         /*!< QUADSPI Alternate Bytes register,                   Address offset: 0x1C */
X  volatile uint32_t ABR;          
N  __IO uint32_t DR;          /*!< QUADSPI Data register,                              Address offset: 0x20 */
X  volatile uint32_t DR;           
N  __IO uint32_t PSMKR;       /*!< QUADSPI Polling Status Mask register,               Address offset: 0x24 */
X  volatile uint32_t PSMKR;        
N  __IO uint32_t PSMAR;       /*!< QUADSPI Polling Status Match register,              Address offset: 0x28 */
X  volatile uint32_t PSMAR;        
N  __IO uint32_t PIR;         /*!< QUADSPI Polling Interval register,                  Address offset: 0x2C */
X  volatile uint32_t PIR;          
N  __IO uint32_t LPTR;        /*!< QUADSPI Low Power Timeout register,                 Address offset: 0x30 */
X  volatile uint32_t LPTR;         
N} QUADSPI_TypeDef;
N
N
N/**
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< RCC clock control register,                                              Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t ICSCR;       /*!< RCC internal clock sources calibration register,                         Address offset: 0x04 */
X  volatile uint32_t ICSCR;        
N  __IO uint32_t CFGR;        /*!< RCC clock configuration register,                                        Address offset: 0x08 */
X  volatile uint32_t CFGR;         
N  __IO uint32_t PLLCFGR;     /*!< RCC system PLL configuration register,                                   Address offset: 0x0C */
X  volatile uint32_t PLLCFGR;      
N  __IO uint32_t PLLSAI1CFGR; /*!< RCC PLL SAI1 configuration register,                                     Address offset: 0x10 */
X  volatile uint32_t PLLSAI1CFGR;  
N  uint32_t      RESERVED;    /*!< Reserved,                                                                Address offset: 0x14 */
N  __IO uint32_t CIER;        /*!< RCC clock interrupt enable register,                                     Address offset: 0x18 */
X  volatile uint32_t CIER;         
N  __IO uint32_t CIFR;        /*!< RCC clock interrupt flag register,                                       Address offset: 0x1C */
X  volatile uint32_t CIFR;         
N  __IO uint32_t CICR;        /*!< RCC clock interrupt clear register,                                      Address offset: 0x20 */
X  volatile uint32_t CICR;         
N  uint32_t      RESERVED0;   /*!< Reserved,                                                                Address offset: 0x24 */
N  __IO uint32_t AHB1RSTR;    /*!< RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */
X  volatile uint32_t AHB1RSTR;     
N  __IO uint32_t AHB2RSTR;    /*!< RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */
X  volatile uint32_t AHB2RSTR;     
N  __IO uint32_t AHB3RSTR;    /*!< RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */
X  volatile uint32_t AHB3RSTR;     
N  uint32_t      RESERVED1;   /*!< Reserved,                                                                Address offset: 0x34 */
N  __IO uint32_t APB1RSTR1;   /*!< RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */
X  volatile uint32_t APB1RSTR1;    
N  __IO uint32_t APB1RSTR2;   /*!< RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */
X  volatile uint32_t APB1RSTR2;    
N  __IO uint32_t APB2RSTR;    /*!< RCC APB2 peripheral reset register,                                      Address offset: 0x40 */
X  volatile uint32_t APB2RSTR;     
N  uint32_t      RESERVED2;   /*!< Reserved,                                                                Address offset: 0x44 */
N  __IO uint32_t AHB1ENR;     /*!< RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */
X  volatile uint32_t AHB1ENR;      
N  __IO uint32_t AHB2ENR;     /*!< RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */
X  volatile uint32_t AHB2ENR;      
N  __IO uint32_t AHB3ENR;     /*!< RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */
X  volatile uint32_t AHB3ENR;      
N  uint32_t      RESERVED3;   /*!< Reserved,                                                                Address offset: 0x54 */
N  __IO uint32_t APB1ENR1;    /*!< RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */
X  volatile uint32_t APB1ENR1;     
N  __IO uint32_t APB1ENR2;    /*!< RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */
X  volatile uint32_t APB1ENR2;     
N  __IO uint32_t APB2ENR;     /*!< RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */
X  volatile uint32_t APB2ENR;      
N  uint32_t      RESERVED4;   /*!< Reserved,                                                                Address offset: 0x64 */
N  __IO uint32_t AHB1SMENR;   /*!< RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */
X  volatile uint32_t AHB1SMENR;    
N  __IO uint32_t AHB2SMENR;   /*!< RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */
X  volatile uint32_t AHB2SMENR;    
N  __IO uint32_t AHB3SMENR;   /*!< RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */
X  volatile uint32_t AHB3SMENR;    
N  uint32_t      RESERVED5;   /*!< Reserved,                                                                Address offset: 0x74 */
N  __IO uint32_t APB1SMENR1;  /*!< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */
X  volatile uint32_t APB1SMENR1;   
N  __IO uint32_t APB1SMENR2;  /*!< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */
X  volatile uint32_t APB1SMENR2;   
N  __IO uint32_t APB2SMENR;   /*!< RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */
X  volatile uint32_t APB2SMENR;    
N  uint32_t      RESERVED6;   /*!< Reserved,                                                                Address offset: 0x84 */
N  __IO uint32_t CCIPR;       /*!< RCC peripherals independent clock configuration register,                Address offset: 0x88 */
X  volatile uint32_t CCIPR;        
N  uint32_t      RESERVED7;   /*!< Reserved,                                                                Address offset: 0x8C */
N  __IO uint32_t BDCR;        /*!< RCC backup domain control register,                                      Address offset: 0x90 */
X  volatile uint32_t BDCR;         
N  __IO uint32_t CSR;         /*!< RCC clock control & status register,                                     Address offset: 0x94 */
X  volatile uint32_t CSR;          
N  __IO uint32_t CRRCR;       /*!< RCC clock recovery RC register,                                          Address offset: 0x98 */
X  volatile uint32_t CRRCR;        
N} RCC_TypeDef;
N
N/**
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;          /*!< RTC time register,                                         Address offset: 0x00 */
X  volatile uint32_t TR;           
N  __IO uint32_t DR;          /*!< RTC date register,                                         Address offset: 0x04 */
X  volatile uint32_t DR;           
N  __IO uint32_t CR;          /*!< RTC control register,                                      Address offset: 0x08 */
X  volatile uint32_t CR;           
N  __IO uint32_t ISR;         /*!< RTC initialization and status register,                    Address offset: 0x0C */
X  volatile uint32_t ISR;          
N  __IO uint32_t PRER;        /*!< RTC prescaler register,                                    Address offset: 0x10 */
X  volatile uint32_t PRER;         
N  __IO uint32_t WUTR;        /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
X  volatile uint32_t WUTR;         
N       uint32_t reserved;    /*!< Reserved  */
N  __IO uint32_t ALRMAR;      /*!< RTC alarm A register,                                      Address offset: 0x1C */
X  volatile uint32_t ALRMAR;       
N  __IO uint32_t ALRMBR;      /*!< RTC alarm B register,                                      Address offset: 0x20 */
X  volatile uint32_t ALRMBR;       
N  __IO uint32_t WPR;         /*!< RTC write protection register,                             Address offset: 0x24 */
X  volatile uint32_t WPR;          
N  __IO uint32_t SSR;         /*!< RTC sub second register,                                   Address offset: 0x28 */
X  volatile uint32_t SSR;          
N  __IO uint32_t SHIFTR;      /*!< RTC shift control register,                                Address offset: 0x2C */
X  volatile uint32_t SHIFTR;       
N  __IO uint32_t TSTR;        /*!< RTC time stamp time register,                              Address offset: 0x30 */
X  volatile uint32_t TSTR;         
N  __IO uint32_t TSDR;        /*!< RTC time stamp date register,                              Address offset: 0x34 */
X  volatile uint32_t TSDR;         
N  __IO uint32_t TSSSR;       /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X  volatile uint32_t TSSSR;        
N  __IO uint32_t CALR;        /*!< RTC calibration register,                                  Address offset: 0x3C */
X  volatile uint32_t CALR;         
N  __IO uint32_t TAMPCR;      /*!< RTC tamper configuration register,                         Address offset: 0x40 */
X  volatile uint32_t TAMPCR;       
N  __IO uint32_t ALRMASSR;    /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;     
N  __IO uint32_t ALRMBSSR;    /*!< RTC alarm B sub second register,                           Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR;     
N  __IO uint32_t OR;          /*!< RTC option register,                                       Address offset: 0x4C */
X  volatile uint32_t OR;           
N  __IO uint32_t BKP0R;       /*!< RTC backup register 0,                                     Address offset: 0x50 */
X  volatile uint32_t BKP0R;        
N  __IO uint32_t BKP1R;       /*!< RTC backup register 1,                                     Address offset: 0x54 */
X  volatile uint32_t BKP1R;        
N  __IO uint32_t BKP2R;       /*!< RTC backup register 2,                                     Address offset: 0x58 */
X  volatile uint32_t BKP2R;        
N  __IO uint32_t BKP3R;       /*!< RTC backup register 3,                                     Address offset: 0x5C */
X  volatile uint32_t BKP3R;        
N  __IO uint32_t BKP4R;       /*!< RTC backup register 4,                                     Address offset: 0x60 */
X  volatile uint32_t BKP4R;        
N  __IO uint32_t BKP5R;       /*!< RTC backup register 5,                                     Address offset: 0x64 */
X  volatile uint32_t BKP5R;        
N  __IO uint32_t BKP6R;       /*!< RTC backup register 6,                                     Address offset: 0x68 */
X  volatile uint32_t BKP6R;        
N  __IO uint32_t BKP7R;       /*!< RTC backup register 7,                                     Address offset: 0x6C */
X  volatile uint32_t BKP7R;        
N  __IO uint32_t BKP8R;       /*!< RTC backup register 8,                                     Address offset: 0x70 */
X  volatile uint32_t BKP8R;        
N  __IO uint32_t BKP9R;       /*!< RTC backup register 9,                                     Address offset: 0x74 */
X  volatile uint32_t BKP9R;        
N  __IO uint32_t BKP10R;      /*!< RTC backup register 10,                                    Address offset: 0x78 */
X  volatile uint32_t BKP10R;       
N  __IO uint32_t BKP11R;      /*!< RTC backup register 11,                                    Address offset: 0x7C */
X  volatile uint32_t BKP11R;       
N  __IO uint32_t BKP12R;      /*!< RTC backup register 12,                                    Address offset: 0x80 */
X  volatile uint32_t BKP12R;       
N  __IO uint32_t BKP13R;      /*!< RTC backup register 13,                                    Address offset: 0x84 */
X  volatile uint32_t BKP13R;       
N  __IO uint32_t BKP14R;      /*!< RTC backup register 14,                                    Address offset: 0x88 */
X  volatile uint32_t BKP14R;       
N  __IO uint32_t BKP15R;      /*!< RTC backup register 15,                                    Address offset: 0x8C */
X  volatile uint32_t BKP15R;       
N  __IO uint32_t BKP16R;      /*!< RTC backup register 16,                                    Address offset: 0x90 */
X  volatile uint32_t BKP16R;       
N  __IO uint32_t BKP17R;      /*!< RTC backup register 17,                                    Address offset: 0x94 */
X  volatile uint32_t BKP17R;       
N  __IO uint32_t BKP18R;      /*!< RTC backup register 18,                                    Address offset: 0x98 */
X  volatile uint32_t BKP18R;       
N  __IO uint32_t BKP19R;      /*!< RTC backup register 19,                                    Address offset: 0x9C */
X  volatile uint32_t BKP19R;       
N  __IO uint32_t BKP20R;      /*!< RTC backup register 20,                                    Address offset: 0xA0 */
X  volatile uint32_t BKP20R;       
N  __IO uint32_t BKP21R;      /*!< RTC backup register 21,                                    Address offset: 0xA4 */
X  volatile uint32_t BKP21R;       
N  __IO uint32_t BKP22R;      /*!< RTC backup register 22,                                    Address offset: 0xA8 */
X  volatile uint32_t BKP22R;       
N  __IO uint32_t BKP23R;      /*!< RTC backup register 23,                                    Address offset: 0xAC */
X  volatile uint32_t BKP23R;       
N  __IO uint32_t BKP24R;      /*!< RTC backup register 24,                                    Address offset: 0xB0 */
X  volatile uint32_t BKP24R;       
N  __IO uint32_t BKP25R;      /*!< RTC backup register 25,                                    Address offset: 0xB4 */
X  volatile uint32_t BKP25R;       
N  __IO uint32_t BKP26R;      /*!< RTC backup register 26,                                    Address offset: 0xB8 */
X  volatile uint32_t BKP26R;       
N  __IO uint32_t BKP27R;      /*!< RTC backup register 27,                                    Address offset: 0xBC */
X  volatile uint32_t BKP27R;       
N  __IO uint32_t BKP28R;      /*!< RTC backup register 28,                                    Address offset: 0xC0 */
X  volatile uint32_t BKP28R;       
N  __IO uint32_t BKP29R;      /*!< RTC backup register 29,                                    Address offset: 0xC4 */
X  volatile uint32_t BKP29R;       
N  __IO uint32_t BKP30R;      /*!< RTC backup register 30,                                    Address offset: 0xC8 */
X  volatile uint32_t BKP30R;       
N  __IO uint32_t BKP31R;      /*!< RTC backup register 31,                                    Address offset: 0xCC */
X  volatile uint32_t BKP31R;       
N} RTC_TypeDef;
N
N
N/**
N  * @brief Serial Audio Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t GCR;         /*!< SAI global configuration register,        Address offset: 0x00 */
X  volatile uint32_t GCR;          
N} SAI_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< SAI block x configuration register 1,     Address offset: 0x04 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< SAI block x configuration register 2,     Address offset: 0x08 */
X  volatile uint32_t CR2;          
N  __IO uint32_t FRCR;        /*!< SAI block x frame configuration register, Address offset: 0x0C */
X  volatile uint32_t FRCR;         
N  __IO uint32_t SLOTR;       /*!< SAI block x slot register,                Address offset: 0x10 */
X  volatile uint32_t SLOTR;        
N  __IO uint32_t IMR;         /*!< SAI block x interrupt mask register,      Address offset: 0x14 */
X  volatile uint32_t IMR;          
N  __IO uint32_t SR;          /*!< SAI block x status register,              Address offset: 0x18 */
X  volatile uint32_t SR;           
N  __IO uint32_t CLRFR;       /*!< SAI block x clear flag register,          Address offset: 0x1C */
X  volatile uint32_t CLRFR;        
N  __IO uint32_t DR;          /*!< SAI block x data register,                Address offset: 0x20 */
X  volatile uint32_t DR;           
N} SAI_Block_TypeDef;
N
N
N/**
N  * @brief Secure digital input/output Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;          /*!< SDMMC power control register,    Address offset: 0x00 */
X  volatile uint32_t POWER;           
N  __IO uint32_t CLKCR;          /*!< SDMMC clock control register,    Address offset: 0x04 */
X  volatile uint32_t CLKCR;           
N  __IO uint32_t ARG;            /*!< SDMMC argument register,         Address offset: 0x08 */
X  volatile uint32_t ARG;             
N  __IO uint32_t CMD;            /*!< SDMMC command register,          Address offset: 0x0C */
X  volatile uint32_t CMD;             
N  __I uint32_t  RESPCMD;        /*!< SDMMC command response register, Address offset: 0x10 */
X  volatile uint32_t  RESPCMD;         
N  __I uint32_t  RESP1;          /*!< SDMMC response 1 register,       Address offset: 0x14 */
X  volatile uint32_t  RESP1;           
N  __I uint32_t  RESP2;          /*!< SDMMC response 2 register,       Address offset: 0x18 */
X  volatile uint32_t  RESP2;           
N  __I uint32_t  RESP3;          /*!< SDMMC response 3 register,       Address offset: 0x1C */
X  volatile uint32_t  RESP3;           
N  __I uint32_t  RESP4;          /*!< SDMMC response 4 register,       Address offset: 0x20 */
X  volatile uint32_t  RESP4;           
N  __IO uint32_t DTIMER;         /*!< SDMMC data timer register,       Address offset: 0x24 */
X  volatile uint32_t DTIMER;          
N  __IO uint32_t DLEN;           /*!< SDMMC data length register,      Address offset: 0x28 */
X  volatile uint32_t DLEN;            
N  __IO uint32_t DCTRL;          /*!< SDMMC data control register,     Address offset: 0x2C */
X  volatile uint32_t DCTRL;           
N  __I uint32_t  DCOUNT;         /*!< SDMMC data counter register,     Address offset: 0x30 */
X  volatile uint32_t  DCOUNT;          
N  __I uint32_t  STA;            /*!< SDMMC status register,           Address offset: 0x34 */
X  volatile uint32_t  STA;             
N  __IO uint32_t ICR;            /*!< SDMMC interrupt clear register,  Address offset: 0x38 */
X  volatile uint32_t ICR;             
N  __IO uint32_t MASK;           /*!< SDMMC mask register,             Address offset: 0x3C */
X  volatile uint32_t MASK;            
N  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
N  __I uint32_t  FIFOCNT;        /*!< SDMMC FIFO counter register,     Address offset: 0x48 */
X  volatile uint32_t  FIFOCNT;         
N  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
N  __IO uint32_t FIFO;           /*!< SDMMC data FIFO register,        Address offset: 0x80 */
X  volatile uint32_t FIFO;            
N} SDMMC_TypeDef;
N
N
N/**
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< SPI Control register 1,                              Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< SPI Control register 2,                              Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t SR;          /*!< SPI Status register,                                 Address offset: 0x08 */
X  volatile uint32_t SR;           
N  __IO uint32_t DR;          /*!< SPI data register,                                   Address offset: 0x0C */
X  volatile uint32_t DR;           
N  __IO uint32_t CRCPR;       /*!< SPI CRC polynomial register,                         Address offset: 0x10 */
X  volatile uint32_t CRCPR;        
N  __IO uint32_t RXCRCR;      /*!< SPI Rx CRC register,                                 Address offset: 0x14 */
X  volatile uint32_t RXCRCR;       
N  __IO uint32_t TXCRCR;      /*!< SPI Tx CRC register,                                 Address offset: 0x18 */
X  volatile uint32_t TXCRCR;       
N} SPI_TypeDef;
N
N
N/**
N  * @brief Single Wire Protocol Master Interface SPWMI
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< SWPMI Configuration/Control register,     Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t BRR;         /*!< SWPMI bitrate register,                   Address offset: 0x04 */
X  volatile uint32_t BRR;          
N    uint32_t  RESERVED1;     /*!< Reserved, 0x08                                                 */
N  __IO uint32_t ISR;         /*!< SWPMI Interrupt and Status register,      Address offset: 0x0C */
X  volatile uint32_t ISR;          
N  __IO uint32_t ICR;         /*!< SWPMI Interrupt Flag Clear register,      Address offset: 0x10 */
X  volatile uint32_t ICR;          
N  __IO uint32_t IER;         /*!< SWPMI Interrupt Enable register,          Address offset: 0x14 */
X  volatile uint32_t IER;          
N  __IO uint32_t RFL;         /*!< SWPMI Receive Frame Length register,      Address offset: 0x18 */
X  volatile uint32_t RFL;          
N  __IO uint32_t TDR;         /*!< SWPMI Transmit data register,             Address offset: 0x1C */
X  volatile uint32_t TDR;          
N  __IO uint32_t RDR;         /*!< SWPMI Receive data register,              Address offset: 0x20 */
X  volatile uint32_t RDR;          
N  __IO uint32_t OR;          /*!< SWPMI Option register,                    Address offset: 0x24 */
X  volatile uint32_t OR;           
N} SWPMI_TypeDef;
N
N
N/**
N  * @brief System configuration controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MEMRMP;      /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
X  volatile uint32_t MEMRMP;       
N  __IO uint32_t CFGR1;       /*!< SYSCFG configuration register 1,                   Address offset: 0x04      */
X  volatile uint32_t CFGR1;        
N  __IO uint32_t EXTICR[4];   /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
X  volatile uint32_t EXTICR[4];    
N  __IO uint32_t SCSR;        /*!< SYSCFG SRAM2 control and status register,          Address offset: 0x18      */
X  volatile uint32_t SCSR;         
N  __IO uint32_t CFGR2;       /*!< SYSCFG configuration register 2,                   Address offset: 0x1C      */
X  volatile uint32_t CFGR2;        
N  __IO uint32_t SWPR;        /*!< SYSCFG SRAM2 write protection register,            Address offset: 0x20      */
X  volatile uint32_t SWPR;         
N  __IO uint32_t SKR;         /*!< SYSCFG SRAM2 key register,                         Address offset: 0x24      */
X  volatile uint32_t SKR;          
N} SYSCFG_TypeDef;
N
N
N/**
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< TIM control register 1,                   Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< TIM control register 2,                   Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t SMCR;        /*!< TIM slave mode control register,          Address offset: 0x08 */
X  volatile uint32_t SMCR;         
N  __IO uint32_t DIER;        /*!< TIM DMA/interrupt enable register,        Address offset: 0x0C */
X  volatile uint32_t DIER;         
N  __IO uint32_t SR;          /*!< TIM status register,                      Address offset: 0x10 */
X  volatile uint32_t SR;           
N  __IO uint32_t EGR;         /*!< TIM event generation register,            Address offset: 0x14 */
X  volatile uint32_t EGR;          
N  __IO uint32_t CCMR1;       /*!< TIM capture/compare mode register 1,      Address offset: 0x18 */
X  volatile uint32_t CCMR1;        
N  __IO uint32_t CCMR2;       /*!< TIM capture/compare mode register 2,      Address offset: 0x1C */
X  volatile uint32_t CCMR2;        
N  __IO uint32_t CCER;        /*!< TIM capture/compare enable register,      Address offset: 0x20 */
X  volatile uint32_t CCER;         
N  __IO uint32_t CNT;         /*!< TIM counter register,                     Address offset: 0x24 */
X  volatile uint32_t CNT;          
N  __IO uint32_t PSC;         /*!< TIM prescaler,                            Address offset: 0x28 */
X  volatile uint32_t PSC;          
N  __IO uint32_t ARR;         /*!< TIM auto-reload register,                 Address offset: 0x2C */
X  volatile uint32_t ARR;          
N  __IO uint32_t RCR;         /*!< TIM repetition counter register,          Address offset: 0x30 */
X  volatile uint32_t RCR;          
N  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,           Address offset: 0x34 */
X  volatile uint32_t CCR1;         
N  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,           Address offset: 0x38 */
X  volatile uint32_t CCR2;         
N  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,           Address offset: 0x3C */
X  volatile uint32_t CCR3;         
N  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,           Address offset: 0x40 */
X  volatile uint32_t CCR4;         
N  __IO uint32_t BDTR;        /*!< TIM break and dead-time register,         Address offset: 0x44 */
X  volatile uint32_t BDTR;         
N  __IO uint32_t DCR;         /*!< TIM DMA control register,                 Address offset: 0x48 */
X  volatile uint32_t DCR;          
N  __IO uint32_t DMAR;        /*!< TIM DMA address for full transfer,        Address offset: 0x4C */
X  volatile uint32_t DMAR;         
N  __IO uint32_t OR1;         /*!< TIM option register 1,                    Address offset: 0x50 */
X  volatile uint32_t OR1;          
N  __IO uint32_t CCMR3;       /*!< TIM capture/compare mode register 3,      Address offset: 0x54 */
X  volatile uint32_t CCMR3;        
N  __IO uint32_t CCR5;        /*!< TIM capture/compare register5,            Address offset: 0x58 */
X  volatile uint32_t CCR5;         
N  __IO uint32_t CCR6;        /*!< TIM capture/compare register6,            Address offset: 0x5C */
X  volatile uint32_t CCR6;         
N  __IO uint32_t OR2;         /*!< TIM option register 2,                    Address offset: 0x60 */
X  volatile uint32_t OR2;          
N  __IO uint32_t OR3;         /*!< TIM option register 3,                    Address offset: 0x64 */
X  volatile uint32_t OR3;          
N} TIM_TypeDef;
N
N
N/**
N  * @brief Touch Sensing Controller (TSC)
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< TSC control register,                                     Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t IER;           /*!< TSC interrupt enable register,                            Address offset: 0x04 */
X  volatile uint32_t IER;            
N  __IO uint32_t ICR;           /*!< TSC interrupt clear register,                             Address offset: 0x08 */
X  volatile uint32_t ICR;            
N  __IO uint32_t ISR;           /*!< TSC interrupt status register,                            Address offset: 0x0C */
X  volatile uint32_t ISR;            
N  __IO uint32_t IOHCR;         /*!< TSC I/O hysteresis control register,                      Address offset: 0x10 */
X  volatile uint32_t IOHCR;          
N  uint32_t      RESERVED1;     /*!< Reserved,                                                 Address offset: 0x14 */
N  __IO uint32_t IOASCR;        /*!< TSC I/O analog switch control register,                   Address offset: 0x18 */
X  volatile uint32_t IOASCR;         
N  uint32_t      RESERVED2;     /*!< Reserved,                                                 Address offset: 0x1C */
N  __IO uint32_t IOSCR;         /*!< TSC I/O sampling control register,                        Address offset: 0x20 */
X  volatile uint32_t IOSCR;          
N  uint32_t      RESERVED3;     /*!< Reserved,                                                 Address offset: 0x24 */
N  __IO uint32_t IOCCR;         /*!< TSC I/O channel control register,                         Address offset: 0x28 */
X  volatile uint32_t IOCCR;          
N  uint32_t      RESERVED4;     /*!< Reserved,                                                 Address offset: 0x2C */
N  __IO uint32_t IOGCSR;        /*!< TSC I/O group control status register,                    Address offset: 0x30 */
X  volatile uint32_t IOGCSR;         
N  __IO uint32_t IOGXCR[7];     /*!< TSC I/O group x counter register,                         Address offset: 0x34-4C */
X  volatile uint32_t IOGXCR[7];      
N} TSC_TypeDef;
N
N/**
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< USART Control register 1,                 Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< USART Control register 2,                 Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t CR3;         /*!< USART Control register 3,                 Address offset: 0x08 */
X  volatile uint32_t CR3;          
N  __IO uint32_t BRR;         /*!< USART Baud rate register,                 Address offset: 0x0C */
X  volatile uint32_t BRR;          
N  __IO uint16_t GTPR;        /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
X  volatile uint16_t GTPR;         
N  uint16_t  RESERVED2;       /*!< Reserved, 0x12                                                 */
N  __IO uint32_t RTOR;        /*!< USART Receiver Time Out register,         Address offset: 0x14 */
X  volatile uint32_t RTOR;         
N  __IO uint16_t RQR;         /*!< USART Request register,                   Address offset: 0x18 */
X  volatile uint16_t RQR;          
N  uint16_t  RESERVED3;       /*!< Reserved, 0x1A                                                 */
N  __IO uint32_t ISR;         /*!< USART Interrupt and status register,      Address offset: 0x1C */
X  volatile uint32_t ISR;          
N  __IO uint32_t ICR;         /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X  volatile uint32_t ICR;          
N  __IO uint16_t RDR;         /*!< USART Receive Data register,              Address offset: 0x24 */
X  volatile uint16_t RDR;          
N  uint16_t  RESERVED4;       /*!< Reserved, 0x26                                                 */
N  __IO uint16_t TDR;         /*!< USART Transmit Data register,             Address offset: 0x28 */
X  volatile uint16_t TDR;          
N  uint16_t  RESERVED5;       /*!< Reserved, 0x2A                                                 */
N} USART_TypeDef;
N
N/**
N  * @brief VREFBUF
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< VREFBUF control and status register,         Address offset: 0x00 */
X  volatile uint32_t CSR;          
N  __IO uint32_t CCR;         /*!< VREFBUF calibration and control register,    Address offset: 0x04 */
X  volatile uint32_t CCR;          
N} VREFBUF_TypeDef;
N
N/**
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t CFR;         /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;          
N  __IO uint32_t SR;          /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;           
N} WWDG_TypeDef;
N
N/**
N  * @brief RNG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
X  volatile uint32_t CR;   
N  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
X  volatile uint32_t SR;   
N  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
X  volatile uint32_t DR;   
N} RNG_TypeDef;
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N#define FLASH_BASE            (0x08000000UL) /*!< FLASH(up to 256 KB) base address */
N#define SRAM1_BASE            (0x20000000UL) /*!< SRAM1(up to 48 KB) base address */
N#define SRAM2_BASE            (0x10000000UL) /*!< SRAM2(16 KB) base address */
N#define PERIPH_BASE           (0x40000000UL) /*!< Peripheral base address */
N#define QSPI_BASE             (0x90000000UL) /*!< QUADSPI memories accessible over AHB base address */
N
N#define QSPI_R_BASE           (0xA0001000UL) /*!< QUADSPI control registers base address */
N#define SRAM1_BB_BASE         (0x22000000UL) /*!< SRAM1(96 KB) base address in the bit-band region */
N#define PERIPH_BB_BASE        (0x42000000UL) /*!< Peripheral base address in the bit-band region */
N
N/* Legacy defines */
N#define SRAM_BASE             SRAM1_BASE
N#define SRAM_BB_BASE          SRAM1_BB_BASE
N
N#define SRAM1_SIZE_MAX        (0x0000C000UL) /*!< maximum SRAM1 size (up to 48 KBytes) */
N#define SRAM2_SIZE            (0x00004000UL) /*!< SRAM2 size (16 KBytes) */
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE        PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)
N#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000UL)
N
N
N/*!< APB1 peripherals */
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000UL)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000UL)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400UL)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800UL)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00UL)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000UL)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800UL)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00UL)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400UL)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800UL)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400UL)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800UL)
N#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00UL)
N#define CRS_BASE              (APB1PERIPH_BASE + 0x6000UL)
N#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400UL)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000UL)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400UL)
N#define DAC1_BASE             (APB1PERIPH_BASE + 0x7400UL)
N#define OPAMP_BASE            (APB1PERIPH_BASE + 0x7800UL)
N#define OPAMP1_BASE           (APB1PERIPH_BASE + 0x7800UL)
N#define LPTIM1_BASE           (APB1PERIPH_BASE + 0x7C00UL)
N#define LPUART1_BASE          (APB1PERIPH_BASE + 0x8000UL)
N#define SWPMI1_BASE           (APB1PERIPH_BASE + 0x8800UL)
N#define LPTIM2_BASE           (APB1PERIPH_BASE + 0x9400UL)
N
N
N/*!< APB2 peripherals */
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x0000UL)
N#define VREFBUF_BASE          (APB2PERIPH_BASE + 0x0030UL)
N#define COMP1_BASE            (APB2PERIPH_BASE + 0x0200UL)
N#define COMP2_BASE            (APB2PERIPH_BASE + 0x0204UL)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400UL)
N#define FIREWALL_BASE         (APB2PERIPH_BASE + 0x1C00UL)
N#define SDMMC1_BASE           (APB2PERIPH_BASE + 0x2800UL)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00UL)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000UL)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800UL)
N#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000UL)
N#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400UL)
N#define SAI1_BASE             (APB2PERIPH_BASE + 0x5400UL)
N#define SAI1_Block_A_BASE     (SAI1_BASE + 0x0004UL)
N#define SAI1_Block_B_BASE     (SAI1_BASE + 0x0024UL)
N
N/*!< AHB1 peripherals */
N#define DMA1_BASE             (AHB1PERIPH_BASE)
N#define DMA2_BASE             (AHB1PERIPH_BASE + 0x0400UL)
N#define RCC_BASE              (AHB1PERIPH_BASE + 0x1000UL)
N#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x2000UL)
N#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000UL)
N#define TSC_BASE              (AHB1PERIPH_BASE + 0x4000UL)
N
N
N#define DMA1_Channel1_BASE    (DMA1_BASE + 0x0008UL)
N#define DMA1_Channel2_BASE    (DMA1_BASE + 0x001CUL)
N#define DMA1_Channel3_BASE    (DMA1_BASE + 0x0030UL)
N#define DMA1_Channel4_BASE    (DMA1_BASE + 0x0044UL)
N#define DMA1_Channel5_BASE    (DMA1_BASE + 0x0058UL)
N#define DMA1_Channel6_BASE    (DMA1_BASE + 0x006CUL)
N#define DMA1_Channel7_BASE    (DMA1_BASE + 0x0080UL)
N#define DMA1_CSELR_BASE       (DMA1_BASE + 0x00A8UL)
N
N
N#define DMA2_Channel1_BASE    (DMA2_BASE + 0x0008UL)
N#define DMA2_Channel2_BASE    (DMA2_BASE + 0x001CUL)
N#define DMA2_Channel3_BASE    (DMA2_BASE + 0x0030UL)
N#define DMA2_Channel4_BASE    (DMA2_BASE + 0x0044UL)
N#define DMA2_Channel5_BASE    (DMA2_BASE + 0x0058UL)
N#define DMA2_Channel6_BASE    (DMA2_BASE + 0x006CUL)
N#define DMA2_Channel7_BASE    (DMA2_BASE + 0x0080UL)
N#define DMA2_CSELR_BASE       (DMA2_BASE + 0x00A8UL)
N
N
N/*!< AHB2 peripherals */
N#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x0000UL)
N#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x0400UL)
N#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x0800UL)
N#define GPIOD_BASE            (AHB2PERIPH_BASE + 0x0C00UL)
N#define GPIOE_BASE            (AHB2PERIPH_BASE + 0x1000UL)
N#define GPIOH_BASE            (AHB2PERIPH_BASE + 0x1C00UL)
N
N
N#define ADC1_BASE             (AHB2PERIPH_BASE + 0x08040000UL)
N#define ADC1_COMMON_BASE      (AHB2PERIPH_BASE + 0x08040300UL)
N
N
N#define RNG_BASE              (AHB2PERIPH_BASE + 0x08060800UL)
N
N
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE           (0xE0042000UL)
N
N
N#define PACKAGE_BASE          (0x1FFF7500UL)        /*!< Package data register base address     */
N#define UID_BASE              (0x1FFF7590UL)        /*!< Unique device ID register base address */
N#define FLASHSIZE_BASE        (0x1FFF75E0UL)        /*!< Flash size data register base address  */
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
N#define CRS                 ((CRS_TypeDef *) CRS_BASE)
N#define CAN                 ((CAN_TypeDef *) CAN1_BASE)
N#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC1_BASE)
N#define DAC1                ((DAC_TypeDef *) DAC1_BASE)
N#define OPAMP               ((OPAMP_TypeDef *) OPAMP_BASE)
N#define OPAMP1              ((OPAMP_TypeDef *) OPAMP1_BASE)
N#define OPAMP1_COMMON       ((OPAMP_Common_TypeDef *) OPAMP1_BASE)
N#define LPTIM1              ((LPTIM_TypeDef *) LPTIM1_BASE)
N#define LPUART1             ((USART_TypeDef *) LPUART1_BASE)
N#define SWPMI1              ((SWPMI_TypeDef *) SWPMI1_BASE)
N#define LPTIM2              ((LPTIM_TypeDef *) LPTIM2_BASE)
N
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define VREFBUF             ((VREFBUF_TypeDef *) VREFBUF_BASE)
N#define COMP1               ((COMP_TypeDef *) COMP1_BASE)
N#define COMP2               ((COMP_TypeDef *) COMP2_BASE)
N#define COMP12_COMMON       ((COMP_Common_TypeDef *) COMP2_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define FIREWALL            ((FIREWALL_TypeDef *) FIREWALL_BASE)
N#define SDMMC1              ((SDMMC_TypeDef *) SDMMC1_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define SAI1                ((SAI_TypeDef *) SAI1_BASE)
N#define SAI1_Block_A        ((SAI_Block_TypeDef *)SAI1_Block_A_BASE)
N#define SAI1_Block_B        ((SAI_Block_TypeDef *)SAI1_Block_B_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define TSC                 ((TSC_TypeDef *) TSC_BASE)
N
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC1_COMMON         ((ADC_Common_TypeDef *) ADC1_COMMON_BASE)
N#define RNG                 ((RNG_TypeDef *) RNG_BASE)
N
N
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#define DMA1_CSELR          ((DMA_Request_TypeDef *) DMA1_CSELR_BASE)
N
N
N#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#define DMA2_Channel6       ((DMA_Channel_TypeDef *) DMA2_Channel6_BASE)
N#define DMA2_Channel7       ((DMA_Channel_TypeDef *) DMA2_Channel7_BASE)
N#define DMA2_CSELR          ((DMA_Request_TypeDef *) DMA2_CSELR_BASE)
N
N
N
N#define QUADSPI             ((QUADSPI_TypeDef *) QSPI_R_BASE)
N
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N
N/** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter                         */
N/*                                                                            */
N/******************************************************************************/
N
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32L4 serie)
N */
N/* Note: No specific macro feature on this device */
N
N/********************  Bit definition for ADC_ISR register  *******************/
N#define ADC_ISR_ADRDY_Pos              (0U)
N#define ADC_ISR_ADRDY_Msk              (0x1UL << ADC_ISR_ADRDY_Pos)            /*!< 0x00000001 */
N#define ADC_ISR_ADRDY                  ADC_ISR_ADRDY_Msk                       /*!< ADC ready flag */
N#define ADC_ISR_EOSMP_Pos              (1U)
N#define ADC_ISR_EOSMP_Msk              (0x1UL << ADC_ISR_EOSMP_Pos)            /*!< 0x00000002 */
N#define ADC_ISR_EOSMP                  ADC_ISR_EOSMP_Msk                       /*!< ADC group regular end of sampling flag */
N#define ADC_ISR_EOC_Pos                (2U)
N#define ADC_ISR_EOC_Msk                (0x1UL << ADC_ISR_EOC_Pos)              /*!< 0x00000004 */
N#define ADC_ISR_EOC                    ADC_ISR_EOC_Msk                         /*!< ADC group regular end of unitary conversion flag */
N#define ADC_ISR_EOS_Pos                (3U)
N#define ADC_ISR_EOS_Msk                (0x1UL << ADC_ISR_EOS_Pos)              /*!< 0x00000008 */
N#define ADC_ISR_EOS                    ADC_ISR_EOS_Msk                         /*!< ADC group regular end of sequence conversions flag */
N#define ADC_ISR_OVR_Pos                (4U)
N#define ADC_ISR_OVR_Msk                (0x1UL << ADC_ISR_OVR_Pos)              /*!< 0x00000010 */
N#define ADC_ISR_OVR                    ADC_ISR_OVR_Msk                         /*!< ADC group regular overrun flag */
N#define ADC_ISR_JEOC_Pos               (5U)
N#define ADC_ISR_JEOC_Msk               (0x1UL << ADC_ISR_JEOC_Pos)             /*!< 0x00000020 */
N#define ADC_ISR_JEOC                   ADC_ISR_JEOC_Msk                        /*!< ADC group injected end of unitary conversion flag */
N#define ADC_ISR_JEOS_Pos               (6U)
N#define ADC_ISR_JEOS_Msk               (0x1UL << ADC_ISR_JEOS_Pos)             /*!< 0x00000040 */
N#define ADC_ISR_JEOS                   ADC_ISR_JEOS_Msk                        /*!< ADC group injected end of sequence conversions flag */
N#define ADC_ISR_AWD1_Pos               (7U)
N#define ADC_ISR_AWD1_Msk               (0x1UL << ADC_ISR_AWD1_Pos)             /*!< 0x00000080 */
N#define ADC_ISR_AWD1                   ADC_ISR_AWD1_Msk                        /*!< ADC analog watchdog 1 flag */
N#define ADC_ISR_AWD2_Pos               (8U)
N#define ADC_ISR_AWD2_Msk               (0x1UL << ADC_ISR_AWD2_Pos)             /*!< 0x00000100 */
N#define ADC_ISR_AWD2                   ADC_ISR_AWD2_Msk                        /*!< ADC analog watchdog 2 flag */
N#define ADC_ISR_AWD3_Pos               (9U)
N#define ADC_ISR_AWD3_Msk               (0x1UL << ADC_ISR_AWD3_Pos)             /*!< 0x00000200 */
N#define ADC_ISR_AWD3                   ADC_ISR_AWD3_Msk                        /*!< ADC analog watchdog 3 flag */
N#define ADC_ISR_JQOVF_Pos              (10U)
N#define ADC_ISR_JQOVF_Msk              (0x1UL << ADC_ISR_JQOVF_Pos)            /*!< 0x00000400 */
N#define ADC_ISR_JQOVF                  ADC_ISR_JQOVF_Msk                       /*!< ADC group injected contexts queue overflow flag */
N
N/********************  Bit definition for ADC_IER register  *******************/
N#define ADC_IER_ADRDYIE_Pos            (0U)
N#define ADC_IER_ADRDYIE_Msk            (0x1UL << ADC_IER_ADRDYIE_Pos)          /*!< 0x00000001 */
N#define ADC_IER_ADRDYIE                ADC_IER_ADRDYIE_Msk                     /*!< ADC ready interrupt */
N#define ADC_IER_EOSMPIE_Pos            (1U)
N#define ADC_IER_EOSMPIE_Msk            (0x1UL << ADC_IER_EOSMPIE_Pos)          /*!< 0x00000002 */
N#define ADC_IER_EOSMPIE                ADC_IER_EOSMPIE_Msk                     /*!< ADC group regular end of sampling interrupt */
N#define ADC_IER_EOCIE_Pos              (2U)
N#define ADC_IER_EOCIE_Msk              (0x1UL << ADC_IER_EOCIE_Pos)            /*!< 0x00000004 */
N#define ADC_IER_EOCIE                  ADC_IER_EOCIE_Msk                       /*!< ADC group regular end of unitary conversion interrupt */
N#define ADC_IER_EOSIE_Pos              (3U)
N#define ADC_IER_EOSIE_Msk              (0x1UL << ADC_IER_EOSIE_Pos)            /*!< 0x00000008 */
N#define ADC_IER_EOSIE                  ADC_IER_EOSIE_Msk                       /*!< ADC group regular end of sequence conversions interrupt */
N#define ADC_IER_OVRIE_Pos              (4U)
N#define ADC_IER_OVRIE_Msk              (0x1UL << ADC_IER_OVRIE_Pos)            /*!< 0x00000010 */
N#define ADC_IER_OVRIE                  ADC_IER_OVRIE_Msk                       /*!< ADC group regular overrun interrupt */
N#define ADC_IER_JEOCIE_Pos             (5U)
N#define ADC_IER_JEOCIE_Msk             (0x1UL << ADC_IER_JEOCIE_Pos)           /*!< 0x00000020 */
N#define ADC_IER_JEOCIE                 ADC_IER_JEOCIE_Msk                      /*!< ADC group injected end of unitary conversion interrupt */
N#define ADC_IER_JEOSIE_Pos             (6U)
N#define ADC_IER_JEOSIE_Msk             (0x1UL << ADC_IER_JEOSIE_Pos)           /*!< 0x00000040 */
N#define ADC_IER_JEOSIE                 ADC_IER_JEOSIE_Msk                      /*!< ADC group injected end of sequence conversions interrupt */
N#define ADC_IER_AWD1IE_Pos             (7U)
N#define ADC_IER_AWD1IE_Msk             (0x1UL << ADC_IER_AWD1IE_Pos)           /*!< 0x00000080 */
N#define ADC_IER_AWD1IE                 ADC_IER_AWD1IE_Msk                      /*!< ADC analog watchdog 1 interrupt */
N#define ADC_IER_AWD2IE_Pos             (8U)
N#define ADC_IER_AWD2IE_Msk             (0x1UL << ADC_IER_AWD2IE_Pos)           /*!< 0x00000100 */
N#define ADC_IER_AWD2IE                 ADC_IER_AWD2IE_Msk                      /*!< ADC analog watchdog 2 interrupt */
N#define ADC_IER_AWD3IE_Pos             (9U)
N#define ADC_IER_AWD3IE_Msk             (0x1UL << ADC_IER_AWD3IE_Pos)           /*!< 0x00000200 */
N#define ADC_IER_AWD3IE                 ADC_IER_AWD3IE_Msk                      /*!< ADC analog watchdog 3 interrupt */
N#define ADC_IER_JQOVFIE_Pos            (10U)
N#define ADC_IER_JQOVFIE_Msk            (0x1UL << ADC_IER_JQOVFIE_Pos)          /*!< 0x00000400 */
N#define ADC_IER_JQOVFIE                ADC_IER_JQOVFIE_Msk                     /*!< ADC group injected contexts queue overflow interrupt */
N
N/* Legacy defines */
N#define ADC_IER_ADRDY           (ADC_IER_ADRDYIE)
N#define ADC_IER_EOSMP           (ADC_IER_EOSMPIE)
N#define ADC_IER_EOC             (ADC_IER_EOCIE)
N#define ADC_IER_EOS             (ADC_IER_EOSIE)
N#define ADC_IER_OVR             (ADC_IER_OVRIE)
N#define ADC_IER_JEOC            (ADC_IER_JEOCIE)
N#define ADC_IER_JEOS            (ADC_IER_JEOSIE)
N#define ADC_IER_AWD1            (ADC_IER_AWD1IE)
N#define ADC_IER_AWD2            (ADC_IER_AWD2IE)
N#define ADC_IER_AWD3            (ADC_IER_AWD3IE)
N#define ADC_IER_JQOVF           (ADC_IER_JQOVFIE)
N
N/********************  Bit definition for ADC_CR register  ********************/
N#define ADC_CR_ADEN_Pos                (0U)
N#define ADC_CR_ADEN_Msk                (0x1UL << ADC_CR_ADEN_Pos)              /*!< 0x00000001 */
N#define ADC_CR_ADEN                    ADC_CR_ADEN_Msk                         /*!< ADC enable */
N#define ADC_CR_ADDIS_Pos               (1U)
N#define ADC_CR_ADDIS_Msk               (0x1UL << ADC_CR_ADDIS_Pos)             /*!< 0x00000002 */
N#define ADC_CR_ADDIS                   ADC_CR_ADDIS_Msk                        /*!< ADC disable */
N#define ADC_CR_ADSTART_Pos             (2U)
N#define ADC_CR_ADSTART_Msk             (0x1UL << ADC_CR_ADSTART_Pos)           /*!< 0x00000004 */
N#define ADC_CR_ADSTART                 ADC_CR_ADSTART_Msk                      /*!< ADC group regular conversion start */
N#define ADC_CR_JADSTART_Pos            (3U)
N#define ADC_CR_JADSTART_Msk            (0x1UL << ADC_CR_JADSTART_Pos)          /*!< 0x00000008 */
N#define ADC_CR_JADSTART                ADC_CR_JADSTART_Msk                     /*!< ADC group injected conversion start */
N#define ADC_CR_ADSTP_Pos               (4U)
N#define ADC_CR_ADSTP_Msk               (0x1UL << ADC_CR_ADSTP_Pos)             /*!< 0x00000010 */
N#define ADC_CR_ADSTP                   ADC_CR_ADSTP_Msk                        /*!< ADC group regular conversion stop */
N#define ADC_CR_JADSTP_Pos              (5U)
N#define ADC_CR_JADSTP_Msk              (0x1UL << ADC_CR_JADSTP_Pos)            /*!< 0x00000020 */
N#define ADC_CR_JADSTP                  ADC_CR_JADSTP_Msk                       /*!< ADC group injected conversion stop */
N#define ADC_CR_ADVREGEN_Pos            (28U)
N#define ADC_CR_ADVREGEN_Msk            (0x1UL << ADC_CR_ADVREGEN_Pos)          /*!< 0x10000000 */
N#define ADC_CR_ADVREGEN                ADC_CR_ADVREGEN_Msk                     /*!< ADC voltage regulator enable */
N#define ADC_CR_DEEPPWD_Pos             (29U)
N#define ADC_CR_DEEPPWD_Msk             (0x1UL << ADC_CR_DEEPPWD_Pos)           /*!< 0x20000000 */
N#define ADC_CR_DEEPPWD                 ADC_CR_DEEPPWD_Msk                      /*!< ADC deep power down enable */
N#define ADC_CR_ADCALDIF_Pos            (30U)
N#define ADC_CR_ADCALDIF_Msk            (0x1UL << ADC_CR_ADCALDIF_Pos)          /*!< 0x40000000 */
N#define ADC_CR_ADCALDIF                ADC_CR_ADCALDIF_Msk                     /*!< ADC differential mode for calibration */
N#define ADC_CR_ADCAL_Pos               (31U)
N#define ADC_CR_ADCAL_Msk               (0x1UL << ADC_CR_ADCAL_Pos)             /*!< 0x80000000 */
N#define ADC_CR_ADCAL                   ADC_CR_ADCAL_Msk                        /*!< ADC calibration */
N
N/********************  Bit definition for ADC_CFGR register  ******************/
N#define ADC_CFGR_DMAEN_Pos             (0U)
N#define ADC_CFGR_DMAEN_Msk             (0x1UL << ADC_CFGR_DMAEN_Pos)           /*!< 0x00000001 */
N#define ADC_CFGR_DMAEN                 ADC_CFGR_DMAEN_Msk                      /*!< ADC DMA transfer enable */
N#define ADC_CFGR_DMACFG_Pos            (1U)
N#define ADC_CFGR_DMACFG_Msk            (0x1UL << ADC_CFGR_DMACFG_Pos)          /*!< 0x00000002 */
N#define ADC_CFGR_DMACFG                ADC_CFGR_DMACFG_Msk                     /*!< ADC DMA transfer configuration */
N
N#define ADC_CFGR_RES_Pos               (3U)
N#define ADC_CFGR_RES_Msk               (0x3UL << ADC_CFGR_RES_Pos)             /*!< 0x00000018 */
N#define ADC_CFGR_RES                   ADC_CFGR_RES_Msk                        /*!< ADC data resolution */
N#define ADC_CFGR_RES_0                 (0x1UL << ADC_CFGR_RES_Pos)             /*!< 0x00000008 */
N#define ADC_CFGR_RES_1                 (0x2UL << ADC_CFGR_RES_Pos)             /*!< 0x00000010 */
N
N#define ADC_CFGR_ALIGN_Pos             (5U)
N#define ADC_CFGR_ALIGN_Msk             (0x1UL << ADC_CFGR_ALIGN_Pos)           /*!< 0x00000020 */
N#define ADC_CFGR_ALIGN                 ADC_CFGR_ALIGN_Msk                      /*!< ADC data alignement */
N
N#define ADC_CFGR_EXTSEL_Pos            (6U)
N#define ADC_CFGR_EXTSEL_Msk            (0xFUL << ADC_CFGR_EXTSEL_Pos)          /*!< 0x000003C0 */
N#define ADC_CFGR_EXTSEL                ADC_CFGR_EXTSEL_Msk                     /*!< ADC group regular external trigger source */
N#define ADC_CFGR_EXTSEL_0              (0x1UL << ADC_CFGR_EXTSEL_Pos)          /*!< 0x00000040 */
N#define ADC_CFGR_EXTSEL_1              (0x2UL << ADC_CFGR_EXTSEL_Pos)          /*!< 0x00000080 */
N#define ADC_CFGR_EXTSEL_2              (0x4UL << ADC_CFGR_EXTSEL_Pos)          /*!< 0x00000100 */
N#define ADC_CFGR_EXTSEL_3              (0x8UL << ADC_CFGR_EXTSEL_Pos)          /*!< 0x00000200 */
N
N#define ADC_CFGR_EXTEN_Pos             (10U)
N#define ADC_CFGR_EXTEN_Msk             (0x3UL << ADC_CFGR_EXTEN_Pos)           /*!< 0x00000C00 */
N#define ADC_CFGR_EXTEN                 ADC_CFGR_EXTEN_Msk                      /*!< ADC group regular external trigger polarity */
N#define ADC_CFGR_EXTEN_0               (0x1UL << ADC_CFGR_EXTEN_Pos)           /*!< 0x00000400 */
N#define ADC_CFGR_EXTEN_1               (0x2UL << ADC_CFGR_EXTEN_Pos)           /*!< 0x00000800 */
N
N#define ADC_CFGR_OVRMOD_Pos            (12U)
N#define ADC_CFGR_OVRMOD_Msk            (0x1UL << ADC_CFGR_OVRMOD_Pos)          /*!< 0x00001000 */
N#define ADC_CFGR_OVRMOD                ADC_CFGR_OVRMOD_Msk                     /*!< ADC group regular overrun configuration */
N#define ADC_CFGR_CONT_Pos              (13U)
N#define ADC_CFGR_CONT_Msk              (0x1UL << ADC_CFGR_CONT_Pos)            /*!< 0x00002000 */
N#define ADC_CFGR_CONT                  ADC_CFGR_CONT_Msk                       /*!< ADC group regular continuous conversion mode */
N#define ADC_CFGR_AUTDLY_Pos            (14U)
N#define ADC_CFGR_AUTDLY_Msk            (0x1UL << ADC_CFGR_AUTDLY_Pos)          /*!< 0x00004000 */
N#define ADC_CFGR_AUTDLY                ADC_CFGR_AUTDLY_Msk                     /*!< ADC low power auto wait */
N
N#define ADC_CFGR_DISCEN_Pos            (16U)
N#define ADC_CFGR_DISCEN_Msk            (0x1UL << ADC_CFGR_DISCEN_Pos)          /*!< 0x00010000 */
N#define ADC_CFGR_DISCEN                ADC_CFGR_DISCEN_Msk                     /*!< ADC group regular sequencer discontinuous mode */
N
N#define ADC_CFGR_DISCNUM_Pos           (17U)
N#define ADC_CFGR_DISCNUM_Msk           (0x7UL << ADC_CFGR_DISCNUM_Pos)         /*!< 0x000E0000 */
N#define ADC_CFGR_DISCNUM               ADC_CFGR_DISCNUM_Msk                    /*!< ADC group regular sequencer discontinuous number of ranks */
N#define ADC_CFGR_DISCNUM_0             (0x1UL << ADC_CFGR_DISCNUM_Pos)         /*!< 0x00020000 */
N#define ADC_CFGR_DISCNUM_1             (0x2UL << ADC_CFGR_DISCNUM_Pos)         /*!< 0x00040000 */
N#define ADC_CFGR_DISCNUM_2             (0x4UL << ADC_CFGR_DISCNUM_Pos)         /*!< 0x00080000 */
N
N#define ADC_CFGR_JDISCEN_Pos           (20U)
N#define ADC_CFGR_JDISCEN_Msk           (0x1UL << ADC_CFGR_JDISCEN_Pos)         /*!< 0x00100000 */
N#define ADC_CFGR_JDISCEN               ADC_CFGR_JDISCEN_Msk                    /*!< ADC group injected sequencer discontinuous mode */
N#define ADC_CFGR_JQM_Pos               (21U)
N#define ADC_CFGR_JQM_Msk               (0x1UL << ADC_CFGR_JQM_Pos)             /*!< 0x00200000 */
N#define ADC_CFGR_JQM                   ADC_CFGR_JQM_Msk                        /*!< ADC group injected contexts queue mode */
N#define ADC_CFGR_AWD1SGL_Pos           (22U)
N#define ADC_CFGR_AWD1SGL_Msk           (0x1UL << ADC_CFGR_AWD1SGL_Pos)         /*!< 0x00400000 */
N#define ADC_CFGR_AWD1SGL               ADC_CFGR_AWD1SGL_Msk                    /*!< ADC analog watchdog 1 monitoring a single channel or all channels */
N#define ADC_CFGR_AWD1EN_Pos            (23U)
N#define ADC_CFGR_AWD1EN_Msk            (0x1UL << ADC_CFGR_AWD1EN_Pos)          /*!< 0x00800000 */
N#define ADC_CFGR_AWD1EN                ADC_CFGR_AWD1EN_Msk                     /*!< ADC analog watchdog 1 enable on scope ADC group regular */
N#define ADC_CFGR_JAWD1EN_Pos           (24U)
N#define ADC_CFGR_JAWD1EN_Msk           (0x1UL << ADC_CFGR_JAWD1EN_Pos)         /*!< 0x01000000 */
N#define ADC_CFGR_JAWD1EN               ADC_CFGR_JAWD1EN_Msk                    /*!< ADC analog watchdog 1 enable on scope ADC group injected */
N#define ADC_CFGR_JAUTO_Pos             (25U)
N#define ADC_CFGR_JAUTO_Msk             (0x1UL << ADC_CFGR_JAUTO_Pos)           /*!< 0x02000000 */
N#define ADC_CFGR_JAUTO                 ADC_CFGR_JAUTO_Msk                      /*!< ADC group injected automatic trigger mode */
N
N#define ADC_CFGR_AWD1CH_Pos            (26U)
N#define ADC_CFGR_AWD1CH_Msk            (0x1FUL << ADC_CFGR_AWD1CH_Pos)         /*!< 0x7C000000 */
N#define ADC_CFGR_AWD1CH                ADC_CFGR_AWD1CH_Msk                     /*!< ADC analog watchdog 1 monitored channel selection */
N#define ADC_CFGR_AWD1CH_0              (0x01UL << ADC_CFGR_AWD1CH_Pos)         /*!< 0x04000000 */
N#define ADC_CFGR_AWD1CH_1              (0x02UL << ADC_CFGR_AWD1CH_Pos)         /*!< 0x08000000 */
N#define ADC_CFGR_AWD1CH_2              (0x04UL << ADC_CFGR_AWD1CH_Pos)         /*!< 0x10000000 */
N#define ADC_CFGR_AWD1CH_3              (0x08UL << ADC_CFGR_AWD1CH_Pos)         /*!< 0x20000000 */
N#define ADC_CFGR_AWD1CH_4              (0x10UL << ADC_CFGR_AWD1CH_Pos)         /*!< 0x40000000 */
N
N#define ADC_CFGR_JQDIS_Pos             (31U)
N#define ADC_CFGR_JQDIS_Msk             (0x1UL << ADC_CFGR_JQDIS_Pos)           /*!< 0x80000000 */
N#define ADC_CFGR_JQDIS                 ADC_CFGR_JQDIS_Msk                      /*!< ADC group injected contexts queue disable */
N
N/********************  Bit definition for ADC_CFGR2 register  *****************/
N#define ADC_CFGR2_ROVSE_Pos            (0U)
N#define ADC_CFGR2_ROVSE_Msk            (0x1UL << ADC_CFGR2_ROVSE_Pos)          /*!< 0x00000001 */
N#define ADC_CFGR2_ROVSE                ADC_CFGR2_ROVSE_Msk                     /*!< ADC oversampler enable on scope ADC group regular */
N#define ADC_CFGR2_JOVSE_Pos            (1U)
N#define ADC_CFGR2_JOVSE_Msk            (0x1UL << ADC_CFGR2_JOVSE_Pos)          /*!< 0x00000002 */
N#define ADC_CFGR2_JOVSE                ADC_CFGR2_JOVSE_Msk                     /*!< ADC oversampler enable on scope ADC group injected */
N
N#define ADC_CFGR2_OVSR_Pos             (2U)
N#define ADC_CFGR2_OVSR_Msk             (0x7UL << ADC_CFGR2_OVSR_Pos)           /*!< 0x0000001C */
N#define ADC_CFGR2_OVSR                 ADC_CFGR2_OVSR_Msk                      /*!< ADC oversampling ratio */
N#define ADC_CFGR2_OVSR_0               (0x1UL << ADC_CFGR2_OVSR_Pos)           /*!< 0x00000004 */
N#define ADC_CFGR2_OVSR_1               (0x2UL << ADC_CFGR2_OVSR_Pos)           /*!< 0x00000008 */
N#define ADC_CFGR2_OVSR_2               (0x4UL << ADC_CFGR2_OVSR_Pos)           /*!< 0x00000010 */
N
N#define ADC_CFGR2_OVSS_Pos             (5U)
N#define ADC_CFGR2_OVSS_Msk             (0xFUL << ADC_CFGR2_OVSS_Pos)           /*!< 0x000001E0 */
N#define ADC_CFGR2_OVSS                 ADC_CFGR2_OVSS_Msk                      /*!< ADC oversampling shift */
N#define ADC_CFGR2_OVSS_0               (0x1UL << ADC_CFGR2_OVSS_Pos)           /*!< 0x00000020 */
N#define ADC_CFGR2_OVSS_1               (0x2UL << ADC_CFGR2_OVSS_Pos)           /*!< 0x00000040 */
N#define ADC_CFGR2_OVSS_2               (0x4UL << ADC_CFGR2_OVSS_Pos)           /*!< 0x00000080 */
N#define ADC_CFGR2_OVSS_3               (0x8UL << ADC_CFGR2_OVSS_Pos)           /*!< 0x00000100 */
N
N#define ADC_CFGR2_TROVS_Pos            (9U)
N#define ADC_CFGR2_TROVS_Msk            (0x1UL << ADC_CFGR2_TROVS_Pos)          /*!< 0x00000200 */
N#define ADC_CFGR2_TROVS                ADC_CFGR2_TROVS_Msk                     /*!< ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
N#define ADC_CFGR2_ROVSM_Pos            (10U)
N#define ADC_CFGR2_ROVSM_Msk            (0x1UL << ADC_CFGR2_ROVSM_Pos)          /*!< 0x00000400 */
N#define ADC_CFGR2_ROVSM                ADC_CFGR2_ROVSM_Msk                     /*!< ADC oversampling mode managing interlaced conversions of ADC group regular and group injected */
N
N/********************  Bit definition for ADC_SMPR1 register  *****************/
N#define ADC_SMPR1_SMP0_Pos             (0U)
N#define ADC_SMPR1_SMP0_Msk             (0x7UL << ADC_SMPR1_SMP0_Pos)           /*!< 0x00000007 */
N#define ADC_SMPR1_SMP0                 ADC_SMPR1_SMP0_Msk                      /*!< ADC channel 0 sampling time selection  */
N#define ADC_SMPR1_SMP0_0               (0x1UL << ADC_SMPR1_SMP0_Pos)           /*!< 0x00000001 */
N#define ADC_SMPR1_SMP0_1               (0x2UL << ADC_SMPR1_SMP0_Pos)           /*!< 0x00000002 */
N#define ADC_SMPR1_SMP0_2               (0x4UL << ADC_SMPR1_SMP0_Pos)           /*!< 0x00000004 */
N
N#define ADC_SMPR1_SMP1_Pos             (3U)
N#define ADC_SMPR1_SMP1_Msk             (0x7UL << ADC_SMPR1_SMP1_Pos)           /*!< 0x00000038 */
N#define ADC_SMPR1_SMP1                 ADC_SMPR1_SMP1_Msk                      /*!< ADC channel 1 sampling time selection  */
N#define ADC_SMPR1_SMP1_0               (0x1UL << ADC_SMPR1_SMP1_Pos)           /*!< 0x00000008 */
N#define ADC_SMPR1_SMP1_1               (0x2UL << ADC_SMPR1_SMP1_Pos)           /*!< 0x00000010 */
N#define ADC_SMPR1_SMP1_2               (0x4UL << ADC_SMPR1_SMP1_Pos)           /*!< 0x00000020 */
N
N#define ADC_SMPR1_SMP2_Pos             (6U)
N#define ADC_SMPR1_SMP2_Msk             (0x7UL << ADC_SMPR1_SMP2_Pos)           /*!< 0x000001C0 */
N#define ADC_SMPR1_SMP2                 ADC_SMPR1_SMP2_Msk                      /*!< ADC channel 2 sampling time selection  */
N#define ADC_SMPR1_SMP2_0               (0x1UL << ADC_SMPR1_SMP2_Pos)           /*!< 0x00000040 */
N#define ADC_SMPR1_SMP2_1               (0x2UL << ADC_SMPR1_SMP2_Pos)           /*!< 0x00000080 */
N#define ADC_SMPR1_SMP2_2               (0x4UL << ADC_SMPR1_SMP2_Pos)           /*!< 0x00000100 */
N
N#define ADC_SMPR1_SMP3_Pos             (9U)
N#define ADC_SMPR1_SMP3_Msk             (0x7UL << ADC_SMPR1_SMP3_Pos)           /*!< 0x00000E00 */
N#define ADC_SMPR1_SMP3                 ADC_SMPR1_SMP3_Msk                      /*!< ADC channel 3 sampling time selection  */
N#define ADC_SMPR1_SMP3_0               (0x1UL << ADC_SMPR1_SMP3_Pos)           /*!< 0x00000200 */
N#define ADC_SMPR1_SMP3_1               (0x2UL << ADC_SMPR1_SMP3_Pos)           /*!< 0x00000400 */
N#define ADC_SMPR1_SMP3_2               (0x4UL << ADC_SMPR1_SMP3_Pos)           /*!< 0x00000800 */
N
N#define ADC_SMPR1_SMP4_Pos             (12U)
N#define ADC_SMPR1_SMP4_Msk             (0x7UL << ADC_SMPR1_SMP4_Pos)           /*!< 0x00007000 */
N#define ADC_SMPR1_SMP4                 ADC_SMPR1_SMP4_Msk                      /*!< ADC channel 4 sampling time selection  */
N#define ADC_SMPR1_SMP4_0               (0x1UL << ADC_SMPR1_SMP4_Pos)           /*!< 0x00001000 */
N#define ADC_SMPR1_SMP4_1               (0x2UL << ADC_SMPR1_SMP4_Pos)           /*!< 0x00002000 */
N#define ADC_SMPR1_SMP4_2               (0x4UL << ADC_SMPR1_SMP4_Pos)           /*!< 0x00004000 */
N
N#define ADC_SMPR1_SMP5_Pos             (15U)
N#define ADC_SMPR1_SMP5_Msk             (0x7UL << ADC_SMPR1_SMP5_Pos)           /*!< 0x00038000 */
N#define ADC_SMPR1_SMP5                 ADC_SMPR1_SMP5_Msk                      /*!< ADC channel 5 sampling time selection  */
N#define ADC_SMPR1_SMP5_0               (0x1UL << ADC_SMPR1_SMP5_Pos)           /*!< 0x00008000 */
N#define ADC_SMPR1_SMP5_1               (0x2UL << ADC_SMPR1_SMP5_Pos)           /*!< 0x00010000 */
N#define ADC_SMPR1_SMP5_2               (0x4UL << ADC_SMPR1_SMP5_Pos)           /*!< 0x00020000 */
N
N#define ADC_SMPR1_SMP6_Pos             (18U)
N#define ADC_SMPR1_SMP6_Msk             (0x7UL << ADC_SMPR1_SMP6_Pos)           /*!< 0x001C0000 */
N#define ADC_SMPR1_SMP6                 ADC_SMPR1_SMP6_Msk                      /*!< ADC channel 6 sampling time selection  */
N#define ADC_SMPR1_SMP6_0               (0x1UL << ADC_SMPR1_SMP6_Pos)           /*!< 0x00040000 */
N#define ADC_SMPR1_SMP6_1               (0x2UL << ADC_SMPR1_SMP6_Pos)           /*!< 0x00080000 */
N#define ADC_SMPR1_SMP6_2               (0x4UL << ADC_SMPR1_SMP6_Pos)           /*!< 0x00100000 */
N
N#define ADC_SMPR1_SMP7_Pos             (21U)
N#define ADC_SMPR1_SMP7_Msk             (0x7UL << ADC_SMPR1_SMP7_Pos)           /*!< 0x00E00000 */
N#define ADC_SMPR1_SMP7                 ADC_SMPR1_SMP7_Msk                      /*!< ADC channel 7 sampling time selection  */
N#define ADC_SMPR1_SMP7_0               (0x1UL << ADC_SMPR1_SMP7_Pos)           /*!< 0x00200000 */
N#define ADC_SMPR1_SMP7_1               (0x2UL << ADC_SMPR1_SMP7_Pos)           /*!< 0x00400000 */
N#define ADC_SMPR1_SMP7_2               (0x4UL << ADC_SMPR1_SMP7_Pos)           /*!< 0x00800000 */
N
N#define ADC_SMPR1_SMP8_Pos             (24U)
N#define ADC_SMPR1_SMP8_Msk             (0x7UL << ADC_SMPR1_SMP8_Pos)           /*!< 0x07000000 */
N#define ADC_SMPR1_SMP8                 ADC_SMPR1_SMP8_Msk                      /*!< ADC channel 8 sampling time selection  */
N#define ADC_SMPR1_SMP8_0               (0x1UL << ADC_SMPR1_SMP8_Pos)           /*!< 0x01000000 */
N#define ADC_SMPR1_SMP8_1               (0x2UL << ADC_SMPR1_SMP8_Pos)           /*!< 0x02000000 */
N#define ADC_SMPR1_SMP8_2               (0x4UL << ADC_SMPR1_SMP8_Pos)           /*!< 0x04000000 */
N
N#define ADC_SMPR1_SMP9_Pos             (27U)
N#define ADC_SMPR1_SMP9_Msk             (0x7UL << ADC_SMPR1_SMP9_Pos)           /*!< 0x38000000 */
N#define ADC_SMPR1_SMP9                 ADC_SMPR1_SMP9_Msk                      /*!< ADC channel 9 sampling time selection  */
N#define ADC_SMPR1_SMP9_0               (0x1UL << ADC_SMPR1_SMP9_Pos)           /*!< 0x08000000 */
N#define ADC_SMPR1_SMP9_1               (0x2UL << ADC_SMPR1_SMP9_Pos)           /*!< 0x10000000 */
N#define ADC_SMPR1_SMP9_2               (0x4UL << ADC_SMPR1_SMP9_Pos)           /*!< 0x20000000 */
N
N/********************  Bit definition for ADC_SMPR2 register  *****************/
N#define ADC_SMPR2_SMP10_Pos            (0U)
N#define ADC_SMPR2_SMP10_Msk            (0x7UL << ADC_SMPR2_SMP10_Pos)          /*!< 0x00000007 */
N#define ADC_SMPR2_SMP10                ADC_SMPR2_SMP10_Msk                     /*!< ADC channel 10 sampling time selection  */
N#define ADC_SMPR2_SMP10_0              (0x1UL << ADC_SMPR2_SMP10_Pos)          /*!< 0x00000001 */
N#define ADC_SMPR2_SMP10_1              (0x2UL << ADC_SMPR2_SMP10_Pos)          /*!< 0x00000002 */
N#define ADC_SMPR2_SMP10_2              (0x4UL << ADC_SMPR2_SMP10_Pos)          /*!< 0x00000004 */
N
N#define ADC_SMPR2_SMP11_Pos            (3U)
N#define ADC_SMPR2_SMP11_Msk            (0x7UL << ADC_SMPR2_SMP11_Pos)          /*!< 0x00000038 */
N#define ADC_SMPR2_SMP11                ADC_SMPR2_SMP11_Msk                     /*!< ADC channel 11 sampling time selection  */
N#define ADC_SMPR2_SMP11_0              (0x1UL << ADC_SMPR2_SMP11_Pos)          /*!< 0x00000008 */
N#define ADC_SMPR2_SMP11_1              (0x2UL << ADC_SMPR2_SMP11_Pos)          /*!< 0x00000010 */
N#define ADC_SMPR2_SMP11_2              (0x4UL << ADC_SMPR2_SMP11_Pos)          /*!< 0x00000020 */
N
N#define ADC_SMPR2_SMP12_Pos            (6U)
N#define ADC_SMPR2_SMP12_Msk            (0x7UL << ADC_SMPR2_SMP12_Pos)          /*!< 0x000001C0 */
N#define ADC_SMPR2_SMP12                ADC_SMPR2_SMP12_Msk                     /*!< ADC channel 12 sampling time selection  */
N#define ADC_SMPR2_SMP12_0              (0x1UL << ADC_SMPR2_SMP12_Pos)          /*!< 0x00000040 */
N#define ADC_SMPR2_SMP12_1              (0x2UL << ADC_SMPR2_SMP12_Pos)          /*!< 0x00000080 */
N#define ADC_SMPR2_SMP12_2              (0x4UL << ADC_SMPR2_SMP12_Pos)          /*!< 0x00000100 */
N
N#define ADC_SMPR2_SMP13_Pos            (9U)
N#define ADC_SMPR2_SMP13_Msk            (0x7UL << ADC_SMPR2_SMP13_Pos)          /*!< 0x00000E00 */
N#define ADC_SMPR2_SMP13                ADC_SMPR2_SMP13_Msk                     /*!< ADC channel 13 sampling time selection  */
N#define ADC_SMPR2_SMP13_0              (0x1UL << ADC_SMPR2_SMP13_Pos)          /*!< 0x00000200 */
N#define ADC_SMPR2_SMP13_1              (0x2UL << ADC_SMPR2_SMP13_Pos)          /*!< 0x00000400 */
N#define ADC_SMPR2_SMP13_2              (0x4UL << ADC_SMPR2_SMP13_Pos)          /*!< 0x00000800 */
N
N#define ADC_SMPR2_SMP14_Pos            (12U)
N#define ADC_SMPR2_SMP14_Msk            (0x7UL << ADC_SMPR2_SMP14_Pos)          /*!< 0x00007000 */
N#define ADC_SMPR2_SMP14                ADC_SMPR2_SMP14_Msk                     /*!< ADC channel 14 sampling time selection  */
N#define ADC_SMPR2_SMP14_0              (0x1UL << ADC_SMPR2_SMP14_Pos)          /*!< 0x00001000 */
N#define ADC_SMPR2_SMP14_1              (0x2UL << ADC_SMPR2_SMP14_Pos)          /*!< 0x00002000 */
N#define ADC_SMPR2_SMP14_2              (0x4UL << ADC_SMPR2_SMP14_Pos)          /*!< 0x00004000 */
N
N#define ADC_SMPR2_SMP15_Pos            (15U)
N#define ADC_SMPR2_SMP15_Msk            (0x7UL << ADC_SMPR2_SMP15_Pos)          /*!< 0x00038000 */
N#define ADC_SMPR2_SMP15                ADC_SMPR2_SMP15_Msk                     /*!< ADC channel 15 sampling time selection  */
N#define ADC_SMPR2_SMP15_0              (0x1UL << ADC_SMPR2_SMP15_Pos)          /*!< 0x00008000 */
N#define ADC_SMPR2_SMP15_1              (0x2UL << ADC_SMPR2_SMP15_Pos)          /*!< 0x00010000 */
N#define ADC_SMPR2_SMP15_2              (0x4UL << ADC_SMPR2_SMP15_Pos)          /*!< 0x00020000 */
N
N#define ADC_SMPR2_SMP16_Pos            (18U)
N#define ADC_SMPR2_SMP16_Msk            (0x7UL << ADC_SMPR2_SMP16_Pos)          /*!< 0x001C0000 */
N#define ADC_SMPR2_SMP16                ADC_SMPR2_SMP16_Msk                     /*!< ADC channel 16 sampling time selection  */
N#define ADC_SMPR2_SMP16_0              (0x1UL << ADC_SMPR2_SMP16_Pos)          /*!< 0x00040000 */
N#define ADC_SMPR2_SMP16_1              (0x2UL << ADC_SMPR2_SMP16_Pos)          /*!< 0x00080000 */
N#define ADC_SMPR2_SMP16_2              (0x4UL << ADC_SMPR2_SMP16_Pos)          /*!< 0x00100000 */
N
N#define ADC_SMPR2_SMP17_Pos            (21U)
N#define ADC_SMPR2_SMP17_Msk            (0x7UL << ADC_SMPR2_SMP17_Pos)          /*!< 0x00E00000 */
N#define ADC_SMPR2_SMP17                ADC_SMPR2_SMP17_Msk                     /*!< ADC channel 17 sampling time selection  */
N#define ADC_SMPR2_SMP17_0              (0x1UL << ADC_SMPR2_SMP17_Pos)          /*!< 0x00200000 */
N#define ADC_SMPR2_SMP17_1              (0x2UL << ADC_SMPR2_SMP17_Pos)          /*!< 0x00400000 */
N#define ADC_SMPR2_SMP17_2              (0x4UL << ADC_SMPR2_SMP17_Pos)          /*!< 0x00800000 */
N
N#define ADC_SMPR2_SMP18_Pos            (24U)
N#define ADC_SMPR2_SMP18_Msk            (0x7UL << ADC_SMPR2_SMP18_Pos)          /*!< 0x07000000 */
N#define ADC_SMPR2_SMP18                ADC_SMPR2_SMP18_Msk                     /*!< ADC channel 18 sampling time selection  */
N#define ADC_SMPR2_SMP18_0              (0x1UL << ADC_SMPR2_SMP18_Pos)          /*!< 0x01000000 */
N#define ADC_SMPR2_SMP18_1              (0x2UL << ADC_SMPR2_SMP18_Pos)          /*!< 0x02000000 */
N#define ADC_SMPR2_SMP18_2              (0x4UL << ADC_SMPR2_SMP18_Pos)          /*!< 0x04000000 */
N
N/********************  Bit definition for ADC_TR1 register  *******************/
N#define ADC_TR1_LT1_Pos                (0U)
N#define ADC_TR1_LT1_Msk                (0xFFFUL << ADC_TR1_LT1_Pos)            /*!< 0x00000FFF */
N#define ADC_TR1_LT1                    ADC_TR1_LT1_Msk                         /*!< ADC analog watchdog 1 threshold low */
N#define ADC_TR1_LT1_0                  (0x001UL << ADC_TR1_LT1_Pos)            /*!< 0x00000001 */
N#define ADC_TR1_LT1_1                  (0x002UL << ADC_TR1_LT1_Pos)            /*!< 0x00000002 */
N#define ADC_TR1_LT1_2                  (0x004UL << ADC_TR1_LT1_Pos)            /*!< 0x00000004 */
N#define ADC_TR1_LT1_3                  (0x008UL << ADC_TR1_LT1_Pos)            /*!< 0x00000008 */
N#define ADC_TR1_LT1_4                  (0x010UL << ADC_TR1_LT1_Pos)            /*!< 0x00000010 */
N#define ADC_TR1_LT1_5                  (0x020UL << ADC_TR1_LT1_Pos)            /*!< 0x00000020 */
N#define ADC_TR1_LT1_6                  (0x040UL << ADC_TR1_LT1_Pos)            /*!< 0x00000040 */
N#define ADC_TR1_LT1_7                  (0x080UL << ADC_TR1_LT1_Pos)            /*!< 0x00000080 */
N#define ADC_TR1_LT1_8                  (0x100UL << ADC_TR1_LT1_Pos)            /*!< 0x00000100 */
N#define ADC_TR1_LT1_9                  (0x200UL << ADC_TR1_LT1_Pos)            /*!< 0x00000200 */
N#define ADC_TR1_LT1_10                 (0x400UL << ADC_TR1_LT1_Pos)            /*!< 0x00000400 */
N#define ADC_TR1_LT1_11                 (0x800UL << ADC_TR1_LT1_Pos)            /*!< 0x00000800 */
N
N#define ADC_TR1_HT1_Pos                (16U)
N#define ADC_TR1_HT1_Msk                (0xFFFUL << ADC_TR1_HT1_Pos)            /*!< 0x0FFF0000 */
N#define ADC_TR1_HT1                    ADC_TR1_HT1_Msk                         /*!< ADC Analog watchdog 1 threshold high */
N#define ADC_TR1_HT1_0                  (0x001UL << ADC_TR1_HT1_Pos)            /*!< 0x00010000 */
N#define ADC_TR1_HT1_1                  (0x002UL << ADC_TR1_HT1_Pos)            /*!< 0x00020000 */
N#define ADC_TR1_HT1_2                  (0x004UL << ADC_TR1_HT1_Pos)            /*!< 0x00040000 */
N#define ADC_TR1_HT1_3                  (0x008UL << ADC_TR1_HT1_Pos)            /*!< 0x00080000 */
N#define ADC_TR1_HT1_4                  (0x010UL << ADC_TR1_HT1_Pos)            /*!< 0x00100000 */
N#define ADC_TR1_HT1_5                  (0x020UL << ADC_TR1_HT1_Pos)            /*!< 0x00200000 */
N#define ADC_TR1_HT1_6                  (0x040UL << ADC_TR1_HT1_Pos)            /*!< 0x00400000 */
N#define ADC_TR1_HT1_7                  (0x080UL << ADC_TR1_HT1_Pos)            /*!< 0x00800000 */
N#define ADC_TR1_HT1_8                  (0x100UL << ADC_TR1_HT1_Pos)            /*!< 0x01000000 */
N#define ADC_TR1_HT1_9                  (0x200UL << ADC_TR1_HT1_Pos)            /*!< 0x02000000 */
N#define ADC_TR1_HT1_10                 (0x400UL << ADC_TR1_HT1_Pos)            /*!< 0x04000000 */
N#define ADC_TR1_HT1_11                 (0x800UL << ADC_TR1_HT1_Pos)            /*!< 0x08000000 */
N
N/********************  Bit definition for ADC_TR2 register  *******************/
N#define ADC_TR2_LT2_Pos                (0U)
N#define ADC_TR2_LT2_Msk                (0xFFUL << ADC_TR2_LT2_Pos)             /*!< 0x000000FF */
N#define ADC_TR2_LT2                    ADC_TR2_LT2_Msk                         /*!< ADC analog watchdog 2 threshold low */
N#define ADC_TR2_LT2_0                  (0x01UL << ADC_TR2_LT2_Pos)             /*!< 0x00000001 */
N#define ADC_TR2_LT2_1                  (0x02UL << ADC_TR2_LT2_Pos)             /*!< 0x00000002 */
N#define ADC_TR2_LT2_2                  (0x04UL << ADC_TR2_LT2_Pos)             /*!< 0x00000004 */
N#define ADC_TR2_LT2_3                  (0x08UL << ADC_TR2_LT2_Pos)             /*!< 0x00000008 */
N#define ADC_TR2_LT2_4                  (0x10UL << ADC_TR2_LT2_Pos)             /*!< 0x00000010 */
N#define ADC_TR2_LT2_5                  (0x20UL << ADC_TR2_LT2_Pos)             /*!< 0x00000020 */
N#define ADC_TR2_LT2_6                  (0x40UL << ADC_TR2_LT2_Pos)             /*!< 0x00000040 */
N#define ADC_TR2_LT2_7                  (0x80UL << ADC_TR2_LT2_Pos)             /*!< 0x00000080 */
N
N#define ADC_TR2_HT2_Pos                (16U)
N#define ADC_TR2_HT2_Msk                (0xFFUL << ADC_TR2_HT2_Pos)             /*!< 0x00FF0000 */
N#define ADC_TR2_HT2                    ADC_TR2_HT2_Msk                         /*!< ADC analog watchdog 2 threshold high */
N#define ADC_TR2_HT2_0                  (0x01UL << ADC_TR2_HT2_Pos)             /*!< 0x00010000 */
N#define ADC_TR2_HT2_1                  (0x02UL << ADC_TR2_HT2_Pos)             /*!< 0x00020000 */
N#define ADC_TR2_HT2_2                  (0x04UL << ADC_TR2_HT2_Pos)             /*!< 0x00040000 */
N#define ADC_TR2_HT2_3                  (0x08UL << ADC_TR2_HT2_Pos)             /*!< 0x00080000 */
N#define ADC_TR2_HT2_4                  (0x10UL << ADC_TR2_HT2_Pos)             /*!< 0x00100000 */
N#define ADC_TR2_HT2_5                  (0x20UL << ADC_TR2_HT2_Pos)             /*!< 0x00200000 */
N#define ADC_TR2_HT2_6                  (0x40UL << ADC_TR2_HT2_Pos)             /*!< 0x00400000 */
N#define ADC_TR2_HT2_7                  (0x80UL << ADC_TR2_HT2_Pos)             /*!< 0x00800000 */
N
N/********************  Bit definition for ADC_TR3 register  *******************/
N#define ADC_TR3_LT3_Pos                (0U)
N#define ADC_TR3_LT3_Msk                (0xFFUL << ADC_TR3_LT3_Pos)             /*!< 0x000000FF */
N#define ADC_TR3_LT3                    ADC_TR3_LT3_Msk                         /*!< ADC analog watchdog 3 threshold low */
N#define ADC_TR3_LT3_0                  (0x01UL << ADC_TR3_LT3_Pos)             /*!< 0x00000001 */
N#define ADC_TR3_LT3_1                  (0x02UL << ADC_TR3_LT3_Pos)             /*!< 0x00000002 */
N#define ADC_TR3_LT3_2                  (0x04UL << ADC_TR3_LT3_Pos)             /*!< 0x00000004 */
N#define ADC_TR3_LT3_3                  (0x08UL << ADC_TR3_LT3_Pos)             /*!< 0x00000008 */
N#define ADC_TR3_LT3_4                  (0x10UL << ADC_TR3_LT3_Pos)             /*!< 0x00000010 */
N#define ADC_TR3_LT3_5                  (0x20UL << ADC_TR3_LT3_Pos)             /*!< 0x00000020 */
N#define ADC_TR3_LT3_6                  (0x40UL << ADC_TR3_LT3_Pos)             /*!< 0x00000040 */
N#define ADC_TR3_LT3_7                  (0x80UL << ADC_TR3_LT3_Pos)             /*!< 0x00000080 */
N
N#define ADC_TR3_HT3_Pos                (16U)
N#define ADC_TR3_HT3_Msk                (0xFFUL << ADC_TR3_HT3_Pos)             /*!< 0x00FF0000 */
N#define ADC_TR3_HT3                    ADC_TR3_HT3_Msk                         /*!< ADC analog watchdog 3 threshold high */
N#define ADC_TR3_HT3_0                  (0x01UL << ADC_TR3_HT3_Pos)             /*!< 0x00010000 */
N#define ADC_TR3_HT3_1                  (0x02UL << ADC_TR3_HT3_Pos)             /*!< 0x00020000 */
N#define ADC_TR3_HT3_2                  (0x04UL << ADC_TR3_HT3_Pos)             /*!< 0x00040000 */
N#define ADC_TR3_HT3_3                  (0x08UL << ADC_TR3_HT3_Pos)             /*!< 0x00080000 */
N#define ADC_TR3_HT3_4                  (0x10UL << ADC_TR3_HT3_Pos)             /*!< 0x00100000 */
N#define ADC_TR3_HT3_5                  (0x20UL << ADC_TR3_HT3_Pos)             /*!< 0x00200000 */
N#define ADC_TR3_HT3_6                  (0x40UL << ADC_TR3_HT3_Pos)             /*!< 0x00400000 */
N#define ADC_TR3_HT3_7                  (0x80UL << ADC_TR3_HT3_Pos)             /*!< 0x00800000 */
N
N/********************  Bit definition for ADC_SQR1 register  ******************/
N#define ADC_SQR1_L_Pos                 (0U)
N#define ADC_SQR1_L_Msk                 (0xFUL << ADC_SQR1_L_Pos)               /*!< 0x0000000F */
N#define ADC_SQR1_L                     ADC_SQR1_L_Msk                          /*!< ADC group regular sequencer scan length */
N#define ADC_SQR1_L_0                   (0x1UL << ADC_SQR1_L_Pos)               /*!< 0x00000001 */
N#define ADC_SQR1_L_1                   (0x2UL << ADC_SQR1_L_Pos)               /*!< 0x00000002 */
N#define ADC_SQR1_L_2                   (0x4UL << ADC_SQR1_L_Pos)               /*!< 0x00000004 */
N#define ADC_SQR1_L_3                   (0x8UL << ADC_SQR1_L_Pos)               /*!< 0x00000008 */
N
N#define ADC_SQR1_SQ1_Pos               (6U)
N#define ADC_SQR1_SQ1_Msk               (0x1FUL << ADC_SQR1_SQ1_Pos)            /*!< 0x000007C0 */
N#define ADC_SQR1_SQ1                   ADC_SQR1_SQ1_Msk                        /*!< ADC group regular sequencer rank 1 */
N#define ADC_SQR1_SQ1_0                 (0x01UL << ADC_SQR1_SQ1_Pos)            /*!< 0x00000040 */
N#define ADC_SQR1_SQ1_1                 (0x02UL << ADC_SQR1_SQ1_Pos)            /*!< 0x00000080 */
N#define ADC_SQR1_SQ1_2                 (0x04UL << ADC_SQR1_SQ1_Pos)            /*!< 0x00000100 */
N#define ADC_SQR1_SQ1_3                 (0x08UL << ADC_SQR1_SQ1_Pos)            /*!< 0x00000200 */
N#define ADC_SQR1_SQ1_4                 (0x10UL << ADC_SQR1_SQ1_Pos)            /*!< 0x00000400 */
N
N#define ADC_SQR1_SQ2_Pos               (12U)
N#define ADC_SQR1_SQ2_Msk               (0x1FUL << ADC_SQR1_SQ2_Pos)            /*!< 0x0001F000 */
N#define ADC_SQR1_SQ2                   ADC_SQR1_SQ2_Msk                        /*!< ADC group regular sequencer rank 2 */
N#define ADC_SQR1_SQ2_0                 (0x01UL << ADC_SQR1_SQ2_Pos)            /*!< 0x00001000 */
N#define ADC_SQR1_SQ2_1                 (0x02UL << ADC_SQR1_SQ2_Pos)            /*!< 0x00002000 */
N#define ADC_SQR1_SQ2_2                 (0x04UL << ADC_SQR1_SQ2_Pos)            /*!< 0x00004000 */
N#define ADC_SQR1_SQ2_3                 (0x08UL << ADC_SQR1_SQ2_Pos)            /*!< 0x00008000 */
N#define ADC_SQR1_SQ2_4                 (0x10UL << ADC_SQR1_SQ2_Pos)            /*!< 0x00010000 */
N
N#define ADC_SQR1_SQ3_Pos               (18U)
N#define ADC_SQR1_SQ3_Msk               (0x1FUL << ADC_SQR1_SQ3_Pos)            /*!< 0x007C0000 */
N#define ADC_SQR1_SQ3                   ADC_SQR1_SQ3_Msk                        /*!< ADC group regular sequencer rank 3 */
N#define ADC_SQR1_SQ3_0                 (0x01UL << ADC_SQR1_SQ3_Pos)            /*!< 0x00040000 */
N#define ADC_SQR1_SQ3_1                 (0x02UL << ADC_SQR1_SQ3_Pos)            /*!< 0x00080000 */
N#define ADC_SQR1_SQ3_2                 (0x04UL << ADC_SQR1_SQ3_Pos)            /*!< 0x00100000 */
N#define ADC_SQR1_SQ3_3                 (0x08UL << ADC_SQR1_SQ3_Pos)            /*!< 0x00200000 */
N#define ADC_SQR1_SQ3_4                 (0x10UL << ADC_SQR1_SQ3_Pos)            /*!< 0x00400000 */
N
N#define ADC_SQR1_SQ4_Pos               (24U)
N#define ADC_SQR1_SQ4_Msk               (0x1FUL << ADC_SQR1_SQ4_Pos)            /*!< 0x1F000000 */
N#define ADC_SQR1_SQ4                   ADC_SQR1_SQ4_Msk                        /*!< ADC group regular sequencer rank 4 */
N#define ADC_SQR1_SQ4_0                 (0x01UL << ADC_SQR1_SQ4_Pos)            /*!< 0x01000000 */
N#define ADC_SQR1_SQ4_1                 (0x02UL << ADC_SQR1_SQ4_Pos)            /*!< 0x02000000 */
N#define ADC_SQR1_SQ4_2                 (0x04UL << ADC_SQR1_SQ4_Pos)            /*!< 0x04000000 */
N#define ADC_SQR1_SQ4_3                 (0x08UL << ADC_SQR1_SQ4_Pos)            /*!< 0x08000000 */
N#define ADC_SQR1_SQ4_4                 (0x10UL << ADC_SQR1_SQ4_Pos)            /*!< 0x10000000 */
N
N/********************  Bit definition for ADC_SQR2 register  ******************/
N#define ADC_SQR2_SQ5_Pos               (0U)
N#define ADC_SQR2_SQ5_Msk               (0x1FUL << ADC_SQR2_SQ5_Pos)            /*!< 0x0000001F */
N#define ADC_SQR2_SQ5                   ADC_SQR2_SQ5_Msk                        /*!< ADC group regular sequencer rank 5 */
N#define ADC_SQR2_SQ5_0                 (0x01UL << ADC_SQR2_SQ5_Pos)            /*!< 0x00000001 */
N#define ADC_SQR2_SQ5_1                 (0x02UL << ADC_SQR2_SQ5_Pos)            /*!< 0x00000002 */
N#define ADC_SQR2_SQ5_2                 (0x04UL << ADC_SQR2_SQ5_Pos)            /*!< 0x00000004 */
N#define ADC_SQR2_SQ5_3                 (0x08UL << ADC_SQR2_SQ5_Pos)            /*!< 0x00000008 */
N#define ADC_SQR2_SQ5_4                 (0x10UL << ADC_SQR2_SQ5_Pos)            /*!< 0x00000010 */
N
N#define ADC_SQR2_SQ6_Pos               (6U)
N#define ADC_SQR2_SQ6_Msk               (0x1FUL << ADC_SQR2_SQ6_Pos)            /*!< 0x000007C0 */
N#define ADC_SQR2_SQ6                   ADC_SQR2_SQ6_Msk                        /*!< ADC group regular sequencer rank 6 */
N#define ADC_SQR2_SQ6_0                 (0x01UL << ADC_SQR2_SQ6_Pos)            /*!< 0x00000040 */
N#define ADC_SQR2_SQ6_1                 (0x02UL << ADC_SQR2_SQ6_Pos)            /*!< 0x00000080 */
N#define ADC_SQR2_SQ6_2                 (0x04UL << ADC_SQR2_SQ6_Pos)            /*!< 0x00000100 */
N#define ADC_SQR2_SQ6_3                 (0x08UL << ADC_SQR2_SQ6_Pos)            /*!< 0x00000200 */
N#define ADC_SQR2_SQ6_4                 (0x10UL << ADC_SQR2_SQ6_Pos)            /*!< 0x00000400 */
N
N#define ADC_SQR2_SQ7_Pos               (12U)
N#define ADC_SQR2_SQ7_Msk               (0x1FUL << ADC_SQR2_SQ7_Pos)            /*!< 0x0001F000 */
N#define ADC_SQR2_SQ7                   ADC_SQR2_SQ7_Msk                        /*!< ADC group regular sequencer rank 7 */
N#define ADC_SQR2_SQ7_0                 (0x01UL << ADC_SQR2_SQ7_Pos)            /*!< 0x00001000 */
N#define ADC_SQR2_SQ7_1                 (0x02UL << ADC_SQR2_SQ7_Pos)            /*!< 0x00002000 */
N#define ADC_SQR2_SQ7_2                 (0x04UL << ADC_SQR2_SQ7_Pos)            /*!< 0x00004000 */
N#define ADC_SQR2_SQ7_3                 (0x08UL << ADC_SQR2_SQ7_Pos)            /*!< 0x00008000 */
N#define ADC_SQR2_SQ7_4                 (0x10UL << ADC_SQR2_SQ7_Pos)            /*!< 0x00010000 */
N
N#define ADC_SQR2_SQ8_Pos               (18U)
N#define ADC_SQR2_SQ8_Msk               (0x1FUL << ADC_SQR2_SQ8_Pos)            /*!< 0x007C0000 */
N#define ADC_SQR2_SQ8                   ADC_SQR2_SQ8_Msk                        /*!< ADC group regular sequencer rank 8 */
N#define ADC_SQR2_SQ8_0                 (0x01UL << ADC_SQR2_SQ8_Pos)            /*!< 0x00040000 */
N#define ADC_SQR2_SQ8_1                 (0x02UL << ADC_SQR2_SQ8_Pos)            /*!< 0x00080000 */
N#define ADC_SQR2_SQ8_2                 (0x04UL << ADC_SQR2_SQ8_Pos)            /*!< 0x00100000 */
N#define ADC_SQR2_SQ8_3                 (0x08UL << ADC_SQR2_SQ8_Pos)            /*!< 0x00200000 */
N#define ADC_SQR2_SQ8_4                 (0x10UL << ADC_SQR2_SQ8_Pos)            /*!< 0x00400000 */
N
N#define ADC_SQR2_SQ9_Pos               (24U)
N#define ADC_SQR2_SQ9_Msk               (0x1FUL << ADC_SQR2_SQ9_Pos)            /*!< 0x1F000000 */
N#define ADC_SQR2_SQ9                   ADC_SQR2_SQ9_Msk                        /*!< ADC group regular sequencer rank 9 */
N#define ADC_SQR2_SQ9_0                 (0x01UL << ADC_SQR2_SQ9_Pos)            /*!< 0x01000000 */
N#define ADC_SQR2_SQ9_1                 (0x02UL << ADC_SQR2_SQ9_Pos)            /*!< 0x02000000 */
N#define ADC_SQR2_SQ9_2                 (0x04UL << ADC_SQR2_SQ9_Pos)            /*!< 0x04000000 */
N#define ADC_SQR2_SQ9_3                 (0x08UL << ADC_SQR2_SQ9_Pos)            /*!< 0x08000000 */
N#define ADC_SQR2_SQ9_4                 (0x10UL << ADC_SQR2_SQ9_Pos)            /*!< 0x10000000 */
N
N/********************  Bit definition for ADC_SQR3 register  ******************/
N#define ADC_SQR3_SQ10_Pos              (0U)
N#define ADC_SQR3_SQ10_Msk              (0x1FUL << ADC_SQR3_SQ10_Pos)           /*!< 0x0000001F */
N#define ADC_SQR3_SQ10                  ADC_SQR3_SQ10_Msk                       /*!< ADC group regular sequencer rank 10 */
N#define ADC_SQR3_SQ10_0                (0x01UL << ADC_SQR3_SQ10_Pos)           /*!< 0x00000001 */
N#define ADC_SQR3_SQ10_1                (0x02UL << ADC_SQR3_SQ10_Pos)           /*!< 0x00000002 */
N#define ADC_SQR3_SQ10_2                (0x04UL << ADC_SQR3_SQ10_Pos)           /*!< 0x00000004 */
N#define ADC_SQR3_SQ10_3                (0x08UL << ADC_SQR3_SQ10_Pos)           /*!< 0x00000008 */
N#define ADC_SQR3_SQ10_4                (0x10UL << ADC_SQR3_SQ10_Pos)           /*!< 0x00000010 */
N
N#define ADC_SQR3_SQ11_Pos              (6U)
N#define ADC_SQR3_SQ11_Msk              (0x1FUL << ADC_SQR3_SQ11_Pos)           /*!< 0x000007C0 */
N#define ADC_SQR3_SQ11                  ADC_SQR3_SQ11_Msk                       /*!< ADC group regular sequencer rank 11 */
N#define ADC_SQR3_SQ11_0                (0x01UL << ADC_SQR3_SQ11_Pos)           /*!< 0x00000040 */
N#define ADC_SQR3_SQ11_1                (0x02UL << ADC_SQR3_SQ11_Pos)           /*!< 0x00000080 */
N#define ADC_SQR3_SQ11_2                (0x04UL << ADC_SQR3_SQ11_Pos)           /*!< 0x00000100 */
N#define ADC_SQR3_SQ11_3                (0x08UL << ADC_SQR3_SQ11_Pos)           /*!< 0x00000200 */
N#define ADC_SQR3_SQ11_4                (0x10UL << ADC_SQR3_SQ11_Pos)           /*!< 0x00000400 */
N
N#define ADC_SQR3_SQ12_Pos              (12U)
N#define ADC_SQR3_SQ12_Msk              (0x1FUL << ADC_SQR3_SQ12_Pos)           /*!< 0x0001F000 */
N#define ADC_SQR3_SQ12                  ADC_SQR3_SQ12_Msk                       /*!< ADC group regular sequencer rank 12 */
N#define ADC_SQR3_SQ12_0                (0x01UL << ADC_SQR3_SQ12_Pos)           /*!< 0x00001000 */
N#define ADC_SQR3_SQ12_1                (0x02UL << ADC_SQR3_SQ12_Pos)           /*!< 0x00002000 */
N#define ADC_SQR3_SQ12_2                (0x04UL << ADC_SQR3_SQ12_Pos)           /*!< 0x00004000 */
N#define ADC_SQR3_SQ12_3                (0x08UL << ADC_SQR3_SQ12_Pos)           /*!< 0x00008000 */
N#define ADC_SQR3_SQ12_4                (0x10UL << ADC_SQR3_SQ12_Pos)           /*!< 0x00010000 */
N
N#define ADC_SQR3_SQ13_Pos              (18U)
N#define ADC_SQR3_SQ13_Msk              (0x1FUL << ADC_SQR3_SQ13_Pos)           /*!< 0x007C0000 */
N#define ADC_SQR3_SQ13                  ADC_SQR3_SQ13_Msk                       /*!< ADC group regular sequencer rank 13 */
N#define ADC_SQR3_SQ13_0                (0x01UL << ADC_SQR3_SQ13_Pos)           /*!< 0x00040000 */
N#define ADC_SQR3_SQ13_1                (0x02UL << ADC_SQR3_SQ13_Pos)           /*!< 0x00080000 */
N#define ADC_SQR3_SQ13_2                (0x04UL << ADC_SQR3_SQ13_Pos)           /*!< 0x00100000 */
N#define ADC_SQR3_SQ13_3                (0x08UL << ADC_SQR3_SQ13_Pos)           /*!< 0x00200000 */
N#define ADC_SQR3_SQ13_4                (0x10UL << ADC_SQR3_SQ13_Pos)           /*!< 0x00400000 */
N
N#define ADC_SQR3_SQ14_Pos              (24U)
N#define ADC_SQR3_SQ14_Msk              (0x1FUL << ADC_SQR3_SQ14_Pos)           /*!< 0x1F000000 */
N#define ADC_SQR3_SQ14                  ADC_SQR3_SQ14_Msk                       /*!< ADC group regular sequencer rank 14 */
N#define ADC_SQR3_SQ14_0                (0x01UL << ADC_SQR3_SQ14_Pos)           /*!< 0x01000000 */
N#define ADC_SQR3_SQ14_1                (0x02UL << ADC_SQR3_SQ14_Pos)           /*!< 0x02000000 */
N#define ADC_SQR3_SQ14_2                (0x04UL << ADC_SQR3_SQ14_Pos)           /*!< 0x04000000 */
N#define ADC_SQR3_SQ14_3                (0x08UL << ADC_SQR3_SQ14_Pos)           /*!< 0x08000000 */
N#define ADC_SQR3_SQ14_4                (0x10UL << ADC_SQR3_SQ14_Pos)           /*!< 0x10000000 */
N
N/********************  Bit definition for ADC_SQR4 register  ******************/
N#define ADC_SQR4_SQ15_Pos              (0U)
N#define ADC_SQR4_SQ15_Msk              (0x1FUL << ADC_SQR4_SQ15_Pos)           /*!< 0x0000001F */
N#define ADC_SQR4_SQ15                  ADC_SQR4_SQ15_Msk                       /*!< ADC group regular sequencer rank 15 */
N#define ADC_SQR4_SQ15_0                (0x01UL << ADC_SQR4_SQ15_Pos)           /*!< 0x00000001 */
N#define ADC_SQR4_SQ15_1                (0x02UL << ADC_SQR4_SQ15_Pos)           /*!< 0x00000002 */
N#define ADC_SQR4_SQ15_2                (0x04UL << ADC_SQR4_SQ15_Pos)           /*!< 0x00000004 */
N#define ADC_SQR4_SQ15_3                (0x08UL << ADC_SQR4_SQ15_Pos)           /*!< 0x00000008 */
N#define ADC_SQR4_SQ15_4                (0x10UL << ADC_SQR4_SQ15_Pos)           /*!< 0x00000010 */
N
N#define ADC_SQR4_SQ16_Pos              (6U)
N#define ADC_SQR4_SQ16_Msk              (0x1FUL << ADC_SQR4_SQ16_Pos)           /*!< 0x000007C0 */
N#define ADC_SQR4_SQ16                  ADC_SQR4_SQ16_Msk                       /*!< ADC group regular sequencer rank 16 */
N#define ADC_SQR4_SQ16_0                (0x01UL << ADC_SQR4_SQ16_Pos)           /*!< 0x00000040 */
N#define ADC_SQR4_SQ16_1                (0x02UL << ADC_SQR4_SQ16_Pos)           /*!< 0x00000080 */
N#define ADC_SQR4_SQ16_2                (0x04UL << ADC_SQR4_SQ16_Pos)           /*!< 0x00000100 */
N#define ADC_SQR4_SQ16_3                (0x08UL << ADC_SQR4_SQ16_Pos)           /*!< 0x00000200 */
N#define ADC_SQR4_SQ16_4                (0x10UL << ADC_SQR4_SQ16_Pos)           /*!< 0x00000400 */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define ADC_DR_RDATA_Pos               (0U)
N#define ADC_DR_RDATA_Msk               (0xFFFFUL << ADC_DR_RDATA_Pos)          /*!< 0x0000FFFF */
N#define ADC_DR_RDATA                   ADC_DR_RDATA_Msk                        /*!< ADC group regular conversion data */
N#define ADC_DR_RDATA_0                 (0x0001UL << ADC_DR_RDATA_Pos)          /*!< 0x00000001 */
N#define ADC_DR_RDATA_1                 (0x0002UL << ADC_DR_RDATA_Pos)          /*!< 0x00000002 */
N#define ADC_DR_RDATA_2                 (0x0004UL << ADC_DR_RDATA_Pos)          /*!< 0x00000004 */
N#define ADC_DR_RDATA_3                 (0x0008UL << ADC_DR_RDATA_Pos)          /*!< 0x00000008 */
N#define ADC_DR_RDATA_4                 (0x0010UL << ADC_DR_RDATA_Pos)          /*!< 0x00000010 */
N#define ADC_DR_RDATA_5                 (0x0020UL << ADC_DR_RDATA_Pos)          /*!< 0x00000020 */
N#define ADC_DR_RDATA_6                 (0x0040UL << ADC_DR_RDATA_Pos)          /*!< 0x00000040 */
N#define ADC_DR_RDATA_7                 (0x0080UL << ADC_DR_RDATA_Pos)          /*!< 0x00000080 */
N#define ADC_DR_RDATA_8                 (0x0100UL << ADC_DR_RDATA_Pos)          /*!< 0x00000100 */
N#define ADC_DR_RDATA_9                 (0x0200UL << ADC_DR_RDATA_Pos)          /*!< 0x00000200 */
N#define ADC_DR_RDATA_10                (0x0400UL << ADC_DR_RDATA_Pos)          /*!< 0x00000400 */
N#define ADC_DR_RDATA_11                (0x0800UL << ADC_DR_RDATA_Pos)          /*!< 0x00000800 */
N#define ADC_DR_RDATA_12                (0x1000UL << ADC_DR_RDATA_Pos)          /*!< 0x00001000 */
N#define ADC_DR_RDATA_13                (0x2000UL << ADC_DR_RDATA_Pos)          /*!< 0x00002000 */
N#define ADC_DR_RDATA_14                (0x4000UL << ADC_DR_RDATA_Pos)          /*!< 0x00004000 */
N#define ADC_DR_RDATA_15                (0x8000UL << ADC_DR_RDATA_Pos)          /*!< 0x00008000 */
N
N/********************  Bit definition for ADC_JSQR register  ******************/
N#define ADC_JSQR_JL_Pos                (0U)
N#define ADC_JSQR_JL_Msk                (0x3UL << ADC_JSQR_JL_Pos)              /*!< 0x00000003 */
N#define ADC_JSQR_JL                    ADC_JSQR_JL_Msk                         /*!< ADC group injected sequencer scan length */
N#define ADC_JSQR_JL_0                  (0x1UL << ADC_JSQR_JL_Pos)              /*!< 0x00000001 */
N#define ADC_JSQR_JL_1                  (0x2UL << ADC_JSQR_JL_Pos)              /*!< 0x00000002 */
N
N#define ADC_JSQR_JEXTSEL_Pos           (2U)
N#define ADC_JSQR_JEXTSEL_Msk           (0xFUL << ADC_JSQR_JEXTSEL_Pos)         /*!< 0x0000003C */
N#define ADC_JSQR_JEXTSEL               ADC_JSQR_JEXTSEL_Msk                    /*!< ADC group injected external trigger source */
N#define ADC_JSQR_JEXTSEL_0             (0x1UL << ADC_JSQR_JEXTSEL_Pos)         /*!< 0x00000004 */
N#define ADC_JSQR_JEXTSEL_1             (0x2UL << ADC_JSQR_JEXTSEL_Pos)         /*!< 0x00000008 */
N#define ADC_JSQR_JEXTSEL_2             (0x4UL << ADC_JSQR_JEXTSEL_Pos)         /*!< 0x00000010 */
N#define ADC_JSQR_JEXTSEL_3             (0x8UL << ADC_JSQR_JEXTSEL_Pos)         /*!< 0x00000020 */
N
N#define ADC_JSQR_JEXTEN_Pos            (6U)
N#define ADC_JSQR_JEXTEN_Msk            (0x3UL << ADC_JSQR_JEXTEN_Pos)          /*!< 0x000000C0 */
N#define ADC_JSQR_JEXTEN                ADC_JSQR_JEXTEN_Msk                     /*!< ADC group injected external trigger polarity */
N#define ADC_JSQR_JEXTEN_0              (0x1UL << ADC_JSQR_JEXTEN_Pos)          /*!< 0x00000040 */
N#define ADC_JSQR_JEXTEN_1              (0x2UL << ADC_JSQR_JEXTEN_Pos)          /*!< 0x00000080 */
N
N#define ADC_JSQR_JSQ1_Pos              (8U)
N#define ADC_JSQR_JSQ1_Msk              (0x1FUL << ADC_JSQR_JSQ1_Pos)           /*!< 0x00001F00 */
N#define ADC_JSQR_JSQ1                  ADC_JSQR_JSQ1_Msk                       /*!< ADC group injected sequencer rank 1 */
N#define ADC_JSQR_JSQ1_0                (0x01UL << ADC_JSQR_JSQ1_Pos)           /*!< 0x00000100 */
N#define ADC_JSQR_JSQ1_1                (0x02UL << ADC_JSQR_JSQ1_Pos)           /*!< 0x00000200 */
N#define ADC_JSQR_JSQ1_2                (0x04UL << ADC_JSQR_JSQ1_Pos)           /*!< 0x00000400 */
N#define ADC_JSQR_JSQ1_3                (0x08UL << ADC_JSQR_JSQ1_Pos)           /*!< 0x00000800 */
N#define ADC_JSQR_JSQ1_4                (0x10UL << ADC_JSQR_JSQ1_Pos)           /*!< 0x00001000 */
N
N#define ADC_JSQR_JSQ2_Pos              (14U)
N#define ADC_JSQR_JSQ2_Msk              (0x1FUL << ADC_JSQR_JSQ2_Pos)           /*!< 0x0007C000 */
N#define ADC_JSQR_JSQ2                  ADC_JSQR_JSQ2_Msk                       /*!< ADC group injected sequencer rank 2 */
N#define ADC_JSQR_JSQ2_0                (0x01UL << ADC_JSQR_JSQ2_Pos)           /*!< 0x00004000 */
N#define ADC_JSQR_JSQ2_1                (0x02UL << ADC_JSQR_JSQ2_Pos)           /*!< 0x00008000 */
N#define ADC_JSQR_JSQ2_2                (0x04UL << ADC_JSQR_JSQ2_Pos)           /*!< 0x00010000 */
N#define ADC_JSQR_JSQ2_3                (0x08UL << ADC_JSQR_JSQ2_Pos)           /*!< 0x00020000 */
N#define ADC_JSQR_JSQ2_4                (0x10UL << ADC_JSQR_JSQ2_Pos)           /*!< 0x00040000 */
N
N#define ADC_JSQR_JSQ3_Pos              (20U)
N#define ADC_JSQR_JSQ3_Msk              (0x1FUL << ADC_JSQR_JSQ3_Pos)           /*!< 0x01F00000 */
N#define ADC_JSQR_JSQ3                  ADC_JSQR_JSQ3_Msk                       /*!< ADC group injected sequencer rank 3 */
N#define ADC_JSQR_JSQ3_0                (0x01UL << ADC_JSQR_JSQ3_Pos)           /*!< 0x00100000 */
N#define ADC_JSQR_JSQ3_1                (0x02UL << ADC_JSQR_JSQ3_Pos)           /*!< 0x00200000 */
N#define ADC_JSQR_JSQ3_2                (0x04UL << ADC_JSQR_JSQ3_Pos)           /*!< 0x00400000 */
N#define ADC_JSQR_JSQ3_3                (0x08UL << ADC_JSQR_JSQ3_Pos)           /*!< 0x00800000 */
N#define ADC_JSQR_JSQ3_4                (0x10UL << ADC_JSQR_JSQ3_Pos)           /*!< 0x01000000 */
N
N#define ADC_JSQR_JSQ4_Pos              (26U)
N#define ADC_JSQR_JSQ4_Msk              (0x1FUL << ADC_JSQR_JSQ4_Pos)           /*!< 0x7C000000 */
N#define ADC_JSQR_JSQ4                  ADC_JSQR_JSQ4_Msk                       /*!< ADC group injected sequencer rank 4 */
N#define ADC_JSQR_JSQ4_0                (0x01UL << ADC_JSQR_JSQ4_Pos)           /*!< 0x04000000 */
N#define ADC_JSQR_JSQ4_1                (0x02UL << ADC_JSQR_JSQ4_Pos)           /*!< 0x08000000 */
N#define ADC_JSQR_JSQ4_2                (0x04UL << ADC_JSQR_JSQ4_Pos)           /*!< 0x10000000 */
N#define ADC_JSQR_JSQ4_3                (0x08UL << ADC_JSQR_JSQ4_Pos)           /*!< 0x20000000 */
N#define ADC_JSQR_JSQ4_4                (0x10UL << ADC_JSQR_JSQ4_Pos)           /*!< 0x40000000 */
N
N/********************  Bit definition for ADC_OFR1 register  ******************/
N#define ADC_OFR1_OFFSET1_Pos           (0U)
N#define ADC_OFR1_OFFSET1_Msk           (0xFFFUL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000FFF */
N#define ADC_OFR1_OFFSET1               ADC_OFR1_OFFSET1_Msk                    /*!< ADC offset number 1 offset level */
N#define ADC_OFR1_OFFSET1_0             (0x001UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000001 */
N#define ADC_OFR1_OFFSET1_1             (0x002UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000002 */
N#define ADC_OFR1_OFFSET1_2             (0x004UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000004 */
N#define ADC_OFR1_OFFSET1_3             (0x008UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000008 */
N#define ADC_OFR1_OFFSET1_4             (0x010UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000010 */
N#define ADC_OFR1_OFFSET1_5             (0x020UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000020 */
N#define ADC_OFR1_OFFSET1_6             (0x040UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000040 */
N#define ADC_OFR1_OFFSET1_7             (0x080UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000080 */
N#define ADC_OFR1_OFFSET1_8             (0x100UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000100 */
N#define ADC_OFR1_OFFSET1_9             (0x200UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000200 */
N#define ADC_OFR1_OFFSET1_10            (0x400UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000400 */
N#define ADC_OFR1_OFFSET1_11            (0x800UL << ADC_OFR1_OFFSET1_Pos)       /*!< 0x00000800 */
N
N#define ADC_OFR1_OFFSET1_CH_Pos        (26U)
N#define ADC_OFR1_OFFSET1_CH_Msk        (0x1FUL << ADC_OFR1_OFFSET1_CH_Pos)     /*!< 0x7C000000 */
N#define ADC_OFR1_OFFSET1_CH            ADC_OFR1_OFFSET1_CH_Msk                 /*!< ADC offset number 1 channel selection */
N#define ADC_OFR1_OFFSET1_CH_0          (0x01UL << ADC_OFR1_OFFSET1_CH_Pos)     /*!< 0x04000000 */
N#define ADC_OFR1_OFFSET1_CH_1          (0x02UL << ADC_OFR1_OFFSET1_CH_Pos)     /*!< 0x08000000 */
N#define ADC_OFR1_OFFSET1_CH_2          (0x04UL << ADC_OFR1_OFFSET1_CH_Pos)     /*!< 0x10000000 */
N#define ADC_OFR1_OFFSET1_CH_3          (0x08UL << ADC_OFR1_OFFSET1_CH_Pos)     /*!< 0x20000000 */
N#define ADC_OFR1_OFFSET1_CH_4          (0x10UL << ADC_OFR1_OFFSET1_CH_Pos)     /*!< 0x40000000 */
N
N#define ADC_OFR1_OFFSET1_EN_Pos        (31U)
N#define ADC_OFR1_OFFSET1_EN_Msk        (0x1UL << ADC_OFR1_OFFSET1_EN_Pos)      /*!< 0x80000000 */
N#define ADC_OFR1_OFFSET1_EN            ADC_OFR1_OFFSET1_EN_Msk                 /*!< ADC offset number 1 enable */
N
N/********************  Bit definition for ADC_OFR2 register  ******************/
N#define ADC_OFR2_OFFSET2_Pos           (0U)
N#define ADC_OFR2_OFFSET2_Msk           (0xFFFUL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000FFF */
N#define ADC_OFR2_OFFSET2               ADC_OFR2_OFFSET2_Msk                    /*!< ADC offset number 2 offset level */
N#define ADC_OFR2_OFFSET2_0             (0x001UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000001 */
N#define ADC_OFR2_OFFSET2_1             (0x002UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000002 */
N#define ADC_OFR2_OFFSET2_2             (0x004UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000004 */
N#define ADC_OFR2_OFFSET2_3             (0x008UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000008 */
N#define ADC_OFR2_OFFSET2_4             (0x010UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000010 */
N#define ADC_OFR2_OFFSET2_5             (0x020UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000020 */
N#define ADC_OFR2_OFFSET2_6             (0x040UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000040 */
N#define ADC_OFR2_OFFSET2_7             (0x080UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000080 */
N#define ADC_OFR2_OFFSET2_8             (0x100UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000100 */
N#define ADC_OFR2_OFFSET2_9             (0x200UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000200 */
N#define ADC_OFR2_OFFSET2_10            (0x400UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000400 */
N#define ADC_OFR2_OFFSET2_11            (0x800UL << ADC_OFR2_OFFSET2_Pos)       /*!< 0x00000800 */
N
N#define ADC_OFR2_OFFSET2_CH_Pos        (26U)
N#define ADC_OFR2_OFFSET2_CH_Msk        (0x1FUL << ADC_OFR2_OFFSET2_CH_Pos)     /*!< 0x7C000000 */
N#define ADC_OFR2_OFFSET2_CH            ADC_OFR2_OFFSET2_CH_Msk                 /*!< ADC offset number 2 channel selection */
N#define ADC_OFR2_OFFSET2_CH_0          (0x01UL << ADC_OFR2_OFFSET2_CH_Pos)     /*!< 0x04000000 */
N#define ADC_OFR2_OFFSET2_CH_1          (0x02UL << ADC_OFR2_OFFSET2_CH_Pos)     /*!< 0x08000000 */
N#define ADC_OFR2_OFFSET2_CH_2          (0x04UL << ADC_OFR2_OFFSET2_CH_Pos)     /*!< 0x10000000 */
N#define ADC_OFR2_OFFSET2_CH_3          (0x08UL << ADC_OFR2_OFFSET2_CH_Pos)     /*!< 0x20000000 */
N#define ADC_OFR2_OFFSET2_CH_4          (0x10UL << ADC_OFR2_OFFSET2_CH_Pos)     /*!< 0x40000000 */
N
N#define ADC_OFR2_OFFSET2_EN_Pos        (31U)
N#define ADC_OFR2_OFFSET2_EN_Msk        (0x1UL << ADC_OFR2_OFFSET2_EN_Pos)      /*!< 0x80000000 */
N#define ADC_OFR2_OFFSET2_EN            ADC_OFR2_OFFSET2_EN_Msk                 /*!< ADC offset number 2 enable */
N
N/********************  Bit definition for ADC_OFR3 register  ******************/
N#define ADC_OFR3_OFFSET3_Pos           (0U)
N#define ADC_OFR3_OFFSET3_Msk           (0xFFFUL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000FFF */
N#define ADC_OFR3_OFFSET3               ADC_OFR3_OFFSET3_Msk                    /*!< ADC offset number 3 offset level */
N#define ADC_OFR3_OFFSET3_0             (0x001UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000001 */
N#define ADC_OFR3_OFFSET3_1             (0x002UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000002 */
N#define ADC_OFR3_OFFSET3_2             (0x004UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000004 */
N#define ADC_OFR3_OFFSET3_3             (0x008UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000008 */
N#define ADC_OFR3_OFFSET3_4             (0x010UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000010 */
N#define ADC_OFR3_OFFSET3_5             (0x020UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000020 */
N#define ADC_OFR3_OFFSET3_6             (0x040UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000040 */
N#define ADC_OFR3_OFFSET3_7             (0x080UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000080 */
N#define ADC_OFR3_OFFSET3_8             (0x100UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000100 */
N#define ADC_OFR3_OFFSET3_9             (0x200UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000200 */
N#define ADC_OFR3_OFFSET3_10            (0x400UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000400 */
N#define ADC_OFR3_OFFSET3_11            (0x800UL << ADC_OFR3_OFFSET3_Pos)       /*!< 0x00000800 */
N
N#define ADC_OFR3_OFFSET3_CH_Pos        (26U)
N#define ADC_OFR3_OFFSET3_CH_Msk        (0x1FUL << ADC_OFR3_OFFSET3_CH_Pos)     /*!< 0x7C000000 */
N#define ADC_OFR3_OFFSET3_CH            ADC_OFR3_OFFSET3_CH_Msk                 /*!< ADC offset number 3 channel selection */
N#define ADC_OFR3_OFFSET3_CH_0          (0x01UL << ADC_OFR3_OFFSET3_CH_Pos)     /*!< 0x04000000 */
N#define ADC_OFR3_OFFSET3_CH_1          (0x02UL << ADC_OFR3_OFFSET3_CH_Pos)     /*!< 0x08000000 */
N#define ADC_OFR3_OFFSET3_CH_2          (0x04UL << ADC_OFR3_OFFSET3_CH_Pos)     /*!< 0x10000000 */
N#define ADC_OFR3_OFFSET3_CH_3          (0x08UL << ADC_OFR3_OFFSET3_CH_Pos)     /*!< 0x20000000 */
N#define ADC_OFR3_OFFSET3_CH_4          (0x10UL << ADC_OFR3_OFFSET3_CH_Pos)     /*!< 0x40000000 */
N
N#define ADC_OFR3_OFFSET3_EN_Pos        (31U)
N#define ADC_OFR3_OFFSET3_EN_Msk        (0x1UL << ADC_OFR3_OFFSET3_EN_Pos)      /*!< 0x80000000 */
N#define ADC_OFR3_OFFSET3_EN            ADC_OFR3_OFFSET3_EN_Msk                 /*!< ADC offset number 3 enable */
N
N/********************  Bit definition for ADC_OFR4 register  ******************/
N#define ADC_OFR4_OFFSET4_Pos           (0U)
N#define ADC_OFR4_OFFSET4_Msk           (0xFFFUL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000FFF */
N#define ADC_OFR4_OFFSET4               ADC_OFR4_OFFSET4_Msk                    /*!< ADC offset number 4 offset level */
N#define ADC_OFR4_OFFSET4_0             (0x001UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000001 */
N#define ADC_OFR4_OFFSET4_1             (0x002UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000002 */
N#define ADC_OFR4_OFFSET4_2             (0x004UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000004 */
N#define ADC_OFR4_OFFSET4_3             (0x008UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000008 */
N#define ADC_OFR4_OFFSET4_4             (0x010UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000010 */
N#define ADC_OFR4_OFFSET4_5             (0x020UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000020 */
N#define ADC_OFR4_OFFSET4_6             (0x040UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000040 */
N#define ADC_OFR4_OFFSET4_7             (0x080UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000080 */
N#define ADC_OFR4_OFFSET4_8             (0x100UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000100 */
N#define ADC_OFR4_OFFSET4_9             (0x200UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000200 */
N#define ADC_OFR4_OFFSET4_10            (0x400UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000400 */
N#define ADC_OFR4_OFFSET4_11            (0x800UL << ADC_OFR4_OFFSET4_Pos)       /*!< 0x00000800 */
N
N#define ADC_OFR4_OFFSET4_CH_Pos        (26U)
N#define ADC_OFR4_OFFSET4_CH_Msk        (0x1FUL << ADC_OFR4_OFFSET4_CH_Pos)     /*!< 0x7C000000 */
N#define ADC_OFR4_OFFSET4_CH            ADC_OFR4_OFFSET4_CH_Msk                 /*!< ADC offset number 4 channel selection */
N#define ADC_OFR4_OFFSET4_CH_0          (0x01UL << ADC_OFR4_OFFSET4_CH_Pos)     /*!< 0x04000000 */
N#define ADC_OFR4_OFFSET4_CH_1          (0x02UL << ADC_OFR4_OFFSET4_CH_Pos)     /*!< 0x08000000 */
N#define ADC_OFR4_OFFSET4_CH_2          (0x04UL << ADC_OFR4_OFFSET4_CH_Pos)     /*!< 0x10000000 */
N#define ADC_OFR4_OFFSET4_CH_3          (0x08UL << ADC_OFR4_OFFSET4_CH_Pos)     /*!< 0x20000000 */
N#define ADC_OFR4_OFFSET4_CH_4          (0x10UL << ADC_OFR4_OFFSET4_CH_Pos)     /*!< 0x40000000 */
N
N#define ADC_OFR4_OFFSET4_EN_Pos        (31U)
N#define ADC_OFR4_OFFSET4_EN_Msk        (0x1UL << ADC_OFR4_OFFSET4_EN_Pos)      /*!< 0x80000000 */
N#define ADC_OFR4_OFFSET4_EN            ADC_OFR4_OFFSET4_EN_Msk                 /*!< ADC offset number 4 enable */
N
N/********************  Bit definition for ADC_JDR1 register  ******************/
N#define ADC_JDR1_JDATA_Pos             (0U)
N#define ADC_JDR1_JDATA_Msk             (0xFFFFUL << ADC_JDR1_JDATA_Pos)        /*!< 0x0000FFFF */
N#define ADC_JDR1_JDATA                 ADC_JDR1_JDATA_Msk                      /*!< ADC group injected sequencer rank 1 conversion data */
N#define ADC_JDR1_JDATA_0               (0x0001UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000001 */
N#define ADC_JDR1_JDATA_1               (0x0002UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000002 */
N#define ADC_JDR1_JDATA_2               (0x0004UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000004 */
N#define ADC_JDR1_JDATA_3               (0x0008UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000008 */
N#define ADC_JDR1_JDATA_4               (0x0010UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000010 */
N#define ADC_JDR1_JDATA_5               (0x0020UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000020 */
N#define ADC_JDR1_JDATA_6               (0x0040UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000040 */
N#define ADC_JDR1_JDATA_7               (0x0080UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000080 */
N#define ADC_JDR1_JDATA_8               (0x0100UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000100 */
N#define ADC_JDR1_JDATA_9               (0x0200UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000200 */
N#define ADC_JDR1_JDATA_10              (0x0400UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000400 */
N#define ADC_JDR1_JDATA_11              (0x0800UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00000800 */
N#define ADC_JDR1_JDATA_12              (0x1000UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00001000 */
N#define ADC_JDR1_JDATA_13              (0x2000UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00002000 */
N#define ADC_JDR1_JDATA_14              (0x4000UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00004000 */
N#define ADC_JDR1_JDATA_15              (0x8000UL << ADC_JDR1_JDATA_Pos)        /*!< 0x00008000 */
N
N/********************  Bit definition for ADC_JDR2 register  ******************/
N#define ADC_JDR2_JDATA_Pos             (0U)
N#define ADC_JDR2_JDATA_Msk             (0xFFFFUL << ADC_JDR2_JDATA_Pos)        /*!< 0x0000FFFF */
N#define ADC_JDR2_JDATA                 ADC_JDR2_JDATA_Msk                      /*!< ADC group injected sequencer rank 2 conversion data */
N#define ADC_JDR2_JDATA_0               (0x0001UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000001 */
N#define ADC_JDR2_JDATA_1               (0x0002UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000002 */
N#define ADC_JDR2_JDATA_2               (0x0004UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000004 */
N#define ADC_JDR2_JDATA_3               (0x0008UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000008 */
N#define ADC_JDR2_JDATA_4               (0x0010UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000010 */
N#define ADC_JDR2_JDATA_5               (0x0020UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000020 */
N#define ADC_JDR2_JDATA_6               (0x0040UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000040 */
N#define ADC_JDR2_JDATA_7               (0x0080UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000080 */
N#define ADC_JDR2_JDATA_8               (0x0100UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000100 */
N#define ADC_JDR2_JDATA_9               (0x0200UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000200 */
N#define ADC_JDR2_JDATA_10              (0x0400UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000400 */
N#define ADC_JDR2_JDATA_11              (0x0800UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00000800 */
N#define ADC_JDR2_JDATA_12              (0x1000UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00001000 */
N#define ADC_JDR2_JDATA_13              (0x2000UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00002000 */
N#define ADC_JDR2_JDATA_14              (0x4000UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00004000 */
N#define ADC_JDR2_JDATA_15              (0x8000UL << ADC_JDR2_JDATA_Pos)        /*!< 0x00008000 */
N
N/********************  Bit definition for ADC_JDR3 register  ******************/
N#define ADC_JDR3_JDATA_Pos             (0U)
N#define ADC_JDR3_JDATA_Msk             (0xFFFFUL << ADC_JDR3_JDATA_Pos)        /*!< 0x0000FFFF */
N#define ADC_JDR3_JDATA                 ADC_JDR3_JDATA_Msk                      /*!< ADC group injected sequencer rank 3 conversion data */
N#define ADC_JDR3_JDATA_0               (0x0001UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000001 */
N#define ADC_JDR3_JDATA_1               (0x0002UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000002 */
N#define ADC_JDR3_JDATA_2               (0x0004UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000004 */
N#define ADC_JDR3_JDATA_3               (0x0008UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000008 */
N#define ADC_JDR3_JDATA_4               (0x0010UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000010 */
N#define ADC_JDR3_JDATA_5               (0x0020UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000020 */
N#define ADC_JDR3_JDATA_6               (0x0040UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000040 */
N#define ADC_JDR3_JDATA_7               (0x0080UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000080 */
N#define ADC_JDR3_JDATA_8               (0x0100UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000100 */
N#define ADC_JDR3_JDATA_9               (0x0200UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000200 */
N#define ADC_JDR3_JDATA_10              (0x0400UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000400 */
N#define ADC_JDR3_JDATA_11              (0x0800UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00000800 */
N#define ADC_JDR3_JDATA_12              (0x1000UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00001000 */
N#define ADC_JDR3_JDATA_13              (0x2000UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00002000 */
N#define ADC_JDR3_JDATA_14              (0x4000UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00004000 */
N#define ADC_JDR3_JDATA_15              (0x8000UL << ADC_JDR3_JDATA_Pos)        /*!< 0x00008000 */
N
N/********************  Bit definition for ADC_JDR4 register  ******************/
N#define ADC_JDR4_JDATA_Pos             (0U)
N#define ADC_JDR4_JDATA_Msk             (0xFFFFUL << ADC_JDR4_JDATA_Pos)        /*!< 0x0000FFFF */
N#define ADC_JDR4_JDATA                 ADC_JDR4_JDATA_Msk                      /*!< ADC group injected sequencer rank 4 conversion data */
N#define ADC_JDR4_JDATA_0               (0x0001UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000001 */
N#define ADC_JDR4_JDATA_1               (0x0002UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000002 */
N#define ADC_JDR4_JDATA_2               (0x0004UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000004 */
N#define ADC_JDR4_JDATA_3               (0x0008UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000008 */
N#define ADC_JDR4_JDATA_4               (0x0010UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000010 */
N#define ADC_JDR4_JDATA_5               (0x0020UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000020 */
N#define ADC_JDR4_JDATA_6               (0x0040UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000040 */
N#define ADC_JDR4_JDATA_7               (0x0080UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000080 */
N#define ADC_JDR4_JDATA_8               (0x0100UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000100 */
N#define ADC_JDR4_JDATA_9               (0x0200UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000200 */
N#define ADC_JDR4_JDATA_10              (0x0400UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000400 */
N#define ADC_JDR4_JDATA_11              (0x0800UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00000800 */
N#define ADC_JDR4_JDATA_12              (0x1000UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00001000 */
N#define ADC_JDR4_JDATA_13              (0x2000UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00002000 */
N#define ADC_JDR4_JDATA_14              (0x4000UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00004000 */
N#define ADC_JDR4_JDATA_15              (0x8000UL << ADC_JDR4_JDATA_Pos)        /*!< 0x00008000 */
N
N/********************  Bit definition for ADC_AWD2CR register  ****************/
N#define ADC_AWD2CR_AWD2CH_Pos          (0U)
N#define ADC_AWD2CR_AWD2CH_Msk          (0x7FFFFUL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x0007FFFF */
N#define ADC_AWD2CR_AWD2CH              ADC_AWD2CR_AWD2CH_Msk                   /*!< ADC analog watchdog 2 monitored channel selection */
N#define ADC_AWD2CR_AWD2CH_0            (0x00001UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000001 */
N#define ADC_AWD2CR_AWD2CH_1            (0x00002UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000002 */
N#define ADC_AWD2CR_AWD2CH_2            (0x00004UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000004 */
N#define ADC_AWD2CR_AWD2CH_3            (0x00008UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000008 */
N#define ADC_AWD2CR_AWD2CH_4            (0x00010UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000010 */
N#define ADC_AWD2CR_AWD2CH_5            (0x00020UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000020 */
N#define ADC_AWD2CR_AWD2CH_6            (0x00040UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000040 */
N#define ADC_AWD2CR_AWD2CH_7            (0x00080UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000080 */
N#define ADC_AWD2CR_AWD2CH_8            (0x00100UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000100 */
N#define ADC_AWD2CR_AWD2CH_9            (0x00200UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000200 */
N#define ADC_AWD2CR_AWD2CH_10           (0x00400UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000400 */
N#define ADC_AWD2CR_AWD2CH_11           (0x00800UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00000800 */
N#define ADC_AWD2CR_AWD2CH_12           (0x01000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00001000 */
N#define ADC_AWD2CR_AWD2CH_13           (0x02000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00002000 */
N#define ADC_AWD2CR_AWD2CH_14           (0x04000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00004000 */
N#define ADC_AWD2CR_AWD2CH_15           (0x08000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00008000 */
N#define ADC_AWD2CR_AWD2CH_16           (0x10000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00010000 */
N#define ADC_AWD2CR_AWD2CH_17           (0x20000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00020000 */
N#define ADC_AWD2CR_AWD2CH_18           (0x40000UL << ADC_AWD2CR_AWD2CH_Pos)    /*!< 0x00040000 */
N
N/********************  Bit definition for ADC_AWD3CR register  ****************/
N#define ADC_AWD3CR_AWD3CH_Pos          (0U)
N#define ADC_AWD3CR_AWD3CH_Msk          (0x7FFFFUL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x0007FFFF */
N#define ADC_AWD3CR_AWD3CH              ADC_AWD3CR_AWD3CH_Msk                   /*!< ADC analog watchdog 3 monitored channel selection */
N#define ADC_AWD3CR_AWD3CH_0            (0x00001UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000001 */
N#define ADC_AWD3CR_AWD3CH_1            (0x00002UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000002 */
N#define ADC_AWD3CR_AWD3CH_2            (0x00004UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000004 */
N#define ADC_AWD3CR_AWD3CH_3            (0x00008UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000008 */
N#define ADC_AWD3CR_AWD3CH_4            (0x00010UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000010 */
N#define ADC_AWD3CR_AWD3CH_5            (0x00020UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000020 */
N#define ADC_AWD3CR_AWD3CH_6            (0x00040UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000040 */
N#define ADC_AWD3CR_AWD3CH_7            (0x00080UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000080 */
N#define ADC_AWD3CR_AWD3CH_8            (0x00100UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000100 */
N#define ADC_AWD3CR_AWD3CH_9            (0x00200UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000200 */
N#define ADC_AWD3CR_AWD3CH_10           (0x00400UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000400 */
N#define ADC_AWD3CR_AWD3CH_11           (0x00800UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00000800 */
N#define ADC_AWD3CR_AWD3CH_12           (0x01000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00001000 */
N#define ADC_AWD3CR_AWD3CH_13           (0x02000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00002000 */
N#define ADC_AWD3CR_AWD3CH_14           (0x04000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00004000 */
N#define ADC_AWD3CR_AWD3CH_15           (0x08000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00008000 */
N#define ADC_AWD3CR_AWD3CH_16           (0x10000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00010000 */
N#define ADC_AWD3CR_AWD3CH_17           (0x20000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00020000 */
N#define ADC_AWD3CR_AWD3CH_18           (0x40000UL << ADC_AWD3CR_AWD3CH_Pos)    /*!< 0x00040000 */
N
N/********************  Bit definition for ADC_DIFSEL register  ****************/
N#define ADC_DIFSEL_DIFSEL_Pos          (0U)
N#define ADC_DIFSEL_DIFSEL_Msk          (0x7FFFFUL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x0007FFFF */
N#define ADC_DIFSEL_DIFSEL              ADC_DIFSEL_DIFSEL_Msk                   /*!< ADC channel differential or single-ended mode */
N#define ADC_DIFSEL_DIFSEL_0            (0x00001UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000001 */
N#define ADC_DIFSEL_DIFSEL_1            (0x00002UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000002 */
N#define ADC_DIFSEL_DIFSEL_2            (0x00004UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000004 */
N#define ADC_DIFSEL_DIFSEL_3            (0x00008UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000008 */
N#define ADC_DIFSEL_DIFSEL_4            (0x00010UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000010 */
N#define ADC_DIFSEL_DIFSEL_5            (0x00020UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000020 */
N#define ADC_DIFSEL_DIFSEL_6            (0x00040UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000040 */
N#define ADC_DIFSEL_DIFSEL_7            (0x00080UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000080 */
N#define ADC_DIFSEL_DIFSEL_8            (0x00100UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000100 */
N#define ADC_DIFSEL_DIFSEL_9            (0x00200UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000200 */
N#define ADC_DIFSEL_DIFSEL_10           (0x00400UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000400 */
N#define ADC_DIFSEL_DIFSEL_11           (0x00800UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00000800 */
N#define ADC_DIFSEL_DIFSEL_12           (0x01000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00001000 */
N#define ADC_DIFSEL_DIFSEL_13           (0x02000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00002000 */
N#define ADC_DIFSEL_DIFSEL_14           (0x04000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00004000 */
N#define ADC_DIFSEL_DIFSEL_15           (0x08000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00008000 */
N#define ADC_DIFSEL_DIFSEL_16           (0x10000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00010000 */
N#define ADC_DIFSEL_DIFSEL_17           (0x20000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00020000 */
N#define ADC_DIFSEL_DIFSEL_18           (0x40000UL << ADC_DIFSEL_DIFSEL_Pos)    /*!< 0x00040000 */
N
N/********************  Bit definition for ADC_CALFACT register  ***************/
N#define ADC_CALFACT_CALFACT_S_Pos      (0U)
N#define ADC_CALFACT_CALFACT_S_Msk      (0x7FUL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x0000007F */
N#define ADC_CALFACT_CALFACT_S          ADC_CALFACT_CALFACT_S_Msk               /*!< ADC calibration factor in single-ended mode */
N#define ADC_CALFACT_CALFACT_S_0        (0x01UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000001 */
N#define ADC_CALFACT_CALFACT_S_1        (0x02UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000002 */
N#define ADC_CALFACT_CALFACT_S_2        (0x04UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000004 */
N#define ADC_CALFACT_CALFACT_S_3        (0x08UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000008 */
N#define ADC_CALFACT_CALFACT_S_4        (0x10UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000010 */
N#define ADC_CALFACT_CALFACT_S_5        (0x20UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000020 */
N#define ADC_CALFACT_CALFACT_S_6        (0x40UL << ADC_CALFACT_CALFACT_S_Pos)   /*!< 0x00000040 */
N
N#define ADC_CALFACT_CALFACT_D_Pos      (16U)
N#define ADC_CALFACT_CALFACT_D_Msk      (0x7FUL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x007F0000 */
N#define ADC_CALFACT_CALFACT_D          ADC_CALFACT_CALFACT_D_Msk               /*!< ADC calibration factor in differential mode */
N#define ADC_CALFACT_CALFACT_D_0        (0x01UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00010000 */
N#define ADC_CALFACT_CALFACT_D_1        (0x02UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00020000 */
N#define ADC_CALFACT_CALFACT_D_2        (0x04UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00040000 */
N#define ADC_CALFACT_CALFACT_D_3        (0x08UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00080000 */
N#define ADC_CALFACT_CALFACT_D_4        (0x10UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00100000 */
N#define ADC_CALFACT_CALFACT_D_5        (0x20UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00200000 */
N#define ADC_CALFACT_CALFACT_D_6        (0x40UL << ADC_CALFACT_CALFACT_D_Pos)   /*!< 0x00400000 */
N
N/*************************  ADC Common registers  *****************************/
N/********************  Bit definition for ADC_CCR register  *******************/
N#define ADC_CCR_CKMODE_Pos             (16U)
N#define ADC_CCR_CKMODE_Msk             (0x3UL << ADC_CCR_CKMODE_Pos)           /*!< 0x00030000 */
N#define ADC_CCR_CKMODE                 ADC_CCR_CKMODE_Msk                      /*!< ADC common clock source and prescaler (prescaler only for clock source synchronous) */
N#define ADC_CCR_CKMODE_0               (0x1UL << ADC_CCR_CKMODE_Pos)           /*!< 0x00010000 */
N#define ADC_CCR_CKMODE_1               (0x2UL << ADC_CCR_CKMODE_Pos)           /*!< 0x00020000 */
N
N#define ADC_CCR_PRESC_Pos              (18U)
N#define ADC_CCR_PRESC_Msk              (0xFUL << ADC_CCR_PRESC_Pos)            /*!< 0x003C0000 */
N#define ADC_CCR_PRESC                  ADC_CCR_PRESC_Msk                       /*!< ADC common clock prescaler, only for clock source asynchronous */
N#define ADC_CCR_PRESC_0                (0x1UL << ADC_CCR_PRESC_Pos)            /*!< 0x00040000 */
N#define ADC_CCR_PRESC_1                (0x2UL << ADC_CCR_PRESC_Pos)            /*!< 0x00080000 */
N#define ADC_CCR_PRESC_2                (0x4UL << ADC_CCR_PRESC_Pos)            /*!< 0x00100000 */
N#define ADC_CCR_PRESC_3                (0x8UL << ADC_CCR_PRESC_Pos)            /*!< 0x00200000 */
N
N#define ADC_CCR_VREFEN_Pos             (22U)
N#define ADC_CCR_VREFEN_Msk             (0x1UL << ADC_CCR_VREFEN_Pos)           /*!< 0x00400000 */
N#define ADC_CCR_VREFEN                 ADC_CCR_VREFEN_Msk                      /*!< ADC internal path to VrefInt enable */
N#define ADC_CCR_TSEN_Pos               (23U)
N#define ADC_CCR_TSEN_Msk               (0x1UL << ADC_CCR_TSEN_Pos)             /*!< 0x00800000 */
N#define ADC_CCR_TSEN                   ADC_CCR_TSEN_Msk                        /*!< ADC internal path to temperature sensor enable */
N#define ADC_CCR_VBATEN_Pos             (24U)
N#define ADC_CCR_VBATEN_Msk             (0x1UL << ADC_CCR_VBATEN_Pos)           /*!< 0x01000000 */
N#define ADC_CCR_VBATEN                 ADC_CCR_VBATEN_Msk                      /*!< ADC internal path to battery voltage enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Controller Area Network                            */
N/*                                                                            */
N/******************************************************************************/
N/*!<CAN control and status registers */
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define CAN_MCR_INRQ_Pos       (0U)
N#define CAN_MCR_INRQ_Msk       (0x1UL << CAN_MCR_INRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_MCR_INRQ           CAN_MCR_INRQ_Msk                                /*!<Initialization Request */
N#define CAN_MCR_SLEEP_Pos      (1U)
N#define CAN_MCR_SLEEP_Msk      (0x1UL << CAN_MCR_SLEEP_Pos)                    /*!< 0x00000002 */
N#define CAN_MCR_SLEEP          CAN_MCR_SLEEP_Msk                               /*!<Sleep Mode Request */
N#define CAN_MCR_TXFP_Pos       (2U)
N#define CAN_MCR_TXFP_Msk       (0x1UL << CAN_MCR_TXFP_Pos)                     /*!< 0x00000004 */
N#define CAN_MCR_TXFP           CAN_MCR_TXFP_Msk                                /*!<Transmit FIFO Priority */
N#define CAN_MCR_RFLM_Pos       (3U)
N#define CAN_MCR_RFLM_Msk       (0x1UL << CAN_MCR_RFLM_Pos)                     /*!< 0x00000008 */
N#define CAN_MCR_RFLM           CAN_MCR_RFLM_Msk                                /*!<Receive FIFO Locked Mode */
N#define CAN_MCR_NART_Pos       (4U)
N#define CAN_MCR_NART_Msk       (0x1UL << CAN_MCR_NART_Pos)                     /*!< 0x00000010 */
N#define CAN_MCR_NART           CAN_MCR_NART_Msk                                /*!<No Automatic Retransmission */
N#define CAN_MCR_AWUM_Pos       (5U)
N#define CAN_MCR_AWUM_Msk       (0x1UL << CAN_MCR_AWUM_Pos)                     /*!< 0x00000020 */
N#define CAN_MCR_AWUM           CAN_MCR_AWUM_Msk                                /*!<Automatic Wakeup Mode */
N#define CAN_MCR_ABOM_Pos       (6U)
N#define CAN_MCR_ABOM_Msk       (0x1UL << CAN_MCR_ABOM_Pos)                     /*!< 0x00000040 */
N#define CAN_MCR_ABOM           CAN_MCR_ABOM_Msk                                /*!<Automatic Bus-Off Management */
N#define CAN_MCR_TTCM_Pos       (7U)
N#define CAN_MCR_TTCM_Msk       (0x1UL << CAN_MCR_TTCM_Pos)                     /*!< 0x00000080 */
N#define CAN_MCR_TTCM           CAN_MCR_TTCM_Msk                                /*!<Time Triggered Communication Mode */
N#define CAN_MCR_RESET_Pos      (15U)
N#define CAN_MCR_RESET_Msk      (0x1UL << CAN_MCR_RESET_Pos)                    /*!< 0x00008000 */
N#define CAN_MCR_RESET          CAN_MCR_RESET_Msk                               /*!<bxCAN software master reset */
N
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define CAN_MSR_INAK_Pos       (0U)
N#define CAN_MSR_INAK_Msk       (0x1UL << CAN_MSR_INAK_Pos)                     /*!< 0x00000001 */
N#define CAN_MSR_INAK           CAN_MSR_INAK_Msk                                /*!<Initialization Acknowledge */
N#define CAN_MSR_SLAK_Pos       (1U)
N#define CAN_MSR_SLAK_Msk       (0x1UL << CAN_MSR_SLAK_Pos)                     /*!< 0x00000002 */
N#define CAN_MSR_SLAK           CAN_MSR_SLAK_Msk                                /*!<Sleep Acknowledge */
N#define CAN_MSR_ERRI_Pos       (2U)
N#define CAN_MSR_ERRI_Msk       (0x1UL << CAN_MSR_ERRI_Pos)                     /*!< 0x00000004 */
N#define CAN_MSR_ERRI           CAN_MSR_ERRI_Msk                                /*!<Error Interrupt */
N#define CAN_MSR_WKUI_Pos       (3U)
N#define CAN_MSR_WKUI_Msk       (0x1UL << CAN_MSR_WKUI_Pos)                     /*!< 0x00000008 */
N#define CAN_MSR_WKUI           CAN_MSR_WKUI_Msk                                /*!<Wakeup Interrupt */
N#define CAN_MSR_SLAKI_Pos      (4U)
N#define CAN_MSR_SLAKI_Msk      (0x1UL << CAN_MSR_SLAKI_Pos)                    /*!< 0x00000010 */
N#define CAN_MSR_SLAKI          CAN_MSR_SLAKI_Msk                               /*!<Sleep Acknowledge Interrupt */
N#define CAN_MSR_TXM_Pos        (8U)
N#define CAN_MSR_TXM_Msk        (0x1UL << CAN_MSR_TXM_Pos)                      /*!< 0x00000100 */
N#define CAN_MSR_TXM            CAN_MSR_TXM_Msk                                 /*!<Transmit Mode */
N#define CAN_MSR_RXM_Pos        (9U)
N#define CAN_MSR_RXM_Msk        (0x1UL << CAN_MSR_RXM_Pos)                      /*!< 0x00000200 */
N#define CAN_MSR_RXM            CAN_MSR_RXM_Msk                                 /*!<Receive Mode */
N#define CAN_MSR_SAMP_Pos       (10U)
N#define CAN_MSR_SAMP_Msk       (0x1UL << CAN_MSR_SAMP_Pos)                     /*!< 0x00000400 */
N#define CAN_MSR_SAMP           CAN_MSR_SAMP_Msk                                /*!<Last Sample Point */
N#define CAN_MSR_RX_Pos         (11U)
N#define CAN_MSR_RX_Msk         (0x1UL << CAN_MSR_RX_Pos)                       /*!< 0x00000800 */
N#define CAN_MSR_RX             CAN_MSR_RX_Msk                                  /*!<CAN Rx Signal */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define CAN_TSR_RQCP0_Pos      (0U)
N#define CAN_TSR_RQCP0_Msk      (0x1UL << CAN_TSR_RQCP0_Pos)                    /*!< 0x00000001 */
N#define CAN_TSR_RQCP0          CAN_TSR_RQCP0_Msk                               /*!<Request Completed Mailbox0 */
N#define CAN_TSR_TXOK0_Pos      (1U)
N#define CAN_TSR_TXOK0_Msk      (0x1UL << CAN_TSR_TXOK0_Pos)                    /*!< 0x00000002 */
N#define CAN_TSR_TXOK0          CAN_TSR_TXOK0_Msk                               /*!<Transmission OK of Mailbox0 */
N#define CAN_TSR_ALST0_Pos      (2U)
N#define CAN_TSR_ALST0_Msk      (0x1UL << CAN_TSR_ALST0_Pos)                    /*!< 0x00000004 */
N#define CAN_TSR_ALST0          CAN_TSR_ALST0_Msk                               /*!<Arbitration Lost for Mailbox0 */
N#define CAN_TSR_TERR0_Pos      (3U)
N#define CAN_TSR_TERR0_Msk      (0x1UL << CAN_TSR_TERR0_Pos)                    /*!< 0x00000008 */
N#define CAN_TSR_TERR0          CAN_TSR_TERR0_Msk                               /*!<Transmission Error of Mailbox0 */
N#define CAN_TSR_ABRQ0_Pos      (7U)
N#define CAN_TSR_ABRQ0_Msk      (0x1UL << CAN_TSR_ABRQ0_Pos)                    /*!< 0x00000080 */
N#define CAN_TSR_ABRQ0          CAN_TSR_ABRQ0_Msk                               /*!<Abort Request for Mailbox0 */
N#define CAN_TSR_RQCP1_Pos      (8U)
N#define CAN_TSR_RQCP1_Msk      (0x1UL << CAN_TSR_RQCP1_Pos)                    /*!< 0x00000100 */
N#define CAN_TSR_RQCP1          CAN_TSR_RQCP1_Msk                               /*!<Request Completed Mailbox1 */
N#define CAN_TSR_TXOK1_Pos      (9U)
N#define CAN_TSR_TXOK1_Msk      (0x1UL << CAN_TSR_TXOK1_Pos)                    /*!< 0x00000200 */
N#define CAN_TSR_TXOK1          CAN_TSR_TXOK1_Msk                               /*!<Transmission OK of Mailbox1 */
N#define CAN_TSR_ALST1_Pos      (10U)
N#define CAN_TSR_ALST1_Msk      (0x1UL << CAN_TSR_ALST1_Pos)                    /*!< 0x00000400 */
N#define CAN_TSR_ALST1          CAN_TSR_ALST1_Msk                               /*!<Arbitration Lost for Mailbox1 */
N#define CAN_TSR_TERR1_Pos      (11U)
N#define CAN_TSR_TERR1_Msk      (0x1UL << CAN_TSR_TERR1_Pos)                    /*!< 0x00000800 */
N#define CAN_TSR_TERR1          CAN_TSR_TERR1_Msk                               /*!<Transmission Error of Mailbox1 */
N#define CAN_TSR_ABRQ1_Pos      (15U)
N#define CAN_TSR_ABRQ1_Msk      (0x1UL << CAN_TSR_ABRQ1_Pos)                    /*!< 0x00008000 */
N#define CAN_TSR_ABRQ1          CAN_TSR_ABRQ1_Msk                               /*!<Abort Request for Mailbox 1 */
N#define CAN_TSR_RQCP2_Pos      (16U)
N#define CAN_TSR_RQCP2_Msk      (0x1UL << CAN_TSR_RQCP2_Pos)                    /*!< 0x00010000 */
N#define CAN_TSR_RQCP2          CAN_TSR_RQCP2_Msk                               /*!<Request Completed Mailbox2 */
N#define CAN_TSR_TXOK2_Pos      (17U)
N#define CAN_TSR_TXOK2_Msk      (0x1UL << CAN_TSR_TXOK2_Pos)                    /*!< 0x00020000 */
N#define CAN_TSR_TXOK2          CAN_TSR_TXOK2_Msk                               /*!<Transmission OK of Mailbox 2 */
N#define CAN_TSR_ALST2_Pos      (18U)
N#define CAN_TSR_ALST2_Msk      (0x1UL << CAN_TSR_ALST2_Pos)                    /*!< 0x00040000 */
N#define CAN_TSR_ALST2          CAN_TSR_ALST2_Msk                               /*!<Arbitration Lost for mailbox 2 */
N#define CAN_TSR_TERR2_Pos      (19U)
N#define CAN_TSR_TERR2_Msk      (0x1UL << CAN_TSR_TERR2_Pos)                    /*!< 0x00080000 */
N#define CAN_TSR_TERR2          CAN_TSR_TERR2_Msk                               /*!<Transmission Error of Mailbox 2 */
N#define CAN_TSR_ABRQ2_Pos      (23U)
N#define CAN_TSR_ABRQ2_Msk      (0x1UL << CAN_TSR_ABRQ2_Pos)                    /*!< 0x00800000 */
N#define CAN_TSR_ABRQ2          CAN_TSR_ABRQ2_Msk                               /*!<Abort Request for Mailbox 2 */
N#define CAN_TSR_CODE_Pos       (24U)
N#define CAN_TSR_CODE_Msk       (0x3UL << CAN_TSR_CODE_Pos)                     /*!< 0x03000000 */
N#define CAN_TSR_CODE           CAN_TSR_CODE_Msk                                /*!<Mailbox Code */
N
N#define CAN_TSR_TME_Pos        (26U)
N#define CAN_TSR_TME_Msk        (0x7UL << CAN_TSR_TME_Pos)                      /*!< 0x1C000000 */
N#define CAN_TSR_TME            CAN_TSR_TME_Msk                                 /*!<TME[2:0] bits */
N#define CAN_TSR_TME0_Pos       (26U)
N#define CAN_TSR_TME0_Msk       (0x1UL << CAN_TSR_TME0_Pos)                     /*!< 0x04000000 */
N#define CAN_TSR_TME0           CAN_TSR_TME0_Msk                                /*!<Transmit Mailbox 0 Empty */
N#define CAN_TSR_TME1_Pos       (27U)
N#define CAN_TSR_TME1_Msk       (0x1UL << CAN_TSR_TME1_Pos)                     /*!< 0x08000000 */
N#define CAN_TSR_TME1           CAN_TSR_TME1_Msk                                /*!<Transmit Mailbox 1 Empty */
N#define CAN_TSR_TME2_Pos       (28U)
N#define CAN_TSR_TME2_Msk       (0x1UL << CAN_TSR_TME2_Pos)                     /*!< 0x10000000 */
N#define CAN_TSR_TME2           CAN_TSR_TME2_Msk                                /*!<Transmit Mailbox 2 Empty */
N
N#define CAN_TSR_LOW_Pos        (29U)
N#define CAN_TSR_LOW_Msk        (0x7UL << CAN_TSR_LOW_Pos)                      /*!< 0xE0000000 */
N#define CAN_TSR_LOW            CAN_TSR_LOW_Msk                                 /*!<LOW[2:0] bits */
N#define CAN_TSR_LOW0_Pos       (29U)
N#define CAN_TSR_LOW0_Msk       (0x1UL << CAN_TSR_LOW0_Pos)                     /*!< 0x20000000 */
N#define CAN_TSR_LOW0           CAN_TSR_LOW0_Msk                                /*!<Lowest Priority Flag for Mailbox 0 */
N#define CAN_TSR_LOW1_Pos       (30U)
N#define CAN_TSR_LOW1_Msk       (0x1UL << CAN_TSR_LOW1_Pos)                     /*!< 0x40000000 */
N#define CAN_TSR_LOW1           CAN_TSR_LOW1_Msk                                /*!<Lowest Priority Flag for Mailbox 1 */
N#define CAN_TSR_LOW2_Pos       (31U)
N#define CAN_TSR_LOW2_Msk       (0x1UL << CAN_TSR_LOW2_Pos)                     /*!< 0x80000000 */
N#define CAN_TSR_LOW2           CAN_TSR_LOW2_Msk                                /*!<Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define CAN_RF0R_FMP0_Pos      (0U)
N#define CAN_RF0R_FMP0_Msk      (0x3UL << CAN_RF0R_FMP0_Pos)                    /*!< 0x00000003 */
N#define CAN_RF0R_FMP0          CAN_RF0R_FMP0_Msk                               /*!<FIFO 0 Message Pending */
N#define CAN_RF0R_FULL0_Pos     (3U)
N#define CAN_RF0R_FULL0_Msk     (0x1UL << CAN_RF0R_FULL0_Pos)                   /*!< 0x00000008 */
N#define CAN_RF0R_FULL0         CAN_RF0R_FULL0_Msk                              /*!<FIFO 0 Full */
N#define CAN_RF0R_FOVR0_Pos     (4U)
N#define CAN_RF0R_FOVR0_Msk     (0x1UL << CAN_RF0R_FOVR0_Pos)                   /*!< 0x00000010 */
N#define CAN_RF0R_FOVR0         CAN_RF0R_FOVR0_Msk                              /*!<FIFO 0 Overrun */
N#define CAN_RF0R_RFOM0_Pos     (5U)
N#define CAN_RF0R_RFOM0_Msk     (0x1UL << CAN_RF0R_RFOM0_Pos)                   /*!< 0x00000020 */
N#define CAN_RF0R_RFOM0         CAN_RF0R_RFOM0_Msk                              /*!<Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define CAN_RF1R_FMP1_Pos      (0U)
N#define CAN_RF1R_FMP1_Msk      (0x3UL << CAN_RF1R_FMP1_Pos)                    /*!< 0x00000003 */
N#define CAN_RF1R_FMP1          CAN_RF1R_FMP1_Msk                               /*!<FIFO 1 Message Pending */
N#define CAN_RF1R_FULL1_Pos     (3U)
N#define CAN_RF1R_FULL1_Msk     (0x1UL << CAN_RF1R_FULL1_Pos)                   /*!< 0x00000008 */
N#define CAN_RF1R_FULL1         CAN_RF1R_FULL1_Msk                              /*!<FIFO 1 Full */
N#define CAN_RF1R_FOVR1_Pos     (4U)
N#define CAN_RF1R_FOVR1_Msk     (0x1UL << CAN_RF1R_FOVR1_Pos)                   /*!< 0x00000010 */
N#define CAN_RF1R_FOVR1         CAN_RF1R_FOVR1_Msk                              /*!<FIFO 1 Overrun */
N#define CAN_RF1R_RFOM1_Pos     (5U)
N#define CAN_RF1R_RFOM1_Msk     (0x1UL << CAN_RF1R_RFOM1_Pos)                   /*!< 0x00000020 */
N#define CAN_RF1R_RFOM1         CAN_RF1R_RFOM1_Msk                              /*!<Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define CAN_IER_TMEIE_Pos      (0U)
N#define CAN_IER_TMEIE_Msk      (0x1UL << CAN_IER_TMEIE_Pos)                    /*!< 0x00000001 */
N#define CAN_IER_TMEIE          CAN_IER_TMEIE_Msk                               /*!<Transmit Mailbox Empty Interrupt Enable */
N#define CAN_IER_FMPIE0_Pos     (1U)
N#define CAN_IER_FMPIE0_Msk     (0x1UL << CAN_IER_FMPIE0_Pos)                   /*!< 0x00000002 */
N#define CAN_IER_FMPIE0         CAN_IER_FMPIE0_Msk                              /*!<FIFO Message Pending Interrupt Enable */
N#define CAN_IER_FFIE0_Pos      (2U)
N#define CAN_IER_FFIE0_Msk      (0x1UL << CAN_IER_FFIE0_Pos)                    /*!< 0x00000004 */
N#define CAN_IER_FFIE0          CAN_IER_FFIE0_Msk                               /*!<FIFO Full Interrupt Enable */
N#define CAN_IER_FOVIE0_Pos     (3U)
N#define CAN_IER_FOVIE0_Msk     (0x1UL << CAN_IER_FOVIE0_Pos)                   /*!< 0x00000008 */
N#define CAN_IER_FOVIE0         CAN_IER_FOVIE0_Msk                              /*!<FIFO Overrun Interrupt Enable */
N#define CAN_IER_FMPIE1_Pos     (4U)
N#define CAN_IER_FMPIE1_Msk     (0x1UL << CAN_IER_FMPIE1_Pos)                   /*!< 0x00000010 */
N#define CAN_IER_FMPIE1         CAN_IER_FMPIE1_Msk                              /*!<FIFO Message Pending Interrupt Enable */
N#define CAN_IER_FFIE1_Pos      (5U)
N#define CAN_IER_FFIE1_Msk      (0x1UL << CAN_IER_FFIE1_Pos)                    /*!< 0x00000020 */
N#define CAN_IER_FFIE1          CAN_IER_FFIE1_Msk                               /*!<FIFO Full Interrupt Enable */
N#define CAN_IER_FOVIE1_Pos     (6U)
N#define CAN_IER_FOVIE1_Msk     (0x1UL << CAN_IER_FOVIE1_Pos)                   /*!< 0x00000040 */
N#define CAN_IER_FOVIE1         CAN_IER_FOVIE1_Msk                              /*!<FIFO Overrun Interrupt Enable */
N#define CAN_IER_EWGIE_Pos      (8U)
N#define CAN_IER_EWGIE_Msk      (0x1UL << CAN_IER_EWGIE_Pos)                    /*!< 0x00000100 */
N#define CAN_IER_EWGIE          CAN_IER_EWGIE_Msk                               /*!<Error Warning Interrupt Enable */
N#define CAN_IER_EPVIE_Pos      (9U)
N#define CAN_IER_EPVIE_Msk      (0x1UL << CAN_IER_EPVIE_Pos)                    /*!< 0x00000200 */
N#define CAN_IER_EPVIE          CAN_IER_EPVIE_Msk                               /*!<Error Passive Interrupt Enable */
N#define CAN_IER_BOFIE_Pos      (10U)
N#define CAN_IER_BOFIE_Msk      (0x1UL << CAN_IER_BOFIE_Pos)                    /*!< 0x00000400 */
N#define CAN_IER_BOFIE          CAN_IER_BOFIE_Msk                               /*!<Bus-Off Interrupt Enable */
N#define CAN_IER_LECIE_Pos      (11U)
N#define CAN_IER_LECIE_Msk      (0x1UL << CAN_IER_LECIE_Pos)                    /*!< 0x00000800 */
N#define CAN_IER_LECIE          CAN_IER_LECIE_Msk                               /*!<Last Error Code Interrupt Enable */
N#define CAN_IER_ERRIE_Pos      (15U)
N#define CAN_IER_ERRIE_Msk      (0x1UL << CAN_IER_ERRIE_Pos)                    /*!< 0x00008000 */
N#define CAN_IER_ERRIE          CAN_IER_ERRIE_Msk                               /*!<Error Interrupt Enable */
N#define CAN_IER_WKUIE_Pos      (16U)
N#define CAN_IER_WKUIE_Msk      (0x1UL << CAN_IER_WKUIE_Pos)                    /*!< 0x00010000 */
N#define CAN_IER_WKUIE          CAN_IER_WKUIE_Msk                               /*!<Wakeup Interrupt Enable */
N#define CAN_IER_SLKIE_Pos      (17U)
N#define CAN_IER_SLKIE_Msk      (0x1UL << CAN_IER_SLKIE_Pos)                    /*!< 0x00020000 */
N#define CAN_IER_SLKIE          CAN_IER_SLKIE_Msk                               /*!<Sleep Interrupt Enable */
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define CAN_ESR_EWGF_Pos       (0U)
N#define CAN_ESR_EWGF_Msk       (0x1UL << CAN_ESR_EWGF_Pos)                     /*!< 0x00000001 */
N#define CAN_ESR_EWGF           CAN_ESR_EWGF_Msk                                /*!<Error Warning Flag */
N#define CAN_ESR_EPVF_Pos       (1U)
N#define CAN_ESR_EPVF_Msk       (0x1UL << CAN_ESR_EPVF_Pos)                     /*!< 0x00000002 */
N#define CAN_ESR_EPVF           CAN_ESR_EPVF_Msk                                /*!<Error Passive Flag */
N#define CAN_ESR_BOFF_Pos       (2U)
N#define CAN_ESR_BOFF_Msk       (0x1UL << CAN_ESR_BOFF_Pos)                     /*!< 0x00000004 */
N#define CAN_ESR_BOFF           CAN_ESR_BOFF_Msk                                /*!<Bus-Off Flag */
N
N#define CAN_ESR_LEC_Pos        (4U)
N#define CAN_ESR_LEC_Msk        (0x7UL << CAN_ESR_LEC_Pos)                      /*!< 0x00000070 */
N#define CAN_ESR_LEC            CAN_ESR_LEC_Msk                                 /*!<LEC[2:0] bits (Last Error Code) */
N#define CAN_ESR_LEC_0          (0x1UL << CAN_ESR_LEC_Pos)                      /*!< 0x00000010 */
N#define CAN_ESR_LEC_1          (0x2UL << CAN_ESR_LEC_Pos)                      /*!< 0x00000020 */
N#define CAN_ESR_LEC_2          (0x4UL << CAN_ESR_LEC_Pos)                      /*!< 0x00000040 */
N
N#define CAN_ESR_TEC_Pos        (16U)
N#define CAN_ESR_TEC_Msk        (0xFFUL << CAN_ESR_TEC_Pos)                     /*!< 0x00FF0000 */
N#define CAN_ESR_TEC            CAN_ESR_TEC_Msk                                 /*!<Least significant byte of the 9-bit Transmit Error Counter */
N#define CAN_ESR_REC_Pos        (24U)
N#define CAN_ESR_REC_Msk        (0xFFUL << CAN_ESR_REC_Pos)                     /*!< 0xFF000000 */
N#define CAN_ESR_REC            CAN_ESR_REC_Msk                                 /*!<Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define CAN_BTR_BRP_Pos        (0U)
N#define CAN_BTR_BRP_Msk        (0x3FFUL << CAN_BTR_BRP_Pos)                    /*!< 0x000003FF */
N#define CAN_BTR_BRP            CAN_BTR_BRP_Msk                                 /*!<Baud Rate Prescaler */
N#define CAN_BTR_TS1_Pos        (16U)
N#define CAN_BTR_TS1_Msk        (0xFUL << CAN_BTR_TS1_Pos)                      /*!< 0x000F0000 */
N#define CAN_BTR_TS1            CAN_BTR_TS1_Msk                                 /*!<Time Segment 1 */
N#define CAN_BTR_TS1_0          (0x1UL << CAN_BTR_TS1_Pos)                      /*!< 0x00010000 */
N#define CAN_BTR_TS1_1          (0x2UL << CAN_BTR_TS1_Pos)                      /*!< 0x00020000 */
N#define CAN_BTR_TS1_2          (0x4UL << CAN_BTR_TS1_Pos)                      /*!< 0x00040000 */
N#define CAN_BTR_TS1_3          (0x8UL << CAN_BTR_TS1_Pos)                      /*!< 0x00080000 */
N#define CAN_BTR_TS2_Pos        (20U)
N#define CAN_BTR_TS2_Msk        (0x7UL << CAN_BTR_TS2_Pos)                      /*!< 0x00700000 */
N#define CAN_BTR_TS2            CAN_BTR_TS2_Msk                                 /*!<Time Segment 2 */
N#define CAN_BTR_TS2_0          (0x1UL << CAN_BTR_TS2_Pos)                      /*!< 0x00100000 */
N#define CAN_BTR_TS2_1          (0x2UL << CAN_BTR_TS2_Pos)                      /*!< 0x00200000 */
N#define CAN_BTR_TS2_2          (0x4UL << CAN_BTR_TS2_Pos)                      /*!< 0x00400000 */
N#define CAN_BTR_SJW_Pos        (24U)
N#define CAN_BTR_SJW_Msk        (0x3UL << CAN_BTR_SJW_Pos)                      /*!< 0x03000000 */
N#define CAN_BTR_SJW            CAN_BTR_SJW_Msk                                 /*!<Resynchronization Jump Width */
N#define CAN_BTR_SJW_0          (0x1UL << CAN_BTR_SJW_Pos)                      /*!< 0x01000000 */
N#define CAN_BTR_SJW_1          (0x2UL << CAN_BTR_SJW_Pos)                      /*!< 0x02000000 */
N#define CAN_BTR_LBKM_Pos       (30U)
N#define CAN_BTR_LBKM_Msk       (0x1UL << CAN_BTR_LBKM_Pos)                     /*!< 0x40000000 */
N#define CAN_BTR_LBKM           CAN_BTR_LBKM_Msk                                /*!<Loop Back Mode (Debug) */
N#define CAN_BTR_SILM_Pos       (31U)
N#define CAN_BTR_SILM_Msk       (0x1UL << CAN_BTR_SILM_Pos)                     /*!< 0x80000000 */
N#define CAN_BTR_SILM           CAN_BTR_SILM_Msk                                /*!<Silent Mode */
N
N/*!<Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define CAN_TI0R_TXRQ_Pos      (0U)
N#define CAN_TI0R_TXRQ_Msk      (0x1UL << CAN_TI0R_TXRQ_Pos)                    /*!< 0x00000001 */
N#define CAN_TI0R_TXRQ          CAN_TI0R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI0R_RTR_Pos       (1U)
N#define CAN_TI0R_RTR_Msk       (0x1UL << CAN_TI0R_RTR_Pos)                     /*!< 0x00000002 */
N#define CAN_TI0R_RTR           CAN_TI0R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI0R_IDE_Pos       (2U)
N#define CAN_TI0R_IDE_Msk       (0x1UL << CAN_TI0R_IDE_Pos)                     /*!< 0x00000004 */
N#define CAN_TI0R_IDE           CAN_TI0R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI0R_EXID_Pos      (3U)
N#define CAN_TI0R_EXID_Msk      (0x3FFFFUL << CAN_TI0R_EXID_Pos)                /*!< 0x001FFFF8 */
N#define CAN_TI0R_EXID          CAN_TI0R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_TI0R_STID_Pos      (21U)
N#define CAN_TI0R_STID_Msk      (0x7FFUL << CAN_TI0R_STID_Pos)                  /*!< 0xFFE00000 */
N#define CAN_TI0R_STID          CAN_TI0R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define CAN_TDT0R_DLC_Pos      (0U)
N#define CAN_TDT0R_DLC_Msk      (0xFUL << CAN_TDT0R_DLC_Pos)                    /*!< 0x0000000F */
N#define CAN_TDT0R_DLC          CAN_TDT0R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT0R_TGT_Pos      (8U)
N#define CAN_TDT0R_TGT_Msk      (0x1UL << CAN_TDT0R_TGT_Pos)                    /*!< 0x00000100 */
N#define CAN_TDT0R_TGT          CAN_TDT0R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT0R_TIME_Pos     (16U)
N#define CAN_TDT0R_TIME_Msk     (0xFFFFUL << CAN_TDT0R_TIME_Pos)                /*!< 0xFFFF0000 */
N#define CAN_TDT0R_TIME         CAN_TDT0R_TIME_Msk                              /*!<Message Time Stamp */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define CAN_TDL0R_DATA0_Pos    (0U)
N#define CAN_TDL0R_DATA0_Msk    (0xFFUL << CAN_TDL0R_DATA0_Pos)                 /*!< 0x000000FF */
N#define CAN_TDL0R_DATA0        CAN_TDL0R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL0R_DATA1_Pos    (8U)
N#define CAN_TDL0R_DATA1_Msk    (0xFFUL << CAN_TDL0R_DATA1_Pos)                 /*!< 0x0000FF00 */
N#define CAN_TDL0R_DATA1        CAN_TDL0R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL0R_DATA2_Pos    (16U)
N#define CAN_TDL0R_DATA2_Msk    (0xFFUL << CAN_TDL0R_DATA2_Pos)                 /*!< 0x00FF0000 */
N#define CAN_TDL0R_DATA2        CAN_TDL0R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL0R_DATA3_Pos    (24U)
N#define CAN_TDL0R_DATA3_Msk    (0xFFUL << CAN_TDL0R_DATA3_Pos)                 /*!< 0xFF000000 */
N#define CAN_TDL0R_DATA3        CAN_TDL0R_DATA3_Msk                             /*!<Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define CAN_TDH0R_DATA4_Pos    (0U)
N#define CAN_TDH0R_DATA4_Msk    (0xFFUL << CAN_TDH0R_DATA4_Pos)                 /*!< 0x000000FF */
N#define CAN_TDH0R_DATA4        CAN_TDH0R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH0R_DATA5_Pos    (8U)
N#define CAN_TDH0R_DATA5_Msk    (0xFFUL << CAN_TDH0R_DATA5_Pos)                 /*!< 0x0000FF00 */
N#define CAN_TDH0R_DATA5        CAN_TDH0R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH0R_DATA6_Pos    (16U)
N#define CAN_TDH0R_DATA6_Msk    (0xFFUL << CAN_TDH0R_DATA6_Pos)                 /*!< 0x00FF0000 */
N#define CAN_TDH0R_DATA6        CAN_TDH0R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH0R_DATA7_Pos    (24U)
N#define CAN_TDH0R_DATA7_Msk    (0xFFUL << CAN_TDH0R_DATA7_Pos)                 /*!< 0xFF000000 */
N#define CAN_TDH0R_DATA7        CAN_TDH0R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define CAN_TI1R_TXRQ_Pos      (0U)
N#define CAN_TI1R_TXRQ_Msk      (0x1UL << CAN_TI1R_TXRQ_Pos)                    /*!< 0x00000001 */
N#define CAN_TI1R_TXRQ          CAN_TI1R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI1R_RTR_Pos       (1U)
N#define CAN_TI1R_RTR_Msk       (0x1UL << CAN_TI1R_RTR_Pos)                     /*!< 0x00000002 */
N#define CAN_TI1R_RTR           CAN_TI1R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI1R_IDE_Pos       (2U)
N#define CAN_TI1R_IDE_Msk       (0x1UL << CAN_TI1R_IDE_Pos)                     /*!< 0x00000004 */
N#define CAN_TI1R_IDE           CAN_TI1R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI1R_EXID_Pos      (3U)
N#define CAN_TI1R_EXID_Msk      (0x3FFFFUL << CAN_TI1R_EXID_Pos)                /*!< 0x001FFFF8 */
N#define CAN_TI1R_EXID          CAN_TI1R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_TI1R_STID_Pos      (21U)
N#define CAN_TI1R_STID_Msk      (0x7FFUL << CAN_TI1R_STID_Pos)                  /*!< 0xFFE00000 */
N#define CAN_TI1R_STID          CAN_TI1R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define CAN_TDT1R_DLC_Pos      (0U)
N#define CAN_TDT1R_DLC_Msk      (0xFUL << CAN_TDT1R_DLC_Pos)                    /*!< 0x0000000F */
N#define CAN_TDT1R_DLC          CAN_TDT1R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT1R_TGT_Pos      (8U)
N#define CAN_TDT1R_TGT_Msk      (0x1UL << CAN_TDT1R_TGT_Pos)                    /*!< 0x00000100 */
N#define CAN_TDT1R_TGT          CAN_TDT1R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT1R_TIME_Pos     (16U)
N#define CAN_TDT1R_TIME_Msk     (0xFFFFUL << CAN_TDT1R_TIME_Pos)                /*!< 0xFFFF0000 */
N#define CAN_TDT1R_TIME         CAN_TDT1R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define CAN_TDL1R_DATA0_Pos    (0U)
N#define CAN_TDL1R_DATA0_Msk    (0xFFUL << CAN_TDL1R_DATA0_Pos)                 /*!< 0x000000FF */
N#define CAN_TDL1R_DATA0        CAN_TDL1R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL1R_DATA1_Pos    (8U)
N#define CAN_TDL1R_DATA1_Msk    (0xFFUL << CAN_TDL1R_DATA1_Pos)                 /*!< 0x0000FF00 */
N#define CAN_TDL1R_DATA1        CAN_TDL1R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL1R_DATA2_Pos    (16U)
N#define CAN_TDL1R_DATA2_Msk    (0xFFUL << CAN_TDL1R_DATA2_Pos)                 /*!< 0x00FF0000 */
N#define CAN_TDL1R_DATA2        CAN_TDL1R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL1R_DATA3_Pos    (24U)
N#define CAN_TDL1R_DATA3_Msk    (0xFFUL << CAN_TDL1R_DATA3_Pos)                 /*!< 0xFF000000 */
N#define CAN_TDL1R_DATA3        CAN_TDL1R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define CAN_TDH1R_DATA4_Pos    (0U)
N#define CAN_TDH1R_DATA4_Msk    (0xFFUL << CAN_TDH1R_DATA4_Pos)                 /*!< 0x000000FF */
N#define CAN_TDH1R_DATA4        CAN_TDH1R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH1R_DATA5_Pos    (8U)
N#define CAN_TDH1R_DATA5_Msk    (0xFFUL << CAN_TDH1R_DATA5_Pos)                 /*!< 0x0000FF00 */
N#define CAN_TDH1R_DATA5        CAN_TDH1R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH1R_DATA6_Pos    (16U)
N#define CAN_TDH1R_DATA6_Msk    (0xFFUL << CAN_TDH1R_DATA6_Pos)                 /*!< 0x00FF0000 */
N#define CAN_TDH1R_DATA6        CAN_TDH1R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH1R_DATA7_Pos    (24U)
N#define CAN_TDH1R_DATA7_Msk    (0xFFUL << CAN_TDH1R_DATA7_Pos)                 /*!< 0xFF000000 */
N#define CAN_TDH1R_DATA7        CAN_TDH1R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define CAN_TI2R_TXRQ_Pos      (0U)
N#define CAN_TI2R_TXRQ_Msk      (0x1UL << CAN_TI2R_TXRQ_Pos)                    /*!< 0x00000001 */
N#define CAN_TI2R_TXRQ          CAN_TI2R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI2R_RTR_Pos       (1U)
N#define CAN_TI2R_RTR_Msk       (0x1UL << CAN_TI2R_RTR_Pos)                     /*!< 0x00000002 */
N#define CAN_TI2R_RTR           CAN_TI2R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI2R_IDE_Pos       (2U)
N#define CAN_TI2R_IDE_Msk       (0x1UL << CAN_TI2R_IDE_Pos)                     /*!< 0x00000004 */
N#define CAN_TI2R_IDE           CAN_TI2R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI2R_EXID_Pos      (3U)
N#define CAN_TI2R_EXID_Msk      (0x3FFFFUL << CAN_TI2R_EXID_Pos)                /*!< 0x001FFFF8 */
N#define CAN_TI2R_EXID          CAN_TI2R_EXID_Msk                               /*!<Extended identifier */
N#define CAN_TI2R_STID_Pos      (21U)
N#define CAN_TI2R_STID_Msk      (0x7FFUL << CAN_TI2R_STID_Pos)                  /*!< 0xFFE00000 */
N#define CAN_TI2R_STID          CAN_TI2R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/
N#define CAN_TDT2R_DLC_Pos      (0U)
N#define CAN_TDT2R_DLC_Msk      (0xFUL << CAN_TDT2R_DLC_Pos)                    /*!< 0x0000000F */
N#define CAN_TDT2R_DLC          CAN_TDT2R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT2R_TGT_Pos      (8U)
N#define CAN_TDT2R_TGT_Msk      (0x1UL << CAN_TDT2R_TGT_Pos)                    /*!< 0x00000100 */
N#define CAN_TDT2R_TGT          CAN_TDT2R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT2R_TIME_Pos     (16U)
N#define CAN_TDT2R_TIME_Msk     (0xFFFFUL << CAN_TDT2R_TIME_Pos)                /*!< 0xFFFF0000 */
N#define CAN_TDT2R_TIME         CAN_TDT2R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define CAN_TDL2R_DATA0_Pos    (0U)
N#define CAN_TDL2R_DATA0_Msk    (0xFFUL << CAN_TDL2R_DATA0_Pos)                 /*!< 0x000000FF */
N#define CAN_TDL2R_DATA0        CAN_TDL2R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL2R_DATA1_Pos    (8U)
N#define CAN_TDL2R_DATA1_Msk    (0xFFUL << CAN_TDL2R_DATA1_Pos)                 /*!< 0x0000FF00 */
N#define CAN_TDL2R_DATA1        CAN_TDL2R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL2R_DATA2_Pos    (16U)
N#define CAN_TDL2R_DATA2_Msk    (0xFFUL << CAN_TDL2R_DATA2_Pos)                 /*!< 0x00FF0000 */
N#define CAN_TDL2R_DATA2        CAN_TDL2R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL2R_DATA3_Pos    (24U)
N#define CAN_TDL2R_DATA3_Msk    (0xFFUL << CAN_TDL2R_DATA3_Pos)                 /*!< 0xFF000000 */
N#define CAN_TDL2R_DATA3        CAN_TDL2R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define CAN_TDH2R_DATA4_Pos    (0U)
N#define CAN_TDH2R_DATA4_Msk    (0xFFUL << CAN_TDH2R_DATA4_Pos)                 /*!< 0x000000FF */
N#define CAN_TDH2R_DATA4        CAN_TDH2R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH2R_DATA5_Pos    (8U)
N#define CAN_TDH2R_DATA5_Msk    (0xFFUL << CAN_TDH2R_DATA5_Pos)                 /*!< 0x0000FF00 */
N#define CAN_TDH2R_DATA5        CAN_TDH2R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH2R_DATA6_Pos    (16U)
N#define CAN_TDH2R_DATA6_Msk    (0xFFUL << CAN_TDH2R_DATA6_Pos)                 /*!< 0x00FF0000 */
N#define CAN_TDH2R_DATA6        CAN_TDH2R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH2R_DATA7_Pos    (24U)
N#define CAN_TDH2R_DATA7_Msk    (0xFFUL << CAN_TDH2R_DATA7_Pos)                 /*!< 0xFF000000 */
N#define CAN_TDH2R_DATA7        CAN_TDH2R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define CAN_RI0R_RTR_Pos       (1U)
N#define CAN_RI0R_RTR_Msk       (0x1UL << CAN_RI0R_RTR_Pos)                     /*!< 0x00000002 */
N#define CAN_RI0R_RTR           CAN_RI0R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_RI0R_IDE_Pos       (2U)
N#define CAN_RI0R_IDE_Msk       (0x1UL << CAN_RI0R_IDE_Pos)                     /*!< 0x00000004 */
N#define CAN_RI0R_IDE           CAN_RI0R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_RI0R_EXID_Pos      (3U)
N#define CAN_RI0R_EXID_Msk      (0x3FFFFUL << CAN_RI0R_EXID_Pos)                /*!< 0x001FFFF8 */
N#define CAN_RI0R_EXID          CAN_RI0R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_RI0R_STID_Pos      (21U)
N#define CAN_RI0R_STID_Msk      (0x7FFUL << CAN_RI0R_STID_Pos)                  /*!< 0xFFE00000 */
N#define CAN_RI0R_STID          CAN_RI0R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define CAN_RDT0R_DLC_Pos      (0U)
N#define CAN_RDT0R_DLC_Msk      (0xFUL << CAN_RDT0R_DLC_Pos)                    /*!< 0x0000000F */
N#define CAN_RDT0R_DLC          CAN_RDT0R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_RDT0R_FMI_Pos      (8U)
N#define CAN_RDT0R_FMI_Msk      (0xFFUL << CAN_RDT0R_FMI_Pos)                   /*!< 0x0000FF00 */
N#define CAN_RDT0R_FMI          CAN_RDT0R_FMI_Msk                               /*!<Filter Match Index */
N#define CAN_RDT0R_TIME_Pos     (16U)
N#define CAN_RDT0R_TIME_Msk     (0xFFFFUL << CAN_RDT0R_TIME_Pos)                /*!< 0xFFFF0000 */
N#define CAN_RDT0R_TIME         CAN_RDT0R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define CAN_RDL0R_DATA0_Pos    (0U)
N#define CAN_RDL0R_DATA0_Msk    (0xFFUL << CAN_RDL0R_DATA0_Pos)                 /*!< 0x000000FF */
N#define CAN_RDL0R_DATA0        CAN_RDL0R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_RDL0R_DATA1_Pos    (8U)
N#define CAN_RDL0R_DATA1_Msk    (0xFFUL << CAN_RDL0R_DATA1_Pos)                 /*!< 0x0000FF00 */
N#define CAN_RDL0R_DATA1        CAN_RDL0R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_RDL0R_DATA2_Pos    (16U)
N#define CAN_RDL0R_DATA2_Msk    (0xFFUL << CAN_RDL0R_DATA2_Pos)                 /*!< 0x00FF0000 */
N#define CAN_RDL0R_DATA2        CAN_RDL0R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_RDL0R_DATA3_Pos    (24U)
N#define CAN_RDL0R_DATA3_Msk    (0xFFUL << CAN_RDL0R_DATA3_Pos)                 /*!< 0xFF000000 */
N#define CAN_RDL0R_DATA3        CAN_RDL0R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define CAN_RDH0R_DATA4_Pos    (0U)
N#define CAN_RDH0R_DATA4_Msk    (0xFFUL << CAN_RDH0R_DATA4_Pos)                 /*!< 0x000000FF */
N#define CAN_RDH0R_DATA4        CAN_RDH0R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_RDH0R_DATA5_Pos    (8U)
N#define CAN_RDH0R_DATA5_Msk    (0xFFUL << CAN_RDH0R_DATA5_Pos)                 /*!< 0x0000FF00 */
N#define CAN_RDH0R_DATA5        CAN_RDH0R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_RDH0R_DATA6_Pos    (16U)
N#define CAN_RDH0R_DATA6_Msk    (0xFFUL << CAN_RDH0R_DATA6_Pos)                 /*!< 0x00FF0000 */
N#define CAN_RDH0R_DATA6        CAN_RDH0R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_RDH0R_DATA7_Pos    (24U)
N#define CAN_RDH0R_DATA7_Msk    (0xFFUL << CAN_RDH0R_DATA7_Pos)                 /*!< 0xFF000000 */
N#define CAN_RDH0R_DATA7        CAN_RDH0R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define CAN_RI1R_RTR_Pos       (1U)
N#define CAN_RI1R_RTR_Msk       (0x1UL << CAN_RI1R_RTR_Pos)                     /*!< 0x00000002 */
N#define CAN_RI1R_RTR           CAN_RI1R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_RI1R_IDE_Pos       (2U)
N#define CAN_RI1R_IDE_Msk       (0x1UL << CAN_RI1R_IDE_Pos)                     /*!< 0x00000004 */
N#define CAN_RI1R_IDE           CAN_RI1R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_RI1R_EXID_Pos      (3U)
N#define CAN_RI1R_EXID_Msk      (0x3FFFFUL << CAN_RI1R_EXID_Pos)                /*!< 0x001FFFF8 */
N#define CAN_RI1R_EXID          CAN_RI1R_EXID_Msk                               /*!<Extended identifier */
N#define CAN_RI1R_STID_Pos      (21U)
N#define CAN_RI1R_STID_Msk      (0x7FFUL << CAN_RI1R_STID_Pos)                  /*!< 0xFFE00000 */
N#define CAN_RI1R_STID          CAN_RI1R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define CAN_RDT1R_DLC_Pos      (0U)
N#define CAN_RDT1R_DLC_Msk      (0xFUL << CAN_RDT1R_DLC_Pos)                    /*!< 0x0000000F */
N#define CAN_RDT1R_DLC          CAN_RDT1R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_RDT1R_FMI_Pos      (8U)
N#define CAN_RDT1R_FMI_Msk      (0xFFUL << CAN_RDT1R_FMI_Pos)                   /*!< 0x0000FF00 */
N#define CAN_RDT1R_FMI          CAN_RDT1R_FMI_Msk                               /*!<Filter Match Index */
N#define CAN_RDT1R_TIME_Pos     (16U)
N#define CAN_RDT1R_TIME_Msk     (0xFFFFUL << CAN_RDT1R_TIME_Pos)                /*!< 0xFFFF0000 */
N#define CAN_RDT1R_TIME         CAN_RDT1R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define CAN_RDL1R_DATA0_Pos    (0U)
N#define CAN_RDL1R_DATA0_Msk    (0xFFUL << CAN_RDL1R_DATA0_Pos)                 /*!< 0x000000FF */
N#define CAN_RDL1R_DATA0        CAN_RDL1R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_RDL1R_DATA1_Pos    (8U)
N#define CAN_RDL1R_DATA1_Msk    (0xFFUL << CAN_RDL1R_DATA1_Pos)                 /*!< 0x0000FF00 */
N#define CAN_RDL1R_DATA1        CAN_RDL1R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_RDL1R_DATA2_Pos    (16U)
N#define CAN_RDL1R_DATA2_Msk    (0xFFUL << CAN_RDL1R_DATA2_Pos)                 /*!< 0x00FF0000 */
N#define CAN_RDL1R_DATA2        CAN_RDL1R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_RDL1R_DATA3_Pos    (24U)
N#define CAN_RDL1R_DATA3_Msk    (0xFFUL << CAN_RDL1R_DATA3_Pos)                 /*!< 0xFF000000 */
N#define CAN_RDL1R_DATA3        CAN_RDL1R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define CAN_RDH1R_DATA4_Pos    (0U)
N#define CAN_RDH1R_DATA4_Msk    (0xFFUL << CAN_RDH1R_DATA4_Pos)                 /*!< 0x000000FF */
N#define CAN_RDH1R_DATA4        CAN_RDH1R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_RDH1R_DATA5_Pos    (8U)
N#define CAN_RDH1R_DATA5_Msk    (0xFFUL << CAN_RDH1R_DATA5_Pos)                 /*!< 0x0000FF00 */
N#define CAN_RDH1R_DATA5        CAN_RDH1R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_RDH1R_DATA6_Pos    (16U)
N#define CAN_RDH1R_DATA6_Msk    (0xFFUL << CAN_RDH1R_DATA6_Pos)                 /*!< 0x00FF0000 */
N#define CAN_RDH1R_DATA6        CAN_RDH1R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_RDH1R_DATA7_Pos    (24U)
N#define CAN_RDH1R_DATA7_Msk    (0xFFUL << CAN_RDH1R_DATA7_Pos)                 /*!< 0xFF000000 */
N#define CAN_RDH1R_DATA7        CAN_RDH1R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*!<CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define CAN_FMR_FINIT_Pos      (0U)
N#define CAN_FMR_FINIT_Msk      (0x1UL << CAN_FMR_FINIT_Pos)                    /*!< 0x00000001 */
N#define CAN_FMR_FINIT          CAN_FMR_FINIT_Msk                               /*!<Filter Init Mode */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define CAN_FM1R_FBM_Pos       (0U)
N#define CAN_FM1R_FBM_Msk       (0x3FFFUL << CAN_FM1R_FBM_Pos)                  /*!< 0x00003FFF */
N#define CAN_FM1R_FBM           CAN_FM1R_FBM_Msk                                /*!<Filter Mode */
N#define CAN_FM1R_FBM0_Pos      (0U)
N#define CAN_FM1R_FBM0_Msk      (0x1UL << CAN_FM1R_FBM0_Pos)                    /*!< 0x00000001 */
N#define CAN_FM1R_FBM0          CAN_FM1R_FBM0_Msk                               /*!<Filter Init Mode bit 0 */
N#define CAN_FM1R_FBM1_Pos      (1U)
N#define CAN_FM1R_FBM1_Msk      (0x1UL << CAN_FM1R_FBM1_Pos)                    /*!< 0x00000002 */
N#define CAN_FM1R_FBM1          CAN_FM1R_FBM1_Msk                               /*!<Filter Init Mode bit 1 */
N#define CAN_FM1R_FBM2_Pos      (2U)
N#define CAN_FM1R_FBM2_Msk      (0x1UL << CAN_FM1R_FBM2_Pos)                    /*!< 0x00000004 */
N#define CAN_FM1R_FBM2          CAN_FM1R_FBM2_Msk                               /*!<Filter Init Mode bit 2 */
N#define CAN_FM1R_FBM3_Pos      (3U)
N#define CAN_FM1R_FBM3_Msk      (0x1UL << CAN_FM1R_FBM3_Pos)                    /*!< 0x00000008 */
N#define CAN_FM1R_FBM3          CAN_FM1R_FBM3_Msk                               /*!<Filter Init Mode bit 3 */
N#define CAN_FM1R_FBM4_Pos      (4U)
N#define CAN_FM1R_FBM4_Msk      (0x1UL << CAN_FM1R_FBM4_Pos)                    /*!< 0x00000010 */
N#define CAN_FM1R_FBM4          CAN_FM1R_FBM4_Msk                               /*!<Filter Init Mode bit 4 */
N#define CAN_FM1R_FBM5_Pos      (5U)
N#define CAN_FM1R_FBM5_Msk      (0x1UL << CAN_FM1R_FBM5_Pos)                    /*!< 0x00000020 */
N#define CAN_FM1R_FBM5          CAN_FM1R_FBM5_Msk                               /*!<Filter Init Mode bit 5 */
N#define CAN_FM1R_FBM6_Pos      (6U)
N#define CAN_FM1R_FBM6_Msk      (0x1UL << CAN_FM1R_FBM6_Pos)                    /*!< 0x00000040 */
N#define CAN_FM1R_FBM6          CAN_FM1R_FBM6_Msk                               /*!<Filter Init Mode bit 6 */
N#define CAN_FM1R_FBM7_Pos      (7U)
N#define CAN_FM1R_FBM7_Msk      (0x1UL << CAN_FM1R_FBM7_Pos)                    /*!< 0x00000080 */
N#define CAN_FM1R_FBM7          CAN_FM1R_FBM7_Msk                               /*!<Filter Init Mode bit 7 */
N#define CAN_FM1R_FBM8_Pos      (8U)
N#define CAN_FM1R_FBM8_Msk      (0x1UL << CAN_FM1R_FBM8_Pos)                    /*!< 0x00000100 */
N#define CAN_FM1R_FBM8          CAN_FM1R_FBM8_Msk                               /*!<Filter Init Mode bit 8 */
N#define CAN_FM1R_FBM9_Pos      (9U)
N#define CAN_FM1R_FBM9_Msk      (0x1UL << CAN_FM1R_FBM9_Pos)                    /*!< 0x00000200 */
N#define CAN_FM1R_FBM9          CAN_FM1R_FBM9_Msk                               /*!<Filter Init Mode bit 9 */
N#define CAN_FM1R_FBM10_Pos     (10U)
N#define CAN_FM1R_FBM10_Msk     (0x1UL << CAN_FM1R_FBM10_Pos)                   /*!< 0x00000400 */
N#define CAN_FM1R_FBM10         CAN_FM1R_FBM10_Msk                              /*!<Filter Init Mode bit 10 */
N#define CAN_FM1R_FBM11_Pos     (11U)
N#define CAN_FM1R_FBM11_Msk     (0x1UL << CAN_FM1R_FBM11_Pos)                   /*!< 0x00000800 */
N#define CAN_FM1R_FBM11         CAN_FM1R_FBM11_Msk                              /*!<Filter Init Mode bit 11 */
N#define CAN_FM1R_FBM12_Pos     (12U)
N#define CAN_FM1R_FBM12_Msk     (0x1UL << CAN_FM1R_FBM12_Pos)                   /*!< 0x00001000 */
N#define CAN_FM1R_FBM12         CAN_FM1R_FBM12_Msk                              /*!<Filter Init Mode bit 12 */
N#define CAN_FM1R_FBM13_Pos     (13U)
N#define CAN_FM1R_FBM13_Msk     (0x1UL << CAN_FM1R_FBM13_Pos)                   /*!< 0x00002000 */
N#define CAN_FM1R_FBM13         CAN_FM1R_FBM13_Msk                              /*!<Filter Init Mode bit 13 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define CAN_FS1R_FSC_Pos       (0U)
N#define CAN_FS1R_FSC_Msk       (0x3FFFUL << CAN_FS1R_FSC_Pos)                  /*!< 0x00003FFF */
N#define CAN_FS1R_FSC           CAN_FS1R_FSC_Msk                                /*!<Filter Scale Configuration */
N#define CAN_FS1R_FSC0_Pos      (0U)
N#define CAN_FS1R_FSC0_Msk      (0x1UL << CAN_FS1R_FSC0_Pos)                    /*!< 0x00000001 */
N#define CAN_FS1R_FSC0          CAN_FS1R_FSC0_Msk                               /*!<Filter Scale Configuration bit 0 */
N#define CAN_FS1R_FSC1_Pos      (1U)
N#define CAN_FS1R_FSC1_Msk      (0x1UL << CAN_FS1R_FSC1_Pos)                    /*!< 0x00000002 */
N#define CAN_FS1R_FSC1          CAN_FS1R_FSC1_Msk                               /*!<Filter Scale Configuration bit 1 */
N#define CAN_FS1R_FSC2_Pos      (2U)
N#define CAN_FS1R_FSC2_Msk      (0x1UL << CAN_FS1R_FSC2_Pos)                    /*!< 0x00000004 */
N#define CAN_FS1R_FSC2          CAN_FS1R_FSC2_Msk                               /*!<Filter Scale Configuration bit 2 */
N#define CAN_FS1R_FSC3_Pos      (3U)
N#define CAN_FS1R_FSC3_Msk      (0x1UL << CAN_FS1R_FSC3_Pos)                    /*!< 0x00000008 */
N#define CAN_FS1R_FSC3          CAN_FS1R_FSC3_Msk                               /*!<Filter Scale Configuration bit 3 */
N#define CAN_FS1R_FSC4_Pos      (4U)
N#define CAN_FS1R_FSC4_Msk      (0x1UL << CAN_FS1R_FSC4_Pos)                    /*!< 0x00000010 */
N#define CAN_FS1R_FSC4          CAN_FS1R_FSC4_Msk                               /*!<Filter Scale Configuration bit 4 */
N#define CAN_FS1R_FSC5_Pos      (5U)
N#define CAN_FS1R_FSC5_Msk      (0x1UL << CAN_FS1R_FSC5_Pos)                    /*!< 0x00000020 */
N#define CAN_FS1R_FSC5          CAN_FS1R_FSC5_Msk                               /*!<Filter Scale Configuration bit 5 */
N#define CAN_FS1R_FSC6_Pos      (6U)
N#define CAN_FS1R_FSC6_Msk      (0x1UL << CAN_FS1R_FSC6_Pos)                    /*!< 0x00000040 */
N#define CAN_FS1R_FSC6          CAN_FS1R_FSC6_Msk                               /*!<Filter Scale Configuration bit 6 */
N#define CAN_FS1R_FSC7_Pos      (7U)
N#define CAN_FS1R_FSC7_Msk      (0x1UL << CAN_FS1R_FSC7_Pos)                    /*!< 0x00000080 */
N#define CAN_FS1R_FSC7          CAN_FS1R_FSC7_Msk                               /*!<Filter Scale Configuration bit 7 */
N#define CAN_FS1R_FSC8_Pos      (8U)
N#define CAN_FS1R_FSC8_Msk      (0x1UL << CAN_FS1R_FSC8_Pos)                    /*!< 0x00000100 */
N#define CAN_FS1R_FSC8          CAN_FS1R_FSC8_Msk                               /*!<Filter Scale Configuration bit 8 */
N#define CAN_FS1R_FSC9_Pos      (9U)
N#define CAN_FS1R_FSC9_Msk      (0x1UL << CAN_FS1R_FSC9_Pos)                    /*!< 0x00000200 */
N#define CAN_FS1R_FSC9          CAN_FS1R_FSC9_Msk                               /*!<Filter Scale Configuration bit 9 */
N#define CAN_FS1R_FSC10_Pos     (10U)
N#define CAN_FS1R_FSC10_Msk     (0x1UL << CAN_FS1R_FSC10_Pos)                   /*!< 0x00000400 */
N#define CAN_FS1R_FSC10         CAN_FS1R_FSC10_Msk                              /*!<Filter Scale Configuration bit 10 */
N#define CAN_FS1R_FSC11_Pos     (11U)
N#define CAN_FS1R_FSC11_Msk     (0x1UL << CAN_FS1R_FSC11_Pos)                   /*!< 0x00000800 */
N#define CAN_FS1R_FSC11         CAN_FS1R_FSC11_Msk                              /*!<Filter Scale Configuration bit 11 */
N#define CAN_FS1R_FSC12_Pos     (12U)
N#define CAN_FS1R_FSC12_Msk     (0x1UL << CAN_FS1R_FSC12_Pos)                   /*!< 0x00001000 */
N#define CAN_FS1R_FSC12         CAN_FS1R_FSC12_Msk                              /*!<Filter Scale Configuration bit 12 */
N#define CAN_FS1R_FSC13_Pos     (13U)
N#define CAN_FS1R_FSC13_Msk     (0x1UL << CAN_FS1R_FSC13_Pos)                   /*!< 0x00002000 */
N#define CAN_FS1R_FSC13         CAN_FS1R_FSC13_Msk                              /*!<Filter Scale Configuration bit 13 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define CAN_FFA1R_FFA_Pos      (0U)
N#define CAN_FFA1R_FFA_Msk      (0x3FFFUL << CAN_FFA1R_FFA_Pos)                 /*!< 0x00003FFF */
N#define CAN_FFA1R_FFA          CAN_FFA1R_FFA_Msk                               /*!<Filter FIFO Assignment */
N#define CAN_FFA1R_FFA0_Pos     (0U)
N#define CAN_FFA1R_FFA0_Msk     (0x1UL << CAN_FFA1R_FFA0_Pos)                   /*!< 0x00000001 */
N#define CAN_FFA1R_FFA0         CAN_FFA1R_FFA0_Msk                              /*!<Filter FIFO Assignment for Filter 0 */
N#define CAN_FFA1R_FFA1_Pos     (1U)
N#define CAN_FFA1R_FFA1_Msk     (0x1UL << CAN_FFA1R_FFA1_Pos)                   /*!< 0x00000002 */
N#define CAN_FFA1R_FFA1         CAN_FFA1R_FFA1_Msk                              /*!<Filter FIFO Assignment for Filter 1 */
N#define CAN_FFA1R_FFA2_Pos     (2U)
N#define CAN_FFA1R_FFA2_Msk     (0x1UL << CAN_FFA1R_FFA2_Pos)                   /*!< 0x00000004 */
N#define CAN_FFA1R_FFA2         CAN_FFA1R_FFA2_Msk                              /*!<Filter FIFO Assignment for Filter 2 */
N#define CAN_FFA1R_FFA3_Pos     (3U)
N#define CAN_FFA1R_FFA3_Msk     (0x1UL << CAN_FFA1R_FFA3_Pos)                   /*!< 0x00000008 */
N#define CAN_FFA1R_FFA3         CAN_FFA1R_FFA3_Msk                              /*!<Filter FIFO Assignment for Filter 3 */
N#define CAN_FFA1R_FFA4_Pos     (4U)
N#define CAN_FFA1R_FFA4_Msk     (0x1UL << CAN_FFA1R_FFA4_Pos)                   /*!< 0x00000010 */
N#define CAN_FFA1R_FFA4         CAN_FFA1R_FFA4_Msk                              /*!<Filter FIFO Assignment for Filter 4 */
N#define CAN_FFA1R_FFA5_Pos     (5U)
N#define CAN_FFA1R_FFA5_Msk     (0x1UL << CAN_FFA1R_FFA5_Pos)                   /*!< 0x00000020 */
N#define CAN_FFA1R_FFA5         CAN_FFA1R_FFA5_Msk                              /*!<Filter FIFO Assignment for Filter 5 */
N#define CAN_FFA1R_FFA6_Pos     (6U)
N#define CAN_FFA1R_FFA6_Msk     (0x1UL << CAN_FFA1R_FFA6_Pos)                   /*!< 0x00000040 */
N#define CAN_FFA1R_FFA6         CAN_FFA1R_FFA6_Msk                              /*!<Filter FIFO Assignment for Filter 6 */
N#define CAN_FFA1R_FFA7_Pos     (7U)
N#define CAN_FFA1R_FFA7_Msk     (0x1UL << CAN_FFA1R_FFA7_Pos)                   /*!< 0x00000080 */
N#define CAN_FFA1R_FFA7         CAN_FFA1R_FFA7_Msk                              /*!<Filter FIFO Assignment for Filter 7 */
N#define CAN_FFA1R_FFA8_Pos     (8U)
N#define CAN_FFA1R_FFA8_Msk     (0x1UL << CAN_FFA1R_FFA8_Pos)                   /*!< 0x00000100 */
N#define CAN_FFA1R_FFA8         CAN_FFA1R_FFA8_Msk                              /*!<Filter FIFO Assignment for Filter 8 */
N#define CAN_FFA1R_FFA9_Pos     (9U)
N#define CAN_FFA1R_FFA9_Msk     (0x1UL << CAN_FFA1R_FFA9_Pos)                   /*!< 0x00000200 */
N#define CAN_FFA1R_FFA9         CAN_FFA1R_FFA9_Msk                              /*!<Filter FIFO Assignment for Filter 9 */
N#define CAN_FFA1R_FFA10_Pos    (10U)
N#define CAN_FFA1R_FFA10_Msk    (0x1UL << CAN_FFA1R_FFA10_Pos)                  /*!< 0x00000400 */
N#define CAN_FFA1R_FFA10        CAN_FFA1R_FFA10_Msk                             /*!<Filter FIFO Assignment for Filter 10 */
N#define CAN_FFA1R_FFA11_Pos    (11U)
N#define CAN_FFA1R_FFA11_Msk    (0x1UL << CAN_FFA1R_FFA11_Pos)                  /*!< 0x00000800 */
N#define CAN_FFA1R_FFA11        CAN_FFA1R_FFA11_Msk                             /*!<Filter FIFO Assignment for Filter 11 */
N#define CAN_FFA1R_FFA12_Pos    (12U)
N#define CAN_FFA1R_FFA12_Msk    (0x1UL << CAN_FFA1R_FFA12_Pos)                  /*!< 0x00001000 */
N#define CAN_FFA1R_FFA12        CAN_FFA1R_FFA12_Msk                             /*!<Filter FIFO Assignment for Filter 12 */
N#define CAN_FFA1R_FFA13_Pos    (13U)
N#define CAN_FFA1R_FFA13_Msk    (0x1UL << CAN_FFA1R_FFA13_Pos)                  /*!< 0x00002000 */
N#define CAN_FFA1R_FFA13        CAN_FFA1R_FFA13_Msk                             /*!<Filter FIFO Assignment for Filter 13 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define CAN_FA1R_FACT_Pos      (0U)
N#define CAN_FA1R_FACT_Msk      (0x3FFFUL << CAN_FA1R_FACT_Pos)                 /*!< 0x00003FFF */
N#define CAN_FA1R_FACT          CAN_FA1R_FACT_Msk                               /*!<Filter Active */
N#define CAN_FA1R_FACT0_Pos     (0U)
N#define CAN_FA1R_FACT0_Msk     (0x1UL << CAN_FA1R_FACT0_Pos)                   /*!< 0x00000001 */
N#define CAN_FA1R_FACT0         CAN_FA1R_FACT0_Msk                              /*!<Filter 0 Active */
N#define CAN_FA1R_FACT1_Pos     (1U)
N#define CAN_FA1R_FACT1_Msk     (0x1UL << CAN_FA1R_FACT1_Pos)                   /*!< 0x00000002 */
N#define CAN_FA1R_FACT1         CAN_FA1R_FACT1_Msk                              /*!<Filter 1 Active */
N#define CAN_FA1R_FACT2_Pos     (2U)
N#define CAN_FA1R_FACT2_Msk     (0x1UL << CAN_FA1R_FACT2_Pos)                   /*!< 0x00000004 */
N#define CAN_FA1R_FACT2         CAN_FA1R_FACT2_Msk                              /*!<Filter 2 Active */
N#define CAN_FA1R_FACT3_Pos     (3U)
N#define CAN_FA1R_FACT3_Msk     (0x1UL << CAN_FA1R_FACT3_Pos)                   /*!< 0x00000008 */
N#define CAN_FA1R_FACT3         CAN_FA1R_FACT3_Msk                              /*!<Filter 3 Active */
N#define CAN_FA1R_FACT4_Pos     (4U)
N#define CAN_FA1R_FACT4_Msk     (0x1UL << CAN_FA1R_FACT4_Pos)                   /*!< 0x00000010 */
N#define CAN_FA1R_FACT4         CAN_FA1R_FACT4_Msk                              /*!<Filter 4 Active */
N#define CAN_FA1R_FACT5_Pos     (5U)
N#define CAN_FA1R_FACT5_Msk     (0x1UL << CAN_FA1R_FACT5_Pos)                   /*!< 0x00000020 */
N#define CAN_FA1R_FACT5         CAN_FA1R_FACT5_Msk                              /*!<Filter 5 Active */
N#define CAN_FA1R_FACT6_Pos     (6U)
N#define CAN_FA1R_FACT6_Msk     (0x1UL << CAN_FA1R_FACT6_Pos)                   /*!< 0x00000040 */
N#define CAN_FA1R_FACT6         CAN_FA1R_FACT6_Msk                              /*!<Filter 6 Active */
N#define CAN_FA1R_FACT7_Pos     (7U)
N#define CAN_FA1R_FACT7_Msk     (0x1UL << CAN_FA1R_FACT7_Pos)                   /*!< 0x00000080 */
N#define CAN_FA1R_FACT7         CAN_FA1R_FACT7_Msk                              /*!<Filter 7 Active */
N#define CAN_FA1R_FACT8_Pos     (8U)
N#define CAN_FA1R_FACT8_Msk     (0x1UL << CAN_FA1R_FACT8_Pos)                   /*!< 0x00000100 */
N#define CAN_FA1R_FACT8         CAN_FA1R_FACT8_Msk                              /*!<Filter 8 Active */
N#define CAN_FA1R_FACT9_Pos     (9U)
N#define CAN_FA1R_FACT9_Msk     (0x1UL << CAN_FA1R_FACT9_Pos)                   /*!< 0x00000200 */
N#define CAN_FA1R_FACT9         CAN_FA1R_FACT9_Msk                              /*!<Filter 9 Active */
N#define CAN_FA1R_FACT10_Pos    (10U)
N#define CAN_FA1R_FACT10_Msk    (0x1UL << CAN_FA1R_FACT10_Pos)                  /*!< 0x00000400 */
N#define CAN_FA1R_FACT10        CAN_FA1R_FACT10_Msk                             /*!<Filter 10 Active */
N#define CAN_FA1R_FACT11_Pos    (11U)
N#define CAN_FA1R_FACT11_Msk    (0x1UL << CAN_FA1R_FACT11_Pos)                  /*!< 0x00000800 */
N#define CAN_FA1R_FACT11        CAN_FA1R_FACT11_Msk                             /*!<Filter 11 Active */
N#define CAN_FA1R_FACT12_Pos    (12U)
N#define CAN_FA1R_FACT12_Msk    (0x1UL << CAN_FA1R_FACT12_Pos)                  /*!< 0x00001000 */
N#define CAN_FA1R_FACT12        CAN_FA1R_FACT12_Msk                             /*!<Filter 12 Active */
N#define CAN_FA1R_FACT13_Pos    (13U)
N#define CAN_FA1R_FACT13_Msk    (0x1UL << CAN_FA1R_FACT13_Pos)                  /*!< 0x00002000 */
N#define CAN_FA1R_FACT13        CAN_FA1R_FACT13_Msk                             /*!<Filter 13 Active */
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define CAN_F0R1_FB0_Pos       (0U)
N#define CAN_F0R1_FB0_Msk       (0x1UL << CAN_F0R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F0R1_FB0           CAN_F0R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F0R1_FB1_Pos       (1U)
N#define CAN_F0R1_FB1_Msk       (0x1UL << CAN_F0R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F0R1_FB1           CAN_F0R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F0R1_FB2_Pos       (2U)
N#define CAN_F0R1_FB2_Msk       (0x1UL << CAN_F0R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F0R1_FB2           CAN_F0R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F0R1_FB3_Pos       (3U)
N#define CAN_F0R1_FB3_Msk       (0x1UL << CAN_F0R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F0R1_FB3           CAN_F0R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F0R1_FB4_Pos       (4U)
N#define CAN_F0R1_FB4_Msk       (0x1UL << CAN_F0R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F0R1_FB4           CAN_F0R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F0R1_FB5_Pos       (5U)
N#define CAN_F0R1_FB5_Msk       (0x1UL << CAN_F0R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F0R1_FB5           CAN_F0R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F0R1_FB6_Pos       (6U)
N#define CAN_F0R1_FB6_Msk       (0x1UL << CAN_F0R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F0R1_FB6           CAN_F0R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F0R1_FB7_Pos       (7U)
N#define CAN_F0R1_FB7_Msk       (0x1UL << CAN_F0R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F0R1_FB7           CAN_F0R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F0R1_FB8_Pos       (8U)
N#define CAN_F0R1_FB8_Msk       (0x1UL << CAN_F0R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F0R1_FB8           CAN_F0R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F0R1_FB9_Pos       (9U)
N#define CAN_F0R1_FB9_Msk       (0x1UL << CAN_F0R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F0R1_FB9           CAN_F0R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F0R1_FB10_Pos      (10U)
N#define CAN_F0R1_FB10_Msk      (0x1UL << CAN_F0R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F0R1_FB10          CAN_F0R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F0R1_FB11_Pos      (11U)
N#define CAN_F0R1_FB11_Msk      (0x1UL << CAN_F0R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F0R1_FB11          CAN_F0R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F0R1_FB12_Pos      (12U)
N#define CAN_F0R1_FB12_Msk      (0x1UL << CAN_F0R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F0R1_FB12          CAN_F0R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F0R1_FB13_Pos      (13U)
N#define CAN_F0R1_FB13_Msk      (0x1UL << CAN_F0R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F0R1_FB13          CAN_F0R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F0R1_FB14_Pos      (14U)
N#define CAN_F0R1_FB14_Msk      (0x1UL << CAN_F0R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F0R1_FB14          CAN_F0R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F0R1_FB15_Pos      (15U)
N#define CAN_F0R1_FB15_Msk      (0x1UL << CAN_F0R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F0R1_FB15          CAN_F0R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F0R1_FB16_Pos      (16U)
N#define CAN_F0R1_FB16_Msk      (0x1UL << CAN_F0R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F0R1_FB16          CAN_F0R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F0R1_FB17_Pos      (17U)
N#define CAN_F0R1_FB17_Msk      (0x1UL << CAN_F0R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F0R1_FB17          CAN_F0R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F0R1_FB18_Pos      (18U)
N#define CAN_F0R1_FB18_Msk      (0x1UL << CAN_F0R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F0R1_FB18          CAN_F0R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F0R1_FB19_Pos      (19U)
N#define CAN_F0R1_FB19_Msk      (0x1UL << CAN_F0R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F0R1_FB19          CAN_F0R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F0R1_FB20_Pos      (20U)
N#define CAN_F0R1_FB20_Msk      (0x1UL << CAN_F0R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F0R1_FB20          CAN_F0R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F0R1_FB21_Pos      (21U)
N#define CAN_F0R1_FB21_Msk      (0x1UL << CAN_F0R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F0R1_FB21          CAN_F0R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F0R1_FB22_Pos      (22U)
N#define CAN_F0R1_FB22_Msk      (0x1UL << CAN_F0R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F0R1_FB22          CAN_F0R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F0R1_FB23_Pos      (23U)
N#define CAN_F0R1_FB23_Msk      (0x1UL << CAN_F0R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F0R1_FB23          CAN_F0R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F0R1_FB24_Pos      (24U)
N#define CAN_F0R1_FB24_Msk      (0x1UL << CAN_F0R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F0R1_FB24          CAN_F0R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F0R1_FB25_Pos      (25U)
N#define CAN_F0R1_FB25_Msk      (0x1UL << CAN_F0R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F0R1_FB25          CAN_F0R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F0R1_FB26_Pos      (26U)
N#define CAN_F0R1_FB26_Msk      (0x1UL << CAN_F0R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F0R1_FB26          CAN_F0R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F0R1_FB27_Pos      (27U)
N#define CAN_F0R1_FB27_Msk      (0x1UL << CAN_F0R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F0R1_FB27          CAN_F0R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F0R1_FB28_Pos      (28U)
N#define CAN_F0R1_FB28_Msk      (0x1UL << CAN_F0R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F0R1_FB28          CAN_F0R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F0R1_FB29_Pos      (29U)
N#define CAN_F0R1_FB29_Msk      (0x1UL << CAN_F0R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F0R1_FB29          CAN_F0R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F0R1_FB30_Pos      (30U)
N#define CAN_F0R1_FB30_Msk      (0x1UL << CAN_F0R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F0R1_FB30          CAN_F0R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F0R1_FB31_Pos      (31U)
N#define CAN_F0R1_FB31_Msk      (0x1UL << CAN_F0R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F0R1_FB31          CAN_F0R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define CAN_F1R1_FB0_Pos       (0U)
N#define CAN_F1R1_FB0_Msk       (0x1UL << CAN_F1R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F1R1_FB0           CAN_F1R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F1R1_FB1_Pos       (1U)
N#define CAN_F1R1_FB1_Msk       (0x1UL << CAN_F1R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F1R1_FB1           CAN_F1R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F1R1_FB2_Pos       (2U)
N#define CAN_F1R1_FB2_Msk       (0x1UL << CAN_F1R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F1R1_FB2           CAN_F1R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F1R1_FB3_Pos       (3U)
N#define CAN_F1R1_FB3_Msk       (0x1UL << CAN_F1R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F1R1_FB3           CAN_F1R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F1R1_FB4_Pos       (4U)
N#define CAN_F1R1_FB4_Msk       (0x1UL << CAN_F1R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F1R1_FB4           CAN_F1R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F1R1_FB5_Pos       (5U)
N#define CAN_F1R1_FB5_Msk       (0x1UL << CAN_F1R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F1R1_FB5           CAN_F1R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F1R1_FB6_Pos       (6U)
N#define CAN_F1R1_FB6_Msk       (0x1UL << CAN_F1R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F1R1_FB6           CAN_F1R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F1R1_FB7_Pos       (7U)
N#define CAN_F1R1_FB7_Msk       (0x1UL << CAN_F1R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F1R1_FB7           CAN_F1R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F1R1_FB8_Pos       (8U)
N#define CAN_F1R1_FB8_Msk       (0x1UL << CAN_F1R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F1R1_FB8           CAN_F1R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F1R1_FB9_Pos       (9U)
N#define CAN_F1R1_FB9_Msk       (0x1UL << CAN_F1R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F1R1_FB9           CAN_F1R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F1R1_FB10_Pos      (10U)
N#define CAN_F1R1_FB10_Msk      (0x1UL << CAN_F1R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F1R1_FB10          CAN_F1R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F1R1_FB11_Pos      (11U)
N#define CAN_F1R1_FB11_Msk      (0x1UL << CAN_F1R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F1R1_FB11          CAN_F1R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F1R1_FB12_Pos      (12U)
N#define CAN_F1R1_FB12_Msk      (0x1UL << CAN_F1R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F1R1_FB12          CAN_F1R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F1R1_FB13_Pos      (13U)
N#define CAN_F1R1_FB13_Msk      (0x1UL << CAN_F1R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F1R1_FB13          CAN_F1R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F1R1_FB14_Pos      (14U)
N#define CAN_F1R1_FB14_Msk      (0x1UL << CAN_F1R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F1R1_FB14          CAN_F1R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F1R1_FB15_Pos      (15U)
N#define CAN_F1R1_FB15_Msk      (0x1UL << CAN_F1R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F1R1_FB15          CAN_F1R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F1R1_FB16_Pos      (16U)
N#define CAN_F1R1_FB16_Msk      (0x1UL << CAN_F1R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F1R1_FB16          CAN_F1R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F1R1_FB17_Pos      (17U)
N#define CAN_F1R1_FB17_Msk      (0x1UL << CAN_F1R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F1R1_FB17          CAN_F1R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F1R1_FB18_Pos      (18U)
N#define CAN_F1R1_FB18_Msk      (0x1UL << CAN_F1R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F1R1_FB18          CAN_F1R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F1R1_FB19_Pos      (19U)
N#define CAN_F1R1_FB19_Msk      (0x1UL << CAN_F1R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F1R1_FB19          CAN_F1R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F1R1_FB20_Pos      (20U)
N#define CAN_F1R1_FB20_Msk      (0x1UL << CAN_F1R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F1R1_FB20          CAN_F1R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F1R1_FB21_Pos      (21U)
N#define CAN_F1R1_FB21_Msk      (0x1UL << CAN_F1R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F1R1_FB21          CAN_F1R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F1R1_FB22_Pos      (22U)
N#define CAN_F1R1_FB22_Msk      (0x1UL << CAN_F1R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F1R1_FB22          CAN_F1R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F1R1_FB23_Pos      (23U)
N#define CAN_F1R1_FB23_Msk      (0x1UL << CAN_F1R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F1R1_FB23          CAN_F1R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F1R1_FB24_Pos      (24U)
N#define CAN_F1R1_FB24_Msk      (0x1UL << CAN_F1R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F1R1_FB24          CAN_F1R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F1R1_FB25_Pos      (25U)
N#define CAN_F1R1_FB25_Msk      (0x1UL << CAN_F1R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F1R1_FB25          CAN_F1R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F1R1_FB26_Pos      (26U)
N#define CAN_F1R1_FB26_Msk      (0x1UL << CAN_F1R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F1R1_FB26          CAN_F1R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F1R1_FB27_Pos      (27U)
N#define CAN_F1R1_FB27_Msk      (0x1UL << CAN_F1R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F1R1_FB27          CAN_F1R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F1R1_FB28_Pos      (28U)
N#define CAN_F1R1_FB28_Msk      (0x1UL << CAN_F1R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F1R1_FB28          CAN_F1R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F1R1_FB29_Pos      (29U)
N#define CAN_F1R1_FB29_Msk      (0x1UL << CAN_F1R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F1R1_FB29          CAN_F1R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F1R1_FB30_Pos      (30U)
N#define CAN_F1R1_FB30_Msk      (0x1UL << CAN_F1R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F1R1_FB30          CAN_F1R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F1R1_FB31_Pos      (31U)
N#define CAN_F1R1_FB31_Msk      (0x1UL << CAN_F1R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F1R1_FB31          CAN_F1R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define CAN_F2R1_FB0_Pos       (0U)
N#define CAN_F2R1_FB0_Msk       (0x1UL << CAN_F2R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F2R1_FB0           CAN_F2R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F2R1_FB1_Pos       (1U)
N#define CAN_F2R1_FB1_Msk       (0x1UL << CAN_F2R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F2R1_FB1           CAN_F2R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F2R1_FB2_Pos       (2U)
N#define CAN_F2R1_FB2_Msk       (0x1UL << CAN_F2R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F2R1_FB2           CAN_F2R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F2R1_FB3_Pos       (3U)
N#define CAN_F2R1_FB3_Msk       (0x1UL << CAN_F2R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F2R1_FB3           CAN_F2R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F2R1_FB4_Pos       (4U)
N#define CAN_F2R1_FB4_Msk       (0x1UL << CAN_F2R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F2R1_FB4           CAN_F2R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F2R1_FB5_Pos       (5U)
N#define CAN_F2R1_FB5_Msk       (0x1UL << CAN_F2R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F2R1_FB5           CAN_F2R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F2R1_FB6_Pos       (6U)
N#define CAN_F2R1_FB6_Msk       (0x1UL << CAN_F2R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F2R1_FB6           CAN_F2R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F2R1_FB7_Pos       (7U)
N#define CAN_F2R1_FB7_Msk       (0x1UL << CAN_F2R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F2R1_FB7           CAN_F2R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F2R1_FB8_Pos       (8U)
N#define CAN_F2R1_FB8_Msk       (0x1UL << CAN_F2R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F2R1_FB8           CAN_F2R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F2R1_FB9_Pos       (9U)
N#define CAN_F2R1_FB9_Msk       (0x1UL << CAN_F2R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F2R1_FB9           CAN_F2R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F2R1_FB10_Pos      (10U)
N#define CAN_F2R1_FB10_Msk      (0x1UL << CAN_F2R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F2R1_FB10          CAN_F2R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F2R1_FB11_Pos      (11U)
N#define CAN_F2R1_FB11_Msk      (0x1UL << CAN_F2R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F2R1_FB11          CAN_F2R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F2R1_FB12_Pos      (12U)
N#define CAN_F2R1_FB12_Msk      (0x1UL << CAN_F2R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F2R1_FB12          CAN_F2R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F2R1_FB13_Pos      (13U)
N#define CAN_F2R1_FB13_Msk      (0x1UL << CAN_F2R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F2R1_FB13          CAN_F2R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F2R1_FB14_Pos      (14U)
N#define CAN_F2R1_FB14_Msk      (0x1UL << CAN_F2R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F2R1_FB14          CAN_F2R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F2R1_FB15_Pos      (15U)
N#define CAN_F2R1_FB15_Msk      (0x1UL << CAN_F2R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F2R1_FB15          CAN_F2R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F2R1_FB16_Pos      (16U)
N#define CAN_F2R1_FB16_Msk      (0x1UL << CAN_F2R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F2R1_FB16          CAN_F2R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F2R1_FB17_Pos      (17U)
N#define CAN_F2R1_FB17_Msk      (0x1UL << CAN_F2R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F2R1_FB17          CAN_F2R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F2R1_FB18_Pos      (18U)
N#define CAN_F2R1_FB18_Msk      (0x1UL << CAN_F2R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F2R1_FB18          CAN_F2R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F2R1_FB19_Pos      (19U)
N#define CAN_F2R1_FB19_Msk      (0x1UL << CAN_F2R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F2R1_FB19          CAN_F2R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F2R1_FB20_Pos      (20U)
N#define CAN_F2R1_FB20_Msk      (0x1UL << CAN_F2R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F2R1_FB20          CAN_F2R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F2R1_FB21_Pos      (21U)
N#define CAN_F2R1_FB21_Msk      (0x1UL << CAN_F2R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F2R1_FB21          CAN_F2R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F2R1_FB22_Pos      (22U)
N#define CAN_F2R1_FB22_Msk      (0x1UL << CAN_F2R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F2R1_FB22          CAN_F2R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F2R1_FB23_Pos      (23U)
N#define CAN_F2R1_FB23_Msk      (0x1UL << CAN_F2R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F2R1_FB23          CAN_F2R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F2R1_FB24_Pos      (24U)
N#define CAN_F2R1_FB24_Msk      (0x1UL << CAN_F2R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F2R1_FB24          CAN_F2R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F2R1_FB25_Pos      (25U)
N#define CAN_F2R1_FB25_Msk      (0x1UL << CAN_F2R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F2R1_FB25          CAN_F2R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F2R1_FB26_Pos      (26U)
N#define CAN_F2R1_FB26_Msk      (0x1UL << CAN_F2R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F2R1_FB26          CAN_F2R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F2R1_FB27_Pos      (27U)
N#define CAN_F2R1_FB27_Msk      (0x1UL << CAN_F2R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F2R1_FB27          CAN_F2R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F2R1_FB28_Pos      (28U)
N#define CAN_F2R1_FB28_Msk      (0x1UL << CAN_F2R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F2R1_FB28          CAN_F2R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F2R1_FB29_Pos      (29U)
N#define CAN_F2R1_FB29_Msk      (0x1UL << CAN_F2R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F2R1_FB29          CAN_F2R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F2R1_FB30_Pos      (30U)
N#define CAN_F2R1_FB30_Msk      (0x1UL << CAN_F2R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F2R1_FB30          CAN_F2R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F2R1_FB31_Pos      (31U)
N#define CAN_F2R1_FB31_Msk      (0x1UL << CAN_F2R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F2R1_FB31          CAN_F2R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define CAN_F3R1_FB0_Pos       (0U)
N#define CAN_F3R1_FB0_Msk       (0x1UL << CAN_F3R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F3R1_FB0           CAN_F3R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F3R1_FB1_Pos       (1U)
N#define CAN_F3R1_FB1_Msk       (0x1UL << CAN_F3R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F3R1_FB1           CAN_F3R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F3R1_FB2_Pos       (2U)
N#define CAN_F3R1_FB2_Msk       (0x1UL << CAN_F3R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F3R1_FB2           CAN_F3R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F3R1_FB3_Pos       (3U)
N#define CAN_F3R1_FB3_Msk       (0x1UL << CAN_F3R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F3R1_FB3           CAN_F3R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F3R1_FB4_Pos       (4U)
N#define CAN_F3R1_FB4_Msk       (0x1UL << CAN_F3R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F3R1_FB4           CAN_F3R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F3R1_FB5_Pos       (5U)
N#define CAN_F3R1_FB5_Msk       (0x1UL << CAN_F3R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F3R1_FB5           CAN_F3R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F3R1_FB6_Pos       (6U)
N#define CAN_F3R1_FB6_Msk       (0x1UL << CAN_F3R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F3R1_FB6           CAN_F3R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F3R1_FB7_Pos       (7U)
N#define CAN_F3R1_FB7_Msk       (0x1UL << CAN_F3R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F3R1_FB7           CAN_F3R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F3R1_FB8_Pos       (8U)
N#define CAN_F3R1_FB8_Msk       (0x1UL << CAN_F3R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F3R1_FB8           CAN_F3R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F3R1_FB9_Pos       (9U)
N#define CAN_F3R1_FB9_Msk       (0x1UL << CAN_F3R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F3R1_FB9           CAN_F3R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F3R1_FB10_Pos      (10U)
N#define CAN_F3R1_FB10_Msk      (0x1UL << CAN_F3R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F3R1_FB10          CAN_F3R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F3R1_FB11_Pos      (11U)
N#define CAN_F3R1_FB11_Msk      (0x1UL << CAN_F3R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F3R1_FB11          CAN_F3R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F3R1_FB12_Pos      (12U)
N#define CAN_F3R1_FB12_Msk      (0x1UL << CAN_F3R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F3R1_FB12          CAN_F3R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F3R1_FB13_Pos      (13U)
N#define CAN_F3R1_FB13_Msk      (0x1UL << CAN_F3R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F3R1_FB13          CAN_F3R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F3R1_FB14_Pos      (14U)
N#define CAN_F3R1_FB14_Msk      (0x1UL << CAN_F3R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F3R1_FB14          CAN_F3R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F3R1_FB15_Pos      (15U)
N#define CAN_F3R1_FB15_Msk      (0x1UL << CAN_F3R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F3R1_FB15          CAN_F3R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F3R1_FB16_Pos      (16U)
N#define CAN_F3R1_FB16_Msk      (0x1UL << CAN_F3R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F3R1_FB16          CAN_F3R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F3R1_FB17_Pos      (17U)
N#define CAN_F3R1_FB17_Msk      (0x1UL << CAN_F3R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F3R1_FB17          CAN_F3R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F3R1_FB18_Pos      (18U)
N#define CAN_F3R1_FB18_Msk      (0x1UL << CAN_F3R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F3R1_FB18          CAN_F3R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F3R1_FB19_Pos      (19U)
N#define CAN_F3R1_FB19_Msk      (0x1UL << CAN_F3R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F3R1_FB19          CAN_F3R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F3R1_FB20_Pos      (20U)
N#define CAN_F3R1_FB20_Msk      (0x1UL << CAN_F3R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F3R1_FB20          CAN_F3R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F3R1_FB21_Pos      (21U)
N#define CAN_F3R1_FB21_Msk      (0x1UL << CAN_F3R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F3R1_FB21          CAN_F3R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F3R1_FB22_Pos      (22U)
N#define CAN_F3R1_FB22_Msk      (0x1UL << CAN_F3R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F3R1_FB22          CAN_F3R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F3R1_FB23_Pos      (23U)
N#define CAN_F3R1_FB23_Msk      (0x1UL << CAN_F3R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F3R1_FB23          CAN_F3R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F3R1_FB24_Pos      (24U)
N#define CAN_F3R1_FB24_Msk      (0x1UL << CAN_F3R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F3R1_FB24          CAN_F3R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F3R1_FB25_Pos      (25U)
N#define CAN_F3R1_FB25_Msk      (0x1UL << CAN_F3R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F3R1_FB25          CAN_F3R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F3R1_FB26_Pos      (26U)
N#define CAN_F3R1_FB26_Msk      (0x1UL << CAN_F3R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F3R1_FB26          CAN_F3R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F3R1_FB27_Pos      (27U)
N#define CAN_F3R1_FB27_Msk      (0x1UL << CAN_F3R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F3R1_FB27          CAN_F3R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F3R1_FB28_Pos      (28U)
N#define CAN_F3R1_FB28_Msk      (0x1UL << CAN_F3R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F3R1_FB28          CAN_F3R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F3R1_FB29_Pos      (29U)
N#define CAN_F3R1_FB29_Msk      (0x1UL << CAN_F3R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F3R1_FB29          CAN_F3R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F3R1_FB30_Pos      (30U)
N#define CAN_F3R1_FB30_Msk      (0x1UL << CAN_F3R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F3R1_FB30          CAN_F3R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F3R1_FB31_Pos      (31U)
N#define CAN_F3R1_FB31_Msk      (0x1UL << CAN_F3R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F3R1_FB31          CAN_F3R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define CAN_F4R1_FB0_Pos       (0U)
N#define CAN_F4R1_FB0_Msk       (0x1UL << CAN_F4R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F4R1_FB0           CAN_F4R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F4R1_FB1_Pos       (1U)
N#define CAN_F4R1_FB1_Msk       (0x1UL << CAN_F4R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F4R1_FB1           CAN_F4R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F4R1_FB2_Pos       (2U)
N#define CAN_F4R1_FB2_Msk       (0x1UL << CAN_F4R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F4R1_FB2           CAN_F4R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F4R1_FB3_Pos       (3U)
N#define CAN_F4R1_FB3_Msk       (0x1UL << CAN_F4R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F4R1_FB3           CAN_F4R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F4R1_FB4_Pos       (4U)
N#define CAN_F4R1_FB4_Msk       (0x1UL << CAN_F4R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F4R1_FB4           CAN_F4R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F4R1_FB5_Pos       (5U)
N#define CAN_F4R1_FB5_Msk       (0x1UL << CAN_F4R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F4R1_FB5           CAN_F4R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F4R1_FB6_Pos       (6U)
N#define CAN_F4R1_FB6_Msk       (0x1UL << CAN_F4R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F4R1_FB6           CAN_F4R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F4R1_FB7_Pos       (7U)
N#define CAN_F4R1_FB7_Msk       (0x1UL << CAN_F4R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F4R1_FB7           CAN_F4R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F4R1_FB8_Pos       (8U)
N#define CAN_F4R1_FB8_Msk       (0x1UL << CAN_F4R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F4R1_FB8           CAN_F4R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F4R1_FB9_Pos       (9U)
N#define CAN_F4R1_FB9_Msk       (0x1UL << CAN_F4R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F4R1_FB9           CAN_F4R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F4R1_FB10_Pos      (10U)
N#define CAN_F4R1_FB10_Msk      (0x1UL << CAN_F4R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F4R1_FB10          CAN_F4R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F4R1_FB11_Pos      (11U)
N#define CAN_F4R1_FB11_Msk      (0x1UL << CAN_F4R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F4R1_FB11          CAN_F4R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F4R1_FB12_Pos      (12U)
N#define CAN_F4R1_FB12_Msk      (0x1UL << CAN_F4R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F4R1_FB12          CAN_F4R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F4R1_FB13_Pos      (13U)
N#define CAN_F4R1_FB13_Msk      (0x1UL << CAN_F4R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F4R1_FB13          CAN_F4R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F4R1_FB14_Pos      (14U)
N#define CAN_F4R1_FB14_Msk      (0x1UL << CAN_F4R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F4R1_FB14          CAN_F4R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F4R1_FB15_Pos      (15U)
N#define CAN_F4R1_FB15_Msk      (0x1UL << CAN_F4R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F4R1_FB15          CAN_F4R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F4R1_FB16_Pos      (16U)
N#define CAN_F4R1_FB16_Msk      (0x1UL << CAN_F4R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F4R1_FB16          CAN_F4R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F4R1_FB17_Pos      (17U)
N#define CAN_F4R1_FB17_Msk      (0x1UL << CAN_F4R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F4R1_FB17          CAN_F4R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F4R1_FB18_Pos      (18U)
N#define CAN_F4R1_FB18_Msk      (0x1UL << CAN_F4R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F4R1_FB18          CAN_F4R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F4R1_FB19_Pos      (19U)
N#define CAN_F4R1_FB19_Msk      (0x1UL << CAN_F4R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F4R1_FB19          CAN_F4R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F4R1_FB20_Pos      (20U)
N#define CAN_F4R1_FB20_Msk      (0x1UL << CAN_F4R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F4R1_FB20          CAN_F4R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F4R1_FB21_Pos      (21U)
N#define CAN_F4R1_FB21_Msk      (0x1UL << CAN_F4R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F4R1_FB21          CAN_F4R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F4R1_FB22_Pos      (22U)
N#define CAN_F4R1_FB22_Msk      (0x1UL << CAN_F4R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F4R1_FB22          CAN_F4R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F4R1_FB23_Pos      (23U)
N#define CAN_F4R1_FB23_Msk      (0x1UL << CAN_F4R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F4R1_FB23          CAN_F4R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F4R1_FB24_Pos      (24U)
N#define CAN_F4R1_FB24_Msk      (0x1UL << CAN_F4R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F4R1_FB24          CAN_F4R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F4R1_FB25_Pos      (25U)
N#define CAN_F4R1_FB25_Msk      (0x1UL << CAN_F4R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F4R1_FB25          CAN_F4R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F4R1_FB26_Pos      (26U)
N#define CAN_F4R1_FB26_Msk      (0x1UL << CAN_F4R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F4R1_FB26          CAN_F4R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F4R1_FB27_Pos      (27U)
N#define CAN_F4R1_FB27_Msk      (0x1UL << CAN_F4R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F4R1_FB27          CAN_F4R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F4R1_FB28_Pos      (28U)
N#define CAN_F4R1_FB28_Msk      (0x1UL << CAN_F4R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F4R1_FB28          CAN_F4R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F4R1_FB29_Pos      (29U)
N#define CAN_F4R1_FB29_Msk      (0x1UL << CAN_F4R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F4R1_FB29          CAN_F4R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F4R1_FB30_Pos      (30U)
N#define CAN_F4R1_FB30_Msk      (0x1UL << CAN_F4R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F4R1_FB30          CAN_F4R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F4R1_FB31_Pos      (31U)
N#define CAN_F4R1_FB31_Msk      (0x1UL << CAN_F4R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F4R1_FB31          CAN_F4R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define CAN_F5R1_FB0_Pos       (0U)
N#define CAN_F5R1_FB0_Msk       (0x1UL << CAN_F5R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F5R1_FB0           CAN_F5R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F5R1_FB1_Pos       (1U)
N#define CAN_F5R1_FB1_Msk       (0x1UL << CAN_F5R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F5R1_FB1           CAN_F5R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F5R1_FB2_Pos       (2U)
N#define CAN_F5R1_FB2_Msk       (0x1UL << CAN_F5R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F5R1_FB2           CAN_F5R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F5R1_FB3_Pos       (3U)
N#define CAN_F5R1_FB3_Msk       (0x1UL << CAN_F5R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F5R1_FB3           CAN_F5R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F5R1_FB4_Pos       (4U)
N#define CAN_F5R1_FB4_Msk       (0x1UL << CAN_F5R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F5R1_FB4           CAN_F5R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F5R1_FB5_Pos       (5U)
N#define CAN_F5R1_FB5_Msk       (0x1UL << CAN_F5R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F5R1_FB5           CAN_F5R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F5R1_FB6_Pos       (6U)
N#define CAN_F5R1_FB6_Msk       (0x1UL << CAN_F5R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F5R1_FB6           CAN_F5R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F5R1_FB7_Pos       (7U)
N#define CAN_F5R1_FB7_Msk       (0x1UL << CAN_F5R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F5R1_FB7           CAN_F5R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F5R1_FB8_Pos       (8U)
N#define CAN_F5R1_FB8_Msk       (0x1UL << CAN_F5R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F5R1_FB8           CAN_F5R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F5R1_FB9_Pos       (9U)
N#define CAN_F5R1_FB9_Msk       (0x1UL << CAN_F5R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F5R1_FB9           CAN_F5R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F5R1_FB10_Pos      (10U)
N#define CAN_F5R1_FB10_Msk      (0x1UL << CAN_F5R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F5R1_FB10          CAN_F5R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F5R1_FB11_Pos      (11U)
N#define CAN_F5R1_FB11_Msk      (0x1UL << CAN_F5R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F5R1_FB11          CAN_F5R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F5R1_FB12_Pos      (12U)
N#define CAN_F5R1_FB12_Msk      (0x1UL << CAN_F5R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F5R1_FB12          CAN_F5R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F5R1_FB13_Pos      (13U)
N#define CAN_F5R1_FB13_Msk      (0x1UL << CAN_F5R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F5R1_FB13          CAN_F5R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F5R1_FB14_Pos      (14U)
N#define CAN_F5R1_FB14_Msk      (0x1UL << CAN_F5R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F5R1_FB14          CAN_F5R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F5R1_FB15_Pos      (15U)
N#define CAN_F5R1_FB15_Msk      (0x1UL << CAN_F5R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F5R1_FB15          CAN_F5R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F5R1_FB16_Pos      (16U)
N#define CAN_F5R1_FB16_Msk      (0x1UL << CAN_F5R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F5R1_FB16          CAN_F5R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F5R1_FB17_Pos      (17U)
N#define CAN_F5R1_FB17_Msk      (0x1UL << CAN_F5R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F5R1_FB17          CAN_F5R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F5R1_FB18_Pos      (18U)
N#define CAN_F5R1_FB18_Msk      (0x1UL << CAN_F5R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F5R1_FB18          CAN_F5R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F5R1_FB19_Pos      (19U)
N#define CAN_F5R1_FB19_Msk      (0x1UL << CAN_F5R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F5R1_FB19          CAN_F5R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F5R1_FB20_Pos      (20U)
N#define CAN_F5R1_FB20_Msk      (0x1UL << CAN_F5R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F5R1_FB20          CAN_F5R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F5R1_FB21_Pos      (21U)
N#define CAN_F5R1_FB21_Msk      (0x1UL << CAN_F5R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F5R1_FB21          CAN_F5R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F5R1_FB22_Pos      (22U)
N#define CAN_F5R1_FB22_Msk      (0x1UL << CAN_F5R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F5R1_FB22          CAN_F5R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F5R1_FB23_Pos      (23U)
N#define CAN_F5R1_FB23_Msk      (0x1UL << CAN_F5R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F5R1_FB23          CAN_F5R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F5R1_FB24_Pos      (24U)
N#define CAN_F5R1_FB24_Msk      (0x1UL << CAN_F5R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F5R1_FB24          CAN_F5R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F5R1_FB25_Pos      (25U)
N#define CAN_F5R1_FB25_Msk      (0x1UL << CAN_F5R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F5R1_FB25          CAN_F5R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F5R1_FB26_Pos      (26U)
N#define CAN_F5R1_FB26_Msk      (0x1UL << CAN_F5R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F5R1_FB26          CAN_F5R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F5R1_FB27_Pos      (27U)
N#define CAN_F5R1_FB27_Msk      (0x1UL << CAN_F5R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F5R1_FB27          CAN_F5R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F5R1_FB28_Pos      (28U)
N#define CAN_F5R1_FB28_Msk      (0x1UL << CAN_F5R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F5R1_FB28          CAN_F5R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F5R1_FB29_Pos      (29U)
N#define CAN_F5R1_FB29_Msk      (0x1UL << CAN_F5R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F5R1_FB29          CAN_F5R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F5R1_FB30_Pos      (30U)
N#define CAN_F5R1_FB30_Msk      (0x1UL << CAN_F5R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F5R1_FB30          CAN_F5R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F5R1_FB31_Pos      (31U)
N#define CAN_F5R1_FB31_Msk      (0x1UL << CAN_F5R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F5R1_FB31          CAN_F5R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define CAN_F6R1_FB0_Pos       (0U)
N#define CAN_F6R1_FB0_Msk       (0x1UL << CAN_F6R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F6R1_FB0           CAN_F6R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F6R1_FB1_Pos       (1U)
N#define CAN_F6R1_FB1_Msk       (0x1UL << CAN_F6R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F6R1_FB1           CAN_F6R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F6R1_FB2_Pos       (2U)
N#define CAN_F6R1_FB2_Msk       (0x1UL << CAN_F6R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F6R1_FB2           CAN_F6R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F6R1_FB3_Pos       (3U)
N#define CAN_F6R1_FB3_Msk       (0x1UL << CAN_F6R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F6R1_FB3           CAN_F6R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F6R1_FB4_Pos       (4U)
N#define CAN_F6R1_FB4_Msk       (0x1UL << CAN_F6R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F6R1_FB4           CAN_F6R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F6R1_FB5_Pos       (5U)
N#define CAN_F6R1_FB5_Msk       (0x1UL << CAN_F6R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F6R1_FB5           CAN_F6R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F6R1_FB6_Pos       (6U)
N#define CAN_F6R1_FB6_Msk       (0x1UL << CAN_F6R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F6R1_FB6           CAN_F6R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F6R1_FB7_Pos       (7U)
N#define CAN_F6R1_FB7_Msk       (0x1UL << CAN_F6R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F6R1_FB7           CAN_F6R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F6R1_FB8_Pos       (8U)
N#define CAN_F6R1_FB8_Msk       (0x1UL << CAN_F6R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F6R1_FB8           CAN_F6R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F6R1_FB9_Pos       (9U)
N#define CAN_F6R1_FB9_Msk       (0x1UL << CAN_F6R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F6R1_FB9           CAN_F6R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F6R1_FB10_Pos      (10U)
N#define CAN_F6R1_FB10_Msk      (0x1UL << CAN_F6R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F6R1_FB10          CAN_F6R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F6R1_FB11_Pos      (11U)
N#define CAN_F6R1_FB11_Msk      (0x1UL << CAN_F6R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F6R1_FB11          CAN_F6R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F6R1_FB12_Pos      (12U)
N#define CAN_F6R1_FB12_Msk      (0x1UL << CAN_F6R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F6R1_FB12          CAN_F6R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F6R1_FB13_Pos      (13U)
N#define CAN_F6R1_FB13_Msk      (0x1UL << CAN_F6R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F6R1_FB13          CAN_F6R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F6R1_FB14_Pos      (14U)
N#define CAN_F6R1_FB14_Msk      (0x1UL << CAN_F6R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F6R1_FB14          CAN_F6R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F6R1_FB15_Pos      (15U)
N#define CAN_F6R1_FB15_Msk      (0x1UL << CAN_F6R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F6R1_FB15          CAN_F6R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F6R1_FB16_Pos      (16U)
N#define CAN_F6R1_FB16_Msk      (0x1UL << CAN_F6R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F6R1_FB16          CAN_F6R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F6R1_FB17_Pos      (17U)
N#define CAN_F6R1_FB17_Msk      (0x1UL << CAN_F6R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F6R1_FB17          CAN_F6R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F6R1_FB18_Pos      (18U)
N#define CAN_F6R1_FB18_Msk      (0x1UL << CAN_F6R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F6R1_FB18          CAN_F6R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F6R1_FB19_Pos      (19U)
N#define CAN_F6R1_FB19_Msk      (0x1UL << CAN_F6R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F6R1_FB19          CAN_F6R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F6R1_FB20_Pos      (20U)
N#define CAN_F6R1_FB20_Msk      (0x1UL << CAN_F6R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F6R1_FB20          CAN_F6R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F6R1_FB21_Pos      (21U)
N#define CAN_F6R1_FB21_Msk      (0x1UL << CAN_F6R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F6R1_FB21          CAN_F6R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F6R1_FB22_Pos      (22U)
N#define CAN_F6R1_FB22_Msk      (0x1UL << CAN_F6R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F6R1_FB22          CAN_F6R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F6R1_FB23_Pos      (23U)
N#define CAN_F6R1_FB23_Msk      (0x1UL << CAN_F6R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F6R1_FB23          CAN_F6R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F6R1_FB24_Pos      (24U)
N#define CAN_F6R1_FB24_Msk      (0x1UL << CAN_F6R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F6R1_FB24          CAN_F6R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F6R1_FB25_Pos      (25U)
N#define CAN_F6R1_FB25_Msk      (0x1UL << CAN_F6R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F6R1_FB25          CAN_F6R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F6R1_FB26_Pos      (26U)
N#define CAN_F6R1_FB26_Msk      (0x1UL << CAN_F6R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F6R1_FB26          CAN_F6R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F6R1_FB27_Pos      (27U)
N#define CAN_F6R1_FB27_Msk      (0x1UL << CAN_F6R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F6R1_FB27          CAN_F6R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F6R1_FB28_Pos      (28U)
N#define CAN_F6R1_FB28_Msk      (0x1UL << CAN_F6R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F6R1_FB28          CAN_F6R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F6R1_FB29_Pos      (29U)
N#define CAN_F6R1_FB29_Msk      (0x1UL << CAN_F6R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F6R1_FB29          CAN_F6R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F6R1_FB30_Pos      (30U)
N#define CAN_F6R1_FB30_Msk      (0x1UL << CAN_F6R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F6R1_FB30          CAN_F6R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F6R1_FB31_Pos      (31U)
N#define CAN_F6R1_FB31_Msk      (0x1UL << CAN_F6R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F6R1_FB31          CAN_F6R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define CAN_F7R1_FB0_Pos       (0U)
N#define CAN_F7R1_FB0_Msk       (0x1UL << CAN_F7R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F7R1_FB0           CAN_F7R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F7R1_FB1_Pos       (1U)
N#define CAN_F7R1_FB1_Msk       (0x1UL << CAN_F7R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F7R1_FB1           CAN_F7R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F7R1_FB2_Pos       (2U)
N#define CAN_F7R1_FB2_Msk       (0x1UL << CAN_F7R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F7R1_FB2           CAN_F7R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F7R1_FB3_Pos       (3U)
N#define CAN_F7R1_FB3_Msk       (0x1UL << CAN_F7R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F7R1_FB3           CAN_F7R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F7R1_FB4_Pos       (4U)
N#define CAN_F7R1_FB4_Msk       (0x1UL << CAN_F7R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F7R1_FB4           CAN_F7R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F7R1_FB5_Pos       (5U)
N#define CAN_F7R1_FB5_Msk       (0x1UL << CAN_F7R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F7R1_FB5           CAN_F7R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F7R1_FB6_Pos       (6U)
N#define CAN_F7R1_FB6_Msk       (0x1UL << CAN_F7R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F7R1_FB6           CAN_F7R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F7R1_FB7_Pos       (7U)
N#define CAN_F7R1_FB7_Msk       (0x1UL << CAN_F7R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F7R1_FB7           CAN_F7R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F7R1_FB8_Pos       (8U)
N#define CAN_F7R1_FB8_Msk       (0x1UL << CAN_F7R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F7R1_FB8           CAN_F7R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F7R1_FB9_Pos       (9U)
N#define CAN_F7R1_FB9_Msk       (0x1UL << CAN_F7R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F7R1_FB9           CAN_F7R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F7R1_FB10_Pos      (10U)
N#define CAN_F7R1_FB10_Msk      (0x1UL << CAN_F7R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F7R1_FB10          CAN_F7R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F7R1_FB11_Pos      (11U)
N#define CAN_F7R1_FB11_Msk      (0x1UL << CAN_F7R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F7R1_FB11          CAN_F7R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F7R1_FB12_Pos      (12U)
N#define CAN_F7R1_FB12_Msk      (0x1UL << CAN_F7R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F7R1_FB12          CAN_F7R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F7R1_FB13_Pos      (13U)
N#define CAN_F7R1_FB13_Msk      (0x1UL << CAN_F7R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F7R1_FB13          CAN_F7R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F7R1_FB14_Pos      (14U)
N#define CAN_F7R1_FB14_Msk      (0x1UL << CAN_F7R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F7R1_FB14          CAN_F7R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F7R1_FB15_Pos      (15U)
N#define CAN_F7R1_FB15_Msk      (0x1UL << CAN_F7R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F7R1_FB15          CAN_F7R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F7R1_FB16_Pos      (16U)
N#define CAN_F7R1_FB16_Msk      (0x1UL << CAN_F7R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F7R1_FB16          CAN_F7R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F7R1_FB17_Pos      (17U)
N#define CAN_F7R1_FB17_Msk      (0x1UL << CAN_F7R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F7R1_FB17          CAN_F7R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F7R1_FB18_Pos      (18U)
N#define CAN_F7R1_FB18_Msk      (0x1UL << CAN_F7R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F7R1_FB18          CAN_F7R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F7R1_FB19_Pos      (19U)
N#define CAN_F7R1_FB19_Msk      (0x1UL << CAN_F7R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F7R1_FB19          CAN_F7R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F7R1_FB20_Pos      (20U)
N#define CAN_F7R1_FB20_Msk      (0x1UL << CAN_F7R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F7R1_FB20          CAN_F7R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F7R1_FB21_Pos      (21U)
N#define CAN_F7R1_FB21_Msk      (0x1UL << CAN_F7R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F7R1_FB21          CAN_F7R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F7R1_FB22_Pos      (22U)
N#define CAN_F7R1_FB22_Msk      (0x1UL << CAN_F7R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F7R1_FB22          CAN_F7R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F7R1_FB23_Pos      (23U)
N#define CAN_F7R1_FB23_Msk      (0x1UL << CAN_F7R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F7R1_FB23          CAN_F7R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F7R1_FB24_Pos      (24U)
N#define CAN_F7R1_FB24_Msk      (0x1UL << CAN_F7R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F7R1_FB24          CAN_F7R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F7R1_FB25_Pos      (25U)
N#define CAN_F7R1_FB25_Msk      (0x1UL << CAN_F7R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F7R1_FB25          CAN_F7R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F7R1_FB26_Pos      (26U)
N#define CAN_F7R1_FB26_Msk      (0x1UL << CAN_F7R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F7R1_FB26          CAN_F7R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F7R1_FB27_Pos      (27U)
N#define CAN_F7R1_FB27_Msk      (0x1UL << CAN_F7R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F7R1_FB27          CAN_F7R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F7R1_FB28_Pos      (28U)
N#define CAN_F7R1_FB28_Msk      (0x1UL << CAN_F7R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F7R1_FB28          CAN_F7R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F7R1_FB29_Pos      (29U)
N#define CAN_F7R1_FB29_Msk      (0x1UL << CAN_F7R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F7R1_FB29          CAN_F7R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F7R1_FB30_Pos      (30U)
N#define CAN_F7R1_FB30_Msk      (0x1UL << CAN_F7R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F7R1_FB30          CAN_F7R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F7R1_FB31_Pos      (31U)
N#define CAN_F7R1_FB31_Msk      (0x1UL << CAN_F7R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F7R1_FB31          CAN_F7R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define CAN_F8R1_FB0_Pos       (0U)
N#define CAN_F8R1_FB0_Msk       (0x1UL << CAN_F8R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F8R1_FB0           CAN_F8R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F8R1_FB1_Pos       (1U)
N#define CAN_F8R1_FB1_Msk       (0x1UL << CAN_F8R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F8R1_FB1           CAN_F8R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F8R1_FB2_Pos       (2U)
N#define CAN_F8R1_FB2_Msk       (0x1UL << CAN_F8R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F8R1_FB2           CAN_F8R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F8R1_FB3_Pos       (3U)
N#define CAN_F8R1_FB3_Msk       (0x1UL << CAN_F8R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F8R1_FB3           CAN_F8R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F8R1_FB4_Pos       (4U)
N#define CAN_F8R1_FB4_Msk       (0x1UL << CAN_F8R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F8R1_FB4           CAN_F8R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F8R1_FB5_Pos       (5U)
N#define CAN_F8R1_FB5_Msk       (0x1UL << CAN_F8R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F8R1_FB5           CAN_F8R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F8R1_FB6_Pos       (6U)
N#define CAN_F8R1_FB6_Msk       (0x1UL << CAN_F8R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F8R1_FB6           CAN_F8R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F8R1_FB7_Pos       (7U)
N#define CAN_F8R1_FB7_Msk       (0x1UL << CAN_F8R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F8R1_FB7           CAN_F8R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F8R1_FB8_Pos       (8U)
N#define CAN_F8R1_FB8_Msk       (0x1UL << CAN_F8R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F8R1_FB8           CAN_F8R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F8R1_FB9_Pos       (9U)
N#define CAN_F8R1_FB9_Msk       (0x1UL << CAN_F8R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F8R1_FB9           CAN_F8R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F8R1_FB10_Pos      (10U)
N#define CAN_F8R1_FB10_Msk      (0x1UL << CAN_F8R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F8R1_FB10          CAN_F8R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F8R1_FB11_Pos      (11U)
N#define CAN_F8R1_FB11_Msk      (0x1UL << CAN_F8R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F8R1_FB11          CAN_F8R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F8R1_FB12_Pos      (12U)
N#define CAN_F8R1_FB12_Msk      (0x1UL << CAN_F8R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F8R1_FB12          CAN_F8R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F8R1_FB13_Pos      (13U)
N#define CAN_F8R1_FB13_Msk      (0x1UL << CAN_F8R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F8R1_FB13          CAN_F8R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F8R1_FB14_Pos      (14U)
N#define CAN_F8R1_FB14_Msk      (0x1UL << CAN_F8R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F8R1_FB14          CAN_F8R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F8R1_FB15_Pos      (15U)
N#define CAN_F8R1_FB15_Msk      (0x1UL << CAN_F8R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F8R1_FB15          CAN_F8R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F8R1_FB16_Pos      (16U)
N#define CAN_F8R1_FB16_Msk      (0x1UL << CAN_F8R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F8R1_FB16          CAN_F8R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F8R1_FB17_Pos      (17U)
N#define CAN_F8R1_FB17_Msk      (0x1UL << CAN_F8R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F8R1_FB17          CAN_F8R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F8R1_FB18_Pos      (18U)
N#define CAN_F8R1_FB18_Msk      (0x1UL << CAN_F8R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F8R1_FB18          CAN_F8R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F8R1_FB19_Pos      (19U)
N#define CAN_F8R1_FB19_Msk      (0x1UL << CAN_F8R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F8R1_FB19          CAN_F8R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F8R1_FB20_Pos      (20U)
N#define CAN_F8R1_FB20_Msk      (0x1UL << CAN_F8R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F8R1_FB20          CAN_F8R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F8R1_FB21_Pos      (21U)
N#define CAN_F8R1_FB21_Msk      (0x1UL << CAN_F8R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F8R1_FB21          CAN_F8R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F8R1_FB22_Pos      (22U)
N#define CAN_F8R1_FB22_Msk      (0x1UL << CAN_F8R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F8R1_FB22          CAN_F8R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F8R1_FB23_Pos      (23U)
N#define CAN_F8R1_FB23_Msk      (0x1UL << CAN_F8R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F8R1_FB23          CAN_F8R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F8R1_FB24_Pos      (24U)
N#define CAN_F8R1_FB24_Msk      (0x1UL << CAN_F8R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F8R1_FB24          CAN_F8R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F8R1_FB25_Pos      (25U)
N#define CAN_F8R1_FB25_Msk      (0x1UL << CAN_F8R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F8R1_FB25          CAN_F8R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F8R1_FB26_Pos      (26U)
N#define CAN_F8R1_FB26_Msk      (0x1UL << CAN_F8R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F8R1_FB26          CAN_F8R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F8R1_FB27_Pos      (27U)
N#define CAN_F8R1_FB27_Msk      (0x1UL << CAN_F8R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F8R1_FB27          CAN_F8R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F8R1_FB28_Pos      (28U)
N#define CAN_F8R1_FB28_Msk      (0x1UL << CAN_F8R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F8R1_FB28          CAN_F8R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F8R1_FB29_Pos      (29U)
N#define CAN_F8R1_FB29_Msk      (0x1UL << CAN_F8R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F8R1_FB29          CAN_F8R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F8R1_FB30_Pos      (30U)
N#define CAN_F8R1_FB30_Msk      (0x1UL << CAN_F8R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F8R1_FB30          CAN_F8R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F8R1_FB31_Pos      (31U)
N#define CAN_F8R1_FB31_Msk      (0x1UL << CAN_F8R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F8R1_FB31          CAN_F8R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define CAN_F9R1_FB0_Pos       (0U)
N#define CAN_F9R1_FB0_Msk       (0x1UL << CAN_F9R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F9R1_FB0           CAN_F9R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F9R1_FB1_Pos       (1U)
N#define CAN_F9R1_FB1_Msk       (0x1UL << CAN_F9R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F9R1_FB1           CAN_F9R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F9R1_FB2_Pos       (2U)
N#define CAN_F9R1_FB2_Msk       (0x1UL << CAN_F9R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F9R1_FB2           CAN_F9R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F9R1_FB3_Pos       (3U)
N#define CAN_F9R1_FB3_Msk       (0x1UL << CAN_F9R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F9R1_FB3           CAN_F9R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F9R1_FB4_Pos       (4U)
N#define CAN_F9R1_FB4_Msk       (0x1UL << CAN_F9R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F9R1_FB4           CAN_F9R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F9R1_FB5_Pos       (5U)
N#define CAN_F9R1_FB5_Msk       (0x1UL << CAN_F9R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F9R1_FB5           CAN_F9R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F9R1_FB6_Pos       (6U)
N#define CAN_F9R1_FB6_Msk       (0x1UL << CAN_F9R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F9R1_FB6           CAN_F9R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F9R1_FB7_Pos       (7U)
N#define CAN_F9R1_FB7_Msk       (0x1UL << CAN_F9R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F9R1_FB7           CAN_F9R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F9R1_FB8_Pos       (8U)
N#define CAN_F9R1_FB8_Msk       (0x1UL << CAN_F9R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F9R1_FB8           CAN_F9R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F9R1_FB9_Pos       (9U)
N#define CAN_F9R1_FB9_Msk       (0x1UL << CAN_F9R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F9R1_FB9           CAN_F9R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F9R1_FB10_Pos      (10U)
N#define CAN_F9R1_FB10_Msk      (0x1UL << CAN_F9R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F9R1_FB10          CAN_F9R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F9R1_FB11_Pos      (11U)
N#define CAN_F9R1_FB11_Msk      (0x1UL << CAN_F9R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F9R1_FB11          CAN_F9R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F9R1_FB12_Pos      (12U)
N#define CAN_F9R1_FB12_Msk      (0x1UL << CAN_F9R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F9R1_FB12          CAN_F9R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F9R1_FB13_Pos      (13U)
N#define CAN_F9R1_FB13_Msk      (0x1UL << CAN_F9R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F9R1_FB13          CAN_F9R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F9R1_FB14_Pos      (14U)
N#define CAN_F9R1_FB14_Msk      (0x1UL << CAN_F9R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F9R1_FB14          CAN_F9R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F9R1_FB15_Pos      (15U)
N#define CAN_F9R1_FB15_Msk      (0x1UL << CAN_F9R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F9R1_FB15          CAN_F9R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F9R1_FB16_Pos      (16U)
N#define CAN_F9R1_FB16_Msk      (0x1UL << CAN_F9R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F9R1_FB16          CAN_F9R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F9R1_FB17_Pos      (17U)
N#define CAN_F9R1_FB17_Msk      (0x1UL << CAN_F9R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F9R1_FB17          CAN_F9R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F9R1_FB18_Pos      (18U)
N#define CAN_F9R1_FB18_Msk      (0x1UL << CAN_F9R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F9R1_FB18          CAN_F9R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F9R1_FB19_Pos      (19U)
N#define CAN_F9R1_FB19_Msk      (0x1UL << CAN_F9R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F9R1_FB19          CAN_F9R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F9R1_FB20_Pos      (20U)
N#define CAN_F9R1_FB20_Msk      (0x1UL << CAN_F9R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F9R1_FB20          CAN_F9R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F9R1_FB21_Pos      (21U)
N#define CAN_F9R1_FB21_Msk      (0x1UL << CAN_F9R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F9R1_FB21          CAN_F9R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F9R1_FB22_Pos      (22U)
N#define CAN_F9R1_FB22_Msk      (0x1UL << CAN_F9R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F9R1_FB22          CAN_F9R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F9R1_FB23_Pos      (23U)
N#define CAN_F9R1_FB23_Msk      (0x1UL << CAN_F9R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F9R1_FB23          CAN_F9R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F9R1_FB24_Pos      (24U)
N#define CAN_F9R1_FB24_Msk      (0x1UL << CAN_F9R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F9R1_FB24          CAN_F9R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F9R1_FB25_Pos      (25U)
N#define CAN_F9R1_FB25_Msk      (0x1UL << CAN_F9R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F9R1_FB25          CAN_F9R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F9R1_FB26_Pos      (26U)
N#define CAN_F9R1_FB26_Msk      (0x1UL << CAN_F9R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F9R1_FB26          CAN_F9R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F9R1_FB27_Pos      (27U)
N#define CAN_F9R1_FB27_Msk      (0x1UL << CAN_F9R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F9R1_FB27          CAN_F9R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F9R1_FB28_Pos      (28U)
N#define CAN_F9R1_FB28_Msk      (0x1UL << CAN_F9R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F9R1_FB28          CAN_F9R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F9R1_FB29_Pos      (29U)
N#define CAN_F9R1_FB29_Msk      (0x1UL << CAN_F9R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F9R1_FB29          CAN_F9R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F9R1_FB30_Pos      (30U)
N#define CAN_F9R1_FB30_Msk      (0x1UL << CAN_F9R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F9R1_FB30          CAN_F9R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F9R1_FB31_Pos      (31U)
N#define CAN_F9R1_FB31_Msk      (0x1UL << CAN_F9R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F9R1_FB31          CAN_F9R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define CAN_F10R1_FB0_Pos      (0U)
N#define CAN_F10R1_FB0_Msk      (0x1UL << CAN_F10R1_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F10R1_FB0          CAN_F10R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F10R1_FB1_Pos      (1U)
N#define CAN_F10R1_FB1_Msk      (0x1UL << CAN_F10R1_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F10R1_FB1          CAN_F10R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F10R1_FB2_Pos      (2U)
N#define CAN_F10R1_FB2_Msk      (0x1UL << CAN_F10R1_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F10R1_FB2          CAN_F10R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F10R1_FB3_Pos      (3U)
N#define CAN_F10R1_FB3_Msk      (0x1UL << CAN_F10R1_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F10R1_FB3          CAN_F10R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F10R1_FB4_Pos      (4U)
N#define CAN_F10R1_FB4_Msk      (0x1UL << CAN_F10R1_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F10R1_FB4          CAN_F10R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F10R1_FB5_Pos      (5U)
N#define CAN_F10R1_FB5_Msk      (0x1UL << CAN_F10R1_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F10R1_FB5          CAN_F10R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F10R1_FB6_Pos      (6U)
N#define CAN_F10R1_FB6_Msk      (0x1UL << CAN_F10R1_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F10R1_FB6          CAN_F10R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F10R1_FB7_Pos      (7U)
N#define CAN_F10R1_FB7_Msk      (0x1UL << CAN_F10R1_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F10R1_FB7          CAN_F10R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F10R1_FB8_Pos      (8U)
N#define CAN_F10R1_FB8_Msk      (0x1UL << CAN_F10R1_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F10R1_FB8          CAN_F10R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F10R1_FB9_Pos      (9U)
N#define CAN_F10R1_FB9_Msk      (0x1UL << CAN_F10R1_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F10R1_FB9          CAN_F10R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F10R1_FB10_Pos     (10U)
N#define CAN_F10R1_FB10_Msk     (0x1UL << CAN_F10R1_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F10R1_FB10         CAN_F10R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F10R1_FB11_Pos     (11U)
N#define CAN_F10R1_FB11_Msk     (0x1UL << CAN_F10R1_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F10R1_FB11         CAN_F10R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F10R1_FB12_Pos     (12U)
N#define CAN_F10R1_FB12_Msk     (0x1UL << CAN_F10R1_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F10R1_FB12         CAN_F10R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F10R1_FB13_Pos     (13U)
N#define CAN_F10R1_FB13_Msk     (0x1UL << CAN_F10R1_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F10R1_FB13         CAN_F10R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F10R1_FB14_Pos     (14U)
N#define CAN_F10R1_FB14_Msk     (0x1UL << CAN_F10R1_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F10R1_FB14         CAN_F10R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F10R1_FB15_Pos     (15U)
N#define CAN_F10R1_FB15_Msk     (0x1UL << CAN_F10R1_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F10R1_FB15         CAN_F10R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F10R1_FB16_Pos     (16U)
N#define CAN_F10R1_FB16_Msk     (0x1UL << CAN_F10R1_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F10R1_FB16         CAN_F10R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F10R1_FB17_Pos     (17U)
N#define CAN_F10R1_FB17_Msk     (0x1UL << CAN_F10R1_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F10R1_FB17         CAN_F10R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F10R1_FB18_Pos     (18U)
N#define CAN_F10R1_FB18_Msk     (0x1UL << CAN_F10R1_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F10R1_FB18         CAN_F10R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F10R1_FB19_Pos     (19U)
N#define CAN_F10R1_FB19_Msk     (0x1UL << CAN_F10R1_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F10R1_FB19         CAN_F10R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F10R1_FB20_Pos     (20U)
N#define CAN_F10R1_FB20_Msk     (0x1UL << CAN_F10R1_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F10R1_FB20         CAN_F10R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F10R1_FB21_Pos     (21U)
N#define CAN_F10R1_FB21_Msk     (0x1UL << CAN_F10R1_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F10R1_FB21         CAN_F10R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F10R1_FB22_Pos     (22U)
N#define CAN_F10R1_FB22_Msk     (0x1UL << CAN_F10R1_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F10R1_FB22         CAN_F10R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F10R1_FB23_Pos     (23U)
N#define CAN_F10R1_FB23_Msk     (0x1UL << CAN_F10R1_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F10R1_FB23         CAN_F10R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F10R1_FB24_Pos     (24U)
N#define CAN_F10R1_FB24_Msk     (0x1UL << CAN_F10R1_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F10R1_FB24         CAN_F10R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F10R1_FB25_Pos     (25U)
N#define CAN_F10R1_FB25_Msk     (0x1UL << CAN_F10R1_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F10R1_FB25         CAN_F10R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F10R1_FB26_Pos     (26U)
N#define CAN_F10R1_FB26_Msk     (0x1UL << CAN_F10R1_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F10R1_FB26         CAN_F10R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F10R1_FB27_Pos     (27U)
N#define CAN_F10R1_FB27_Msk     (0x1UL << CAN_F10R1_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F10R1_FB27         CAN_F10R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F10R1_FB28_Pos     (28U)
N#define CAN_F10R1_FB28_Msk     (0x1UL << CAN_F10R1_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F10R1_FB28         CAN_F10R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F10R1_FB29_Pos     (29U)
N#define CAN_F10R1_FB29_Msk     (0x1UL << CAN_F10R1_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F10R1_FB29         CAN_F10R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F10R1_FB30_Pos     (30U)
N#define CAN_F10R1_FB30_Msk     (0x1UL << CAN_F10R1_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F10R1_FB30         CAN_F10R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F10R1_FB31_Pos     (31U)
N#define CAN_F10R1_FB31_Msk     (0x1UL << CAN_F10R1_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F10R1_FB31         CAN_F10R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define CAN_F11R1_FB0_Pos      (0U)
N#define CAN_F11R1_FB0_Msk      (0x1UL << CAN_F11R1_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F11R1_FB0          CAN_F11R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F11R1_FB1_Pos      (1U)
N#define CAN_F11R1_FB1_Msk      (0x1UL << CAN_F11R1_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F11R1_FB1          CAN_F11R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F11R1_FB2_Pos      (2U)
N#define CAN_F11R1_FB2_Msk      (0x1UL << CAN_F11R1_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F11R1_FB2          CAN_F11R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F11R1_FB3_Pos      (3U)
N#define CAN_F11R1_FB3_Msk      (0x1UL << CAN_F11R1_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F11R1_FB3          CAN_F11R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F11R1_FB4_Pos      (4U)
N#define CAN_F11R1_FB4_Msk      (0x1UL << CAN_F11R1_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F11R1_FB4          CAN_F11R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F11R1_FB5_Pos      (5U)
N#define CAN_F11R1_FB5_Msk      (0x1UL << CAN_F11R1_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F11R1_FB5          CAN_F11R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F11R1_FB6_Pos      (6U)
N#define CAN_F11R1_FB6_Msk      (0x1UL << CAN_F11R1_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F11R1_FB6          CAN_F11R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F11R1_FB7_Pos      (7U)
N#define CAN_F11R1_FB7_Msk      (0x1UL << CAN_F11R1_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F11R1_FB7          CAN_F11R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F11R1_FB8_Pos      (8U)
N#define CAN_F11R1_FB8_Msk      (0x1UL << CAN_F11R1_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F11R1_FB8          CAN_F11R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F11R1_FB9_Pos      (9U)
N#define CAN_F11R1_FB9_Msk      (0x1UL << CAN_F11R1_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F11R1_FB9          CAN_F11R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F11R1_FB10_Pos     (10U)
N#define CAN_F11R1_FB10_Msk     (0x1UL << CAN_F11R1_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F11R1_FB10         CAN_F11R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F11R1_FB11_Pos     (11U)
N#define CAN_F11R1_FB11_Msk     (0x1UL << CAN_F11R1_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F11R1_FB11         CAN_F11R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F11R1_FB12_Pos     (12U)
N#define CAN_F11R1_FB12_Msk     (0x1UL << CAN_F11R1_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F11R1_FB12         CAN_F11R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F11R1_FB13_Pos     (13U)
N#define CAN_F11R1_FB13_Msk     (0x1UL << CAN_F11R1_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F11R1_FB13         CAN_F11R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F11R1_FB14_Pos     (14U)
N#define CAN_F11R1_FB14_Msk     (0x1UL << CAN_F11R1_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F11R1_FB14         CAN_F11R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F11R1_FB15_Pos     (15U)
N#define CAN_F11R1_FB15_Msk     (0x1UL << CAN_F11R1_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F11R1_FB15         CAN_F11R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F11R1_FB16_Pos     (16U)
N#define CAN_F11R1_FB16_Msk     (0x1UL << CAN_F11R1_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F11R1_FB16         CAN_F11R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F11R1_FB17_Pos     (17U)
N#define CAN_F11R1_FB17_Msk     (0x1UL << CAN_F11R1_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F11R1_FB17         CAN_F11R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F11R1_FB18_Pos     (18U)
N#define CAN_F11R1_FB18_Msk     (0x1UL << CAN_F11R1_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F11R1_FB18         CAN_F11R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F11R1_FB19_Pos     (19U)
N#define CAN_F11R1_FB19_Msk     (0x1UL << CAN_F11R1_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F11R1_FB19         CAN_F11R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F11R1_FB20_Pos     (20U)
N#define CAN_F11R1_FB20_Msk     (0x1UL << CAN_F11R1_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F11R1_FB20         CAN_F11R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F11R1_FB21_Pos     (21U)
N#define CAN_F11R1_FB21_Msk     (0x1UL << CAN_F11R1_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F11R1_FB21         CAN_F11R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F11R1_FB22_Pos     (22U)
N#define CAN_F11R1_FB22_Msk     (0x1UL << CAN_F11R1_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F11R1_FB22         CAN_F11R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F11R1_FB23_Pos     (23U)
N#define CAN_F11R1_FB23_Msk     (0x1UL << CAN_F11R1_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F11R1_FB23         CAN_F11R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F11R1_FB24_Pos     (24U)
N#define CAN_F11R1_FB24_Msk     (0x1UL << CAN_F11R1_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F11R1_FB24         CAN_F11R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F11R1_FB25_Pos     (25U)
N#define CAN_F11R1_FB25_Msk     (0x1UL << CAN_F11R1_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F11R1_FB25         CAN_F11R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F11R1_FB26_Pos     (26U)
N#define CAN_F11R1_FB26_Msk     (0x1UL << CAN_F11R1_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F11R1_FB26         CAN_F11R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F11R1_FB27_Pos     (27U)
N#define CAN_F11R1_FB27_Msk     (0x1UL << CAN_F11R1_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F11R1_FB27         CAN_F11R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F11R1_FB28_Pos     (28U)
N#define CAN_F11R1_FB28_Msk     (0x1UL << CAN_F11R1_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F11R1_FB28         CAN_F11R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F11R1_FB29_Pos     (29U)
N#define CAN_F11R1_FB29_Msk     (0x1UL << CAN_F11R1_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F11R1_FB29         CAN_F11R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F11R1_FB30_Pos     (30U)
N#define CAN_F11R1_FB30_Msk     (0x1UL << CAN_F11R1_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F11R1_FB30         CAN_F11R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F11R1_FB31_Pos     (31U)
N#define CAN_F11R1_FB31_Msk     (0x1UL << CAN_F11R1_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F11R1_FB31         CAN_F11R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define CAN_F12R1_FB0_Pos      (0U)
N#define CAN_F12R1_FB0_Msk      (0x1UL << CAN_F12R1_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F12R1_FB0          CAN_F12R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F12R1_FB1_Pos      (1U)
N#define CAN_F12R1_FB1_Msk      (0x1UL << CAN_F12R1_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F12R1_FB1          CAN_F12R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F12R1_FB2_Pos      (2U)
N#define CAN_F12R1_FB2_Msk      (0x1UL << CAN_F12R1_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F12R1_FB2          CAN_F12R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F12R1_FB3_Pos      (3U)
N#define CAN_F12R1_FB3_Msk      (0x1UL << CAN_F12R1_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F12R1_FB3          CAN_F12R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F12R1_FB4_Pos      (4U)
N#define CAN_F12R1_FB4_Msk      (0x1UL << CAN_F12R1_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F12R1_FB4          CAN_F12R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F12R1_FB5_Pos      (5U)
N#define CAN_F12R1_FB5_Msk      (0x1UL << CAN_F12R1_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F12R1_FB5          CAN_F12R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F12R1_FB6_Pos      (6U)
N#define CAN_F12R1_FB6_Msk      (0x1UL << CAN_F12R1_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F12R1_FB6          CAN_F12R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F12R1_FB7_Pos      (7U)
N#define CAN_F12R1_FB7_Msk      (0x1UL << CAN_F12R1_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F12R1_FB7          CAN_F12R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F12R1_FB8_Pos      (8U)
N#define CAN_F12R1_FB8_Msk      (0x1UL << CAN_F12R1_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F12R1_FB8          CAN_F12R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F12R1_FB9_Pos      (9U)
N#define CAN_F12R1_FB9_Msk      (0x1UL << CAN_F12R1_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F12R1_FB9          CAN_F12R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F12R1_FB10_Pos     (10U)
N#define CAN_F12R1_FB10_Msk     (0x1UL << CAN_F12R1_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F12R1_FB10         CAN_F12R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F12R1_FB11_Pos     (11U)
N#define CAN_F12R1_FB11_Msk     (0x1UL << CAN_F12R1_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F12R1_FB11         CAN_F12R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F12R1_FB12_Pos     (12U)
N#define CAN_F12R1_FB12_Msk     (0x1UL << CAN_F12R1_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F12R1_FB12         CAN_F12R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F12R1_FB13_Pos     (13U)
N#define CAN_F12R1_FB13_Msk     (0x1UL << CAN_F12R1_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F12R1_FB13         CAN_F12R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F12R1_FB14_Pos     (14U)
N#define CAN_F12R1_FB14_Msk     (0x1UL << CAN_F12R1_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F12R1_FB14         CAN_F12R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F12R1_FB15_Pos     (15U)
N#define CAN_F12R1_FB15_Msk     (0x1UL << CAN_F12R1_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F12R1_FB15         CAN_F12R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F12R1_FB16_Pos     (16U)
N#define CAN_F12R1_FB16_Msk     (0x1UL << CAN_F12R1_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F12R1_FB16         CAN_F12R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F12R1_FB17_Pos     (17U)
N#define CAN_F12R1_FB17_Msk     (0x1UL << CAN_F12R1_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F12R1_FB17         CAN_F12R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F12R1_FB18_Pos     (18U)
N#define CAN_F12R1_FB18_Msk     (0x1UL << CAN_F12R1_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F12R1_FB18         CAN_F12R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F12R1_FB19_Pos     (19U)
N#define CAN_F12R1_FB19_Msk     (0x1UL << CAN_F12R1_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F12R1_FB19         CAN_F12R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F12R1_FB20_Pos     (20U)
N#define CAN_F12R1_FB20_Msk     (0x1UL << CAN_F12R1_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F12R1_FB20         CAN_F12R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F12R1_FB21_Pos     (21U)
N#define CAN_F12R1_FB21_Msk     (0x1UL << CAN_F12R1_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F12R1_FB21         CAN_F12R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F12R1_FB22_Pos     (22U)
N#define CAN_F12R1_FB22_Msk     (0x1UL << CAN_F12R1_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F12R1_FB22         CAN_F12R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F12R1_FB23_Pos     (23U)
N#define CAN_F12R1_FB23_Msk     (0x1UL << CAN_F12R1_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F12R1_FB23         CAN_F12R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F12R1_FB24_Pos     (24U)
N#define CAN_F12R1_FB24_Msk     (0x1UL << CAN_F12R1_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F12R1_FB24         CAN_F12R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F12R1_FB25_Pos     (25U)
N#define CAN_F12R1_FB25_Msk     (0x1UL << CAN_F12R1_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F12R1_FB25         CAN_F12R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F12R1_FB26_Pos     (26U)
N#define CAN_F12R1_FB26_Msk     (0x1UL << CAN_F12R1_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F12R1_FB26         CAN_F12R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F12R1_FB27_Pos     (27U)
N#define CAN_F12R1_FB27_Msk     (0x1UL << CAN_F12R1_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F12R1_FB27         CAN_F12R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F12R1_FB28_Pos     (28U)
N#define CAN_F12R1_FB28_Msk     (0x1UL << CAN_F12R1_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F12R1_FB28         CAN_F12R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F12R1_FB29_Pos     (29U)
N#define CAN_F12R1_FB29_Msk     (0x1UL << CAN_F12R1_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F12R1_FB29         CAN_F12R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F12R1_FB30_Pos     (30U)
N#define CAN_F12R1_FB30_Msk     (0x1UL << CAN_F12R1_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F12R1_FB30         CAN_F12R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F12R1_FB31_Pos     (31U)
N#define CAN_F12R1_FB31_Msk     (0x1UL << CAN_F12R1_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F12R1_FB31         CAN_F12R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define CAN_F13R1_FB0_Pos      (0U)
N#define CAN_F13R1_FB0_Msk      (0x1UL << CAN_F13R1_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F13R1_FB0          CAN_F13R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F13R1_FB1_Pos      (1U)
N#define CAN_F13R1_FB1_Msk      (0x1UL << CAN_F13R1_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F13R1_FB1          CAN_F13R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F13R1_FB2_Pos      (2U)
N#define CAN_F13R1_FB2_Msk      (0x1UL << CAN_F13R1_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F13R1_FB2          CAN_F13R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F13R1_FB3_Pos      (3U)
N#define CAN_F13R1_FB3_Msk      (0x1UL << CAN_F13R1_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F13R1_FB3          CAN_F13R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F13R1_FB4_Pos      (4U)
N#define CAN_F13R1_FB4_Msk      (0x1UL << CAN_F13R1_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F13R1_FB4          CAN_F13R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F13R1_FB5_Pos      (5U)
N#define CAN_F13R1_FB5_Msk      (0x1UL << CAN_F13R1_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F13R1_FB5          CAN_F13R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F13R1_FB6_Pos      (6U)
N#define CAN_F13R1_FB6_Msk      (0x1UL << CAN_F13R1_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F13R1_FB6          CAN_F13R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F13R1_FB7_Pos      (7U)
N#define CAN_F13R1_FB7_Msk      (0x1UL << CAN_F13R1_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F13R1_FB7          CAN_F13R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F13R1_FB8_Pos      (8U)
N#define CAN_F13R1_FB8_Msk      (0x1UL << CAN_F13R1_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F13R1_FB8          CAN_F13R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F13R1_FB9_Pos      (9U)
N#define CAN_F13R1_FB9_Msk      (0x1UL << CAN_F13R1_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F13R1_FB9          CAN_F13R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F13R1_FB10_Pos     (10U)
N#define CAN_F13R1_FB10_Msk     (0x1UL << CAN_F13R1_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F13R1_FB10         CAN_F13R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F13R1_FB11_Pos     (11U)
N#define CAN_F13R1_FB11_Msk     (0x1UL << CAN_F13R1_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F13R1_FB11         CAN_F13R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F13R1_FB12_Pos     (12U)
N#define CAN_F13R1_FB12_Msk     (0x1UL << CAN_F13R1_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F13R1_FB12         CAN_F13R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F13R1_FB13_Pos     (13U)
N#define CAN_F13R1_FB13_Msk     (0x1UL << CAN_F13R1_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F13R1_FB13         CAN_F13R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F13R1_FB14_Pos     (14U)
N#define CAN_F13R1_FB14_Msk     (0x1UL << CAN_F13R1_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F13R1_FB14         CAN_F13R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F13R1_FB15_Pos     (15U)
N#define CAN_F13R1_FB15_Msk     (0x1UL << CAN_F13R1_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F13R1_FB15         CAN_F13R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F13R1_FB16_Pos     (16U)
N#define CAN_F13R1_FB16_Msk     (0x1UL << CAN_F13R1_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F13R1_FB16         CAN_F13R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F13R1_FB17_Pos     (17U)
N#define CAN_F13R1_FB17_Msk     (0x1UL << CAN_F13R1_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F13R1_FB17         CAN_F13R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F13R1_FB18_Pos     (18U)
N#define CAN_F13R1_FB18_Msk     (0x1UL << CAN_F13R1_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F13R1_FB18         CAN_F13R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F13R1_FB19_Pos     (19U)
N#define CAN_F13R1_FB19_Msk     (0x1UL << CAN_F13R1_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F13R1_FB19         CAN_F13R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F13R1_FB20_Pos     (20U)
N#define CAN_F13R1_FB20_Msk     (0x1UL << CAN_F13R1_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F13R1_FB20         CAN_F13R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F13R1_FB21_Pos     (21U)
N#define CAN_F13R1_FB21_Msk     (0x1UL << CAN_F13R1_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F13R1_FB21         CAN_F13R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F13R1_FB22_Pos     (22U)
N#define CAN_F13R1_FB22_Msk     (0x1UL << CAN_F13R1_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F13R1_FB22         CAN_F13R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F13R1_FB23_Pos     (23U)
N#define CAN_F13R1_FB23_Msk     (0x1UL << CAN_F13R1_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F13R1_FB23         CAN_F13R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F13R1_FB24_Pos     (24U)
N#define CAN_F13R1_FB24_Msk     (0x1UL << CAN_F13R1_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F13R1_FB24         CAN_F13R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F13R1_FB25_Pos     (25U)
N#define CAN_F13R1_FB25_Msk     (0x1UL << CAN_F13R1_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F13R1_FB25         CAN_F13R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F13R1_FB26_Pos     (26U)
N#define CAN_F13R1_FB26_Msk     (0x1UL << CAN_F13R1_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F13R1_FB26         CAN_F13R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F13R1_FB27_Pos     (27U)
N#define CAN_F13R1_FB27_Msk     (0x1UL << CAN_F13R1_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F13R1_FB27         CAN_F13R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F13R1_FB28_Pos     (28U)
N#define CAN_F13R1_FB28_Msk     (0x1UL << CAN_F13R1_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F13R1_FB28         CAN_F13R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F13R1_FB29_Pos     (29U)
N#define CAN_F13R1_FB29_Msk     (0x1UL << CAN_F13R1_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F13R1_FB29         CAN_F13R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F13R1_FB30_Pos     (30U)
N#define CAN_F13R1_FB30_Msk     (0x1UL << CAN_F13R1_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F13R1_FB30         CAN_F13R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F13R1_FB31_Pos     (31U)
N#define CAN_F13R1_FB31_Msk     (0x1UL << CAN_F13R1_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F13R1_FB31         CAN_F13R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define CAN_F0R2_FB0_Pos       (0U)
N#define CAN_F0R2_FB0_Msk       (0x1UL << CAN_F0R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F0R2_FB0           CAN_F0R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F0R2_FB1_Pos       (1U)
N#define CAN_F0R2_FB1_Msk       (0x1UL << CAN_F0R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F0R2_FB1           CAN_F0R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F0R2_FB2_Pos       (2U)
N#define CAN_F0R2_FB2_Msk       (0x1UL << CAN_F0R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F0R2_FB2           CAN_F0R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F0R2_FB3_Pos       (3U)
N#define CAN_F0R2_FB3_Msk       (0x1UL << CAN_F0R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F0R2_FB3           CAN_F0R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F0R2_FB4_Pos       (4U)
N#define CAN_F0R2_FB4_Msk       (0x1UL << CAN_F0R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F0R2_FB4           CAN_F0R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F0R2_FB5_Pos       (5U)
N#define CAN_F0R2_FB5_Msk       (0x1UL << CAN_F0R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F0R2_FB5           CAN_F0R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F0R2_FB6_Pos       (6U)
N#define CAN_F0R2_FB6_Msk       (0x1UL << CAN_F0R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F0R2_FB6           CAN_F0R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F0R2_FB7_Pos       (7U)
N#define CAN_F0R2_FB7_Msk       (0x1UL << CAN_F0R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F0R2_FB7           CAN_F0R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F0R2_FB8_Pos       (8U)
N#define CAN_F0R2_FB8_Msk       (0x1UL << CAN_F0R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F0R2_FB8           CAN_F0R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F0R2_FB9_Pos       (9U)
N#define CAN_F0R2_FB9_Msk       (0x1UL << CAN_F0R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F0R2_FB9           CAN_F0R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F0R2_FB10_Pos      (10U)
N#define CAN_F0R2_FB10_Msk      (0x1UL << CAN_F0R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F0R2_FB10          CAN_F0R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F0R2_FB11_Pos      (11U)
N#define CAN_F0R2_FB11_Msk      (0x1UL << CAN_F0R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F0R2_FB11          CAN_F0R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F0R2_FB12_Pos      (12U)
N#define CAN_F0R2_FB12_Msk      (0x1UL << CAN_F0R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F0R2_FB12          CAN_F0R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F0R2_FB13_Pos      (13U)
N#define CAN_F0R2_FB13_Msk      (0x1UL << CAN_F0R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F0R2_FB13          CAN_F0R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F0R2_FB14_Pos      (14U)
N#define CAN_F0R2_FB14_Msk      (0x1UL << CAN_F0R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F0R2_FB14          CAN_F0R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F0R2_FB15_Pos      (15U)
N#define CAN_F0R2_FB15_Msk      (0x1UL << CAN_F0R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F0R2_FB15          CAN_F0R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F0R2_FB16_Pos      (16U)
N#define CAN_F0R2_FB16_Msk      (0x1UL << CAN_F0R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F0R2_FB16          CAN_F0R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F0R2_FB17_Pos      (17U)
N#define CAN_F0R2_FB17_Msk      (0x1UL << CAN_F0R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F0R2_FB17          CAN_F0R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F0R2_FB18_Pos      (18U)
N#define CAN_F0R2_FB18_Msk      (0x1UL << CAN_F0R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F0R2_FB18          CAN_F0R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F0R2_FB19_Pos      (19U)
N#define CAN_F0R2_FB19_Msk      (0x1UL << CAN_F0R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F0R2_FB19          CAN_F0R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F0R2_FB20_Pos      (20U)
N#define CAN_F0R2_FB20_Msk      (0x1UL << CAN_F0R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F0R2_FB20          CAN_F0R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F0R2_FB21_Pos      (21U)
N#define CAN_F0R2_FB21_Msk      (0x1UL << CAN_F0R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F0R2_FB21          CAN_F0R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F0R2_FB22_Pos      (22U)
N#define CAN_F0R2_FB22_Msk      (0x1UL << CAN_F0R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F0R2_FB22          CAN_F0R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F0R2_FB23_Pos      (23U)
N#define CAN_F0R2_FB23_Msk      (0x1UL << CAN_F0R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F0R2_FB23          CAN_F0R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F0R2_FB24_Pos      (24U)
N#define CAN_F0R2_FB24_Msk      (0x1UL << CAN_F0R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F0R2_FB24          CAN_F0R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F0R2_FB25_Pos      (25U)
N#define CAN_F0R2_FB25_Msk      (0x1UL << CAN_F0R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F0R2_FB25          CAN_F0R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F0R2_FB26_Pos      (26U)
N#define CAN_F0R2_FB26_Msk      (0x1UL << CAN_F0R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F0R2_FB26          CAN_F0R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F0R2_FB27_Pos      (27U)
N#define CAN_F0R2_FB27_Msk      (0x1UL << CAN_F0R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F0R2_FB27          CAN_F0R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F0R2_FB28_Pos      (28U)
N#define CAN_F0R2_FB28_Msk      (0x1UL << CAN_F0R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F0R2_FB28          CAN_F0R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F0R2_FB29_Pos      (29U)
N#define CAN_F0R2_FB29_Msk      (0x1UL << CAN_F0R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F0R2_FB29          CAN_F0R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F0R2_FB30_Pos      (30U)
N#define CAN_F0R2_FB30_Msk      (0x1UL << CAN_F0R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F0R2_FB30          CAN_F0R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F0R2_FB31_Pos      (31U)
N#define CAN_F0R2_FB31_Msk      (0x1UL << CAN_F0R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F0R2_FB31          CAN_F0R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define CAN_F1R2_FB0_Pos       (0U)
N#define CAN_F1R2_FB0_Msk       (0x1UL << CAN_F1R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F1R2_FB0           CAN_F1R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F1R2_FB1_Pos       (1U)
N#define CAN_F1R2_FB1_Msk       (0x1UL << CAN_F1R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F1R2_FB1           CAN_F1R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F1R2_FB2_Pos       (2U)
N#define CAN_F1R2_FB2_Msk       (0x1UL << CAN_F1R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F1R2_FB2           CAN_F1R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F1R2_FB3_Pos       (3U)
N#define CAN_F1R2_FB3_Msk       (0x1UL << CAN_F1R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F1R2_FB3           CAN_F1R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F1R2_FB4_Pos       (4U)
N#define CAN_F1R2_FB4_Msk       (0x1UL << CAN_F1R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F1R2_FB4           CAN_F1R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F1R2_FB5_Pos       (5U)
N#define CAN_F1R2_FB5_Msk       (0x1UL << CAN_F1R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F1R2_FB5           CAN_F1R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F1R2_FB6_Pos       (6U)
N#define CAN_F1R2_FB6_Msk       (0x1UL << CAN_F1R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F1R2_FB6           CAN_F1R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F1R2_FB7_Pos       (7U)
N#define CAN_F1R2_FB7_Msk       (0x1UL << CAN_F1R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F1R2_FB7           CAN_F1R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F1R2_FB8_Pos       (8U)
N#define CAN_F1R2_FB8_Msk       (0x1UL << CAN_F1R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F1R2_FB8           CAN_F1R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F1R2_FB9_Pos       (9U)
N#define CAN_F1R2_FB9_Msk       (0x1UL << CAN_F1R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F1R2_FB9           CAN_F1R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F1R2_FB10_Pos      (10U)
N#define CAN_F1R2_FB10_Msk      (0x1UL << CAN_F1R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F1R2_FB10          CAN_F1R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F1R2_FB11_Pos      (11U)
N#define CAN_F1R2_FB11_Msk      (0x1UL << CAN_F1R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F1R2_FB11          CAN_F1R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F1R2_FB12_Pos      (12U)
N#define CAN_F1R2_FB12_Msk      (0x1UL << CAN_F1R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F1R2_FB12          CAN_F1R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F1R2_FB13_Pos      (13U)
N#define CAN_F1R2_FB13_Msk      (0x1UL << CAN_F1R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F1R2_FB13          CAN_F1R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F1R2_FB14_Pos      (14U)
N#define CAN_F1R2_FB14_Msk      (0x1UL << CAN_F1R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F1R2_FB14          CAN_F1R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F1R2_FB15_Pos      (15U)
N#define CAN_F1R2_FB15_Msk      (0x1UL << CAN_F1R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F1R2_FB15          CAN_F1R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F1R2_FB16_Pos      (16U)
N#define CAN_F1R2_FB16_Msk      (0x1UL << CAN_F1R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F1R2_FB16          CAN_F1R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F1R2_FB17_Pos      (17U)
N#define CAN_F1R2_FB17_Msk      (0x1UL << CAN_F1R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F1R2_FB17          CAN_F1R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F1R2_FB18_Pos      (18U)
N#define CAN_F1R2_FB18_Msk      (0x1UL << CAN_F1R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F1R2_FB18          CAN_F1R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F1R2_FB19_Pos      (19U)
N#define CAN_F1R2_FB19_Msk      (0x1UL << CAN_F1R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F1R2_FB19          CAN_F1R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F1R2_FB20_Pos      (20U)
N#define CAN_F1R2_FB20_Msk      (0x1UL << CAN_F1R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F1R2_FB20          CAN_F1R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F1R2_FB21_Pos      (21U)
N#define CAN_F1R2_FB21_Msk      (0x1UL << CAN_F1R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F1R2_FB21          CAN_F1R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F1R2_FB22_Pos      (22U)
N#define CAN_F1R2_FB22_Msk      (0x1UL << CAN_F1R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F1R2_FB22          CAN_F1R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F1R2_FB23_Pos      (23U)
N#define CAN_F1R2_FB23_Msk      (0x1UL << CAN_F1R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F1R2_FB23          CAN_F1R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F1R2_FB24_Pos      (24U)
N#define CAN_F1R2_FB24_Msk      (0x1UL << CAN_F1R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F1R2_FB24          CAN_F1R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F1R2_FB25_Pos      (25U)
N#define CAN_F1R2_FB25_Msk      (0x1UL << CAN_F1R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F1R2_FB25          CAN_F1R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F1R2_FB26_Pos      (26U)
N#define CAN_F1R2_FB26_Msk      (0x1UL << CAN_F1R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F1R2_FB26          CAN_F1R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F1R2_FB27_Pos      (27U)
N#define CAN_F1R2_FB27_Msk      (0x1UL << CAN_F1R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F1R2_FB27          CAN_F1R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F1R2_FB28_Pos      (28U)
N#define CAN_F1R2_FB28_Msk      (0x1UL << CAN_F1R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F1R2_FB28          CAN_F1R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F1R2_FB29_Pos      (29U)
N#define CAN_F1R2_FB29_Msk      (0x1UL << CAN_F1R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F1R2_FB29          CAN_F1R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F1R2_FB30_Pos      (30U)
N#define CAN_F1R2_FB30_Msk      (0x1UL << CAN_F1R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F1R2_FB30          CAN_F1R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F1R2_FB31_Pos      (31U)
N#define CAN_F1R2_FB31_Msk      (0x1UL << CAN_F1R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F1R2_FB31          CAN_F1R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define CAN_F2R2_FB0_Pos       (0U)
N#define CAN_F2R2_FB0_Msk       (0x1UL << CAN_F2R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F2R2_FB0           CAN_F2R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F2R2_FB1_Pos       (1U)
N#define CAN_F2R2_FB1_Msk       (0x1UL << CAN_F2R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F2R2_FB1           CAN_F2R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F2R2_FB2_Pos       (2U)
N#define CAN_F2R2_FB2_Msk       (0x1UL << CAN_F2R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F2R2_FB2           CAN_F2R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F2R2_FB3_Pos       (3U)
N#define CAN_F2R2_FB3_Msk       (0x1UL << CAN_F2R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F2R2_FB3           CAN_F2R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F2R2_FB4_Pos       (4U)
N#define CAN_F2R2_FB4_Msk       (0x1UL << CAN_F2R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F2R2_FB4           CAN_F2R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F2R2_FB5_Pos       (5U)
N#define CAN_F2R2_FB5_Msk       (0x1UL << CAN_F2R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F2R2_FB5           CAN_F2R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F2R2_FB6_Pos       (6U)
N#define CAN_F2R2_FB6_Msk       (0x1UL << CAN_F2R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F2R2_FB6           CAN_F2R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F2R2_FB7_Pos       (7U)
N#define CAN_F2R2_FB7_Msk       (0x1UL << CAN_F2R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F2R2_FB7           CAN_F2R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F2R2_FB8_Pos       (8U)
N#define CAN_F2R2_FB8_Msk       (0x1UL << CAN_F2R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F2R2_FB8           CAN_F2R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F2R2_FB9_Pos       (9U)
N#define CAN_F2R2_FB9_Msk       (0x1UL << CAN_F2R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F2R2_FB9           CAN_F2R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F2R2_FB10_Pos      (10U)
N#define CAN_F2R2_FB10_Msk      (0x1UL << CAN_F2R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F2R2_FB10          CAN_F2R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F2R2_FB11_Pos      (11U)
N#define CAN_F2R2_FB11_Msk      (0x1UL << CAN_F2R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F2R2_FB11          CAN_F2R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F2R2_FB12_Pos      (12U)
N#define CAN_F2R2_FB12_Msk      (0x1UL << CAN_F2R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F2R2_FB12          CAN_F2R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F2R2_FB13_Pos      (13U)
N#define CAN_F2R2_FB13_Msk      (0x1UL << CAN_F2R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F2R2_FB13          CAN_F2R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F2R2_FB14_Pos      (14U)
N#define CAN_F2R2_FB14_Msk      (0x1UL << CAN_F2R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F2R2_FB14          CAN_F2R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F2R2_FB15_Pos      (15U)
N#define CAN_F2R2_FB15_Msk      (0x1UL << CAN_F2R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F2R2_FB15          CAN_F2R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F2R2_FB16_Pos      (16U)
N#define CAN_F2R2_FB16_Msk      (0x1UL << CAN_F2R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F2R2_FB16          CAN_F2R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F2R2_FB17_Pos      (17U)
N#define CAN_F2R2_FB17_Msk      (0x1UL << CAN_F2R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F2R2_FB17          CAN_F2R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F2R2_FB18_Pos      (18U)
N#define CAN_F2R2_FB18_Msk      (0x1UL << CAN_F2R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F2R2_FB18          CAN_F2R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F2R2_FB19_Pos      (19U)
N#define CAN_F2R2_FB19_Msk      (0x1UL << CAN_F2R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F2R2_FB19          CAN_F2R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F2R2_FB20_Pos      (20U)
N#define CAN_F2R2_FB20_Msk      (0x1UL << CAN_F2R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F2R2_FB20          CAN_F2R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F2R2_FB21_Pos      (21U)
N#define CAN_F2R2_FB21_Msk      (0x1UL << CAN_F2R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F2R2_FB21          CAN_F2R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F2R2_FB22_Pos      (22U)
N#define CAN_F2R2_FB22_Msk      (0x1UL << CAN_F2R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F2R2_FB22          CAN_F2R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F2R2_FB23_Pos      (23U)
N#define CAN_F2R2_FB23_Msk      (0x1UL << CAN_F2R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F2R2_FB23          CAN_F2R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F2R2_FB24_Pos      (24U)
N#define CAN_F2R2_FB24_Msk      (0x1UL << CAN_F2R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F2R2_FB24          CAN_F2R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F2R2_FB25_Pos      (25U)
N#define CAN_F2R2_FB25_Msk      (0x1UL << CAN_F2R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F2R2_FB25          CAN_F2R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F2R2_FB26_Pos      (26U)
N#define CAN_F2R2_FB26_Msk      (0x1UL << CAN_F2R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F2R2_FB26          CAN_F2R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F2R2_FB27_Pos      (27U)
N#define CAN_F2R2_FB27_Msk      (0x1UL << CAN_F2R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F2R2_FB27          CAN_F2R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F2R2_FB28_Pos      (28U)
N#define CAN_F2R2_FB28_Msk      (0x1UL << CAN_F2R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F2R2_FB28          CAN_F2R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F2R2_FB29_Pos      (29U)
N#define CAN_F2R2_FB29_Msk      (0x1UL << CAN_F2R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F2R2_FB29          CAN_F2R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F2R2_FB30_Pos      (30U)
N#define CAN_F2R2_FB30_Msk      (0x1UL << CAN_F2R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F2R2_FB30          CAN_F2R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F2R2_FB31_Pos      (31U)
N#define CAN_F2R2_FB31_Msk      (0x1UL << CAN_F2R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F2R2_FB31          CAN_F2R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define CAN_F3R2_FB0_Pos       (0U)
N#define CAN_F3R2_FB0_Msk       (0x1UL << CAN_F3R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F3R2_FB0           CAN_F3R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F3R2_FB1_Pos       (1U)
N#define CAN_F3R2_FB1_Msk       (0x1UL << CAN_F3R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F3R2_FB1           CAN_F3R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F3R2_FB2_Pos       (2U)
N#define CAN_F3R2_FB2_Msk       (0x1UL << CAN_F3R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F3R2_FB2           CAN_F3R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F3R2_FB3_Pos       (3U)
N#define CAN_F3R2_FB3_Msk       (0x1UL << CAN_F3R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F3R2_FB3           CAN_F3R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F3R2_FB4_Pos       (4U)
N#define CAN_F3R2_FB4_Msk       (0x1UL << CAN_F3R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F3R2_FB4           CAN_F3R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F3R2_FB5_Pos       (5U)
N#define CAN_F3R2_FB5_Msk       (0x1UL << CAN_F3R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F3R2_FB5           CAN_F3R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F3R2_FB6_Pos       (6U)
N#define CAN_F3R2_FB6_Msk       (0x1UL << CAN_F3R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F3R2_FB6           CAN_F3R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F3R2_FB7_Pos       (7U)
N#define CAN_F3R2_FB7_Msk       (0x1UL << CAN_F3R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F3R2_FB7           CAN_F3R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F3R2_FB8_Pos       (8U)
N#define CAN_F3R2_FB8_Msk       (0x1UL << CAN_F3R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F3R2_FB8           CAN_F3R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F3R2_FB9_Pos       (9U)
N#define CAN_F3R2_FB9_Msk       (0x1UL << CAN_F3R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F3R2_FB9           CAN_F3R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F3R2_FB10_Pos      (10U)
N#define CAN_F3R2_FB10_Msk      (0x1UL << CAN_F3R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F3R2_FB10          CAN_F3R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F3R2_FB11_Pos      (11U)
N#define CAN_F3R2_FB11_Msk      (0x1UL << CAN_F3R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F3R2_FB11          CAN_F3R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F3R2_FB12_Pos      (12U)
N#define CAN_F3R2_FB12_Msk      (0x1UL << CAN_F3R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F3R2_FB12          CAN_F3R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F3R2_FB13_Pos      (13U)
N#define CAN_F3R2_FB13_Msk      (0x1UL << CAN_F3R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F3R2_FB13          CAN_F3R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F3R2_FB14_Pos      (14U)
N#define CAN_F3R2_FB14_Msk      (0x1UL << CAN_F3R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F3R2_FB14          CAN_F3R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F3R2_FB15_Pos      (15U)
N#define CAN_F3R2_FB15_Msk      (0x1UL << CAN_F3R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F3R2_FB15          CAN_F3R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F3R2_FB16_Pos      (16U)
N#define CAN_F3R2_FB16_Msk      (0x1UL << CAN_F3R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F3R2_FB16          CAN_F3R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F3R2_FB17_Pos      (17U)
N#define CAN_F3R2_FB17_Msk      (0x1UL << CAN_F3R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F3R2_FB17          CAN_F3R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F3R2_FB18_Pos      (18U)
N#define CAN_F3R2_FB18_Msk      (0x1UL << CAN_F3R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F3R2_FB18          CAN_F3R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F3R2_FB19_Pos      (19U)
N#define CAN_F3R2_FB19_Msk      (0x1UL << CAN_F3R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F3R2_FB19          CAN_F3R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F3R2_FB20_Pos      (20U)
N#define CAN_F3R2_FB20_Msk      (0x1UL << CAN_F3R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F3R2_FB20          CAN_F3R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F3R2_FB21_Pos      (21U)
N#define CAN_F3R2_FB21_Msk      (0x1UL << CAN_F3R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F3R2_FB21          CAN_F3R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F3R2_FB22_Pos      (22U)
N#define CAN_F3R2_FB22_Msk      (0x1UL << CAN_F3R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F3R2_FB22          CAN_F3R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F3R2_FB23_Pos      (23U)
N#define CAN_F3R2_FB23_Msk      (0x1UL << CAN_F3R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F3R2_FB23          CAN_F3R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F3R2_FB24_Pos      (24U)
N#define CAN_F3R2_FB24_Msk      (0x1UL << CAN_F3R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F3R2_FB24          CAN_F3R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F3R2_FB25_Pos      (25U)
N#define CAN_F3R2_FB25_Msk      (0x1UL << CAN_F3R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F3R2_FB25          CAN_F3R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F3R2_FB26_Pos      (26U)
N#define CAN_F3R2_FB26_Msk      (0x1UL << CAN_F3R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F3R2_FB26          CAN_F3R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F3R2_FB27_Pos      (27U)
N#define CAN_F3R2_FB27_Msk      (0x1UL << CAN_F3R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F3R2_FB27          CAN_F3R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F3R2_FB28_Pos      (28U)
N#define CAN_F3R2_FB28_Msk      (0x1UL << CAN_F3R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F3R2_FB28          CAN_F3R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F3R2_FB29_Pos      (29U)
N#define CAN_F3R2_FB29_Msk      (0x1UL << CAN_F3R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F3R2_FB29          CAN_F3R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F3R2_FB30_Pos      (30U)
N#define CAN_F3R2_FB30_Msk      (0x1UL << CAN_F3R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F3R2_FB30          CAN_F3R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F3R2_FB31_Pos      (31U)
N#define CAN_F3R2_FB31_Msk      (0x1UL << CAN_F3R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F3R2_FB31          CAN_F3R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define CAN_F4R2_FB0_Pos       (0U)
N#define CAN_F4R2_FB0_Msk       (0x1UL << CAN_F4R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F4R2_FB0           CAN_F4R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F4R2_FB1_Pos       (1U)
N#define CAN_F4R2_FB1_Msk       (0x1UL << CAN_F4R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F4R2_FB1           CAN_F4R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F4R2_FB2_Pos       (2U)
N#define CAN_F4R2_FB2_Msk       (0x1UL << CAN_F4R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F4R2_FB2           CAN_F4R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F4R2_FB3_Pos       (3U)
N#define CAN_F4R2_FB3_Msk       (0x1UL << CAN_F4R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F4R2_FB3           CAN_F4R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F4R2_FB4_Pos       (4U)
N#define CAN_F4R2_FB4_Msk       (0x1UL << CAN_F4R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F4R2_FB4           CAN_F4R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F4R2_FB5_Pos       (5U)
N#define CAN_F4R2_FB5_Msk       (0x1UL << CAN_F4R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F4R2_FB5           CAN_F4R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F4R2_FB6_Pos       (6U)
N#define CAN_F4R2_FB6_Msk       (0x1UL << CAN_F4R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F4R2_FB6           CAN_F4R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F4R2_FB7_Pos       (7U)
N#define CAN_F4R2_FB7_Msk       (0x1UL << CAN_F4R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F4R2_FB7           CAN_F4R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F4R2_FB8_Pos       (8U)
N#define CAN_F4R2_FB8_Msk       (0x1UL << CAN_F4R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F4R2_FB8           CAN_F4R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F4R2_FB9_Pos       (9U)
N#define CAN_F4R2_FB9_Msk       (0x1UL << CAN_F4R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F4R2_FB9           CAN_F4R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F4R2_FB10_Pos      (10U)
N#define CAN_F4R2_FB10_Msk      (0x1UL << CAN_F4R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F4R2_FB10          CAN_F4R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F4R2_FB11_Pos      (11U)
N#define CAN_F4R2_FB11_Msk      (0x1UL << CAN_F4R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F4R2_FB11          CAN_F4R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F4R2_FB12_Pos      (12U)
N#define CAN_F4R2_FB12_Msk      (0x1UL << CAN_F4R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F4R2_FB12          CAN_F4R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F4R2_FB13_Pos      (13U)
N#define CAN_F4R2_FB13_Msk      (0x1UL << CAN_F4R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F4R2_FB13          CAN_F4R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F4R2_FB14_Pos      (14U)
N#define CAN_F4R2_FB14_Msk      (0x1UL << CAN_F4R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F4R2_FB14          CAN_F4R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F4R2_FB15_Pos      (15U)
N#define CAN_F4R2_FB15_Msk      (0x1UL << CAN_F4R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F4R2_FB15          CAN_F4R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F4R2_FB16_Pos      (16U)
N#define CAN_F4R2_FB16_Msk      (0x1UL << CAN_F4R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F4R2_FB16          CAN_F4R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F4R2_FB17_Pos      (17U)
N#define CAN_F4R2_FB17_Msk      (0x1UL << CAN_F4R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F4R2_FB17          CAN_F4R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F4R2_FB18_Pos      (18U)
N#define CAN_F4R2_FB18_Msk      (0x1UL << CAN_F4R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F4R2_FB18          CAN_F4R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F4R2_FB19_Pos      (19U)
N#define CAN_F4R2_FB19_Msk      (0x1UL << CAN_F4R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F4R2_FB19          CAN_F4R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F4R2_FB20_Pos      (20U)
N#define CAN_F4R2_FB20_Msk      (0x1UL << CAN_F4R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F4R2_FB20          CAN_F4R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F4R2_FB21_Pos      (21U)
N#define CAN_F4R2_FB21_Msk      (0x1UL << CAN_F4R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F4R2_FB21          CAN_F4R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F4R2_FB22_Pos      (22U)
N#define CAN_F4R2_FB22_Msk      (0x1UL << CAN_F4R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F4R2_FB22          CAN_F4R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F4R2_FB23_Pos      (23U)
N#define CAN_F4R2_FB23_Msk      (0x1UL << CAN_F4R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F4R2_FB23          CAN_F4R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F4R2_FB24_Pos      (24U)
N#define CAN_F4R2_FB24_Msk      (0x1UL << CAN_F4R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F4R2_FB24          CAN_F4R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F4R2_FB25_Pos      (25U)
N#define CAN_F4R2_FB25_Msk      (0x1UL << CAN_F4R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F4R2_FB25          CAN_F4R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F4R2_FB26_Pos      (26U)
N#define CAN_F4R2_FB26_Msk      (0x1UL << CAN_F4R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F4R2_FB26          CAN_F4R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F4R2_FB27_Pos      (27U)
N#define CAN_F4R2_FB27_Msk      (0x1UL << CAN_F4R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F4R2_FB27          CAN_F4R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F4R2_FB28_Pos      (28U)
N#define CAN_F4R2_FB28_Msk      (0x1UL << CAN_F4R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F4R2_FB28          CAN_F4R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F4R2_FB29_Pos      (29U)
N#define CAN_F4R2_FB29_Msk      (0x1UL << CAN_F4R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F4R2_FB29          CAN_F4R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F4R2_FB30_Pos      (30U)
N#define CAN_F4R2_FB30_Msk      (0x1UL << CAN_F4R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F4R2_FB30          CAN_F4R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F4R2_FB31_Pos      (31U)
N#define CAN_F4R2_FB31_Msk      (0x1UL << CAN_F4R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F4R2_FB31          CAN_F4R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define CAN_F5R2_FB0_Pos       (0U)
N#define CAN_F5R2_FB0_Msk       (0x1UL << CAN_F5R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F5R2_FB0           CAN_F5R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F5R2_FB1_Pos       (1U)
N#define CAN_F5R2_FB1_Msk       (0x1UL << CAN_F5R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F5R2_FB1           CAN_F5R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F5R2_FB2_Pos       (2U)
N#define CAN_F5R2_FB2_Msk       (0x1UL << CAN_F5R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F5R2_FB2           CAN_F5R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F5R2_FB3_Pos       (3U)
N#define CAN_F5R2_FB3_Msk       (0x1UL << CAN_F5R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F5R2_FB3           CAN_F5R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F5R2_FB4_Pos       (4U)
N#define CAN_F5R2_FB4_Msk       (0x1UL << CAN_F5R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F5R2_FB4           CAN_F5R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F5R2_FB5_Pos       (5U)
N#define CAN_F5R2_FB5_Msk       (0x1UL << CAN_F5R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F5R2_FB5           CAN_F5R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F5R2_FB6_Pos       (6U)
N#define CAN_F5R2_FB6_Msk       (0x1UL << CAN_F5R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F5R2_FB6           CAN_F5R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F5R2_FB7_Pos       (7U)
N#define CAN_F5R2_FB7_Msk       (0x1UL << CAN_F5R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F5R2_FB7           CAN_F5R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F5R2_FB8_Pos       (8U)
N#define CAN_F5R2_FB8_Msk       (0x1UL << CAN_F5R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F5R2_FB8           CAN_F5R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F5R2_FB9_Pos       (9U)
N#define CAN_F5R2_FB9_Msk       (0x1UL << CAN_F5R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F5R2_FB9           CAN_F5R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F5R2_FB10_Pos      (10U)
N#define CAN_F5R2_FB10_Msk      (0x1UL << CAN_F5R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F5R2_FB10          CAN_F5R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F5R2_FB11_Pos      (11U)
N#define CAN_F5R2_FB11_Msk      (0x1UL << CAN_F5R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F5R2_FB11          CAN_F5R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F5R2_FB12_Pos      (12U)
N#define CAN_F5R2_FB12_Msk      (0x1UL << CAN_F5R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F5R2_FB12          CAN_F5R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F5R2_FB13_Pos      (13U)
N#define CAN_F5R2_FB13_Msk      (0x1UL << CAN_F5R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F5R2_FB13          CAN_F5R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F5R2_FB14_Pos      (14U)
N#define CAN_F5R2_FB14_Msk      (0x1UL << CAN_F5R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F5R2_FB14          CAN_F5R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F5R2_FB15_Pos      (15U)
N#define CAN_F5R2_FB15_Msk      (0x1UL << CAN_F5R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F5R2_FB15          CAN_F5R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F5R2_FB16_Pos      (16U)
N#define CAN_F5R2_FB16_Msk      (0x1UL << CAN_F5R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F5R2_FB16          CAN_F5R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F5R2_FB17_Pos      (17U)
N#define CAN_F5R2_FB17_Msk      (0x1UL << CAN_F5R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F5R2_FB17          CAN_F5R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F5R2_FB18_Pos      (18U)
N#define CAN_F5R2_FB18_Msk      (0x1UL << CAN_F5R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F5R2_FB18          CAN_F5R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F5R2_FB19_Pos      (19U)
N#define CAN_F5R2_FB19_Msk      (0x1UL << CAN_F5R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F5R2_FB19          CAN_F5R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F5R2_FB20_Pos      (20U)
N#define CAN_F5R2_FB20_Msk      (0x1UL << CAN_F5R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F5R2_FB20          CAN_F5R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F5R2_FB21_Pos      (21U)
N#define CAN_F5R2_FB21_Msk      (0x1UL << CAN_F5R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F5R2_FB21          CAN_F5R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F5R2_FB22_Pos      (22U)
N#define CAN_F5R2_FB22_Msk      (0x1UL << CAN_F5R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F5R2_FB22          CAN_F5R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F5R2_FB23_Pos      (23U)
N#define CAN_F5R2_FB23_Msk      (0x1UL << CAN_F5R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F5R2_FB23          CAN_F5R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F5R2_FB24_Pos      (24U)
N#define CAN_F5R2_FB24_Msk      (0x1UL << CAN_F5R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F5R2_FB24          CAN_F5R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F5R2_FB25_Pos      (25U)
N#define CAN_F5R2_FB25_Msk      (0x1UL << CAN_F5R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F5R2_FB25          CAN_F5R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F5R2_FB26_Pos      (26U)
N#define CAN_F5R2_FB26_Msk      (0x1UL << CAN_F5R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F5R2_FB26          CAN_F5R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F5R2_FB27_Pos      (27U)
N#define CAN_F5R2_FB27_Msk      (0x1UL << CAN_F5R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F5R2_FB27          CAN_F5R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F5R2_FB28_Pos      (28U)
N#define CAN_F5R2_FB28_Msk      (0x1UL << CAN_F5R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F5R2_FB28          CAN_F5R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F5R2_FB29_Pos      (29U)
N#define CAN_F5R2_FB29_Msk      (0x1UL << CAN_F5R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F5R2_FB29          CAN_F5R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F5R2_FB30_Pos      (30U)
N#define CAN_F5R2_FB30_Msk      (0x1UL << CAN_F5R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F5R2_FB30          CAN_F5R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F5R2_FB31_Pos      (31U)
N#define CAN_F5R2_FB31_Msk      (0x1UL << CAN_F5R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F5R2_FB31          CAN_F5R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define CAN_F6R2_FB0_Pos       (0U)
N#define CAN_F6R2_FB0_Msk       (0x1UL << CAN_F6R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F6R2_FB0           CAN_F6R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F6R2_FB1_Pos       (1U)
N#define CAN_F6R2_FB1_Msk       (0x1UL << CAN_F6R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F6R2_FB1           CAN_F6R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F6R2_FB2_Pos       (2U)
N#define CAN_F6R2_FB2_Msk       (0x1UL << CAN_F6R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F6R2_FB2           CAN_F6R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F6R2_FB3_Pos       (3U)
N#define CAN_F6R2_FB3_Msk       (0x1UL << CAN_F6R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F6R2_FB3           CAN_F6R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F6R2_FB4_Pos       (4U)
N#define CAN_F6R2_FB4_Msk       (0x1UL << CAN_F6R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F6R2_FB4           CAN_F6R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F6R2_FB5_Pos       (5U)
N#define CAN_F6R2_FB5_Msk       (0x1UL << CAN_F6R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F6R2_FB5           CAN_F6R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F6R2_FB6_Pos       (6U)
N#define CAN_F6R2_FB6_Msk       (0x1UL << CAN_F6R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F6R2_FB6           CAN_F6R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F6R2_FB7_Pos       (7U)
N#define CAN_F6R2_FB7_Msk       (0x1UL << CAN_F6R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F6R2_FB7           CAN_F6R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F6R2_FB8_Pos       (8U)
N#define CAN_F6R2_FB8_Msk       (0x1UL << CAN_F6R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F6R2_FB8           CAN_F6R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F6R2_FB9_Pos       (9U)
N#define CAN_F6R2_FB9_Msk       (0x1UL << CAN_F6R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F6R2_FB9           CAN_F6R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F6R2_FB10_Pos      (10U)
N#define CAN_F6R2_FB10_Msk      (0x1UL << CAN_F6R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F6R2_FB10          CAN_F6R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F6R2_FB11_Pos      (11U)
N#define CAN_F6R2_FB11_Msk      (0x1UL << CAN_F6R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F6R2_FB11          CAN_F6R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F6R2_FB12_Pos      (12U)
N#define CAN_F6R2_FB12_Msk      (0x1UL << CAN_F6R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F6R2_FB12          CAN_F6R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F6R2_FB13_Pos      (13U)
N#define CAN_F6R2_FB13_Msk      (0x1UL << CAN_F6R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F6R2_FB13          CAN_F6R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F6R2_FB14_Pos      (14U)
N#define CAN_F6R2_FB14_Msk      (0x1UL << CAN_F6R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F6R2_FB14          CAN_F6R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F6R2_FB15_Pos      (15U)
N#define CAN_F6R2_FB15_Msk      (0x1UL << CAN_F6R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F6R2_FB15          CAN_F6R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F6R2_FB16_Pos      (16U)
N#define CAN_F6R2_FB16_Msk      (0x1UL << CAN_F6R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F6R2_FB16          CAN_F6R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F6R2_FB17_Pos      (17U)
N#define CAN_F6R2_FB17_Msk      (0x1UL << CAN_F6R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F6R2_FB17          CAN_F6R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F6R2_FB18_Pos      (18U)
N#define CAN_F6R2_FB18_Msk      (0x1UL << CAN_F6R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F6R2_FB18          CAN_F6R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F6R2_FB19_Pos      (19U)
N#define CAN_F6R2_FB19_Msk      (0x1UL << CAN_F6R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F6R2_FB19          CAN_F6R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F6R2_FB20_Pos      (20U)
N#define CAN_F6R2_FB20_Msk      (0x1UL << CAN_F6R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F6R2_FB20          CAN_F6R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F6R2_FB21_Pos      (21U)
N#define CAN_F6R2_FB21_Msk      (0x1UL << CAN_F6R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F6R2_FB21          CAN_F6R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F6R2_FB22_Pos      (22U)
N#define CAN_F6R2_FB22_Msk      (0x1UL << CAN_F6R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F6R2_FB22          CAN_F6R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F6R2_FB23_Pos      (23U)
N#define CAN_F6R2_FB23_Msk      (0x1UL << CAN_F6R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F6R2_FB23          CAN_F6R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F6R2_FB24_Pos      (24U)
N#define CAN_F6R2_FB24_Msk      (0x1UL << CAN_F6R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F6R2_FB24          CAN_F6R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F6R2_FB25_Pos      (25U)
N#define CAN_F6R2_FB25_Msk      (0x1UL << CAN_F6R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F6R2_FB25          CAN_F6R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F6R2_FB26_Pos      (26U)
N#define CAN_F6R2_FB26_Msk      (0x1UL << CAN_F6R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F6R2_FB26          CAN_F6R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F6R2_FB27_Pos      (27U)
N#define CAN_F6R2_FB27_Msk      (0x1UL << CAN_F6R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F6R2_FB27          CAN_F6R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F6R2_FB28_Pos      (28U)
N#define CAN_F6R2_FB28_Msk      (0x1UL << CAN_F6R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F6R2_FB28          CAN_F6R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F6R2_FB29_Pos      (29U)
N#define CAN_F6R2_FB29_Msk      (0x1UL << CAN_F6R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F6R2_FB29          CAN_F6R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F6R2_FB30_Pos      (30U)
N#define CAN_F6R2_FB30_Msk      (0x1UL << CAN_F6R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F6R2_FB30          CAN_F6R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F6R2_FB31_Pos      (31U)
N#define CAN_F6R2_FB31_Msk      (0x1UL << CAN_F6R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F6R2_FB31          CAN_F6R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define CAN_F7R2_FB0_Pos       (0U)
N#define CAN_F7R2_FB0_Msk       (0x1UL << CAN_F7R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F7R2_FB0           CAN_F7R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F7R2_FB1_Pos       (1U)
N#define CAN_F7R2_FB1_Msk       (0x1UL << CAN_F7R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F7R2_FB1           CAN_F7R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F7R2_FB2_Pos       (2U)
N#define CAN_F7R2_FB2_Msk       (0x1UL << CAN_F7R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F7R2_FB2           CAN_F7R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F7R2_FB3_Pos       (3U)
N#define CAN_F7R2_FB3_Msk       (0x1UL << CAN_F7R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F7R2_FB3           CAN_F7R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F7R2_FB4_Pos       (4U)
N#define CAN_F7R2_FB4_Msk       (0x1UL << CAN_F7R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F7R2_FB4           CAN_F7R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F7R2_FB5_Pos       (5U)
N#define CAN_F7R2_FB5_Msk       (0x1UL << CAN_F7R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F7R2_FB5           CAN_F7R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F7R2_FB6_Pos       (6U)
N#define CAN_F7R2_FB6_Msk       (0x1UL << CAN_F7R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F7R2_FB6           CAN_F7R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F7R2_FB7_Pos       (7U)
N#define CAN_F7R2_FB7_Msk       (0x1UL << CAN_F7R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F7R2_FB7           CAN_F7R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F7R2_FB8_Pos       (8U)
N#define CAN_F7R2_FB8_Msk       (0x1UL << CAN_F7R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F7R2_FB8           CAN_F7R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F7R2_FB9_Pos       (9U)
N#define CAN_F7R2_FB9_Msk       (0x1UL << CAN_F7R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F7R2_FB9           CAN_F7R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F7R2_FB10_Pos      (10U)
N#define CAN_F7R2_FB10_Msk      (0x1UL << CAN_F7R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F7R2_FB10          CAN_F7R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F7R2_FB11_Pos      (11U)
N#define CAN_F7R2_FB11_Msk      (0x1UL << CAN_F7R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F7R2_FB11          CAN_F7R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F7R2_FB12_Pos      (12U)
N#define CAN_F7R2_FB12_Msk      (0x1UL << CAN_F7R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F7R2_FB12          CAN_F7R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F7R2_FB13_Pos      (13U)
N#define CAN_F7R2_FB13_Msk      (0x1UL << CAN_F7R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F7R2_FB13          CAN_F7R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F7R2_FB14_Pos      (14U)
N#define CAN_F7R2_FB14_Msk      (0x1UL << CAN_F7R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F7R2_FB14          CAN_F7R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F7R2_FB15_Pos      (15U)
N#define CAN_F7R2_FB15_Msk      (0x1UL << CAN_F7R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F7R2_FB15          CAN_F7R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F7R2_FB16_Pos      (16U)
N#define CAN_F7R2_FB16_Msk      (0x1UL << CAN_F7R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F7R2_FB16          CAN_F7R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F7R2_FB17_Pos      (17U)
N#define CAN_F7R2_FB17_Msk      (0x1UL << CAN_F7R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F7R2_FB17          CAN_F7R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F7R2_FB18_Pos      (18U)
N#define CAN_F7R2_FB18_Msk      (0x1UL << CAN_F7R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F7R2_FB18          CAN_F7R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F7R2_FB19_Pos      (19U)
N#define CAN_F7R2_FB19_Msk      (0x1UL << CAN_F7R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F7R2_FB19          CAN_F7R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F7R2_FB20_Pos      (20U)
N#define CAN_F7R2_FB20_Msk      (0x1UL << CAN_F7R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F7R2_FB20          CAN_F7R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F7R2_FB21_Pos      (21U)
N#define CAN_F7R2_FB21_Msk      (0x1UL << CAN_F7R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F7R2_FB21          CAN_F7R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F7R2_FB22_Pos      (22U)
N#define CAN_F7R2_FB22_Msk      (0x1UL << CAN_F7R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F7R2_FB22          CAN_F7R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F7R2_FB23_Pos      (23U)
N#define CAN_F7R2_FB23_Msk      (0x1UL << CAN_F7R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F7R2_FB23          CAN_F7R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F7R2_FB24_Pos      (24U)
N#define CAN_F7R2_FB24_Msk      (0x1UL << CAN_F7R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F7R2_FB24          CAN_F7R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F7R2_FB25_Pos      (25U)
N#define CAN_F7R2_FB25_Msk      (0x1UL << CAN_F7R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F7R2_FB25          CAN_F7R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F7R2_FB26_Pos      (26U)
N#define CAN_F7R2_FB26_Msk      (0x1UL << CAN_F7R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F7R2_FB26          CAN_F7R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F7R2_FB27_Pos      (27U)
N#define CAN_F7R2_FB27_Msk      (0x1UL << CAN_F7R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F7R2_FB27          CAN_F7R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F7R2_FB28_Pos      (28U)
N#define CAN_F7R2_FB28_Msk      (0x1UL << CAN_F7R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F7R2_FB28          CAN_F7R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F7R2_FB29_Pos      (29U)
N#define CAN_F7R2_FB29_Msk      (0x1UL << CAN_F7R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F7R2_FB29          CAN_F7R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F7R2_FB30_Pos      (30U)
N#define CAN_F7R2_FB30_Msk      (0x1UL << CAN_F7R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F7R2_FB30          CAN_F7R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F7R2_FB31_Pos      (31U)
N#define CAN_F7R2_FB31_Msk      (0x1UL << CAN_F7R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F7R2_FB31          CAN_F7R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define CAN_F8R2_FB0_Pos       (0U)
N#define CAN_F8R2_FB0_Msk       (0x1UL << CAN_F8R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F8R2_FB0           CAN_F8R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F8R2_FB1_Pos       (1U)
N#define CAN_F8R2_FB1_Msk       (0x1UL << CAN_F8R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F8R2_FB1           CAN_F8R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F8R2_FB2_Pos       (2U)
N#define CAN_F8R2_FB2_Msk       (0x1UL << CAN_F8R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F8R2_FB2           CAN_F8R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F8R2_FB3_Pos       (3U)
N#define CAN_F8R2_FB3_Msk       (0x1UL << CAN_F8R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F8R2_FB3           CAN_F8R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F8R2_FB4_Pos       (4U)
N#define CAN_F8R2_FB4_Msk       (0x1UL << CAN_F8R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F8R2_FB4           CAN_F8R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F8R2_FB5_Pos       (5U)
N#define CAN_F8R2_FB5_Msk       (0x1UL << CAN_F8R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F8R2_FB5           CAN_F8R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F8R2_FB6_Pos       (6U)
N#define CAN_F8R2_FB6_Msk       (0x1UL << CAN_F8R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F8R2_FB6           CAN_F8R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F8R2_FB7_Pos       (7U)
N#define CAN_F8R2_FB7_Msk       (0x1UL << CAN_F8R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F8R2_FB7           CAN_F8R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F8R2_FB8_Pos       (8U)
N#define CAN_F8R2_FB8_Msk       (0x1UL << CAN_F8R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F8R2_FB8           CAN_F8R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F8R2_FB9_Pos       (9U)
N#define CAN_F8R2_FB9_Msk       (0x1UL << CAN_F8R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F8R2_FB9           CAN_F8R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F8R2_FB10_Pos      (10U)
N#define CAN_F8R2_FB10_Msk      (0x1UL << CAN_F8R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F8R2_FB10          CAN_F8R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F8R2_FB11_Pos      (11U)
N#define CAN_F8R2_FB11_Msk      (0x1UL << CAN_F8R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F8R2_FB11          CAN_F8R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F8R2_FB12_Pos      (12U)
N#define CAN_F8R2_FB12_Msk      (0x1UL << CAN_F8R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F8R2_FB12          CAN_F8R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F8R2_FB13_Pos      (13U)
N#define CAN_F8R2_FB13_Msk      (0x1UL << CAN_F8R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F8R2_FB13          CAN_F8R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F8R2_FB14_Pos      (14U)
N#define CAN_F8R2_FB14_Msk      (0x1UL << CAN_F8R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F8R2_FB14          CAN_F8R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F8R2_FB15_Pos      (15U)
N#define CAN_F8R2_FB15_Msk      (0x1UL << CAN_F8R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F8R2_FB15          CAN_F8R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F8R2_FB16_Pos      (16U)
N#define CAN_F8R2_FB16_Msk      (0x1UL << CAN_F8R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F8R2_FB16          CAN_F8R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F8R2_FB17_Pos      (17U)
N#define CAN_F8R2_FB17_Msk      (0x1UL << CAN_F8R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F8R2_FB17          CAN_F8R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F8R2_FB18_Pos      (18U)
N#define CAN_F8R2_FB18_Msk      (0x1UL << CAN_F8R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F8R2_FB18          CAN_F8R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F8R2_FB19_Pos      (19U)
N#define CAN_F8R2_FB19_Msk      (0x1UL << CAN_F8R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F8R2_FB19          CAN_F8R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F8R2_FB20_Pos      (20U)
N#define CAN_F8R2_FB20_Msk      (0x1UL << CAN_F8R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F8R2_FB20          CAN_F8R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F8R2_FB21_Pos      (21U)
N#define CAN_F8R2_FB21_Msk      (0x1UL << CAN_F8R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F8R2_FB21          CAN_F8R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F8R2_FB22_Pos      (22U)
N#define CAN_F8R2_FB22_Msk      (0x1UL << CAN_F8R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F8R2_FB22          CAN_F8R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F8R2_FB23_Pos      (23U)
N#define CAN_F8R2_FB23_Msk      (0x1UL << CAN_F8R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F8R2_FB23          CAN_F8R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F8R2_FB24_Pos      (24U)
N#define CAN_F8R2_FB24_Msk      (0x1UL << CAN_F8R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F8R2_FB24          CAN_F8R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F8R2_FB25_Pos      (25U)
N#define CAN_F8R2_FB25_Msk      (0x1UL << CAN_F8R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F8R2_FB25          CAN_F8R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F8R2_FB26_Pos      (26U)
N#define CAN_F8R2_FB26_Msk      (0x1UL << CAN_F8R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F8R2_FB26          CAN_F8R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F8R2_FB27_Pos      (27U)
N#define CAN_F8R2_FB27_Msk      (0x1UL << CAN_F8R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F8R2_FB27          CAN_F8R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F8R2_FB28_Pos      (28U)
N#define CAN_F8R2_FB28_Msk      (0x1UL << CAN_F8R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F8R2_FB28          CAN_F8R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F8R2_FB29_Pos      (29U)
N#define CAN_F8R2_FB29_Msk      (0x1UL << CAN_F8R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F8R2_FB29          CAN_F8R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F8R2_FB30_Pos      (30U)
N#define CAN_F8R2_FB30_Msk      (0x1UL << CAN_F8R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F8R2_FB30          CAN_F8R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F8R2_FB31_Pos      (31U)
N#define CAN_F8R2_FB31_Msk      (0x1UL << CAN_F8R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F8R2_FB31          CAN_F8R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define CAN_F9R2_FB0_Pos       (0U)
N#define CAN_F9R2_FB0_Msk       (0x1UL << CAN_F9R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F9R2_FB0           CAN_F9R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F9R2_FB1_Pos       (1U)
N#define CAN_F9R2_FB1_Msk       (0x1UL << CAN_F9R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F9R2_FB1           CAN_F9R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F9R2_FB2_Pos       (2U)
N#define CAN_F9R2_FB2_Msk       (0x1UL << CAN_F9R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F9R2_FB2           CAN_F9R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F9R2_FB3_Pos       (3U)
N#define CAN_F9R2_FB3_Msk       (0x1UL << CAN_F9R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F9R2_FB3           CAN_F9R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F9R2_FB4_Pos       (4U)
N#define CAN_F9R2_FB4_Msk       (0x1UL << CAN_F9R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F9R2_FB4           CAN_F9R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F9R2_FB5_Pos       (5U)
N#define CAN_F9R2_FB5_Msk       (0x1UL << CAN_F9R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F9R2_FB5           CAN_F9R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F9R2_FB6_Pos       (6U)
N#define CAN_F9R2_FB6_Msk       (0x1UL << CAN_F9R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F9R2_FB6           CAN_F9R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F9R2_FB7_Pos       (7U)
N#define CAN_F9R2_FB7_Msk       (0x1UL << CAN_F9R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F9R2_FB7           CAN_F9R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F9R2_FB8_Pos       (8U)
N#define CAN_F9R2_FB8_Msk       (0x1UL << CAN_F9R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F9R2_FB8           CAN_F9R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F9R2_FB9_Pos       (9U)
N#define CAN_F9R2_FB9_Msk       (0x1UL << CAN_F9R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F9R2_FB9           CAN_F9R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F9R2_FB10_Pos      (10U)
N#define CAN_F9R2_FB10_Msk      (0x1UL << CAN_F9R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F9R2_FB10          CAN_F9R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F9R2_FB11_Pos      (11U)
N#define CAN_F9R2_FB11_Msk      (0x1UL << CAN_F9R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F9R2_FB11          CAN_F9R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F9R2_FB12_Pos      (12U)
N#define CAN_F9R2_FB12_Msk      (0x1UL << CAN_F9R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F9R2_FB12          CAN_F9R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F9R2_FB13_Pos      (13U)
N#define CAN_F9R2_FB13_Msk      (0x1UL << CAN_F9R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F9R2_FB13          CAN_F9R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F9R2_FB14_Pos      (14U)
N#define CAN_F9R2_FB14_Msk      (0x1UL << CAN_F9R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F9R2_FB14          CAN_F9R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F9R2_FB15_Pos      (15U)
N#define CAN_F9R2_FB15_Msk      (0x1UL << CAN_F9R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F9R2_FB15          CAN_F9R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F9R2_FB16_Pos      (16U)
N#define CAN_F9R2_FB16_Msk      (0x1UL << CAN_F9R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F9R2_FB16          CAN_F9R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F9R2_FB17_Pos      (17U)
N#define CAN_F9R2_FB17_Msk      (0x1UL << CAN_F9R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F9R2_FB17          CAN_F9R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F9R2_FB18_Pos      (18U)
N#define CAN_F9R2_FB18_Msk      (0x1UL << CAN_F9R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F9R2_FB18          CAN_F9R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F9R2_FB19_Pos      (19U)
N#define CAN_F9R2_FB19_Msk      (0x1UL << CAN_F9R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F9R2_FB19          CAN_F9R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F9R2_FB20_Pos      (20U)
N#define CAN_F9R2_FB20_Msk      (0x1UL << CAN_F9R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F9R2_FB20          CAN_F9R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F9R2_FB21_Pos      (21U)
N#define CAN_F9R2_FB21_Msk      (0x1UL << CAN_F9R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F9R2_FB21          CAN_F9R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F9R2_FB22_Pos      (22U)
N#define CAN_F9R2_FB22_Msk      (0x1UL << CAN_F9R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F9R2_FB22          CAN_F9R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F9R2_FB23_Pos      (23U)
N#define CAN_F9R2_FB23_Msk      (0x1UL << CAN_F9R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F9R2_FB23          CAN_F9R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F9R2_FB24_Pos      (24U)
N#define CAN_F9R2_FB24_Msk      (0x1UL << CAN_F9R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F9R2_FB24          CAN_F9R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F9R2_FB25_Pos      (25U)
N#define CAN_F9R2_FB25_Msk      (0x1UL << CAN_F9R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F9R2_FB25          CAN_F9R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F9R2_FB26_Pos      (26U)
N#define CAN_F9R2_FB26_Msk      (0x1UL << CAN_F9R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F9R2_FB26          CAN_F9R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F9R2_FB27_Pos      (27U)
N#define CAN_F9R2_FB27_Msk      (0x1UL << CAN_F9R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F9R2_FB27          CAN_F9R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F9R2_FB28_Pos      (28U)
N#define CAN_F9R2_FB28_Msk      (0x1UL << CAN_F9R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F9R2_FB28          CAN_F9R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F9R2_FB29_Pos      (29U)
N#define CAN_F9R2_FB29_Msk      (0x1UL << CAN_F9R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F9R2_FB29          CAN_F9R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F9R2_FB30_Pos      (30U)
N#define CAN_F9R2_FB30_Msk      (0x1UL << CAN_F9R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F9R2_FB30          CAN_F9R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F9R2_FB31_Pos      (31U)
N#define CAN_F9R2_FB31_Msk      (0x1UL << CAN_F9R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F9R2_FB31          CAN_F9R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define CAN_F10R2_FB0_Pos      (0U)
N#define CAN_F10R2_FB0_Msk      (0x1UL << CAN_F10R2_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F10R2_FB0          CAN_F10R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F10R2_FB1_Pos      (1U)
N#define CAN_F10R2_FB1_Msk      (0x1UL << CAN_F10R2_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F10R2_FB1          CAN_F10R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F10R2_FB2_Pos      (2U)
N#define CAN_F10R2_FB2_Msk      (0x1UL << CAN_F10R2_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F10R2_FB2          CAN_F10R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F10R2_FB3_Pos      (3U)
N#define CAN_F10R2_FB3_Msk      (0x1UL << CAN_F10R2_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F10R2_FB3          CAN_F10R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F10R2_FB4_Pos      (4U)
N#define CAN_F10R2_FB4_Msk      (0x1UL << CAN_F10R2_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F10R2_FB4          CAN_F10R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F10R2_FB5_Pos      (5U)
N#define CAN_F10R2_FB5_Msk      (0x1UL << CAN_F10R2_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F10R2_FB5          CAN_F10R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F10R2_FB6_Pos      (6U)
N#define CAN_F10R2_FB6_Msk      (0x1UL << CAN_F10R2_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F10R2_FB6          CAN_F10R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F10R2_FB7_Pos      (7U)
N#define CAN_F10R2_FB7_Msk      (0x1UL << CAN_F10R2_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F10R2_FB7          CAN_F10R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F10R2_FB8_Pos      (8U)
N#define CAN_F10R2_FB8_Msk      (0x1UL << CAN_F10R2_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F10R2_FB8          CAN_F10R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F10R2_FB9_Pos      (9U)
N#define CAN_F10R2_FB9_Msk      (0x1UL << CAN_F10R2_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F10R2_FB9          CAN_F10R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F10R2_FB10_Pos     (10U)
N#define CAN_F10R2_FB10_Msk     (0x1UL << CAN_F10R2_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F10R2_FB10         CAN_F10R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F10R2_FB11_Pos     (11U)
N#define CAN_F10R2_FB11_Msk     (0x1UL << CAN_F10R2_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F10R2_FB11         CAN_F10R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F10R2_FB12_Pos     (12U)
N#define CAN_F10R2_FB12_Msk     (0x1UL << CAN_F10R2_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F10R2_FB12         CAN_F10R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F10R2_FB13_Pos     (13U)
N#define CAN_F10R2_FB13_Msk     (0x1UL << CAN_F10R2_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F10R2_FB13         CAN_F10R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F10R2_FB14_Pos     (14U)
N#define CAN_F10R2_FB14_Msk     (0x1UL << CAN_F10R2_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F10R2_FB14         CAN_F10R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F10R2_FB15_Pos     (15U)
N#define CAN_F10R2_FB15_Msk     (0x1UL << CAN_F10R2_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F10R2_FB15         CAN_F10R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F10R2_FB16_Pos     (16U)
N#define CAN_F10R2_FB16_Msk     (0x1UL << CAN_F10R2_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F10R2_FB16         CAN_F10R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F10R2_FB17_Pos     (17U)
N#define CAN_F10R2_FB17_Msk     (0x1UL << CAN_F10R2_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F10R2_FB17         CAN_F10R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F10R2_FB18_Pos     (18U)
N#define CAN_F10R2_FB18_Msk     (0x1UL << CAN_F10R2_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F10R2_FB18         CAN_F10R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F10R2_FB19_Pos     (19U)
N#define CAN_F10R2_FB19_Msk     (0x1UL << CAN_F10R2_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F10R2_FB19         CAN_F10R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F10R2_FB20_Pos     (20U)
N#define CAN_F10R2_FB20_Msk     (0x1UL << CAN_F10R2_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F10R2_FB20         CAN_F10R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F10R2_FB21_Pos     (21U)
N#define CAN_F10R2_FB21_Msk     (0x1UL << CAN_F10R2_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F10R2_FB21         CAN_F10R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F10R2_FB22_Pos     (22U)
N#define CAN_F10R2_FB22_Msk     (0x1UL << CAN_F10R2_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F10R2_FB22         CAN_F10R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F10R2_FB23_Pos     (23U)
N#define CAN_F10R2_FB23_Msk     (0x1UL << CAN_F10R2_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F10R2_FB23         CAN_F10R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F10R2_FB24_Pos     (24U)
N#define CAN_F10R2_FB24_Msk     (0x1UL << CAN_F10R2_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F10R2_FB24         CAN_F10R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F10R2_FB25_Pos     (25U)
N#define CAN_F10R2_FB25_Msk     (0x1UL << CAN_F10R2_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F10R2_FB25         CAN_F10R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F10R2_FB26_Pos     (26U)
N#define CAN_F10R2_FB26_Msk     (0x1UL << CAN_F10R2_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F10R2_FB26         CAN_F10R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F10R2_FB27_Pos     (27U)
N#define CAN_F10R2_FB27_Msk     (0x1UL << CAN_F10R2_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F10R2_FB27         CAN_F10R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F10R2_FB28_Pos     (28U)
N#define CAN_F10R2_FB28_Msk     (0x1UL << CAN_F10R2_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F10R2_FB28         CAN_F10R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F10R2_FB29_Pos     (29U)
N#define CAN_F10R2_FB29_Msk     (0x1UL << CAN_F10R2_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F10R2_FB29         CAN_F10R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F10R2_FB30_Pos     (30U)
N#define CAN_F10R2_FB30_Msk     (0x1UL << CAN_F10R2_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F10R2_FB30         CAN_F10R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F10R2_FB31_Pos     (31U)
N#define CAN_F10R2_FB31_Msk     (0x1UL << CAN_F10R2_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F10R2_FB31         CAN_F10R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define CAN_F11R2_FB0_Pos      (0U)
N#define CAN_F11R2_FB0_Msk      (0x1UL << CAN_F11R2_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F11R2_FB0          CAN_F11R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F11R2_FB1_Pos      (1U)
N#define CAN_F11R2_FB1_Msk      (0x1UL << CAN_F11R2_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F11R2_FB1          CAN_F11R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F11R2_FB2_Pos      (2U)
N#define CAN_F11R2_FB2_Msk      (0x1UL << CAN_F11R2_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F11R2_FB2          CAN_F11R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F11R2_FB3_Pos      (3U)
N#define CAN_F11R2_FB3_Msk      (0x1UL << CAN_F11R2_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F11R2_FB3          CAN_F11R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F11R2_FB4_Pos      (4U)
N#define CAN_F11R2_FB4_Msk      (0x1UL << CAN_F11R2_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F11R2_FB4          CAN_F11R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F11R2_FB5_Pos      (5U)
N#define CAN_F11R2_FB5_Msk      (0x1UL << CAN_F11R2_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F11R2_FB5          CAN_F11R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F11R2_FB6_Pos      (6U)
N#define CAN_F11R2_FB6_Msk      (0x1UL << CAN_F11R2_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F11R2_FB6          CAN_F11R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F11R2_FB7_Pos      (7U)
N#define CAN_F11R2_FB7_Msk      (0x1UL << CAN_F11R2_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F11R2_FB7          CAN_F11R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F11R2_FB8_Pos      (8U)
N#define CAN_F11R2_FB8_Msk      (0x1UL << CAN_F11R2_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F11R2_FB8          CAN_F11R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F11R2_FB9_Pos      (9U)
N#define CAN_F11R2_FB9_Msk      (0x1UL << CAN_F11R2_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F11R2_FB9          CAN_F11R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F11R2_FB10_Pos     (10U)
N#define CAN_F11R2_FB10_Msk     (0x1UL << CAN_F11R2_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F11R2_FB10         CAN_F11R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F11R2_FB11_Pos     (11U)
N#define CAN_F11R2_FB11_Msk     (0x1UL << CAN_F11R2_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F11R2_FB11         CAN_F11R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F11R2_FB12_Pos     (12U)
N#define CAN_F11R2_FB12_Msk     (0x1UL << CAN_F11R2_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F11R2_FB12         CAN_F11R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F11R2_FB13_Pos     (13U)
N#define CAN_F11R2_FB13_Msk     (0x1UL << CAN_F11R2_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F11R2_FB13         CAN_F11R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F11R2_FB14_Pos     (14U)
N#define CAN_F11R2_FB14_Msk     (0x1UL << CAN_F11R2_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F11R2_FB14         CAN_F11R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F11R2_FB15_Pos     (15U)
N#define CAN_F11R2_FB15_Msk     (0x1UL << CAN_F11R2_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F11R2_FB15         CAN_F11R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F11R2_FB16_Pos     (16U)
N#define CAN_F11R2_FB16_Msk     (0x1UL << CAN_F11R2_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F11R2_FB16         CAN_F11R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F11R2_FB17_Pos     (17U)
N#define CAN_F11R2_FB17_Msk     (0x1UL << CAN_F11R2_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F11R2_FB17         CAN_F11R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F11R2_FB18_Pos     (18U)
N#define CAN_F11R2_FB18_Msk     (0x1UL << CAN_F11R2_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F11R2_FB18         CAN_F11R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F11R2_FB19_Pos     (19U)
N#define CAN_F11R2_FB19_Msk     (0x1UL << CAN_F11R2_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F11R2_FB19         CAN_F11R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F11R2_FB20_Pos     (20U)
N#define CAN_F11R2_FB20_Msk     (0x1UL << CAN_F11R2_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F11R2_FB20         CAN_F11R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F11R2_FB21_Pos     (21U)
N#define CAN_F11R2_FB21_Msk     (0x1UL << CAN_F11R2_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F11R2_FB21         CAN_F11R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F11R2_FB22_Pos     (22U)
N#define CAN_F11R2_FB22_Msk     (0x1UL << CAN_F11R2_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F11R2_FB22         CAN_F11R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F11R2_FB23_Pos     (23U)
N#define CAN_F11R2_FB23_Msk     (0x1UL << CAN_F11R2_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F11R2_FB23         CAN_F11R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F11R2_FB24_Pos     (24U)
N#define CAN_F11R2_FB24_Msk     (0x1UL << CAN_F11R2_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F11R2_FB24         CAN_F11R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F11R2_FB25_Pos     (25U)
N#define CAN_F11R2_FB25_Msk     (0x1UL << CAN_F11R2_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F11R2_FB25         CAN_F11R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F11R2_FB26_Pos     (26U)
N#define CAN_F11R2_FB26_Msk     (0x1UL << CAN_F11R2_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F11R2_FB26         CAN_F11R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F11R2_FB27_Pos     (27U)
N#define CAN_F11R2_FB27_Msk     (0x1UL << CAN_F11R2_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F11R2_FB27         CAN_F11R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F11R2_FB28_Pos     (28U)
N#define CAN_F11R2_FB28_Msk     (0x1UL << CAN_F11R2_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F11R2_FB28         CAN_F11R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F11R2_FB29_Pos     (29U)
N#define CAN_F11R2_FB29_Msk     (0x1UL << CAN_F11R2_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F11R2_FB29         CAN_F11R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F11R2_FB30_Pos     (30U)
N#define CAN_F11R2_FB30_Msk     (0x1UL << CAN_F11R2_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F11R2_FB30         CAN_F11R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F11R2_FB31_Pos     (31U)
N#define CAN_F11R2_FB31_Msk     (0x1UL << CAN_F11R2_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F11R2_FB31         CAN_F11R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define CAN_F12R2_FB0_Pos      (0U)
N#define CAN_F12R2_FB0_Msk      (0x1UL << CAN_F12R2_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F12R2_FB0          CAN_F12R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F12R2_FB1_Pos      (1U)
N#define CAN_F12R2_FB1_Msk      (0x1UL << CAN_F12R2_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F12R2_FB1          CAN_F12R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F12R2_FB2_Pos      (2U)
N#define CAN_F12R2_FB2_Msk      (0x1UL << CAN_F12R2_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F12R2_FB2          CAN_F12R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F12R2_FB3_Pos      (3U)
N#define CAN_F12R2_FB3_Msk      (0x1UL << CAN_F12R2_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F12R2_FB3          CAN_F12R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F12R2_FB4_Pos      (4U)
N#define CAN_F12R2_FB4_Msk      (0x1UL << CAN_F12R2_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F12R2_FB4          CAN_F12R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F12R2_FB5_Pos      (5U)
N#define CAN_F12R2_FB5_Msk      (0x1UL << CAN_F12R2_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F12R2_FB5          CAN_F12R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F12R2_FB6_Pos      (6U)
N#define CAN_F12R2_FB6_Msk      (0x1UL << CAN_F12R2_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F12R2_FB6          CAN_F12R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F12R2_FB7_Pos      (7U)
N#define CAN_F12R2_FB7_Msk      (0x1UL << CAN_F12R2_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F12R2_FB7          CAN_F12R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F12R2_FB8_Pos      (8U)
N#define CAN_F12R2_FB8_Msk      (0x1UL << CAN_F12R2_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F12R2_FB8          CAN_F12R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F12R2_FB9_Pos      (9U)
N#define CAN_F12R2_FB9_Msk      (0x1UL << CAN_F12R2_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F12R2_FB9          CAN_F12R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F12R2_FB10_Pos     (10U)
N#define CAN_F12R2_FB10_Msk     (0x1UL << CAN_F12R2_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F12R2_FB10         CAN_F12R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F12R2_FB11_Pos     (11U)
N#define CAN_F12R2_FB11_Msk     (0x1UL << CAN_F12R2_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F12R2_FB11         CAN_F12R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F12R2_FB12_Pos     (12U)
N#define CAN_F12R2_FB12_Msk     (0x1UL << CAN_F12R2_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F12R2_FB12         CAN_F12R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F12R2_FB13_Pos     (13U)
N#define CAN_F12R2_FB13_Msk     (0x1UL << CAN_F12R2_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F12R2_FB13         CAN_F12R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F12R2_FB14_Pos     (14U)
N#define CAN_F12R2_FB14_Msk     (0x1UL << CAN_F12R2_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F12R2_FB14         CAN_F12R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F12R2_FB15_Pos     (15U)
N#define CAN_F12R2_FB15_Msk     (0x1UL << CAN_F12R2_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F12R2_FB15         CAN_F12R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F12R2_FB16_Pos     (16U)
N#define CAN_F12R2_FB16_Msk     (0x1UL << CAN_F12R2_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F12R2_FB16         CAN_F12R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F12R2_FB17_Pos     (17U)
N#define CAN_F12R2_FB17_Msk     (0x1UL << CAN_F12R2_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F12R2_FB17         CAN_F12R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F12R2_FB18_Pos     (18U)
N#define CAN_F12R2_FB18_Msk     (0x1UL << CAN_F12R2_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F12R2_FB18         CAN_F12R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F12R2_FB19_Pos     (19U)
N#define CAN_F12R2_FB19_Msk     (0x1UL << CAN_F12R2_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F12R2_FB19         CAN_F12R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F12R2_FB20_Pos     (20U)
N#define CAN_F12R2_FB20_Msk     (0x1UL << CAN_F12R2_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F12R2_FB20         CAN_F12R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F12R2_FB21_Pos     (21U)
N#define CAN_F12R2_FB21_Msk     (0x1UL << CAN_F12R2_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F12R2_FB21         CAN_F12R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F12R2_FB22_Pos     (22U)
N#define CAN_F12R2_FB22_Msk     (0x1UL << CAN_F12R2_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F12R2_FB22         CAN_F12R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F12R2_FB23_Pos     (23U)
N#define CAN_F12R2_FB23_Msk     (0x1UL << CAN_F12R2_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F12R2_FB23         CAN_F12R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F12R2_FB24_Pos     (24U)
N#define CAN_F12R2_FB24_Msk     (0x1UL << CAN_F12R2_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F12R2_FB24         CAN_F12R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F12R2_FB25_Pos     (25U)
N#define CAN_F12R2_FB25_Msk     (0x1UL << CAN_F12R2_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F12R2_FB25         CAN_F12R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F12R2_FB26_Pos     (26U)
N#define CAN_F12R2_FB26_Msk     (0x1UL << CAN_F12R2_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F12R2_FB26         CAN_F12R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F12R2_FB27_Pos     (27U)
N#define CAN_F12R2_FB27_Msk     (0x1UL << CAN_F12R2_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F12R2_FB27         CAN_F12R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F12R2_FB28_Pos     (28U)
N#define CAN_F12R2_FB28_Msk     (0x1UL << CAN_F12R2_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F12R2_FB28         CAN_F12R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F12R2_FB29_Pos     (29U)
N#define CAN_F12R2_FB29_Msk     (0x1UL << CAN_F12R2_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F12R2_FB29         CAN_F12R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F12R2_FB30_Pos     (30U)
N#define CAN_F12R2_FB30_Msk     (0x1UL << CAN_F12R2_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F12R2_FB30         CAN_F12R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F12R2_FB31_Pos     (31U)
N#define CAN_F12R2_FB31_Msk     (0x1UL << CAN_F12R2_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F12R2_FB31         CAN_F12R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define CAN_F13R2_FB0_Pos      (0U)
N#define CAN_F13R2_FB0_Msk      (0x1UL << CAN_F13R2_FB0_Pos)                    /*!< 0x00000001 */
N#define CAN_F13R2_FB0          CAN_F13R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F13R2_FB1_Pos      (1U)
N#define CAN_F13R2_FB1_Msk      (0x1UL << CAN_F13R2_FB1_Pos)                    /*!< 0x00000002 */
N#define CAN_F13R2_FB1          CAN_F13R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F13R2_FB2_Pos      (2U)
N#define CAN_F13R2_FB2_Msk      (0x1UL << CAN_F13R2_FB2_Pos)                    /*!< 0x00000004 */
N#define CAN_F13R2_FB2          CAN_F13R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F13R2_FB3_Pos      (3U)
N#define CAN_F13R2_FB3_Msk      (0x1UL << CAN_F13R2_FB3_Pos)                    /*!< 0x00000008 */
N#define CAN_F13R2_FB3          CAN_F13R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F13R2_FB4_Pos      (4U)
N#define CAN_F13R2_FB4_Msk      (0x1UL << CAN_F13R2_FB4_Pos)                    /*!< 0x00000010 */
N#define CAN_F13R2_FB4          CAN_F13R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F13R2_FB5_Pos      (5U)
N#define CAN_F13R2_FB5_Msk      (0x1UL << CAN_F13R2_FB5_Pos)                    /*!< 0x00000020 */
N#define CAN_F13R2_FB5          CAN_F13R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F13R2_FB6_Pos      (6U)
N#define CAN_F13R2_FB6_Msk      (0x1UL << CAN_F13R2_FB6_Pos)                    /*!< 0x00000040 */
N#define CAN_F13R2_FB6          CAN_F13R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F13R2_FB7_Pos      (7U)
N#define CAN_F13R2_FB7_Msk      (0x1UL << CAN_F13R2_FB7_Pos)                    /*!< 0x00000080 */
N#define CAN_F13R2_FB7          CAN_F13R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F13R2_FB8_Pos      (8U)
N#define CAN_F13R2_FB8_Msk      (0x1UL << CAN_F13R2_FB8_Pos)                    /*!< 0x00000100 */
N#define CAN_F13R2_FB8          CAN_F13R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F13R2_FB9_Pos      (9U)
N#define CAN_F13R2_FB9_Msk      (0x1UL << CAN_F13R2_FB9_Pos)                    /*!< 0x00000200 */
N#define CAN_F13R2_FB9          CAN_F13R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F13R2_FB10_Pos     (10U)
N#define CAN_F13R2_FB10_Msk     (0x1UL << CAN_F13R2_FB10_Pos)                   /*!< 0x00000400 */
N#define CAN_F13R2_FB10         CAN_F13R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F13R2_FB11_Pos     (11U)
N#define CAN_F13R2_FB11_Msk     (0x1UL << CAN_F13R2_FB11_Pos)                   /*!< 0x00000800 */
N#define CAN_F13R2_FB11         CAN_F13R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F13R2_FB12_Pos     (12U)
N#define CAN_F13R2_FB12_Msk     (0x1UL << CAN_F13R2_FB12_Pos)                   /*!< 0x00001000 */
N#define CAN_F13R2_FB12         CAN_F13R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F13R2_FB13_Pos     (13U)
N#define CAN_F13R2_FB13_Msk     (0x1UL << CAN_F13R2_FB13_Pos)                   /*!< 0x00002000 */
N#define CAN_F13R2_FB13         CAN_F13R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F13R2_FB14_Pos     (14U)
N#define CAN_F13R2_FB14_Msk     (0x1UL << CAN_F13R2_FB14_Pos)                   /*!< 0x00004000 */
N#define CAN_F13R2_FB14         CAN_F13R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F13R2_FB15_Pos     (15U)
N#define CAN_F13R2_FB15_Msk     (0x1UL << CAN_F13R2_FB15_Pos)                   /*!< 0x00008000 */
N#define CAN_F13R2_FB15         CAN_F13R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F13R2_FB16_Pos     (16U)
N#define CAN_F13R2_FB16_Msk     (0x1UL << CAN_F13R2_FB16_Pos)                   /*!< 0x00010000 */
N#define CAN_F13R2_FB16         CAN_F13R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F13R2_FB17_Pos     (17U)
N#define CAN_F13R2_FB17_Msk     (0x1UL << CAN_F13R2_FB17_Pos)                   /*!< 0x00020000 */
N#define CAN_F13R2_FB17         CAN_F13R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F13R2_FB18_Pos     (18U)
N#define CAN_F13R2_FB18_Msk     (0x1UL << CAN_F13R2_FB18_Pos)                   /*!< 0x00040000 */
N#define CAN_F13R2_FB18         CAN_F13R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F13R2_FB19_Pos     (19U)
N#define CAN_F13R2_FB19_Msk     (0x1UL << CAN_F13R2_FB19_Pos)                   /*!< 0x00080000 */
N#define CAN_F13R2_FB19         CAN_F13R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F13R2_FB20_Pos     (20U)
N#define CAN_F13R2_FB20_Msk     (0x1UL << CAN_F13R2_FB20_Pos)                   /*!< 0x00100000 */
N#define CAN_F13R2_FB20         CAN_F13R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F13R2_FB21_Pos     (21U)
N#define CAN_F13R2_FB21_Msk     (0x1UL << CAN_F13R2_FB21_Pos)                   /*!< 0x00200000 */
N#define CAN_F13R2_FB21         CAN_F13R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F13R2_FB22_Pos     (22U)
N#define CAN_F13R2_FB22_Msk     (0x1UL << CAN_F13R2_FB22_Pos)                   /*!< 0x00400000 */
N#define CAN_F13R2_FB22         CAN_F13R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F13R2_FB23_Pos     (23U)
N#define CAN_F13R2_FB23_Msk     (0x1UL << CAN_F13R2_FB23_Pos)                   /*!< 0x00800000 */
N#define CAN_F13R2_FB23         CAN_F13R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F13R2_FB24_Pos     (24U)
N#define CAN_F13R2_FB24_Msk     (0x1UL << CAN_F13R2_FB24_Pos)                   /*!< 0x01000000 */
N#define CAN_F13R2_FB24         CAN_F13R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F13R2_FB25_Pos     (25U)
N#define CAN_F13R2_FB25_Msk     (0x1UL << CAN_F13R2_FB25_Pos)                   /*!< 0x02000000 */
N#define CAN_F13R2_FB25         CAN_F13R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F13R2_FB26_Pos     (26U)
N#define CAN_F13R2_FB26_Msk     (0x1UL << CAN_F13R2_FB26_Pos)                   /*!< 0x04000000 */
N#define CAN_F13R2_FB26         CAN_F13R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F13R2_FB27_Pos     (27U)
N#define CAN_F13R2_FB27_Msk     (0x1UL << CAN_F13R2_FB27_Pos)                   /*!< 0x08000000 */
N#define CAN_F13R2_FB27         CAN_F13R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F13R2_FB28_Pos     (28U)
N#define CAN_F13R2_FB28_Msk     (0x1UL << CAN_F13R2_FB28_Pos)                   /*!< 0x10000000 */
N#define CAN_F13R2_FB28         CAN_F13R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F13R2_FB29_Pos     (29U)
N#define CAN_F13R2_FB29_Msk     (0x1UL << CAN_F13R2_FB29_Pos)                   /*!< 0x20000000 */
N#define CAN_F13R2_FB29         CAN_F13R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F13R2_FB30_Pos     (30U)
N#define CAN_F13R2_FB30_Msk     (0x1UL << CAN_F13R2_FB30_Pos)                   /*!< 0x40000000 */
N#define CAN_F13R2_FB30         CAN_F13R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F13R2_FB31_Pos     (31U)
N#define CAN_F13R2_FB31_Msk     (0x1UL << CAN_F13R2_FB31_Pos)                   /*!< 0x80000000 */
N#define CAN_F13R2_FB31         CAN_F13R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRC calculation unit                              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define CRC_DR_DR_Pos            (0U)
N#define CRC_DR_DR_Msk            (0xFFFFFFFFUL << CRC_DR_DR_Pos)               /*!< 0xFFFFFFFF */
N#define CRC_DR_DR                CRC_DR_DR_Msk                                 /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define CRC_IDR_IDR_Pos          (0U)
N#define CRC_IDR_IDR_Msk          (0xFFUL << CRC_IDR_IDR_Pos)                   /*!< 0x000000FF */
N#define CRC_IDR_IDR              CRC_IDR_IDR_Msk                               /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define CRC_CR_RESET_Pos         (0U)
N#define CRC_CR_RESET_Msk         (0x1UL << CRC_CR_RESET_Pos)                   /*!< 0x00000001 */
N#define CRC_CR_RESET             CRC_CR_RESET_Msk                              /*!< RESET the CRC computation unit bit */
N#define CRC_CR_POLYSIZE_Pos      (3U)
N#define CRC_CR_POLYSIZE_Msk      (0x3UL << CRC_CR_POLYSIZE_Pos)                /*!< 0x00000018 */
N#define CRC_CR_POLYSIZE          CRC_CR_POLYSIZE_Msk                           /*!< Polynomial size bits */
N#define CRC_CR_POLYSIZE_0        (0x1UL << CRC_CR_POLYSIZE_Pos)                /*!< 0x00000008 */
N#define CRC_CR_POLYSIZE_1        (0x2UL << CRC_CR_POLYSIZE_Pos)                /*!< 0x00000010 */
N#define CRC_CR_REV_IN_Pos        (5U)
N#define CRC_CR_REV_IN_Msk        (0x3UL << CRC_CR_REV_IN_Pos)                  /*!< 0x00000060 */
N#define CRC_CR_REV_IN            CRC_CR_REV_IN_Msk                             /*!< REV_IN Reverse Input Data bits */
N#define CRC_CR_REV_IN_0          (0x1UL << CRC_CR_REV_IN_Pos)                  /*!< 0x00000020 */
N#define CRC_CR_REV_IN_1          (0x2UL << CRC_CR_REV_IN_Pos)                  /*!< 0x00000040 */
N#define CRC_CR_REV_OUT_Pos       (7U)
N#define CRC_CR_REV_OUT_Msk       (0x1UL << CRC_CR_REV_OUT_Pos)                 /*!< 0x00000080 */
N#define CRC_CR_REV_OUT           CRC_CR_REV_OUT_Msk                            /*!< REV_OUT Reverse Output Data bits */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define CRC_INIT_INIT_Pos        (0U)
N#define CRC_INIT_INIT_Msk        (0xFFFFFFFFUL << CRC_INIT_INIT_Pos)           /*!< 0xFFFFFFFF */
N#define CRC_INIT_INIT            CRC_INIT_INIT_Msk                             /*!< Initial CRC value bits */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N#define CRC_POL_POL_Pos          (0U)
N#define CRC_POL_POL_Msk          (0xFFFFFFFFUL << CRC_POL_POL_Pos)             /*!< 0xFFFFFFFF */
N#define CRC_POL_POL              CRC_POL_POL_Msk                               /*!< Coefficients of the polynomial */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRS Clock Recovery System                         */
N/******************************************************************************/
N
N/*******************  Bit definition for CRS_CR register  *********************/
N#define CRS_CR_SYNCOKIE_Pos       (0U)
N#define CRS_CR_SYNCOKIE_Msk       (0x1UL << CRS_CR_SYNCOKIE_Pos)               /*!< 0x00000001 */
N#define CRS_CR_SYNCOKIE           CRS_CR_SYNCOKIE_Msk                          /*!< SYNC event OK interrupt enable */
N#define CRS_CR_SYNCWARNIE_Pos     (1U)
N#define CRS_CR_SYNCWARNIE_Msk     (0x1UL << CRS_CR_SYNCWARNIE_Pos)             /*!< 0x00000002 */
N#define CRS_CR_SYNCWARNIE         CRS_CR_SYNCWARNIE_Msk                        /*!< SYNC warning interrupt enable */
N#define CRS_CR_ERRIE_Pos          (2U)
N#define CRS_CR_ERRIE_Msk          (0x1UL << CRS_CR_ERRIE_Pos)                  /*!< 0x00000004 */
N#define CRS_CR_ERRIE              CRS_CR_ERRIE_Msk                             /*!< SYNC error or trimming error interrupt enable */
N#define CRS_CR_ESYNCIE_Pos        (3U)
N#define CRS_CR_ESYNCIE_Msk        (0x1UL << CRS_CR_ESYNCIE_Pos)                /*!< 0x00000008 */
N#define CRS_CR_ESYNCIE            CRS_CR_ESYNCIE_Msk                           /*!< Expected SYNC interrupt enable */
N#define CRS_CR_CEN_Pos            (5U)
N#define CRS_CR_CEN_Msk            (0x1UL << CRS_CR_CEN_Pos)                    /*!< 0x00000020 */
N#define CRS_CR_CEN                CRS_CR_CEN_Msk                               /*!< Frequency error counter enable */
N#define CRS_CR_AUTOTRIMEN_Pos     (6U)
N#define CRS_CR_AUTOTRIMEN_Msk     (0x1UL << CRS_CR_AUTOTRIMEN_Pos)             /*!< 0x00000040 */
N#define CRS_CR_AUTOTRIMEN         CRS_CR_AUTOTRIMEN_Msk                        /*!< Automatic trimming enable */
N#define CRS_CR_SWSYNC_Pos         (7U)
N#define CRS_CR_SWSYNC_Msk         (0x1UL << CRS_CR_SWSYNC_Pos)                 /*!< 0x00000080 */
N#define CRS_CR_SWSYNC             CRS_CR_SWSYNC_Msk                            /*!< Generate software SYNC event */
N#define CRS_CR_TRIM_Pos           (8U)
N#define CRS_CR_TRIM_Msk           (0x3FUL << CRS_CR_TRIM_Pos)                  /*!< 0x00003F00 */
N#define CRS_CR_TRIM               CRS_CR_TRIM_Msk                              /*!< HSI48 oscillator smooth trimming */
N
N/*******************  Bit definition for CRS_CFGR register  *********************/
N#define CRS_CFGR_RELOAD_Pos       (0U)
N#define CRS_CFGR_RELOAD_Msk       (0xFFFFUL << CRS_CFGR_RELOAD_Pos)            /*!< 0x0000FFFF */
N#define CRS_CFGR_RELOAD           CRS_CFGR_RELOAD_Msk                          /*!< Counter reload value */
N#define CRS_CFGR_FELIM_Pos        (16U)
N#define CRS_CFGR_FELIM_Msk        (0xFFUL << CRS_CFGR_FELIM_Pos)               /*!< 0x00FF0000 */
N#define CRS_CFGR_FELIM            CRS_CFGR_FELIM_Msk                           /*!< Frequency error limit */
N
N#define CRS_CFGR_SYNCDIV_Pos      (24U)
N#define CRS_CFGR_SYNCDIV_Msk      (0x7UL << CRS_CFGR_SYNCDIV_Pos)              /*!< 0x07000000 */
N#define CRS_CFGR_SYNCDIV          CRS_CFGR_SYNCDIV_Msk                         /*!< SYNC divider */
N#define CRS_CFGR_SYNCDIV_0        (0x1UL << CRS_CFGR_SYNCDIV_Pos)              /*!< 0x01000000 */
N#define CRS_CFGR_SYNCDIV_1        (0x2UL << CRS_CFGR_SYNCDIV_Pos)              /*!< 0x02000000 */
N#define CRS_CFGR_SYNCDIV_2        (0x4UL << CRS_CFGR_SYNCDIV_Pos)              /*!< 0x04000000 */
N
N#define CRS_CFGR_SYNCSRC_Pos      (28U)
N#define CRS_CFGR_SYNCSRC_Msk      (0x3UL << CRS_CFGR_SYNCSRC_Pos)              /*!< 0x30000000 */
N#define CRS_CFGR_SYNCSRC          CRS_CFGR_SYNCSRC_Msk                         /*!< SYNC signal source selection */
N#define CRS_CFGR_SYNCSRC_0        (0x1UL << CRS_CFGR_SYNCSRC_Pos)              /*!< 0x10000000 */
N#define CRS_CFGR_SYNCSRC_1        (0x2UL << CRS_CFGR_SYNCSRC_Pos)              /*!< 0x20000000 */
N
N#define CRS_CFGR_SYNCPOL_Pos      (31U)
N#define CRS_CFGR_SYNCPOL_Msk      (0x1UL << CRS_CFGR_SYNCPOL_Pos)              /*!< 0x80000000 */
N#define CRS_CFGR_SYNCPOL          CRS_CFGR_SYNCPOL_Msk                         /*!< SYNC polarity selection */
N
N/*******************  Bit definition for CRS_ISR register  *********************/
N#define CRS_ISR_SYNCOKF_Pos       (0U)
N#define CRS_ISR_SYNCOKF_Msk       (0x1UL << CRS_ISR_SYNCOKF_Pos)               /*!< 0x00000001 */
N#define CRS_ISR_SYNCOKF           CRS_ISR_SYNCOKF_Msk                          /*!< SYNC event OK flag */
N#define CRS_ISR_SYNCWARNF_Pos     (1U)
N#define CRS_ISR_SYNCWARNF_Msk     (0x1UL << CRS_ISR_SYNCWARNF_Pos)             /*!< 0x00000002 */
N#define CRS_ISR_SYNCWARNF         CRS_ISR_SYNCWARNF_Msk                        /*!< SYNC warning flag */
N#define CRS_ISR_ERRF_Pos          (2U)
N#define CRS_ISR_ERRF_Msk          (0x1UL << CRS_ISR_ERRF_Pos)                  /*!< 0x00000004 */
N#define CRS_ISR_ERRF              CRS_ISR_ERRF_Msk                             /*!< Error flag */
N#define CRS_ISR_ESYNCF_Pos        (3U)
N#define CRS_ISR_ESYNCF_Msk        (0x1UL << CRS_ISR_ESYNCF_Pos)                /*!< 0x00000008 */
N#define CRS_ISR_ESYNCF            CRS_ISR_ESYNCF_Msk                           /*!< Expected SYNC flag */
N#define CRS_ISR_SYNCERR_Pos       (8U)
N#define CRS_ISR_SYNCERR_Msk       (0x1UL << CRS_ISR_SYNCERR_Pos)               /*!< 0x00000100 */
N#define CRS_ISR_SYNCERR           CRS_ISR_SYNCERR_Msk                          /*!< SYNC error */
N#define CRS_ISR_SYNCMISS_Pos      (9U)
N#define CRS_ISR_SYNCMISS_Msk      (0x1UL << CRS_ISR_SYNCMISS_Pos)              /*!< 0x00000200 */
N#define CRS_ISR_SYNCMISS          CRS_ISR_SYNCMISS_Msk                         /*!< SYNC missed */
N#define CRS_ISR_TRIMOVF_Pos       (10U)
N#define CRS_ISR_TRIMOVF_Msk       (0x1UL << CRS_ISR_TRIMOVF_Pos)               /*!< 0x00000400 */
N#define CRS_ISR_TRIMOVF           CRS_ISR_TRIMOVF_Msk                          /*!< Trimming overflow or underflow */
N#define CRS_ISR_FEDIR_Pos         (15U)
N#define CRS_ISR_FEDIR_Msk         (0x1UL << CRS_ISR_FEDIR_Pos)                 /*!< 0x00008000 */
N#define CRS_ISR_FEDIR             CRS_ISR_FEDIR_Msk                            /*!< Frequency error direction */
N#define CRS_ISR_FECAP_Pos         (16U)
N#define CRS_ISR_FECAP_Msk         (0xFFFFUL << CRS_ISR_FECAP_Pos)              /*!< 0xFFFF0000 */
N#define CRS_ISR_FECAP             CRS_ISR_FECAP_Msk                            /*!< Frequency error capture */
N
N/*******************  Bit definition for CRS_ICR register  *********************/
N#define CRS_ICR_SYNCOKC_Pos       (0U)
N#define CRS_ICR_SYNCOKC_Msk       (0x1UL << CRS_ICR_SYNCOKC_Pos)               /*!< 0x00000001 */
N#define CRS_ICR_SYNCOKC           CRS_ICR_SYNCOKC_Msk                          /*!< SYNC event OK clear flag */
N#define CRS_ICR_SYNCWARNC_Pos     (1U)
N#define CRS_ICR_SYNCWARNC_Msk     (0x1UL << CRS_ICR_SYNCWARNC_Pos)             /*!< 0x00000002 */
N#define CRS_ICR_SYNCWARNC         CRS_ICR_SYNCWARNC_Msk                        /*!< SYNC warning clear flag */
N#define CRS_ICR_ERRC_Pos          (2U)
N#define CRS_ICR_ERRC_Msk          (0x1UL << CRS_ICR_ERRC_Pos)                  /*!< 0x00000004 */
N#define CRS_ICR_ERRC              CRS_ICR_ERRC_Msk                             /*!< Error clear flag */
N#define CRS_ICR_ESYNCC_Pos        (3U)
N#define CRS_ICR_ESYNCC_Msk        (0x1UL << CRS_ICR_ESYNCC_Pos)                /*!< 0x00000008 */
N#define CRS_ICR_ESYNCC            CRS_ICR_ESYNCC_Msk                           /*!< Expected SYNC clear flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Digital to Analog Converter                           */
N/*                                                                            */
N/******************************************************************************/
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32L4 serie)
N */
N#define DAC_CHANNEL2_SUPPORT                           /*!< DAC feature available only on specific devices: DAC channel 2 available */
N
N/********************  Bit definition for DAC_CR register  ********************/
N#define DAC_CR_EN1_Pos              (0U)
N#define DAC_CR_EN1_Msk              (0x1UL << DAC_CR_EN1_Pos)                  /*!< 0x00000001 */
N#define DAC_CR_EN1                  DAC_CR_EN1_Msk                             /*!<DAC channel1 enable */
N#define DAC_CR_TEN1_Pos             (2U)
N#define DAC_CR_TEN1_Msk             (0x1UL << DAC_CR_TEN1_Pos)                 /*!< 0x00000004 */
N#define DAC_CR_TEN1                 DAC_CR_TEN1_Msk                            /*!<DAC channel1 Trigger enable */
N
N#define DAC_CR_TSEL1_Pos            (3U)
N#define DAC_CR_TSEL1_Msk            (0x7UL << DAC_CR_TSEL1_Pos)                /*!< 0x00000038 */
N#define DAC_CR_TSEL1                DAC_CR_TSEL1_Msk                           /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define DAC_CR_TSEL1_0              (0x1UL << DAC_CR_TSEL1_Pos)                /*!< 0x00000008 */
N#define DAC_CR_TSEL1_1              (0x2UL << DAC_CR_TSEL1_Pos)                /*!< 0x00000010 */
N#define DAC_CR_TSEL1_2              (0x4UL << DAC_CR_TSEL1_Pos)                /*!< 0x00000020 */
N
N#define DAC_CR_WAVE1_Pos            (6U)
N#define DAC_CR_WAVE1_Msk            (0x3UL << DAC_CR_WAVE1_Pos)                /*!< 0x000000C0 */
N#define DAC_CR_WAVE1                DAC_CR_WAVE1_Msk                           /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define DAC_CR_WAVE1_0              (0x1UL << DAC_CR_WAVE1_Pos)                /*!< 0x00000040 */
N#define DAC_CR_WAVE1_1              (0x2UL << DAC_CR_WAVE1_Pos)                /*!< 0x00000080 */
N
N#define DAC_CR_MAMP1_Pos            (8U)
N#define DAC_CR_MAMP1_Msk            (0xFUL << DAC_CR_MAMP1_Pos)                /*!< 0x00000F00 */
N#define DAC_CR_MAMP1                DAC_CR_MAMP1_Msk                           /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define DAC_CR_MAMP1_0              (0x1UL << DAC_CR_MAMP1_Pos)                /*!< 0x00000100 */
N#define DAC_CR_MAMP1_1              (0x2UL << DAC_CR_MAMP1_Pos)                /*!< 0x00000200 */
N#define DAC_CR_MAMP1_2              (0x4UL << DAC_CR_MAMP1_Pos)                /*!< 0x00000400 */
N#define DAC_CR_MAMP1_3              (0x8UL << DAC_CR_MAMP1_Pos)                /*!< 0x00000800 */
N
N#define DAC_CR_DMAEN1_Pos           (12U)
N#define DAC_CR_DMAEN1_Msk           (0x1UL << DAC_CR_DMAEN1_Pos)               /*!< 0x00001000 */
N#define DAC_CR_DMAEN1               DAC_CR_DMAEN1_Msk                          /*!<DAC channel1 DMA enable */
N#define DAC_CR_DMAUDRIE1_Pos        (13U)
N#define DAC_CR_DMAUDRIE1_Msk        (0x1UL << DAC_CR_DMAUDRIE1_Pos)            /*!< 0x00002000 */
N#define DAC_CR_DMAUDRIE1            DAC_CR_DMAUDRIE1_Msk                       /*!<DAC channel 1 DMA underrun interrupt enable  >*/
N#define DAC_CR_CEN1_Pos             (14U)
N#define DAC_CR_CEN1_Msk             (0x1UL << DAC_CR_CEN1_Pos)                 /*!< 0x00004000 */
N#define DAC_CR_CEN1                 DAC_CR_CEN1_Msk                            /*!<DAC channel 1 calibration enable >*/
N
N#define DAC_CR_EN2_Pos              (16U)
N#define DAC_CR_EN2_Msk              (0x1UL << DAC_CR_EN2_Pos)                  /*!< 0x00010000 */
N#define DAC_CR_EN2                  DAC_CR_EN2_Msk                             /*!<DAC channel2 enable */
N#define DAC_CR_TEN2_Pos             (18U)
N#define DAC_CR_TEN2_Msk             (0x1UL << DAC_CR_TEN2_Pos)                 /*!< 0x00040000 */
N#define DAC_CR_TEN2                 DAC_CR_TEN2_Msk                            /*!<DAC channel2 Trigger enable */
N
N#define DAC_CR_TSEL2_Pos            (19U)
N#define DAC_CR_TSEL2_Msk            (0x7UL << DAC_CR_TSEL2_Pos)                /*!< 0x00380000 */
N#define DAC_CR_TSEL2                DAC_CR_TSEL2_Msk                           /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define DAC_CR_TSEL2_0              (0x1UL << DAC_CR_TSEL2_Pos)                /*!< 0x00080000 */
N#define DAC_CR_TSEL2_1              (0x2UL << DAC_CR_TSEL2_Pos)                /*!< 0x00100000 */
N#define DAC_CR_TSEL2_2              (0x4UL << DAC_CR_TSEL2_Pos)                /*!< 0x00200000 */
N
N#define DAC_CR_WAVE2_Pos            (22U)
N#define DAC_CR_WAVE2_Msk            (0x3UL << DAC_CR_WAVE2_Pos)                /*!< 0x00C00000 */
N#define DAC_CR_WAVE2                DAC_CR_WAVE2_Msk                           /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define DAC_CR_WAVE2_0              (0x1UL << DAC_CR_WAVE2_Pos)                /*!< 0x00400000 */
N#define DAC_CR_WAVE2_1              (0x2UL << DAC_CR_WAVE2_Pos)                /*!< 0x00800000 */
N
N#define DAC_CR_MAMP2_Pos            (24U)
N#define DAC_CR_MAMP2_Msk            (0xFUL << DAC_CR_MAMP2_Pos)                /*!< 0x0F000000 */
N#define DAC_CR_MAMP2                DAC_CR_MAMP2_Msk                           /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define DAC_CR_MAMP2_0              (0x1UL << DAC_CR_MAMP2_Pos)                /*!< 0x01000000 */
N#define DAC_CR_MAMP2_1              (0x2UL << DAC_CR_MAMP2_Pos)                /*!< 0x02000000 */
N#define DAC_CR_MAMP2_2              (0x4UL << DAC_CR_MAMP2_Pos)                /*!< 0x04000000 */
N#define DAC_CR_MAMP2_3              (0x8UL << DAC_CR_MAMP2_Pos)                /*!< 0x08000000 */
N
N#define DAC_CR_DMAEN2_Pos           (28U)
N#define DAC_CR_DMAEN2_Msk           (0x1UL << DAC_CR_DMAEN2_Pos)               /*!< 0x10000000 */
N#define DAC_CR_DMAEN2               DAC_CR_DMAEN2_Msk                          /*!<DAC channel2 DMA enabled */
N#define DAC_CR_DMAUDRIE2_Pos        (29U)
N#define DAC_CR_DMAUDRIE2_Msk        (0x1UL << DAC_CR_DMAUDRIE2_Pos)            /*!< 0x20000000 */
N#define DAC_CR_DMAUDRIE2            DAC_CR_DMAUDRIE2_Msk                       /*!<DAC channel2 DMA underrun interrupt enable  >*/
N#define DAC_CR_CEN2_Pos             (30U)
N#define DAC_CR_CEN2_Msk             (0x1UL << DAC_CR_CEN2_Pos)                 /*!< 0x40000000 */
N#define DAC_CR_CEN2                 DAC_CR_CEN2_Msk                            /*!<DAC channel2 calibration enable >*/
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define DAC_SWTRIGR_SWTRIG1_Pos     (0U)
N#define DAC_SWTRIGR_SWTRIG1_Msk     (0x1UL << DAC_SWTRIGR_SWTRIG1_Pos)         /*!< 0x00000001 */
N#define DAC_SWTRIGR_SWTRIG1         DAC_SWTRIGR_SWTRIG1_Msk                    /*!<DAC channel1 software trigger */
N#define DAC_SWTRIGR_SWTRIG2_Pos     (1U)
N#define DAC_SWTRIGR_SWTRIG2_Msk     (0x1UL << DAC_SWTRIGR_SWTRIG2_Pos)         /*!< 0x00000002 */
N#define DAC_SWTRIGR_SWTRIG2         DAC_SWTRIGR_SWTRIG2_Msk                    /*!<DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define DAC_DHR12R1_DACC1DHR_Pos    (0U)
N#define DAC_DHR12R1_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12R1_DACC1DHR_Pos)      /*!< 0x00000FFF */
N#define DAC_DHR12R1_DACC1DHR        DAC_DHR12R1_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define DAC_DHR12L1_DACC1DHR_Pos    (4U)
N#define DAC_DHR12L1_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12L1_DACC1DHR_Pos)      /*!< 0x0000FFF0 */
N#define DAC_DHR12L1_DACC1DHR        DAC_DHR12L1_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define DAC_DHR8R1_DACC1DHR_Pos     (0U)
N#define DAC_DHR8R1_DACC1DHR_Msk     (0xFFUL << DAC_DHR8R1_DACC1DHR_Pos)        /*!< 0x000000FF */
N#define DAC_DHR8R1_DACC1DHR         DAC_DHR8R1_DACC1DHR_Msk                    /*!<DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define DAC_DHR12R2_DACC2DHR_Pos    (0U)
N#define DAC_DHR12R2_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12R2_DACC2DHR_Pos)      /*!< 0x00000FFF */
N#define DAC_DHR12R2_DACC2DHR        DAC_DHR12R2_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define DAC_DHR12L2_DACC2DHR_Pos    (4U)
N#define DAC_DHR12L2_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12L2_DACC2DHR_Pos)      /*!< 0x0000FFF0 */
N#define DAC_DHR12L2_DACC2DHR        DAC_DHR12L2_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define DAC_DHR8R2_DACC2DHR_Pos     (0U)
N#define DAC_DHR8R2_DACC2DHR_Msk     (0xFFUL << DAC_DHR8R2_DACC2DHR_Pos)        /*!< 0x000000FF */
N#define DAC_DHR8R2_DACC2DHR         DAC_DHR8R2_DACC2DHR_Msk                    /*!<DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define DAC_DHR12RD_DACC1DHR_Pos    (0U)
N#define DAC_DHR12RD_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12RD_DACC1DHR_Pos)      /*!< 0x00000FFF */
N#define DAC_DHR12RD_DACC1DHR        DAC_DHR12RD_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Right aligned data */
N#define DAC_DHR12RD_DACC2DHR_Pos    (16U)
N#define DAC_DHR12RD_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12RD_DACC2DHR_Pos)      /*!< 0x0FFF0000 */
N#define DAC_DHR12RD_DACC2DHR        DAC_DHR12RD_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define DAC_DHR12LD_DACC1DHR_Pos    (4U)
N#define DAC_DHR12LD_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12LD_DACC1DHR_Pos)      /*!< 0x0000FFF0 */
N#define DAC_DHR12LD_DACC1DHR        DAC_DHR12LD_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Left aligned data */
N#define DAC_DHR12LD_DACC2DHR_Pos    (20U)
N#define DAC_DHR12LD_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12LD_DACC2DHR_Pos)      /*!< 0xFFF00000 */
N#define DAC_DHR12LD_DACC2DHR        DAC_DHR12LD_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define DAC_DHR8RD_DACC1DHR_Pos     (0U)
N#define DAC_DHR8RD_DACC1DHR_Msk     (0xFFUL << DAC_DHR8RD_DACC1DHR_Pos)        /*!< 0x000000FF */
N#define DAC_DHR8RD_DACC1DHR         DAC_DHR8RD_DACC1DHR_Msk                    /*!<DAC channel1 8-bit Right aligned data */
N#define DAC_DHR8RD_DACC2DHR_Pos     (8U)
N#define DAC_DHR8RD_DACC2DHR_Msk     (0xFFUL << DAC_DHR8RD_DACC2DHR_Pos)        /*!< 0x0000FF00 */
N#define DAC_DHR8RD_DACC2DHR         DAC_DHR8RD_DACC2DHR_Msk                    /*!<DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define DAC_DOR1_DACC1DOR_Pos       (0U)
N#define DAC_DOR1_DACC1DOR_Msk       (0xFFFUL << DAC_DOR1_DACC1DOR_Pos)         /*!< 0x00000FFF */
N#define DAC_DOR1_DACC1DOR           DAC_DOR1_DACC1DOR_Msk                      /*!<DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define DAC_DOR2_DACC2DOR_Pos       (0U)
N#define DAC_DOR2_DACC2DOR_Msk       (0xFFFUL << DAC_DOR2_DACC2DOR_Pos)         /*!< 0x00000FFF */
N#define DAC_DOR2_DACC2DOR           DAC_DOR2_DACC2DOR_Msk                      /*!<DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define DAC_SR_DMAUDR1_Pos          (13U)
N#define DAC_SR_DMAUDR1_Msk          (0x1UL << DAC_SR_DMAUDR1_Pos)              /*!< 0x00002000 */
N#define DAC_SR_DMAUDR1              DAC_SR_DMAUDR1_Msk                         /*!<DAC channel1 DMA underrun flag */
N#define DAC_SR_CAL_FLAG1_Pos        (14U)
N#define DAC_SR_CAL_FLAG1_Msk        (0x1UL << DAC_SR_CAL_FLAG1_Pos)            /*!< 0x00004000 */
N#define DAC_SR_CAL_FLAG1            DAC_SR_CAL_FLAG1_Msk                       /*!<DAC channel1 calibration offset status */
N#define DAC_SR_BWST1_Pos            (15U)
N#define DAC_SR_BWST1_Msk            (0x1UL << DAC_SR_BWST1_Pos)                /*!< 0x00008000 */
N#define DAC_SR_BWST1                DAC_SR_BWST1_Msk                           /*!<DAC channel1 busy writing sample time flag */
N
N#define DAC_SR_DMAUDR2_Pos          (29U)
N#define DAC_SR_DMAUDR2_Msk          (0x1UL << DAC_SR_DMAUDR2_Pos)              /*!< 0x20000000 */
N#define DAC_SR_DMAUDR2              DAC_SR_DMAUDR2_Msk                         /*!<DAC channel2 DMA underrun flag */
N#define DAC_SR_CAL_FLAG2_Pos        (30U)
N#define DAC_SR_CAL_FLAG2_Msk        (0x1UL << DAC_SR_CAL_FLAG2_Pos)            /*!< 0x40000000 */
N#define DAC_SR_CAL_FLAG2            DAC_SR_CAL_FLAG2_Msk                       /*!<DAC channel2 calibration offset status */
N#define DAC_SR_BWST2_Pos            (31U)
N#define DAC_SR_BWST2_Msk            (0x1UL << DAC_SR_BWST2_Pos)                /*!< 0x80000000 */
N#define DAC_SR_BWST2                DAC_SR_BWST2_Msk                           /*!<DAC channel2 busy writing sample time flag */
N
N/*******************  Bit definition for DAC_CCR register  ********************/
N#define DAC_CCR_OTRIM1_Pos          (0U)
N#define DAC_CCR_OTRIM1_Msk          (0x1FUL << DAC_CCR_OTRIM1_Pos)             /*!< 0x0000001F */
N#define DAC_CCR_OTRIM1              DAC_CCR_OTRIM1_Msk                         /*!<DAC channel1 offset trimming value */
N#define DAC_CCR_OTRIM2_Pos          (16U)
N#define DAC_CCR_OTRIM2_Msk          (0x1FUL << DAC_CCR_OTRIM2_Pos)             /*!< 0x001F0000 */
N#define DAC_CCR_OTRIM2              DAC_CCR_OTRIM2_Msk                         /*!<DAC channel2 offset trimming value */
N
N/*******************  Bit definition for DAC_MCR register  *******************/
N#define DAC_MCR_MODE1_Pos           (0U)
N#define DAC_MCR_MODE1_Msk           (0x7UL << DAC_MCR_MODE1_Pos)               /*!< 0x00000007 */
N#define DAC_MCR_MODE1               DAC_MCR_MODE1_Msk                          /*!<MODE1[2:0] (DAC channel1 mode) */
N#define DAC_MCR_MODE1_0             (0x1UL << DAC_MCR_MODE1_Pos)               /*!< 0x00000001 */
N#define DAC_MCR_MODE1_1             (0x2UL << DAC_MCR_MODE1_Pos)               /*!< 0x00000002 */
N#define DAC_MCR_MODE1_2             (0x4UL << DAC_MCR_MODE1_Pos)               /*!< 0x00000004 */
N
N#define DAC_MCR_MODE2_Pos           (16U)
N#define DAC_MCR_MODE2_Msk           (0x7UL << DAC_MCR_MODE2_Pos)               /*!< 0x00070000 */
N#define DAC_MCR_MODE2               DAC_MCR_MODE2_Msk                          /*!<MODE2[2:0] (DAC channel2 mode) */
N#define DAC_MCR_MODE2_0             (0x1UL << DAC_MCR_MODE2_Pos)               /*!< 0x00010000 */
N#define DAC_MCR_MODE2_1             (0x2UL << DAC_MCR_MODE2_Pos)               /*!< 0x00020000 */
N#define DAC_MCR_MODE2_2             (0x4UL << DAC_MCR_MODE2_Pos)               /*!< 0x00040000 */
N
N/******************  Bit definition for DAC_SHSR1 register  ******************/
N#define DAC_SHSR1_TSAMPLE1_Pos      (0U)
N#define DAC_SHSR1_TSAMPLE1_Msk      (0x3FFUL << DAC_SHSR1_TSAMPLE1_Pos)        /*!< 0x000003FF */
N#define DAC_SHSR1_TSAMPLE1          DAC_SHSR1_TSAMPLE1_Msk                     /*!<DAC channel1 sample time */
N
N/******************  Bit definition for DAC_SHSR2 register  ******************/
N#define DAC_SHSR2_TSAMPLE2_Pos      (0U)
N#define DAC_SHSR2_TSAMPLE2_Msk      (0x3FFUL << DAC_SHSR2_TSAMPLE2_Pos)        /*!< 0x000003FF */
N#define DAC_SHSR2_TSAMPLE2          DAC_SHSR2_TSAMPLE2_Msk                     /*!<DAC channel2 sample time */
N
N/******************  Bit definition for DAC_SHHR register  ******************/
N#define DAC_SHHR_THOLD1_Pos         (0U)
N#define DAC_SHHR_THOLD1_Msk         (0x3FFUL << DAC_SHHR_THOLD1_Pos)           /*!< 0x000003FF */
N#define DAC_SHHR_THOLD1             DAC_SHHR_THOLD1_Msk                        /*!<DAC channel1 hold time */
N#define DAC_SHHR_THOLD2_Pos         (16U)
N#define DAC_SHHR_THOLD2_Msk         (0x3FFUL << DAC_SHHR_THOLD2_Pos)           /*!< 0x03FF0000 */
N#define DAC_SHHR_THOLD2             DAC_SHHR_THOLD2_Msk                        /*!<DAC channel2 hold time */
N
N/******************  Bit definition for DAC_SHRR register  ******************/
N#define DAC_SHRR_TREFRESH1_Pos      (0U)
N#define DAC_SHRR_TREFRESH1_Msk      (0xFFUL << DAC_SHRR_TREFRESH1_Pos)         /*!< 0x000000FF */
N#define DAC_SHRR_TREFRESH1          DAC_SHRR_TREFRESH1_Msk                     /*!<DAC channel1 refresh time */
N#define DAC_SHRR_TREFRESH2_Pos      (16U)
N#define DAC_SHRR_TREFRESH2_Msk      (0xFFUL << DAC_SHRR_TREFRESH2_Pos)         /*!< 0x00FF0000 */
N#define DAC_SHRR_TREFRESH2          DAC_SHRR_TREFRESH2_Msk                     /*!<DAC channel2 refresh time */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           DMA Controller (DMA)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define DMA_ISR_GIF1_Pos       (0U)
N#define DMA_ISR_GIF1_Msk       (0x1UL << DMA_ISR_GIF1_Pos)                     /*!< 0x00000001 */
N#define DMA_ISR_GIF1           DMA_ISR_GIF1_Msk                                /*!< Channel 1 Global interrupt flag */
N#define DMA_ISR_TCIF1_Pos      (1U)
N#define DMA_ISR_TCIF1_Msk      (0x1UL << DMA_ISR_TCIF1_Pos)                    /*!< 0x00000002 */
N#define DMA_ISR_TCIF1          DMA_ISR_TCIF1_Msk                               /*!< Channel 1 Transfer Complete flag */
N#define DMA_ISR_HTIF1_Pos      (2U)
N#define DMA_ISR_HTIF1_Msk      (0x1UL << DMA_ISR_HTIF1_Pos)                    /*!< 0x00000004 */
N#define DMA_ISR_HTIF1          DMA_ISR_HTIF1_Msk                               /*!< Channel 1 Half Transfer flag */
N#define DMA_ISR_TEIF1_Pos      (3U)
N#define DMA_ISR_TEIF1_Msk      (0x1UL << DMA_ISR_TEIF1_Pos)                    /*!< 0x00000008 */
N#define DMA_ISR_TEIF1          DMA_ISR_TEIF1_Msk                               /*!< Channel 1 Transfer Error flag */
N#define DMA_ISR_GIF2_Pos       (4U)
N#define DMA_ISR_GIF2_Msk       (0x1UL << DMA_ISR_GIF2_Pos)                     /*!< 0x00000010 */
N#define DMA_ISR_GIF2           DMA_ISR_GIF2_Msk                                /*!< Channel 2 Global interrupt flag */
N#define DMA_ISR_TCIF2_Pos      (5U)
N#define DMA_ISR_TCIF2_Msk      (0x1UL << DMA_ISR_TCIF2_Pos)                    /*!< 0x00000020 */
N#define DMA_ISR_TCIF2          DMA_ISR_TCIF2_Msk                               /*!< Channel 2 Transfer Complete flag */
N#define DMA_ISR_HTIF2_Pos      (6U)
N#define DMA_ISR_HTIF2_Msk      (0x1UL << DMA_ISR_HTIF2_Pos)                    /*!< 0x00000040 */
N#define DMA_ISR_HTIF2          DMA_ISR_HTIF2_Msk                               /*!< Channel 2 Half Transfer flag */
N#define DMA_ISR_TEIF2_Pos      (7U)
N#define DMA_ISR_TEIF2_Msk      (0x1UL << DMA_ISR_TEIF2_Pos)                    /*!< 0x00000080 */
N#define DMA_ISR_TEIF2          DMA_ISR_TEIF2_Msk                               /*!< Channel 2 Transfer Error flag */
N#define DMA_ISR_GIF3_Pos       (8U)
N#define DMA_ISR_GIF3_Msk       (0x1UL << DMA_ISR_GIF3_Pos)                     /*!< 0x00000100 */
N#define DMA_ISR_GIF3           DMA_ISR_GIF3_Msk                                /*!< Channel 3 Global interrupt flag */
N#define DMA_ISR_TCIF3_Pos      (9U)
N#define DMA_ISR_TCIF3_Msk      (0x1UL << DMA_ISR_TCIF3_Pos)                    /*!< 0x00000200 */
N#define DMA_ISR_TCIF3          DMA_ISR_TCIF3_Msk                               /*!< Channel 3 Transfer Complete flag */
N#define DMA_ISR_HTIF3_Pos      (10U)
N#define DMA_ISR_HTIF3_Msk      (0x1UL << DMA_ISR_HTIF3_Pos)                    /*!< 0x00000400 */
N#define DMA_ISR_HTIF3          DMA_ISR_HTIF3_Msk                               /*!< Channel 3 Half Transfer flag */
N#define DMA_ISR_TEIF3_Pos      (11U)
N#define DMA_ISR_TEIF3_Msk      (0x1UL << DMA_ISR_TEIF3_Pos)                    /*!< 0x00000800 */
N#define DMA_ISR_TEIF3          DMA_ISR_TEIF3_Msk                               /*!< Channel 3 Transfer Error flag */
N#define DMA_ISR_GIF4_Pos       (12U)
N#define DMA_ISR_GIF4_Msk       (0x1UL << DMA_ISR_GIF4_Pos)                     /*!< 0x00001000 */
N#define DMA_ISR_GIF4           DMA_ISR_GIF4_Msk                                /*!< Channel 4 Global interrupt flag */
N#define DMA_ISR_TCIF4_Pos      (13U)
N#define DMA_ISR_TCIF4_Msk      (0x1UL << DMA_ISR_TCIF4_Pos)                    /*!< 0x00002000 */
N#define DMA_ISR_TCIF4          DMA_ISR_TCIF4_Msk                               /*!< Channel 4 Transfer Complete flag */
N#define DMA_ISR_HTIF4_Pos      (14U)
N#define DMA_ISR_HTIF4_Msk      (0x1UL << DMA_ISR_HTIF4_Pos)                    /*!< 0x00004000 */
N#define DMA_ISR_HTIF4          DMA_ISR_HTIF4_Msk                               /*!< Channel 4 Half Transfer flag */
N#define DMA_ISR_TEIF4_Pos      (15U)
N#define DMA_ISR_TEIF4_Msk      (0x1UL << DMA_ISR_TEIF4_Pos)                    /*!< 0x00008000 */
N#define DMA_ISR_TEIF4          DMA_ISR_TEIF4_Msk                               /*!< Channel 4 Transfer Error flag */
N#define DMA_ISR_GIF5_Pos       (16U)
N#define DMA_ISR_GIF5_Msk       (0x1UL << DMA_ISR_GIF5_Pos)                     /*!< 0x00010000 */
N#define DMA_ISR_GIF5           DMA_ISR_GIF5_Msk                                /*!< Channel 5 Global interrupt flag */
N#define DMA_ISR_TCIF5_Pos      (17U)
N#define DMA_ISR_TCIF5_Msk      (0x1UL << DMA_ISR_TCIF5_Pos)                    /*!< 0x00020000 */
N#define DMA_ISR_TCIF5          DMA_ISR_TCIF5_Msk                               /*!< Channel 5 Transfer Complete flag */
N#define DMA_ISR_HTIF5_Pos      (18U)
N#define DMA_ISR_HTIF5_Msk      (0x1UL << DMA_ISR_HTIF5_Pos)                    /*!< 0x00040000 */
N#define DMA_ISR_HTIF5          DMA_ISR_HTIF5_Msk                               /*!< Channel 5 Half Transfer flag */
N#define DMA_ISR_TEIF5_Pos      (19U)
N#define DMA_ISR_TEIF5_Msk      (0x1UL << DMA_ISR_TEIF5_Pos)                    /*!< 0x00080000 */
N#define DMA_ISR_TEIF5          DMA_ISR_TEIF5_Msk                               /*!< Channel 5 Transfer Error flag */
N#define DMA_ISR_GIF6_Pos       (20U)
N#define DMA_ISR_GIF6_Msk       (0x1UL << DMA_ISR_GIF6_Pos)                     /*!< 0x00100000 */
N#define DMA_ISR_GIF6           DMA_ISR_GIF6_Msk                                /*!< Channel 6 Global interrupt flag */
N#define DMA_ISR_TCIF6_Pos      (21U)
N#define DMA_ISR_TCIF6_Msk      (0x1UL << DMA_ISR_TCIF6_Pos)                    /*!< 0x00200000 */
N#define DMA_ISR_TCIF6          DMA_ISR_TCIF6_Msk                               /*!< Channel 6 Transfer Complete flag */
N#define DMA_ISR_HTIF6_Pos      (22U)
N#define DMA_ISR_HTIF6_Msk      (0x1UL << DMA_ISR_HTIF6_Pos)                    /*!< 0x00400000 */
N#define DMA_ISR_HTIF6          DMA_ISR_HTIF6_Msk                               /*!< Channel 6 Half Transfer flag */
N#define DMA_ISR_TEIF6_Pos      (23U)
N#define DMA_ISR_TEIF6_Msk      (0x1UL << DMA_ISR_TEIF6_Pos)                    /*!< 0x00800000 */
N#define DMA_ISR_TEIF6          DMA_ISR_TEIF6_Msk                               /*!< Channel 6 Transfer Error flag */
N#define DMA_ISR_GIF7_Pos       (24U)
N#define DMA_ISR_GIF7_Msk       (0x1UL << DMA_ISR_GIF7_Pos)                     /*!< 0x01000000 */
N#define DMA_ISR_GIF7           DMA_ISR_GIF7_Msk                                /*!< Channel 7 Global interrupt flag */
N#define DMA_ISR_TCIF7_Pos      (25U)
N#define DMA_ISR_TCIF7_Msk      (0x1UL << DMA_ISR_TCIF7_Pos)                    /*!< 0x02000000 */
N#define DMA_ISR_TCIF7          DMA_ISR_TCIF7_Msk                               /*!< Channel 7 Transfer Complete flag */
N#define DMA_ISR_HTIF7_Pos      (26U)
N#define DMA_ISR_HTIF7_Msk      (0x1UL << DMA_ISR_HTIF7_Pos)                    /*!< 0x04000000 */
N#define DMA_ISR_HTIF7          DMA_ISR_HTIF7_Msk                               /*!< Channel 7 Half Transfer flag */
N#define DMA_ISR_TEIF7_Pos      (27U)
N#define DMA_ISR_TEIF7_Msk      (0x1UL << DMA_ISR_TEIF7_Pos)                    /*!< 0x08000000 */
N#define DMA_ISR_TEIF7          DMA_ISR_TEIF7_Msk                               /*!< Channel 7 Transfer Error flag */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define DMA_IFCR_CGIF1_Pos     (0U)
N#define DMA_IFCR_CGIF1_Msk     (0x1UL << DMA_IFCR_CGIF1_Pos)                   /*!< 0x00000001 */
N#define DMA_IFCR_CGIF1         DMA_IFCR_CGIF1_Msk                              /*!< Channel 1 Global interrupt clearr */
N#define DMA_IFCR_CTCIF1_Pos    (1U)
N#define DMA_IFCR_CTCIF1_Msk    (0x1UL << DMA_IFCR_CTCIF1_Pos)                  /*!< 0x00000002 */
N#define DMA_IFCR_CTCIF1        DMA_IFCR_CTCIF1_Msk                             /*!< Channel 1 Transfer Complete clear */
N#define DMA_IFCR_CHTIF1_Pos    (2U)
N#define DMA_IFCR_CHTIF1_Msk    (0x1UL << DMA_IFCR_CHTIF1_Pos)                  /*!< 0x00000004 */
N#define DMA_IFCR_CHTIF1        DMA_IFCR_CHTIF1_Msk                             /*!< Channel 1 Half Transfer clear */
N#define DMA_IFCR_CTEIF1_Pos    (3U)
N#define DMA_IFCR_CTEIF1_Msk    (0x1UL << DMA_IFCR_CTEIF1_Pos)                  /*!< 0x00000008 */
N#define DMA_IFCR_CTEIF1        DMA_IFCR_CTEIF1_Msk                             /*!< Channel 1 Transfer Error clear */
N#define DMA_IFCR_CGIF2_Pos     (4U)
N#define DMA_IFCR_CGIF2_Msk     (0x1UL << DMA_IFCR_CGIF2_Pos)                   /*!< 0x00000010 */
N#define DMA_IFCR_CGIF2         DMA_IFCR_CGIF2_Msk                              /*!< Channel 2 Global interrupt clear */
N#define DMA_IFCR_CTCIF2_Pos    (5U)
N#define DMA_IFCR_CTCIF2_Msk    (0x1UL << DMA_IFCR_CTCIF2_Pos)                  /*!< 0x00000020 */
N#define DMA_IFCR_CTCIF2        DMA_IFCR_CTCIF2_Msk                             /*!< Channel 2 Transfer Complete clear */
N#define DMA_IFCR_CHTIF2_Pos    (6U)
N#define DMA_IFCR_CHTIF2_Msk    (0x1UL << DMA_IFCR_CHTIF2_Pos)                  /*!< 0x00000040 */
N#define DMA_IFCR_CHTIF2        DMA_IFCR_CHTIF2_Msk                             /*!< Channel 2 Half Transfer clear */
N#define DMA_IFCR_CTEIF2_Pos    (7U)
N#define DMA_IFCR_CTEIF2_Msk    (0x1UL << DMA_IFCR_CTEIF2_Pos)                  /*!< 0x00000080 */
N#define DMA_IFCR_CTEIF2        DMA_IFCR_CTEIF2_Msk                             /*!< Channel 2 Transfer Error clear */
N#define DMA_IFCR_CGIF3_Pos     (8U)
N#define DMA_IFCR_CGIF3_Msk     (0x1UL << DMA_IFCR_CGIF3_Pos)                   /*!< 0x00000100 */
N#define DMA_IFCR_CGIF3         DMA_IFCR_CGIF3_Msk                              /*!< Channel 3 Global interrupt clear */
N#define DMA_IFCR_CTCIF3_Pos    (9U)
N#define DMA_IFCR_CTCIF3_Msk    (0x1UL << DMA_IFCR_CTCIF3_Pos)                  /*!< 0x00000200 */
N#define DMA_IFCR_CTCIF3        DMA_IFCR_CTCIF3_Msk                             /*!< Channel 3 Transfer Complete clear */
N#define DMA_IFCR_CHTIF3_Pos    (10U)
N#define DMA_IFCR_CHTIF3_Msk    (0x1UL << DMA_IFCR_CHTIF3_Pos)                  /*!< 0x00000400 */
N#define DMA_IFCR_CHTIF3        DMA_IFCR_CHTIF3_Msk                             /*!< Channel 3 Half Transfer clear */
N#define DMA_IFCR_CTEIF3_Pos    (11U)
N#define DMA_IFCR_CTEIF3_Msk    (0x1UL << DMA_IFCR_CTEIF3_Pos)                  /*!< 0x00000800 */
N#define DMA_IFCR_CTEIF3        DMA_IFCR_CTEIF3_Msk                             /*!< Channel 3 Transfer Error clear */
N#define DMA_IFCR_CGIF4_Pos     (12U)
N#define DMA_IFCR_CGIF4_Msk     (0x1UL << DMA_IFCR_CGIF4_Pos)                   /*!< 0x00001000 */
N#define DMA_IFCR_CGIF4         DMA_IFCR_CGIF4_Msk                              /*!< Channel 4 Global interrupt clear */
N#define DMA_IFCR_CTCIF4_Pos    (13U)
N#define DMA_IFCR_CTCIF4_Msk    (0x1UL << DMA_IFCR_CTCIF4_Pos)                  /*!< 0x00002000 */
N#define DMA_IFCR_CTCIF4        DMA_IFCR_CTCIF4_Msk                             /*!< Channel 4 Transfer Complete clear */
N#define DMA_IFCR_CHTIF4_Pos    (14U)
N#define DMA_IFCR_CHTIF4_Msk    (0x1UL << DMA_IFCR_CHTIF4_Pos)                  /*!< 0x00004000 */
N#define DMA_IFCR_CHTIF4        DMA_IFCR_CHTIF4_Msk                             /*!< Channel 4 Half Transfer clear */
N#define DMA_IFCR_CTEIF4_Pos    (15U)
N#define DMA_IFCR_CTEIF4_Msk    (0x1UL << DMA_IFCR_CTEIF4_Pos)                  /*!< 0x00008000 */
N#define DMA_IFCR_CTEIF4        DMA_IFCR_CTEIF4_Msk                             /*!< Channel 4 Transfer Error clear */
N#define DMA_IFCR_CGIF5_Pos     (16U)
N#define DMA_IFCR_CGIF5_Msk     (0x1UL << DMA_IFCR_CGIF5_Pos)                   /*!< 0x00010000 */
N#define DMA_IFCR_CGIF5         DMA_IFCR_CGIF5_Msk                              /*!< Channel 5 Global interrupt clear */
N#define DMA_IFCR_CTCIF5_Pos    (17U)
N#define DMA_IFCR_CTCIF5_Msk    (0x1UL << DMA_IFCR_CTCIF5_Pos)                  /*!< 0x00020000 */
N#define DMA_IFCR_CTCIF5        DMA_IFCR_CTCIF5_Msk                             /*!< Channel 5 Transfer Complete clear */
N#define DMA_IFCR_CHTIF5_Pos    (18U)
N#define DMA_IFCR_CHTIF5_Msk    (0x1UL << DMA_IFCR_CHTIF5_Pos)                  /*!< 0x00040000 */
N#define DMA_IFCR_CHTIF5        DMA_IFCR_CHTIF5_Msk                             /*!< Channel 5 Half Transfer clear */
N#define DMA_IFCR_CTEIF5_Pos    (19U)
N#define DMA_IFCR_CTEIF5_Msk    (0x1UL << DMA_IFCR_CTEIF5_Pos)                  /*!< 0x00080000 */
N#define DMA_IFCR_CTEIF5        DMA_IFCR_CTEIF5_Msk                             /*!< Channel 5 Transfer Error clear */
N#define DMA_IFCR_CGIF6_Pos     (20U)
N#define DMA_IFCR_CGIF6_Msk     (0x1UL << DMA_IFCR_CGIF6_Pos)                   /*!< 0x00100000 */
N#define DMA_IFCR_CGIF6         DMA_IFCR_CGIF6_Msk                              /*!< Channel 6 Global interrupt clear */
N#define DMA_IFCR_CTCIF6_Pos    (21U)
N#define DMA_IFCR_CTCIF6_Msk    (0x1UL << DMA_IFCR_CTCIF6_Pos)                  /*!< 0x00200000 */
N#define DMA_IFCR_CTCIF6        DMA_IFCR_CTCIF6_Msk                             /*!< Channel 6 Transfer Complete clear */
N#define DMA_IFCR_CHTIF6_Pos    (22U)
N#define DMA_IFCR_CHTIF6_Msk    (0x1UL << DMA_IFCR_CHTIF6_Pos)                  /*!< 0x00400000 */
N#define DMA_IFCR_CHTIF6        DMA_IFCR_CHTIF6_Msk                             /*!< Channel 6 Half Transfer clear */
N#define DMA_IFCR_CTEIF6_Pos    (23U)
N#define DMA_IFCR_CTEIF6_Msk    (0x1UL << DMA_IFCR_CTEIF6_Pos)                  /*!< 0x00800000 */
N#define DMA_IFCR_CTEIF6        DMA_IFCR_CTEIF6_Msk                             /*!< Channel 6 Transfer Error clear */
N#define DMA_IFCR_CGIF7_Pos     (24U)
N#define DMA_IFCR_CGIF7_Msk     (0x1UL << DMA_IFCR_CGIF7_Pos)                   /*!< 0x01000000 */
N#define DMA_IFCR_CGIF7         DMA_IFCR_CGIF7_Msk                              /*!< Channel 7 Global interrupt clear */
N#define DMA_IFCR_CTCIF7_Pos    (25U)
N#define DMA_IFCR_CTCIF7_Msk    (0x1UL << DMA_IFCR_CTCIF7_Pos)                  /*!< 0x02000000 */
N#define DMA_IFCR_CTCIF7        DMA_IFCR_CTCIF7_Msk                             /*!< Channel 7 Transfer Complete clear */
N#define DMA_IFCR_CHTIF7_Pos    (26U)
N#define DMA_IFCR_CHTIF7_Msk    (0x1UL << DMA_IFCR_CHTIF7_Pos)                  /*!< 0x04000000 */
N#define DMA_IFCR_CHTIF7        DMA_IFCR_CHTIF7_Msk                             /*!< Channel 7 Half Transfer clear */
N#define DMA_IFCR_CTEIF7_Pos    (27U)
N#define DMA_IFCR_CTEIF7_Msk    (0x1UL << DMA_IFCR_CTEIF7_Pos)                  /*!< 0x08000000 */
N#define DMA_IFCR_CTEIF7        DMA_IFCR_CTEIF7_Msk                             /*!< Channel 7 Transfer Error clear */
N
N/*******************  Bit definition for DMA_CCR register  ********************/
N#define DMA_CCR_EN_Pos         (0U)
N#define DMA_CCR_EN_Msk         (0x1UL << DMA_CCR_EN_Pos)                       /*!< 0x00000001 */
N#define DMA_CCR_EN             DMA_CCR_EN_Msk                                  /*!< Channel enable                      */
N#define DMA_CCR_TCIE_Pos       (1U)
N#define DMA_CCR_TCIE_Msk       (0x1UL << DMA_CCR_TCIE_Pos)                     /*!< 0x00000002 */
N#define DMA_CCR_TCIE           DMA_CCR_TCIE_Msk                                /*!< Transfer complete interrupt enable  */
N#define DMA_CCR_HTIE_Pos       (2U)
N#define DMA_CCR_HTIE_Msk       (0x1UL << DMA_CCR_HTIE_Pos)                     /*!< 0x00000004 */
N#define DMA_CCR_HTIE           DMA_CCR_HTIE_Msk                                /*!< Half Transfer interrupt enable      */
N#define DMA_CCR_TEIE_Pos       (3U)
N#define DMA_CCR_TEIE_Msk       (0x1UL << DMA_CCR_TEIE_Pos)                     /*!< 0x00000008 */
N#define DMA_CCR_TEIE           DMA_CCR_TEIE_Msk                                /*!< Transfer error interrupt enable     */
N#define DMA_CCR_DIR_Pos        (4U)
N#define DMA_CCR_DIR_Msk        (0x1UL << DMA_CCR_DIR_Pos)                      /*!< 0x00000010 */
N#define DMA_CCR_DIR            DMA_CCR_DIR_Msk                                 /*!< Data transfer direction             */
N#define DMA_CCR_CIRC_Pos       (5U)
N#define DMA_CCR_CIRC_Msk       (0x1UL << DMA_CCR_CIRC_Pos)                     /*!< 0x00000020 */
N#define DMA_CCR_CIRC           DMA_CCR_CIRC_Msk                                /*!< Circular mode                       */
N#define DMA_CCR_PINC_Pos       (6U)
N#define DMA_CCR_PINC_Msk       (0x1UL << DMA_CCR_PINC_Pos)                     /*!< 0x00000040 */
N#define DMA_CCR_PINC           DMA_CCR_PINC_Msk                                /*!< Peripheral increment mode           */
N#define DMA_CCR_MINC_Pos       (7U)
N#define DMA_CCR_MINC_Msk       (0x1UL << DMA_CCR_MINC_Pos)                     /*!< 0x00000080 */
N#define DMA_CCR_MINC           DMA_CCR_MINC_Msk                                /*!< Memory increment mode               */
N
N#define DMA_CCR_PSIZE_Pos      (8U)
N#define DMA_CCR_PSIZE_Msk      (0x3UL << DMA_CCR_PSIZE_Pos)                    /*!< 0x00000300 */
N#define DMA_CCR_PSIZE          DMA_CCR_PSIZE_Msk                               /*!< PSIZE[1:0] bits (Peripheral size)   */
N#define DMA_CCR_PSIZE_0        (0x1UL << DMA_CCR_PSIZE_Pos)                    /*!< 0x00000100 */
N#define DMA_CCR_PSIZE_1        (0x2UL << DMA_CCR_PSIZE_Pos)                    /*!< 0x00000200 */
N
N#define DMA_CCR_MSIZE_Pos      (10U)
N#define DMA_CCR_MSIZE_Msk      (0x3UL << DMA_CCR_MSIZE_Pos)                    /*!< 0x00000C00 */
N#define DMA_CCR_MSIZE          DMA_CCR_MSIZE_Msk                               /*!< MSIZE[1:0] bits (Memory size)       */
N#define DMA_CCR_MSIZE_0        (0x1UL << DMA_CCR_MSIZE_Pos)                    /*!< 0x00000400 */
N#define DMA_CCR_MSIZE_1        (0x2UL << DMA_CCR_MSIZE_Pos)                    /*!< 0x00000800 */
N
N#define DMA_CCR_PL_Pos         (12U)
N#define DMA_CCR_PL_Msk         (0x3UL << DMA_CCR_PL_Pos)                       /*!< 0x00003000 */
N#define DMA_CCR_PL             DMA_CCR_PL_Msk                                  /*!< PL[1:0] bits(Channel Priority level)*/
N#define DMA_CCR_PL_0           (0x1UL << DMA_CCR_PL_Pos)                       /*!< 0x00001000 */
N#define DMA_CCR_PL_1           (0x2UL << DMA_CCR_PL_Pos)                       /*!< 0x00002000 */
N
N#define DMA_CCR_MEM2MEM_Pos    (14U)
N#define DMA_CCR_MEM2MEM_Msk    (0x1UL << DMA_CCR_MEM2MEM_Pos)                  /*!< 0x00004000 */
N#define DMA_CCR_MEM2MEM        DMA_CCR_MEM2MEM_Msk                             /*!< Memory to memory mode               */
N
N/******************  Bit definition for DMA_CNDTR register  *******************/
N#define DMA_CNDTR_NDT_Pos      (0U)
N#define DMA_CNDTR_NDT_Msk      (0xFFFFUL << DMA_CNDTR_NDT_Pos)                 /*!< 0x0000FFFF */
N#define DMA_CNDTR_NDT          DMA_CNDTR_NDT_Msk                               /*!< Number of data to Transfer          */
N
N/******************  Bit definition for DMA_CPAR register  ********************/
N#define DMA_CPAR_PA_Pos        (0U)
N#define DMA_CPAR_PA_Msk        (0xFFFFFFFFUL << DMA_CPAR_PA_Pos)               /*!< 0xFFFFFFFF */
N#define DMA_CPAR_PA            DMA_CPAR_PA_Msk                                 /*!< Peripheral Address                  */
N
N/******************  Bit definition for DMA_CMAR register  ********************/
N#define DMA_CMAR_MA_Pos        (0U)
N#define DMA_CMAR_MA_Msk        (0xFFFFFFFFUL << DMA_CMAR_MA_Pos)               /*!< 0xFFFFFFFF */
N#define DMA_CMAR_MA            DMA_CMAR_MA_Msk                                 /*!< Memory Address                      */
N
N
N/*******************  Bit definition for DMA_CSELR register  *******************/
N#define DMA_CSELR_C1S_Pos      (0U)
N#define DMA_CSELR_C1S_Msk      (0xFUL << DMA_CSELR_C1S_Pos)                    /*!< 0x0000000F */
N#define DMA_CSELR_C1S          DMA_CSELR_C1S_Msk                               /*!< Channel 1 Selection */
N#define DMA_CSELR_C2S_Pos      (4U)
N#define DMA_CSELR_C2S_Msk      (0xFUL << DMA_CSELR_C2S_Pos)                    /*!< 0x000000F0 */
N#define DMA_CSELR_C2S          DMA_CSELR_C2S_Msk                               /*!< Channel 2 Selection */
N#define DMA_CSELR_C3S_Pos      (8U)
N#define DMA_CSELR_C3S_Msk      (0xFUL << DMA_CSELR_C3S_Pos)                    /*!< 0x00000F00 */
N#define DMA_CSELR_C3S          DMA_CSELR_C3S_Msk                               /*!< Channel 3 Selection */
N#define DMA_CSELR_C4S_Pos      (12U)
N#define DMA_CSELR_C4S_Msk      (0xFUL << DMA_CSELR_C4S_Pos)                    /*!< 0x0000F000 */
N#define DMA_CSELR_C4S          DMA_CSELR_C4S_Msk                               /*!< Channel 4 Selection */
N#define DMA_CSELR_C5S_Pos      (16U)
N#define DMA_CSELR_C5S_Msk      (0xFUL << DMA_CSELR_C5S_Pos)                    /*!< 0x000F0000 */
N#define DMA_CSELR_C5S          DMA_CSELR_C5S_Msk                               /*!< Channel 5 Selection */
N#define DMA_CSELR_C6S_Pos      (20U)
N#define DMA_CSELR_C6S_Msk      (0xFUL << DMA_CSELR_C6S_Pos)                    /*!< 0x00F00000 */
N#define DMA_CSELR_C6S          DMA_CSELR_C6S_Msk                               /*!< Channel 6 Selection */
N#define DMA_CSELR_C7S_Pos      (24U)
N#define DMA_CSELR_C7S_Msk      (0xFUL << DMA_CSELR_C7S_Pos)                    /*!< 0x0F000000 */
N#define DMA_CSELR_C7S          DMA_CSELR_C7S_Msk                               /*!< Channel 7 Selection */
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR1 register  ******************/
N#define EXTI_IMR1_IM0_Pos        (0U)
N#define EXTI_IMR1_IM0_Msk        (0x1UL << EXTI_IMR1_IM0_Pos)                  /*!< 0x00000001 */
N#define EXTI_IMR1_IM0            EXTI_IMR1_IM0_Msk                             /*!< Interrupt Mask on line 0 */
N#define EXTI_IMR1_IM1_Pos        (1U)
N#define EXTI_IMR1_IM1_Msk        (0x1UL << EXTI_IMR1_IM1_Pos)                  /*!< 0x00000002 */
N#define EXTI_IMR1_IM1            EXTI_IMR1_IM1_Msk                             /*!< Interrupt Mask on line 1 */
N#define EXTI_IMR1_IM2_Pos        (2U)
N#define EXTI_IMR1_IM2_Msk        (0x1UL << EXTI_IMR1_IM2_Pos)                  /*!< 0x00000004 */
N#define EXTI_IMR1_IM2            EXTI_IMR1_IM2_Msk                             /*!< Interrupt Mask on line 2 */
N#define EXTI_IMR1_IM3_Pos        (3U)
N#define EXTI_IMR1_IM3_Msk        (0x1UL << EXTI_IMR1_IM3_Pos)                  /*!< 0x00000008 */
N#define EXTI_IMR1_IM3            EXTI_IMR1_IM3_Msk                             /*!< Interrupt Mask on line 3 */
N#define EXTI_IMR1_IM4_Pos        (4U)
N#define EXTI_IMR1_IM4_Msk        (0x1UL << EXTI_IMR1_IM4_Pos)                  /*!< 0x00000010 */
N#define EXTI_IMR1_IM4            EXTI_IMR1_IM4_Msk                             /*!< Interrupt Mask on line 4 */
N#define EXTI_IMR1_IM5_Pos        (5U)
N#define EXTI_IMR1_IM5_Msk        (0x1UL << EXTI_IMR1_IM5_Pos)                  /*!< 0x00000020 */
N#define EXTI_IMR1_IM5            EXTI_IMR1_IM5_Msk                             /*!< Interrupt Mask on line 5 */
N#define EXTI_IMR1_IM6_Pos        (6U)
N#define EXTI_IMR1_IM6_Msk        (0x1UL << EXTI_IMR1_IM6_Pos)                  /*!< 0x00000040 */
N#define EXTI_IMR1_IM6            EXTI_IMR1_IM6_Msk                             /*!< Interrupt Mask on line 6 */
N#define EXTI_IMR1_IM7_Pos        (7U)
N#define EXTI_IMR1_IM7_Msk        (0x1UL << EXTI_IMR1_IM7_Pos)                  /*!< 0x00000080 */
N#define EXTI_IMR1_IM7            EXTI_IMR1_IM7_Msk                             /*!< Interrupt Mask on line 7 */
N#define EXTI_IMR1_IM8_Pos        (8U)
N#define EXTI_IMR1_IM8_Msk        (0x1UL << EXTI_IMR1_IM8_Pos)                  /*!< 0x00000100 */
N#define EXTI_IMR1_IM8            EXTI_IMR1_IM8_Msk                             /*!< Interrupt Mask on line 8 */
N#define EXTI_IMR1_IM9_Pos        (9U)
N#define EXTI_IMR1_IM9_Msk        (0x1UL << EXTI_IMR1_IM9_Pos)                  /*!< 0x00000200 */
N#define EXTI_IMR1_IM9            EXTI_IMR1_IM9_Msk                             /*!< Interrupt Mask on line 9 */
N#define EXTI_IMR1_IM10_Pos       (10U)
N#define EXTI_IMR1_IM10_Msk       (0x1UL << EXTI_IMR1_IM10_Pos)                 /*!< 0x00000400 */
N#define EXTI_IMR1_IM10           EXTI_IMR1_IM10_Msk                            /*!< Interrupt Mask on line 10 */
N#define EXTI_IMR1_IM11_Pos       (11U)
N#define EXTI_IMR1_IM11_Msk       (0x1UL << EXTI_IMR1_IM11_Pos)                 /*!< 0x00000800 */
N#define EXTI_IMR1_IM11           EXTI_IMR1_IM11_Msk                            /*!< Interrupt Mask on line 11 */
N#define EXTI_IMR1_IM12_Pos       (12U)
N#define EXTI_IMR1_IM12_Msk       (0x1UL << EXTI_IMR1_IM12_Pos)                 /*!< 0x00001000 */
N#define EXTI_IMR1_IM12           EXTI_IMR1_IM12_Msk                            /*!< Interrupt Mask on line 12 */
N#define EXTI_IMR1_IM13_Pos       (13U)
N#define EXTI_IMR1_IM13_Msk       (0x1UL << EXTI_IMR1_IM13_Pos)                 /*!< 0x00002000 */
N#define EXTI_IMR1_IM13           EXTI_IMR1_IM13_Msk                            /*!< Interrupt Mask on line 13 */
N#define EXTI_IMR1_IM14_Pos       (14U)
N#define EXTI_IMR1_IM14_Msk       (0x1UL << EXTI_IMR1_IM14_Pos)                 /*!< 0x00004000 */
N#define EXTI_IMR1_IM14           EXTI_IMR1_IM14_Msk                            /*!< Interrupt Mask on line 14 */
N#define EXTI_IMR1_IM15_Pos       (15U)
N#define EXTI_IMR1_IM15_Msk       (0x1UL << EXTI_IMR1_IM15_Pos)                 /*!< 0x00008000 */
N#define EXTI_IMR1_IM15           EXTI_IMR1_IM15_Msk                            /*!< Interrupt Mask on line 15 */
N#define EXTI_IMR1_IM16_Pos       (16U)
N#define EXTI_IMR1_IM16_Msk       (0x1UL << EXTI_IMR1_IM16_Pos)                 /*!< 0x00010000 */
N#define EXTI_IMR1_IM16           EXTI_IMR1_IM16_Msk                            /*!< Interrupt Mask on line 16 */
N#define EXTI_IMR1_IM17_Pos       (17U)
N#define EXTI_IMR1_IM17_Msk       (0x1UL << EXTI_IMR1_IM17_Pos)                 /*!< 0x00020000 */
N#define EXTI_IMR1_IM17           EXTI_IMR1_IM17_Msk                            /*!< Interrupt Mask on line 17 */
N#define EXTI_IMR1_IM18_Pos       (18U)
N#define EXTI_IMR1_IM18_Msk       (0x1UL << EXTI_IMR1_IM18_Pos)                 /*!< 0x00040000 */
N#define EXTI_IMR1_IM18           EXTI_IMR1_IM18_Msk                            /*!< Interrupt Mask on line 18 */
N#define EXTI_IMR1_IM19_Pos       (19U)
N#define EXTI_IMR1_IM19_Msk       (0x1UL << EXTI_IMR1_IM19_Pos)                 /*!< 0x00080000 */
N#define EXTI_IMR1_IM19           EXTI_IMR1_IM19_Msk                            /*!< Interrupt Mask on line 19 */
N#define EXTI_IMR1_IM20_Pos       (20U)
N#define EXTI_IMR1_IM20_Msk       (0x1UL << EXTI_IMR1_IM20_Pos)                 /*!< 0x00100000 */
N#define EXTI_IMR1_IM20           EXTI_IMR1_IM20_Msk                            /*!< Interrupt Mask on line 20 */
N#define EXTI_IMR1_IM21_Pos       (21U)
N#define EXTI_IMR1_IM21_Msk       (0x1UL << EXTI_IMR1_IM21_Pos)                 /*!< 0x00200000 */
N#define EXTI_IMR1_IM21           EXTI_IMR1_IM21_Msk                            /*!< Interrupt Mask on line 21 */
N#define EXTI_IMR1_IM22_Pos       (22U)
N#define EXTI_IMR1_IM22_Msk       (0x1UL << EXTI_IMR1_IM22_Pos)                 /*!< 0x00400000 */
N#define EXTI_IMR1_IM22           EXTI_IMR1_IM22_Msk                            /*!< Interrupt Mask on line 22 */
N#define EXTI_IMR1_IM23_Pos       (23U)
N#define EXTI_IMR1_IM23_Msk       (0x1UL << EXTI_IMR1_IM23_Pos)                 /*!< 0x00800000 */
N#define EXTI_IMR1_IM23           EXTI_IMR1_IM23_Msk                            /*!< Interrupt Mask on line 23 */
N#define EXTI_IMR1_IM24_Pos       (24U)
N#define EXTI_IMR1_IM24_Msk       (0x1UL << EXTI_IMR1_IM24_Pos)                 /*!< 0x01000000 */
N#define EXTI_IMR1_IM24           EXTI_IMR1_IM24_Msk                            /*!< Interrupt Mask on line 24 */
N#define EXTI_IMR1_IM25_Pos       (25U)
N#define EXTI_IMR1_IM25_Msk       (0x1UL << EXTI_IMR1_IM25_Pos)                 /*!< 0x02000000 */
N#define EXTI_IMR1_IM25           EXTI_IMR1_IM25_Msk                            /*!< Interrupt Mask on line 25 */
N#define EXTI_IMR1_IM26_Pos       (26U)
N#define EXTI_IMR1_IM26_Msk       (0x1UL << EXTI_IMR1_IM26_Pos)                 /*!< 0x04000000 */
N#define EXTI_IMR1_IM26           EXTI_IMR1_IM26_Msk                            /*!< Interrupt Mask on line 26 */
N#define EXTI_IMR1_IM27_Pos       (27U)
N#define EXTI_IMR1_IM27_Msk       (0x1UL << EXTI_IMR1_IM27_Pos)                 /*!< 0x08000000 */
N#define EXTI_IMR1_IM27           EXTI_IMR1_IM27_Msk                            /*!< Interrupt Mask on line 27 */
N#define EXTI_IMR1_IM28_Pos       (28U)
N#define EXTI_IMR1_IM28_Msk       (0x1UL << EXTI_IMR1_IM28_Pos)                 /*!< 0x10000000 */
N#define EXTI_IMR1_IM28           EXTI_IMR1_IM28_Msk                            /*!< Interrupt Mask on line 28 */
N#define EXTI_IMR1_IM31_Pos       (31U)
N#define EXTI_IMR1_IM31_Msk       (0x1UL << EXTI_IMR1_IM31_Pos)                 /*!< 0x80000000 */
N#define EXTI_IMR1_IM31           EXTI_IMR1_IM31_Msk                            /*!< Interrupt Mask on line 31 */
N#define EXTI_IMR1_IM_Pos         (0U)
N#define EXTI_IMR1_IM_Msk         (0x9FFFFFFFUL << EXTI_IMR1_IM_Pos)            /*!< 0x9FFFFFFF */
N#define EXTI_IMR1_IM             EXTI_IMR1_IM_Msk                              /*!< Interrupt Mask All */
N
N/*******************  Bit definition for EXTI_EMR1 register  ******************/
N#define EXTI_EMR1_EM0_Pos        (0U)
N#define EXTI_EMR1_EM0_Msk        (0x1UL << EXTI_EMR1_EM0_Pos)                  /*!< 0x00000001 */
N#define EXTI_EMR1_EM0            EXTI_EMR1_EM0_Msk                             /*!< Event Mask on line 0 */
N#define EXTI_EMR1_EM1_Pos        (1U)
N#define EXTI_EMR1_EM1_Msk        (0x1UL << EXTI_EMR1_EM1_Pos)                  /*!< 0x00000002 */
N#define EXTI_EMR1_EM1            EXTI_EMR1_EM1_Msk                             /*!< Event Mask on line 1 */
N#define EXTI_EMR1_EM2_Pos        (2U)
N#define EXTI_EMR1_EM2_Msk        (0x1UL << EXTI_EMR1_EM2_Pos)                  /*!< 0x00000004 */
N#define EXTI_EMR1_EM2            EXTI_EMR1_EM2_Msk                             /*!< Event Mask on line 2 */
N#define EXTI_EMR1_EM3_Pos        (3U)
N#define EXTI_EMR1_EM3_Msk        (0x1UL << EXTI_EMR1_EM3_Pos)                  /*!< 0x00000008 */
N#define EXTI_EMR1_EM3            EXTI_EMR1_EM3_Msk                             /*!< Event Mask on line 3 */
N#define EXTI_EMR1_EM4_Pos        (4U)
N#define EXTI_EMR1_EM4_Msk        (0x1UL << EXTI_EMR1_EM4_Pos)                  /*!< 0x00000010 */
N#define EXTI_EMR1_EM4            EXTI_EMR1_EM4_Msk                             /*!< Event Mask on line 4 */
N#define EXTI_EMR1_EM5_Pos        (5U)
N#define EXTI_EMR1_EM5_Msk        (0x1UL << EXTI_EMR1_EM5_Pos)                  /*!< 0x00000020 */
N#define EXTI_EMR1_EM5            EXTI_EMR1_EM5_Msk                             /*!< Event Mask on line 5 */
N#define EXTI_EMR1_EM6_Pos        (6U)
N#define EXTI_EMR1_EM6_Msk        (0x1UL << EXTI_EMR1_EM6_Pos)                  /*!< 0x00000040 */
N#define EXTI_EMR1_EM6            EXTI_EMR1_EM6_Msk                             /*!< Event Mask on line 6 */
N#define EXTI_EMR1_EM7_Pos        (7U)
N#define EXTI_EMR1_EM7_Msk        (0x1UL << EXTI_EMR1_EM7_Pos)                  /*!< 0x00000080 */
N#define EXTI_EMR1_EM7            EXTI_EMR1_EM7_Msk                             /*!< Event Mask on line 7 */
N#define EXTI_EMR1_EM8_Pos        (8U)
N#define EXTI_EMR1_EM8_Msk        (0x1UL << EXTI_EMR1_EM8_Pos)                  /*!< 0x00000100 */
N#define EXTI_EMR1_EM8            EXTI_EMR1_EM8_Msk                             /*!< Event Mask on line 8 */
N#define EXTI_EMR1_EM9_Pos        (9U)
N#define EXTI_EMR1_EM9_Msk        (0x1UL << EXTI_EMR1_EM9_Pos)                  /*!< 0x00000200 */
N#define EXTI_EMR1_EM9            EXTI_EMR1_EM9_Msk                             /*!< Event Mask on line 9 */
N#define EXTI_EMR1_EM10_Pos       (10U)
N#define EXTI_EMR1_EM10_Msk       (0x1UL << EXTI_EMR1_EM10_Pos)                 /*!< 0x00000400 */
N#define EXTI_EMR1_EM10           EXTI_EMR1_EM10_Msk                            /*!< Event Mask on line 10 */
N#define EXTI_EMR1_EM11_Pos       (11U)
N#define EXTI_EMR1_EM11_Msk       (0x1UL << EXTI_EMR1_EM11_Pos)                 /*!< 0x00000800 */
N#define EXTI_EMR1_EM11           EXTI_EMR1_EM11_Msk                            /*!< Event Mask on line 11 */
N#define EXTI_EMR1_EM12_Pos       (12U)
N#define EXTI_EMR1_EM12_Msk       (0x1UL << EXTI_EMR1_EM12_Pos)                 /*!< 0x00001000 */
N#define EXTI_EMR1_EM12           EXTI_EMR1_EM12_Msk                            /*!< Event Mask on line 12 */
N#define EXTI_EMR1_EM13_Pos       (13U)
N#define EXTI_EMR1_EM13_Msk       (0x1UL << EXTI_EMR1_EM13_Pos)                 /*!< 0x00002000 */
N#define EXTI_EMR1_EM13           EXTI_EMR1_EM13_Msk                            /*!< Event Mask on line 13 */
N#define EXTI_EMR1_EM14_Pos       (14U)
N#define EXTI_EMR1_EM14_Msk       (0x1UL << EXTI_EMR1_EM14_Pos)                 /*!< 0x00004000 */
N#define EXTI_EMR1_EM14           EXTI_EMR1_EM14_Msk                            /*!< Event Mask on line 14 */
N#define EXTI_EMR1_EM15_Pos       (15U)
N#define EXTI_EMR1_EM15_Msk       (0x1UL << EXTI_EMR1_EM15_Pos)                 /*!< 0x00008000 */
N#define EXTI_EMR1_EM15           EXTI_EMR1_EM15_Msk                            /*!< Event Mask on line 15 */
N#define EXTI_EMR1_EM16_Pos       (16U)
N#define EXTI_EMR1_EM16_Msk       (0x1UL << EXTI_EMR1_EM16_Pos)                 /*!< 0x00010000 */
N#define EXTI_EMR1_EM16           EXTI_EMR1_EM16_Msk                            /*!< Event Mask on line 16 */
N#define EXTI_EMR1_EM17_Pos       (17U)
N#define EXTI_EMR1_EM17_Msk       (0x1UL << EXTI_EMR1_EM17_Pos)                 /*!< 0x00020000 */
N#define EXTI_EMR1_EM17           EXTI_EMR1_EM17_Msk                            /*!< Event Mask on line 17 */
N#define EXTI_EMR1_EM18_Pos       (18U)
N#define EXTI_EMR1_EM18_Msk       (0x1UL << EXTI_EMR1_EM18_Pos)                 /*!< 0x00040000 */
N#define EXTI_EMR1_EM18           EXTI_EMR1_EM18_Msk                            /*!< Event Mask on line 18 */
N#define EXTI_EMR1_EM19_Pos       (19U)
N#define EXTI_EMR1_EM19_Msk       (0x1UL << EXTI_EMR1_EM19_Pos)                 /*!< 0x00080000 */
N#define EXTI_EMR1_EM19           EXTI_EMR1_EM19_Msk                            /*!< Event Mask on line 19 */
N#define EXTI_EMR1_EM20_Pos       (20U)
N#define EXTI_EMR1_EM20_Msk       (0x1UL << EXTI_EMR1_EM20_Pos)                 /*!< 0x00100000 */
N#define EXTI_EMR1_EM20           EXTI_EMR1_EM20_Msk                            /*!< Event Mask on line 20 */
N#define EXTI_EMR1_EM21_Pos       (21U)
N#define EXTI_EMR1_EM21_Msk       (0x1UL << EXTI_EMR1_EM21_Pos)                 /*!< 0x00200000 */
N#define EXTI_EMR1_EM21           EXTI_EMR1_EM21_Msk                            /*!< Event Mask on line 21 */
N#define EXTI_EMR1_EM22_Pos       (22U)
N#define EXTI_EMR1_EM22_Msk       (0x1UL << EXTI_EMR1_EM22_Pos)                 /*!< 0x00400000 */
N#define EXTI_EMR1_EM22           EXTI_EMR1_EM22_Msk                            /*!< Event Mask on line 22 */
N#define EXTI_EMR1_EM23_Pos       (23U)
N#define EXTI_EMR1_EM23_Msk       (0x1UL << EXTI_EMR1_EM23_Pos)                 /*!< 0x00800000 */
N#define EXTI_EMR1_EM23           EXTI_EMR1_EM23_Msk                            /*!< Event Mask on line 23 */
N#define EXTI_EMR1_EM24_Pos       (24U)
N#define EXTI_EMR1_EM24_Msk       (0x1UL << EXTI_EMR1_EM24_Pos)                 /*!< 0x01000000 */
N#define EXTI_EMR1_EM24           EXTI_EMR1_EM24_Msk                            /*!< Event Mask on line 24 */
N#define EXTI_EMR1_EM25_Pos       (25U)
N#define EXTI_EMR1_EM25_Msk       (0x1UL << EXTI_EMR1_EM25_Pos)                 /*!< 0x02000000 */
N#define EXTI_EMR1_EM25           EXTI_EMR1_EM25_Msk                            /*!< Event Mask on line 25 */
N#define EXTI_EMR1_EM26_Pos       (26U)
N#define EXTI_EMR1_EM26_Msk       (0x1UL << EXTI_EMR1_EM26_Pos)                 /*!< 0x04000000 */
N#define EXTI_EMR1_EM26           EXTI_EMR1_EM26_Msk                            /*!< Event Mask on line 26 */
N#define EXTI_EMR1_EM27_Pos       (27U)
N#define EXTI_EMR1_EM27_Msk       (0x1UL << EXTI_EMR1_EM27_Pos)                 /*!< 0x08000000 */
N#define EXTI_EMR1_EM27           EXTI_EMR1_EM27_Msk                            /*!< Event Mask on line 27 */
N#define EXTI_EMR1_EM28_Pos       (28U)
N#define EXTI_EMR1_EM28_Msk       (0x1UL << EXTI_EMR1_EM28_Pos)                 /*!< 0x10000000 */
N#define EXTI_EMR1_EM28           EXTI_EMR1_EM28_Msk                            /*!< Event Mask on line 28 */
N#define EXTI_EMR1_EM31_Pos       (31U)
N#define EXTI_EMR1_EM31_Msk       (0x1UL << EXTI_EMR1_EM31_Pos)                 /*!< 0x80000000 */
N#define EXTI_EMR1_EM31           EXTI_EMR1_EM31_Msk                            /*!< Event Mask on line 31 */
N
N/******************  Bit definition for EXTI_RTSR1 register  ******************/
N#define EXTI_RTSR1_RT0_Pos       (0U)
N#define EXTI_RTSR1_RT0_Msk       (0x1UL << EXTI_RTSR1_RT0_Pos)                 /*!< 0x00000001 */
N#define EXTI_RTSR1_RT0           EXTI_RTSR1_RT0_Msk                            /*!< Rising trigger event configuration bit of line 0 */
N#define EXTI_RTSR1_RT1_Pos       (1U)
N#define EXTI_RTSR1_RT1_Msk       (0x1UL << EXTI_RTSR1_RT1_Pos)                 /*!< 0x00000002 */
N#define EXTI_RTSR1_RT1           EXTI_RTSR1_RT1_Msk                            /*!< Rising trigger event configuration bit of line 1 */
N#define EXTI_RTSR1_RT2_Pos       (2U)
N#define EXTI_RTSR1_RT2_Msk       (0x1UL << EXTI_RTSR1_RT2_Pos)                 /*!< 0x00000004 */
N#define EXTI_RTSR1_RT2           EXTI_RTSR1_RT2_Msk                            /*!< Rising trigger event configuration bit of line 2 */
N#define EXTI_RTSR1_RT3_Pos       (3U)
N#define EXTI_RTSR1_RT3_Msk       (0x1UL << EXTI_RTSR1_RT3_Pos)                 /*!< 0x00000008 */
N#define EXTI_RTSR1_RT3           EXTI_RTSR1_RT3_Msk                            /*!< Rising trigger event configuration bit of line 3 */
N#define EXTI_RTSR1_RT4_Pos       (4U)
N#define EXTI_RTSR1_RT4_Msk       (0x1UL << EXTI_RTSR1_RT4_Pos)                 /*!< 0x00000010 */
N#define EXTI_RTSR1_RT4           EXTI_RTSR1_RT4_Msk                            /*!< Rising trigger event configuration bit of line 4 */
N#define EXTI_RTSR1_RT5_Pos       (5U)
N#define EXTI_RTSR1_RT5_Msk       (0x1UL << EXTI_RTSR1_RT5_Pos)                 /*!< 0x00000020 */
N#define EXTI_RTSR1_RT5           EXTI_RTSR1_RT5_Msk                            /*!< Rising trigger event configuration bit of line 5 */
N#define EXTI_RTSR1_RT6_Pos       (6U)
N#define EXTI_RTSR1_RT6_Msk       (0x1UL << EXTI_RTSR1_RT6_Pos)                 /*!< 0x00000040 */
N#define EXTI_RTSR1_RT6           EXTI_RTSR1_RT6_Msk                            /*!< Rising trigger event configuration bit of line 6 */
N#define EXTI_RTSR1_RT7_Pos       (7U)
N#define EXTI_RTSR1_RT7_Msk       (0x1UL << EXTI_RTSR1_RT7_Pos)                 /*!< 0x00000080 */
N#define EXTI_RTSR1_RT7           EXTI_RTSR1_RT7_Msk                            /*!< Rising trigger event configuration bit of line 7 */
N#define EXTI_RTSR1_RT8_Pos       (8U)
N#define EXTI_RTSR1_RT8_Msk       (0x1UL << EXTI_RTSR1_RT8_Pos)                 /*!< 0x00000100 */
N#define EXTI_RTSR1_RT8           EXTI_RTSR1_RT8_Msk                            /*!< Rising trigger event configuration bit of line 8 */
N#define EXTI_RTSR1_RT9_Pos       (9U)
N#define EXTI_RTSR1_RT9_Msk       (0x1UL << EXTI_RTSR1_RT9_Pos)                 /*!< 0x00000200 */
N#define EXTI_RTSR1_RT9           EXTI_RTSR1_RT9_Msk                            /*!< Rising trigger event configuration bit of line 9 */
N#define EXTI_RTSR1_RT10_Pos      (10U)
N#define EXTI_RTSR1_RT10_Msk      (0x1UL << EXTI_RTSR1_RT10_Pos)                /*!< 0x00000400 */
N#define EXTI_RTSR1_RT10          EXTI_RTSR1_RT10_Msk                           /*!< Rising trigger event configuration bit of line 10 */
N#define EXTI_RTSR1_RT11_Pos      (11U)
N#define EXTI_RTSR1_RT11_Msk      (0x1UL << EXTI_RTSR1_RT11_Pos)                /*!< 0x00000800 */
N#define EXTI_RTSR1_RT11          EXTI_RTSR1_RT11_Msk                           /*!< Rising trigger event configuration bit of line 11 */
N#define EXTI_RTSR1_RT12_Pos      (12U)
N#define EXTI_RTSR1_RT12_Msk      (0x1UL << EXTI_RTSR1_RT12_Pos)                /*!< 0x00001000 */
N#define EXTI_RTSR1_RT12          EXTI_RTSR1_RT12_Msk                           /*!< Rising trigger event configuration bit of line 12 */
N#define EXTI_RTSR1_RT13_Pos      (13U)
N#define EXTI_RTSR1_RT13_Msk      (0x1UL << EXTI_RTSR1_RT13_Pos)                /*!< 0x00002000 */
N#define EXTI_RTSR1_RT13          EXTI_RTSR1_RT13_Msk                           /*!< Rising trigger event configuration bit of line 13 */
N#define EXTI_RTSR1_RT14_Pos      (14U)
N#define EXTI_RTSR1_RT14_Msk      (0x1UL << EXTI_RTSR1_RT14_Pos)                /*!< 0x00004000 */
N#define EXTI_RTSR1_RT14          EXTI_RTSR1_RT14_Msk                           /*!< Rising trigger event configuration bit of line 14 */
N#define EXTI_RTSR1_RT15_Pos      (15U)
N#define EXTI_RTSR1_RT15_Msk      (0x1UL << EXTI_RTSR1_RT15_Pos)                /*!< 0x00008000 */
N#define EXTI_RTSR1_RT15          EXTI_RTSR1_RT15_Msk                           /*!< Rising trigger event configuration bit of line 15 */
N#define EXTI_RTSR1_RT16_Pos      (16U)
N#define EXTI_RTSR1_RT16_Msk      (0x1UL << EXTI_RTSR1_RT16_Pos)                /*!< 0x00010000 */
N#define EXTI_RTSR1_RT16          EXTI_RTSR1_RT16_Msk                           /*!< Rising trigger event configuration bit of line 16 */
N#define EXTI_RTSR1_RT18_Pos      (18U)
N#define EXTI_RTSR1_RT18_Msk      (0x1UL << EXTI_RTSR1_RT18_Pos)                /*!< 0x00040000 */
N#define EXTI_RTSR1_RT18          EXTI_RTSR1_RT18_Msk                           /*!< Rising trigger event configuration bit of line 18 */
N#define EXTI_RTSR1_RT19_Pos      (19U)
N#define EXTI_RTSR1_RT19_Msk      (0x1UL << EXTI_RTSR1_RT19_Pos)                /*!< 0x00080000 */
N#define EXTI_RTSR1_RT19          EXTI_RTSR1_RT19_Msk                           /*!< Rising trigger event configuration bit of line 19 */
N#define EXTI_RTSR1_RT20_Pos      (20U)
N#define EXTI_RTSR1_RT20_Msk      (0x1UL << EXTI_RTSR1_RT20_Pos)                /*!< 0x00100000 */
N#define EXTI_RTSR1_RT20          EXTI_RTSR1_RT20_Msk                           /*!< Rising trigger event configuration bit of line 20 */
N#define EXTI_RTSR1_RT21_Pos      (21U)
N#define EXTI_RTSR1_RT21_Msk      (0x1UL << EXTI_RTSR1_RT21_Pos)                /*!< 0x00200000 */
N#define EXTI_RTSR1_RT21          EXTI_RTSR1_RT21_Msk                           /*!< Rising trigger event configuration bit of line 21 */
N#define EXTI_RTSR1_RT22_Pos      (22U)
N#define EXTI_RTSR1_RT22_Msk      (0x1UL << EXTI_RTSR1_RT22_Pos)                /*!< 0x00400000 */
N#define EXTI_RTSR1_RT22          EXTI_RTSR1_RT22_Msk                           /*!< Rising trigger event configuration bit of line 22 */
N
N/******************  Bit definition for EXTI_FTSR1 register  ******************/
N#define EXTI_FTSR1_FT0_Pos       (0U)
N#define EXTI_FTSR1_FT0_Msk       (0x1UL << EXTI_FTSR1_FT0_Pos)                 /*!< 0x00000001 */
N#define EXTI_FTSR1_FT0           EXTI_FTSR1_FT0_Msk                            /*!< Falling trigger event configuration bit of line 0 */
N#define EXTI_FTSR1_FT1_Pos       (1U)
N#define EXTI_FTSR1_FT1_Msk       (0x1UL << EXTI_FTSR1_FT1_Pos)                 /*!< 0x00000002 */
N#define EXTI_FTSR1_FT1           EXTI_FTSR1_FT1_Msk                            /*!< Falling trigger event configuration bit of line 1 */
N#define EXTI_FTSR1_FT2_Pos       (2U)
N#define EXTI_FTSR1_FT2_Msk       (0x1UL << EXTI_FTSR1_FT2_Pos)                 /*!< 0x00000004 */
N#define EXTI_FTSR1_FT2           EXTI_FTSR1_FT2_Msk                            /*!< Falling trigger event configuration bit of line 2 */
N#define EXTI_FTSR1_FT3_Pos       (3U)
N#define EXTI_FTSR1_FT3_Msk       (0x1UL << EXTI_FTSR1_FT3_Pos)                 /*!< 0x00000008 */
N#define EXTI_FTSR1_FT3           EXTI_FTSR1_FT3_Msk                            /*!< Falling trigger event configuration bit of line 3 */
N#define EXTI_FTSR1_FT4_Pos       (4U)
N#define EXTI_FTSR1_FT4_Msk       (0x1UL << EXTI_FTSR1_FT4_Pos)                 /*!< 0x00000010 */
N#define EXTI_FTSR1_FT4           EXTI_FTSR1_FT4_Msk                            /*!< Falling trigger event configuration bit of line 4 */
N#define EXTI_FTSR1_FT5_Pos       (5U)
N#define EXTI_FTSR1_FT5_Msk       (0x1UL << EXTI_FTSR1_FT5_Pos)                 /*!< 0x00000020 */
N#define EXTI_FTSR1_FT5           EXTI_FTSR1_FT5_Msk                            /*!< Falling trigger event configuration bit of line 5 */
N#define EXTI_FTSR1_FT6_Pos       (6U)
N#define EXTI_FTSR1_FT6_Msk       (0x1UL << EXTI_FTSR1_FT6_Pos)                 /*!< 0x00000040 */
N#define EXTI_FTSR1_FT6           EXTI_FTSR1_FT6_Msk                            /*!< Falling trigger event configuration bit of line 6 */
N#define EXTI_FTSR1_FT7_Pos       (7U)
N#define EXTI_FTSR1_FT7_Msk       (0x1UL << EXTI_FTSR1_FT7_Pos)                 /*!< 0x00000080 */
N#define EXTI_FTSR1_FT7           EXTI_FTSR1_FT7_Msk                            /*!< Falling trigger event configuration bit of line 7 */
N#define EXTI_FTSR1_FT8_Pos       (8U)
N#define EXTI_FTSR1_FT8_Msk       (0x1UL << EXTI_FTSR1_FT8_Pos)                 /*!< 0x00000100 */
N#define EXTI_FTSR1_FT8           EXTI_FTSR1_FT8_Msk                            /*!< Falling trigger event configuration bit of line 8 */
N#define EXTI_FTSR1_FT9_Pos       (9U)
N#define EXTI_FTSR1_FT9_Msk       (0x1UL << EXTI_FTSR1_FT9_Pos)                 /*!< 0x00000200 */
N#define EXTI_FTSR1_FT9           EXTI_FTSR1_FT9_Msk                            /*!< Falling trigger event configuration bit of line 9 */
N#define EXTI_FTSR1_FT10_Pos      (10U)
N#define EXTI_FTSR1_FT10_Msk      (0x1UL << EXTI_FTSR1_FT10_Pos)                /*!< 0x00000400 */
N#define EXTI_FTSR1_FT10          EXTI_FTSR1_FT10_Msk                           /*!< Falling trigger event configuration bit of line 10 */
N#define EXTI_FTSR1_FT11_Pos      (11U)
N#define EXTI_FTSR1_FT11_Msk      (0x1UL << EXTI_FTSR1_FT11_Pos)                /*!< 0x00000800 */
N#define EXTI_FTSR1_FT11          EXTI_FTSR1_FT11_Msk                           /*!< Falling trigger event configuration bit of line 11 */
N#define EXTI_FTSR1_FT12_Pos      (12U)
N#define EXTI_FTSR1_FT12_Msk      (0x1UL << EXTI_FTSR1_FT12_Pos)                /*!< 0x00001000 */
N#define EXTI_FTSR1_FT12          EXTI_FTSR1_FT12_Msk                           /*!< Falling trigger event configuration bit of line 12 */
N#define EXTI_FTSR1_FT13_Pos      (13U)
N#define EXTI_FTSR1_FT13_Msk      (0x1UL << EXTI_FTSR1_FT13_Pos)                /*!< 0x00002000 */
N#define EXTI_FTSR1_FT13          EXTI_FTSR1_FT13_Msk                           /*!< Falling trigger event configuration bit of line 13 */
N#define EXTI_FTSR1_FT14_Pos      (14U)
N#define EXTI_FTSR1_FT14_Msk      (0x1UL << EXTI_FTSR1_FT14_Pos)                /*!< 0x00004000 */
N#define EXTI_FTSR1_FT14          EXTI_FTSR1_FT14_Msk                           /*!< Falling trigger event configuration bit of line 14 */
N#define EXTI_FTSR1_FT15_Pos      (15U)
N#define EXTI_FTSR1_FT15_Msk      (0x1UL << EXTI_FTSR1_FT15_Pos)                /*!< 0x00008000 */
N#define EXTI_FTSR1_FT15          EXTI_FTSR1_FT15_Msk                           /*!< Falling trigger event configuration bit of line 15 */
N#define EXTI_FTSR1_FT16_Pos      (16U)
N#define EXTI_FTSR1_FT16_Msk      (0x1UL << EXTI_FTSR1_FT16_Pos)                /*!< 0x00010000 */
N#define EXTI_FTSR1_FT16          EXTI_FTSR1_FT16_Msk                           /*!< Falling trigger event configuration bit of line 16 */
N#define EXTI_FTSR1_FT18_Pos      (18U)
N#define EXTI_FTSR1_FT18_Msk      (0x1UL << EXTI_FTSR1_FT18_Pos)                /*!< 0x00040000 */
N#define EXTI_FTSR1_FT18          EXTI_FTSR1_FT18_Msk                           /*!< Falling trigger event configuration bit of line 18 */
N#define EXTI_FTSR1_FT19_Pos      (19U)
N#define EXTI_FTSR1_FT19_Msk      (0x1UL << EXTI_FTSR1_FT19_Pos)                /*!< 0x00080000 */
N#define EXTI_FTSR1_FT19          EXTI_FTSR1_FT19_Msk                           /*!< Falling trigger event configuration bit of line 19 */
N#define EXTI_FTSR1_FT20_Pos      (20U)
N#define EXTI_FTSR1_FT20_Msk      (0x1UL << EXTI_FTSR1_FT20_Pos)                /*!< 0x00100000 */
N#define EXTI_FTSR1_FT20          EXTI_FTSR1_FT20_Msk                           /*!< Falling trigger event configuration bit of line 20 */
N#define EXTI_FTSR1_FT21_Pos      (21U)
N#define EXTI_FTSR1_FT21_Msk      (0x1UL << EXTI_FTSR1_FT21_Pos)                /*!< 0x00200000 */
N#define EXTI_FTSR1_FT21          EXTI_FTSR1_FT21_Msk                           /*!< Falling trigger event configuration bit of line 21 */
N#define EXTI_FTSR1_FT22_Pos      (22U)
N#define EXTI_FTSR1_FT22_Msk      (0x1UL << EXTI_FTSR1_FT22_Pos)                /*!< 0x00400000 */
N#define EXTI_FTSR1_FT22          EXTI_FTSR1_FT22_Msk                           /*!< Falling trigger event configuration bit of line 22 */
N
N/******************  Bit definition for EXTI_SWIER1 register  *****************/
N#define EXTI_SWIER1_SWI0_Pos     (0U)
N#define EXTI_SWIER1_SWI0_Msk     (0x1UL << EXTI_SWIER1_SWI0_Pos)               /*!< 0x00000001 */
N#define EXTI_SWIER1_SWI0         EXTI_SWIER1_SWI0_Msk                          /*!< Software Interrupt on line 0 */
N#define EXTI_SWIER1_SWI1_Pos     (1U)
N#define EXTI_SWIER1_SWI1_Msk     (0x1UL << EXTI_SWIER1_SWI1_Pos)               /*!< 0x00000002 */
N#define EXTI_SWIER1_SWI1         EXTI_SWIER1_SWI1_Msk                          /*!< Software Interrupt on line 1 */
N#define EXTI_SWIER1_SWI2_Pos     (2U)
N#define EXTI_SWIER1_SWI2_Msk     (0x1UL << EXTI_SWIER1_SWI2_Pos)               /*!< 0x00000004 */
N#define EXTI_SWIER1_SWI2         EXTI_SWIER1_SWI2_Msk                          /*!< Software Interrupt on line 2 */
N#define EXTI_SWIER1_SWI3_Pos     (3U)
N#define EXTI_SWIER1_SWI3_Msk     (0x1UL << EXTI_SWIER1_SWI3_Pos)               /*!< 0x00000008 */
N#define EXTI_SWIER1_SWI3         EXTI_SWIER1_SWI3_Msk                          /*!< Software Interrupt on line 3 */
N#define EXTI_SWIER1_SWI4_Pos     (4U)
N#define EXTI_SWIER1_SWI4_Msk     (0x1UL << EXTI_SWIER1_SWI4_Pos)               /*!< 0x00000010 */
N#define EXTI_SWIER1_SWI4         EXTI_SWIER1_SWI4_Msk                          /*!< Software Interrupt on line 4 */
N#define EXTI_SWIER1_SWI5_Pos     (5U)
N#define EXTI_SWIER1_SWI5_Msk     (0x1UL << EXTI_SWIER1_SWI5_Pos)               /*!< 0x00000020 */
N#define EXTI_SWIER1_SWI5         EXTI_SWIER1_SWI5_Msk                          /*!< Software Interrupt on line 5 */
N#define EXTI_SWIER1_SWI6_Pos     (6U)
N#define EXTI_SWIER1_SWI6_Msk     (0x1UL << EXTI_SWIER1_SWI6_Pos)               /*!< 0x00000040 */
N#define EXTI_SWIER1_SWI6         EXTI_SWIER1_SWI6_Msk                          /*!< Software Interrupt on line 6 */
N#define EXTI_SWIER1_SWI7_Pos     (7U)
N#define EXTI_SWIER1_SWI7_Msk     (0x1UL << EXTI_SWIER1_SWI7_Pos)               /*!< 0x00000080 */
N#define EXTI_SWIER1_SWI7         EXTI_SWIER1_SWI7_Msk                          /*!< Software Interrupt on line 7 */
N#define EXTI_SWIER1_SWI8_Pos     (8U)
N#define EXTI_SWIER1_SWI8_Msk     (0x1UL << EXTI_SWIER1_SWI8_Pos)               /*!< 0x00000100 */
N#define EXTI_SWIER1_SWI8         EXTI_SWIER1_SWI8_Msk                          /*!< Software Interrupt on line 8 */
N#define EXTI_SWIER1_SWI9_Pos     (9U)
N#define EXTI_SWIER1_SWI9_Msk     (0x1UL << EXTI_SWIER1_SWI9_Pos)               /*!< 0x00000200 */
N#define EXTI_SWIER1_SWI9         EXTI_SWIER1_SWI9_Msk                          /*!< Software Interrupt on line 9 */
N#define EXTI_SWIER1_SWI10_Pos    (10U)
N#define EXTI_SWIER1_SWI10_Msk    (0x1UL << EXTI_SWIER1_SWI10_Pos)              /*!< 0x00000400 */
N#define EXTI_SWIER1_SWI10        EXTI_SWIER1_SWI10_Msk                         /*!< Software Interrupt on line 10 */
N#define EXTI_SWIER1_SWI11_Pos    (11U)
N#define EXTI_SWIER1_SWI11_Msk    (0x1UL << EXTI_SWIER1_SWI11_Pos)              /*!< 0x00000800 */
N#define EXTI_SWIER1_SWI11        EXTI_SWIER1_SWI11_Msk                         /*!< Software Interrupt on line 11 */
N#define EXTI_SWIER1_SWI12_Pos    (12U)
N#define EXTI_SWIER1_SWI12_Msk    (0x1UL << EXTI_SWIER1_SWI12_Pos)              /*!< 0x00001000 */
N#define EXTI_SWIER1_SWI12        EXTI_SWIER1_SWI12_Msk                         /*!< Software Interrupt on line 12 */
N#define EXTI_SWIER1_SWI13_Pos    (13U)
N#define EXTI_SWIER1_SWI13_Msk    (0x1UL << EXTI_SWIER1_SWI13_Pos)              /*!< 0x00002000 */
N#define EXTI_SWIER1_SWI13        EXTI_SWIER1_SWI13_Msk                         /*!< Software Interrupt on line 13 */
N#define EXTI_SWIER1_SWI14_Pos    (14U)
N#define EXTI_SWIER1_SWI14_Msk    (0x1UL << EXTI_SWIER1_SWI14_Pos)              /*!< 0x00004000 */
N#define EXTI_SWIER1_SWI14        EXTI_SWIER1_SWI14_Msk                         /*!< Software Interrupt on line 14 */
N#define EXTI_SWIER1_SWI15_Pos    (15U)
N#define EXTI_SWIER1_SWI15_Msk    (0x1UL << EXTI_SWIER1_SWI15_Pos)              /*!< 0x00008000 */
N#define EXTI_SWIER1_SWI15        EXTI_SWIER1_SWI15_Msk                         /*!< Software Interrupt on line 15 */
N#define EXTI_SWIER1_SWI16_Pos    (16U)
N#define EXTI_SWIER1_SWI16_Msk    (0x1UL << EXTI_SWIER1_SWI16_Pos)              /*!< 0x00010000 */
N#define EXTI_SWIER1_SWI16        EXTI_SWIER1_SWI16_Msk                         /*!< Software Interrupt on line 16 */
N#define EXTI_SWIER1_SWI18_Pos    (18U)
N#define EXTI_SWIER1_SWI18_Msk    (0x1UL << EXTI_SWIER1_SWI18_Pos)              /*!< 0x00040000 */
N#define EXTI_SWIER1_SWI18        EXTI_SWIER1_SWI18_Msk                         /*!< Software Interrupt on line 18 */
N#define EXTI_SWIER1_SWI19_Pos    (19U)
N#define EXTI_SWIER1_SWI19_Msk    (0x1UL << EXTI_SWIER1_SWI19_Pos)              /*!< 0x00080000 */
N#define EXTI_SWIER1_SWI19        EXTI_SWIER1_SWI19_Msk                         /*!< Software Interrupt on line 19 */
N#define EXTI_SWIER1_SWI20_Pos    (20U)
N#define EXTI_SWIER1_SWI20_Msk    (0x1UL << EXTI_SWIER1_SWI20_Pos)              /*!< 0x00100000 */
N#define EXTI_SWIER1_SWI20        EXTI_SWIER1_SWI20_Msk                         /*!< Software Interrupt on line 20 */
N#define EXTI_SWIER1_SWI21_Pos    (21U)
N#define EXTI_SWIER1_SWI21_Msk    (0x1UL << EXTI_SWIER1_SWI21_Pos)              /*!< 0x00200000 */
N#define EXTI_SWIER1_SWI21        EXTI_SWIER1_SWI21_Msk                         /*!< Software Interrupt on line 21 */
N#define EXTI_SWIER1_SWI22_Pos    (22U)
N#define EXTI_SWIER1_SWI22_Msk    (0x1UL << EXTI_SWIER1_SWI22_Pos)              /*!< 0x00400000 */
N#define EXTI_SWIER1_SWI22        EXTI_SWIER1_SWI22_Msk                         /*!< Software Interrupt on line 22 */
N
N/*******************  Bit definition for EXTI_PR1 register  *******************/
N#define EXTI_PR1_PIF0_Pos        (0U)
N#define EXTI_PR1_PIF0_Msk        (0x1UL << EXTI_PR1_PIF0_Pos)                  /*!< 0x00000001 */
N#define EXTI_PR1_PIF0            EXTI_PR1_PIF0_Msk                             /*!< Pending bit for line 0 */
N#define EXTI_PR1_PIF1_Pos        (1U)
N#define EXTI_PR1_PIF1_Msk        (0x1UL << EXTI_PR1_PIF1_Pos)                  /*!< 0x00000002 */
N#define EXTI_PR1_PIF1            EXTI_PR1_PIF1_Msk                             /*!< Pending bit for line 1 */
N#define EXTI_PR1_PIF2_Pos        (2U)
N#define EXTI_PR1_PIF2_Msk        (0x1UL << EXTI_PR1_PIF2_Pos)                  /*!< 0x00000004 */
N#define EXTI_PR1_PIF2            EXTI_PR1_PIF2_Msk                             /*!< Pending bit for line 2 */
N#define EXTI_PR1_PIF3_Pos        (3U)
N#define EXTI_PR1_PIF3_Msk        (0x1UL << EXTI_PR1_PIF3_Pos)                  /*!< 0x00000008 */
N#define EXTI_PR1_PIF3            EXTI_PR1_PIF3_Msk                             /*!< Pending bit for line 3 */
N#define EXTI_PR1_PIF4_Pos        (4U)
N#define EXTI_PR1_PIF4_Msk        (0x1UL << EXTI_PR1_PIF4_Pos)                  /*!< 0x00000010 */
N#define EXTI_PR1_PIF4            EXTI_PR1_PIF4_Msk                             /*!< Pending bit for line 4 */
N#define EXTI_PR1_PIF5_Pos        (5U)
N#define EXTI_PR1_PIF5_Msk        (0x1UL << EXTI_PR1_PIF5_Pos)                  /*!< 0x00000020 */
N#define EXTI_PR1_PIF5            EXTI_PR1_PIF5_Msk                             /*!< Pending bit for line 5 */
N#define EXTI_PR1_PIF6_Pos        (6U)
N#define EXTI_PR1_PIF6_Msk        (0x1UL << EXTI_PR1_PIF6_Pos)                  /*!< 0x00000040 */
N#define EXTI_PR1_PIF6            EXTI_PR1_PIF6_Msk                             /*!< Pending bit for line 6 */
N#define EXTI_PR1_PIF7_Pos        (7U)
N#define EXTI_PR1_PIF7_Msk        (0x1UL << EXTI_PR1_PIF7_Pos)                  /*!< 0x00000080 */
N#define EXTI_PR1_PIF7            EXTI_PR1_PIF7_Msk                             /*!< Pending bit for line 7 */
N#define EXTI_PR1_PIF8_Pos        (8U)
N#define EXTI_PR1_PIF8_Msk        (0x1UL << EXTI_PR1_PIF8_Pos)                  /*!< 0x00000100 */
N#define EXTI_PR1_PIF8            EXTI_PR1_PIF8_Msk                             /*!< Pending bit for line 8 */
N#define EXTI_PR1_PIF9_Pos        (9U)
N#define EXTI_PR1_PIF9_Msk        (0x1UL << EXTI_PR1_PIF9_Pos)                  /*!< 0x00000200 */
N#define EXTI_PR1_PIF9            EXTI_PR1_PIF9_Msk                             /*!< Pending bit for line 9 */
N#define EXTI_PR1_PIF10_Pos       (10U)
N#define EXTI_PR1_PIF10_Msk       (0x1UL << EXTI_PR1_PIF10_Pos)                 /*!< 0x00000400 */
N#define EXTI_PR1_PIF10           EXTI_PR1_PIF10_Msk                            /*!< Pending bit for line 10 */
N#define EXTI_PR1_PIF11_Pos       (11U)
N#define EXTI_PR1_PIF11_Msk       (0x1UL << EXTI_PR1_PIF11_Pos)                 /*!< 0x00000800 */
N#define EXTI_PR1_PIF11           EXTI_PR1_PIF11_Msk                            /*!< Pending bit for line 11 */
N#define EXTI_PR1_PIF12_Pos       (12U)
N#define EXTI_PR1_PIF12_Msk       (0x1UL << EXTI_PR1_PIF12_Pos)                 /*!< 0x00001000 */
N#define EXTI_PR1_PIF12           EXTI_PR1_PIF12_Msk                            /*!< Pending bit for line 12 */
N#define EXTI_PR1_PIF13_Pos       (13U)
N#define EXTI_PR1_PIF13_Msk       (0x1UL << EXTI_PR1_PIF13_Pos)                 /*!< 0x00002000 */
N#define EXTI_PR1_PIF13           EXTI_PR1_PIF13_Msk                            /*!< Pending bit for line 13 */
N#define EXTI_PR1_PIF14_Pos       (14U)
N#define EXTI_PR1_PIF14_Msk       (0x1UL << EXTI_PR1_PIF14_Pos)                 /*!< 0x00004000 */
N#define EXTI_PR1_PIF14           EXTI_PR1_PIF14_Msk                            /*!< Pending bit for line 14 */
N#define EXTI_PR1_PIF15_Pos       (15U)
N#define EXTI_PR1_PIF15_Msk       (0x1UL << EXTI_PR1_PIF15_Pos)                 /*!< 0x00008000 */
N#define EXTI_PR1_PIF15           EXTI_PR1_PIF15_Msk                            /*!< Pending bit for line 15 */
N#define EXTI_PR1_PIF16_Pos       (16U)
N#define EXTI_PR1_PIF16_Msk       (0x1UL << EXTI_PR1_PIF16_Pos)                 /*!< 0x00010000 */
N#define EXTI_PR1_PIF16           EXTI_PR1_PIF16_Msk                            /*!< Pending bit for line 16 */
N#define EXTI_PR1_PIF18_Pos       (18U)
N#define EXTI_PR1_PIF18_Msk       (0x1UL << EXTI_PR1_PIF18_Pos)                 /*!< 0x00040000 */
N#define EXTI_PR1_PIF18           EXTI_PR1_PIF18_Msk                            /*!< Pending bit for line 18 */
N#define EXTI_PR1_PIF19_Pos       (19U)
N#define EXTI_PR1_PIF19_Msk       (0x1UL << EXTI_PR1_PIF19_Pos)                 /*!< 0x00080000 */
N#define EXTI_PR1_PIF19           EXTI_PR1_PIF19_Msk                            /*!< Pending bit for line 19 */
N#define EXTI_PR1_PIF20_Pos       (20U)
N#define EXTI_PR1_PIF20_Msk       (0x1UL << EXTI_PR1_PIF20_Pos)                 /*!< 0x00100000 */
N#define EXTI_PR1_PIF20           EXTI_PR1_PIF20_Msk                            /*!< Pending bit for line 20 */
N#define EXTI_PR1_PIF21_Pos       (21U)
N#define EXTI_PR1_PIF21_Msk       (0x1UL << EXTI_PR1_PIF21_Pos)                 /*!< 0x00200000 */
N#define EXTI_PR1_PIF21           EXTI_PR1_PIF21_Msk                            /*!< Pending bit for line 21 */
N#define EXTI_PR1_PIF22_Pos       (22U)
N#define EXTI_PR1_PIF22_Msk       (0x1UL << EXTI_PR1_PIF22_Pos)                 /*!< 0x00400000 */
N#define EXTI_PR1_PIF22           EXTI_PR1_PIF22_Msk                            /*!< Pending bit for line 22 */
N
N/*******************  Bit definition for EXTI_IMR2 register  ******************/
N#define EXTI_IMR2_IM32_Pos       (0U)
N#define EXTI_IMR2_IM32_Msk       (0x1UL << EXTI_IMR2_IM32_Pos)                 /*!< 0x00000001 */
N#define EXTI_IMR2_IM32           EXTI_IMR2_IM32_Msk                            /*!< Interrupt Mask on line 32 */
N#define EXTI_IMR2_IM33_Pos       (1U)
N#define EXTI_IMR2_IM33_Msk       (0x1UL << EXTI_IMR2_IM33_Pos)                 /*!< 0x00000002 */
N#define EXTI_IMR2_IM33           EXTI_IMR2_IM33_Msk                            /*!< Interrupt Mask on line 33 */
N#define EXTI_IMR2_IM34_Pos       (2U)
N#define EXTI_IMR2_IM34_Msk       (0x1UL << EXTI_IMR2_IM34_Pos)                 /*!< 0x00000004 */
N#define EXTI_IMR2_IM34           EXTI_IMR2_IM34_Msk                            /*!< Interrupt Mask on line 34 */
N#define EXTI_IMR2_IM37_Pos       (5U)
N#define EXTI_IMR2_IM37_Msk       (0x1UL << EXTI_IMR2_IM37_Pos)                 /*!< 0x00000020 */
N#define EXTI_IMR2_IM37           EXTI_IMR2_IM37_Msk                            /*!< Interrupt Mask on line 37 */
N#define EXTI_IMR2_IM38_Pos       (6U)
N#define EXTI_IMR2_IM38_Msk       (0x1UL << EXTI_IMR2_IM38_Pos)                 /*!< 0x00000040 */
N#define EXTI_IMR2_IM38           EXTI_IMR2_IM38_Msk                            /*!< Interrupt Mask on line 38 */
N#define EXTI_IMR2_IM_Pos         (0U)
N#define EXTI_IMR2_IM_Msk         (0x67UL << EXTI_IMR2_IM_Pos)                  /*!< 0x00000067 */
N#define EXTI_IMR2_IM             EXTI_IMR2_IM_Msk                              /*!< Interrupt Mask all        */
N
N/*******************  Bit definition for EXTI_EMR2 register  ******************/
N#define EXTI_EMR2_EM32_Pos       (0U)
N#define EXTI_EMR2_EM32_Msk       (0x1UL << EXTI_EMR2_EM32_Pos)                 /*!< 0x00000001 */
N#define EXTI_EMR2_EM32           EXTI_EMR2_EM32_Msk                            /*!< Event Mask on line 32 */
N#define EXTI_EMR2_EM33_Pos       (1U)
N#define EXTI_EMR2_EM33_Msk       (0x1UL << EXTI_EMR2_EM33_Pos)                 /*!< 0x00000002 */
N#define EXTI_EMR2_EM33           EXTI_EMR2_EM33_Msk                            /*!< Event Mask on line 33 */
N#define EXTI_EMR2_EM34_Pos       (2U)
N#define EXTI_EMR2_EM34_Msk       (0x1UL << EXTI_EMR2_EM34_Pos)                 /*!< 0x00000004 */
N#define EXTI_EMR2_EM34           EXTI_EMR2_EM34_Msk                            /*!< Event Mask on line 34 */
N#define EXTI_EMR2_EM37_Pos       (5U)
N#define EXTI_EMR2_EM37_Msk       (0x1UL << EXTI_EMR2_EM37_Pos)                 /*!< 0x00000020 */
N#define EXTI_EMR2_EM37           EXTI_EMR2_EM37_Msk                            /*!< Event Mask on line 37 */
N#define EXTI_EMR2_EM38_Pos       (6U)
N#define EXTI_EMR2_EM38_Msk       (0x1UL << EXTI_EMR2_EM38_Pos)                 /*!< 0x00000040 */
N#define EXTI_EMR2_EM38           EXTI_EMR2_EM38_Msk                            /*!< Event Mask on line 38 */
N#define EXTI_EMR2_EM_Pos         (0U)
N#define EXTI_EMR2_EM_Msk         (0x67UL << EXTI_EMR2_EM_Pos)                  /*!< 0x00000067 */
N#define EXTI_EMR2_EM             EXTI_EMR2_EM_Msk                              /*!< Interrupt Mask all        */
N
N/******************  Bit definition for EXTI_RTSR2 register  ******************/
N#define EXTI_RTSR2_RT37_Pos      (5U)
N#define EXTI_RTSR2_RT37_Msk      (0x1UL << EXTI_RTSR2_RT37_Pos)                /*!< 0x00000020 */
N#define EXTI_RTSR2_RT37          EXTI_RTSR2_RT37_Msk                           /*!< Rising trigger event configuration bit of line 37 */
N#define EXTI_RTSR2_RT38_Pos      (6U)
N#define EXTI_RTSR2_RT38_Msk      (0x1UL << EXTI_RTSR2_RT38_Pos)                /*!< 0x00000040 */
N#define EXTI_RTSR2_RT38          EXTI_RTSR2_RT38_Msk                           /*!< Rising trigger event configuration bit of line 38 */
N
N/******************  Bit definition for EXTI_FTSR2 register  ******************/
N#define EXTI_FTSR2_FT37_Pos      (5U)
N#define EXTI_FTSR2_FT37_Msk      (0x1UL << EXTI_FTSR2_FT37_Pos)                /*!< 0x00000020 */
N#define EXTI_FTSR2_FT37          EXTI_FTSR2_FT37_Msk                           /*!< Falling trigger event configuration bit of line 37 */
N#define EXTI_FTSR2_FT38_Pos      (6U)
N#define EXTI_FTSR2_FT38_Msk      (0x1UL << EXTI_FTSR2_FT38_Pos)                /*!< 0x00000040 */
N#define EXTI_FTSR2_FT38          EXTI_FTSR2_FT38_Msk                           /*!< Falling trigger event configuration bit of line 38 */
N
N/******************  Bit definition for EXTI_SWIER2 register  *****************/
N#define EXTI_SWIER2_SWI37_Pos    (5U)
N#define EXTI_SWIER2_SWI37_Msk    (0x1UL << EXTI_SWIER2_SWI37_Pos)              /*!< 0x00000020 */
N#define EXTI_SWIER2_SWI37        EXTI_SWIER2_SWI37_Msk                         /*!< Software Interrupt on line 37 */
N#define EXTI_SWIER2_SWI38_Pos    (6U)
N#define EXTI_SWIER2_SWI38_Msk    (0x1UL << EXTI_SWIER2_SWI38_Pos)              /*!< 0x00000040 */
N#define EXTI_SWIER2_SWI38        EXTI_SWIER2_SWI38_Msk                         /*!< Software Interrupt on line 38 */
N
N/*******************  Bit definition for EXTI_PR2 register  *******************/
N#define EXTI_PR2_PIF37_Pos       (5U)
N#define EXTI_PR2_PIF37_Msk       (0x1UL << EXTI_PR2_PIF37_Pos)                 /*!< 0x00000020 */
N#define EXTI_PR2_PIF37           EXTI_PR2_PIF37_Msk                            /*!< Pending bit for line 37 */
N#define EXTI_PR2_PIF38_Pos       (6U)
N#define EXTI_PR2_PIF38_Msk       (0x1UL << EXTI_PR2_PIF38_Pos)                 /*!< 0x00000040 */
N#define EXTI_PR2_PIF38           EXTI_PR2_PIF38_Msk                            /*!< Pending bit for line 38 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    FLASH                                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bits definition for FLASH_ACR register  *****************/
N#define FLASH_ACR_LATENCY_Pos             (0U)
N#define FLASH_ACR_LATENCY_Msk             (0x7UL << FLASH_ACR_LATENCY_Pos)     /*!< 0x00000007 */
N#define FLASH_ACR_LATENCY                 FLASH_ACR_LATENCY_Msk
N#define FLASH_ACR_LATENCY_0WS             (0x00000000UL)
N#define FLASH_ACR_LATENCY_1WS             (0x00000001UL)
N#define FLASH_ACR_LATENCY_2WS             (0x00000002UL)
N#define FLASH_ACR_LATENCY_3WS             (0x00000003UL)
N#define FLASH_ACR_LATENCY_4WS             (0x00000004UL)
N#define FLASH_ACR_PRFTEN_Pos              (8U)
N#define FLASH_ACR_PRFTEN_Msk              (0x1UL << FLASH_ACR_PRFTEN_Pos)      /*!< 0x00000100 */
N#define FLASH_ACR_PRFTEN                  FLASH_ACR_PRFTEN_Msk
N#define FLASH_ACR_ICEN_Pos                (9U)
N#define FLASH_ACR_ICEN_Msk                (0x1UL << FLASH_ACR_ICEN_Pos)        /*!< 0x00000200 */
N#define FLASH_ACR_ICEN                    FLASH_ACR_ICEN_Msk
N#define FLASH_ACR_DCEN_Pos                (10U)
N#define FLASH_ACR_DCEN_Msk                (0x1UL << FLASH_ACR_DCEN_Pos)        /*!< 0x00000400 */
N#define FLASH_ACR_DCEN                    FLASH_ACR_DCEN_Msk
N#define FLASH_ACR_ICRST_Pos               (11U)
N#define FLASH_ACR_ICRST_Msk               (0x1UL << FLASH_ACR_ICRST_Pos)       /*!< 0x00000800 */
N#define FLASH_ACR_ICRST                   FLASH_ACR_ICRST_Msk
N#define FLASH_ACR_DCRST_Pos               (12U)
N#define FLASH_ACR_DCRST_Msk               (0x1UL << FLASH_ACR_DCRST_Pos)       /*!< 0x00001000 */
N#define FLASH_ACR_DCRST                   FLASH_ACR_DCRST_Msk
N#define FLASH_ACR_RUN_PD_Pos              (13U)
N#define FLASH_ACR_RUN_PD_Msk              (0x1UL << FLASH_ACR_RUN_PD_Pos)      /*!< 0x00002000 */
N#define FLASH_ACR_RUN_PD                  FLASH_ACR_RUN_PD_Msk                 /*!< Flash power down mode during run */
N#define FLASH_ACR_SLEEP_PD_Pos            (14U)
N#define FLASH_ACR_SLEEP_PD_Msk            (0x1UL << FLASH_ACR_SLEEP_PD_Pos)    /*!< 0x00004000 */
N#define FLASH_ACR_SLEEP_PD                FLASH_ACR_SLEEP_PD_Msk               /*!< Flash power down mode during sleep */
N
N/*******************  Bits definition for FLASH_SR register  ******************/
N#define FLASH_SR_EOP_Pos                  (0U)
N#define FLASH_SR_EOP_Msk                  (0x1UL << FLASH_SR_EOP_Pos)          /*!< 0x00000001 */
N#define FLASH_SR_EOP                      FLASH_SR_EOP_Msk
N#define FLASH_SR_OPERR_Pos                (1U)
N#define FLASH_SR_OPERR_Msk                (0x1UL << FLASH_SR_OPERR_Pos)        /*!< 0x00000002 */
N#define FLASH_SR_OPERR                    FLASH_SR_OPERR_Msk
N#define FLASH_SR_PROGERR_Pos              (3U)
N#define FLASH_SR_PROGERR_Msk              (0x1UL << FLASH_SR_PROGERR_Pos)      /*!< 0x00000008 */
N#define FLASH_SR_PROGERR                  FLASH_SR_PROGERR_Msk
N#define FLASH_SR_WRPERR_Pos               (4U)
N#define FLASH_SR_WRPERR_Msk               (0x1UL << FLASH_SR_WRPERR_Pos)       /*!< 0x00000010 */
N#define FLASH_SR_WRPERR                   FLASH_SR_WRPERR_Msk
N#define FLASH_SR_PGAERR_Pos               (5U)
N#define FLASH_SR_PGAERR_Msk               (0x1UL << FLASH_SR_PGAERR_Pos)       /*!< 0x00000020 */
N#define FLASH_SR_PGAERR                   FLASH_SR_PGAERR_Msk
N#define FLASH_SR_SIZERR_Pos               (6U)
N#define FLASH_SR_SIZERR_Msk               (0x1UL << FLASH_SR_SIZERR_Pos)       /*!< 0x00000040 */
N#define FLASH_SR_SIZERR                   FLASH_SR_SIZERR_Msk
N#define FLASH_SR_PGSERR_Pos               (7U)
N#define FLASH_SR_PGSERR_Msk               (0x1UL << FLASH_SR_PGSERR_Pos)       /*!< 0x00000080 */
N#define FLASH_SR_PGSERR                   FLASH_SR_PGSERR_Msk
N#define FLASH_SR_MISERR_Pos               (8U)
N#define FLASH_SR_MISERR_Msk               (0x1UL << FLASH_SR_MISERR_Pos)       /*!< 0x00000100 */
N#define FLASH_SR_MISERR                   FLASH_SR_MISERR_Msk
N#define FLASH_SR_FASTERR_Pos              (9U)
N#define FLASH_SR_FASTERR_Msk              (0x1UL << FLASH_SR_FASTERR_Pos)      /*!< 0x00000200 */
N#define FLASH_SR_FASTERR                  FLASH_SR_FASTERR_Msk
N#define FLASH_SR_RDERR_Pos                (14U)
N#define FLASH_SR_RDERR_Msk                (0x1UL << FLASH_SR_RDERR_Pos)        /*!< 0x00004000 */
N#define FLASH_SR_RDERR                    FLASH_SR_RDERR_Msk
N#define FLASH_SR_OPTVERR_Pos              (15U)
N#define FLASH_SR_OPTVERR_Msk              (0x1UL << FLASH_SR_OPTVERR_Pos)      /*!< 0x00008000 */
N#define FLASH_SR_OPTVERR                  FLASH_SR_OPTVERR_Msk
N#define FLASH_SR_BSY_Pos                  (16U)
N#define FLASH_SR_BSY_Msk                  (0x1UL << FLASH_SR_BSY_Pos)          /*!< 0x00010000 */
N#define FLASH_SR_BSY                      FLASH_SR_BSY_Msk
N#define FLASH_SR_PEMPTY_Pos               (17U)
N#define FLASH_SR_PEMPTY_Msk               (0x1UL << FLASH_SR_PEMPTY_Pos)       /*!< 0x00020000 */
N#define FLASH_SR_PEMPTY                   FLASH_SR_PEMPTY_Msk
N
N/*******************  Bits definition for FLASH_CR register  ******************/
N#define FLASH_CR_PG_Pos                   (0U)
N#define FLASH_CR_PG_Msk                   (0x1UL << FLASH_CR_PG_Pos)           /*!< 0x00000001 */
N#define FLASH_CR_PG                       FLASH_CR_PG_Msk
N#define FLASH_CR_PER_Pos                  (1U)
N#define FLASH_CR_PER_Msk                  (0x1UL << FLASH_CR_PER_Pos)          /*!< 0x00000002 */
N#define FLASH_CR_PER                      FLASH_CR_PER_Msk
N#define FLASH_CR_MER1_Pos                 (2U)
N#define FLASH_CR_MER1_Msk                 (0x1UL << FLASH_CR_MER1_Pos)         /*!< 0x00000004 */
N#define FLASH_CR_MER1                     FLASH_CR_MER1_Msk
N#define FLASH_CR_PNB_Pos                  (3U)
N#define FLASH_CR_PNB_Msk                  (0xFFUL << FLASH_CR_PNB_Pos)         /*!< 0x000007F8 */
N#define FLASH_CR_PNB                      FLASH_CR_PNB_Msk
N#define FLASH_CR_STRT_Pos                 (16U)
N#define FLASH_CR_STRT_Msk                 (0x1UL << FLASH_CR_STRT_Pos)         /*!< 0x00010000 */
N#define FLASH_CR_STRT                     FLASH_CR_STRT_Msk
N#define FLASH_CR_OPTSTRT_Pos              (17U)
N#define FLASH_CR_OPTSTRT_Msk              (0x1UL << FLASH_CR_OPTSTRT_Pos)      /*!< 0x00020000 */
N#define FLASH_CR_OPTSTRT                  FLASH_CR_OPTSTRT_Msk
N#define FLASH_CR_FSTPG_Pos                (18U)
N#define FLASH_CR_FSTPG_Msk                (0x1UL << FLASH_CR_FSTPG_Pos)        /*!< 0x00040000 */
N#define FLASH_CR_FSTPG                    FLASH_CR_FSTPG_Msk
N#define FLASH_CR_EOPIE_Pos                (24U)
N#define FLASH_CR_EOPIE_Msk                (0x1UL << FLASH_CR_EOPIE_Pos)        /*!< 0x01000000 */
N#define FLASH_CR_EOPIE                    FLASH_CR_EOPIE_Msk
N#define FLASH_CR_ERRIE_Pos                (25U)
N#define FLASH_CR_ERRIE_Msk                (0x1UL << FLASH_CR_ERRIE_Pos)        /*!< 0x02000000 */
N#define FLASH_CR_ERRIE                    FLASH_CR_ERRIE_Msk
N#define FLASH_CR_RDERRIE_Pos              (26U)
N#define FLASH_CR_RDERRIE_Msk              (0x1UL << FLASH_CR_RDERRIE_Pos)      /*!< 0x04000000 */
N#define FLASH_CR_RDERRIE                  FLASH_CR_RDERRIE_Msk
N#define FLASH_CR_OBL_LAUNCH_Pos           (27U)
N#define FLASH_CR_OBL_LAUNCH_Msk           (0x1UL << FLASH_CR_OBL_LAUNCH_Pos)   /*!< 0x08000000 */
N#define FLASH_CR_OBL_LAUNCH               FLASH_CR_OBL_LAUNCH_Msk
N#define FLASH_CR_OPTLOCK_Pos              (30U)
N#define FLASH_CR_OPTLOCK_Msk              (0x1UL << FLASH_CR_OPTLOCK_Pos)      /*!< 0x40000000 */
N#define FLASH_CR_OPTLOCK                  FLASH_CR_OPTLOCK_Msk
N#define FLASH_CR_LOCK_Pos                 (31U)
N#define FLASH_CR_LOCK_Msk                 (0x1UL << FLASH_CR_LOCK_Pos)         /*!< 0x80000000 */
N#define FLASH_CR_LOCK                     FLASH_CR_LOCK_Msk
N
N/*******************  Bits definition for FLASH_ECCR register  ***************/
N#define FLASH_ECCR_ADDR_ECC_Pos           (0U)
N#define FLASH_ECCR_ADDR_ECC_Msk           (0x7FFFFUL << FLASH_ECCR_ADDR_ECC_Pos) /*!< 0x0007FFFF */
N#define FLASH_ECCR_ADDR_ECC               FLASH_ECCR_ADDR_ECC_Msk
N#define FLASH_ECCR_SYSF_ECC_Pos           (20U)
N#define FLASH_ECCR_SYSF_ECC_Msk           (0x1UL << FLASH_ECCR_SYSF_ECC_Pos)   /*!< 0x00100000 */
N#define FLASH_ECCR_SYSF_ECC               FLASH_ECCR_SYSF_ECC_Msk
N#define FLASH_ECCR_ECCIE_Pos              (24U)
N#define FLASH_ECCR_ECCIE_Msk              (0x1UL << FLASH_ECCR_ECCIE_Pos)      /*!< 0x01000000 */
N#define FLASH_ECCR_ECCIE                  FLASH_ECCR_ECCIE_Msk
N#define FLASH_ECCR_ECCC_Pos               (30U)
N#define FLASH_ECCR_ECCC_Msk               (0x1UL << FLASH_ECCR_ECCC_Pos)       /*!< 0x40000000 */
N#define FLASH_ECCR_ECCC                   FLASH_ECCR_ECCC_Msk
N#define FLASH_ECCR_ECCD_Pos               (31U)
N#define FLASH_ECCR_ECCD_Msk               (0x1UL << FLASH_ECCR_ECCD_Pos)       /*!< 0x80000000 */
N#define FLASH_ECCR_ECCD                   FLASH_ECCR_ECCD_Msk
N
N/*******************  Bits definition for FLASH_OPTR register  ***************/
N#define FLASH_OPTR_RDP_Pos                (0U)
N#define FLASH_OPTR_RDP_Msk                (0xFFUL << FLASH_OPTR_RDP_Pos)       /*!< 0x000000FF */
N#define FLASH_OPTR_RDP                    FLASH_OPTR_RDP_Msk
N#define FLASH_OPTR_BOR_LEV_Pos            (8U)
N#define FLASH_OPTR_BOR_LEV_Msk            (0x7UL << FLASH_OPTR_BOR_LEV_Pos)    /*!< 0x00000700 */
N#define FLASH_OPTR_BOR_LEV                FLASH_OPTR_BOR_LEV_Msk
N#define FLASH_OPTR_BOR_LEV_0              (0x0UL << FLASH_OPTR_BOR_LEV_Pos)    /*!< 0x00000000 */
N#define FLASH_OPTR_BOR_LEV_1              (0x1UL << FLASH_OPTR_BOR_LEV_Pos)    /*!< 0x00000100 */
N#define FLASH_OPTR_BOR_LEV_2              (0x2UL << FLASH_OPTR_BOR_LEV_Pos)    /*!< 0x00000200 */
N#define FLASH_OPTR_BOR_LEV_3              (0x3UL << FLASH_OPTR_BOR_LEV_Pos)    /*!< 0x00000300 */
N#define FLASH_OPTR_BOR_LEV_4              (0x4UL << FLASH_OPTR_BOR_LEV_Pos)    /*!< 0x00000400 */
N#define FLASH_OPTR_nRST_STOP_Pos          (12U)
N#define FLASH_OPTR_nRST_STOP_Msk          (0x1UL << FLASH_OPTR_nRST_STOP_Pos)  /*!< 0x00001000 */
N#define FLASH_OPTR_nRST_STOP              FLASH_OPTR_nRST_STOP_Msk
N#define FLASH_OPTR_nRST_STDBY_Pos         (13U)
N#define FLASH_OPTR_nRST_STDBY_Msk         (0x1UL << FLASH_OPTR_nRST_STDBY_Pos) /*!< 0x00002000 */
N#define FLASH_OPTR_nRST_STDBY             FLASH_OPTR_nRST_STDBY_Msk
N#define FLASH_OPTR_nRST_SHDW_Pos          (14U)
N#define FLASH_OPTR_nRST_SHDW_Msk          (0x1UL << FLASH_OPTR_nRST_SHDW_Pos)  /*!< 0x00004000 */
N#define FLASH_OPTR_nRST_SHDW              FLASH_OPTR_nRST_SHDW_Msk
N#define FLASH_OPTR_IWDG_SW_Pos            (16U)
N#define FLASH_OPTR_IWDG_SW_Msk            (0x1UL << FLASH_OPTR_IWDG_SW_Pos)    /*!< 0x00010000 */
N#define FLASH_OPTR_IWDG_SW                FLASH_OPTR_IWDG_SW_Msk
N#define FLASH_OPTR_IWDG_STOP_Pos          (17U)
N#define FLASH_OPTR_IWDG_STOP_Msk          (0x1UL << FLASH_OPTR_IWDG_STOP_Pos)  /*!< 0x00020000 */
N#define FLASH_OPTR_IWDG_STOP              FLASH_OPTR_IWDG_STOP_Msk
N#define FLASH_OPTR_IWDG_STDBY_Pos         (18U)
N#define FLASH_OPTR_IWDG_STDBY_Msk         (0x1UL << FLASH_OPTR_IWDG_STDBY_Pos) /*!< 0x00040000 */
N#define FLASH_OPTR_IWDG_STDBY             FLASH_OPTR_IWDG_STDBY_Msk
N#define FLASH_OPTR_WWDG_SW_Pos            (19U)
N#define FLASH_OPTR_WWDG_SW_Msk            (0x1UL << FLASH_OPTR_WWDG_SW_Pos)    /*!< 0x00080000 */
N#define FLASH_OPTR_WWDG_SW                FLASH_OPTR_WWDG_SW_Msk
N#define FLASH_OPTR_nBOOT1_Pos             (23U)
N#define FLASH_OPTR_nBOOT1_Msk             (0x1UL << FLASH_OPTR_nBOOT1_Pos)     /*!< 0x00800000 */
N#define FLASH_OPTR_nBOOT1                 FLASH_OPTR_nBOOT1_Msk
N#define FLASH_OPTR_SRAM2_PE_Pos           (24U)
N#define FLASH_OPTR_SRAM2_PE_Msk           (0x1UL << FLASH_OPTR_SRAM2_PE_Pos)   /*!< 0x01000000 */
N#define FLASH_OPTR_SRAM2_PE               FLASH_OPTR_SRAM2_PE_Msk
N#define FLASH_OPTR_SRAM2_RST_Pos          (25U)
N#define FLASH_OPTR_SRAM2_RST_Msk          (0x1UL << FLASH_OPTR_SRAM2_RST_Pos)  /*!< 0x02000000 */
N#define FLASH_OPTR_SRAM2_RST              FLASH_OPTR_SRAM2_RST_Msk
N#define FLASH_OPTR_nSWBOOT0_Pos           (26U)
N#define FLASH_OPTR_nSWBOOT0_Msk           (0x1UL << FLASH_OPTR_nSWBOOT0_Pos)   /*!< 0x04000000 */
N#define FLASH_OPTR_nSWBOOT0               FLASH_OPTR_nSWBOOT0_Msk
N#define FLASH_OPTR_nBOOT0_Pos             (27U)
N#define FLASH_OPTR_nBOOT0_Msk             (0x1UL << FLASH_OPTR_nBOOT0_Pos)     /*!< 0x08000000 */
N#define FLASH_OPTR_nBOOT0                 FLASH_OPTR_nBOOT0_Msk
N
N/******************  Bits definition for FLASH_PCROP1SR register  **********/
N#define FLASH_PCROP1SR_PCROP1_STRT_Pos    (0U)
N#define FLASH_PCROP1SR_PCROP1_STRT_Msk    (0xFFFFUL << FLASH_PCROP1SR_PCROP1_STRT_Pos) /*!< 0x0000FFFF */
N#define FLASH_PCROP1SR_PCROP1_STRT        FLASH_PCROP1SR_PCROP1_STRT_Msk
N
N/******************  Bits definition for FLASH_PCROP1ER register  ***********/
N#define FLASH_PCROP1ER_PCROP1_END_Pos     (0U)
N#define FLASH_PCROP1ER_PCROP1_END_Msk     (0xFFFFUL << FLASH_PCROP1ER_PCROP1_END_Pos) /*!< 0x0000FFFF */
N#define FLASH_PCROP1ER_PCROP1_END         FLASH_PCROP1ER_PCROP1_END_Msk
N#define FLASH_PCROP1ER_PCROP_RDP_Pos      (31U)
N#define FLASH_PCROP1ER_PCROP_RDP_Msk      (0x1UL << FLASH_PCROP1ER_PCROP_RDP_Pos) /*!< 0x80000000 */
N#define FLASH_PCROP1ER_PCROP_RDP          FLASH_PCROP1ER_PCROP_RDP_Msk
N
N/******************  Bits definition for FLASH_WRP1AR register  ***************/
N#define FLASH_WRP1AR_WRP1A_STRT_Pos       (0U)
N#define FLASH_WRP1AR_WRP1A_STRT_Msk       (0xFFUL << FLASH_WRP1AR_WRP1A_STRT_Pos) /*!< 0x000000FF */
N#define FLASH_WRP1AR_WRP1A_STRT           FLASH_WRP1AR_WRP1A_STRT_Msk
N#define FLASH_WRP1AR_WRP1A_END_Pos        (16U)
N#define FLASH_WRP1AR_WRP1A_END_Msk        (0xFFUL << FLASH_WRP1AR_WRP1A_END_Pos) /*!< 0x00FF0000 */
N#define FLASH_WRP1AR_WRP1A_END            FLASH_WRP1AR_WRP1A_END_Msk
N
N/******************  Bits definition for FLASH_WRPB1R register  ***************/
N#define FLASH_WRP1BR_WRP1B_STRT_Pos       (0U)
N#define FLASH_WRP1BR_WRP1B_STRT_Msk       (0xFFUL << FLASH_WRP1BR_WRP1B_STRT_Pos) /*!< 0x000000FF */
N#define FLASH_WRP1BR_WRP1B_STRT           FLASH_WRP1BR_WRP1B_STRT_Msk
N#define FLASH_WRP1BR_WRP1B_END_Pos        (16U)
N#define FLASH_WRP1BR_WRP1B_END_Msk        (0xFFUL << FLASH_WRP1BR_WRP1B_END_Pos) /*!< 0x00FF0000 */
N#define FLASH_WRP1BR_WRP1B_END            FLASH_WRP1BR_WRP1B_END_Msk
N
N
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                       General Purpose IOs (GPIO)                           */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bits definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODE0_Pos           (0U)
N#define GPIO_MODER_MODE0_Msk           (0x3UL << GPIO_MODER_MODE0_Pos)         /*!< 0x00000003 */
N#define GPIO_MODER_MODE0               GPIO_MODER_MODE0_Msk
N#define GPIO_MODER_MODE0_0             (0x1UL << GPIO_MODER_MODE0_Pos)         /*!< 0x00000001 */
N#define GPIO_MODER_MODE0_1             (0x2UL << GPIO_MODER_MODE0_Pos)         /*!< 0x00000002 */
N#define GPIO_MODER_MODE1_Pos           (2U)
N#define GPIO_MODER_MODE1_Msk           (0x3UL << GPIO_MODER_MODE1_Pos)         /*!< 0x0000000C */
N#define GPIO_MODER_MODE1               GPIO_MODER_MODE1_Msk
N#define GPIO_MODER_MODE1_0             (0x1UL << GPIO_MODER_MODE1_Pos)         /*!< 0x00000004 */
N#define GPIO_MODER_MODE1_1             (0x2UL << GPIO_MODER_MODE1_Pos)         /*!< 0x00000008 */
N#define GPIO_MODER_MODE2_Pos           (4U)
N#define GPIO_MODER_MODE2_Msk           (0x3UL << GPIO_MODER_MODE2_Pos)         /*!< 0x00000030 */
N#define GPIO_MODER_MODE2               GPIO_MODER_MODE2_Msk
N#define GPIO_MODER_MODE2_0             (0x1UL << GPIO_MODER_MODE2_Pos)         /*!< 0x00000010 */
N#define GPIO_MODER_MODE2_1             (0x2UL << GPIO_MODER_MODE2_Pos)         /*!< 0x00000020 */
N#define GPIO_MODER_MODE3_Pos           (6U)
N#define GPIO_MODER_MODE3_Msk           (0x3UL << GPIO_MODER_MODE3_Pos)         /*!< 0x000000C0 */
N#define GPIO_MODER_MODE3               GPIO_MODER_MODE3_Msk
N#define GPIO_MODER_MODE3_0             (0x1UL << GPIO_MODER_MODE3_Pos)         /*!< 0x00000040 */
N#define GPIO_MODER_MODE3_1             (0x2UL << GPIO_MODER_MODE3_Pos)         /*!< 0x00000080 */
N#define GPIO_MODER_MODE4_Pos           (8U)
N#define GPIO_MODER_MODE4_Msk           (0x3UL << GPIO_MODER_MODE4_Pos)         /*!< 0x00000300 */
N#define GPIO_MODER_MODE4               GPIO_MODER_MODE4_Msk
N#define GPIO_MODER_MODE4_0             (0x1UL << GPIO_MODER_MODE4_Pos)         /*!< 0x00000100 */
N#define GPIO_MODER_MODE4_1             (0x2UL << GPIO_MODER_MODE4_Pos)         /*!< 0x00000200 */
N#define GPIO_MODER_MODE5_Pos           (10U)
N#define GPIO_MODER_MODE5_Msk           (0x3UL << GPIO_MODER_MODE5_Pos)         /*!< 0x00000C00 */
N#define GPIO_MODER_MODE5               GPIO_MODER_MODE5_Msk
N#define GPIO_MODER_MODE5_0             (0x1UL << GPIO_MODER_MODE5_Pos)         /*!< 0x00000400 */
N#define GPIO_MODER_MODE5_1             (0x2UL << GPIO_MODER_MODE5_Pos)         /*!< 0x00000800 */
N#define GPIO_MODER_MODE6_Pos           (12U)
N#define GPIO_MODER_MODE6_Msk           (0x3UL << GPIO_MODER_MODE6_Pos)         /*!< 0x00003000 */
N#define GPIO_MODER_MODE6               GPIO_MODER_MODE6_Msk
N#define GPIO_MODER_MODE6_0             (0x1UL << GPIO_MODER_MODE6_Pos)         /*!< 0x00001000 */
N#define GPIO_MODER_MODE6_1             (0x2UL << GPIO_MODER_MODE6_Pos)         /*!< 0x00002000 */
N#define GPIO_MODER_MODE7_Pos           (14U)
N#define GPIO_MODER_MODE7_Msk           (0x3UL << GPIO_MODER_MODE7_Pos)         /*!< 0x0000C000 */
N#define GPIO_MODER_MODE7               GPIO_MODER_MODE7_Msk
N#define GPIO_MODER_MODE7_0             (0x1UL << GPIO_MODER_MODE7_Pos)         /*!< 0x00004000 */
N#define GPIO_MODER_MODE7_1             (0x2UL << GPIO_MODER_MODE7_Pos)         /*!< 0x00008000 */
N#define GPIO_MODER_MODE8_Pos           (16U)
N#define GPIO_MODER_MODE8_Msk           (0x3UL << GPIO_MODER_MODE8_Pos)         /*!< 0x00030000 */
N#define GPIO_MODER_MODE8               GPIO_MODER_MODE8_Msk
N#define GPIO_MODER_MODE8_0             (0x1UL << GPIO_MODER_MODE8_Pos)         /*!< 0x00010000 */
N#define GPIO_MODER_MODE8_1             (0x2UL << GPIO_MODER_MODE8_Pos)         /*!< 0x00020000 */
N#define GPIO_MODER_MODE9_Pos           (18U)
N#define GPIO_MODER_MODE9_Msk           (0x3UL << GPIO_MODER_MODE9_Pos)         /*!< 0x000C0000 */
N#define GPIO_MODER_MODE9               GPIO_MODER_MODE9_Msk
N#define GPIO_MODER_MODE9_0             (0x1UL << GPIO_MODER_MODE9_Pos)         /*!< 0x00040000 */
N#define GPIO_MODER_MODE9_1             (0x2UL << GPIO_MODER_MODE9_Pos)         /*!< 0x00080000 */
N#define GPIO_MODER_MODE10_Pos          (20U)
N#define GPIO_MODER_MODE10_Msk          (0x3UL << GPIO_MODER_MODE10_Pos)        /*!< 0x00300000 */
N#define GPIO_MODER_MODE10              GPIO_MODER_MODE10_Msk
N#define GPIO_MODER_MODE10_0            (0x1UL << GPIO_MODER_MODE10_Pos)        /*!< 0x00100000 */
N#define GPIO_MODER_MODE10_1            (0x2UL << GPIO_MODER_MODE10_Pos)        /*!< 0x00200000 */
N#define GPIO_MODER_MODE11_Pos          (22U)
N#define GPIO_MODER_MODE11_Msk          (0x3UL << GPIO_MODER_MODE11_Pos)        /*!< 0x00C00000 */
N#define GPIO_MODER_MODE11              GPIO_MODER_MODE11_Msk
N#define GPIO_MODER_MODE11_0            (0x1UL << GPIO_MODER_MODE11_Pos)        /*!< 0x00400000 */
N#define GPIO_MODER_MODE11_1            (0x2UL << GPIO_MODER_MODE11_Pos)        /*!< 0x00800000 */
N#define GPIO_MODER_MODE12_Pos          (24U)
N#define GPIO_MODER_MODE12_Msk          (0x3UL << GPIO_MODER_MODE12_Pos)        /*!< 0x03000000 */
N#define GPIO_MODER_MODE12              GPIO_MODER_MODE12_Msk
N#define GPIO_MODER_MODE12_0            (0x1UL << GPIO_MODER_MODE12_Pos)        /*!< 0x01000000 */
N#define GPIO_MODER_MODE12_1            (0x2UL << GPIO_MODER_MODE12_Pos)        /*!< 0x02000000 */
N#define GPIO_MODER_MODE13_Pos          (26U)
N#define GPIO_MODER_MODE13_Msk          (0x3UL << GPIO_MODER_MODE13_Pos)        /*!< 0x0C000000 */
N#define GPIO_MODER_MODE13              GPIO_MODER_MODE13_Msk
N#define GPIO_MODER_MODE13_0            (0x1UL << GPIO_MODER_MODE13_Pos)        /*!< 0x04000000 */
N#define GPIO_MODER_MODE13_1            (0x2UL << GPIO_MODER_MODE13_Pos)        /*!< 0x08000000 */
N#define GPIO_MODER_MODE14_Pos          (28U)
N#define GPIO_MODER_MODE14_Msk          (0x3UL << GPIO_MODER_MODE14_Pos)        /*!< 0x30000000 */
N#define GPIO_MODER_MODE14              GPIO_MODER_MODE14_Msk
N#define GPIO_MODER_MODE14_0            (0x1UL << GPIO_MODER_MODE14_Pos)        /*!< 0x10000000 */
N#define GPIO_MODER_MODE14_1            (0x2UL << GPIO_MODER_MODE14_Pos)        /*!< 0x20000000 */
N#define GPIO_MODER_MODE15_Pos          (30U)
N#define GPIO_MODER_MODE15_Msk          (0x3UL << GPIO_MODER_MODE15_Pos)        /*!< 0xC0000000 */
N#define GPIO_MODER_MODE15              GPIO_MODER_MODE15_Msk
N#define GPIO_MODER_MODE15_0            (0x1UL << GPIO_MODER_MODE15_Pos)        /*!< 0x40000000 */
N#define GPIO_MODER_MODE15_1            (0x2UL << GPIO_MODER_MODE15_Pos)        /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_MODER_MODER0                   GPIO_MODER_MODE0
N#define GPIO_MODER_MODER0_0                 GPIO_MODER_MODE0_0
N#define GPIO_MODER_MODER0_1                 GPIO_MODER_MODE0_1
N#define GPIO_MODER_MODER1                   GPIO_MODER_MODE1
N#define GPIO_MODER_MODER1_0                 GPIO_MODER_MODE1_0
N#define GPIO_MODER_MODER1_1                 GPIO_MODER_MODE1_1
N#define GPIO_MODER_MODER2                   GPIO_MODER_MODE2
N#define GPIO_MODER_MODER2_0                 GPIO_MODER_MODE2_0
N#define GPIO_MODER_MODER2_1                 GPIO_MODER_MODE2_1
N#define GPIO_MODER_MODER3                   GPIO_MODER_MODE3
N#define GPIO_MODER_MODER3_0                 GPIO_MODER_MODE3_0
N#define GPIO_MODER_MODER3_1                 GPIO_MODER_MODE3_1
N#define GPIO_MODER_MODER4                   GPIO_MODER_MODE4
N#define GPIO_MODER_MODER4_0                 GPIO_MODER_MODE4_0
N#define GPIO_MODER_MODER4_1                 GPIO_MODER_MODE4_1
N#define GPIO_MODER_MODER5                   GPIO_MODER_MODE5
N#define GPIO_MODER_MODER5_0                 GPIO_MODER_MODE5_0
N#define GPIO_MODER_MODER5_1                 GPIO_MODER_MODE5_1
N#define GPIO_MODER_MODER6                   GPIO_MODER_MODE6
N#define GPIO_MODER_MODER6_0                 GPIO_MODER_MODE6_0
N#define GPIO_MODER_MODER6_1                 GPIO_MODER_MODE6_1
N#define GPIO_MODER_MODER7                   GPIO_MODER_MODE7
N#define GPIO_MODER_MODER7_0                 GPIO_MODER_MODE7_0
N#define GPIO_MODER_MODER7_1                 GPIO_MODER_MODE7_1
N#define GPIO_MODER_MODER8                   GPIO_MODER_MODE8
N#define GPIO_MODER_MODER8_0                 GPIO_MODER_MODE8_0
N#define GPIO_MODER_MODER8_1                 GPIO_MODER_MODE8_1
N#define GPIO_MODER_MODER9                   GPIO_MODER_MODE9
N#define GPIO_MODER_MODER9_0                 GPIO_MODER_MODE9_0
N#define GPIO_MODER_MODER9_1                 GPIO_MODER_MODE9_1
N#define GPIO_MODER_MODER10                  GPIO_MODER_MODE10
N#define GPIO_MODER_MODER10_0                GPIO_MODER_MODE10_0
N#define GPIO_MODER_MODER10_1                GPIO_MODER_MODE10_1
N#define GPIO_MODER_MODER11                  GPIO_MODER_MODE11
N#define GPIO_MODER_MODER11_0                GPIO_MODER_MODE11_0
N#define GPIO_MODER_MODER11_1                GPIO_MODER_MODE11_1
N#define GPIO_MODER_MODER12                  GPIO_MODER_MODE12
N#define GPIO_MODER_MODER12_0                GPIO_MODER_MODE12_0
N#define GPIO_MODER_MODER12_1                GPIO_MODER_MODE12_1
N#define GPIO_MODER_MODER13                  GPIO_MODER_MODE13
N#define GPIO_MODER_MODER13_0                GPIO_MODER_MODE13_0
N#define GPIO_MODER_MODER13_1                GPIO_MODER_MODE13_1
N#define GPIO_MODER_MODER14                  GPIO_MODER_MODE14
N#define GPIO_MODER_MODER14_0                GPIO_MODER_MODE14_0
N#define GPIO_MODER_MODER14_1                GPIO_MODER_MODE14_1
N#define GPIO_MODER_MODER15                  GPIO_MODER_MODE15
N#define GPIO_MODER_MODER15_0                GPIO_MODER_MODE15_0
N#define GPIO_MODER_MODER15_1                GPIO_MODER_MODE15_1
N
N/******************  Bits definition for GPIO_OTYPER register  ****************/
N#define GPIO_OTYPER_OT0_Pos            (0U)
N#define GPIO_OTYPER_OT0_Msk            (0x1UL << GPIO_OTYPER_OT0_Pos)          /*!< 0x00000001 */
N#define GPIO_OTYPER_OT0                GPIO_OTYPER_OT0_Msk
N#define GPIO_OTYPER_OT1_Pos            (1U)
N#define GPIO_OTYPER_OT1_Msk            (0x1UL << GPIO_OTYPER_OT1_Pos)          /*!< 0x00000002 */
N#define GPIO_OTYPER_OT1                GPIO_OTYPER_OT1_Msk
N#define GPIO_OTYPER_OT2_Pos            (2U)
N#define GPIO_OTYPER_OT2_Msk            (0x1UL << GPIO_OTYPER_OT2_Pos)          /*!< 0x00000004 */
N#define GPIO_OTYPER_OT2                GPIO_OTYPER_OT2_Msk
N#define GPIO_OTYPER_OT3_Pos            (3U)
N#define GPIO_OTYPER_OT3_Msk            (0x1UL << GPIO_OTYPER_OT3_Pos)          /*!< 0x00000008 */
N#define GPIO_OTYPER_OT3                GPIO_OTYPER_OT3_Msk
N#define GPIO_OTYPER_OT4_Pos            (4U)
N#define GPIO_OTYPER_OT4_Msk            (0x1UL << GPIO_OTYPER_OT4_Pos)          /*!< 0x00000010 */
N#define GPIO_OTYPER_OT4                GPIO_OTYPER_OT4_Msk
N#define GPIO_OTYPER_OT5_Pos            (5U)
N#define GPIO_OTYPER_OT5_Msk            (0x1UL << GPIO_OTYPER_OT5_Pos)          /*!< 0x00000020 */
N#define GPIO_OTYPER_OT5                GPIO_OTYPER_OT5_Msk
N#define GPIO_OTYPER_OT6_Pos            (6U)
N#define GPIO_OTYPER_OT6_Msk            (0x1UL << GPIO_OTYPER_OT6_Pos)          /*!< 0x00000040 */
N#define GPIO_OTYPER_OT6                GPIO_OTYPER_OT6_Msk
N#define GPIO_OTYPER_OT7_Pos            (7U)
N#define GPIO_OTYPER_OT7_Msk            (0x1UL << GPIO_OTYPER_OT7_Pos)          /*!< 0x00000080 */
N#define GPIO_OTYPER_OT7                GPIO_OTYPER_OT7_Msk
N#define GPIO_OTYPER_OT8_Pos            (8U)
N#define GPIO_OTYPER_OT8_Msk            (0x1UL << GPIO_OTYPER_OT8_Pos)          /*!< 0x00000100 */
N#define GPIO_OTYPER_OT8                GPIO_OTYPER_OT8_Msk
N#define GPIO_OTYPER_OT9_Pos            (9U)
N#define GPIO_OTYPER_OT9_Msk            (0x1UL << GPIO_OTYPER_OT9_Pos)          /*!< 0x00000200 */
N#define GPIO_OTYPER_OT9                GPIO_OTYPER_OT9_Msk
N#define GPIO_OTYPER_OT10_Pos           (10U)
N#define GPIO_OTYPER_OT10_Msk           (0x1UL << GPIO_OTYPER_OT10_Pos)         /*!< 0x00000400 */
N#define GPIO_OTYPER_OT10               GPIO_OTYPER_OT10_Msk
N#define GPIO_OTYPER_OT11_Pos           (11U)
N#define GPIO_OTYPER_OT11_Msk           (0x1UL << GPIO_OTYPER_OT11_Pos)         /*!< 0x00000800 */
N#define GPIO_OTYPER_OT11               GPIO_OTYPER_OT11_Msk
N#define GPIO_OTYPER_OT12_Pos           (12U)
N#define GPIO_OTYPER_OT12_Msk           (0x1UL << GPIO_OTYPER_OT12_Pos)         /*!< 0x00001000 */
N#define GPIO_OTYPER_OT12               GPIO_OTYPER_OT12_Msk
N#define GPIO_OTYPER_OT13_Pos           (13U)
N#define GPIO_OTYPER_OT13_Msk           (0x1UL << GPIO_OTYPER_OT13_Pos)         /*!< 0x00002000 */
N#define GPIO_OTYPER_OT13               GPIO_OTYPER_OT13_Msk
N#define GPIO_OTYPER_OT14_Pos           (14U)
N#define GPIO_OTYPER_OT14_Msk           (0x1UL << GPIO_OTYPER_OT14_Pos)         /*!< 0x00004000 */
N#define GPIO_OTYPER_OT14               GPIO_OTYPER_OT14_Msk
N#define GPIO_OTYPER_OT15_Pos           (15U)
N#define GPIO_OTYPER_OT15_Msk           (0x1UL << GPIO_OTYPER_OT15_Pos)         /*!< 0x00008000 */
N#define GPIO_OTYPER_OT15               GPIO_OTYPER_OT15_Msk
N
N/* Legacy defines */
N#define GPIO_OTYPER_OT_0                    GPIO_OTYPER_OT0
N#define GPIO_OTYPER_OT_1                    GPIO_OTYPER_OT1
N#define GPIO_OTYPER_OT_2                    GPIO_OTYPER_OT2
N#define GPIO_OTYPER_OT_3                    GPIO_OTYPER_OT3
N#define GPIO_OTYPER_OT_4                    GPIO_OTYPER_OT4
N#define GPIO_OTYPER_OT_5                    GPIO_OTYPER_OT5
N#define GPIO_OTYPER_OT_6                    GPIO_OTYPER_OT6
N#define GPIO_OTYPER_OT_7                    GPIO_OTYPER_OT7
N#define GPIO_OTYPER_OT_8                    GPIO_OTYPER_OT8
N#define GPIO_OTYPER_OT_9                    GPIO_OTYPER_OT9
N#define GPIO_OTYPER_OT_10                   GPIO_OTYPER_OT10
N#define GPIO_OTYPER_OT_11                   GPIO_OTYPER_OT11
N#define GPIO_OTYPER_OT_12                   GPIO_OTYPER_OT12
N#define GPIO_OTYPER_OT_13                   GPIO_OTYPER_OT13
N#define GPIO_OTYPER_OT_14                   GPIO_OTYPER_OT14
N#define GPIO_OTYPER_OT_15                   GPIO_OTYPER_OT15
N
N/******************  Bits definition for GPIO_OSPEEDR register  ***************/
N#define GPIO_OSPEEDR_OSPEED0_Pos       (0U)
N#define GPIO_OSPEEDR_OSPEED0_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED0_Pos)     /*!< 0x00000003 */
N#define GPIO_OSPEEDR_OSPEED0           GPIO_OSPEEDR_OSPEED0_Msk
N#define GPIO_OSPEEDR_OSPEED0_0         (0x1UL << GPIO_OSPEEDR_OSPEED0_Pos)     /*!< 0x00000001 */
N#define GPIO_OSPEEDR_OSPEED0_1         (0x2UL << GPIO_OSPEEDR_OSPEED0_Pos)     /*!< 0x00000002 */
N#define GPIO_OSPEEDR_OSPEED1_Pos       (2U)
N#define GPIO_OSPEEDR_OSPEED1_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED1_Pos)     /*!< 0x0000000C */
N#define GPIO_OSPEEDR_OSPEED1           GPIO_OSPEEDR_OSPEED1_Msk
N#define GPIO_OSPEEDR_OSPEED1_0         (0x1UL << GPIO_OSPEEDR_OSPEED1_Pos)     /*!< 0x00000004 */
N#define GPIO_OSPEEDR_OSPEED1_1         (0x2UL << GPIO_OSPEEDR_OSPEED1_Pos)     /*!< 0x00000008 */
N#define GPIO_OSPEEDR_OSPEED2_Pos       (4U)
N#define GPIO_OSPEEDR_OSPEED2_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED2_Pos)     /*!< 0x00000030 */
N#define GPIO_OSPEEDR_OSPEED2           GPIO_OSPEEDR_OSPEED2_Msk
N#define GPIO_OSPEEDR_OSPEED2_0         (0x1UL << GPIO_OSPEEDR_OSPEED2_Pos)     /*!< 0x00000010 */
N#define GPIO_OSPEEDR_OSPEED2_1         (0x2UL << GPIO_OSPEEDR_OSPEED2_Pos)     /*!< 0x00000020 */
N#define GPIO_OSPEEDR_OSPEED3_Pos       (6U)
N#define GPIO_OSPEEDR_OSPEED3_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED3_Pos)     /*!< 0x000000C0 */
N#define GPIO_OSPEEDR_OSPEED3           GPIO_OSPEEDR_OSPEED3_Msk
N#define GPIO_OSPEEDR_OSPEED3_0         (0x1UL << GPIO_OSPEEDR_OSPEED3_Pos)     /*!< 0x00000040 */
N#define GPIO_OSPEEDR_OSPEED3_1         (0x2UL << GPIO_OSPEEDR_OSPEED3_Pos)     /*!< 0x00000080 */
N#define GPIO_OSPEEDR_OSPEED4_Pos       (8U)
N#define GPIO_OSPEEDR_OSPEED4_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED4_Pos)     /*!< 0x00000300 */
N#define GPIO_OSPEEDR_OSPEED4           GPIO_OSPEEDR_OSPEED4_Msk
N#define GPIO_OSPEEDR_OSPEED4_0         (0x1UL << GPIO_OSPEEDR_OSPEED4_Pos)     /*!< 0x00000100 */
N#define GPIO_OSPEEDR_OSPEED4_1         (0x2UL << GPIO_OSPEEDR_OSPEED4_Pos)     /*!< 0x00000200 */
N#define GPIO_OSPEEDR_OSPEED5_Pos       (10U)
N#define GPIO_OSPEEDR_OSPEED5_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED5_Pos)     /*!< 0x00000C00 */
N#define GPIO_OSPEEDR_OSPEED5           GPIO_OSPEEDR_OSPEED5_Msk
N#define GPIO_OSPEEDR_OSPEED5_0         (0x1UL << GPIO_OSPEEDR_OSPEED5_Pos)     /*!< 0x00000400 */
N#define GPIO_OSPEEDR_OSPEED5_1         (0x2UL << GPIO_OSPEEDR_OSPEED5_Pos)     /*!< 0x00000800 */
N#define GPIO_OSPEEDR_OSPEED6_Pos       (12U)
N#define GPIO_OSPEEDR_OSPEED6_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED6_Pos)     /*!< 0x00003000 */
N#define GPIO_OSPEEDR_OSPEED6           GPIO_OSPEEDR_OSPEED6_Msk
N#define GPIO_OSPEEDR_OSPEED6_0         (0x1UL << GPIO_OSPEEDR_OSPEED6_Pos)     /*!< 0x00001000 */
N#define GPIO_OSPEEDR_OSPEED6_1         (0x2UL << GPIO_OSPEEDR_OSPEED6_Pos)     /*!< 0x00002000 */
N#define GPIO_OSPEEDR_OSPEED7_Pos       (14U)
N#define GPIO_OSPEEDR_OSPEED7_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED7_Pos)     /*!< 0x0000C000 */
N#define GPIO_OSPEEDR_OSPEED7           GPIO_OSPEEDR_OSPEED7_Msk
N#define GPIO_OSPEEDR_OSPEED7_0         (0x1UL << GPIO_OSPEEDR_OSPEED7_Pos)     /*!< 0x00004000 */
N#define GPIO_OSPEEDR_OSPEED7_1         (0x2UL << GPIO_OSPEEDR_OSPEED7_Pos)     /*!< 0x00008000 */
N#define GPIO_OSPEEDR_OSPEED8_Pos       (16U)
N#define GPIO_OSPEEDR_OSPEED8_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED8_Pos)     /*!< 0x00030000 */
N#define GPIO_OSPEEDR_OSPEED8           GPIO_OSPEEDR_OSPEED8_Msk
N#define GPIO_OSPEEDR_OSPEED8_0         (0x1UL << GPIO_OSPEEDR_OSPEED8_Pos)     /*!< 0x00010000 */
N#define GPIO_OSPEEDR_OSPEED8_1         (0x2UL << GPIO_OSPEEDR_OSPEED8_Pos)     /*!< 0x00020000 */
N#define GPIO_OSPEEDR_OSPEED9_Pos       (18U)
N#define GPIO_OSPEEDR_OSPEED9_Msk       (0x3UL << GPIO_OSPEEDR_OSPEED9_Pos)     /*!< 0x000C0000 */
N#define GPIO_OSPEEDR_OSPEED9           GPIO_OSPEEDR_OSPEED9_Msk
N#define GPIO_OSPEEDR_OSPEED9_0         (0x1UL << GPIO_OSPEEDR_OSPEED9_Pos)     /*!< 0x00040000 */
N#define GPIO_OSPEEDR_OSPEED9_1         (0x2UL << GPIO_OSPEEDR_OSPEED9_Pos)     /*!< 0x00080000 */
N#define GPIO_OSPEEDR_OSPEED10_Pos      (20U)
N#define GPIO_OSPEEDR_OSPEED10_Msk      (0x3UL << GPIO_OSPEEDR_OSPEED10_Pos)    /*!< 0x00300000 */
N#define GPIO_OSPEEDR_OSPEED10          GPIO_OSPEEDR_OSPEED10_Msk
N#define GPIO_OSPEEDR_OSPEED10_0        (0x1UL << GPIO_OSPEEDR_OSPEED10_Pos)    /*!< 0x00100000 */
N#define GPIO_OSPEEDR_OSPEED10_1        (0x2UL << GPIO_OSPEEDR_OSPEED10_Pos)    /*!< 0x00200000 */
N#define GPIO_OSPEEDR_OSPEED11_Pos      (22U)
N#define GPIO_OSPEEDR_OSPEED11_Msk      (0x3UL << GPIO_OSPEEDR_OSPEED11_Pos)    /*!< 0x00C00000 */
N#define GPIO_OSPEEDR_OSPEED11          GPIO_OSPEEDR_OSPEED11_Msk
N#define GPIO_OSPEEDR_OSPEED11_0        (0x1UL << GPIO_OSPEEDR_OSPEED11_Pos)    /*!< 0x00400000 */
N#define GPIO_OSPEEDR_OSPEED11_1        (0x2UL << GPIO_OSPEEDR_OSPEED11_Pos)    /*!< 0x00800000 */
N#define GPIO_OSPEEDR_OSPEED12_Pos      (24U)
N#define GPIO_OSPEEDR_OSPEED12_Msk      (0x3UL << GPIO_OSPEEDR_OSPEED12_Pos)    /*!< 0x03000000 */
N#define GPIO_OSPEEDR_OSPEED12          GPIO_OSPEEDR_OSPEED12_Msk
N#define GPIO_OSPEEDR_OSPEED12_0        (0x1UL << GPIO_OSPEEDR_OSPEED12_Pos)    /*!< 0x01000000 */
N#define GPIO_OSPEEDR_OSPEED12_1        (0x2UL << GPIO_OSPEEDR_OSPEED12_Pos)    /*!< 0x02000000 */
N#define GPIO_OSPEEDR_OSPEED13_Pos      (26U)
N#define GPIO_OSPEEDR_OSPEED13_Msk      (0x3UL << GPIO_OSPEEDR_OSPEED13_Pos)    /*!< 0x0C000000 */
N#define GPIO_OSPEEDR_OSPEED13          GPIO_OSPEEDR_OSPEED13_Msk
N#define GPIO_OSPEEDR_OSPEED13_0        (0x1UL << GPIO_OSPEEDR_OSPEED13_Pos)    /*!< 0x04000000 */
N#define GPIO_OSPEEDR_OSPEED13_1        (0x2UL << GPIO_OSPEEDR_OSPEED13_Pos)    /*!< 0x08000000 */
N#define GPIO_OSPEEDR_OSPEED14_Pos      (28U)
N#define GPIO_OSPEEDR_OSPEED14_Msk      (0x3UL << GPIO_OSPEEDR_OSPEED14_Pos)    /*!< 0x30000000 */
N#define GPIO_OSPEEDR_OSPEED14          GPIO_OSPEEDR_OSPEED14_Msk
N#define GPIO_OSPEEDR_OSPEED14_0        (0x1UL << GPIO_OSPEEDR_OSPEED14_Pos)    /*!< 0x10000000 */
N#define GPIO_OSPEEDR_OSPEED14_1        (0x2UL << GPIO_OSPEEDR_OSPEED14_Pos)    /*!< 0x20000000 */
N#define GPIO_OSPEEDR_OSPEED15_Pos      (30U)
N#define GPIO_OSPEEDR_OSPEED15_Msk      (0x3UL << GPIO_OSPEEDR_OSPEED15_Pos)    /*!< 0xC0000000 */
N#define GPIO_OSPEEDR_OSPEED15          GPIO_OSPEEDR_OSPEED15_Msk
N#define GPIO_OSPEEDR_OSPEED15_0        (0x1UL << GPIO_OSPEEDR_OSPEED15_Pos)    /*!< 0x40000000 */
N#define GPIO_OSPEEDR_OSPEED15_1        (0x2UL << GPIO_OSPEEDR_OSPEED15_Pos)    /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_OSPEEDER_OSPEEDR0              GPIO_OSPEEDR_OSPEED0
N#define GPIO_OSPEEDER_OSPEEDR0_0            GPIO_OSPEEDR_OSPEED0_0
N#define GPIO_OSPEEDER_OSPEEDR0_1            GPIO_OSPEEDR_OSPEED0_1
N#define GPIO_OSPEEDER_OSPEEDR1              GPIO_OSPEEDR_OSPEED1
N#define GPIO_OSPEEDER_OSPEEDR1_0            GPIO_OSPEEDR_OSPEED1_0
N#define GPIO_OSPEEDER_OSPEEDR1_1            GPIO_OSPEEDR_OSPEED1_1
N#define GPIO_OSPEEDER_OSPEEDR2              GPIO_OSPEEDR_OSPEED2
N#define GPIO_OSPEEDER_OSPEEDR2_0            GPIO_OSPEEDR_OSPEED2_0
N#define GPIO_OSPEEDER_OSPEEDR2_1            GPIO_OSPEEDR_OSPEED2_1
N#define GPIO_OSPEEDER_OSPEEDR3              GPIO_OSPEEDR_OSPEED3
N#define GPIO_OSPEEDER_OSPEEDR3_0            GPIO_OSPEEDR_OSPEED3_0
N#define GPIO_OSPEEDER_OSPEEDR3_1            GPIO_OSPEEDR_OSPEED3_1
N#define GPIO_OSPEEDER_OSPEEDR4              GPIO_OSPEEDR_OSPEED4
N#define GPIO_OSPEEDER_OSPEEDR4_0            GPIO_OSPEEDR_OSPEED4_0
N#define GPIO_OSPEEDER_OSPEEDR4_1            GPIO_OSPEEDR_OSPEED4_1
N#define GPIO_OSPEEDER_OSPEEDR5              GPIO_OSPEEDR_OSPEED5
N#define GPIO_OSPEEDER_OSPEEDR5_0            GPIO_OSPEEDR_OSPEED5_0
N#define GPIO_OSPEEDER_OSPEEDR5_1            GPIO_OSPEEDR_OSPEED5_1
N#define GPIO_OSPEEDER_OSPEEDR6              GPIO_OSPEEDR_OSPEED6
N#define GPIO_OSPEEDER_OSPEEDR6_0            GPIO_OSPEEDR_OSPEED6_0
N#define GPIO_OSPEEDER_OSPEEDR6_1            GPIO_OSPEEDR_OSPEED6_1
N#define GPIO_OSPEEDER_OSPEEDR7              GPIO_OSPEEDR_OSPEED7
N#define GPIO_OSPEEDER_OSPEEDR7_0            GPIO_OSPEEDR_OSPEED7_0
N#define GPIO_OSPEEDER_OSPEEDR7_1            GPIO_OSPEEDR_OSPEED7_1
N#define GPIO_OSPEEDER_OSPEEDR8              GPIO_OSPEEDR_OSPEED8
N#define GPIO_OSPEEDER_OSPEEDR8_0            GPIO_OSPEEDR_OSPEED8_0
N#define GPIO_OSPEEDER_OSPEEDR8_1            GPIO_OSPEEDR_OSPEED8_1
N#define GPIO_OSPEEDER_OSPEEDR9              GPIO_OSPEEDR_OSPEED9
N#define GPIO_OSPEEDER_OSPEEDR9_0            GPIO_OSPEEDR_OSPEED9_0
N#define GPIO_OSPEEDER_OSPEEDR9_1            GPIO_OSPEEDR_OSPEED9_1
N#define GPIO_OSPEEDER_OSPEEDR10             GPIO_OSPEEDR_OSPEED10
N#define GPIO_OSPEEDER_OSPEEDR10_0           GPIO_OSPEEDR_OSPEED10_0
N#define GPIO_OSPEEDER_OSPEEDR10_1           GPIO_OSPEEDR_OSPEED10_1
N#define GPIO_OSPEEDER_OSPEEDR11             GPIO_OSPEEDR_OSPEED11
N#define GPIO_OSPEEDER_OSPEEDR11_0           GPIO_OSPEEDR_OSPEED11_0
N#define GPIO_OSPEEDER_OSPEEDR11_1           GPIO_OSPEEDR_OSPEED11_1
N#define GPIO_OSPEEDER_OSPEEDR12             GPIO_OSPEEDR_OSPEED12
N#define GPIO_OSPEEDER_OSPEEDR12_0           GPIO_OSPEEDR_OSPEED12_0
N#define GPIO_OSPEEDER_OSPEEDR12_1           GPIO_OSPEEDR_OSPEED12_1
N#define GPIO_OSPEEDER_OSPEEDR13             GPIO_OSPEEDR_OSPEED13
N#define GPIO_OSPEEDER_OSPEEDR13_0           GPIO_OSPEEDR_OSPEED13_0
N#define GPIO_OSPEEDER_OSPEEDR13_1           GPIO_OSPEEDR_OSPEED13_1
N#define GPIO_OSPEEDER_OSPEEDR14             GPIO_OSPEEDR_OSPEED14
N#define GPIO_OSPEEDER_OSPEEDR14_0           GPIO_OSPEEDR_OSPEED14_0
N#define GPIO_OSPEEDER_OSPEEDR14_1           GPIO_OSPEEDR_OSPEED14_1
N#define GPIO_OSPEEDER_OSPEEDR15             GPIO_OSPEEDR_OSPEED15
N#define GPIO_OSPEEDER_OSPEEDR15_0           GPIO_OSPEEDR_OSPEED15_0
N#define GPIO_OSPEEDER_OSPEEDR15_1           GPIO_OSPEEDR_OSPEED15_1
N
N/******************  Bits definition for GPIO_PUPDR register  *****************/
N#define GPIO_PUPDR_PUPD0_Pos           (0U)
N#define GPIO_PUPDR_PUPD0_Msk           (0x3UL << GPIO_PUPDR_PUPD0_Pos)         /*!< 0x00000003 */
N#define GPIO_PUPDR_PUPD0               GPIO_PUPDR_PUPD0_Msk
N#define GPIO_PUPDR_PUPD0_0             (0x1UL << GPIO_PUPDR_PUPD0_Pos)         /*!< 0x00000001 */
N#define GPIO_PUPDR_PUPD0_1             (0x2UL << GPIO_PUPDR_PUPD0_Pos)         /*!< 0x00000002 */
N#define GPIO_PUPDR_PUPD1_Pos           (2U)
N#define GPIO_PUPDR_PUPD1_Msk           (0x3UL << GPIO_PUPDR_PUPD1_Pos)         /*!< 0x0000000C */
N#define GPIO_PUPDR_PUPD1               GPIO_PUPDR_PUPD1_Msk
N#define GPIO_PUPDR_PUPD1_0             (0x1UL << GPIO_PUPDR_PUPD1_Pos)         /*!< 0x00000004 */
N#define GPIO_PUPDR_PUPD1_1             (0x2UL << GPIO_PUPDR_PUPD1_Pos)         /*!< 0x00000008 */
N#define GPIO_PUPDR_PUPD2_Pos           (4U)
N#define GPIO_PUPDR_PUPD2_Msk           (0x3UL << GPIO_PUPDR_PUPD2_Pos)         /*!< 0x00000030 */
N#define GPIO_PUPDR_PUPD2               GPIO_PUPDR_PUPD2_Msk
N#define GPIO_PUPDR_PUPD2_0             (0x1UL << GPIO_PUPDR_PUPD2_Pos)         /*!< 0x00000010 */
N#define GPIO_PUPDR_PUPD2_1             (0x2UL << GPIO_PUPDR_PUPD2_Pos)         /*!< 0x00000020 */
N#define GPIO_PUPDR_PUPD3_Pos           (6U)
N#define GPIO_PUPDR_PUPD3_Msk           (0x3UL << GPIO_PUPDR_PUPD3_Pos)         /*!< 0x000000C0 */
N#define GPIO_PUPDR_PUPD3               GPIO_PUPDR_PUPD3_Msk
N#define GPIO_PUPDR_PUPD3_0             (0x1UL << GPIO_PUPDR_PUPD3_Pos)         /*!< 0x00000040 */
N#define GPIO_PUPDR_PUPD3_1             (0x2UL << GPIO_PUPDR_PUPD3_Pos)         /*!< 0x00000080 */
N#define GPIO_PUPDR_PUPD4_Pos           (8U)
N#define GPIO_PUPDR_PUPD4_Msk           (0x3UL << GPIO_PUPDR_PUPD4_Pos)         /*!< 0x00000300 */
N#define GPIO_PUPDR_PUPD4               GPIO_PUPDR_PUPD4_Msk
N#define GPIO_PUPDR_PUPD4_0             (0x1UL << GPIO_PUPDR_PUPD4_Pos)         /*!< 0x00000100 */
N#define GPIO_PUPDR_PUPD4_1             (0x2UL << GPIO_PUPDR_PUPD4_Pos)         /*!< 0x00000200 */
N#define GPIO_PUPDR_PUPD5_Pos           (10U)
N#define GPIO_PUPDR_PUPD5_Msk           (0x3UL << GPIO_PUPDR_PUPD5_Pos)         /*!< 0x00000C00 */
N#define GPIO_PUPDR_PUPD5               GPIO_PUPDR_PUPD5_Msk
N#define GPIO_PUPDR_PUPD5_0             (0x1UL << GPIO_PUPDR_PUPD5_Pos)         /*!< 0x00000400 */
N#define GPIO_PUPDR_PUPD5_1             (0x2UL << GPIO_PUPDR_PUPD5_Pos)         /*!< 0x00000800 */
N#define GPIO_PUPDR_PUPD6_Pos           (12U)
N#define GPIO_PUPDR_PUPD6_Msk           (0x3UL << GPIO_PUPDR_PUPD6_Pos)         /*!< 0x00003000 */
N#define GPIO_PUPDR_PUPD6               GPIO_PUPDR_PUPD6_Msk
N#define GPIO_PUPDR_PUPD6_0             (0x1UL << GPIO_PUPDR_PUPD6_Pos)         /*!< 0x00001000 */
N#define GPIO_PUPDR_PUPD6_1             (0x2UL << GPIO_PUPDR_PUPD6_Pos)         /*!< 0x00002000 */
N#define GPIO_PUPDR_PUPD7_Pos           (14U)
N#define GPIO_PUPDR_PUPD7_Msk           (0x3UL << GPIO_PUPDR_PUPD7_Pos)         /*!< 0x0000C000 */
N#define GPIO_PUPDR_PUPD7               GPIO_PUPDR_PUPD7_Msk
N#define GPIO_PUPDR_PUPD7_0             (0x1UL << GPIO_PUPDR_PUPD7_Pos)         /*!< 0x00004000 */
N#define GPIO_PUPDR_PUPD7_1             (0x2UL << GPIO_PUPDR_PUPD7_Pos)         /*!< 0x00008000 */
N#define GPIO_PUPDR_PUPD8_Pos           (16U)
N#define GPIO_PUPDR_PUPD8_Msk           (0x3UL << GPIO_PUPDR_PUPD8_Pos)         /*!< 0x00030000 */
N#define GPIO_PUPDR_PUPD8               GPIO_PUPDR_PUPD8_Msk
N#define GPIO_PUPDR_PUPD8_0             (0x1UL << GPIO_PUPDR_PUPD8_Pos)         /*!< 0x00010000 */
N#define GPIO_PUPDR_PUPD8_1             (0x2UL << GPIO_PUPDR_PUPD8_Pos)         /*!< 0x00020000 */
N#define GPIO_PUPDR_PUPD9_Pos           (18U)
N#define GPIO_PUPDR_PUPD9_Msk           (0x3UL << GPIO_PUPDR_PUPD9_Pos)         /*!< 0x000C0000 */
N#define GPIO_PUPDR_PUPD9               GPIO_PUPDR_PUPD9_Msk
N#define GPIO_PUPDR_PUPD9_0             (0x1UL << GPIO_PUPDR_PUPD9_Pos)         /*!< 0x00040000 */
N#define GPIO_PUPDR_PUPD9_1             (0x2UL << GPIO_PUPDR_PUPD9_Pos)         /*!< 0x00080000 */
N#define GPIO_PUPDR_PUPD10_Pos          (20U)
N#define GPIO_PUPDR_PUPD10_Msk          (0x3UL << GPIO_PUPDR_PUPD10_Pos)        /*!< 0x00300000 */
N#define GPIO_PUPDR_PUPD10              GPIO_PUPDR_PUPD10_Msk
N#define GPIO_PUPDR_PUPD10_0            (0x1UL << GPIO_PUPDR_PUPD10_Pos)        /*!< 0x00100000 */
N#define GPIO_PUPDR_PUPD10_1            (0x2UL << GPIO_PUPDR_PUPD10_Pos)        /*!< 0x00200000 */
N#define GPIO_PUPDR_PUPD11_Pos          (22U)
N#define GPIO_PUPDR_PUPD11_Msk          (0x3UL << GPIO_PUPDR_PUPD11_Pos)        /*!< 0x00C00000 */
N#define GPIO_PUPDR_PUPD11              GPIO_PUPDR_PUPD11_Msk
N#define GPIO_PUPDR_PUPD11_0            (0x1UL << GPIO_PUPDR_PUPD11_Pos)        /*!< 0x00400000 */
N#define GPIO_PUPDR_PUPD11_1            (0x2UL << GPIO_PUPDR_PUPD11_Pos)        /*!< 0x00800000 */
N#define GPIO_PUPDR_PUPD12_Pos          (24U)
N#define GPIO_PUPDR_PUPD12_Msk          (0x3UL << GPIO_PUPDR_PUPD12_Pos)        /*!< 0x03000000 */
N#define GPIO_PUPDR_PUPD12              GPIO_PUPDR_PUPD12_Msk
N#define GPIO_PUPDR_PUPD12_0            (0x1UL << GPIO_PUPDR_PUPD12_Pos)        /*!< 0x01000000 */
N#define GPIO_PUPDR_PUPD12_1            (0x2UL << GPIO_PUPDR_PUPD12_Pos)        /*!< 0x02000000 */
N#define GPIO_PUPDR_PUPD13_Pos          (26U)
N#define GPIO_PUPDR_PUPD13_Msk          (0x3UL << GPIO_PUPDR_PUPD13_Pos)        /*!< 0x0C000000 */
N#define GPIO_PUPDR_PUPD13              GPIO_PUPDR_PUPD13_Msk
N#define GPIO_PUPDR_PUPD13_0            (0x1UL << GPIO_PUPDR_PUPD13_Pos)        /*!< 0x04000000 */
N#define GPIO_PUPDR_PUPD13_1            (0x2UL << GPIO_PUPDR_PUPD13_Pos)        /*!< 0x08000000 */
N#define GPIO_PUPDR_PUPD14_Pos          (28U)
N#define GPIO_PUPDR_PUPD14_Msk          (0x3UL << GPIO_PUPDR_PUPD14_Pos)        /*!< 0x30000000 */
N#define GPIO_PUPDR_PUPD14              GPIO_PUPDR_PUPD14_Msk
N#define GPIO_PUPDR_PUPD14_0            (0x1UL << GPIO_PUPDR_PUPD14_Pos)        /*!< 0x10000000 */
N#define GPIO_PUPDR_PUPD14_1            (0x2UL << GPIO_PUPDR_PUPD14_Pos)        /*!< 0x20000000 */
N#define GPIO_PUPDR_PUPD15_Pos          (30U)
N#define GPIO_PUPDR_PUPD15_Msk          (0x3UL << GPIO_PUPDR_PUPD15_Pos)        /*!< 0xC0000000 */
N#define GPIO_PUPDR_PUPD15              GPIO_PUPDR_PUPD15_Msk
N#define GPIO_PUPDR_PUPD15_0            (0x1UL << GPIO_PUPDR_PUPD15_Pos)        /*!< 0x40000000 */
N#define GPIO_PUPDR_PUPD15_1            (0x2UL << GPIO_PUPDR_PUPD15_Pos)        /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_PUPDR_PUPDR0                   GPIO_PUPDR_PUPD0
N#define GPIO_PUPDR_PUPDR0_0                 GPIO_PUPDR_PUPD0_0
N#define GPIO_PUPDR_PUPDR0_1                 GPIO_PUPDR_PUPD0_1
N#define GPIO_PUPDR_PUPDR1                   GPIO_PUPDR_PUPD1
N#define GPIO_PUPDR_PUPDR1_0                 GPIO_PUPDR_PUPD1_0
N#define GPIO_PUPDR_PUPDR1_1                 GPIO_PUPDR_PUPD1_1
N#define GPIO_PUPDR_PUPDR2                   GPIO_PUPDR_PUPD2
N#define GPIO_PUPDR_PUPDR2_0                 GPIO_PUPDR_PUPD2_0
N#define GPIO_PUPDR_PUPDR2_1                 GPIO_PUPDR_PUPD2_1
N#define GPIO_PUPDR_PUPDR3                   GPIO_PUPDR_PUPD3
N#define GPIO_PUPDR_PUPDR3_0                 GPIO_PUPDR_PUPD3_0
N#define GPIO_PUPDR_PUPDR3_1                 GPIO_PUPDR_PUPD3_1
N#define GPIO_PUPDR_PUPDR4                   GPIO_PUPDR_PUPD4
N#define GPIO_PUPDR_PUPDR4_0                 GPIO_PUPDR_PUPD4_0
N#define GPIO_PUPDR_PUPDR4_1                 GPIO_PUPDR_PUPD4_1
N#define GPIO_PUPDR_PUPDR5                   GPIO_PUPDR_PUPD5
N#define GPIO_PUPDR_PUPDR5_0                 GPIO_PUPDR_PUPD5_0
N#define GPIO_PUPDR_PUPDR5_1                 GPIO_PUPDR_PUPD5_1
N#define GPIO_PUPDR_PUPDR6                   GPIO_PUPDR_PUPD6
N#define GPIO_PUPDR_PUPDR6_0                 GPIO_PUPDR_PUPD6_0
N#define GPIO_PUPDR_PUPDR6_1                 GPIO_PUPDR_PUPD6_1
N#define GPIO_PUPDR_PUPDR7                   GPIO_PUPDR_PUPD7
N#define GPIO_PUPDR_PUPDR7_0                 GPIO_PUPDR_PUPD7_0
N#define GPIO_PUPDR_PUPDR7_1                 GPIO_PUPDR_PUPD7_1
N#define GPIO_PUPDR_PUPDR8                   GPIO_PUPDR_PUPD8
N#define GPIO_PUPDR_PUPDR8_0                 GPIO_PUPDR_PUPD8_0
N#define GPIO_PUPDR_PUPDR8_1                 GPIO_PUPDR_PUPD8_1
N#define GPIO_PUPDR_PUPDR9                   GPIO_PUPDR_PUPD9
N#define GPIO_PUPDR_PUPDR9_0                 GPIO_PUPDR_PUPD9_0
N#define GPIO_PUPDR_PUPDR9_1                 GPIO_PUPDR_PUPD9_1
N#define GPIO_PUPDR_PUPDR10                  GPIO_PUPDR_PUPD10
N#define GPIO_PUPDR_PUPDR10_0                GPIO_PUPDR_PUPD10_0
N#define GPIO_PUPDR_PUPDR10_1                GPIO_PUPDR_PUPD10_1
N#define GPIO_PUPDR_PUPDR11                  GPIO_PUPDR_PUPD11
N#define GPIO_PUPDR_PUPDR11_0                GPIO_PUPDR_PUPD11_0
N#define GPIO_PUPDR_PUPDR11_1                GPIO_PUPDR_PUPD11_1
N#define GPIO_PUPDR_PUPDR12                  GPIO_PUPDR_PUPD12
N#define GPIO_PUPDR_PUPDR12_0                GPIO_PUPDR_PUPD12_0
N#define GPIO_PUPDR_PUPDR12_1                GPIO_PUPDR_PUPD12_1
N#define GPIO_PUPDR_PUPDR13                  GPIO_PUPDR_PUPD13
N#define GPIO_PUPDR_PUPDR13_0                GPIO_PUPDR_PUPD13_0
N#define GPIO_PUPDR_PUPDR13_1                GPIO_PUPDR_PUPD13_1
N#define GPIO_PUPDR_PUPDR14                  GPIO_PUPDR_PUPD14
N#define GPIO_PUPDR_PUPDR14_0                GPIO_PUPDR_PUPD14_0
N#define GPIO_PUPDR_PUPDR14_1                GPIO_PUPDR_PUPD14_1
N#define GPIO_PUPDR_PUPDR15                  GPIO_PUPDR_PUPD15
N#define GPIO_PUPDR_PUPDR15_0                GPIO_PUPDR_PUPD15_0
N#define GPIO_PUPDR_PUPDR15_1                GPIO_PUPDR_PUPD15_1
N
N/******************  Bits definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_ID0_Pos               (0U)
N#define GPIO_IDR_ID0_Msk               (0x1UL << GPIO_IDR_ID0_Pos)             /*!< 0x00000001 */
N#define GPIO_IDR_ID0                   GPIO_IDR_ID0_Msk
N#define GPIO_IDR_ID1_Pos               (1U)
N#define GPIO_IDR_ID1_Msk               (0x1UL << GPIO_IDR_ID1_Pos)             /*!< 0x00000002 */
N#define GPIO_IDR_ID1                   GPIO_IDR_ID1_Msk
N#define GPIO_IDR_ID2_Pos               (2U)
N#define GPIO_IDR_ID2_Msk               (0x1UL << GPIO_IDR_ID2_Pos)             /*!< 0x00000004 */
N#define GPIO_IDR_ID2                   GPIO_IDR_ID2_Msk
N#define GPIO_IDR_ID3_Pos               (3U)
N#define GPIO_IDR_ID3_Msk               (0x1UL << GPIO_IDR_ID3_Pos)             /*!< 0x00000008 */
N#define GPIO_IDR_ID3                   GPIO_IDR_ID3_Msk
N#define GPIO_IDR_ID4_Pos               (4U)
N#define GPIO_IDR_ID4_Msk               (0x1UL << GPIO_IDR_ID4_Pos)             /*!< 0x00000010 */
N#define GPIO_IDR_ID4                   GPIO_IDR_ID4_Msk
N#define GPIO_IDR_ID5_Pos               (5U)
N#define GPIO_IDR_ID5_Msk               (0x1UL << GPIO_IDR_ID5_Pos)             /*!< 0x00000020 */
N#define GPIO_IDR_ID5                   GPIO_IDR_ID5_Msk
N#define GPIO_IDR_ID6_Pos               (6U)
N#define GPIO_IDR_ID6_Msk               (0x1UL << GPIO_IDR_ID6_Pos)             /*!< 0x00000040 */
N#define GPIO_IDR_ID6                   GPIO_IDR_ID6_Msk
N#define GPIO_IDR_ID7_Pos               (7U)
N#define GPIO_IDR_ID7_Msk               (0x1UL << GPIO_IDR_ID7_Pos)             /*!< 0x00000080 */
N#define GPIO_IDR_ID7                   GPIO_IDR_ID7_Msk
N#define GPIO_IDR_ID8_Pos               (8U)
N#define GPIO_IDR_ID8_Msk               (0x1UL << GPIO_IDR_ID8_Pos)             /*!< 0x00000100 */
N#define GPIO_IDR_ID8                   GPIO_IDR_ID8_Msk
N#define GPIO_IDR_ID9_Pos               (9U)
N#define GPIO_IDR_ID9_Msk               (0x1UL << GPIO_IDR_ID9_Pos)             /*!< 0x00000200 */
N#define GPIO_IDR_ID9                   GPIO_IDR_ID9_Msk
N#define GPIO_IDR_ID10_Pos              (10U)
N#define GPIO_IDR_ID10_Msk              (0x1UL << GPIO_IDR_ID10_Pos)            /*!< 0x00000400 */
N#define GPIO_IDR_ID10                  GPIO_IDR_ID10_Msk
N#define GPIO_IDR_ID11_Pos              (11U)
N#define GPIO_IDR_ID11_Msk              (0x1UL << GPIO_IDR_ID11_Pos)            /*!< 0x00000800 */
N#define GPIO_IDR_ID11                  GPIO_IDR_ID11_Msk
N#define GPIO_IDR_ID12_Pos              (12U)
N#define GPIO_IDR_ID12_Msk              (0x1UL << GPIO_IDR_ID12_Pos)            /*!< 0x00001000 */
N#define GPIO_IDR_ID12                  GPIO_IDR_ID12_Msk
N#define GPIO_IDR_ID13_Pos              (13U)
N#define GPIO_IDR_ID13_Msk              (0x1UL << GPIO_IDR_ID13_Pos)            /*!< 0x00002000 */
N#define GPIO_IDR_ID13                  GPIO_IDR_ID13_Msk
N#define GPIO_IDR_ID14_Pos              (14U)
N#define GPIO_IDR_ID14_Msk              (0x1UL << GPIO_IDR_ID14_Pos)            /*!< 0x00004000 */
N#define GPIO_IDR_ID14                  GPIO_IDR_ID14_Msk
N#define GPIO_IDR_ID15_Pos              (15U)
N#define GPIO_IDR_ID15_Msk              (0x1UL << GPIO_IDR_ID15_Pos)            /*!< 0x00008000 */
N#define GPIO_IDR_ID15                  GPIO_IDR_ID15_Msk
N
N/* Legacy defines */
N#define GPIO_IDR_IDR_0                      GPIO_IDR_ID0
N#define GPIO_IDR_IDR_1                      GPIO_IDR_ID1
N#define GPIO_IDR_IDR_2                      GPIO_IDR_ID2
N#define GPIO_IDR_IDR_3                      GPIO_IDR_ID3
N#define GPIO_IDR_IDR_4                      GPIO_IDR_ID4
N#define GPIO_IDR_IDR_5                      GPIO_IDR_ID5
N#define GPIO_IDR_IDR_6                      GPIO_IDR_ID6
N#define GPIO_IDR_IDR_7                      GPIO_IDR_ID7
N#define GPIO_IDR_IDR_8                      GPIO_IDR_ID8
N#define GPIO_IDR_IDR_9                      GPIO_IDR_ID9
N#define GPIO_IDR_IDR_10                     GPIO_IDR_ID10
N#define GPIO_IDR_IDR_11                     GPIO_IDR_ID11
N#define GPIO_IDR_IDR_12                     GPIO_IDR_ID12
N#define GPIO_IDR_IDR_13                     GPIO_IDR_ID13
N#define GPIO_IDR_IDR_14                     GPIO_IDR_ID14
N#define GPIO_IDR_IDR_15                     GPIO_IDR_ID15
N
N/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
N#define GPIO_OTYPER_IDR_0                   GPIO_IDR_ID0
N#define GPIO_OTYPER_IDR_1                   GPIO_IDR_ID1
N#define GPIO_OTYPER_IDR_2                   GPIO_IDR_ID2
N#define GPIO_OTYPER_IDR_3                   GPIO_IDR_ID3
N#define GPIO_OTYPER_IDR_4                   GPIO_IDR_ID4
N#define GPIO_OTYPER_IDR_5                   GPIO_IDR_ID5
N#define GPIO_OTYPER_IDR_6                   GPIO_IDR_ID6
N#define GPIO_OTYPER_IDR_7                   GPIO_IDR_ID7
N#define GPIO_OTYPER_IDR_8                   GPIO_IDR_ID8
N#define GPIO_OTYPER_IDR_9                   GPIO_IDR_ID9
N#define GPIO_OTYPER_IDR_10                  GPIO_IDR_ID10
N#define GPIO_OTYPER_IDR_11                  GPIO_IDR_ID11
N#define GPIO_OTYPER_IDR_12                  GPIO_IDR_ID12
N#define GPIO_OTYPER_IDR_13                  GPIO_IDR_ID13
N#define GPIO_OTYPER_IDR_14                  GPIO_IDR_ID14
N#define GPIO_OTYPER_IDR_15                  GPIO_IDR_ID15
N
N/******************  Bits definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_OD0_Pos               (0U)
N#define GPIO_ODR_OD0_Msk               (0x1UL << GPIO_ODR_OD0_Pos)             /*!< 0x00000001 */
N#define GPIO_ODR_OD0                   GPIO_ODR_OD0_Msk
N#define GPIO_ODR_OD1_Pos               (1U)
N#define GPIO_ODR_OD1_Msk               (0x1UL << GPIO_ODR_OD1_Pos)             /*!< 0x00000002 */
N#define GPIO_ODR_OD1                   GPIO_ODR_OD1_Msk
N#define GPIO_ODR_OD2_Pos               (2U)
N#define GPIO_ODR_OD2_Msk               (0x1UL << GPIO_ODR_OD2_Pos)             /*!< 0x00000004 */
N#define GPIO_ODR_OD2                   GPIO_ODR_OD2_Msk
N#define GPIO_ODR_OD3_Pos               (3U)
N#define GPIO_ODR_OD3_Msk               (0x1UL << GPIO_ODR_OD3_Pos)             /*!< 0x00000008 */
N#define GPIO_ODR_OD3                   GPIO_ODR_OD3_Msk
N#define GPIO_ODR_OD4_Pos               (4U)
N#define GPIO_ODR_OD4_Msk               (0x1UL << GPIO_ODR_OD4_Pos)             /*!< 0x00000010 */
N#define GPIO_ODR_OD4                   GPIO_ODR_OD4_Msk
N#define GPIO_ODR_OD5_Pos               (5U)
N#define GPIO_ODR_OD5_Msk               (0x1UL << GPIO_ODR_OD5_Pos)             /*!< 0x00000020 */
N#define GPIO_ODR_OD5                   GPIO_ODR_OD5_Msk
N#define GPIO_ODR_OD6_Pos               (6U)
N#define GPIO_ODR_OD6_Msk               (0x1UL << GPIO_ODR_OD6_Pos)             /*!< 0x00000040 */
N#define GPIO_ODR_OD6                   GPIO_ODR_OD6_Msk
N#define GPIO_ODR_OD7_Pos               (7U)
N#define GPIO_ODR_OD7_Msk               (0x1UL << GPIO_ODR_OD7_Pos)             /*!< 0x00000080 */
N#define GPIO_ODR_OD7                   GPIO_ODR_OD7_Msk
N#define GPIO_ODR_OD8_Pos               (8U)
N#define GPIO_ODR_OD8_Msk               (0x1UL << GPIO_ODR_OD8_Pos)             /*!< 0x00000100 */
N#define GPIO_ODR_OD8                   GPIO_ODR_OD8_Msk
N#define GPIO_ODR_OD9_Pos               (9U)
N#define GPIO_ODR_OD9_Msk               (0x1UL << GPIO_ODR_OD9_Pos)             /*!< 0x00000200 */
N#define GPIO_ODR_OD9                   GPIO_ODR_OD9_Msk
N#define GPIO_ODR_OD10_Pos              (10U)
N#define GPIO_ODR_OD10_Msk              (0x1UL << GPIO_ODR_OD10_Pos)            /*!< 0x00000400 */
N#define GPIO_ODR_OD10                  GPIO_ODR_OD10_Msk
N#define GPIO_ODR_OD11_Pos              (11U)
N#define GPIO_ODR_OD11_Msk              (0x1UL << GPIO_ODR_OD11_Pos)            /*!< 0x00000800 */
N#define GPIO_ODR_OD11                  GPIO_ODR_OD11_Msk
N#define GPIO_ODR_OD12_Pos              (12U)
N#define GPIO_ODR_OD12_Msk              (0x1UL << GPIO_ODR_OD12_Pos)            /*!< 0x00001000 */
N#define GPIO_ODR_OD12                  GPIO_ODR_OD12_Msk
N#define GPIO_ODR_OD13_Pos              (13U)
N#define GPIO_ODR_OD13_Msk              (0x1UL << GPIO_ODR_OD13_Pos)            /*!< 0x00002000 */
N#define GPIO_ODR_OD13                  GPIO_ODR_OD13_Msk
N#define GPIO_ODR_OD14_Pos              (14U)
N#define GPIO_ODR_OD14_Msk              (0x1UL << GPIO_ODR_OD14_Pos)            /*!< 0x00004000 */
N#define GPIO_ODR_OD14                  GPIO_ODR_OD14_Msk
N#define GPIO_ODR_OD15_Pos              (15U)
N#define GPIO_ODR_OD15_Msk              (0x1UL << GPIO_ODR_OD15_Pos)            /*!< 0x00008000 */
N#define GPIO_ODR_OD15                  GPIO_ODR_OD15_Msk
N
N/* Legacy defines */
N#define GPIO_ODR_ODR_0                      GPIO_ODR_OD0
N#define GPIO_ODR_ODR_1                      GPIO_ODR_OD1
N#define GPIO_ODR_ODR_2                      GPIO_ODR_OD2
N#define GPIO_ODR_ODR_3                      GPIO_ODR_OD3
N#define GPIO_ODR_ODR_4                      GPIO_ODR_OD4
N#define GPIO_ODR_ODR_5                      GPIO_ODR_OD5
N#define GPIO_ODR_ODR_6                      GPIO_ODR_OD6
N#define GPIO_ODR_ODR_7                      GPIO_ODR_OD7
N#define GPIO_ODR_ODR_8                      GPIO_ODR_OD8
N#define GPIO_ODR_ODR_9                      GPIO_ODR_OD9
N#define GPIO_ODR_ODR_10                     GPIO_ODR_OD10
N#define GPIO_ODR_ODR_11                     GPIO_ODR_OD11
N#define GPIO_ODR_ODR_12                     GPIO_ODR_OD12
N#define GPIO_ODR_ODR_13                     GPIO_ODR_OD13
N#define GPIO_ODR_ODR_14                     GPIO_ODR_OD14
N#define GPIO_ODR_ODR_15                     GPIO_ODR_OD15
N
N/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
N#define GPIO_OTYPER_ODR_0                   GPIO_ODR_OD0
N#define GPIO_OTYPER_ODR_1                   GPIO_ODR_OD1
N#define GPIO_OTYPER_ODR_2                   GPIO_ODR_OD2
N#define GPIO_OTYPER_ODR_3                   GPIO_ODR_OD3
N#define GPIO_OTYPER_ODR_4                   GPIO_ODR_OD4
N#define GPIO_OTYPER_ODR_5                   GPIO_ODR_OD5
N#define GPIO_OTYPER_ODR_6                   GPIO_ODR_OD6
N#define GPIO_OTYPER_ODR_7                   GPIO_ODR_OD7
N#define GPIO_OTYPER_ODR_8                   GPIO_ODR_OD8
N#define GPIO_OTYPER_ODR_9                   GPIO_ODR_OD9
N#define GPIO_OTYPER_ODR_10                  GPIO_ODR_OD10
N#define GPIO_OTYPER_ODR_11                  GPIO_ODR_OD11
N#define GPIO_OTYPER_ODR_12                  GPIO_ODR_OD12
N#define GPIO_OTYPER_ODR_13                  GPIO_ODR_OD13
N#define GPIO_OTYPER_ODR_14                  GPIO_ODR_OD14
N#define GPIO_OTYPER_ODR_15                  GPIO_ODR_OD15
N
N/******************  Bits definition for GPIO_BSRR register  ******************/
N#define GPIO_BSRR_BS0_Pos              (0U)
N#define GPIO_BSRR_BS0_Msk              (0x1UL << GPIO_BSRR_BS0_Pos)            /*!< 0x00000001 */
N#define GPIO_BSRR_BS0                  GPIO_BSRR_BS0_Msk
N#define GPIO_BSRR_BS1_Pos              (1U)
N#define GPIO_BSRR_BS1_Msk              (0x1UL << GPIO_BSRR_BS1_Pos)            /*!< 0x00000002 */
N#define GPIO_BSRR_BS1                  GPIO_BSRR_BS1_Msk
N#define GPIO_BSRR_BS2_Pos              (2U)
N#define GPIO_BSRR_BS2_Msk              (0x1UL << GPIO_BSRR_BS2_Pos)            /*!< 0x00000004 */
N#define GPIO_BSRR_BS2                  GPIO_BSRR_BS2_Msk
N#define GPIO_BSRR_BS3_Pos              (3U)
N#define GPIO_BSRR_BS3_Msk              (0x1UL << GPIO_BSRR_BS3_Pos)            /*!< 0x00000008 */
N#define GPIO_BSRR_BS3                  GPIO_BSRR_BS3_Msk
N#define GPIO_BSRR_BS4_Pos              (4U)
N#define GPIO_BSRR_BS4_Msk              (0x1UL << GPIO_BSRR_BS4_Pos)            /*!< 0x00000010 */
N#define GPIO_BSRR_BS4                  GPIO_BSRR_BS4_Msk
N#define GPIO_BSRR_BS5_Pos              (5U)
N#define GPIO_BSRR_BS5_Msk              (0x1UL << GPIO_BSRR_BS5_Pos)            /*!< 0x00000020 */
N#define GPIO_BSRR_BS5                  GPIO_BSRR_BS5_Msk
N#define GPIO_BSRR_BS6_Pos              (6U)
N#define GPIO_BSRR_BS6_Msk              (0x1UL << GPIO_BSRR_BS6_Pos)            /*!< 0x00000040 */
N#define GPIO_BSRR_BS6                  GPIO_BSRR_BS6_Msk
N#define GPIO_BSRR_BS7_Pos              (7U)
N#define GPIO_BSRR_BS7_Msk              (0x1UL << GPIO_BSRR_BS7_Pos)            /*!< 0x00000080 */
N#define GPIO_BSRR_BS7                  GPIO_BSRR_BS7_Msk
N#define GPIO_BSRR_BS8_Pos              (8U)
N#define GPIO_BSRR_BS8_Msk              (0x1UL << GPIO_BSRR_BS8_Pos)            /*!< 0x00000100 */
N#define GPIO_BSRR_BS8                  GPIO_BSRR_BS8_Msk
N#define GPIO_BSRR_BS9_Pos              (9U)
N#define GPIO_BSRR_BS9_Msk              (0x1UL << GPIO_BSRR_BS9_Pos)            /*!< 0x00000200 */
N#define GPIO_BSRR_BS9                  GPIO_BSRR_BS9_Msk
N#define GPIO_BSRR_BS10_Pos             (10U)
N#define GPIO_BSRR_BS10_Msk             (0x1UL << GPIO_BSRR_BS10_Pos)           /*!< 0x00000400 */
N#define GPIO_BSRR_BS10                 GPIO_BSRR_BS10_Msk
N#define GPIO_BSRR_BS11_Pos             (11U)
N#define GPIO_BSRR_BS11_Msk             (0x1UL << GPIO_BSRR_BS11_Pos)           /*!< 0x00000800 */
N#define GPIO_BSRR_BS11                 GPIO_BSRR_BS11_Msk
N#define GPIO_BSRR_BS12_Pos             (12U)
N#define GPIO_BSRR_BS12_Msk             (0x1UL << GPIO_BSRR_BS12_Pos)           /*!< 0x00001000 */
N#define GPIO_BSRR_BS12                 GPIO_BSRR_BS12_Msk
N#define GPIO_BSRR_BS13_Pos             (13U)
N#define GPIO_BSRR_BS13_Msk             (0x1UL << GPIO_BSRR_BS13_Pos)           /*!< 0x00002000 */
N#define GPIO_BSRR_BS13                 GPIO_BSRR_BS13_Msk
N#define GPIO_BSRR_BS14_Pos             (14U)
N#define GPIO_BSRR_BS14_Msk             (0x1UL << GPIO_BSRR_BS14_Pos)           /*!< 0x00004000 */
N#define GPIO_BSRR_BS14                 GPIO_BSRR_BS14_Msk
N#define GPIO_BSRR_BS15_Pos             (15U)
N#define GPIO_BSRR_BS15_Msk             (0x1UL << GPIO_BSRR_BS15_Pos)           /*!< 0x00008000 */
N#define GPIO_BSRR_BS15                 GPIO_BSRR_BS15_Msk
N#define GPIO_BSRR_BR0_Pos              (16U)
N#define GPIO_BSRR_BR0_Msk              (0x1UL << GPIO_BSRR_BR0_Pos)            /*!< 0x00010000 */
N#define GPIO_BSRR_BR0                  GPIO_BSRR_BR0_Msk
N#define GPIO_BSRR_BR1_Pos              (17U)
N#define GPIO_BSRR_BR1_Msk              (0x1UL << GPIO_BSRR_BR1_Pos)            /*!< 0x00020000 */
N#define GPIO_BSRR_BR1                  GPIO_BSRR_BR1_Msk
N#define GPIO_BSRR_BR2_Pos              (18U)
N#define GPIO_BSRR_BR2_Msk              (0x1UL << GPIO_BSRR_BR2_Pos)            /*!< 0x00040000 */
N#define GPIO_BSRR_BR2                  GPIO_BSRR_BR2_Msk
N#define GPIO_BSRR_BR3_Pos              (19U)
N#define GPIO_BSRR_BR3_Msk              (0x1UL << GPIO_BSRR_BR3_Pos)            /*!< 0x00080000 */
N#define GPIO_BSRR_BR3                  GPIO_BSRR_BR3_Msk
N#define GPIO_BSRR_BR4_Pos              (20U)
N#define GPIO_BSRR_BR4_Msk              (0x1UL << GPIO_BSRR_BR4_Pos)            /*!< 0x00100000 */
N#define GPIO_BSRR_BR4                  GPIO_BSRR_BR4_Msk
N#define GPIO_BSRR_BR5_Pos              (21U)
N#define GPIO_BSRR_BR5_Msk              (0x1UL << GPIO_BSRR_BR5_Pos)            /*!< 0x00200000 */
N#define GPIO_BSRR_BR5                  GPIO_BSRR_BR5_Msk
N#define GPIO_BSRR_BR6_Pos              (22U)
N#define GPIO_BSRR_BR6_Msk              (0x1UL << GPIO_BSRR_BR6_Pos)            /*!< 0x00400000 */
N#define GPIO_BSRR_BR6                  GPIO_BSRR_BR6_Msk
N#define GPIO_BSRR_BR7_Pos              (23U)
N#define GPIO_BSRR_BR7_Msk              (0x1UL << GPIO_BSRR_BR7_Pos)            /*!< 0x00800000 */
N#define GPIO_BSRR_BR7                  GPIO_BSRR_BR7_Msk
N#define GPIO_BSRR_BR8_Pos              (24U)
N#define GPIO_BSRR_BR8_Msk              (0x1UL << GPIO_BSRR_BR8_Pos)            /*!< 0x01000000 */
N#define GPIO_BSRR_BR8                  GPIO_BSRR_BR8_Msk
N#define GPIO_BSRR_BR9_Pos              (25U)
N#define GPIO_BSRR_BR9_Msk              (0x1UL << GPIO_BSRR_BR9_Pos)            /*!< 0x02000000 */
N#define GPIO_BSRR_BR9                  GPIO_BSRR_BR9_Msk
N#define GPIO_BSRR_BR10_Pos             (26U)
N#define GPIO_BSRR_BR10_Msk             (0x1UL << GPIO_BSRR_BR10_Pos)           /*!< 0x04000000 */
N#define GPIO_BSRR_BR10                 GPIO_BSRR_BR10_Msk
N#define GPIO_BSRR_BR11_Pos             (27U)
N#define GPIO_BSRR_BR11_Msk             (0x1UL << GPIO_BSRR_BR11_Pos)           /*!< 0x08000000 */
N#define GPIO_BSRR_BR11                 GPIO_BSRR_BR11_Msk
N#define GPIO_BSRR_BR12_Pos             (28U)
N#define GPIO_BSRR_BR12_Msk             (0x1UL << GPIO_BSRR_BR12_Pos)           /*!< 0x10000000 */
N#define GPIO_BSRR_BR12                 GPIO_BSRR_BR12_Msk
N#define GPIO_BSRR_BR13_Pos             (29U)
N#define GPIO_BSRR_BR13_Msk             (0x1UL << GPIO_BSRR_BR13_Pos)           /*!< 0x20000000 */
N#define GPIO_BSRR_BR13                 GPIO_BSRR_BR13_Msk
N#define GPIO_BSRR_BR14_Pos             (30U)
N#define GPIO_BSRR_BR14_Msk             (0x1UL << GPIO_BSRR_BR14_Pos)           /*!< 0x40000000 */
N#define GPIO_BSRR_BR14                 GPIO_BSRR_BR14_Msk
N#define GPIO_BSRR_BR15_Pos             (31U)
N#define GPIO_BSRR_BR15_Msk             (0x1UL << GPIO_BSRR_BR15_Pos)           /*!< 0x80000000 */
N#define GPIO_BSRR_BR15                 GPIO_BSRR_BR15_Msk
N
N/* Legacy defines */
N#define GPIO_BSRR_BS_0                      GPIO_BSRR_BS0
N#define GPIO_BSRR_BS_1                      GPIO_BSRR_BS1
N#define GPIO_BSRR_BS_2                      GPIO_BSRR_BS2
N#define GPIO_BSRR_BS_3                      GPIO_BSRR_BS3
N#define GPIO_BSRR_BS_4                      GPIO_BSRR_BS4
N#define GPIO_BSRR_BS_5                      GPIO_BSRR_BS5
N#define GPIO_BSRR_BS_6                      GPIO_BSRR_BS6
N#define GPIO_BSRR_BS_7                      GPIO_BSRR_BS7
N#define GPIO_BSRR_BS_8                      GPIO_BSRR_BS8
N#define GPIO_BSRR_BS_9                      GPIO_BSRR_BS9
N#define GPIO_BSRR_BS_10                     GPIO_BSRR_BS10
N#define GPIO_BSRR_BS_11                     GPIO_BSRR_BS11
N#define GPIO_BSRR_BS_12                     GPIO_BSRR_BS12
N#define GPIO_BSRR_BS_13                     GPIO_BSRR_BS13
N#define GPIO_BSRR_BS_14                     GPIO_BSRR_BS14
N#define GPIO_BSRR_BS_15                     GPIO_BSRR_BS15
N#define GPIO_BSRR_BR_0                      GPIO_BSRR_BR0
N#define GPIO_BSRR_BR_1                      GPIO_BSRR_BR1
N#define GPIO_BSRR_BR_2                      GPIO_BSRR_BR2
N#define GPIO_BSRR_BR_3                      GPIO_BSRR_BR3
N#define GPIO_BSRR_BR_4                      GPIO_BSRR_BR4
N#define GPIO_BSRR_BR_5                      GPIO_BSRR_BR5
N#define GPIO_BSRR_BR_6                      GPIO_BSRR_BR6
N#define GPIO_BSRR_BR_7                      GPIO_BSRR_BR7
N#define GPIO_BSRR_BR_8                      GPIO_BSRR_BR8
N#define GPIO_BSRR_BR_9                      GPIO_BSRR_BR9
N#define GPIO_BSRR_BR_10                     GPIO_BSRR_BR10
N#define GPIO_BSRR_BR_11                     GPIO_BSRR_BR11
N#define GPIO_BSRR_BR_12                     GPIO_BSRR_BR12
N#define GPIO_BSRR_BR_13                     GPIO_BSRR_BR13
N#define GPIO_BSRR_BR_14                     GPIO_BSRR_BR14
N#define GPIO_BSRR_BR_15                     GPIO_BSRR_BR15
N
N/****************** Bit definition for GPIO_LCKR register *********************/
N#define GPIO_LCKR_LCK0_Pos             (0U)
N#define GPIO_LCKR_LCK0_Msk             (0x1UL << GPIO_LCKR_LCK0_Pos)           /*!< 0x00000001 */
N#define GPIO_LCKR_LCK0                 GPIO_LCKR_LCK0_Msk
N#define GPIO_LCKR_LCK1_Pos             (1U)
N#define GPIO_LCKR_LCK1_Msk             (0x1UL << GPIO_LCKR_LCK1_Pos)           /*!< 0x00000002 */
N#define GPIO_LCKR_LCK1                 GPIO_LCKR_LCK1_Msk
N#define GPIO_LCKR_LCK2_Pos             (2U)
N#define GPIO_LCKR_LCK2_Msk             (0x1UL << GPIO_LCKR_LCK2_Pos)           /*!< 0x00000004 */
N#define GPIO_LCKR_LCK2                 GPIO_LCKR_LCK2_Msk
N#define GPIO_LCKR_LCK3_Pos             (3U)
N#define GPIO_LCKR_LCK3_Msk             (0x1UL << GPIO_LCKR_LCK3_Pos)           /*!< 0x00000008 */
N#define GPIO_LCKR_LCK3                 GPIO_LCKR_LCK3_Msk
N#define GPIO_LCKR_LCK4_Pos             (4U)
N#define GPIO_LCKR_LCK4_Msk             (0x1UL << GPIO_LCKR_LCK4_Pos)           /*!< 0x00000010 */
N#define GPIO_LCKR_LCK4                 GPIO_LCKR_LCK4_Msk
N#define GPIO_LCKR_LCK5_Pos             (5U)
N#define GPIO_LCKR_LCK5_Msk             (0x1UL << GPIO_LCKR_LCK5_Pos)           /*!< 0x00000020 */
N#define GPIO_LCKR_LCK5                 GPIO_LCKR_LCK5_Msk
N#define GPIO_LCKR_LCK6_Pos             (6U)
N#define GPIO_LCKR_LCK6_Msk             (0x1UL << GPIO_LCKR_LCK6_Pos)           /*!< 0x00000040 */
N#define GPIO_LCKR_LCK6                 GPIO_LCKR_LCK6_Msk
N#define GPIO_LCKR_LCK7_Pos             (7U)
N#define GPIO_LCKR_LCK7_Msk             (0x1UL << GPIO_LCKR_LCK7_Pos)           /*!< 0x00000080 */
N#define GPIO_LCKR_LCK7                 GPIO_LCKR_LCK7_Msk
N#define GPIO_LCKR_LCK8_Pos             (8U)
N#define GPIO_LCKR_LCK8_Msk             (0x1UL << GPIO_LCKR_LCK8_Pos)           /*!< 0x00000100 */
N#define GPIO_LCKR_LCK8                 GPIO_LCKR_LCK8_Msk
N#define GPIO_LCKR_LCK9_Pos             (9U)
N#define GPIO_LCKR_LCK9_Msk             (0x1UL << GPIO_LCKR_LCK9_Pos)           /*!< 0x00000200 */
N#define GPIO_LCKR_LCK9                 GPIO_LCKR_LCK9_Msk
N#define GPIO_LCKR_LCK10_Pos            (10U)
N#define GPIO_LCKR_LCK10_Msk            (0x1UL << GPIO_LCKR_LCK10_Pos)          /*!< 0x00000400 */
N#define GPIO_LCKR_LCK10                GPIO_LCKR_LCK10_Msk
N#define GPIO_LCKR_LCK11_Pos            (11U)
N#define GPIO_LCKR_LCK11_Msk            (0x1UL << GPIO_LCKR_LCK11_Pos)          /*!< 0x00000800 */
N#define GPIO_LCKR_LCK11                GPIO_LCKR_LCK11_Msk
N#define GPIO_LCKR_LCK12_Pos            (12U)
N#define GPIO_LCKR_LCK12_Msk            (0x1UL << GPIO_LCKR_LCK12_Pos)          /*!< 0x00001000 */
N#define GPIO_LCKR_LCK12                GPIO_LCKR_LCK12_Msk
N#define GPIO_LCKR_LCK13_Pos            (13U)
N#define GPIO_LCKR_LCK13_Msk            (0x1UL << GPIO_LCKR_LCK13_Pos)          /*!< 0x00002000 */
N#define GPIO_LCKR_LCK13                GPIO_LCKR_LCK13_Msk
N#define GPIO_LCKR_LCK14_Pos            (14U)
N#define GPIO_LCKR_LCK14_Msk            (0x1UL << GPIO_LCKR_LCK14_Pos)          /*!< 0x00004000 */
N#define GPIO_LCKR_LCK14                GPIO_LCKR_LCK14_Msk
N#define GPIO_LCKR_LCK15_Pos            (15U)
N#define GPIO_LCKR_LCK15_Msk            (0x1UL << GPIO_LCKR_LCK15_Pos)          /*!< 0x00008000 */
N#define GPIO_LCKR_LCK15                GPIO_LCKR_LCK15_Msk
N#define GPIO_LCKR_LCKK_Pos             (16U)
N#define GPIO_LCKR_LCKK_Msk             (0x1UL << GPIO_LCKR_LCKK_Pos)           /*!< 0x00010000 */
N#define GPIO_LCKR_LCKK                 GPIO_LCKR_LCKK_Msk
N
N/****************** Bit definition for GPIO_AFRL register *********************/
N#define GPIO_AFRL_AFSEL0_Pos           (0U)
N#define GPIO_AFRL_AFSEL0_Msk           (0xFUL << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x0000000F */
N#define GPIO_AFRL_AFSEL0               GPIO_AFRL_AFSEL0_Msk
N#define GPIO_AFRL_AFSEL0_0             (0x1UL << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x00000001 */
N#define GPIO_AFRL_AFSEL0_1             (0x2UL << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x00000002 */
N#define GPIO_AFRL_AFSEL0_2             (0x4UL << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x00000004 */
N#define GPIO_AFRL_AFSEL0_3             (0x8UL << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x00000008 */
N#define GPIO_AFRL_AFSEL1_Pos           (4U)
N#define GPIO_AFRL_AFSEL1_Msk           (0xFUL << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x000000F0 */
N#define GPIO_AFRL_AFSEL1               GPIO_AFRL_AFSEL1_Msk
N#define GPIO_AFRL_AFSEL1_0             (0x1UL << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x00000010 */
N#define GPIO_AFRL_AFSEL1_1             (0x2UL << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x00000020 */
N#define GPIO_AFRL_AFSEL1_2             (0x4UL << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x00000040 */
N#define GPIO_AFRL_AFSEL1_3             (0x8UL << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x00000080 */
N#define GPIO_AFRL_AFSEL2_Pos           (8U)
N#define GPIO_AFRL_AFSEL2_Msk           (0xFUL << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000F00 */
N#define GPIO_AFRL_AFSEL2               GPIO_AFRL_AFSEL2_Msk
N#define GPIO_AFRL_AFSEL2_0             (0x1UL << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000100 */
N#define GPIO_AFRL_AFSEL2_1             (0x2UL << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000200 */
N#define GPIO_AFRL_AFSEL2_2             (0x4UL << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000400 */
N#define GPIO_AFRL_AFSEL2_3             (0x8UL << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000800 */
N#define GPIO_AFRL_AFSEL3_Pos           (12U)
N#define GPIO_AFRL_AFSEL3_Msk           (0xFUL << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x0000F000 */
N#define GPIO_AFRL_AFSEL3               GPIO_AFRL_AFSEL3_Msk
N#define GPIO_AFRL_AFSEL3_0             (0x1UL << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x00001000 */
N#define GPIO_AFRL_AFSEL3_1             (0x2UL << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x00002000 */
N#define GPIO_AFRL_AFSEL3_2             (0x4UL << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x00004000 */
N#define GPIO_AFRL_AFSEL3_3             (0x8UL << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x00008000 */
N#define GPIO_AFRL_AFSEL4_Pos           (16U)
N#define GPIO_AFRL_AFSEL4_Msk           (0xFUL << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x000F0000 */
N#define GPIO_AFRL_AFSEL4               GPIO_AFRL_AFSEL4_Msk
N#define GPIO_AFRL_AFSEL4_0             (0x1UL << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x00010000 */
N#define GPIO_AFRL_AFSEL4_1             (0x2UL << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x00020000 */
N#define GPIO_AFRL_AFSEL4_2             (0x4UL << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x00040000 */
N#define GPIO_AFRL_AFSEL4_3             (0x8UL << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x00080000 */
N#define GPIO_AFRL_AFSEL5_Pos           (20U)
N#define GPIO_AFRL_AFSEL5_Msk           (0xFUL << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00F00000 */
N#define GPIO_AFRL_AFSEL5               GPIO_AFRL_AFSEL5_Msk
N#define GPIO_AFRL_AFSEL5_0             (0x1UL << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00100000 */
N#define GPIO_AFRL_AFSEL5_1             (0x2UL << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00200000 */
N#define GPIO_AFRL_AFSEL5_2             (0x4UL << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00400000 */
N#define GPIO_AFRL_AFSEL5_3             (0x8UL << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00800000 */
N#define GPIO_AFRL_AFSEL6_Pos           (24U)
N#define GPIO_AFRL_AFSEL6_Msk           (0xFUL << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x0F000000 */
N#define GPIO_AFRL_AFSEL6               GPIO_AFRL_AFSEL6_Msk
N#define GPIO_AFRL_AFSEL6_0             (0x1UL << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x01000000 */
N#define GPIO_AFRL_AFSEL6_1             (0x2UL << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x02000000 */
N#define GPIO_AFRL_AFSEL6_2             (0x4UL << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x04000000 */
N#define GPIO_AFRL_AFSEL6_3             (0x8UL << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x08000000 */
N#define GPIO_AFRL_AFSEL7_Pos           (28U)
N#define GPIO_AFRL_AFSEL7_Msk           (0xFUL << GPIO_AFRL_AFSEL7_Pos)         /*!< 0xF0000000 */
N#define GPIO_AFRL_AFSEL7               GPIO_AFRL_AFSEL7_Msk
N#define GPIO_AFRL_AFSEL7_0             (0x1UL << GPIO_AFRL_AFSEL7_Pos)         /*!< 0x10000000 */
N#define GPIO_AFRL_AFSEL7_1             (0x2UL << GPIO_AFRL_AFSEL7_Pos)         /*!< 0x20000000 */
N#define GPIO_AFRL_AFSEL7_2             (0x4UL << GPIO_AFRL_AFSEL7_Pos)         /*!< 0x40000000 */
N#define GPIO_AFRL_AFSEL7_3             (0x8UL << GPIO_AFRL_AFSEL7_Pos)         /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_AFRL_AFRL0                      GPIO_AFRL_AFSEL0
N#define GPIO_AFRL_AFRL1                      GPIO_AFRL_AFSEL1
N#define GPIO_AFRL_AFRL2                      GPIO_AFRL_AFSEL2
N#define GPIO_AFRL_AFRL3                      GPIO_AFRL_AFSEL3
N#define GPIO_AFRL_AFRL4                      GPIO_AFRL_AFSEL4
N#define GPIO_AFRL_AFRL5                      GPIO_AFRL_AFSEL5
N#define GPIO_AFRL_AFRL6                      GPIO_AFRL_AFSEL6
N#define GPIO_AFRL_AFRL7                      GPIO_AFRL_AFSEL7
N
N/****************** Bit definition for GPIO_AFRH register *********************/
N#define GPIO_AFRH_AFSEL8_Pos           (0U)
N#define GPIO_AFRH_AFSEL8_Msk           (0xFUL << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x0000000F */
N#define GPIO_AFRH_AFSEL8               GPIO_AFRH_AFSEL8_Msk
N#define GPIO_AFRH_AFSEL8_0             (0x1UL << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x00000001 */
N#define GPIO_AFRH_AFSEL8_1             (0x2UL << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x00000002 */
N#define GPIO_AFRH_AFSEL8_2             (0x4UL << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x00000004 */
N#define GPIO_AFRH_AFSEL8_3             (0x8UL << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x00000008 */
N#define GPIO_AFRH_AFSEL9_Pos           (4U)
N#define GPIO_AFRH_AFSEL9_Msk           (0xFUL << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x000000F0 */
N#define GPIO_AFRH_AFSEL9               GPIO_AFRH_AFSEL9_Msk
N#define GPIO_AFRH_AFSEL9_0             (0x1UL << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x00000010 */
N#define GPIO_AFRH_AFSEL9_1             (0x2UL << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x00000020 */
N#define GPIO_AFRH_AFSEL9_2             (0x4UL << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x00000040 */
N#define GPIO_AFRH_AFSEL9_3             (0x8UL << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x00000080 */
N#define GPIO_AFRH_AFSEL10_Pos          (8U)
N#define GPIO_AFRH_AFSEL10_Msk          (0xFUL << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000F00 */
N#define GPIO_AFRH_AFSEL10              GPIO_AFRH_AFSEL10_Msk
N#define GPIO_AFRH_AFSEL10_0            (0x1UL << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000100 */
N#define GPIO_AFRH_AFSEL10_1            (0x2UL << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000200 */
N#define GPIO_AFRH_AFSEL10_2            (0x4UL << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000400 */
N#define GPIO_AFRH_AFSEL10_3            (0x8UL << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000800 */
N#define GPIO_AFRH_AFSEL11_Pos          (12U)
N#define GPIO_AFRH_AFSEL11_Msk          (0xFUL << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x0000F000 */
N#define GPIO_AFRH_AFSEL11              GPIO_AFRH_AFSEL11_Msk
N#define GPIO_AFRH_AFSEL11_0            (0x1UL << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x00001000 */
N#define GPIO_AFRH_AFSEL11_1            (0x2UL << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x00002000 */
N#define GPIO_AFRH_AFSEL11_2            (0x4UL << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x00004000 */
N#define GPIO_AFRH_AFSEL11_3            (0x8UL << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x00008000 */
N#define GPIO_AFRH_AFSEL12_Pos          (16U)
N#define GPIO_AFRH_AFSEL12_Msk          (0xFUL << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x000F0000 */
N#define GPIO_AFRH_AFSEL12              GPIO_AFRH_AFSEL12_Msk
N#define GPIO_AFRH_AFSEL12_0            (0x1UL << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x00010000 */
N#define GPIO_AFRH_AFSEL12_1            (0x2UL << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x00020000 */
N#define GPIO_AFRH_AFSEL12_2            (0x4UL << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x00040000 */
N#define GPIO_AFRH_AFSEL12_3            (0x8UL << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x00080000 */
N#define GPIO_AFRH_AFSEL13_Pos          (20U)
N#define GPIO_AFRH_AFSEL13_Msk          (0xFUL << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00F00000 */
N#define GPIO_AFRH_AFSEL13              GPIO_AFRH_AFSEL13_Msk
N#define GPIO_AFRH_AFSEL13_0            (0x1UL << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00100000 */
N#define GPIO_AFRH_AFSEL13_1            (0x2UL << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00200000 */
N#define GPIO_AFRH_AFSEL13_2            (0x4UL << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00400000 */
N#define GPIO_AFRH_AFSEL13_3            (0x8UL << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00800000 */
N#define GPIO_AFRH_AFSEL14_Pos          (24U)
N#define GPIO_AFRH_AFSEL14_Msk          (0xFUL << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x0F000000 */
N#define GPIO_AFRH_AFSEL14              GPIO_AFRH_AFSEL14_Msk
N#define GPIO_AFRH_AFSEL14_0            (0x1UL << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x01000000 */
N#define GPIO_AFRH_AFSEL14_1            (0x2UL << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x02000000 */
N#define GPIO_AFRH_AFSEL14_2            (0x4UL << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x04000000 */
N#define GPIO_AFRH_AFSEL14_3            (0x8UL << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x08000000 */
N#define GPIO_AFRH_AFSEL15_Pos          (28U)
N#define GPIO_AFRH_AFSEL15_Msk          (0xFUL << GPIO_AFRH_AFSEL15_Pos)        /*!< 0xF0000000 */
N#define GPIO_AFRH_AFSEL15              GPIO_AFRH_AFSEL15_Msk
N#define GPIO_AFRH_AFSEL15_0            (0x1UL << GPIO_AFRH_AFSEL15_Pos)        /*!< 0x10000000 */
N#define GPIO_AFRH_AFSEL15_1            (0x2UL << GPIO_AFRH_AFSEL15_Pos)        /*!< 0x20000000 */
N#define GPIO_AFRH_AFSEL15_2            (0x4UL << GPIO_AFRH_AFSEL15_Pos)        /*!< 0x40000000 */
N#define GPIO_AFRH_AFSEL15_3            (0x8UL << GPIO_AFRH_AFSEL15_Pos)        /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_AFRH_AFRH0                      GPIO_AFRH_AFSEL8
N#define GPIO_AFRH_AFRH1                      GPIO_AFRH_AFSEL9
N#define GPIO_AFRH_AFRH2                      GPIO_AFRH_AFSEL10
N#define GPIO_AFRH_AFRH3                      GPIO_AFRH_AFSEL11
N#define GPIO_AFRH_AFRH4                      GPIO_AFRH_AFSEL12
N#define GPIO_AFRH_AFRH5                      GPIO_AFRH_AFSEL13
N#define GPIO_AFRH_AFRH6                      GPIO_AFRH_AFSEL14
N#define GPIO_AFRH_AFRH7                      GPIO_AFRH_AFSEL15
N
N/******************  Bits definition for GPIO_BRR register  ******************/
N#define GPIO_BRR_BR0_Pos               (0U)
N#define GPIO_BRR_BR0_Msk               (0x1UL << GPIO_BRR_BR0_Pos)             /*!< 0x00000001 */
N#define GPIO_BRR_BR0                   GPIO_BRR_BR0_Msk
N#define GPIO_BRR_BR1_Pos               (1U)
N#define GPIO_BRR_BR1_Msk               (0x1UL << GPIO_BRR_BR1_Pos)             /*!< 0x00000002 */
N#define GPIO_BRR_BR1                   GPIO_BRR_BR1_Msk
N#define GPIO_BRR_BR2_Pos               (2U)
N#define GPIO_BRR_BR2_Msk               (0x1UL << GPIO_BRR_BR2_Pos)             /*!< 0x00000004 */
N#define GPIO_BRR_BR2                   GPIO_BRR_BR2_Msk
N#define GPIO_BRR_BR3_Pos               (3U)
N#define GPIO_BRR_BR3_Msk               (0x1UL << GPIO_BRR_BR3_Pos)             /*!< 0x00000008 */
N#define GPIO_BRR_BR3                   GPIO_BRR_BR3_Msk
N#define GPIO_BRR_BR4_Pos               (4U)
N#define GPIO_BRR_BR4_Msk               (0x1UL << GPIO_BRR_BR4_Pos)             /*!< 0x00000010 */
N#define GPIO_BRR_BR4                   GPIO_BRR_BR4_Msk
N#define GPIO_BRR_BR5_Pos               (5U)
N#define GPIO_BRR_BR5_Msk               (0x1UL << GPIO_BRR_BR5_Pos)             /*!< 0x00000020 */
N#define GPIO_BRR_BR5                   GPIO_BRR_BR5_Msk
N#define GPIO_BRR_BR6_Pos               (6U)
N#define GPIO_BRR_BR6_Msk               (0x1UL << GPIO_BRR_BR6_Pos)             /*!< 0x00000040 */
N#define GPIO_BRR_BR6                   GPIO_BRR_BR6_Msk
N#define GPIO_BRR_BR7_Pos               (7U)
N#define GPIO_BRR_BR7_Msk               (0x1UL << GPIO_BRR_BR7_Pos)             /*!< 0x00000080 */
N#define GPIO_BRR_BR7                   GPIO_BRR_BR7_Msk
N#define GPIO_BRR_BR8_Pos               (8U)
N#define GPIO_BRR_BR8_Msk               (0x1UL << GPIO_BRR_BR8_Pos)             /*!< 0x00000100 */
N#define GPIO_BRR_BR8                   GPIO_BRR_BR8_Msk
N#define GPIO_BRR_BR9_Pos               (9U)
N#define GPIO_BRR_BR9_Msk               (0x1UL << GPIO_BRR_BR9_Pos)             /*!< 0x00000200 */
N#define GPIO_BRR_BR9                   GPIO_BRR_BR9_Msk
N#define GPIO_BRR_BR10_Pos              (10U)
N#define GPIO_BRR_BR10_Msk              (0x1UL << GPIO_BRR_BR10_Pos)            /*!< 0x00000400 */
N#define GPIO_BRR_BR10                  GPIO_BRR_BR10_Msk
N#define GPIO_BRR_BR11_Pos              (11U)
N#define GPIO_BRR_BR11_Msk              (0x1UL << GPIO_BRR_BR11_Pos)            /*!< 0x00000800 */
N#define GPIO_BRR_BR11                  GPIO_BRR_BR11_Msk
N#define GPIO_BRR_BR12_Pos              (12U)
N#define GPIO_BRR_BR12_Msk              (0x1UL << GPIO_BRR_BR12_Pos)            /*!< 0x00001000 */
N#define GPIO_BRR_BR12                  GPIO_BRR_BR12_Msk
N#define GPIO_BRR_BR13_Pos              (13U)
N#define GPIO_BRR_BR13_Msk              (0x1UL << GPIO_BRR_BR13_Pos)            /*!< 0x00002000 */
N#define GPIO_BRR_BR13                  GPIO_BRR_BR13_Msk
N#define GPIO_BRR_BR14_Pos              (14U)
N#define GPIO_BRR_BR14_Msk              (0x1UL << GPIO_BRR_BR14_Pos)            /*!< 0x00004000 */
N#define GPIO_BRR_BR14                  GPIO_BRR_BR14_Msk
N#define GPIO_BRR_BR15_Pos              (15U)
N#define GPIO_BRR_BR15_Msk              (0x1UL << GPIO_BRR_BR15_Pos)            /*!< 0x00008000 */
N#define GPIO_BRR_BR15                  GPIO_BRR_BR15_Msk
N
N/* Legacy defines */
N#define GPIO_BRR_BR_0                       GPIO_BRR_BR0
N#define GPIO_BRR_BR_1                       GPIO_BRR_BR1
N#define GPIO_BRR_BR_2                       GPIO_BRR_BR2
N#define GPIO_BRR_BR_3                       GPIO_BRR_BR3
N#define GPIO_BRR_BR_4                       GPIO_BRR_BR4
N#define GPIO_BRR_BR_5                       GPIO_BRR_BR5
N#define GPIO_BRR_BR_6                       GPIO_BRR_BR6
N#define GPIO_BRR_BR_7                       GPIO_BRR_BR7
N#define GPIO_BRR_BR_8                       GPIO_BRR_BR8
N#define GPIO_BRR_BR_9                       GPIO_BRR_BR9
N#define GPIO_BRR_BR_10                      GPIO_BRR_BR10
N#define GPIO_BRR_BR_11                      GPIO_BRR_BR11
N#define GPIO_BRR_BR_12                      GPIO_BRR_BR12
N#define GPIO_BRR_BR_13                      GPIO_BRR_BR13
N#define GPIO_BRR_BR_14                      GPIO_BRR_BR14
N#define GPIO_BRR_BR_15                      GPIO_BRR_BR15
N
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface (I2C)              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define I2C_CR1_PE_Pos               (0U)
N#define I2C_CR1_PE_Msk               (0x1UL << I2C_CR1_PE_Pos)                 /*!< 0x00000001 */
N#define I2C_CR1_PE                   I2C_CR1_PE_Msk                            /*!< Peripheral enable                   */
N#define I2C_CR1_TXIE_Pos             (1U)
N#define I2C_CR1_TXIE_Msk             (0x1UL << I2C_CR1_TXIE_Pos)               /*!< 0x00000002 */
N#define I2C_CR1_TXIE                 I2C_CR1_TXIE_Msk                          /*!< TX interrupt enable                 */
N#define I2C_CR1_RXIE_Pos             (2U)
N#define I2C_CR1_RXIE_Msk             (0x1UL << I2C_CR1_RXIE_Pos)               /*!< 0x00000004 */
N#define I2C_CR1_RXIE                 I2C_CR1_RXIE_Msk                          /*!< RX interrupt enable                 */
N#define I2C_CR1_ADDRIE_Pos           (3U)
N#define I2C_CR1_ADDRIE_Msk           (0x1UL << I2C_CR1_ADDRIE_Pos)             /*!< 0x00000008 */
N#define I2C_CR1_ADDRIE               I2C_CR1_ADDRIE_Msk                        /*!< Address match interrupt enable      */
N#define I2C_CR1_NACKIE_Pos           (4U)
N#define I2C_CR1_NACKIE_Msk           (0x1UL << I2C_CR1_NACKIE_Pos)             /*!< 0x00000010 */
N#define I2C_CR1_NACKIE               I2C_CR1_NACKIE_Msk                        /*!< NACK received interrupt enable      */
N#define I2C_CR1_STOPIE_Pos           (5U)
N#define I2C_CR1_STOPIE_Msk           (0x1UL << I2C_CR1_STOPIE_Pos)             /*!< 0x00000020 */
N#define I2C_CR1_STOPIE               I2C_CR1_STOPIE_Msk                        /*!< STOP detection interrupt enable     */
N#define I2C_CR1_TCIE_Pos             (6U)
N#define I2C_CR1_TCIE_Msk             (0x1UL << I2C_CR1_TCIE_Pos)               /*!< 0x00000040 */
N#define I2C_CR1_TCIE                 I2C_CR1_TCIE_Msk                          /*!< Transfer complete interrupt enable  */
N#define I2C_CR1_ERRIE_Pos            (7U)
N#define I2C_CR1_ERRIE_Msk            (0x1UL << I2C_CR1_ERRIE_Pos)              /*!< 0x00000080 */
N#define I2C_CR1_ERRIE                I2C_CR1_ERRIE_Msk                         /*!< Errors interrupt enable             */
N#define I2C_CR1_DNF_Pos              (8U)
N#define I2C_CR1_DNF_Msk              (0xFUL << I2C_CR1_DNF_Pos)                /*!< 0x00000F00 */
N#define I2C_CR1_DNF                  I2C_CR1_DNF_Msk                           /*!< Digital noise filter                */
N#define I2C_CR1_ANFOFF_Pos           (12U)
N#define I2C_CR1_ANFOFF_Msk           (0x1UL << I2C_CR1_ANFOFF_Pos)             /*!< 0x00001000 */
N#define I2C_CR1_ANFOFF               I2C_CR1_ANFOFF_Msk                        /*!< Analog noise filter OFF             */
N#define I2C_CR1_SWRST_Pos            (13U)
N#define I2C_CR1_SWRST_Msk            (0x1UL << I2C_CR1_SWRST_Pos)              /*!< 0x00002000 */
N#define I2C_CR1_SWRST                I2C_CR1_SWRST_Msk                         /*!< Software reset                      */
N#define I2C_CR1_TXDMAEN_Pos          (14U)
N#define I2C_CR1_TXDMAEN_Msk          (0x1UL << I2C_CR1_TXDMAEN_Pos)            /*!< 0x00004000 */
N#define I2C_CR1_TXDMAEN              I2C_CR1_TXDMAEN_Msk                       /*!< DMA transmission requests enable    */
N#define I2C_CR1_RXDMAEN_Pos          (15U)
N#define I2C_CR1_RXDMAEN_Msk          (0x1UL << I2C_CR1_RXDMAEN_Pos)            /*!< 0x00008000 */
N#define I2C_CR1_RXDMAEN              I2C_CR1_RXDMAEN_Msk                       /*!< DMA reception requests enable       */
N#define I2C_CR1_SBC_Pos              (16U)
N#define I2C_CR1_SBC_Msk              (0x1UL << I2C_CR1_SBC_Pos)                /*!< 0x00010000 */
N#define I2C_CR1_SBC                  I2C_CR1_SBC_Msk                           /*!< Slave byte control                  */
N#define I2C_CR1_NOSTRETCH_Pos        (17U)
N#define I2C_CR1_NOSTRETCH_Msk        (0x1UL << I2C_CR1_NOSTRETCH_Pos)          /*!< 0x00020000 */
N#define I2C_CR1_NOSTRETCH            I2C_CR1_NOSTRETCH_Msk                     /*!< Clock stretching disable            */
N#define I2C_CR1_WUPEN_Pos            (18U)
N#define I2C_CR1_WUPEN_Msk            (0x1UL << I2C_CR1_WUPEN_Pos)              /*!< 0x00040000 */
N#define I2C_CR1_WUPEN                I2C_CR1_WUPEN_Msk                         /*!< Wakeup from STOP enable             */
N#define I2C_CR1_GCEN_Pos             (19U)
N#define I2C_CR1_GCEN_Msk             (0x1UL << I2C_CR1_GCEN_Pos)               /*!< 0x00080000 */
N#define I2C_CR1_GCEN                 I2C_CR1_GCEN_Msk                          /*!< General call enable                 */
N#define I2C_CR1_SMBHEN_Pos           (20U)
N#define I2C_CR1_SMBHEN_Msk           (0x1UL << I2C_CR1_SMBHEN_Pos)             /*!< 0x00100000 */
N#define I2C_CR1_SMBHEN               I2C_CR1_SMBHEN_Msk                        /*!< SMBus host address enable           */
N#define I2C_CR1_SMBDEN_Pos           (21U)
N#define I2C_CR1_SMBDEN_Msk           (0x1UL << I2C_CR1_SMBDEN_Pos)             /*!< 0x00200000 */
N#define I2C_CR1_SMBDEN               I2C_CR1_SMBDEN_Msk                        /*!< SMBus device default address enable */
N#define I2C_CR1_ALERTEN_Pos          (22U)
N#define I2C_CR1_ALERTEN_Msk          (0x1UL << I2C_CR1_ALERTEN_Pos)            /*!< 0x00400000 */
N#define I2C_CR1_ALERTEN              I2C_CR1_ALERTEN_Msk                       /*!< SMBus alert enable                  */
N#define I2C_CR1_PECEN_Pos            (23U)
N#define I2C_CR1_PECEN_Msk            (0x1UL << I2C_CR1_PECEN_Pos)              /*!< 0x00800000 */
N#define I2C_CR1_PECEN                I2C_CR1_PECEN_Msk                         /*!< PEC enable                          */
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define I2C_CR2_SADD_Pos             (0U)
N#define I2C_CR2_SADD_Msk             (0x3FFUL << I2C_CR2_SADD_Pos)             /*!< 0x000003FF */
N#define I2C_CR2_SADD                 I2C_CR2_SADD_Msk                          /*!< Slave address (master mode)                             */
N#define I2C_CR2_RD_WRN_Pos           (10U)
N#define I2C_CR2_RD_WRN_Msk           (0x1UL << I2C_CR2_RD_WRN_Pos)             /*!< 0x00000400 */
N#define I2C_CR2_RD_WRN               I2C_CR2_RD_WRN_Msk                        /*!< Transfer direction (master mode)                        */
N#define I2C_CR2_ADD10_Pos            (11U)
N#define I2C_CR2_ADD10_Msk            (0x1UL << I2C_CR2_ADD10_Pos)              /*!< 0x00000800 */
N#define I2C_CR2_ADD10                I2C_CR2_ADD10_Msk                         /*!< 10-bit addressing mode (master mode)                    */
N#define I2C_CR2_HEAD10R_Pos          (12U)
N#define I2C_CR2_HEAD10R_Msk          (0x1UL << I2C_CR2_HEAD10R_Pos)            /*!< 0x00001000 */
N#define I2C_CR2_HEAD10R              I2C_CR2_HEAD10R_Msk                       /*!< 10-bit address header only read direction (master mode) */
N#define I2C_CR2_START_Pos            (13U)
N#define I2C_CR2_START_Msk            (0x1UL << I2C_CR2_START_Pos)              /*!< 0x00002000 */
N#define I2C_CR2_START                I2C_CR2_START_Msk                         /*!< START generation                                        */
N#define I2C_CR2_STOP_Pos             (14U)
N#define I2C_CR2_STOP_Msk             (0x1UL << I2C_CR2_STOP_Pos)               /*!< 0x00004000 */
N#define I2C_CR2_STOP                 I2C_CR2_STOP_Msk                          /*!< STOP generation (master mode)                           */
N#define I2C_CR2_NACK_Pos             (15U)
N#define I2C_CR2_NACK_Msk             (0x1UL << I2C_CR2_NACK_Pos)               /*!< 0x00008000 */
N#define I2C_CR2_NACK                 I2C_CR2_NACK_Msk                          /*!< NACK generation (slave mode)                            */
N#define I2C_CR2_NBYTES_Pos           (16U)
N#define I2C_CR2_NBYTES_Msk           (0xFFUL << I2C_CR2_NBYTES_Pos)            /*!< 0x00FF0000 */
N#define I2C_CR2_NBYTES               I2C_CR2_NBYTES_Msk                        /*!< Number of bytes                                         */
N#define I2C_CR2_RELOAD_Pos           (24U)
N#define I2C_CR2_RELOAD_Msk           (0x1UL << I2C_CR2_RELOAD_Pos)             /*!< 0x01000000 */
N#define I2C_CR2_RELOAD               I2C_CR2_RELOAD_Msk                        /*!< NBYTES reload mode                                      */
N#define I2C_CR2_AUTOEND_Pos          (25U)
N#define I2C_CR2_AUTOEND_Msk          (0x1UL << I2C_CR2_AUTOEND_Pos)            /*!< 0x02000000 */
N#define I2C_CR2_AUTOEND              I2C_CR2_AUTOEND_Msk                       /*!< Automatic end mode (master mode)                        */
N#define I2C_CR2_PECBYTE_Pos          (26U)
N#define I2C_CR2_PECBYTE_Msk          (0x1UL << I2C_CR2_PECBYTE_Pos)            /*!< 0x04000000 */
N#define I2C_CR2_PECBYTE              I2C_CR2_PECBYTE_Msk                       /*!< Packet error checking byte                              */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define I2C_OAR1_OA1_Pos             (0U)
N#define I2C_OAR1_OA1_Msk             (0x3FFUL << I2C_OAR1_OA1_Pos)             /*!< 0x000003FF */
N#define I2C_OAR1_OA1                 I2C_OAR1_OA1_Msk                          /*!< Interface own address 1   */
N#define I2C_OAR1_OA1MODE_Pos         (10U)
N#define I2C_OAR1_OA1MODE_Msk         (0x1UL << I2C_OAR1_OA1MODE_Pos)           /*!< 0x00000400 */
N#define I2C_OAR1_OA1MODE             I2C_OAR1_OA1MODE_Msk                      /*!< Own address 1 10-bit mode */
N#define I2C_OAR1_OA1EN_Pos           (15U)
N#define I2C_OAR1_OA1EN_Msk           (0x1UL << I2C_OAR1_OA1EN_Pos)             /*!< 0x00008000 */
N#define I2C_OAR1_OA1EN               I2C_OAR1_OA1EN_Msk                        /*!< Own address 1 enable      */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define I2C_OAR2_OA2_Pos             (1U)
N#define I2C_OAR2_OA2_Msk             (0x7FUL << I2C_OAR2_OA2_Pos)              /*!< 0x000000FE */
N#define I2C_OAR2_OA2                 I2C_OAR2_OA2_Msk                          /*!< Interface own address 2                        */
N#define I2C_OAR2_OA2MSK_Pos          (8U)
N#define I2C_OAR2_OA2MSK_Msk          (0x7UL << I2C_OAR2_OA2MSK_Pos)            /*!< 0x00000700 */
N#define I2C_OAR2_OA2MSK              I2C_OAR2_OA2MSK_Msk                       /*!< Own address 2 masks                            */
N#define I2C_OAR2_OA2NOMASK           (0x00000000UL)                            /*!< No mask                                        */
N#define I2C_OAR2_OA2MASK01_Pos       (8U)
N#define I2C_OAR2_OA2MASK01_Msk       (0x1UL << I2C_OAR2_OA2MASK01_Pos)         /*!< 0x00000100 */
N#define I2C_OAR2_OA2MASK01           I2C_OAR2_OA2MASK01_Msk                    /*!< OA2[1] is masked, Only OA2[7:2] are compared   */
N#define I2C_OAR2_OA2MASK02_Pos       (9U)
N#define I2C_OAR2_OA2MASK02_Msk       (0x1UL << I2C_OAR2_OA2MASK02_Pos)         /*!< 0x00000200 */
N#define I2C_OAR2_OA2MASK02           I2C_OAR2_OA2MASK02_Msk                    /*!< OA2[2:1] is masked, Only OA2[7:3] are compared */
N#define I2C_OAR2_OA2MASK03_Pos       (8U)
N#define I2C_OAR2_OA2MASK03_Msk       (0x3UL << I2C_OAR2_OA2MASK03_Pos)         /*!< 0x00000300 */
N#define I2C_OAR2_OA2MASK03           I2C_OAR2_OA2MASK03_Msk                    /*!< OA2[3:1] is masked, Only OA2[7:4] are compared */
N#define I2C_OAR2_OA2MASK04_Pos       (10U)
N#define I2C_OAR2_OA2MASK04_Msk       (0x1UL << I2C_OAR2_OA2MASK04_Pos)         /*!< 0x00000400 */
N#define I2C_OAR2_OA2MASK04           I2C_OAR2_OA2MASK04_Msk                    /*!< OA2[4:1] is masked, Only OA2[7:5] are compared */
N#define I2C_OAR2_OA2MASK05_Pos       (8U)
N#define I2C_OAR2_OA2MASK05_Msk       (0x5UL << I2C_OAR2_OA2MASK05_Pos)         /*!< 0x00000500 */
N#define I2C_OAR2_OA2MASK05           I2C_OAR2_OA2MASK05_Msk                    /*!< OA2[5:1] is masked, Only OA2[7:6] are compared */
N#define I2C_OAR2_OA2MASK06_Pos       (9U)
N#define I2C_OAR2_OA2MASK06_Msk       (0x3UL << I2C_OAR2_OA2MASK06_Pos)         /*!< 0x00000600 */
N#define I2C_OAR2_OA2MASK06           I2C_OAR2_OA2MASK06_Msk                    /*!< OA2[6:1] is masked, Only OA2[7] are compared   */
N#define I2C_OAR2_OA2MASK07_Pos       (8U)
N#define I2C_OAR2_OA2MASK07_Msk       (0x7UL << I2C_OAR2_OA2MASK07_Pos)         /*!< 0x00000700 */
N#define I2C_OAR2_OA2MASK07           I2C_OAR2_OA2MASK07_Msk                    /*!< OA2[7:1] is masked, No comparison is done      */
N#define I2C_OAR2_OA2EN_Pos           (15U)
N#define I2C_OAR2_OA2EN_Msk           (0x1UL << I2C_OAR2_OA2EN_Pos)             /*!< 0x00008000 */
N#define I2C_OAR2_OA2EN               I2C_OAR2_OA2EN_Msk                        /*!< Own address 2 enable                           */
N
N/*******************  Bit definition for I2C_TIMINGR register *******************/
N#define I2C_TIMINGR_SCLL_Pos         (0U)
N#define I2C_TIMINGR_SCLL_Msk         (0xFFUL << I2C_TIMINGR_SCLL_Pos)          /*!< 0x000000FF */
N#define I2C_TIMINGR_SCLL             I2C_TIMINGR_SCLL_Msk                      /*!< SCL low period (master mode)  */
N#define I2C_TIMINGR_SCLH_Pos         (8U)
N#define I2C_TIMINGR_SCLH_Msk         (0xFFUL << I2C_TIMINGR_SCLH_Pos)          /*!< 0x0000FF00 */
N#define I2C_TIMINGR_SCLH             I2C_TIMINGR_SCLH_Msk                      /*!< SCL high period (master mode) */
N#define I2C_TIMINGR_SDADEL_Pos       (16U)
N#define I2C_TIMINGR_SDADEL_Msk       (0xFUL << I2C_TIMINGR_SDADEL_Pos)         /*!< 0x000F0000 */
N#define I2C_TIMINGR_SDADEL           I2C_TIMINGR_SDADEL_Msk                    /*!< Data hold time                */
N#define I2C_TIMINGR_SCLDEL_Pos       (20U)
N#define I2C_TIMINGR_SCLDEL_Msk       (0xFUL << I2C_TIMINGR_SCLDEL_Pos)         /*!< 0x00F00000 */
N#define I2C_TIMINGR_SCLDEL           I2C_TIMINGR_SCLDEL_Msk                    /*!< Data setup time               */
N#define I2C_TIMINGR_PRESC_Pos        (28U)
N#define I2C_TIMINGR_PRESC_Msk        (0xFUL << I2C_TIMINGR_PRESC_Pos)          /*!< 0xF0000000 */
N#define I2C_TIMINGR_PRESC            I2C_TIMINGR_PRESC_Msk                     /*!< Timings prescaler             */
N
N/******************* Bit definition for I2C_TIMEOUTR register *******************/
N#define I2C_TIMEOUTR_TIMEOUTA_Pos    (0U)
N#define I2C_TIMEOUTR_TIMEOUTA_Msk    (0xFFFUL << I2C_TIMEOUTR_TIMEOUTA_Pos)    /*!< 0x00000FFF */
N#define I2C_TIMEOUTR_TIMEOUTA        I2C_TIMEOUTR_TIMEOUTA_Msk                 /*!< Bus timeout A                 */
N#define I2C_TIMEOUTR_TIDLE_Pos       (12U)
N#define I2C_TIMEOUTR_TIDLE_Msk       (0x1UL << I2C_TIMEOUTR_TIDLE_Pos)         /*!< 0x00001000 */
N#define I2C_TIMEOUTR_TIDLE           I2C_TIMEOUTR_TIDLE_Msk                    /*!< Idle clock timeout detection  */
N#define I2C_TIMEOUTR_TIMOUTEN_Pos    (15U)
N#define I2C_TIMEOUTR_TIMOUTEN_Msk    (0x1UL << I2C_TIMEOUTR_TIMOUTEN_Pos)      /*!< 0x00008000 */
N#define I2C_TIMEOUTR_TIMOUTEN        I2C_TIMEOUTR_TIMOUTEN_Msk                 /*!< Clock timeout enable          */
N#define I2C_TIMEOUTR_TIMEOUTB_Pos    (16U)
N#define I2C_TIMEOUTR_TIMEOUTB_Msk    (0xFFFUL << I2C_TIMEOUTR_TIMEOUTB_Pos)    /*!< 0x0FFF0000 */
N#define I2C_TIMEOUTR_TIMEOUTB        I2C_TIMEOUTR_TIMEOUTB_Msk                 /*!< Bus timeout B                 */
N#define I2C_TIMEOUTR_TEXTEN_Pos      (31U)
N#define I2C_TIMEOUTR_TEXTEN_Msk      (0x1UL << I2C_TIMEOUTR_TEXTEN_Pos)        /*!< 0x80000000 */
N#define I2C_TIMEOUTR_TEXTEN          I2C_TIMEOUTR_TEXTEN_Msk                   /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  *********************/
N#define I2C_ISR_TXE_Pos              (0U)
N#define I2C_ISR_TXE_Msk              (0x1UL << I2C_ISR_TXE_Pos)                /*!< 0x00000001 */
N#define I2C_ISR_TXE                  I2C_ISR_TXE_Msk                           /*!< Transmit data register empty    */
N#define I2C_ISR_TXIS_Pos             (1U)
N#define I2C_ISR_TXIS_Msk             (0x1UL << I2C_ISR_TXIS_Pos)               /*!< 0x00000002 */
N#define I2C_ISR_TXIS                 I2C_ISR_TXIS_Msk                          /*!< Transmit interrupt status       */
N#define I2C_ISR_RXNE_Pos             (2U)
N#define I2C_ISR_RXNE_Msk             (0x1UL << I2C_ISR_RXNE_Pos)               /*!< 0x00000004 */
N#define I2C_ISR_RXNE                 I2C_ISR_RXNE_Msk                          /*!< Receive data register not empty */
N#define I2C_ISR_ADDR_Pos             (3U)
N#define I2C_ISR_ADDR_Msk             (0x1UL << I2C_ISR_ADDR_Pos)               /*!< 0x00000008 */
N#define I2C_ISR_ADDR                 I2C_ISR_ADDR_Msk                          /*!< Address matched (slave mode)    */
N#define I2C_ISR_NACKF_Pos            (4U)
N#define I2C_ISR_NACKF_Msk            (0x1UL << I2C_ISR_NACKF_Pos)              /*!< 0x00000010 */
N#define I2C_ISR_NACKF                I2C_ISR_NACKF_Msk                         /*!< NACK received flag              */
N#define I2C_ISR_STOPF_Pos            (5U)
N#define I2C_ISR_STOPF_Msk            (0x1UL << I2C_ISR_STOPF_Pos)              /*!< 0x00000020 */
N#define I2C_ISR_STOPF                I2C_ISR_STOPF_Msk                         /*!< STOP detection flag             */
N#define I2C_ISR_TC_Pos               (6U)
N#define I2C_ISR_TC_Msk               (0x1UL << I2C_ISR_TC_Pos)                 /*!< 0x00000040 */
N#define I2C_ISR_TC                   I2C_ISR_TC_Msk                            /*!< Transfer complete (master mode) */
N#define I2C_ISR_TCR_Pos              (7U)
N#define I2C_ISR_TCR_Msk              (0x1UL << I2C_ISR_TCR_Pos)                /*!< 0x00000080 */
N#define I2C_ISR_TCR                  I2C_ISR_TCR_Msk                           /*!< Transfer complete reload        */
N#define I2C_ISR_BERR_Pos             (8U)
N#define I2C_ISR_BERR_Msk             (0x1UL << I2C_ISR_BERR_Pos)               /*!< 0x00000100 */
N#define I2C_ISR_BERR                 I2C_ISR_BERR_Msk                          /*!< Bus error                       */
N#define I2C_ISR_ARLO_Pos             (9U)
N#define I2C_ISR_ARLO_Msk             (0x1UL << I2C_ISR_ARLO_Pos)               /*!< 0x00000200 */
N#define I2C_ISR_ARLO                 I2C_ISR_ARLO_Msk                          /*!< Arbitration lost                */
N#define I2C_ISR_OVR_Pos              (10U)
N#define I2C_ISR_OVR_Msk              (0x1UL << I2C_ISR_OVR_Pos)                /*!< 0x00000400 */
N#define I2C_ISR_OVR                  I2C_ISR_OVR_Msk                           /*!< Overrun/Underrun                */
N#define I2C_ISR_PECERR_Pos           (11U)
N#define I2C_ISR_PECERR_Msk           (0x1UL << I2C_ISR_PECERR_Pos)             /*!< 0x00000800 */
N#define I2C_ISR_PECERR               I2C_ISR_PECERR_Msk                        /*!< PEC error in reception          */
N#define I2C_ISR_TIMEOUT_Pos          (12U)
N#define I2C_ISR_TIMEOUT_Msk          (0x1UL << I2C_ISR_TIMEOUT_Pos)            /*!< 0x00001000 */
N#define I2C_ISR_TIMEOUT              I2C_ISR_TIMEOUT_Msk                       /*!< Timeout or Tlow detection flag  */
N#define I2C_ISR_ALERT_Pos            (13U)
N#define I2C_ISR_ALERT_Msk            (0x1UL << I2C_ISR_ALERT_Pos)              /*!< 0x00002000 */
N#define I2C_ISR_ALERT                I2C_ISR_ALERT_Msk                         /*!< SMBus alert                     */
N#define I2C_ISR_BUSY_Pos             (15U)
N#define I2C_ISR_BUSY_Msk             (0x1UL << I2C_ISR_BUSY_Pos)               /*!< 0x00008000 */
N#define I2C_ISR_BUSY                 I2C_ISR_BUSY_Msk                          /*!< Bus busy                        */
N#define I2C_ISR_DIR_Pos              (16U)
N#define I2C_ISR_DIR_Msk              (0x1UL << I2C_ISR_DIR_Pos)                /*!< 0x00010000 */
N#define I2C_ISR_DIR                  I2C_ISR_DIR_Msk                           /*!< Transfer direction (slave mode) */
N#define I2C_ISR_ADDCODE_Pos          (17U)
N#define I2C_ISR_ADDCODE_Msk          (0x7FUL << I2C_ISR_ADDCODE_Pos)           /*!< 0x00FE0000 */
N#define I2C_ISR_ADDCODE              I2C_ISR_ADDCODE_Msk                       /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  *********************/
N#define I2C_ICR_ADDRCF_Pos           (3U)
N#define I2C_ICR_ADDRCF_Msk           (0x1UL << I2C_ICR_ADDRCF_Pos)             /*!< 0x00000008 */
N#define I2C_ICR_ADDRCF               I2C_ICR_ADDRCF_Msk                        /*!< Address matched clear flag  */
N#define I2C_ICR_NACKCF_Pos           (4U)
N#define I2C_ICR_NACKCF_Msk           (0x1UL << I2C_ICR_NACKCF_Pos)             /*!< 0x00000010 */
N#define I2C_ICR_NACKCF               I2C_ICR_NACKCF_Msk                        /*!< NACK clear flag             */
N#define I2C_ICR_STOPCF_Pos           (5U)
N#define I2C_ICR_STOPCF_Msk           (0x1UL << I2C_ICR_STOPCF_Pos)             /*!< 0x00000020 */
N#define I2C_ICR_STOPCF               I2C_ICR_STOPCF_Msk                        /*!< STOP detection clear flag   */
N#define I2C_ICR_BERRCF_Pos           (8U)
N#define I2C_ICR_BERRCF_Msk           (0x1UL << I2C_ICR_BERRCF_Pos)             /*!< 0x00000100 */
N#define I2C_ICR_BERRCF               I2C_ICR_BERRCF_Msk                        /*!< Bus error clear flag        */
N#define I2C_ICR_ARLOCF_Pos           (9U)
N#define I2C_ICR_ARLOCF_Msk           (0x1UL << I2C_ICR_ARLOCF_Pos)             /*!< 0x00000200 */
N#define I2C_ICR_ARLOCF               I2C_ICR_ARLOCF_Msk                        /*!< Arbitration lost clear flag */
N#define I2C_ICR_OVRCF_Pos            (10U)
N#define I2C_ICR_OVRCF_Msk            (0x1UL << I2C_ICR_OVRCF_Pos)              /*!< 0x00000400 */
N#define I2C_ICR_OVRCF                I2C_ICR_OVRCF_Msk                         /*!< Overrun/Underrun clear flag */
N#define I2C_ICR_PECCF_Pos            (11U)
N#define I2C_ICR_PECCF_Msk            (0x1UL << I2C_ICR_PECCF_Pos)              /*!< 0x00000800 */
N#define I2C_ICR_PECCF                I2C_ICR_PECCF_Msk                         /*!< PAC error clear flag        */
N#define I2C_ICR_TIMOUTCF_Pos         (12U)
N#define I2C_ICR_TIMOUTCF_Msk         (0x1UL << I2C_ICR_TIMOUTCF_Pos)           /*!< 0x00001000 */
N#define I2C_ICR_TIMOUTCF             I2C_ICR_TIMOUTCF_Msk                      /*!< Timeout clear flag          */
N#define I2C_ICR_ALERTCF_Pos          (13U)
N#define I2C_ICR_ALERTCF_Msk          (0x1UL << I2C_ICR_ALERTCF_Pos)            /*!< 0x00002000 */
N#define I2C_ICR_ALERTCF              I2C_ICR_ALERTCF_Msk                       /*!< Alert clear flag            */
N
N/******************  Bit definition for I2C_PECR register  *********************/
N#define I2C_PECR_PEC_Pos             (0U)
N#define I2C_PECR_PEC_Msk             (0xFFUL << I2C_PECR_PEC_Pos)              /*!< 0x000000FF */
N#define I2C_PECR_PEC                 I2C_PECR_PEC_Msk                          /*!< PEC register */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define I2C_RXDR_RXDATA_Pos          (0U)
N#define I2C_RXDR_RXDATA_Msk          (0xFFUL << I2C_RXDR_RXDATA_Pos)           /*!< 0x000000FF */
N#define I2C_RXDR_RXDATA              I2C_RXDR_RXDATA_Msk                       /*!< 8-bit receive data */
N
N/******************  Bit definition for I2C_TXDR register  *********************/
N#define I2C_TXDR_TXDATA_Pos          (0U)
N#define I2C_TXDR_TXDATA_Msk          (0xFFUL << I2C_TXDR_TXDATA_Pos)           /*!< 0x000000FF */
N#define I2C_TXDR_TXDATA              I2C_TXDR_TXDATA_Msk                       /*!< 8-bit transmit data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define IWDG_KR_KEY_Pos      (0U)
N#define IWDG_KR_KEY_Msk      (0xFFFFUL << IWDG_KR_KEY_Pos)                     /*!< 0x0000FFFF */
N#define IWDG_KR_KEY          IWDG_KR_KEY_Msk                                   /*!<Key value (write only, read 0000h)  */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define IWDG_PR_PR_Pos       (0U)
N#define IWDG_PR_PR_Msk       (0x7UL << IWDG_PR_PR_Pos)                         /*!< 0x00000007 */
N#define IWDG_PR_PR           IWDG_PR_PR_Msk                                    /*!<PR[2:0] (Prescaler divider)         */
N#define IWDG_PR_PR_0         (0x1UL << IWDG_PR_PR_Pos)                         /*!< 0x00000001 */
N#define IWDG_PR_PR_1         (0x2UL << IWDG_PR_PR_Pos)                         /*!< 0x00000002 */
N#define IWDG_PR_PR_2         (0x4UL << IWDG_PR_PR_Pos)                         /*!< 0x00000004 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define IWDG_RLR_RL_Pos      (0U)
N#define IWDG_RLR_RL_Msk      (0xFFFUL << IWDG_RLR_RL_Pos)                      /*!< 0x00000FFF */
N#define IWDG_RLR_RL          IWDG_RLR_RL_Msk                                   /*!<Watchdog counter reload value        */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define IWDG_SR_PVU_Pos      (0U)
N#define IWDG_SR_PVU_Msk      (0x1UL << IWDG_SR_PVU_Pos)                        /*!< 0x00000001 */
N#define IWDG_SR_PVU          IWDG_SR_PVU_Msk                                   /*!< Watchdog prescaler value update */
N#define IWDG_SR_RVU_Pos      (1U)
N#define IWDG_SR_RVU_Msk      (0x1UL << IWDG_SR_RVU_Pos)                        /*!< 0x00000002 */
N#define IWDG_SR_RVU          IWDG_SR_RVU_Msk                                   /*!< Watchdog counter reload value update */
N#define IWDG_SR_WVU_Pos      (2U)
N#define IWDG_SR_WVU_Msk      (0x1UL << IWDG_SR_WVU_Pos)                        /*!< 0x00000004 */
N#define IWDG_SR_WVU          IWDG_SR_WVU_Msk                                   /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define IWDG_WINR_WIN_Pos    (0U)
N#define IWDG_WINR_WIN_Msk    (0xFFFUL << IWDG_WINR_WIN_Pos)                    /*!< 0x00000FFF */
N#define IWDG_WINR_WIN        IWDG_WINR_WIN_Msk                                 /*!< Watchdog counter window value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                     Firewall                               */
N/*                                                                            */
N/******************************************************************************/
N
N/*******Bit definition for CSSA;CSL;NVDSSA;NVDSL;VDSSA;VDSL register          */
N#define FW_CSSA_ADD_Pos      (8U)
N#define FW_CSSA_ADD_Msk      (0xFFFFUL << FW_CSSA_ADD_Pos)                     /*!< 0x00FFFF00 */
N#define FW_CSSA_ADD          FW_CSSA_ADD_Msk                                   /*!< Code Segment Start Address */
N#define FW_CSL_LENG_Pos      (8U)
N#define FW_CSL_LENG_Msk      (0x3FFFUL << FW_CSL_LENG_Pos)                     /*!< 0x003FFF00 */
N#define FW_CSL_LENG          FW_CSL_LENG_Msk                                   /*!< Code Segment Length        */
N#define FW_NVDSSA_ADD_Pos    (8U)
N#define FW_NVDSSA_ADD_Msk    (0xFFFFUL << FW_NVDSSA_ADD_Pos)                   /*!< 0x00FFFF00 */
N#define FW_NVDSSA_ADD        FW_NVDSSA_ADD_Msk                                 /*!< Non Volatile Dat Segment Start Address */
N#define FW_NVDSL_LENG_Pos    (8U)
N#define FW_NVDSL_LENG_Msk    (0x3FFFUL << FW_NVDSL_LENG_Pos)                   /*!< 0x003FFF00 */
N#define FW_NVDSL_LENG        FW_NVDSL_LENG_Msk                                 /*!< Non Volatile Data Segment Length */
N#define FW_VDSSA_ADD_Pos     (6U)
N#define FW_VDSSA_ADD_Msk     (0x7FFUL << FW_VDSSA_ADD_Pos)                     /*!< 0x0001FFC0 */
N#define FW_VDSSA_ADD         FW_VDSSA_ADD_Msk                                  /*!< Volatile Data Segment Start Address */
N#define FW_VDSL_LENG_Pos     (6U)
N#define FW_VDSL_LENG_Msk     (0x7FFUL << FW_VDSL_LENG_Pos)                     /*!< 0x0001FFC0 */
N#define FW_VDSL_LENG         FW_VDSL_LENG_Msk                                  /*!< Volatile Data Segment Length */
N
N/**************************Bit definition for CR register *********************/
N#define FW_CR_FPA_Pos        (0U)
N#define FW_CR_FPA_Msk        (0x1UL << FW_CR_FPA_Pos)                          /*!< 0x00000001 */
N#define FW_CR_FPA            FW_CR_FPA_Msk                                     /*!< Firewall Pre Arm*/
N#define FW_CR_VDS_Pos        (1U)
N#define FW_CR_VDS_Msk        (0x1UL << FW_CR_VDS_Pos)                          /*!< 0x00000002 */
N#define FW_CR_VDS            FW_CR_VDS_Msk                                     /*!< Volatile Data Sharing*/
N#define FW_CR_VDE_Pos        (2U)
N#define FW_CR_VDE_Msk        (0x1UL << FW_CR_VDE_Pos)                          /*!< 0x00000004 */
N#define FW_CR_VDE            FW_CR_VDE_Msk                                     /*!< Volatile Data Execution*/
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for PWR_CR1 register  ********************/
N
N#define PWR_CR1_LPR_Pos              (14U)
N#define PWR_CR1_LPR_Msk              (0x1UL << PWR_CR1_LPR_Pos)                /*!< 0x00004000 */
N#define PWR_CR1_LPR                  PWR_CR1_LPR_Msk                           /*!< Regulator low-power mode */
N#define PWR_CR1_VOS_Pos              (9U)
N#define PWR_CR1_VOS_Msk              (0x3UL << PWR_CR1_VOS_Pos)                /*!< 0x00000600 */
N#define PWR_CR1_VOS                  PWR_CR1_VOS_Msk                           /*!< VOS[1:0] bits (Regulator voltage scaling output selection) */
N#define PWR_CR1_VOS_0                (0x1UL << PWR_CR1_VOS_Pos)                /*!< 0x00000200 */
N#define PWR_CR1_VOS_1                (0x2UL << PWR_CR1_VOS_Pos)                /*!< 0x00000400 */
N#define PWR_CR1_DBP_Pos              (8U)
N#define PWR_CR1_DBP_Msk              (0x1UL << PWR_CR1_DBP_Pos)                /*!< 0x00000100 */
N#define PWR_CR1_DBP                  PWR_CR1_DBP_Msk                           /*!< Disable Back-up domain Protection */
N#define PWR_CR1_LPMS_Pos             (0U)
N#define PWR_CR1_LPMS_Msk             (0x7UL << PWR_CR1_LPMS_Pos)               /*!< 0x00000007 */
N#define PWR_CR1_LPMS                 PWR_CR1_LPMS_Msk                          /*!< Low-power mode selection field */
N#define PWR_CR1_LPMS_STOP0           (0x00000000UL)                            /*!< Stop 0 mode */
N#define PWR_CR1_LPMS_STOP1_Pos       (0U)
N#define PWR_CR1_LPMS_STOP1_Msk       (0x1UL << PWR_CR1_LPMS_STOP1_Pos)         /*!< 0x00000001 */
N#define PWR_CR1_LPMS_STOP1           PWR_CR1_LPMS_STOP1_Msk                    /*!< Stop 1 mode */
N#define PWR_CR1_LPMS_STOP2_Pos       (1U)
N#define PWR_CR1_LPMS_STOP2_Msk       (0x1UL << PWR_CR1_LPMS_STOP2_Pos)         /*!< 0x00000002 */
N#define PWR_CR1_LPMS_STOP2           PWR_CR1_LPMS_STOP2_Msk                    /*!< Stop 2 mode */
N#define PWR_CR1_LPMS_STANDBY_Pos     (0U)
N#define PWR_CR1_LPMS_STANDBY_Msk     (0x3UL << PWR_CR1_LPMS_STANDBY_Pos)       /*!< 0x00000003 */
N#define PWR_CR1_LPMS_STANDBY         PWR_CR1_LPMS_STANDBY_Msk                  /*!< Stand-by mode */
N#define PWR_CR1_LPMS_SHUTDOWN_Pos    (2U)
N#define PWR_CR1_LPMS_SHUTDOWN_Msk    (0x1UL << PWR_CR1_LPMS_SHUTDOWN_Pos)      /*!< 0x00000004 */
N#define PWR_CR1_LPMS_SHUTDOWN        PWR_CR1_LPMS_SHUTDOWN_Msk                 /*!< Shut-down mode */
N
N
N/********************  Bit definition for PWR_CR2 register  ********************/
N/*!< PVME  Peripheral Voltage Monitor Enable */
N#define PWR_CR2_PVME_Pos             (6U)
N#define PWR_CR2_PVME_Msk             (0x3UL << PWR_CR2_PVME_Pos)               /*!< 0x000000C0 */
N#define PWR_CR2_PVME                 PWR_CR2_PVME_Msk                          /*!< PVM bits field */
N#define PWR_CR2_PVME4_Pos            (7U)
N#define PWR_CR2_PVME4_Msk            (0x1UL << PWR_CR2_PVME4_Pos)              /*!< 0x00000080 */
N#define PWR_CR2_PVME4                PWR_CR2_PVME4_Msk                         /*!< PVM 4 Enable */
N#define PWR_CR2_PVME3_Pos            (6U)
N#define PWR_CR2_PVME3_Msk            (0x1UL << PWR_CR2_PVME3_Pos)              /*!< 0x00000040 */
N#define PWR_CR2_PVME3                PWR_CR2_PVME3_Msk                         /*!< PVM 3 Enable */
N/*!< PVD level configuration */
N#define PWR_CR2_PLS_Pos              (1U)
N#define PWR_CR2_PLS_Msk              (0x7UL << PWR_CR2_PLS_Pos)                /*!< 0x0000000E */
N#define PWR_CR2_PLS                  PWR_CR2_PLS_Msk                           /*!< PVD level selection */
N#define PWR_CR2_PLS_LEV0             (0x00000000UL)                            /*!< PVD level 0 */
N#define PWR_CR2_PLS_LEV1_Pos         (1U)
N#define PWR_CR2_PLS_LEV1_Msk         (0x1UL << PWR_CR2_PLS_LEV1_Pos)           /*!< 0x00000002 */
N#define PWR_CR2_PLS_LEV1             PWR_CR2_PLS_LEV1_Msk                      /*!< PVD level 1 */
N#define PWR_CR2_PLS_LEV2_Pos         (2U)
N#define PWR_CR2_PLS_LEV2_Msk         (0x1UL << PWR_CR2_PLS_LEV2_Pos)           /*!< 0x00000004 */
N#define PWR_CR2_PLS_LEV2             PWR_CR2_PLS_LEV2_Msk                      /*!< PVD level 2 */
N#define PWR_CR2_PLS_LEV3_Pos         (1U)
N#define PWR_CR2_PLS_LEV3_Msk         (0x3UL << PWR_CR2_PLS_LEV3_Pos)           /*!< 0x00000006 */
N#define PWR_CR2_PLS_LEV3             PWR_CR2_PLS_LEV3_Msk                      /*!< PVD level 3 */
N#define PWR_CR2_PLS_LEV4_Pos         (3U)
N#define PWR_CR2_PLS_LEV4_Msk         (0x1UL << PWR_CR2_PLS_LEV4_Pos)           /*!< 0x00000008 */
N#define PWR_CR2_PLS_LEV4             PWR_CR2_PLS_LEV4_Msk                      /*!< PVD level 4 */
N#define PWR_CR2_PLS_LEV5_Pos         (1U)
N#define PWR_CR2_PLS_LEV5_Msk         (0x5UL << PWR_CR2_PLS_LEV5_Pos)           /*!< 0x0000000A */
N#define PWR_CR2_PLS_LEV5             PWR_CR2_PLS_LEV5_Msk                      /*!< PVD level 5 */
N#define PWR_CR2_PLS_LEV6_Pos         (2U)
N#define PWR_CR2_PLS_LEV6_Msk         (0x3UL << PWR_CR2_PLS_LEV6_Pos)           /*!< 0x0000000C */
N#define PWR_CR2_PLS_LEV6             PWR_CR2_PLS_LEV6_Msk                      /*!< PVD level 6 */
N#define PWR_CR2_PLS_LEV7_Pos         (1U)
N#define PWR_CR2_PLS_LEV7_Msk         (0x7UL << PWR_CR2_PLS_LEV7_Pos)           /*!< 0x0000000E */
N#define PWR_CR2_PLS_LEV7             PWR_CR2_PLS_LEV7_Msk                      /*!< PVD level 7 */
N#define PWR_CR2_PVDE_Pos             (0U)
N#define PWR_CR2_PVDE_Msk             (0x1UL << PWR_CR2_PVDE_Pos)               /*!< 0x00000001 */
N#define PWR_CR2_PVDE                 PWR_CR2_PVDE_Msk                          /*!< Power Voltage Detector Enable */
N
N/********************  Bit definition for PWR_CR3 register  ********************/
N#define PWR_CR3_EIWUL_Pos            (15U)
N#define PWR_CR3_EIWUL_Msk            (0x1UL << PWR_CR3_EIWUL_Pos)              /*!< 0x00008000 */
N#define PWR_CR3_EIWUL                PWR_CR3_EIWUL_Msk                         /*!< Enable Internal Wake-up line */
N#define PWR_CR3_APC_Pos              (10U)
N#define PWR_CR3_APC_Msk              (0x1UL << PWR_CR3_APC_Pos)                /*!< 0x00000400 */
N#define PWR_CR3_APC                  PWR_CR3_APC_Msk                           /*!< Apply pull-up and pull-down configuration */
N#define PWR_CR3_RRS_Pos              (8U)
N#define PWR_CR3_RRS_Msk              (0x1UL << PWR_CR3_RRS_Pos)                /*!< 0x00000100 */
N#define PWR_CR3_RRS                  PWR_CR3_RRS_Msk                           /*!< SRAM2 Retention in Stand-by mode */
N#define PWR_CR3_EWUP5_Pos            (4U)
N#define PWR_CR3_EWUP5_Msk            (0x1UL << PWR_CR3_EWUP5_Pos)              /*!< 0x00000010 */
N#define PWR_CR3_EWUP5                PWR_CR3_EWUP5_Msk                         /*!< Enable Wake-Up Pin 5 */
N#define PWR_CR3_EWUP4_Pos            (3U)
N#define PWR_CR3_EWUP4_Msk            (0x1UL << PWR_CR3_EWUP4_Pos)              /*!< 0x00000008 */
N#define PWR_CR3_EWUP4                PWR_CR3_EWUP4_Msk                         /*!< Enable Wake-Up Pin 4 */
N#define PWR_CR3_EWUP3_Pos            (2U)
N#define PWR_CR3_EWUP3_Msk            (0x1UL << PWR_CR3_EWUP3_Pos)              /*!< 0x00000004 */
N#define PWR_CR3_EWUP3                PWR_CR3_EWUP3_Msk                         /*!< Enable Wake-Up Pin 3 */
N#define PWR_CR3_EWUP2_Pos            (1U)
N#define PWR_CR3_EWUP2_Msk            (0x1UL << PWR_CR3_EWUP2_Pos)              /*!< 0x00000002 */
N#define PWR_CR3_EWUP2                PWR_CR3_EWUP2_Msk                         /*!< Enable Wake-Up Pin 2 */
N#define PWR_CR3_EWUP1_Pos            (0U)
N#define PWR_CR3_EWUP1_Msk            (0x1UL << PWR_CR3_EWUP1_Pos)              /*!< 0x00000001 */
N#define PWR_CR3_EWUP1                PWR_CR3_EWUP1_Msk                         /*!< Enable Wake-Up Pin 1 */
N#define PWR_CR3_EWUP_Pos             (0U)
N#define PWR_CR3_EWUP_Msk             (0x1FUL << PWR_CR3_EWUP_Pos)              /*!< 0x0000001F */
N#define PWR_CR3_EWUP                 PWR_CR3_EWUP_Msk                          /*!< Enable Wake-Up Pins  */
N
N/* Legacy defines */
N#define PWR_CR3_EIWF_Pos             PWR_CR3_EIWUL_Pos
N#define PWR_CR3_EIWF_Msk             PWR_CR3_EIWUL_Msk
N#define PWR_CR3_EIWF                 PWR_CR3_EIWUL
N
N
N/********************  Bit definition for PWR_CR4 register  ********************/
N#define PWR_CR4_VBRS_Pos             (9U)
N#define PWR_CR4_VBRS_Msk             (0x1UL << PWR_CR4_VBRS_Pos)               /*!< 0x00000200 */
N#define PWR_CR4_VBRS                 PWR_CR4_VBRS_Msk                          /*!< VBAT Battery charging Resistor Selection */
N#define PWR_CR4_VBE_Pos              (8U)
N#define PWR_CR4_VBE_Msk              (0x1UL << PWR_CR4_VBE_Pos)                /*!< 0x00000100 */
N#define PWR_CR4_VBE                  PWR_CR4_VBE_Msk                           /*!< VBAT Battery charging Enable  */
N#define PWR_CR4_WP5_Pos              (4U)
N#define PWR_CR4_WP5_Msk              (0x1UL << PWR_CR4_WP5_Pos)                /*!< 0x00000010 */
N#define PWR_CR4_WP5                  PWR_CR4_WP5_Msk                           /*!< Wake-Up Pin 5 polarity */
N#define PWR_CR4_WP4_Pos              (3U)
N#define PWR_CR4_WP4_Msk              (0x1UL << PWR_CR4_WP4_Pos)                /*!< 0x00000008 */
N#define PWR_CR4_WP4                  PWR_CR4_WP4_Msk                           /*!< Wake-Up Pin 4 polarity */
N#define PWR_CR4_WP3_Pos              (2U)
N#define PWR_CR4_WP3_Msk              (0x1UL << PWR_CR4_WP3_Pos)                /*!< 0x00000004 */
N#define PWR_CR4_WP3                  PWR_CR4_WP3_Msk                           /*!< Wake-Up Pin 3 polarity */
N#define PWR_CR4_WP2_Pos              (1U)
N#define PWR_CR4_WP2_Msk              (0x1UL << PWR_CR4_WP2_Pos)                /*!< 0x00000002 */
N#define PWR_CR4_WP2                  PWR_CR4_WP2_Msk                           /*!< Wake-Up Pin 2 polarity */
N#define PWR_CR4_WP1_Pos              (0U)
N#define PWR_CR4_WP1_Msk              (0x1UL << PWR_CR4_WP1_Pos)                /*!< 0x00000001 */
N#define PWR_CR4_WP1                  PWR_CR4_WP1_Msk                           /*!< Wake-Up Pin 1 polarity */
N
N/********************  Bit definition for PWR_SR1 register  ********************/
N#define PWR_SR1_WUFI_Pos             (15U)
N#define PWR_SR1_WUFI_Msk             (0x1UL << PWR_SR1_WUFI_Pos)               /*!< 0x00008000 */
N#define PWR_SR1_WUFI                 PWR_SR1_WUFI_Msk                          /*!< Wake-Up Flag Internal */
N#define PWR_SR1_SBF_Pos              (8U)
N#define PWR_SR1_SBF_Msk              (0x1UL << PWR_SR1_SBF_Pos)                /*!< 0x00000100 */
N#define PWR_SR1_SBF                  PWR_SR1_SBF_Msk                           /*!< Stand-By Flag */
N#define PWR_SR1_WUF_Pos              (0U)
N#define PWR_SR1_WUF_Msk              (0x1FUL << PWR_SR1_WUF_Pos)               /*!< 0x0000001F */
N#define PWR_SR1_WUF                  PWR_SR1_WUF_Msk                           /*!< Wake-up Flags */
N#define PWR_SR1_WUF5_Pos             (4U)
N#define PWR_SR1_WUF5_Msk             (0x1UL << PWR_SR1_WUF5_Pos)               /*!< 0x00000010 */
N#define PWR_SR1_WUF5                 PWR_SR1_WUF5_Msk                          /*!< Wake-up Flag 5 */
N#define PWR_SR1_WUF4_Pos             (3U)
N#define PWR_SR1_WUF4_Msk             (0x1UL << PWR_SR1_WUF4_Pos)               /*!< 0x00000008 */
N#define PWR_SR1_WUF4                 PWR_SR1_WUF4_Msk                          /*!< Wake-up Flag 4 */
N#define PWR_SR1_WUF3_Pos             (2U)
N#define PWR_SR1_WUF3_Msk             (0x1UL << PWR_SR1_WUF3_Pos)               /*!< 0x00000004 */
N#define PWR_SR1_WUF3                 PWR_SR1_WUF3_Msk                          /*!< Wake-up Flag 3 */
N#define PWR_SR1_WUF2_Pos             (1U)
N#define PWR_SR1_WUF2_Msk             (0x1UL << PWR_SR1_WUF2_Pos)               /*!< 0x00000002 */
N#define PWR_SR1_WUF2                 PWR_SR1_WUF2_Msk                          /*!< Wake-up Flag 2 */
N#define PWR_SR1_WUF1_Pos             (0U)
N#define PWR_SR1_WUF1_Msk             (0x1UL << PWR_SR1_WUF1_Pos)               /*!< 0x00000001 */
N#define PWR_SR1_WUF1                 PWR_SR1_WUF1_Msk                          /*!< Wake-up Flag 1 */
N
N/********************  Bit definition for PWR_SR2 register  ********************/
N#define PWR_SR2_PVMO4_Pos            (15U)
N#define PWR_SR2_PVMO4_Msk            (0x1UL << PWR_SR2_PVMO4_Pos)              /*!< 0x00008000 */
N#define PWR_SR2_PVMO4                PWR_SR2_PVMO4_Msk                         /*!< Peripheral Voltage Monitoring Output 4 */
N#define PWR_SR2_PVMO3_Pos            (14U)
N#define PWR_SR2_PVMO3_Msk            (0x1UL << PWR_SR2_PVMO3_Pos)              /*!< 0x00004000 */
N#define PWR_SR2_PVMO3                PWR_SR2_PVMO3_Msk                         /*!< Peripheral Voltage Monitoring Output 3 */
N#define PWR_SR2_PVDO_Pos             (11U)
N#define PWR_SR2_PVDO_Msk             (0x1UL << PWR_SR2_PVDO_Pos)               /*!< 0x00000800 */
N#define PWR_SR2_PVDO                 PWR_SR2_PVDO_Msk                          /*!< Power Voltage Detector Output */
N#define PWR_SR2_VOSF_Pos             (10U)
N#define PWR_SR2_VOSF_Msk             (0x1UL << PWR_SR2_VOSF_Pos)               /*!< 0x00000400 */
N#define PWR_SR2_VOSF                 PWR_SR2_VOSF_Msk                          /*!< Voltage Scaling Flag */
N#define PWR_SR2_REGLPF_Pos           (9U)
N#define PWR_SR2_REGLPF_Msk           (0x1UL << PWR_SR2_REGLPF_Pos)             /*!< 0x00000200 */
N#define PWR_SR2_REGLPF               PWR_SR2_REGLPF_Msk                        /*!< Low-power Regulator Flag */
N#define PWR_SR2_REGLPS_Pos           (8U)
N#define PWR_SR2_REGLPS_Msk           (0x1UL << PWR_SR2_REGLPS_Pos)             /*!< 0x00000100 */
N#define PWR_SR2_REGLPS               PWR_SR2_REGLPS_Msk                        /*!< Low-power Regulator Started */
N
N/********************  Bit definition for PWR_SCR register  ********************/
N#define PWR_SCR_CSBF_Pos             (8U)
N#define PWR_SCR_CSBF_Msk             (0x1UL << PWR_SCR_CSBF_Pos)               /*!< 0x00000100 */
N#define PWR_SCR_CSBF                 PWR_SCR_CSBF_Msk                          /*!< Clear Stand-By Flag */
N#define PWR_SCR_CWUF_Pos             (0U)
N#define PWR_SCR_CWUF_Msk             (0x1FUL << PWR_SCR_CWUF_Pos)              /*!< 0x0000001F */
N#define PWR_SCR_CWUF                 PWR_SCR_CWUF_Msk                          /*!< Clear Wake-up Flags  */
N#define PWR_SCR_CWUF5_Pos            (4U)
N#define PWR_SCR_CWUF5_Msk            (0x1UL << PWR_SCR_CWUF5_Pos)              /*!< 0x00000010 */
N#define PWR_SCR_CWUF5                PWR_SCR_CWUF5_Msk                         /*!< Clear Wake-up Flag 5 */
N#define PWR_SCR_CWUF4_Pos            (3U)
N#define PWR_SCR_CWUF4_Msk            (0x1UL << PWR_SCR_CWUF4_Pos)              /*!< 0x00000008 */
N#define PWR_SCR_CWUF4                PWR_SCR_CWUF4_Msk                         /*!< Clear Wake-up Flag 4 */
N#define PWR_SCR_CWUF3_Pos            (2U)
N#define PWR_SCR_CWUF3_Msk            (0x1UL << PWR_SCR_CWUF3_Pos)              /*!< 0x00000004 */
N#define PWR_SCR_CWUF3                PWR_SCR_CWUF3_Msk                         /*!< Clear Wake-up Flag 3 */
N#define PWR_SCR_CWUF2_Pos            (1U)
N#define PWR_SCR_CWUF2_Msk            (0x1UL << PWR_SCR_CWUF2_Pos)              /*!< 0x00000002 */
N#define PWR_SCR_CWUF2                PWR_SCR_CWUF2_Msk                         /*!< Clear Wake-up Flag 2 */
N#define PWR_SCR_CWUF1_Pos            (0U)
N#define PWR_SCR_CWUF1_Msk            (0x1UL << PWR_SCR_CWUF1_Pos)              /*!< 0x00000001 */
N#define PWR_SCR_CWUF1                PWR_SCR_CWUF1_Msk                         /*!< Clear Wake-up Flag 1 */
N
N/********************  Bit definition for PWR_PUCRA register  ********************/
N#define PWR_PUCRA_PA15_Pos           (15U)
N#define PWR_PUCRA_PA15_Msk           (0x1UL << PWR_PUCRA_PA15_Pos)             /*!< 0x00008000 */
N#define PWR_PUCRA_PA15               PWR_PUCRA_PA15_Msk                        /*!< Port PA15 Pull-Up set */
N#define PWR_PUCRA_PA13_Pos           (13U)
N#define PWR_PUCRA_PA13_Msk           (0x1UL << PWR_PUCRA_PA13_Pos)             /*!< 0x00002000 */
N#define PWR_PUCRA_PA13               PWR_PUCRA_PA13_Msk                        /*!< Port PA13 Pull-Up set */
N#define PWR_PUCRA_PA12_Pos           (12U)
N#define PWR_PUCRA_PA12_Msk           (0x1UL << PWR_PUCRA_PA12_Pos)             /*!< 0x00001000 */
N#define PWR_PUCRA_PA12               PWR_PUCRA_PA12_Msk                        /*!< Port PA12 Pull-Up set */
N#define PWR_PUCRA_PA11_Pos           (11U)
N#define PWR_PUCRA_PA11_Msk           (0x1UL << PWR_PUCRA_PA11_Pos)             /*!< 0x00000800 */
N#define PWR_PUCRA_PA11               PWR_PUCRA_PA11_Msk                        /*!< Port PA11 Pull-Up set */
N#define PWR_PUCRA_PA10_Pos           (10U)
N#define PWR_PUCRA_PA10_Msk           (0x1UL << PWR_PUCRA_PA10_Pos)             /*!< 0x00000400 */
N#define PWR_PUCRA_PA10               PWR_PUCRA_PA10_Msk                        /*!< Port PA10 Pull-Up set */
N#define PWR_PUCRA_PA9_Pos            (9U)
N#define PWR_PUCRA_PA9_Msk            (0x1UL << PWR_PUCRA_PA9_Pos)              /*!< 0x00000200 */
N#define PWR_PUCRA_PA9                PWR_PUCRA_PA9_Msk                         /*!< Port PA9 Pull-Up set  */
N#define PWR_PUCRA_PA8_Pos            (8U)
N#define PWR_PUCRA_PA8_Msk            (0x1UL << PWR_PUCRA_PA8_Pos)              /*!< 0x00000100 */
N#define PWR_PUCRA_PA8                PWR_PUCRA_PA8_Msk                         /*!< Port PA8 Pull-Up set  */
N#define PWR_PUCRA_PA7_Pos            (7U)
N#define PWR_PUCRA_PA7_Msk            (0x1UL << PWR_PUCRA_PA7_Pos)              /*!< 0x00000080 */
N#define PWR_PUCRA_PA7                PWR_PUCRA_PA7_Msk                         /*!< Port PA7 Pull-Up set  */
N#define PWR_PUCRA_PA6_Pos            (6U)
N#define PWR_PUCRA_PA6_Msk            (0x1UL << PWR_PUCRA_PA6_Pos)              /*!< 0x00000040 */
N#define PWR_PUCRA_PA6                PWR_PUCRA_PA6_Msk                         /*!< Port PA6 Pull-Up set  */
N#define PWR_PUCRA_PA5_Pos            (5U)
N#define PWR_PUCRA_PA5_Msk            (0x1UL << PWR_PUCRA_PA5_Pos)              /*!< 0x00000020 */
N#define PWR_PUCRA_PA5                PWR_PUCRA_PA5_Msk                         /*!< Port PA5 Pull-Up set  */
N#define PWR_PUCRA_PA4_Pos            (4U)
N#define PWR_PUCRA_PA4_Msk            (0x1UL << PWR_PUCRA_PA4_Pos)              /*!< 0x00000010 */
N#define PWR_PUCRA_PA4                PWR_PUCRA_PA4_Msk                         /*!< Port PA4 Pull-Up set  */
N#define PWR_PUCRA_PA3_Pos            (3U)
N#define PWR_PUCRA_PA3_Msk            (0x1UL << PWR_PUCRA_PA3_Pos)              /*!< 0x00000008 */
N#define PWR_PUCRA_PA3                PWR_PUCRA_PA3_Msk                         /*!< Port PA3 Pull-Up set  */
N#define PWR_PUCRA_PA2_Pos            (2U)
N#define PWR_PUCRA_PA2_Msk            (0x1UL << PWR_PUCRA_PA2_Pos)              /*!< 0x00000004 */
N#define PWR_PUCRA_PA2                PWR_PUCRA_PA2_Msk                         /*!< Port PA2 Pull-Up set  */
N#define PWR_PUCRA_PA1_Pos            (1U)
N#define PWR_PUCRA_PA1_Msk            (0x1UL << PWR_PUCRA_PA1_Pos)              /*!< 0x00000002 */
N#define PWR_PUCRA_PA1                PWR_PUCRA_PA1_Msk                         /*!< Port PA1 Pull-Up set  */
N#define PWR_PUCRA_PA0_Pos            (0U)
N#define PWR_PUCRA_PA0_Msk            (0x1UL << PWR_PUCRA_PA0_Pos)              /*!< 0x00000001 */
N#define PWR_PUCRA_PA0                PWR_PUCRA_PA0_Msk                         /*!< Port PA0 Pull-Up set  */
N
N/********************  Bit definition for PWR_PDCRA register  ********************/
N#define PWR_PDCRA_PA14_Pos           (14U)
N#define PWR_PDCRA_PA14_Msk           (0x1UL << PWR_PDCRA_PA14_Pos)             /*!< 0x00004000 */
N#define PWR_PDCRA_PA14               PWR_PDCRA_PA14_Msk                        /*!< Port PA14 Pull-Down set */
N#define PWR_PDCRA_PA12_Pos           (12U)
N#define PWR_PDCRA_PA12_Msk           (0x1UL << PWR_PDCRA_PA12_Pos)             /*!< 0x00001000 */
N#define PWR_PDCRA_PA12               PWR_PDCRA_PA12_Msk                        /*!< Port PA12 Pull-Down set */
N#define PWR_PDCRA_PA11_Pos           (11U)
N#define PWR_PDCRA_PA11_Msk           (0x1UL << PWR_PDCRA_PA11_Pos)             /*!< 0x00000800 */
N#define PWR_PDCRA_PA11               PWR_PDCRA_PA11_Msk                        /*!< Port PA11 Pull-Down set */
N#define PWR_PDCRA_PA10_Pos           (10U)
N#define PWR_PDCRA_PA10_Msk           (0x1UL << PWR_PDCRA_PA10_Pos)             /*!< 0x00000400 */
N#define PWR_PDCRA_PA10               PWR_PDCRA_PA10_Msk                        /*!< Port PA10 Pull-Down set */
N#define PWR_PDCRA_PA9_Pos            (9U)
N#define PWR_PDCRA_PA9_Msk            (0x1UL << PWR_PDCRA_PA9_Pos)              /*!< 0x00000200 */
N#define PWR_PDCRA_PA9                PWR_PDCRA_PA9_Msk                         /*!< Port PA9 Pull-Down set  */
N#define PWR_PDCRA_PA8_Pos            (8U)
N#define PWR_PDCRA_PA8_Msk            (0x1UL << PWR_PDCRA_PA8_Pos)              /*!< 0x00000100 */
N#define PWR_PDCRA_PA8                PWR_PDCRA_PA8_Msk                         /*!< Port PA8 Pull-Down set  */
N#define PWR_PDCRA_PA7_Pos            (7U)
N#define PWR_PDCRA_PA7_Msk            (0x1UL << PWR_PDCRA_PA7_Pos)              /*!< 0x00000080 */
N#define PWR_PDCRA_PA7                PWR_PDCRA_PA7_Msk                         /*!< Port PA7 Pull-Down set  */
N#define PWR_PDCRA_PA6_Pos            (6U)
N#define PWR_PDCRA_PA6_Msk            (0x1UL << PWR_PDCRA_PA6_Pos)              /*!< 0x00000040 */
N#define PWR_PDCRA_PA6                PWR_PDCRA_PA6_Msk                         /*!< Port PA6 Pull-Down set  */
N#define PWR_PDCRA_PA5_Pos            (5U)
N#define PWR_PDCRA_PA5_Msk            (0x1UL << PWR_PDCRA_PA5_Pos)              /*!< 0x00000020 */
N#define PWR_PDCRA_PA5                PWR_PDCRA_PA5_Msk                         /*!< Port PA5 Pull-Down set  */
N#define PWR_PDCRA_PA4_Pos            (4U)
N#define PWR_PDCRA_PA4_Msk            (0x1UL << PWR_PDCRA_PA4_Pos)              /*!< 0x00000010 */
N#define PWR_PDCRA_PA4                PWR_PDCRA_PA4_Msk                         /*!< Port PA4 Pull-Down set  */
N#define PWR_PDCRA_PA3_Pos            (3U)
N#define PWR_PDCRA_PA3_Msk            (0x1UL << PWR_PDCRA_PA3_Pos)              /*!< 0x00000008 */
N#define PWR_PDCRA_PA3                PWR_PDCRA_PA3_Msk                         /*!< Port PA3 Pull-Down set  */
N#define PWR_PDCRA_PA2_Pos            (2U)
N#define PWR_PDCRA_PA2_Msk            (0x1UL << PWR_PDCRA_PA2_Pos)              /*!< 0x00000004 */
N#define PWR_PDCRA_PA2                PWR_PDCRA_PA2_Msk                         /*!< Port PA2 Pull-Down set  */
N#define PWR_PDCRA_PA1_Pos            (1U)
N#define PWR_PDCRA_PA1_Msk            (0x1UL << PWR_PDCRA_PA1_Pos)              /*!< 0x00000002 */
N#define PWR_PDCRA_PA1                PWR_PDCRA_PA1_Msk                         /*!< Port PA1 Pull-Down set  */
N#define PWR_PDCRA_PA0_Pos            (0U)
N#define PWR_PDCRA_PA0_Msk            (0x1UL << PWR_PDCRA_PA0_Pos)              /*!< 0x00000001 */
N#define PWR_PDCRA_PA0                PWR_PDCRA_PA0_Msk                         /*!< Port PA0 Pull-Down set  */
N
N/********************  Bit definition for PWR_PUCRB register  ********************/
N#define PWR_PUCRB_PB15_Pos           (15U)
N#define PWR_PUCRB_PB15_Msk           (0x1UL << PWR_PUCRB_PB15_Pos)             /*!< 0x00008000 */
N#define PWR_PUCRB_PB15               PWR_PUCRB_PB15_Msk                        /*!< Port PB15 Pull-Up set */
N#define PWR_PUCRB_PB14_Pos           (14U)
N#define PWR_PUCRB_PB14_Msk           (0x1UL << PWR_PUCRB_PB14_Pos)             /*!< 0x00004000 */
N#define PWR_PUCRB_PB14               PWR_PUCRB_PB14_Msk                        /*!< Port PB14 Pull-Up set */
N#define PWR_PUCRB_PB13_Pos           (13U)
N#define PWR_PUCRB_PB13_Msk           (0x1UL << PWR_PUCRB_PB13_Pos)             /*!< 0x00002000 */
N#define PWR_PUCRB_PB13               PWR_PUCRB_PB13_Msk                        /*!< Port PB13 Pull-Up set */
N#define PWR_PUCRB_PB12_Pos           (12U)
N#define PWR_PUCRB_PB12_Msk           (0x1UL << PWR_PUCRB_PB12_Pos)             /*!< 0x00001000 */
N#define PWR_PUCRB_PB12               PWR_PUCRB_PB12_Msk                        /*!< Port PB12 Pull-Up set */
N#define PWR_PUCRB_PB11_Pos           (11U)
N#define PWR_PUCRB_PB11_Msk           (0x1UL << PWR_PUCRB_PB11_Pos)             /*!< 0x00000800 */
N#define PWR_PUCRB_PB11               PWR_PUCRB_PB11_Msk                        /*!< Port PB11 Pull-Up set */
N#define PWR_PUCRB_PB10_Pos           (10U)
N#define PWR_PUCRB_PB10_Msk           (0x1UL << PWR_PUCRB_PB10_Pos)             /*!< 0x00000400 */
N#define PWR_PUCRB_PB10               PWR_PUCRB_PB10_Msk                        /*!< Port PB10 Pull-Up set */
N#define PWR_PUCRB_PB9_Pos            (9U)
N#define PWR_PUCRB_PB9_Msk            (0x1UL << PWR_PUCRB_PB9_Pos)              /*!< 0x00000200 */
N#define PWR_PUCRB_PB9                PWR_PUCRB_PB9_Msk                         /*!< Port PB9 Pull-Up set  */
N#define PWR_PUCRB_PB8_Pos            (8U)
N#define PWR_PUCRB_PB8_Msk            (0x1UL << PWR_PUCRB_PB8_Pos)              /*!< 0x00000100 */
N#define PWR_PUCRB_PB8                PWR_PUCRB_PB8_Msk                         /*!< Port PB8 Pull-Up set  */
N#define PWR_PUCRB_PB7_Pos            (7U)
N#define PWR_PUCRB_PB7_Msk            (0x1UL << PWR_PUCRB_PB7_Pos)              /*!< 0x00000080 */
N#define PWR_PUCRB_PB7                PWR_PUCRB_PB7_Msk                         /*!< Port PB7 Pull-Up set  */
N#define PWR_PUCRB_PB6_Pos            (6U)
N#define PWR_PUCRB_PB6_Msk            (0x1UL << PWR_PUCRB_PB6_Pos)              /*!< 0x00000040 */
N#define PWR_PUCRB_PB6                PWR_PUCRB_PB6_Msk                         /*!< Port PB6 Pull-Up set  */
N#define PWR_PUCRB_PB5_Pos            (5U)
N#define PWR_PUCRB_PB5_Msk            (0x1UL << PWR_PUCRB_PB5_Pos)              /*!< 0x00000020 */
N#define PWR_PUCRB_PB5                PWR_PUCRB_PB5_Msk                         /*!< Port PB5 Pull-Up set  */
N#define PWR_PUCRB_PB4_Pos            (4U)
N#define PWR_PUCRB_PB4_Msk            (0x1UL << PWR_PUCRB_PB4_Pos)              /*!< 0x00000010 */
N#define PWR_PUCRB_PB4                PWR_PUCRB_PB4_Msk                         /*!< Port PB4 Pull-Up set  */
N#define PWR_PUCRB_PB3_Pos            (3U)
N#define PWR_PUCRB_PB3_Msk            (0x1UL << PWR_PUCRB_PB3_Pos)              /*!< 0x00000008 */
N#define PWR_PUCRB_PB3                PWR_PUCRB_PB3_Msk                         /*!< Port PB3 Pull-Up set  */
N#define PWR_PUCRB_PB2_Pos            (2U)
N#define PWR_PUCRB_PB2_Msk            (0x1UL << PWR_PUCRB_PB2_Pos)              /*!< 0x00000004 */
N#define PWR_PUCRB_PB2                PWR_PUCRB_PB2_Msk                         /*!< Port PB2 Pull-Up set  */
N#define PWR_PUCRB_PB1_Pos            (1U)
N#define PWR_PUCRB_PB1_Msk            (0x1UL << PWR_PUCRB_PB1_Pos)              /*!< 0x00000002 */
N#define PWR_PUCRB_PB1                PWR_PUCRB_PB1_Msk                         /*!< Port PB1 Pull-Up set  */
N#define PWR_PUCRB_PB0_Pos            (0U)
N#define PWR_PUCRB_PB0_Msk            (0x1UL << PWR_PUCRB_PB0_Pos)              /*!< 0x00000001 */
N#define PWR_PUCRB_PB0                PWR_PUCRB_PB0_Msk                         /*!< Port PB0 Pull-Up set  */
N
N/********************  Bit definition for PWR_PDCRB register  ********************/
N#define PWR_PDCRB_PB15_Pos           (15U)
N#define PWR_PDCRB_PB15_Msk           (0x1UL << PWR_PDCRB_PB15_Pos)             /*!< 0x00008000 */
N#define PWR_PDCRB_PB15               PWR_PDCRB_PB15_Msk                        /*!< Port PB15 Pull-Down set */
N#define PWR_PDCRB_PB14_Pos           (14U)
N#define PWR_PDCRB_PB14_Msk           (0x1UL << PWR_PDCRB_PB14_Pos)             /*!< 0x00004000 */
N#define PWR_PDCRB_PB14               PWR_PDCRB_PB14_Msk                        /*!< Port PB14 Pull-Down set */
N#define PWR_PDCRB_PB13_Pos           (13U)
N#define PWR_PDCRB_PB13_Msk           (0x1UL << PWR_PDCRB_PB13_Pos)             /*!< 0x00002000 */
N#define PWR_PDCRB_PB13               PWR_PDCRB_PB13_Msk                        /*!< Port PB13 Pull-Down set */
N#define PWR_PDCRB_PB12_Pos           (12U)
N#define PWR_PDCRB_PB12_Msk           (0x1UL << PWR_PDCRB_PB12_Pos)             /*!< 0x00001000 */
N#define PWR_PDCRB_PB12               PWR_PDCRB_PB12_Msk                        /*!< Port PB12 Pull-Down set */
N#define PWR_PDCRB_PB11_Pos           (11U)
N#define PWR_PDCRB_PB11_Msk           (0x1UL << PWR_PDCRB_PB11_Pos)             /*!< 0x00000800 */
N#define PWR_PDCRB_PB11               PWR_PDCRB_PB11_Msk                        /*!< Port PB11 Pull-Down set */
N#define PWR_PDCRB_PB10_Pos           (10U)
N#define PWR_PDCRB_PB10_Msk           (0x1UL << PWR_PDCRB_PB10_Pos)             /*!< 0x00000400 */
N#define PWR_PDCRB_PB10               PWR_PDCRB_PB10_Msk                        /*!< Port PB10 Pull-Down set */
N#define PWR_PDCRB_PB9_Pos            (9U)
N#define PWR_PDCRB_PB9_Msk            (0x1UL << PWR_PDCRB_PB9_Pos)              /*!< 0x00000200 */
N#define PWR_PDCRB_PB9                PWR_PDCRB_PB9_Msk                         /*!< Port PB9 Pull-Down set  */
N#define PWR_PDCRB_PB8_Pos            (8U)
N#define PWR_PDCRB_PB8_Msk            (0x1UL << PWR_PDCRB_PB8_Pos)              /*!< 0x00000100 */
N#define PWR_PDCRB_PB8                PWR_PDCRB_PB8_Msk                         /*!< Port PB8 Pull-Down set  */
N#define PWR_PDCRB_PB7_Pos            (7U)
N#define PWR_PDCRB_PB7_Msk            (0x1UL << PWR_PDCRB_PB7_Pos)              /*!< 0x00000080 */
N#define PWR_PDCRB_PB7                PWR_PDCRB_PB7_Msk                         /*!< Port PB7 Pull-Down set  */
N#define PWR_PDCRB_PB6_Pos            (6U)
N#define PWR_PDCRB_PB6_Msk            (0x1UL << PWR_PDCRB_PB6_Pos)              /*!< 0x00000040 */
N#define PWR_PDCRB_PB6                PWR_PDCRB_PB6_Msk                         /*!< Port PB6 Pull-Down set  */
N#define PWR_PDCRB_PB5_Pos            (5U)
N#define PWR_PDCRB_PB5_Msk            (0x1UL << PWR_PDCRB_PB5_Pos)              /*!< 0x00000020 */
N#define PWR_PDCRB_PB5                PWR_PDCRB_PB5_Msk                         /*!< Port PB5 Pull-Down set  */
N#define PWR_PDCRB_PB3_Pos            (3U)
N#define PWR_PDCRB_PB3_Msk            (0x1UL << PWR_PDCRB_PB3_Pos)              /*!< 0x00000008 */
N#define PWR_PDCRB_PB3                PWR_PDCRB_PB3_Msk                         /*!< Port PB3 Pull-Down set  */
N#define PWR_PDCRB_PB2_Pos            (2U)
N#define PWR_PDCRB_PB2_Msk            (0x1UL << PWR_PDCRB_PB2_Pos)              /*!< 0x00000004 */
N#define PWR_PDCRB_PB2                PWR_PDCRB_PB2_Msk                         /*!< Port PB2 Pull-Down set  */
N#define PWR_PDCRB_PB1_Pos            (1U)
N#define PWR_PDCRB_PB1_Msk            (0x1UL << PWR_PDCRB_PB1_Pos)              /*!< 0x00000002 */
N#define PWR_PDCRB_PB1                PWR_PDCRB_PB1_Msk                         /*!< Port PB1 Pull-Down set  */
N#define PWR_PDCRB_PB0_Pos            (0U)
N#define PWR_PDCRB_PB0_Msk            (0x1UL << PWR_PDCRB_PB0_Pos)              /*!< 0x00000001 */
N#define PWR_PDCRB_PB0                PWR_PDCRB_PB0_Msk                         /*!< Port PB0 Pull-Down set  */
N
N/********************  Bit definition for PWR_PUCRC register  ********************/
N#define PWR_PUCRC_PC15_Pos           (15U)
N#define PWR_PUCRC_PC15_Msk           (0x1UL << PWR_PUCRC_PC15_Pos)             /*!< 0x00008000 */
N#define PWR_PUCRC_PC15               PWR_PUCRC_PC15_Msk                        /*!< Port PC15 Pull-Up set */
N#define PWR_PUCRC_PC14_Pos           (14U)
N#define PWR_PUCRC_PC14_Msk           (0x1UL << PWR_PUCRC_PC14_Pos)             /*!< 0x00004000 */
N#define PWR_PUCRC_PC14               PWR_PUCRC_PC14_Msk                        /*!< Port PC14 Pull-Up set */
N#define PWR_PUCRC_PC13_Pos           (13U)
N#define PWR_PUCRC_PC13_Msk           (0x1UL << PWR_PUCRC_PC13_Pos)             /*!< 0x00002000 */
N#define PWR_PUCRC_PC13               PWR_PUCRC_PC13_Msk                        /*!< Port PC13 Pull-Up set */
N#define PWR_PUCRC_PC12_Pos           (12U)
N#define PWR_PUCRC_PC12_Msk           (0x1UL << PWR_PUCRC_PC12_Pos)             /*!< 0x00001000 */
N#define PWR_PUCRC_PC12               PWR_PUCRC_PC12_Msk                        /*!< Port PC12 Pull-Up set */
N#define PWR_PUCRC_PC11_Pos           (11U)
N#define PWR_PUCRC_PC11_Msk           (0x1UL << PWR_PUCRC_PC11_Pos)             /*!< 0x00000800 */
N#define PWR_PUCRC_PC11               PWR_PUCRC_PC11_Msk                        /*!< Port PC11 Pull-Up set */
N#define PWR_PUCRC_PC10_Pos           (10U)
N#define PWR_PUCRC_PC10_Msk           (0x1UL << PWR_PUCRC_PC10_Pos)             /*!< 0x00000400 */
N#define PWR_PUCRC_PC10               PWR_PUCRC_PC10_Msk                        /*!< Port PC10 Pull-Up set */
N#define PWR_PUCRC_PC9_Pos            (9U)
N#define PWR_PUCRC_PC9_Msk            (0x1UL << PWR_PUCRC_PC9_Pos)              /*!< 0x00000200 */
N#define PWR_PUCRC_PC9                PWR_PUCRC_PC9_Msk                         /*!< Port PC9 Pull-Up set  */
N#define PWR_PUCRC_PC8_Pos            (8U)
N#define PWR_PUCRC_PC8_Msk            (0x1UL << PWR_PUCRC_PC8_Pos)              /*!< 0x00000100 */
N#define PWR_PUCRC_PC8                PWR_PUCRC_PC8_Msk                         /*!< Port PC8 Pull-Up set  */
N#define PWR_PUCRC_PC7_Pos            (7U)
N#define PWR_PUCRC_PC7_Msk            (0x1UL << PWR_PUCRC_PC7_Pos)              /*!< 0x00000080 */
N#define PWR_PUCRC_PC7                PWR_PUCRC_PC7_Msk                         /*!< Port PC7 Pull-Up set  */
N#define PWR_PUCRC_PC6_Pos            (6U)
N#define PWR_PUCRC_PC6_Msk            (0x1UL << PWR_PUCRC_PC6_Pos)              /*!< 0x00000040 */
N#define PWR_PUCRC_PC6                PWR_PUCRC_PC6_Msk                         /*!< Port PC6 Pull-Up set  */
N#define PWR_PUCRC_PC5_Pos            (5U)
N#define PWR_PUCRC_PC5_Msk            (0x1UL << PWR_PUCRC_PC5_Pos)              /*!< 0x00000020 */
N#define PWR_PUCRC_PC5                PWR_PUCRC_PC5_Msk                         /*!< Port PC5 Pull-Up set  */
N#define PWR_PUCRC_PC4_Pos            (4U)
N#define PWR_PUCRC_PC4_Msk            (0x1UL << PWR_PUCRC_PC4_Pos)              /*!< 0x00000010 */
N#define PWR_PUCRC_PC4                PWR_PUCRC_PC4_Msk                         /*!< Port PC4 Pull-Up set  */
N#define PWR_PUCRC_PC3_Pos            (3U)
N#define PWR_PUCRC_PC3_Msk            (0x1UL << PWR_PUCRC_PC3_Pos)              /*!< 0x00000008 */
N#define PWR_PUCRC_PC3                PWR_PUCRC_PC3_Msk                         /*!< Port PC3 Pull-Up set  */
N#define PWR_PUCRC_PC2_Pos            (2U)
N#define PWR_PUCRC_PC2_Msk            (0x1UL << PWR_PUCRC_PC2_Pos)              /*!< 0x00000004 */
N#define PWR_PUCRC_PC2                PWR_PUCRC_PC2_Msk                         /*!< Port PC2 Pull-Up set  */
N#define PWR_PUCRC_PC1_Pos            (1U)
N#define PWR_PUCRC_PC1_Msk            (0x1UL << PWR_PUCRC_PC1_Pos)              /*!< 0x00000002 */
N#define PWR_PUCRC_PC1                PWR_PUCRC_PC1_Msk                         /*!< Port PC1 Pull-Up set  */
N#define PWR_PUCRC_PC0_Pos            (0U)
N#define PWR_PUCRC_PC0_Msk            (0x1UL << PWR_PUCRC_PC0_Pos)              /*!< 0x00000001 */
N#define PWR_PUCRC_PC0                PWR_PUCRC_PC0_Msk                         /*!< Port PC0 Pull-Up set  */
N
N/********************  Bit definition for PWR_PDCRC register  ********************/
N#define PWR_PDCRC_PC15_Pos           (15U)
N#define PWR_PDCRC_PC15_Msk           (0x1UL << PWR_PDCRC_PC15_Pos)             /*!< 0x00008000 */
N#define PWR_PDCRC_PC15               PWR_PDCRC_PC15_Msk                        /*!< Port PC15 Pull-Down set */
N#define PWR_PDCRC_PC14_Pos           (14U)
N#define PWR_PDCRC_PC14_Msk           (0x1UL << PWR_PDCRC_PC14_Pos)             /*!< 0x00004000 */
N#define PWR_PDCRC_PC14               PWR_PDCRC_PC14_Msk                        /*!< Port PC14 Pull-Down set */
N#define PWR_PDCRC_PC13_Pos           (13U)
N#define PWR_PDCRC_PC13_Msk           (0x1UL << PWR_PDCRC_PC13_Pos)             /*!< 0x00002000 */
N#define PWR_PDCRC_PC13               PWR_PDCRC_PC13_Msk                        /*!< Port PC13 Pull-Down set */
N#define PWR_PDCRC_PC12_Pos           (12U)
N#define PWR_PDCRC_PC12_Msk           (0x1UL << PWR_PDCRC_PC12_Pos)             /*!< 0x00001000 */
N#define PWR_PDCRC_PC12               PWR_PDCRC_PC12_Msk                        /*!< Port PC12 Pull-Down set */
N#define PWR_PDCRC_PC11_Pos           (11U)
N#define PWR_PDCRC_PC11_Msk           (0x1UL << PWR_PDCRC_PC11_Pos)             /*!< 0x00000800 */
N#define PWR_PDCRC_PC11               PWR_PDCRC_PC11_Msk                        /*!< Port PC11 Pull-Down set */
N#define PWR_PDCRC_PC10_Pos           (10U)
N#define PWR_PDCRC_PC10_Msk           (0x1UL << PWR_PDCRC_PC10_Pos)             /*!< 0x00000400 */
N#define PWR_PDCRC_PC10               PWR_PDCRC_PC10_Msk                        /*!< Port PC10 Pull-Down set */
N#define PWR_PDCRC_PC9_Pos            (9U)
N#define PWR_PDCRC_PC9_Msk            (0x1UL << PWR_PDCRC_PC9_Pos)              /*!< 0x00000200 */
N#define PWR_PDCRC_PC9                PWR_PDCRC_PC9_Msk                         /*!< Port PC9 Pull-Down set  */
N#define PWR_PDCRC_PC8_Pos            (8U)
N#define PWR_PDCRC_PC8_Msk            (0x1UL << PWR_PDCRC_PC8_Pos)              /*!< 0x00000100 */
N#define PWR_PDCRC_PC8                PWR_PDCRC_PC8_Msk                         /*!< Port PC8 Pull-Down set  */
N#define PWR_PDCRC_PC7_Pos            (7U)
N#define PWR_PDCRC_PC7_Msk            (0x1UL << PWR_PDCRC_PC7_Pos)              /*!< 0x00000080 */
N#define PWR_PDCRC_PC7                PWR_PDCRC_PC7_Msk                         /*!< Port PC7 Pull-Down set  */
N#define PWR_PDCRC_PC6_Pos            (6U)
N#define PWR_PDCRC_PC6_Msk            (0x1UL << PWR_PDCRC_PC6_Pos)              /*!< 0x00000040 */
N#define PWR_PDCRC_PC6                PWR_PDCRC_PC6_Msk                         /*!< Port PC6 Pull-Down set  */
N#define PWR_PDCRC_PC5_Pos            (5U)
N#define PWR_PDCRC_PC5_Msk            (0x1UL << PWR_PDCRC_PC5_Pos)              /*!< 0x00000020 */
N#define PWR_PDCRC_PC5                PWR_PDCRC_PC5_Msk                         /*!< Port PC5 Pull-Down set  */
N#define PWR_PDCRC_PC4_Pos            (4U)
N#define PWR_PDCRC_PC4_Msk            (0x1UL << PWR_PDCRC_PC4_Pos)              /*!< 0x00000010 */
N#define PWR_PDCRC_PC4                PWR_PDCRC_PC4_Msk                         /*!< Port PC4 Pull-Down set  */
N#define PWR_PDCRC_PC3_Pos            (3U)
N#define PWR_PDCRC_PC3_Msk            (0x1UL << PWR_PDCRC_PC3_Pos)              /*!< 0x00000008 */
N#define PWR_PDCRC_PC3                PWR_PDCRC_PC3_Msk                         /*!< Port PC3 Pull-Down set  */
N#define PWR_PDCRC_PC2_Pos            (2U)
N#define PWR_PDCRC_PC2_Msk            (0x1UL << PWR_PDCRC_PC2_Pos)              /*!< 0x00000004 */
N#define PWR_PDCRC_PC2                PWR_PDCRC_PC2_Msk                         /*!< Port PC2 Pull-Down set  */
N#define PWR_PDCRC_PC1_Pos            (1U)
N#define PWR_PDCRC_PC1_Msk            (0x1UL << PWR_PDCRC_PC1_Pos)              /*!< 0x00000002 */
N#define PWR_PDCRC_PC1                PWR_PDCRC_PC1_Msk                         /*!< Port PC1 Pull-Down set  */
N#define PWR_PDCRC_PC0_Pos            (0U)
N#define PWR_PDCRC_PC0_Msk            (0x1UL << PWR_PDCRC_PC0_Pos)              /*!< 0x00000001 */
N#define PWR_PDCRC_PC0                PWR_PDCRC_PC0_Msk                         /*!< Port PC0 Pull-Down set  */
N
N/********************  Bit definition for PWR_PUCRD register  ********************/
N#define PWR_PUCRD_PD15_Pos           (15U)
N#define PWR_PUCRD_PD15_Msk           (0x1UL << PWR_PUCRD_PD15_Pos)             /*!< 0x00008000 */
N#define PWR_PUCRD_PD15               PWR_PUCRD_PD15_Msk                        /*!< Port PD15 Pull-Up set */
N#define PWR_PUCRD_PD14_Pos           (14U)
N#define PWR_PUCRD_PD14_Msk           (0x1UL << PWR_PUCRD_PD14_Pos)             /*!< 0x00004000 */
N#define PWR_PUCRD_PD14               PWR_PUCRD_PD14_Msk                        /*!< Port PD14 Pull-Up set */
N#define PWR_PUCRD_PD13_Pos           (13U)
N#define PWR_PUCRD_PD13_Msk           (0x1UL << PWR_PUCRD_PD13_Pos)             /*!< 0x00002000 */
N#define PWR_PUCRD_PD13               PWR_PUCRD_PD13_Msk                        /*!< Port PD13 Pull-Up set */
N#define PWR_PUCRD_PD12_Pos           (12U)
N#define PWR_PUCRD_PD12_Msk           (0x1UL << PWR_PUCRD_PD12_Pos)             /*!< 0x00001000 */
N#define PWR_PUCRD_PD12               PWR_PUCRD_PD12_Msk                        /*!< Port PD12 Pull-Up set */
N#define PWR_PUCRD_PD11_Pos           (11U)
N#define PWR_PUCRD_PD11_Msk           (0x1UL << PWR_PUCRD_PD11_Pos)             /*!< 0x00000800 */
N#define PWR_PUCRD_PD11               PWR_PUCRD_PD11_Msk                        /*!< Port PD11 Pull-Up set */
N#define PWR_PUCRD_PD10_Pos           (10U)
N#define PWR_PUCRD_PD10_Msk           (0x1UL << PWR_PUCRD_PD10_Pos)             /*!< 0x00000400 */
N#define PWR_PUCRD_PD10               PWR_PUCRD_PD10_Msk                        /*!< Port PD10 Pull-Up set */
N#define PWR_PUCRD_PD9_Pos            (9U)
N#define PWR_PUCRD_PD9_Msk            (0x1UL << PWR_PUCRD_PD9_Pos)              /*!< 0x00000200 */
N#define PWR_PUCRD_PD9                PWR_PUCRD_PD9_Msk                         /*!< Port PD9 Pull-Up set  */
N#define PWR_PUCRD_PD8_Pos            (8U)
N#define PWR_PUCRD_PD8_Msk            (0x1UL << PWR_PUCRD_PD8_Pos)              /*!< 0x00000100 */
N#define PWR_PUCRD_PD8                PWR_PUCRD_PD8_Msk                         /*!< Port PD8 Pull-Up set  */
N#define PWR_PUCRD_PD7_Pos            (7U)
N#define PWR_PUCRD_PD7_Msk            (0x1UL << PWR_PUCRD_PD7_Pos)              /*!< 0x00000080 */
N#define PWR_PUCRD_PD7                PWR_PUCRD_PD7_Msk                         /*!< Port PD7 Pull-Up set  */
N#define PWR_PUCRD_PD6_Pos            (6U)
N#define PWR_PUCRD_PD6_Msk            (0x1UL << PWR_PUCRD_PD6_Pos)              /*!< 0x00000040 */
N#define PWR_PUCRD_PD6                PWR_PUCRD_PD6_Msk                         /*!< Port PD6 Pull-Up set  */
N#define PWR_PUCRD_PD5_Pos            (5U)
N#define PWR_PUCRD_PD5_Msk            (0x1UL << PWR_PUCRD_PD5_Pos)              /*!< 0x00000020 */
N#define PWR_PUCRD_PD5                PWR_PUCRD_PD5_Msk                         /*!< Port PD5 Pull-Up set  */
N#define PWR_PUCRD_PD4_Pos            (4U)
N#define PWR_PUCRD_PD4_Msk            (0x1UL << PWR_PUCRD_PD4_Pos)              /*!< 0x00000010 */
N#define PWR_PUCRD_PD4                PWR_PUCRD_PD4_Msk                         /*!< Port PD4 Pull-Up set  */
N#define PWR_PUCRD_PD3_Pos            (3U)
N#define PWR_PUCRD_PD3_Msk            (0x1UL << PWR_PUCRD_PD3_Pos)              /*!< 0x00000008 */
N#define PWR_PUCRD_PD3                PWR_PUCRD_PD3_Msk                         /*!< Port PD3 Pull-Up set  */
N#define PWR_PUCRD_PD2_Pos            (2U)
N#define PWR_PUCRD_PD2_Msk            (0x1UL << PWR_PUCRD_PD2_Pos)              /*!< 0x00000004 */
N#define PWR_PUCRD_PD2                PWR_PUCRD_PD2_Msk                         /*!< Port PD2 Pull-Up set  */
N#define PWR_PUCRD_PD1_Pos            (1U)
N#define PWR_PUCRD_PD1_Msk            (0x1UL << PWR_PUCRD_PD1_Pos)              /*!< 0x00000002 */
N#define PWR_PUCRD_PD1                PWR_PUCRD_PD1_Msk                         /*!< Port PD1 Pull-Up set  */
N#define PWR_PUCRD_PD0_Pos            (0U)
N#define PWR_PUCRD_PD0_Msk            (0x1UL << PWR_PUCRD_PD0_Pos)              /*!< 0x00000001 */
N#define PWR_PUCRD_PD0                PWR_PUCRD_PD0_Msk                         /*!< Port PD0 Pull-Up set  */
N
N/********************  Bit definition for PWR_PDCRD register  ********************/
N#define PWR_PDCRD_PD15_Pos           (15U)
N#define PWR_PDCRD_PD15_Msk           (0x1UL << PWR_PDCRD_PD15_Pos)             /*!< 0x00008000 */
N#define PWR_PDCRD_PD15               PWR_PDCRD_PD15_Msk                        /*!< Port PD15 Pull-Down set */
N#define PWR_PDCRD_PD14_Pos           (14U)
N#define PWR_PDCRD_PD14_Msk           (0x1UL << PWR_PDCRD_PD14_Pos)             /*!< 0x00004000 */
N#define PWR_PDCRD_PD14               PWR_PDCRD_PD14_Msk                        /*!< Port PD14 Pull-Down set */
N#define PWR_PDCRD_PD13_Pos           (13U)
N#define PWR_PDCRD_PD13_Msk           (0x1UL << PWR_PDCRD_PD13_Pos)             /*!< 0x00002000 */
N#define PWR_PDCRD_PD13               PWR_PDCRD_PD13_Msk                        /*!< Port PD13 Pull-Down set */
N#define PWR_PDCRD_PD12_Pos           (12U)
N#define PWR_PDCRD_PD12_Msk           (0x1UL << PWR_PDCRD_PD12_Pos)             /*!< 0x00001000 */
N#define PWR_PDCRD_PD12               PWR_PDCRD_PD12_Msk                        /*!< Port PD12 Pull-Down set */
N#define PWR_PDCRD_PD11_Pos           (11U)
N#define PWR_PDCRD_PD11_Msk           (0x1UL << PWR_PDCRD_PD11_Pos)             /*!< 0x00000800 */
N#define PWR_PDCRD_PD11               PWR_PDCRD_PD11_Msk                        /*!< Port PD11 Pull-Down set */
N#define PWR_PDCRD_PD10_Pos           (10U)
N#define PWR_PDCRD_PD10_Msk           (0x1UL << PWR_PDCRD_PD10_Pos)             /*!< 0x00000400 */
N#define PWR_PDCRD_PD10               PWR_PDCRD_PD10_Msk                        /*!< Port PD10 Pull-Down set */
N#define PWR_PDCRD_PD9_Pos            (9U)
N#define PWR_PDCRD_PD9_Msk            (0x1UL << PWR_PDCRD_PD9_Pos)              /*!< 0x00000200 */
N#define PWR_PDCRD_PD9                PWR_PDCRD_PD9_Msk                         /*!< Port PD9 Pull-Down set  */
N#define PWR_PDCRD_PD8_Pos            (8U)
N#define PWR_PDCRD_PD8_Msk            (0x1UL << PWR_PDCRD_PD8_Pos)              /*!< 0x00000100 */
N#define PWR_PDCRD_PD8                PWR_PDCRD_PD8_Msk                         /*!< Port PD8 Pull-Down set  */
N#define PWR_PDCRD_PD7_Pos            (7U)
N#define PWR_PDCRD_PD7_Msk            (0x1UL << PWR_PDCRD_PD7_Pos)              /*!< 0x00000080 */
N#define PWR_PDCRD_PD7                PWR_PDCRD_PD7_Msk                         /*!< Port PD7 Pull-Down set  */
N#define PWR_PDCRD_PD6_Pos            (6U)
N#define PWR_PDCRD_PD6_Msk            (0x1UL << PWR_PDCRD_PD6_Pos)              /*!< 0x00000040 */
N#define PWR_PDCRD_PD6                PWR_PDCRD_PD6_Msk                         /*!< Port PD6 Pull-Down set  */
N#define PWR_PDCRD_PD5_Pos            (5U)
N#define PWR_PDCRD_PD5_Msk            (0x1UL << PWR_PDCRD_PD5_Pos)              /*!< 0x00000020 */
N#define PWR_PDCRD_PD5                PWR_PDCRD_PD5_Msk                         /*!< Port PD5 Pull-Down set  */
N#define PWR_PDCRD_PD4_Pos            (4U)
N#define PWR_PDCRD_PD4_Msk            (0x1UL << PWR_PDCRD_PD4_Pos)              /*!< 0x00000010 */
N#define PWR_PDCRD_PD4                PWR_PDCRD_PD4_Msk                         /*!< Port PD4 Pull-Down set  */
N#define PWR_PDCRD_PD3_Pos            (3U)
N#define PWR_PDCRD_PD3_Msk            (0x1UL << PWR_PDCRD_PD3_Pos)              /*!< 0x00000008 */
N#define PWR_PDCRD_PD3                PWR_PDCRD_PD3_Msk                         /*!< Port PD3 Pull-Down set  */
N#define PWR_PDCRD_PD2_Pos            (2U)
N#define PWR_PDCRD_PD2_Msk            (0x1UL << PWR_PDCRD_PD2_Pos)              /*!< 0x00000004 */
N#define PWR_PDCRD_PD2                PWR_PDCRD_PD2_Msk                         /*!< Port PD2 Pull-Down set  */
N#define PWR_PDCRD_PD1_Pos            (1U)
N#define PWR_PDCRD_PD1_Msk            (0x1UL << PWR_PDCRD_PD1_Pos)              /*!< 0x00000002 */
N#define PWR_PDCRD_PD1                PWR_PDCRD_PD1_Msk                         /*!< Port PD1 Pull-Down set  */
N#define PWR_PDCRD_PD0_Pos            (0U)
N#define PWR_PDCRD_PD0_Msk            (0x1UL << PWR_PDCRD_PD0_Pos)              /*!< 0x00000001 */
N#define PWR_PDCRD_PD0                PWR_PDCRD_PD0_Msk                         /*!< Port PD0 Pull-Down set  */
N
N/********************  Bit definition for PWR_PUCRE register  ********************/
N#define PWR_PUCRE_PE15_Pos           (15U)
N#define PWR_PUCRE_PE15_Msk           (0x1UL << PWR_PUCRE_PE15_Pos)             /*!< 0x00008000 */
N#define PWR_PUCRE_PE15               PWR_PUCRE_PE15_Msk                        /*!< Port PE15 Pull-Up set */
N#define PWR_PUCRE_PE14_Pos           (14U)
N#define PWR_PUCRE_PE14_Msk           (0x1UL << PWR_PUCRE_PE14_Pos)             /*!< 0x00004000 */
N#define PWR_PUCRE_PE14               PWR_PUCRE_PE14_Msk                        /*!< Port PE14 Pull-Up set */
N#define PWR_PUCRE_PE13_Pos           (13U)
N#define PWR_PUCRE_PE13_Msk           (0x1UL << PWR_PUCRE_PE13_Pos)             /*!< 0x00002000 */
N#define PWR_PUCRE_PE13               PWR_PUCRE_PE13_Msk                        /*!< Port PE13 Pull-Up set */
N#define PWR_PUCRE_PE12_Pos           (12U)
N#define PWR_PUCRE_PE12_Msk           (0x1UL << PWR_PUCRE_PE12_Pos)             /*!< 0x00001000 */
N#define PWR_PUCRE_PE12               PWR_PUCRE_PE12_Msk                        /*!< Port PE12 Pull-Up set */
N#define PWR_PUCRE_PE11_Pos           (11U)
N#define PWR_PUCRE_PE11_Msk           (0x1UL << PWR_PUCRE_PE11_Pos)             /*!< 0x00000800 */
N#define PWR_PUCRE_PE11               PWR_PUCRE_PE11_Msk                        /*!< Port PE11 Pull-Up set */
N#define PWR_PUCRE_PE10_Pos           (10U)
N#define PWR_PUCRE_PE10_Msk           (0x1UL << PWR_PUCRE_PE10_Pos)             /*!< 0x00000400 */
N#define PWR_PUCRE_PE10               PWR_PUCRE_PE10_Msk                        /*!< Port PE10 Pull-Up set */
N#define PWR_PUCRE_PE9_Pos            (9U)
N#define PWR_PUCRE_PE9_Msk            (0x1UL << PWR_PUCRE_PE9_Pos)              /*!< 0x00000200 */
N#define PWR_PUCRE_PE9                PWR_PUCRE_PE9_Msk                         /*!< Port PE9 Pull-Up set  */
N#define PWR_PUCRE_PE8_Pos            (8U)
N#define PWR_PUCRE_PE8_Msk            (0x1UL << PWR_PUCRE_PE8_Pos)              /*!< 0x00000100 */
N#define PWR_PUCRE_PE8                PWR_PUCRE_PE8_Msk                         /*!< Port PE8 Pull-Up set  */
N#define PWR_PUCRE_PE7_Pos            (7U)
N#define PWR_PUCRE_PE7_Msk            (0x1UL << PWR_PUCRE_PE7_Pos)              /*!< 0x00000080 */
N#define PWR_PUCRE_PE7                PWR_PUCRE_PE7_Msk                         /*!< Port PE7 Pull-Up set  */
N#define PWR_PUCRE_PE6_Pos            (6U)
N#define PWR_PUCRE_PE6_Msk            (0x1UL << PWR_PUCRE_PE6_Pos)              /*!< 0x00000040 */
N#define PWR_PUCRE_PE6                PWR_PUCRE_PE6_Msk                         /*!< Port PE6 Pull-Up set  */
N#define PWR_PUCRE_PE5_Pos            (5U)
N#define PWR_PUCRE_PE5_Msk            (0x1UL << PWR_PUCRE_PE5_Pos)              /*!< 0x00000020 */
N#define PWR_PUCRE_PE5                PWR_PUCRE_PE5_Msk                         /*!< Port PE5 Pull-Up set  */
N#define PWR_PUCRE_PE4_Pos            (4U)
N#define PWR_PUCRE_PE4_Msk            (0x1UL << PWR_PUCRE_PE4_Pos)              /*!< 0x00000010 */
N#define PWR_PUCRE_PE4                PWR_PUCRE_PE4_Msk                         /*!< Port PE4 Pull-Up set  */
N#define PWR_PUCRE_PE3_Pos            (3U)
N#define PWR_PUCRE_PE3_Msk            (0x1UL << PWR_PUCRE_PE3_Pos)              /*!< 0x00000008 */
N#define PWR_PUCRE_PE3                PWR_PUCRE_PE3_Msk                         /*!< Port PE3 Pull-Up set  */
N#define PWR_PUCRE_PE2_Pos            (2U)
N#define PWR_PUCRE_PE2_Msk            (0x1UL << PWR_PUCRE_PE2_Pos)              /*!< 0x00000004 */
N#define PWR_PUCRE_PE2                PWR_PUCRE_PE2_Msk                         /*!< Port PE2 Pull-Up set  */
N#define PWR_PUCRE_PE1_Pos            (1U)
N#define PWR_PUCRE_PE1_Msk            (0x1UL << PWR_PUCRE_PE1_Pos)              /*!< 0x00000002 */
N#define PWR_PUCRE_PE1                PWR_PUCRE_PE1_Msk                         /*!< Port PE1 Pull-Up set  */
N#define PWR_PUCRE_PE0_Pos            (0U)
N#define PWR_PUCRE_PE0_Msk            (0x1UL << PWR_PUCRE_PE0_Pos)              /*!< 0x00000001 */
N#define PWR_PUCRE_PE0                PWR_PUCRE_PE0_Msk                         /*!< Port PE0 Pull-Up set  */
N
N/********************  Bit definition for PWR_PDCRE register  ********************/
N#define PWR_PDCRE_PE15_Pos           (15U)
N#define PWR_PDCRE_PE15_Msk           (0x1UL << PWR_PDCRE_PE15_Pos)             /*!< 0x00008000 */
N#define PWR_PDCRE_PE15               PWR_PDCRE_PE15_Msk                        /*!< Port PE15 Pull-Down set */
N#define PWR_PDCRE_PE14_Pos           (14U)
N#define PWR_PDCRE_PE14_Msk           (0x1UL << PWR_PDCRE_PE14_Pos)             /*!< 0x00004000 */
N#define PWR_PDCRE_PE14               PWR_PDCRE_PE14_Msk                        /*!< Port PE14 Pull-Down set */
N#define PWR_PDCRE_PE13_Pos           (13U)
N#define PWR_PDCRE_PE13_Msk           (0x1UL << PWR_PDCRE_PE13_Pos)             /*!< 0x00002000 */
N#define PWR_PDCRE_PE13               PWR_PDCRE_PE13_Msk                        /*!< Port PE13 Pull-Down set */
N#define PWR_PDCRE_PE12_Pos           (12U)
N#define PWR_PDCRE_PE12_Msk           (0x1UL << PWR_PDCRE_PE12_Pos)             /*!< 0x00001000 */
N#define PWR_PDCRE_PE12               PWR_PDCRE_PE12_Msk                        /*!< Port PE12 Pull-Down set */
N#define PWR_PDCRE_PE11_Pos           (11U)
N#define PWR_PDCRE_PE11_Msk           (0x1UL << PWR_PDCRE_PE11_Pos)             /*!< 0x00000800 */
N#define PWR_PDCRE_PE11               PWR_PDCRE_PE11_Msk                        /*!< Port PE11 Pull-Down set */
N#define PWR_PDCRE_PE10_Pos           (10U)
N#define PWR_PDCRE_PE10_Msk           (0x1UL << PWR_PDCRE_PE10_Pos)             /*!< 0x00000400 */
N#define PWR_PDCRE_PE10               PWR_PDCRE_PE10_Msk                        /*!< Port PE10 Pull-Down set */
N#define PWR_PDCRE_PE9_Pos            (9U)
N#define PWR_PDCRE_PE9_Msk            (0x1UL << PWR_PDCRE_PE9_Pos)              /*!< 0x00000200 */
N#define PWR_PDCRE_PE9                PWR_PDCRE_PE9_Msk                         /*!< Port PE9 Pull-Down set  */
N#define PWR_PDCRE_PE8_Pos            (8U)
N#define PWR_PDCRE_PE8_Msk            (0x1UL << PWR_PDCRE_PE8_Pos)              /*!< 0x00000100 */
N#define PWR_PDCRE_PE8                PWR_PDCRE_PE8_Msk                         /*!< Port PE8 Pull-Down set  */
N#define PWR_PDCRE_PE7_Pos            (7U)
N#define PWR_PDCRE_PE7_Msk            (0x1UL << PWR_PDCRE_PE7_Pos)              /*!< 0x00000080 */
N#define PWR_PDCRE_PE7                PWR_PDCRE_PE7_Msk                         /*!< Port PE7 Pull-Down set  */
N#define PWR_PDCRE_PE6_Pos            (6U)
N#define PWR_PDCRE_PE6_Msk            (0x1UL << PWR_PDCRE_PE6_Pos)              /*!< 0x00000040 */
N#define PWR_PDCRE_PE6                PWR_PDCRE_PE6_Msk                         /*!< Port PE6 Pull-Down set  */
N#define PWR_PDCRE_PE5_Pos            (5U)
N#define PWR_PDCRE_PE5_Msk            (0x1UL << PWR_PDCRE_PE5_Pos)              /*!< 0x00000020 */
N#define PWR_PDCRE_PE5                PWR_PDCRE_PE5_Msk                         /*!< Port PE5 Pull-Down set  */
N#define PWR_PDCRE_PE4_Pos            (4U)
N#define PWR_PDCRE_PE4_Msk            (0x1UL << PWR_PDCRE_PE4_Pos)              /*!< 0x00000010 */
N#define PWR_PDCRE_PE4                PWR_PDCRE_PE4_Msk                         /*!< Port PE4 Pull-Down set  */
N#define PWR_PDCRE_PE3_Pos            (3U)
N#define PWR_PDCRE_PE3_Msk            (0x1UL << PWR_PDCRE_PE3_Pos)              /*!< 0x00000008 */
N#define PWR_PDCRE_PE3                PWR_PDCRE_PE3_Msk                         /*!< Port PE3 Pull-Down set  */
N#define PWR_PDCRE_PE2_Pos            (2U)
N#define PWR_PDCRE_PE2_Msk            (0x1UL << PWR_PDCRE_PE2_Pos)              /*!< 0x00000004 */
N#define PWR_PDCRE_PE2                PWR_PDCRE_PE2_Msk                         /*!< Port PE2 Pull-Down set  */
N#define PWR_PDCRE_PE1_Pos            (1U)
N#define PWR_PDCRE_PE1_Msk            (0x1UL << PWR_PDCRE_PE1_Pos)              /*!< 0x00000002 */
N#define PWR_PDCRE_PE1                PWR_PDCRE_PE1_Msk                         /*!< Port PE1 Pull-Down set  */
N#define PWR_PDCRE_PE0_Pos            (0U)
N#define PWR_PDCRE_PE0_Msk            (0x1UL << PWR_PDCRE_PE0_Pos)              /*!< 0x00000001 */
N#define PWR_PDCRE_PE0                PWR_PDCRE_PE0_Msk                         /*!< Port PE0 Pull-Down set  */
N
N
N/********************  Bit definition for PWR_PUCRH register  ********************/
N#define PWR_PUCRH_PH3_Pos            (3U)
N#define PWR_PUCRH_PH3_Msk            (0x1UL << PWR_PUCRH_PH3_Pos)              /*!< 0x00000008 */
N#define PWR_PUCRH_PH3                PWR_PUCRH_PH3_Msk                         /*!< Port PH3 Pull-Up set  */
N#define PWR_PUCRH_PH1_Pos            (1U)
N#define PWR_PUCRH_PH1_Msk            (0x1UL << PWR_PUCRH_PH1_Pos)              /*!< 0x00000002 */
N#define PWR_PUCRH_PH1                PWR_PUCRH_PH1_Msk                         /*!< Port PH1 Pull-Up set  */
N#define PWR_PUCRH_PH0_Pos            (0U)
N#define PWR_PUCRH_PH0_Msk            (0x1UL << PWR_PUCRH_PH0_Pos)              /*!< 0x00000001 */
N#define PWR_PUCRH_PH0                PWR_PUCRH_PH0_Msk                         /*!< Port PH0 Pull-Up set  */
N
N/********************  Bit definition for PWR_PDCRH register  ********************/
N#define PWR_PDCRH_PH3_Pos            (3U)
N#define PWR_PDCRH_PH3_Msk            (0x1UL << PWR_PDCRH_PH3_Pos)              /*!< 0x00000008 */
N#define PWR_PDCRH_PH3                PWR_PDCRH_PH3_Msk                         /*!< Port PH3 Pull-Down set  */
N#define PWR_PDCRH_PH1_Pos            (1U)
N#define PWR_PDCRH_PH1_Msk            (0x1UL << PWR_PDCRH_PH1_Pos)              /*!< 0x00000002 */
N#define PWR_PDCRH_PH1                PWR_PDCRH_PH1_Msk                         /*!< Port PH1 Pull-Down set  */
N#define PWR_PDCRH_PH0_Pos            (0U)
N#define PWR_PDCRH_PH0_Msk            (0x1UL << PWR_PDCRH_PH0_Pos)              /*!< 0x00000001 */
N#define PWR_PDCRH_PH0                PWR_PDCRH_PH0_Msk                         /*!< Port PH0 Pull-Down set  */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N/*
N* @brief Specific device feature definitions  (not present on all devices in the STM32L4 serie)
N*/
N#define RCC_HSI48_SUPPORT
N#define RCC_PLLP_DIV_2_31_SUPPORT
N#define RCC_PLLSAI1P_DIV_2_31_SUPPORT
N
N/********************  Bit definition for RCC_CR register  ********************/
N#define RCC_CR_MSION_Pos                     (0U)
N#define RCC_CR_MSION_Msk                     (0x1UL << RCC_CR_MSION_Pos)       /*!< 0x00000001 */
N#define RCC_CR_MSION                         RCC_CR_MSION_Msk                  /*!< Internal Multi Speed oscillator (MSI) clock enable */
N#define RCC_CR_MSIRDY_Pos                    (1U)
N#define RCC_CR_MSIRDY_Msk                    (0x1UL << RCC_CR_MSIRDY_Pos)      /*!< 0x00000002 */
N#define RCC_CR_MSIRDY                        RCC_CR_MSIRDY_Msk                 /*!< Internal Multi Speed oscillator (MSI) clock ready flag */
N#define RCC_CR_MSIPLLEN_Pos                  (2U)
N#define RCC_CR_MSIPLLEN_Msk                  (0x1UL << RCC_CR_MSIPLLEN_Pos)    /*!< 0x00000004 */
N#define RCC_CR_MSIPLLEN                      RCC_CR_MSIPLLEN_Msk               /*!< Internal Multi Speed oscillator (MSI) PLL enable */
N#define RCC_CR_MSIRGSEL_Pos                  (3U)
N#define RCC_CR_MSIRGSEL_Msk                  (0x1UL << RCC_CR_MSIRGSEL_Pos)    /*!< 0x00000008 */
N#define RCC_CR_MSIRGSEL                      RCC_CR_MSIRGSEL_Msk               /*!< Internal Multi Speed oscillator (MSI) range selection */
N
N/*!< MSIRANGE configuration : 12 frequency ranges available */
N#define RCC_CR_MSIRANGE_Pos                  (4U)
N#define RCC_CR_MSIRANGE_Msk                  (0xFUL << RCC_CR_MSIRANGE_Pos)    /*!< 0x000000F0 */
N#define RCC_CR_MSIRANGE                      RCC_CR_MSIRANGE_Msk               /*!< Internal Multi Speed oscillator (MSI) clock Range */
N#define RCC_CR_MSIRANGE_0                    (0x0UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000000 */
N#define RCC_CR_MSIRANGE_1                    (0x1UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000010 */
N#define RCC_CR_MSIRANGE_2                    (0x2UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000020 */
N#define RCC_CR_MSIRANGE_3                    (0x3UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000030 */
N#define RCC_CR_MSIRANGE_4                    (0x4UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000040 */
N#define RCC_CR_MSIRANGE_5                    (0x5UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000050 */
N#define RCC_CR_MSIRANGE_6                    (0x6UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000060 */
N#define RCC_CR_MSIRANGE_7                    (0x7UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000070 */
N#define RCC_CR_MSIRANGE_8                    (0x8UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000080 */
N#define RCC_CR_MSIRANGE_9                    (0x9UL << RCC_CR_MSIRANGE_Pos)    /*!< 0x00000090 */
N#define RCC_CR_MSIRANGE_10                   (0xAUL << RCC_CR_MSIRANGE_Pos)    /*!< 0x000000A0 */
N#define RCC_CR_MSIRANGE_11                   (0xBUL << RCC_CR_MSIRANGE_Pos)    /*!< 0x000000B0 */
N
N#define RCC_CR_HSION_Pos                     (8U)
N#define RCC_CR_HSION_Msk                     (0x1UL << RCC_CR_HSION_Pos)       /*!< 0x00000100 */
N#define RCC_CR_HSION                         RCC_CR_HSION_Msk                  /*!< Internal High Speed oscillator (HSI16) clock enable */
N#define RCC_CR_HSIKERON_Pos                  (9U)
N#define RCC_CR_HSIKERON_Msk                  (0x1UL << RCC_CR_HSIKERON_Pos)    /*!< 0x00000200 */
N#define RCC_CR_HSIKERON                      RCC_CR_HSIKERON_Msk               /*!< Internal High Speed oscillator (HSI16) clock enable for some IPs Kernel */
N#define RCC_CR_HSIRDY_Pos                    (10U)
N#define RCC_CR_HSIRDY_Msk                    (0x1UL << RCC_CR_HSIRDY_Pos)      /*!< 0x00000400 */
N#define RCC_CR_HSIRDY                        RCC_CR_HSIRDY_Msk                 /*!< Internal High Speed oscillator (HSI16) clock ready flag */
N#define RCC_CR_HSIASFS_Pos                   (11U)
N#define RCC_CR_HSIASFS_Msk                   (0x1UL << RCC_CR_HSIASFS_Pos)     /*!< 0x00000800 */
N#define RCC_CR_HSIASFS                       RCC_CR_HSIASFS_Msk                /*!< HSI16 Automatic Start from Stop */
N
N#define RCC_CR_HSEON_Pos                     (16U)
N#define RCC_CR_HSEON_Msk                     (0x1UL << RCC_CR_HSEON_Pos)       /*!< 0x00010000 */
N#define RCC_CR_HSEON                         RCC_CR_HSEON_Msk                  /*!< External High Speed oscillator (HSE) clock enable */
N#define RCC_CR_HSERDY_Pos                    (17U)
N#define RCC_CR_HSERDY_Msk                    (0x1UL << RCC_CR_HSERDY_Pos)      /*!< 0x00020000 */
N#define RCC_CR_HSERDY                        RCC_CR_HSERDY_Msk                 /*!< External High Speed oscillator (HSE) clock ready */
N#define RCC_CR_HSEBYP_Pos                    (18U)
N#define RCC_CR_HSEBYP_Msk                    (0x1UL << RCC_CR_HSEBYP_Pos)      /*!< 0x00040000 */
N#define RCC_CR_HSEBYP                        RCC_CR_HSEBYP_Msk                 /*!< External High Speed oscillator (HSE) clock bypass */
N#define RCC_CR_CSSON_Pos                     (19U)
N#define RCC_CR_CSSON_Msk                     (0x1UL << RCC_CR_CSSON_Pos)       /*!< 0x00080000 */
N#define RCC_CR_CSSON                         RCC_CR_CSSON_Msk                  /*!< HSE Clock Security System enable */
N
N#define RCC_CR_PLLON_Pos                     (24U)
N#define RCC_CR_PLLON_Msk                     (0x1UL << RCC_CR_PLLON_Pos)       /*!< 0x01000000 */
N#define RCC_CR_PLLON                         RCC_CR_PLLON_Msk                  /*!< System PLL clock enable */
N#define RCC_CR_PLLRDY_Pos                    (25U)
N#define RCC_CR_PLLRDY_Msk                    (0x1UL << RCC_CR_PLLRDY_Pos)      /*!< 0x02000000 */
N#define RCC_CR_PLLRDY                        RCC_CR_PLLRDY_Msk                 /*!< System PLL clock ready */
N#define RCC_CR_PLLSAI1ON_Pos                 (26U)
N#define RCC_CR_PLLSAI1ON_Msk                 (0x1UL << RCC_CR_PLLSAI1ON_Pos)   /*!< 0x04000000 */
N#define RCC_CR_PLLSAI1ON                     RCC_CR_PLLSAI1ON_Msk              /*!< SAI1 PLL enable */
N#define RCC_CR_PLLSAI1RDY_Pos                (27U)
N#define RCC_CR_PLLSAI1RDY_Msk                (0x1UL << RCC_CR_PLLSAI1RDY_Pos)  /*!< 0x08000000 */
N#define RCC_CR_PLLSAI1RDY                    RCC_CR_PLLSAI1RDY_Msk             /*!< SAI1 PLL ready */
N
N/********************  Bit definition for RCC_ICSCR register  ***************/
N/*!< MSICAL configuration */
N#define RCC_ICSCR_MSICAL_Pos                 (0U)
N#define RCC_ICSCR_MSICAL_Msk                 (0xFFUL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x000000FF */
N#define RCC_ICSCR_MSICAL                     RCC_ICSCR_MSICAL_Msk              /*!< MSICAL[7:0] bits */
N#define RCC_ICSCR_MSICAL_0                   (0x01UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000001 */
N#define RCC_ICSCR_MSICAL_1                   (0x02UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000002 */
N#define RCC_ICSCR_MSICAL_2                   (0x04UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000004 */
N#define RCC_ICSCR_MSICAL_3                   (0x08UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000008 */
N#define RCC_ICSCR_MSICAL_4                   (0x10UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000010 */
N#define RCC_ICSCR_MSICAL_5                   (0x20UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000020 */
N#define RCC_ICSCR_MSICAL_6                   (0x40UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000040 */
N#define RCC_ICSCR_MSICAL_7                   (0x80UL << RCC_ICSCR_MSICAL_Pos)  /*!< 0x00000080 */
N
N/*!< MSITRIM configuration */
N#define RCC_ICSCR_MSITRIM_Pos                (8U)
N#define RCC_ICSCR_MSITRIM_Msk                (0xFFUL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x0000FF00 */
N#define RCC_ICSCR_MSITRIM                    RCC_ICSCR_MSITRIM_Msk             /*!< MSITRIM[7:0] bits */
N#define RCC_ICSCR_MSITRIM_0                  (0x01UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00000100 */
N#define RCC_ICSCR_MSITRIM_1                  (0x02UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00000200 */
N#define RCC_ICSCR_MSITRIM_2                  (0x04UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00000400 */
N#define RCC_ICSCR_MSITRIM_3                  (0x08UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00000800 */
N#define RCC_ICSCR_MSITRIM_4                  (0x10UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00001000 */
N#define RCC_ICSCR_MSITRIM_5                  (0x20UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00002000 */
N#define RCC_ICSCR_MSITRIM_6                  (0x40UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00004000 */
N#define RCC_ICSCR_MSITRIM_7                  (0x80UL << RCC_ICSCR_MSITRIM_Pos) /*!< 0x00008000 */
N
N/*!< HSICAL configuration */
N#define RCC_ICSCR_HSICAL_Pos                 (16U)
N#define RCC_ICSCR_HSICAL_Msk                 (0xFFUL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00FF0000 */
N#define RCC_ICSCR_HSICAL                     RCC_ICSCR_HSICAL_Msk              /*!< HSICAL[7:0] bits */
N#define RCC_ICSCR_HSICAL_0                   (0x01UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00010000 */
N#define RCC_ICSCR_HSICAL_1                   (0x02UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00020000 */
N#define RCC_ICSCR_HSICAL_2                   (0x04UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00040000 */
N#define RCC_ICSCR_HSICAL_3                   (0x08UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00080000 */
N#define RCC_ICSCR_HSICAL_4                   (0x10UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00100000 */
N#define RCC_ICSCR_HSICAL_5                   (0x20UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00200000 */
N#define RCC_ICSCR_HSICAL_6                   (0x40UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00400000 */
N#define RCC_ICSCR_HSICAL_7                   (0x80UL << RCC_ICSCR_HSICAL_Pos)  /*!< 0x00800000 */
N
N/*!< HSITRIM configuration */
N#define RCC_ICSCR_HSITRIM_Pos                (24U)
N#define RCC_ICSCR_HSITRIM_Msk                (0x1FUL << RCC_ICSCR_HSITRIM_Pos) /*!< 0x1F000000 */
N#define RCC_ICSCR_HSITRIM                    RCC_ICSCR_HSITRIM_Msk             /*!< HSITRIM[4:0] bits */
N#define RCC_ICSCR_HSITRIM_0                  (0x01UL << RCC_ICSCR_HSITRIM_Pos) /*!< 0x01000000 */
N#define RCC_ICSCR_HSITRIM_1                  (0x02UL << RCC_ICSCR_HSITRIM_Pos) /*!< 0x02000000 */
N#define RCC_ICSCR_HSITRIM_2                  (0x04UL << RCC_ICSCR_HSITRIM_Pos) /*!< 0x04000000 */
N#define RCC_ICSCR_HSITRIM_3                  (0x08UL << RCC_ICSCR_HSITRIM_Pos) /*!< 0x08000000 */
N#define RCC_ICSCR_HSITRIM_4                  (0x10UL << RCC_ICSCR_HSITRIM_Pos) /*!< 0x10000000 */
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N/*!< SW configuration */
N#define RCC_CFGR_SW_Pos                      (0U)
N#define RCC_CFGR_SW_Msk                      (0x3UL << RCC_CFGR_SW_Pos)        /*!< 0x00000003 */
N#define RCC_CFGR_SW                          RCC_CFGR_SW_Msk                   /*!< SW[1:0] bits (System clock Switch) */
N#define RCC_CFGR_SW_0                        (0x1UL << RCC_CFGR_SW_Pos)        /*!< 0x00000001 */
N#define RCC_CFGR_SW_1                        (0x2UL << RCC_CFGR_SW_Pos)        /*!< 0x00000002 */
N
N#define RCC_CFGR_SW_MSI                      (0x00000000UL)                    /*!< MSI oscillator selection as system clock */
N#define RCC_CFGR_SW_HSI                      (0x00000001UL)                    /*!< HSI16 oscillator selection as system clock */
N#define RCC_CFGR_SW_HSE                      (0x00000002UL)                    /*!< HSE oscillator selection as system clock */
N#define RCC_CFGR_SW_PLL                      (0x00000003UL)                    /*!< PLL selection as system clock */
N
N/*!< SWS configuration */
N#define RCC_CFGR_SWS_Pos                     (2U)
N#define RCC_CFGR_SWS_Msk                     (0x3UL << RCC_CFGR_SWS_Pos)       /*!< 0x0000000C */
N#define RCC_CFGR_SWS                         RCC_CFGR_SWS_Msk                  /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define RCC_CFGR_SWS_0                       (0x1UL << RCC_CFGR_SWS_Pos)       /*!< 0x00000004 */
N#define RCC_CFGR_SWS_1                       (0x2UL << RCC_CFGR_SWS_Pos)       /*!< 0x00000008 */
N
N#define RCC_CFGR_SWS_MSI                     (0x00000000UL)                    /*!< MSI oscillator used as system clock */
N#define RCC_CFGR_SWS_HSI                     (0x00000004UL)                    /*!< HSI16 oscillator used as system clock */
N#define RCC_CFGR_SWS_HSE                     (0x00000008UL)                    /*!< HSE oscillator used as system clock */
N#define RCC_CFGR_SWS_PLL                     (0x0000000CUL)                    /*!< PLL used as system clock */
N
N/*!< HPRE configuration */
N#define RCC_CFGR_HPRE_Pos                    (4U)
N#define RCC_CFGR_HPRE_Msk                    (0xFUL << RCC_CFGR_HPRE_Pos)      /*!< 0x000000F0 */
N#define RCC_CFGR_HPRE                        RCC_CFGR_HPRE_Msk                 /*!< HPRE[3:0] bits (AHB prescaler) */
N#define RCC_CFGR_HPRE_0                      (0x1UL << RCC_CFGR_HPRE_Pos)      /*!< 0x00000010 */
N#define RCC_CFGR_HPRE_1                      (0x2UL << RCC_CFGR_HPRE_Pos)      /*!< 0x00000020 */
N#define RCC_CFGR_HPRE_2                      (0x4UL << RCC_CFGR_HPRE_Pos)      /*!< 0x00000040 */
N#define RCC_CFGR_HPRE_3                      (0x8UL << RCC_CFGR_HPRE_Pos)      /*!< 0x00000080 */
N
N#define RCC_CFGR_HPRE_DIV1                   (0x00000000UL)                    /*!< SYSCLK not divided */
N#define RCC_CFGR_HPRE_DIV2                   (0x00000080UL)                    /*!< SYSCLK divided by 2 */
N#define RCC_CFGR_HPRE_DIV4                   (0x00000090UL)                    /*!< SYSCLK divided by 4 */
N#define RCC_CFGR_HPRE_DIV8                   (0x000000A0UL)                    /*!< SYSCLK divided by 8 */
N#define RCC_CFGR_HPRE_DIV16                  (0x000000B0UL)                    /*!< SYSCLK divided by 16 */
N#define RCC_CFGR_HPRE_DIV64                  (0x000000C0UL)                    /*!< SYSCLK divided by 64 */
N#define RCC_CFGR_HPRE_DIV128                 (0x000000D0UL)                    /*!< SYSCLK divided by 128 */
N#define RCC_CFGR_HPRE_DIV256                 (0x000000E0UL)                    /*!< SYSCLK divided by 256 */
N#define RCC_CFGR_HPRE_DIV512                 (0x000000F0UL)                    /*!< SYSCLK divided by 512 */
N
N/*!< PPRE1 configuration */
N#define RCC_CFGR_PPRE1_Pos                   (8U)
N#define RCC_CFGR_PPRE1_Msk                   (0x7UL << RCC_CFGR_PPRE1_Pos)     /*!< 0x00000700 */
N#define RCC_CFGR_PPRE1                       RCC_CFGR_PPRE1_Msk                /*!< PRE1[2:0] bits (APB2 prescaler) */
N#define RCC_CFGR_PPRE1_0                     (0x1UL << RCC_CFGR_PPRE1_Pos)     /*!< 0x00000100 */
N#define RCC_CFGR_PPRE1_1                     (0x2UL << RCC_CFGR_PPRE1_Pos)     /*!< 0x00000200 */
N#define RCC_CFGR_PPRE1_2                     (0x4UL << RCC_CFGR_PPRE1_Pos)     /*!< 0x00000400 */
N
N#define RCC_CFGR_PPRE1_DIV1                  (0x00000000UL)                    /*!< HCLK not divided */
N#define RCC_CFGR_PPRE1_DIV2                  (0x00000400UL)                    /*!< HCLK divided by 2 */
N#define RCC_CFGR_PPRE1_DIV4                  (0x00000500UL)                    /*!< HCLK divided by 4 */
N#define RCC_CFGR_PPRE1_DIV8                  (0x00000600UL)                    /*!< HCLK divided by 8 */
N#define RCC_CFGR_PPRE1_DIV16                 (0x00000700UL)                    /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define RCC_CFGR_PPRE2_Pos                   (11U)
N#define RCC_CFGR_PPRE2_Msk                   (0x7UL << RCC_CFGR_PPRE2_Pos)     /*!< 0x00003800 */
N#define RCC_CFGR_PPRE2                       RCC_CFGR_PPRE2_Msk                /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define RCC_CFGR_PPRE2_0                     (0x1UL << RCC_CFGR_PPRE2_Pos)     /*!< 0x00000800 */
N#define RCC_CFGR_PPRE2_1                     (0x2UL << RCC_CFGR_PPRE2_Pos)     /*!< 0x00001000 */
N#define RCC_CFGR_PPRE2_2                     (0x4UL << RCC_CFGR_PPRE2_Pos)     /*!< 0x00002000 */
N
N#define RCC_CFGR_PPRE2_DIV1                  (0x00000000UL)                    /*!< HCLK not divided */
N#define RCC_CFGR_PPRE2_DIV2                  (0x00002000UL)                    /*!< HCLK divided by 2 */
N#define RCC_CFGR_PPRE2_DIV4                  (0x00002800UL)                    /*!< HCLK divided by 4 */
N#define RCC_CFGR_PPRE2_DIV8                  (0x00003000UL)                    /*!< HCLK divided by 8 */
N#define RCC_CFGR_PPRE2_DIV16                 (0x00003800UL)                    /*!< HCLK divided by 16 */
N
N#define RCC_CFGR_STOPWUCK_Pos                (15U)
N#define RCC_CFGR_STOPWUCK_Msk                (0x1UL << RCC_CFGR_STOPWUCK_Pos)  /*!< 0x00008000 */
N#define RCC_CFGR_STOPWUCK                    RCC_CFGR_STOPWUCK_Msk             /*!< Wake Up from stop and CSS backup clock selection */
N
N/*!< MCOSEL configuration */
N#define RCC_CFGR_MCOSEL_Pos                  (24U)
N#define RCC_CFGR_MCOSEL_Msk                  (0xFUL << RCC_CFGR_MCOSEL_Pos)    /*!< 0x0F000000 */
N#define RCC_CFGR_MCOSEL                      RCC_CFGR_MCOSEL_Msk               /*!< MCOSEL [3:0] bits (Clock output selection) */
N#define RCC_CFGR_MCOSEL_0                    (0x1UL << RCC_CFGR_MCOSEL_Pos)    /*!< 0x01000000 */
N#define RCC_CFGR_MCOSEL_1                    (0x2UL << RCC_CFGR_MCOSEL_Pos)    /*!< 0x02000000 */
N#define RCC_CFGR_MCOSEL_2                    (0x4UL << RCC_CFGR_MCOSEL_Pos)    /*!< 0x04000000 */
N#define RCC_CFGR_MCOSEL_3                    (0x8UL << RCC_CFGR_MCOSEL_Pos)    /*!< 0x08000000 */
N
N#define RCC_CFGR_MCOPRE_Pos                  (28U)
N#define RCC_CFGR_MCOPRE_Msk                  (0x7UL << RCC_CFGR_MCOPRE_Pos)    /*!< 0x70000000 */
N#define RCC_CFGR_MCOPRE                      RCC_CFGR_MCOPRE_Msk               /*!< MCO prescaler */
N#define RCC_CFGR_MCOPRE_0                    (0x1UL << RCC_CFGR_MCOPRE_Pos)    /*!< 0x10000000 */
N#define RCC_CFGR_MCOPRE_1                    (0x2UL << RCC_CFGR_MCOPRE_Pos)    /*!< 0x20000000 */
N#define RCC_CFGR_MCOPRE_2                    (0x4UL << RCC_CFGR_MCOPRE_Pos)    /*!< 0x40000000 */
N
N#define RCC_CFGR_MCOPRE_DIV1                 (0x00000000UL)                    /*!< MCO is divided by 1 */
N#define RCC_CFGR_MCOPRE_DIV2                 (0x10000000UL)                    /*!< MCO is divided by 2 */
N#define RCC_CFGR_MCOPRE_DIV4                 (0x20000000UL)                    /*!< MCO is divided by 4 */
N#define RCC_CFGR_MCOPRE_DIV8                 (0x30000000UL)                    /*!< MCO is divided by 8 */
N#define RCC_CFGR_MCOPRE_DIV16                (0x40000000UL)                    /*!< MCO is divided by 16 */
N
N/* Legacy aliases */
N#define RCC_CFGR_MCO_PRE                     RCC_CFGR_MCOPRE
N#define RCC_CFGR_MCO_PRE_1                   RCC_CFGR_MCOPRE_DIV1
N#define RCC_CFGR_MCO_PRE_2                   RCC_CFGR_MCOPRE_DIV2
N#define RCC_CFGR_MCO_PRE_4                   RCC_CFGR_MCOPRE_DIV4
N#define RCC_CFGR_MCO_PRE_8                   RCC_CFGR_MCOPRE_DIV8
N#define RCC_CFGR_MCO_PRE_16                  RCC_CFGR_MCOPRE_DIV16
N
N/********************  Bit definition for RCC_PLLCFGR register  ***************/
N#define RCC_PLLCFGR_PLLSRC_Pos               (0U)
N#define RCC_PLLCFGR_PLLSRC_Msk               (0x3UL << RCC_PLLCFGR_PLLSRC_Pos) /*!< 0x00000003 */
N#define RCC_PLLCFGR_PLLSRC                   RCC_PLLCFGR_PLLSRC_Msk
N
N#define RCC_PLLCFGR_PLLSRC_MSI_Pos           (0U)
N#define RCC_PLLCFGR_PLLSRC_MSI_Msk           (0x1UL << RCC_PLLCFGR_PLLSRC_MSI_Pos) /*!< 0x00000001 */
N#define RCC_PLLCFGR_PLLSRC_MSI               RCC_PLLCFGR_PLLSRC_MSI_Msk        /*!< MSI oscillator source clock selected */
N#define RCC_PLLCFGR_PLLSRC_HSI_Pos           (1U)
N#define RCC_PLLCFGR_PLLSRC_HSI_Msk           (0x1UL << RCC_PLLCFGR_PLLSRC_HSI_Pos) /*!< 0x00000002 */
N#define RCC_PLLCFGR_PLLSRC_HSI               RCC_PLLCFGR_PLLSRC_HSI_Msk        /*!< HSI16 oscillator source clock selected */
N#define RCC_PLLCFGR_PLLSRC_HSE_Pos           (0U)
N#define RCC_PLLCFGR_PLLSRC_HSE_Msk           (0x3UL << RCC_PLLCFGR_PLLSRC_HSE_Pos) /*!< 0x00000003 */
N#define RCC_PLLCFGR_PLLSRC_HSE               RCC_PLLCFGR_PLLSRC_HSE_Msk        /*!< HSE oscillator source clock selected */
N
N#define RCC_PLLCFGR_PLLM_Pos                 (4U)
N#define RCC_PLLCFGR_PLLM_Msk                 (0x7UL << RCC_PLLCFGR_PLLM_Pos)   /*!< 0x00000070 */
N#define RCC_PLLCFGR_PLLM                     RCC_PLLCFGR_PLLM_Msk
N#define RCC_PLLCFGR_PLLM_0                   (0x1UL << RCC_PLLCFGR_PLLM_Pos)   /*!< 0x00000010 */
N#define RCC_PLLCFGR_PLLM_1                   (0x2UL << RCC_PLLCFGR_PLLM_Pos)   /*!< 0x00000020 */
N#define RCC_PLLCFGR_PLLM_2                   (0x4UL << RCC_PLLCFGR_PLLM_Pos)   /*!< 0x00000040 */
N
N#define RCC_PLLCFGR_PLLN_Pos                 (8U)
N#define RCC_PLLCFGR_PLLN_Msk                 (0x7FUL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00007F00 */
N#define RCC_PLLCFGR_PLLN                     RCC_PLLCFGR_PLLN_Msk
N#define RCC_PLLCFGR_PLLN_0                   (0x01UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00000100 */
N#define RCC_PLLCFGR_PLLN_1                   (0x02UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00000200 */
N#define RCC_PLLCFGR_PLLN_2                   (0x04UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00000400 */
N#define RCC_PLLCFGR_PLLN_3                   (0x08UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00000800 */
N#define RCC_PLLCFGR_PLLN_4                   (0x10UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00001000 */
N#define RCC_PLLCFGR_PLLN_5                   (0x20UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00002000 */
N#define RCC_PLLCFGR_PLLN_6                   (0x40UL << RCC_PLLCFGR_PLLN_Pos)  /*!< 0x00004000 */
N
N#define RCC_PLLCFGR_PLLPEN_Pos               (16U)
N#define RCC_PLLCFGR_PLLPEN_Msk               (0x1UL << RCC_PLLCFGR_PLLPEN_Pos) /*!< 0x00010000 */
N#define RCC_PLLCFGR_PLLPEN                   RCC_PLLCFGR_PLLPEN_Msk
N#define RCC_PLLCFGR_PLLP_Pos                 (17U)
N#define RCC_PLLCFGR_PLLP_Msk                 (0x1UL << RCC_PLLCFGR_PLLP_Pos)   /*!< 0x00020000 */
N#define RCC_PLLCFGR_PLLP                     RCC_PLLCFGR_PLLP_Msk
N#define RCC_PLLCFGR_PLLQEN_Pos               (20U)
N#define RCC_PLLCFGR_PLLQEN_Msk               (0x1UL << RCC_PLLCFGR_PLLQEN_Pos) /*!< 0x00100000 */
N#define RCC_PLLCFGR_PLLQEN                   RCC_PLLCFGR_PLLQEN_Msk
N
N#define RCC_PLLCFGR_PLLQ_Pos                 (21U)
N#define RCC_PLLCFGR_PLLQ_Msk                 (0x3UL << RCC_PLLCFGR_PLLQ_Pos)   /*!< 0x00600000 */
N#define RCC_PLLCFGR_PLLQ                     RCC_PLLCFGR_PLLQ_Msk
N#define RCC_PLLCFGR_PLLQ_0                   (0x1UL << RCC_PLLCFGR_PLLQ_Pos)   /*!< 0x00200000 */
N#define RCC_PLLCFGR_PLLQ_1                   (0x2UL << RCC_PLLCFGR_PLLQ_Pos)   /*!< 0x00400000 */
N
N#define RCC_PLLCFGR_PLLREN_Pos               (24U)
N#define RCC_PLLCFGR_PLLREN_Msk               (0x1UL << RCC_PLLCFGR_PLLREN_Pos) /*!< 0x01000000 */
N#define RCC_PLLCFGR_PLLREN                   RCC_PLLCFGR_PLLREN_Msk
N#define RCC_PLLCFGR_PLLR_Pos                 (25U)
N#define RCC_PLLCFGR_PLLR_Msk                 (0x3UL << RCC_PLLCFGR_PLLR_Pos)   /*!< 0x06000000 */
N#define RCC_PLLCFGR_PLLR                     RCC_PLLCFGR_PLLR_Msk
N#define RCC_PLLCFGR_PLLR_0                   (0x1UL << RCC_PLLCFGR_PLLR_Pos)   /*!< 0x02000000 */
N#define RCC_PLLCFGR_PLLR_1                   (0x2UL << RCC_PLLCFGR_PLLR_Pos)   /*!< 0x04000000 */
N
N#define RCC_PLLCFGR_PLLPDIV_Pos              (27U)
N#define RCC_PLLCFGR_PLLPDIV_Msk              (0x1FUL << RCC_PLLCFGR_PLLPDIV_Pos) /*!< 0xF8000000 */
N#define RCC_PLLCFGR_PLLPDIV                  RCC_PLLCFGR_PLLPDIV_Msk
N#define RCC_PLLCFGR_PLLPDIV_0                (0x01UL << RCC_PLLCFGR_PLLPDIV_Pos) /*!< 0x08000000 */
N#define RCC_PLLCFGR_PLLPDIV_1                (0x02UL << RCC_PLLCFGR_PLLPDIV_Pos) /*!< 0x10000000 */
N#define RCC_PLLCFGR_PLLPDIV_2                (0x04UL << RCC_PLLCFGR_PLLPDIV_Pos) /*!< 0x20000000 */
N#define RCC_PLLCFGR_PLLPDIV_3                (0x08UL << RCC_PLLCFGR_PLLPDIV_Pos) /*!< 0x40000000 */
N#define RCC_PLLCFGR_PLLPDIV_4                (0x10UL << RCC_PLLCFGR_PLLPDIV_Pos) /*!< 0x80000000 */
N
N/********************  Bit definition for RCC_PLLSAI1CFGR register  ************/
N#define RCC_PLLSAI1CFGR_PLLSAI1N_Pos         (8U)
N#define RCC_PLLSAI1CFGR_PLLSAI1N_Msk         (0x7FUL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00007F00 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N             RCC_PLLSAI1CFGR_PLLSAI1N_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1N_0           (0x01UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00000100 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N_1           (0x02UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00000200 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N_2           (0x04UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00000400 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N_3           (0x08UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00000800 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N_4           (0x10UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00001000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N_5           (0x20UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00002000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1N_6           (0x40UL << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) /*!< 0x00004000 */
N
N#define RCC_PLLSAI1CFGR_PLLSAI1PEN_Pos       (16U)
N#define RCC_PLLSAI1CFGR_PLLSAI1PEN_Msk       (0x1UL << RCC_PLLSAI1CFGR_PLLSAI1PEN_Pos) /*!< 0x00010000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1PEN           RCC_PLLSAI1CFGR_PLLSAI1PEN_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1P_Pos         (17U)
N#define RCC_PLLSAI1CFGR_PLLSAI1P_Msk         (0x1UL << RCC_PLLSAI1CFGR_PLLSAI1P_Pos) /*!< 0x00020000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1P             RCC_PLLSAI1CFGR_PLLSAI1P_Msk
N
N#define RCC_PLLSAI1CFGR_PLLSAI1QEN_Pos       (20U)
N#define RCC_PLLSAI1CFGR_PLLSAI1QEN_Msk       (0x1UL << RCC_PLLSAI1CFGR_PLLSAI1QEN_Pos) /*!< 0x00100000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1QEN           RCC_PLLSAI1CFGR_PLLSAI1QEN_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1Q_Pos         (21U)
N#define RCC_PLLSAI1CFGR_PLLSAI1Q_Msk         (0x3UL << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) /*!< 0x00600000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1Q             RCC_PLLSAI1CFGR_PLLSAI1Q_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1Q_0           (0x1UL << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) /*!< 0x00200000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1Q_1           (0x2UL << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) /*!< 0x00400000 */
N
N#define RCC_PLLSAI1CFGR_PLLSAI1REN_Pos       (24U)
N#define RCC_PLLSAI1CFGR_PLLSAI1REN_Msk       (0x1UL << RCC_PLLSAI1CFGR_PLLSAI1REN_Pos) /*!< 0x01000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1REN           RCC_PLLSAI1CFGR_PLLSAI1REN_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1R_Pos         (25U)
N#define RCC_PLLSAI1CFGR_PLLSAI1R_Msk         (0x3UL << RCC_PLLSAI1CFGR_PLLSAI1R_Pos) /*!< 0x06000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1R             RCC_PLLSAI1CFGR_PLLSAI1R_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1R_0           (0x1UL << RCC_PLLSAI1CFGR_PLLSAI1R_Pos) /*!< 0x02000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1R_1           (0x2UL << RCC_PLLSAI1CFGR_PLLSAI1R_Pos) /*!< 0x04000000 */
N
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos      (27U)
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_Msk      (0x1FUL << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) /*!< 0xF8000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV          RCC_PLLSAI1CFGR_PLLSAI1PDIV_Msk
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_0        (0x01UL << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) /*!< 0x08000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_1        (0x02UL << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) /*!< 0x10000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_2        (0x04UL << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) /*!< 0x20000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_3        (0x08UL << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) /*!< 0x40000000 */
N#define RCC_PLLSAI1CFGR_PLLSAI1PDIV_4        (0x10UL << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) /*!< 0x80000000 */
N
N/********************  Bit definition for RCC_CIER register  ******************/
N#define RCC_CIER_LSIRDYIE_Pos                (0U)
N#define RCC_CIER_LSIRDYIE_Msk                (0x1UL << RCC_CIER_LSIRDYIE_Pos)  /*!< 0x00000001 */
N#define RCC_CIER_LSIRDYIE                    RCC_CIER_LSIRDYIE_Msk
N#define RCC_CIER_LSERDYIE_Pos                (1U)
N#define RCC_CIER_LSERDYIE_Msk                (0x1UL << RCC_CIER_LSERDYIE_Pos)  /*!< 0x00000002 */
N#define RCC_CIER_LSERDYIE                    RCC_CIER_LSERDYIE_Msk
N#define RCC_CIER_MSIRDYIE_Pos                (2U)
N#define RCC_CIER_MSIRDYIE_Msk                (0x1UL << RCC_CIER_MSIRDYIE_Pos)  /*!< 0x00000004 */
N#define RCC_CIER_MSIRDYIE                    RCC_CIER_MSIRDYIE_Msk
N#define RCC_CIER_HSIRDYIE_Pos                (3U)
N#define RCC_CIER_HSIRDYIE_Msk                (0x1UL << RCC_CIER_HSIRDYIE_Pos)  /*!< 0x00000008 */
N#define RCC_CIER_HSIRDYIE                    RCC_CIER_HSIRDYIE_Msk
N#define RCC_CIER_HSERDYIE_Pos                (4U)
N#define RCC_CIER_HSERDYIE_Msk                (0x1UL << RCC_CIER_HSERDYIE_Pos)  /*!< 0x00000010 */
N#define RCC_CIER_HSERDYIE                    RCC_CIER_HSERDYIE_Msk
N#define RCC_CIER_PLLRDYIE_Pos                (5U)
N#define RCC_CIER_PLLRDYIE_Msk                (0x1UL << RCC_CIER_PLLRDYIE_Pos)  /*!< 0x00000020 */
N#define RCC_CIER_PLLRDYIE                    RCC_CIER_PLLRDYIE_Msk
N#define RCC_CIER_PLLSAI1RDYIE_Pos            (6U)
N#define RCC_CIER_PLLSAI1RDYIE_Msk            (0x1UL << RCC_CIER_PLLSAI1RDYIE_Pos) /*!< 0x00000040 */
N#define RCC_CIER_PLLSAI1RDYIE                RCC_CIER_PLLSAI1RDYIE_Msk
N#define RCC_CIER_LSECSSIE_Pos                (9U)
N#define RCC_CIER_LSECSSIE_Msk                (0x1UL << RCC_CIER_LSECSSIE_Pos)  /*!< 0x00000200 */
N#define RCC_CIER_LSECSSIE                    RCC_CIER_LSECSSIE_Msk
N#define RCC_CIER_HSI48RDYIE_Pos              (10U)
N#define RCC_CIER_HSI48RDYIE_Msk              (0x1UL << RCC_CIER_HSI48RDYIE_Pos) /*!< 0x00000400 */
N#define RCC_CIER_HSI48RDYIE                  RCC_CIER_HSI48RDYIE_Msk
N
N/********************  Bit definition for RCC_CIFR register  ******************/
N#define RCC_CIFR_LSIRDYF_Pos                 (0U)
N#define RCC_CIFR_LSIRDYF_Msk                 (0x1UL << RCC_CIFR_LSIRDYF_Pos)   /*!< 0x00000001 */
N#define RCC_CIFR_LSIRDYF                     RCC_CIFR_LSIRDYF_Msk
N#define RCC_CIFR_LSERDYF_Pos                 (1U)
N#define RCC_CIFR_LSERDYF_Msk                 (0x1UL << RCC_CIFR_LSERDYF_Pos)   /*!< 0x00000002 */
N#define RCC_CIFR_LSERDYF                     RCC_CIFR_LSERDYF_Msk
N#define RCC_CIFR_MSIRDYF_Pos                 (2U)
N#define RCC_CIFR_MSIRDYF_Msk                 (0x1UL << RCC_CIFR_MSIRDYF_Pos)   /*!< 0x00000004 */
N#define RCC_CIFR_MSIRDYF                     RCC_CIFR_MSIRDYF_Msk
N#define RCC_CIFR_HSIRDYF_Pos                 (3U)
N#define RCC_CIFR_HSIRDYF_Msk                 (0x1UL << RCC_CIFR_HSIRDYF_Pos)   /*!< 0x00000008 */
N#define RCC_CIFR_HSIRDYF                     RCC_CIFR_HSIRDYF_Msk
N#define RCC_CIFR_HSERDYF_Pos                 (4U)
N#define RCC_CIFR_HSERDYF_Msk                 (0x1UL << RCC_CIFR_HSERDYF_Pos)   /*!< 0x00000010 */
N#define RCC_CIFR_HSERDYF                     RCC_CIFR_HSERDYF_Msk
N#define RCC_CIFR_PLLRDYF_Pos                 (5U)
N#define RCC_CIFR_PLLRDYF_Msk                 (0x1UL << RCC_CIFR_PLLRDYF_Pos)   /*!< 0x00000020 */
N#define RCC_CIFR_PLLRDYF                     RCC_CIFR_PLLRDYF_Msk
N#define RCC_CIFR_PLLSAI1RDYF_Pos             (6U)
N#define RCC_CIFR_PLLSAI1RDYF_Msk             (0x1UL << RCC_CIFR_PLLSAI1RDYF_Pos) /*!< 0x00000040 */
N#define RCC_CIFR_PLLSAI1RDYF                 RCC_CIFR_PLLSAI1RDYF_Msk
N#define RCC_CIFR_CSSF_Pos                    (8U)
N#define RCC_CIFR_CSSF_Msk                    (0x1UL << RCC_CIFR_CSSF_Pos)      /*!< 0x00000100 */
N#define RCC_CIFR_CSSF                        RCC_CIFR_CSSF_Msk
N#define RCC_CIFR_LSECSSF_Pos                 (9U)
N#define RCC_CIFR_LSECSSF_Msk                 (0x1UL << RCC_CIFR_LSECSSF_Pos)   /*!< 0x00000200 */
N#define RCC_CIFR_LSECSSF                     RCC_CIFR_LSECSSF_Msk
N#define RCC_CIFR_HSI48RDYF_Pos               (10U)
N#define RCC_CIFR_HSI48RDYF_Msk               (0x1UL << RCC_CIFR_HSI48RDYF_Pos) /*!< 0x00000400 */
N#define RCC_CIFR_HSI48RDYF                   RCC_CIFR_HSI48RDYF_Msk
N
N/********************  Bit definition for RCC_CICR register  ******************/
N#define RCC_CICR_LSIRDYC_Pos                 (0U)
N#define RCC_CICR_LSIRDYC_Msk                 (0x1UL << RCC_CICR_LSIRDYC_Pos)   /*!< 0x00000001 */
N#define RCC_CICR_LSIRDYC                     RCC_CICR_LSIRDYC_Msk
N#define RCC_CICR_LSERDYC_Pos                 (1U)
N#define RCC_CICR_LSERDYC_Msk                 (0x1UL << RCC_CICR_LSERDYC_Pos)   /*!< 0x00000002 */
N#define RCC_CICR_LSERDYC                     RCC_CICR_LSERDYC_Msk
N#define RCC_CICR_MSIRDYC_Pos                 (2U)
N#define RCC_CICR_MSIRDYC_Msk                 (0x1UL << RCC_CICR_MSIRDYC_Pos)   /*!< 0x00000004 */
N#define RCC_CICR_MSIRDYC                     RCC_CICR_MSIRDYC_Msk
N#define RCC_CICR_HSIRDYC_Pos                 (3U)
N#define RCC_CICR_HSIRDYC_Msk                 (0x1UL << RCC_CICR_HSIRDYC_Pos)   /*!< 0x00000008 */
N#define RCC_CICR_HSIRDYC                     RCC_CICR_HSIRDYC_Msk
N#define RCC_CICR_HSERDYC_Pos                 (4U)
N#define RCC_CICR_HSERDYC_Msk                 (0x1UL << RCC_CICR_HSERDYC_Pos)   /*!< 0x00000010 */
N#define RCC_CICR_HSERDYC                     RCC_CICR_HSERDYC_Msk
N#define RCC_CICR_PLLRDYC_Pos                 (5U)
N#define RCC_CICR_PLLRDYC_Msk                 (0x1UL << RCC_CICR_PLLRDYC_Pos)   /*!< 0x00000020 */
N#define RCC_CICR_PLLRDYC                     RCC_CICR_PLLRDYC_Msk
N#define RCC_CICR_PLLSAI1RDYC_Pos             (6U)
N#define RCC_CICR_PLLSAI1RDYC_Msk             (0x1UL << RCC_CICR_PLLSAI1RDYC_Pos) /*!< 0x00000040 */
N#define RCC_CICR_PLLSAI1RDYC                 RCC_CICR_PLLSAI1RDYC_Msk
N#define RCC_CICR_CSSC_Pos                    (8U)
N#define RCC_CICR_CSSC_Msk                    (0x1UL << RCC_CICR_CSSC_Pos)      /*!< 0x00000100 */
N#define RCC_CICR_CSSC                        RCC_CICR_CSSC_Msk
N#define RCC_CICR_LSECSSC_Pos                 (9U)
N#define RCC_CICR_LSECSSC_Msk                 (0x1UL << RCC_CICR_LSECSSC_Pos)   /*!< 0x00000200 */
N#define RCC_CICR_LSECSSC                     RCC_CICR_LSECSSC_Msk
N#define RCC_CICR_HSI48RDYC_Pos               (10U)
N#define RCC_CICR_HSI48RDYC_Msk               (0x1UL << RCC_CICR_HSI48RDYC_Pos) /*!< 0x00000400 */
N#define RCC_CICR_HSI48RDYC                   RCC_CICR_HSI48RDYC_Msk
N
N/********************  Bit definition for RCC_AHB1RSTR register  **************/
N#define RCC_AHB1RSTR_DMA1RST_Pos             (0U)
N#define RCC_AHB1RSTR_DMA1RST_Msk             (0x1UL << RCC_AHB1RSTR_DMA1RST_Pos) /*!< 0x00000001 */
N#define RCC_AHB1RSTR_DMA1RST                 RCC_AHB1RSTR_DMA1RST_Msk
N#define RCC_AHB1RSTR_DMA2RST_Pos             (1U)
N#define RCC_AHB1RSTR_DMA2RST_Msk             (0x1UL << RCC_AHB1RSTR_DMA2RST_Pos) /*!< 0x00000002 */
N#define RCC_AHB1RSTR_DMA2RST                 RCC_AHB1RSTR_DMA2RST_Msk
N#define RCC_AHB1RSTR_FLASHRST_Pos            (8U)
N#define RCC_AHB1RSTR_FLASHRST_Msk            (0x1UL << RCC_AHB1RSTR_FLASHRST_Pos) /*!< 0x00000100 */
N#define RCC_AHB1RSTR_FLASHRST                RCC_AHB1RSTR_FLASHRST_Msk
N#define RCC_AHB1RSTR_CRCRST_Pos              (12U)
N#define RCC_AHB1RSTR_CRCRST_Msk              (0x1UL << RCC_AHB1RSTR_CRCRST_Pos) /*!< 0x00001000 */
N#define RCC_AHB1RSTR_CRCRST                  RCC_AHB1RSTR_CRCRST_Msk
N#define RCC_AHB1RSTR_TSCRST_Pos              (16U)
N#define RCC_AHB1RSTR_TSCRST_Msk              (0x1UL << RCC_AHB1RSTR_TSCRST_Pos) /*!< 0x00010000 */
N#define RCC_AHB1RSTR_TSCRST                  RCC_AHB1RSTR_TSCRST_Msk
N
N/********************  Bit definition for RCC_AHB2RSTR register  **************/
N#define RCC_AHB2RSTR_GPIOARST_Pos            (0U)
N#define RCC_AHB2RSTR_GPIOARST_Msk            (0x1UL << RCC_AHB2RSTR_GPIOARST_Pos) /*!< 0x00000001 */
N#define RCC_AHB2RSTR_GPIOARST                RCC_AHB2RSTR_GPIOARST_Msk
N#define RCC_AHB2RSTR_GPIOBRST_Pos            (1U)
N#define RCC_AHB2RSTR_GPIOBRST_Msk            (0x1UL << RCC_AHB2RSTR_GPIOBRST_Pos) /*!< 0x00000002 */
N#define RCC_AHB2RSTR_GPIOBRST                RCC_AHB2RSTR_GPIOBRST_Msk
N#define RCC_AHB2RSTR_GPIOCRST_Pos            (2U)
N#define RCC_AHB2RSTR_GPIOCRST_Msk            (0x1UL << RCC_AHB2RSTR_GPIOCRST_Pos) /*!< 0x00000004 */
N#define RCC_AHB2RSTR_GPIOCRST                RCC_AHB2RSTR_GPIOCRST_Msk
N#define RCC_AHB2RSTR_GPIODRST_Pos            (3U)
N#define RCC_AHB2RSTR_GPIODRST_Msk            (0x1UL << RCC_AHB2RSTR_GPIODRST_Pos) /*!< 0x00000008 */
N#define RCC_AHB2RSTR_GPIODRST                RCC_AHB2RSTR_GPIODRST_Msk
N#define RCC_AHB2RSTR_GPIOERST_Pos            (4U)
N#define RCC_AHB2RSTR_GPIOERST_Msk            (0x1UL << RCC_AHB2RSTR_GPIOERST_Pos) /*!< 0x00000010 */
N#define RCC_AHB2RSTR_GPIOERST                RCC_AHB2RSTR_GPIOERST_Msk
N#define RCC_AHB2RSTR_GPIOHRST_Pos            (7U)
N#define RCC_AHB2RSTR_GPIOHRST_Msk            (0x1UL << RCC_AHB2RSTR_GPIOHRST_Pos) /*!< 0x00000080 */
N#define RCC_AHB2RSTR_GPIOHRST                RCC_AHB2RSTR_GPIOHRST_Msk
N#define RCC_AHB2RSTR_ADCRST_Pos              (13U)
N#define RCC_AHB2RSTR_ADCRST_Msk              (0x1UL << RCC_AHB2RSTR_ADCRST_Pos) /*!< 0x00002000 */
N#define RCC_AHB2RSTR_ADCRST                  RCC_AHB2RSTR_ADCRST_Msk
N#define RCC_AHB2RSTR_RNGRST_Pos              (18U)
N#define RCC_AHB2RSTR_RNGRST_Msk              (0x1UL << RCC_AHB2RSTR_RNGRST_Pos) /*!< 0x00040000 */
N#define RCC_AHB2RSTR_RNGRST                  RCC_AHB2RSTR_RNGRST_Msk
N
N/********************  Bit definition for RCC_AHB3RSTR register  **************/
N#define RCC_AHB3RSTR_QSPIRST_Pos             (8U)
N#define RCC_AHB3RSTR_QSPIRST_Msk             (0x1UL << RCC_AHB3RSTR_QSPIRST_Pos) /*!< 0x00000100 */
N#define RCC_AHB3RSTR_QSPIRST                 RCC_AHB3RSTR_QSPIRST_Msk
N
N/********************  Bit definition for RCC_APB1RSTR1 register  **************/
N#define RCC_APB1RSTR1_TIM2RST_Pos            (0U)
N#define RCC_APB1RSTR1_TIM2RST_Msk            (0x1UL << RCC_APB1RSTR1_TIM2RST_Pos) /*!< 0x00000001 */
N#define RCC_APB1RSTR1_TIM2RST                RCC_APB1RSTR1_TIM2RST_Msk
N#define RCC_APB1RSTR1_TIM6RST_Pos            (4U)
N#define RCC_APB1RSTR1_TIM6RST_Msk            (0x1UL << RCC_APB1RSTR1_TIM6RST_Pos) /*!< 0x00000010 */
N#define RCC_APB1RSTR1_TIM6RST                RCC_APB1RSTR1_TIM6RST_Msk
N#define RCC_APB1RSTR1_TIM7RST_Pos            (5U)
N#define RCC_APB1RSTR1_TIM7RST_Msk            (0x1UL << RCC_APB1RSTR1_TIM7RST_Pos) /*!< 0x00000020 */
N#define RCC_APB1RSTR1_TIM7RST                RCC_APB1RSTR1_TIM7RST_Msk
N#define RCC_APB1RSTR1_SPI2RST_Pos            (14U)
N#define RCC_APB1RSTR1_SPI2RST_Msk            (0x1UL << RCC_APB1RSTR1_SPI2RST_Pos) /*!< 0x00004000 */
N#define RCC_APB1RSTR1_SPI2RST                RCC_APB1RSTR1_SPI2RST_Msk
N#define RCC_APB1RSTR1_SPI3RST_Pos            (15U)
N#define RCC_APB1RSTR1_SPI3RST_Msk            (0x1UL << RCC_APB1RSTR1_SPI3RST_Pos) /*!< 0x00008000 */
N#define RCC_APB1RSTR1_SPI3RST                RCC_APB1RSTR1_SPI3RST_Msk
N#define RCC_APB1RSTR1_USART2RST_Pos          (17U)
N#define RCC_APB1RSTR1_USART2RST_Msk          (0x1UL << RCC_APB1RSTR1_USART2RST_Pos) /*!< 0x00020000 */
N#define RCC_APB1RSTR1_USART2RST              RCC_APB1RSTR1_USART2RST_Msk
N#define RCC_APB1RSTR1_USART3RST_Pos          (18U)
N#define RCC_APB1RSTR1_USART3RST_Msk          (0x1UL << RCC_APB1RSTR1_USART3RST_Pos) /*!< 0x00040000 */
N#define RCC_APB1RSTR1_USART3RST              RCC_APB1RSTR1_USART3RST_Msk
N#define RCC_APB1RSTR1_I2C1RST_Pos            (21U)
N#define RCC_APB1RSTR1_I2C1RST_Msk            (0x1UL << RCC_APB1RSTR1_I2C1RST_Pos) /*!< 0x00200000 */
N#define RCC_APB1RSTR1_I2C1RST                RCC_APB1RSTR1_I2C1RST_Msk
N#define RCC_APB1RSTR1_I2C2RST_Pos            (22U)
N#define RCC_APB1RSTR1_I2C2RST_Msk            (0x1UL << RCC_APB1RSTR1_I2C2RST_Pos) /*!< 0x00400000 */
N#define RCC_APB1RSTR1_I2C2RST                RCC_APB1RSTR1_I2C2RST_Msk
N#define RCC_APB1RSTR1_I2C3RST_Pos            (23U)
N#define RCC_APB1RSTR1_I2C3RST_Msk            (0x1UL << RCC_APB1RSTR1_I2C3RST_Pos) /*!< 0x00800000 */
N#define RCC_APB1RSTR1_I2C3RST                RCC_APB1RSTR1_I2C3RST_Msk
N#define RCC_APB1RSTR1_CRSRST_Pos             (24U)
N#define RCC_APB1RSTR1_CRSRST_Msk             (0x1UL << RCC_APB1RSTR1_CRSRST_Pos) /*!< 0x01000000 */
N#define RCC_APB1RSTR1_CRSRST                 RCC_APB1RSTR1_CRSRST_Msk
N#define RCC_APB1RSTR1_CAN1RST_Pos            (25U)
N#define RCC_APB1RSTR1_CAN1RST_Msk            (0x1UL << RCC_APB1RSTR1_CAN1RST_Pos) /*!< 0x02000000 */
N#define RCC_APB1RSTR1_CAN1RST                RCC_APB1RSTR1_CAN1RST_Msk
N#define RCC_APB1RSTR1_PWRRST_Pos             (28U)
N#define RCC_APB1RSTR1_PWRRST_Msk             (0x1UL << RCC_APB1RSTR1_PWRRST_Pos) /*!< 0x10000000 */
N#define RCC_APB1RSTR1_PWRRST                 RCC_APB1RSTR1_PWRRST_Msk
N#define RCC_APB1RSTR1_DAC1RST_Pos            (29U)
N#define RCC_APB1RSTR1_DAC1RST_Msk            (0x1UL << RCC_APB1RSTR1_DAC1RST_Pos) /*!< 0x20000000 */
N#define RCC_APB1RSTR1_DAC1RST                RCC_APB1RSTR1_DAC1RST_Msk
N#define RCC_APB1RSTR1_OPAMPRST_Pos           (30U)
N#define RCC_APB1RSTR1_OPAMPRST_Msk           (0x1UL << RCC_APB1RSTR1_OPAMPRST_Pos) /*!< 0x40000000 */
N#define RCC_APB1RSTR1_OPAMPRST               RCC_APB1RSTR1_OPAMPRST_Msk
N#define RCC_APB1RSTR1_LPTIM1RST_Pos          (31U)
N#define RCC_APB1RSTR1_LPTIM1RST_Msk          (0x1UL << RCC_APB1RSTR1_LPTIM1RST_Pos) /*!< 0x80000000 */
N#define RCC_APB1RSTR1_LPTIM1RST              RCC_APB1RSTR1_LPTIM1RST_Msk
N
N/********************  Bit definition for RCC_APB1RSTR2 register  **************/
N#define RCC_APB1RSTR2_LPUART1RST_Pos         (0U)
N#define RCC_APB1RSTR2_LPUART1RST_Msk         (0x1UL << RCC_APB1RSTR2_LPUART1RST_Pos) /*!< 0x00000001 */
N#define RCC_APB1RSTR2_LPUART1RST             RCC_APB1RSTR2_LPUART1RST_Msk
N#define RCC_APB1RSTR2_SWPMI1RST_Pos          (2U)
N#define RCC_APB1RSTR2_SWPMI1RST_Msk          (0x1UL << RCC_APB1RSTR2_SWPMI1RST_Pos) /*!< 0x00000004 */
N#define RCC_APB1RSTR2_SWPMI1RST              RCC_APB1RSTR2_SWPMI1RST_Msk
N#define RCC_APB1RSTR2_LPTIM2RST_Pos          (5U)
N#define RCC_APB1RSTR2_LPTIM2RST_Msk          (0x1UL << RCC_APB1RSTR2_LPTIM2RST_Pos) /*!< 0x00000020 */
N#define RCC_APB1RSTR2_LPTIM2RST              RCC_APB1RSTR2_LPTIM2RST_Msk
N
N/********************  Bit definition for RCC_APB2RSTR register  **************/
N#define RCC_APB2RSTR_SYSCFGRST_Pos           (0U)
N#define RCC_APB2RSTR_SYSCFGRST_Msk           (0x1UL << RCC_APB2RSTR_SYSCFGRST_Pos) /*!< 0x00000001 */
N#define RCC_APB2RSTR_SYSCFGRST               RCC_APB2RSTR_SYSCFGRST_Msk
N#define RCC_APB2RSTR_SDMMC1RST_Pos           (10U)
N#define RCC_APB2RSTR_SDMMC1RST_Msk           (0x1UL << RCC_APB2RSTR_SDMMC1RST_Pos) /*!< 0x00000400 */
N#define RCC_APB2RSTR_SDMMC1RST               RCC_APB2RSTR_SDMMC1RST_Msk
N#define RCC_APB2RSTR_TIM1RST_Pos             (11U)
N#define RCC_APB2RSTR_TIM1RST_Msk             (0x1UL << RCC_APB2RSTR_TIM1RST_Pos) /*!< 0x00000800 */
N#define RCC_APB2RSTR_TIM1RST                 RCC_APB2RSTR_TIM1RST_Msk
N#define RCC_APB2RSTR_SPI1RST_Pos             (12U)
N#define RCC_APB2RSTR_SPI1RST_Msk             (0x1UL << RCC_APB2RSTR_SPI1RST_Pos) /*!< 0x00001000 */
N#define RCC_APB2RSTR_SPI1RST                 RCC_APB2RSTR_SPI1RST_Msk
N#define RCC_APB2RSTR_USART1RST_Pos           (14U)
N#define RCC_APB2RSTR_USART1RST_Msk           (0x1UL << RCC_APB2RSTR_USART1RST_Pos) /*!< 0x00004000 */
N#define RCC_APB2RSTR_USART1RST               RCC_APB2RSTR_USART1RST_Msk
N#define RCC_APB2RSTR_TIM15RST_Pos            (16U)
N#define RCC_APB2RSTR_TIM15RST_Msk            (0x1UL << RCC_APB2RSTR_TIM15RST_Pos) /*!< 0x00010000 */
N#define RCC_APB2RSTR_TIM15RST                RCC_APB2RSTR_TIM15RST_Msk
N#define RCC_APB2RSTR_TIM16RST_Pos            (17U)
N#define RCC_APB2RSTR_TIM16RST_Msk            (0x1UL << RCC_APB2RSTR_TIM16RST_Pos) /*!< 0x00020000 */
N#define RCC_APB2RSTR_TIM16RST                RCC_APB2RSTR_TIM16RST_Msk
N#define RCC_APB2RSTR_SAI1RST_Pos             (21U)
N#define RCC_APB2RSTR_SAI1RST_Msk             (0x1UL << RCC_APB2RSTR_SAI1RST_Pos) /*!< 0x00200000 */
N#define RCC_APB2RSTR_SAI1RST                 RCC_APB2RSTR_SAI1RST_Msk
N
N/********************  Bit definition for RCC_AHB1ENR register  ***************/
N#define RCC_AHB1ENR_DMA1EN_Pos               (0U)
N#define RCC_AHB1ENR_DMA1EN_Msk               (0x1UL << RCC_AHB1ENR_DMA1EN_Pos) /*!< 0x00000001 */
N#define RCC_AHB1ENR_DMA1EN                   RCC_AHB1ENR_DMA1EN_Msk
N#define RCC_AHB1ENR_DMA2EN_Pos               (1U)
N#define RCC_AHB1ENR_DMA2EN_Msk               (0x1UL << RCC_AHB1ENR_DMA2EN_Pos) /*!< 0x00000002 */
N#define RCC_AHB1ENR_DMA2EN                   RCC_AHB1ENR_DMA2EN_Msk
N#define RCC_AHB1ENR_FLASHEN_Pos              (8U)
N#define RCC_AHB1ENR_FLASHEN_Msk              (0x1UL << RCC_AHB1ENR_FLASHEN_Pos) /*!< 0x00000100 */
N#define RCC_AHB1ENR_FLASHEN                  RCC_AHB1ENR_FLASHEN_Msk
N#define RCC_AHB1ENR_CRCEN_Pos                (12U)
N#define RCC_AHB1ENR_CRCEN_Msk                (0x1UL << RCC_AHB1ENR_CRCEN_Pos)  /*!< 0x00001000 */
N#define RCC_AHB1ENR_CRCEN                    RCC_AHB1ENR_CRCEN_Msk
N#define RCC_AHB1ENR_TSCEN_Pos                (16U)
N#define RCC_AHB1ENR_TSCEN_Msk                (0x1UL << RCC_AHB1ENR_TSCEN_Pos)  /*!< 0x00010000 */
N#define RCC_AHB1ENR_TSCEN                    RCC_AHB1ENR_TSCEN_Msk
N
N/********************  Bit definition for RCC_AHB2ENR register  ***************/
N#define RCC_AHB2ENR_GPIOAEN_Pos              (0U)
N#define RCC_AHB2ENR_GPIOAEN_Msk              (0x1UL << RCC_AHB2ENR_GPIOAEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB2ENR_GPIOAEN                  RCC_AHB2ENR_GPIOAEN_Msk
N#define RCC_AHB2ENR_GPIOBEN_Pos              (1U)
N#define RCC_AHB2ENR_GPIOBEN_Msk              (0x1UL << RCC_AHB2ENR_GPIOBEN_Pos) /*!< 0x00000002 */
N#define RCC_AHB2ENR_GPIOBEN                  RCC_AHB2ENR_GPIOBEN_Msk
N#define RCC_AHB2ENR_GPIOCEN_Pos              (2U)
N#define RCC_AHB2ENR_GPIOCEN_Msk              (0x1UL << RCC_AHB2ENR_GPIOCEN_Pos) /*!< 0x00000004 */
N#define RCC_AHB2ENR_GPIOCEN                  RCC_AHB2ENR_GPIOCEN_Msk
N#define RCC_AHB2ENR_GPIODEN_Pos              (3U)
N#define RCC_AHB2ENR_GPIODEN_Msk              (0x1UL << RCC_AHB2ENR_GPIODEN_Pos) /*!< 0x00000008 */
N#define RCC_AHB2ENR_GPIODEN                  RCC_AHB2ENR_GPIODEN_Msk
N#define RCC_AHB2ENR_GPIOEEN_Pos              (4U)
N#define RCC_AHB2ENR_GPIOEEN_Msk              (0x1UL << RCC_AHB2ENR_GPIOEEN_Pos) /*!< 0x00000010 */
N#define RCC_AHB2ENR_GPIOEEN                  RCC_AHB2ENR_GPIOEEN_Msk
N#define RCC_AHB2ENR_GPIOHEN_Pos              (7U)
N#define RCC_AHB2ENR_GPIOHEN_Msk              (0x1UL << RCC_AHB2ENR_GPIOHEN_Pos) /*!< 0x00000080 */
N#define RCC_AHB2ENR_GPIOHEN                  RCC_AHB2ENR_GPIOHEN_Msk
N#define RCC_AHB2ENR_ADCEN_Pos                (13U)
N#define RCC_AHB2ENR_ADCEN_Msk                (0x1UL << RCC_AHB2ENR_ADCEN_Pos)  /*!< 0x00002000 */
N#define RCC_AHB2ENR_ADCEN                    RCC_AHB2ENR_ADCEN_Msk
N#define RCC_AHB2ENR_RNGEN_Pos                (18U)
N#define RCC_AHB2ENR_RNGEN_Msk                (0x1UL << RCC_AHB2ENR_RNGEN_Pos)  /*!< 0x00040000 */
N#define RCC_AHB2ENR_RNGEN                    RCC_AHB2ENR_RNGEN_Msk
N
N/********************  Bit definition for RCC_AHB3ENR register  ***************/
N#define RCC_AHB3ENR_QSPIEN_Pos               (8U)
N#define RCC_AHB3ENR_QSPIEN_Msk               (0x1UL << RCC_AHB3ENR_QSPIEN_Pos) /*!< 0x00000100 */
N#define RCC_AHB3ENR_QSPIEN                   RCC_AHB3ENR_QSPIEN_Msk
N
N/********************  Bit definition for RCC_APB1ENR1 register  ***************/
N#define RCC_APB1ENR1_TIM2EN_Pos              (0U)
N#define RCC_APB1ENR1_TIM2EN_Msk              (0x1UL << RCC_APB1ENR1_TIM2EN_Pos) /*!< 0x00000001 */
N#define RCC_APB1ENR1_TIM2EN                  RCC_APB1ENR1_TIM2EN_Msk
N#define RCC_APB1ENR1_TIM6EN_Pos              (4U)
N#define RCC_APB1ENR1_TIM6EN_Msk              (0x1UL << RCC_APB1ENR1_TIM6EN_Pos) /*!< 0x00000010 */
N#define RCC_APB1ENR1_TIM6EN                  RCC_APB1ENR1_TIM6EN_Msk
N#define RCC_APB1ENR1_TIM7EN_Pos              (5U)
N#define RCC_APB1ENR1_TIM7EN_Msk              (0x1UL << RCC_APB1ENR1_TIM7EN_Pos) /*!< 0x00000020 */
N#define RCC_APB1ENR1_TIM7EN                  RCC_APB1ENR1_TIM7EN_Msk
N#define RCC_APB1ENR1_RTCAPBEN_Pos            (10U)
N#define RCC_APB1ENR1_RTCAPBEN_Msk            (0x1UL << RCC_APB1ENR1_RTCAPBEN_Pos) /*!< 0x00000400 */
N#define RCC_APB1ENR1_RTCAPBEN                RCC_APB1ENR1_RTCAPBEN_Msk
N#define RCC_APB1ENR1_WWDGEN_Pos              (11U)
N#define RCC_APB1ENR1_WWDGEN_Msk              (0x1UL << RCC_APB1ENR1_WWDGEN_Pos) /*!< 0x00000800 */
N#define RCC_APB1ENR1_WWDGEN                  RCC_APB1ENR1_WWDGEN_Msk
N#define RCC_APB1ENR1_SPI2EN_Pos              (14U)
N#define RCC_APB1ENR1_SPI2EN_Msk              (0x1UL << RCC_APB1ENR1_SPI2EN_Pos) /*!< 0x00004000 */
N#define RCC_APB1ENR1_SPI2EN                  RCC_APB1ENR1_SPI2EN_Msk
N#define RCC_APB1ENR1_SPI3EN_Pos              (15U)
N#define RCC_APB1ENR1_SPI3EN_Msk              (0x1UL << RCC_APB1ENR1_SPI3EN_Pos) /*!< 0x00008000 */
N#define RCC_APB1ENR1_SPI3EN                  RCC_APB1ENR1_SPI3EN_Msk
N#define RCC_APB1ENR1_USART2EN_Pos            (17U)
N#define RCC_APB1ENR1_USART2EN_Msk            (0x1UL << RCC_APB1ENR1_USART2EN_Pos) /*!< 0x00020000 */
N#define RCC_APB1ENR1_USART2EN                RCC_APB1ENR1_USART2EN_Msk
N#define RCC_APB1ENR1_USART3EN_Pos            (18U)
N#define RCC_APB1ENR1_USART3EN_Msk            (0x1UL << RCC_APB1ENR1_USART3EN_Pos) /*!< 0x00040000 */
N#define RCC_APB1ENR1_USART3EN                RCC_APB1ENR1_USART3EN_Msk
N#define RCC_APB1ENR1_I2C1EN_Pos              (21U)
N#define RCC_APB1ENR1_I2C1EN_Msk              (0x1UL << RCC_APB1ENR1_I2C1EN_Pos) /*!< 0x00200000 */
N#define RCC_APB1ENR1_I2C1EN                  RCC_APB1ENR1_I2C1EN_Msk
N#define RCC_APB1ENR1_I2C2EN_Pos              (22U)
N#define RCC_APB1ENR1_I2C2EN_Msk              (0x1UL << RCC_APB1ENR1_I2C2EN_Pos) /*!< 0x00400000 */
N#define RCC_APB1ENR1_I2C2EN                  RCC_APB1ENR1_I2C2EN_Msk
N#define RCC_APB1ENR1_I2C3EN_Pos              (23U)
N#define RCC_APB1ENR1_I2C3EN_Msk              (0x1UL << RCC_APB1ENR1_I2C3EN_Pos) /*!< 0x00800000 */
N#define RCC_APB1ENR1_I2C3EN                  RCC_APB1ENR1_I2C3EN_Msk
N#define RCC_APB1ENR1_CRSEN_Pos               (24U)
N#define RCC_APB1ENR1_CRSEN_Msk               (0x1UL << RCC_APB1ENR1_CRSEN_Pos) /*!< 0x01000000 */
N#define RCC_APB1ENR1_CRSEN                   RCC_APB1ENR1_CRSEN_Msk
N#define RCC_APB1ENR1_CAN1EN_Pos              (25U)
N#define RCC_APB1ENR1_CAN1EN_Msk              (0x1UL << RCC_APB1ENR1_CAN1EN_Pos) /*!< 0x02000000 */
N#define RCC_APB1ENR1_CAN1EN                  RCC_APB1ENR1_CAN1EN_Msk
N#define RCC_APB1ENR1_PWREN_Pos               (28U)
N#define RCC_APB1ENR1_PWREN_Msk               (0x1UL << RCC_APB1ENR1_PWREN_Pos) /*!< 0x10000000 */
N#define RCC_APB1ENR1_PWREN                   RCC_APB1ENR1_PWREN_Msk
N#define RCC_APB1ENR1_DAC1EN_Pos              (29U)
N#define RCC_APB1ENR1_DAC1EN_Msk              (0x1UL << RCC_APB1ENR1_DAC1EN_Pos) /*!< 0x20000000 */
N#define RCC_APB1ENR1_DAC1EN                  RCC_APB1ENR1_DAC1EN_Msk
N#define RCC_APB1ENR1_OPAMPEN_Pos             (30U)
N#define RCC_APB1ENR1_OPAMPEN_Msk             (0x1UL << RCC_APB1ENR1_OPAMPEN_Pos) /*!< 0x40000000 */
N#define RCC_APB1ENR1_OPAMPEN                 RCC_APB1ENR1_OPAMPEN_Msk
N#define RCC_APB1ENR1_LPTIM1EN_Pos            (31U)
N#define RCC_APB1ENR1_LPTIM1EN_Msk            (0x1UL << RCC_APB1ENR1_LPTIM1EN_Pos) /*!< 0x80000000 */
N#define RCC_APB1ENR1_LPTIM1EN                RCC_APB1ENR1_LPTIM1EN_Msk
N
N/********************  Bit definition for RCC_APB1RSTR2 register  **************/
N#define RCC_APB1ENR2_LPUART1EN_Pos           (0U)
N#define RCC_APB1ENR2_LPUART1EN_Msk           (0x1UL << RCC_APB1ENR2_LPUART1EN_Pos) /*!< 0x00000001 */
N#define RCC_APB1ENR2_LPUART1EN               RCC_APB1ENR2_LPUART1EN_Msk
N#define RCC_APB1ENR2_SWPMI1EN_Pos            (2U)
N#define RCC_APB1ENR2_SWPMI1EN_Msk            (0x1UL << RCC_APB1ENR2_SWPMI1EN_Pos) /*!< 0x00000004 */
N#define RCC_APB1ENR2_SWPMI1EN                RCC_APB1ENR2_SWPMI1EN_Msk
N#define RCC_APB1ENR2_LPTIM2EN_Pos            (5U)
N#define RCC_APB1ENR2_LPTIM2EN_Msk            (0x1UL << RCC_APB1ENR2_LPTIM2EN_Pos) /*!< 0x00000020 */
N#define RCC_APB1ENR2_LPTIM2EN                RCC_APB1ENR2_LPTIM2EN_Msk
N
N/********************  Bit definition for RCC_APB2ENR register  ***************/
N#define RCC_APB2ENR_SYSCFGEN_Pos             (0U)
N#define RCC_APB2ENR_SYSCFGEN_Msk             (0x1UL << RCC_APB2ENR_SYSCFGEN_Pos) /*!< 0x00000001 */
N#define RCC_APB2ENR_SYSCFGEN                 RCC_APB2ENR_SYSCFGEN_Msk
N#define RCC_APB2ENR_FWEN_Pos                 (7U)
N#define RCC_APB2ENR_FWEN_Msk                 (0x1UL << RCC_APB2ENR_FWEN_Pos)   /*!< 0x00000080 */
N#define RCC_APB2ENR_FWEN                     RCC_APB2ENR_FWEN_Msk
N#define RCC_APB2ENR_SDMMC1EN_Pos             (10U)
N#define RCC_APB2ENR_SDMMC1EN_Msk             (0x1UL << RCC_APB2ENR_SDMMC1EN_Pos) /*!< 0x00000400 */
N#define RCC_APB2ENR_SDMMC1EN                 RCC_APB2ENR_SDMMC1EN_Msk
N#define RCC_APB2ENR_TIM1EN_Pos               (11U)
N#define RCC_APB2ENR_TIM1EN_Msk               (0x1UL << RCC_APB2ENR_TIM1EN_Pos) /*!< 0x00000800 */
N#define RCC_APB2ENR_TIM1EN                   RCC_APB2ENR_TIM1EN_Msk
N#define RCC_APB2ENR_SPI1EN_Pos               (12U)
N#define RCC_APB2ENR_SPI1EN_Msk               (0x1UL << RCC_APB2ENR_SPI1EN_Pos) /*!< 0x00001000 */
N#define RCC_APB2ENR_SPI1EN                   RCC_APB2ENR_SPI1EN_Msk
N#define RCC_APB2ENR_USART1EN_Pos             (14U)
N#define RCC_APB2ENR_USART1EN_Msk             (0x1UL << RCC_APB2ENR_USART1EN_Pos) /*!< 0x00004000 */
N#define RCC_APB2ENR_USART1EN                 RCC_APB2ENR_USART1EN_Msk
N#define RCC_APB2ENR_TIM15EN_Pos              (16U)
N#define RCC_APB2ENR_TIM15EN_Msk              (0x1UL << RCC_APB2ENR_TIM15EN_Pos) /*!< 0x00010000 */
N#define RCC_APB2ENR_TIM15EN                  RCC_APB2ENR_TIM15EN_Msk
N#define RCC_APB2ENR_TIM16EN_Pos              (17U)
N#define RCC_APB2ENR_TIM16EN_Msk              (0x1UL << RCC_APB2ENR_TIM16EN_Pos) /*!< 0x00020000 */
N#define RCC_APB2ENR_TIM16EN                  RCC_APB2ENR_TIM16EN_Msk
N#define RCC_APB2ENR_SAI1EN_Pos               (21U)
N#define RCC_APB2ENR_SAI1EN_Msk               (0x1UL << RCC_APB2ENR_SAI1EN_Pos) /*!< 0x00200000 */
N#define RCC_APB2ENR_SAI1EN                   RCC_APB2ENR_SAI1EN_Msk
N
N/********************  Bit definition for RCC_AHB1SMENR register  ***************/
N#define RCC_AHB1SMENR_DMA1SMEN_Pos           (0U)
N#define RCC_AHB1SMENR_DMA1SMEN_Msk           (0x1UL << RCC_AHB1SMENR_DMA1SMEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB1SMENR_DMA1SMEN               RCC_AHB1SMENR_DMA1SMEN_Msk
N#define RCC_AHB1SMENR_DMA2SMEN_Pos           (1U)
N#define RCC_AHB1SMENR_DMA2SMEN_Msk           (0x1UL << RCC_AHB1SMENR_DMA2SMEN_Pos) /*!< 0x00000002 */
N#define RCC_AHB1SMENR_DMA2SMEN               RCC_AHB1SMENR_DMA2SMEN_Msk
N#define RCC_AHB1SMENR_FLASHSMEN_Pos          (8U)
N#define RCC_AHB1SMENR_FLASHSMEN_Msk          (0x1UL << RCC_AHB1SMENR_FLASHSMEN_Pos) /*!< 0x00000100 */
N#define RCC_AHB1SMENR_FLASHSMEN              RCC_AHB1SMENR_FLASHSMEN_Msk
N#define RCC_AHB1SMENR_SRAM1SMEN_Pos          (9U)
N#define RCC_AHB1SMENR_SRAM1SMEN_Msk          (0x1UL << RCC_AHB1SMENR_SRAM1SMEN_Pos) /*!< 0x00000200 */
N#define RCC_AHB1SMENR_SRAM1SMEN              RCC_AHB1SMENR_SRAM1SMEN_Msk
N#define RCC_AHB1SMENR_CRCSMEN_Pos            (12U)
N#define RCC_AHB1SMENR_CRCSMEN_Msk            (0x1UL << RCC_AHB1SMENR_CRCSMEN_Pos) /*!< 0x00001000 */
N#define RCC_AHB1SMENR_CRCSMEN                RCC_AHB1SMENR_CRCSMEN_Msk
N#define RCC_AHB1SMENR_TSCSMEN_Pos            (16U)
N#define RCC_AHB1SMENR_TSCSMEN_Msk            (0x1UL << RCC_AHB1SMENR_TSCSMEN_Pos) /*!< 0x00010000 */
N#define RCC_AHB1SMENR_TSCSMEN                RCC_AHB1SMENR_TSCSMEN_Msk
N
N/********************  Bit definition for RCC_AHB2SMENR register  *************/
N#define RCC_AHB2SMENR_GPIOASMEN_Pos          (0U)
N#define RCC_AHB2SMENR_GPIOASMEN_Msk          (0x1UL << RCC_AHB2SMENR_GPIOASMEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB2SMENR_GPIOASMEN              RCC_AHB2SMENR_GPIOASMEN_Msk
N#define RCC_AHB2SMENR_GPIOBSMEN_Pos          (1U)
N#define RCC_AHB2SMENR_GPIOBSMEN_Msk          (0x1UL << RCC_AHB2SMENR_GPIOBSMEN_Pos) /*!< 0x00000002 */
N#define RCC_AHB2SMENR_GPIOBSMEN              RCC_AHB2SMENR_GPIOBSMEN_Msk
N#define RCC_AHB2SMENR_GPIOCSMEN_Pos          (2U)
N#define RCC_AHB2SMENR_GPIOCSMEN_Msk          (0x1UL << RCC_AHB2SMENR_GPIOCSMEN_Pos) /*!< 0x00000004 */
N#define RCC_AHB2SMENR_GPIOCSMEN              RCC_AHB2SMENR_GPIOCSMEN_Msk
N#define RCC_AHB2SMENR_GPIODSMEN_Pos          (3U)
N#define RCC_AHB2SMENR_GPIODSMEN_Msk          (0x1UL << RCC_AHB2SMENR_GPIODSMEN_Pos) /*!< 0x00000008 */
N#define RCC_AHB2SMENR_GPIODSMEN              RCC_AHB2SMENR_GPIODSMEN_Msk
N#define RCC_AHB2SMENR_GPIOESMEN_Pos          (4U)
N#define RCC_AHB2SMENR_GPIOESMEN_Msk          (0x1UL << RCC_AHB2SMENR_GPIOESMEN_Pos) /*!< 0x00000010 */
N#define RCC_AHB2SMENR_GPIOESMEN              RCC_AHB2SMENR_GPIOESMEN_Msk
N#define RCC_AHB2SMENR_GPIOHSMEN_Pos          (7U)
N#define RCC_AHB2SMENR_GPIOHSMEN_Msk          (0x1UL << RCC_AHB2SMENR_GPIOHSMEN_Pos) /*!< 0x00000080 */
N#define RCC_AHB2SMENR_GPIOHSMEN              RCC_AHB2SMENR_GPIOHSMEN_Msk
N#define RCC_AHB2SMENR_SRAM2SMEN_Pos          (9U)
N#define RCC_AHB2SMENR_SRAM2SMEN_Msk          (0x1UL << RCC_AHB2SMENR_SRAM2SMEN_Pos) /*!< 0x00000200 */
N#define RCC_AHB2SMENR_SRAM2SMEN              RCC_AHB2SMENR_SRAM2SMEN_Msk
N#define RCC_AHB2SMENR_ADCSMEN_Pos            (13U)
N#define RCC_AHB2SMENR_ADCSMEN_Msk            (0x1UL << RCC_AHB2SMENR_ADCSMEN_Pos) /*!< 0x00002000 */
N#define RCC_AHB2SMENR_ADCSMEN                RCC_AHB2SMENR_ADCSMEN_Msk
N#define RCC_AHB2SMENR_RNGSMEN_Pos            (18U)
N#define RCC_AHB2SMENR_RNGSMEN_Msk            (0x1UL << RCC_AHB2SMENR_RNGSMEN_Pos) /*!< 0x00040000 */
N#define RCC_AHB2SMENR_RNGSMEN                RCC_AHB2SMENR_RNGSMEN_Msk
N
N/********************  Bit definition for RCC_AHB3SMENR register  *************/
N#define RCC_AHB3SMENR_QSPISMEN_Pos           (8U)
N#define RCC_AHB3SMENR_QSPISMEN_Msk           (0x1UL << RCC_AHB3SMENR_QSPISMEN_Pos) /*!< 0x00000100 */
N#define RCC_AHB3SMENR_QSPISMEN               RCC_AHB3SMENR_QSPISMEN_Msk
N
N/********************  Bit definition for RCC_APB1SMENR1 register  *************/
N#define RCC_APB1SMENR1_TIM2SMEN_Pos          (0U)
N#define RCC_APB1SMENR1_TIM2SMEN_Msk          (0x1UL << RCC_APB1SMENR1_TIM2SMEN_Pos) /*!< 0x00000001 */
N#define RCC_APB1SMENR1_TIM2SMEN              RCC_APB1SMENR1_TIM2SMEN_Msk
N#define RCC_APB1SMENR1_TIM6SMEN_Pos          (4U)
N#define RCC_APB1SMENR1_TIM6SMEN_Msk          (0x1UL << RCC_APB1SMENR1_TIM6SMEN_Pos) /*!< 0x00000010 */
N#define RCC_APB1SMENR1_TIM6SMEN              RCC_APB1SMENR1_TIM6SMEN_Msk
N#define RCC_APB1SMENR1_TIM7SMEN_Pos          (5U)
N#define RCC_APB1SMENR1_TIM7SMEN_Msk          (0x1UL << RCC_APB1SMENR1_TIM7SMEN_Pos) /*!< 0x00000020 */
N#define RCC_APB1SMENR1_TIM7SMEN              RCC_APB1SMENR1_TIM7SMEN_Msk
N#define RCC_APB1SMENR1_RTCAPBSMEN_Pos        (10U)
N#define RCC_APB1SMENR1_RTCAPBSMEN_Msk        (0x1UL << RCC_APB1SMENR1_RTCAPBSMEN_Pos) /*!< 0x00000400 */
N#define RCC_APB1SMENR1_RTCAPBSMEN            RCC_APB1SMENR1_RTCAPBSMEN_Msk
N#define RCC_APB1SMENR1_WWDGSMEN_Pos          (11U)
N#define RCC_APB1SMENR1_WWDGSMEN_Msk          (0x1UL << RCC_APB1SMENR1_WWDGSMEN_Pos) /*!< 0x00000800 */
N#define RCC_APB1SMENR1_WWDGSMEN              RCC_APB1SMENR1_WWDGSMEN_Msk
N#define RCC_APB1SMENR1_SPI2SMEN_Pos          (14U)
N#define RCC_APB1SMENR1_SPI2SMEN_Msk          (0x1UL << RCC_APB1SMENR1_SPI2SMEN_Pos) /*!< 0x00004000 */
N#define RCC_APB1SMENR1_SPI2SMEN              RCC_APB1SMENR1_SPI2SMEN_Msk
N#define RCC_APB1SMENR1_SPI3SMEN_Pos          (15U)
N#define RCC_APB1SMENR1_SPI3SMEN_Msk          (0x1UL << RCC_APB1SMENR1_SPI3SMEN_Pos) /*!< 0x00008000 */
N#define RCC_APB1SMENR1_SPI3SMEN              RCC_APB1SMENR1_SPI3SMEN_Msk
N#define RCC_APB1SMENR1_USART2SMEN_Pos        (17U)
N#define RCC_APB1SMENR1_USART2SMEN_Msk        (0x1UL << RCC_APB1SMENR1_USART2SMEN_Pos) /*!< 0x00020000 */
N#define RCC_APB1SMENR1_USART2SMEN            RCC_APB1SMENR1_USART2SMEN_Msk
N#define RCC_APB1SMENR1_USART3SMEN_Pos        (18U)
N#define RCC_APB1SMENR1_USART3SMEN_Msk        (0x1UL << RCC_APB1SMENR1_USART3SMEN_Pos) /*!< 0x00040000 */
N#define RCC_APB1SMENR1_USART3SMEN            RCC_APB1SMENR1_USART3SMEN_Msk
N#define RCC_APB1SMENR1_I2C1SMEN_Pos          (21U)
N#define RCC_APB1SMENR1_I2C1SMEN_Msk          (0x1UL << RCC_APB1SMENR1_I2C1SMEN_Pos) /*!< 0x00200000 */
N#define RCC_APB1SMENR1_I2C1SMEN              RCC_APB1SMENR1_I2C1SMEN_Msk
N#define RCC_APB1SMENR1_I2C2SMEN_Pos          (22U)
N#define RCC_APB1SMENR1_I2C2SMEN_Msk          (0x1UL << RCC_APB1SMENR1_I2C2SMEN_Pos) /*!< 0x00400000 */
N#define RCC_APB1SMENR1_I2C2SMEN              RCC_APB1SMENR1_I2C2SMEN_Msk
N#define RCC_APB1SMENR1_I2C3SMEN_Pos          (23U)
N#define RCC_APB1SMENR1_I2C3SMEN_Msk          (0x1UL << RCC_APB1SMENR1_I2C3SMEN_Pos) /*!< 0x00800000 */
N#define RCC_APB1SMENR1_I2C3SMEN              RCC_APB1SMENR1_I2C3SMEN_Msk
N#define RCC_APB1SMENR1_CRSSMEN_Pos           (24U)
N#define RCC_APB1SMENR1_CRSSMEN_Msk           (0x1UL << RCC_APB1SMENR1_CRSSMEN_Pos) /*!< 0x01000000 */
N#define RCC_APB1SMENR1_CRSSMEN               RCC_APB1SMENR1_CRSSMEN_Msk
N#define RCC_APB1SMENR1_CAN1SMEN_Pos          (25U)
N#define RCC_APB1SMENR1_CAN1SMEN_Msk          (0x1UL << RCC_APB1SMENR1_CAN1SMEN_Pos) /*!< 0x02000000 */
N#define RCC_APB1SMENR1_CAN1SMEN              RCC_APB1SMENR1_CAN1SMEN_Msk
N#define RCC_APB1SMENR1_PWRSMEN_Pos           (28U)
N#define RCC_APB1SMENR1_PWRSMEN_Msk           (0x1UL << RCC_APB1SMENR1_PWRSMEN_Pos) /*!< 0x10000000 */
N#define RCC_APB1SMENR1_PWRSMEN               RCC_APB1SMENR1_PWRSMEN_Msk
N#define RCC_APB1SMENR1_DAC1SMEN_Pos          (29U)
N#define RCC_APB1SMENR1_DAC1SMEN_Msk          (0x1UL << RCC_APB1SMENR1_DAC1SMEN_Pos) /*!< 0x20000000 */
N#define RCC_APB1SMENR1_DAC1SMEN              RCC_APB1SMENR1_DAC1SMEN_Msk
N#define RCC_APB1SMENR1_OPAMPSMEN_Pos         (30U)
N#define RCC_APB1SMENR1_OPAMPSMEN_Msk         (0x1UL << RCC_APB1SMENR1_OPAMPSMEN_Pos) /*!< 0x40000000 */
N#define RCC_APB1SMENR1_OPAMPSMEN             RCC_APB1SMENR1_OPAMPSMEN_Msk
N#define RCC_APB1SMENR1_LPTIM1SMEN_Pos        (31U)
N#define RCC_APB1SMENR1_LPTIM1SMEN_Msk        (0x1UL << RCC_APB1SMENR1_LPTIM1SMEN_Pos) /*!< 0x80000000 */
N#define RCC_APB1SMENR1_LPTIM1SMEN            RCC_APB1SMENR1_LPTIM1SMEN_Msk
N
N/********************  Bit definition for RCC_APB1SMENR2 register  *************/
N#define RCC_APB1SMENR2_LPUART1SMEN_Pos       (0U)
N#define RCC_APB1SMENR2_LPUART1SMEN_Msk       (0x1UL << RCC_APB1SMENR2_LPUART1SMEN_Pos) /*!< 0x00000001 */
N#define RCC_APB1SMENR2_LPUART1SMEN           RCC_APB1SMENR2_LPUART1SMEN_Msk
N#define RCC_APB1SMENR2_SWPMI1SMEN_Pos        (2U)
N#define RCC_APB1SMENR2_SWPMI1SMEN_Msk        (0x1UL << RCC_APB1SMENR2_SWPMI1SMEN_Pos) /*!< 0x00000004 */
N#define RCC_APB1SMENR2_SWPMI1SMEN            RCC_APB1SMENR2_SWPMI1SMEN_Msk
N#define RCC_APB1SMENR2_LPTIM2SMEN_Pos        (5U)
N#define RCC_APB1SMENR2_LPTIM2SMEN_Msk        (0x1UL << RCC_APB1SMENR2_LPTIM2SMEN_Pos) /*!< 0x00000020 */
N#define RCC_APB1SMENR2_LPTIM2SMEN            RCC_APB1SMENR2_LPTIM2SMEN_Msk
N
N/********************  Bit definition for RCC_APB2SMENR register  *************/
N#define RCC_APB2SMENR_SYSCFGSMEN_Pos         (0U)
N#define RCC_APB2SMENR_SYSCFGSMEN_Msk         (0x1UL << RCC_APB2SMENR_SYSCFGSMEN_Pos) /*!< 0x00000001 */
N#define RCC_APB2SMENR_SYSCFGSMEN             RCC_APB2SMENR_SYSCFGSMEN_Msk
N#define RCC_APB2SMENR_SDMMC1SMEN_Pos         (10U)
N#define RCC_APB2SMENR_SDMMC1SMEN_Msk         (0x1UL << RCC_APB2SMENR_SDMMC1SMEN_Pos) /*!< 0x00000400 */
N#define RCC_APB2SMENR_SDMMC1SMEN             RCC_APB2SMENR_SDMMC1SMEN_Msk
N#define RCC_APB2SMENR_TIM1SMEN_Pos           (11U)
N#define RCC_APB2SMENR_TIM1SMEN_Msk           (0x1UL << RCC_APB2SMENR_TIM1SMEN_Pos) /*!< 0x00000800 */
N#define RCC_APB2SMENR_TIM1SMEN               RCC_APB2SMENR_TIM1SMEN_Msk
N#define RCC_APB2SMENR_SPI1SMEN_Pos           (12U)
N#define RCC_APB2SMENR_SPI1SMEN_Msk           (0x1UL << RCC_APB2SMENR_SPI1SMEN_Pos) /*!< 0x00001000 */
N#define RCC_APB2SMENR_SPI1SMEN               RCC_APB2SMENR_SPI1SMEN_Msk
N#define RCC_APB2SMENR_USART1SMEN_Pos         (14U)
N#define RCC_APB2SMENR_USART1SMEN_Msk         (0x1UL << RCC_APB2SMENR_USART1SMEN_Pos) /*!< 0x00004000 */
N#define RCC_APB2SMENR_USART1SMEN             RCC_APB2SMENR_USART1SMEN_Msk
N#define RCC_APB2SMENR_TIM15SMEN_Pos          (16U)
N#define RCC_APB2SMENR_TIM15SMEN_Msk          (0x1UL << RCC_APB2SMENR_TIM15SMEN_Pos) /*!< 0x00010000 */
N#define RCC_APB2SMENR_TIM15SMEN              RCC_APB2SMENR_TIM15SMEN_Msk
N#define RCC_APB2SMENR_TIM16SMEN_Pos          (17U)
N#define RCC_APB2SMENR_TIM16SMEN_Msk          (0x1UL << RCC_APB2SMENR_TIM16SMEN_Pos) /*!< 0x00020000 */
N#define RCC_APB2SMENR_TIM16SMEN              RCC_APB2SMENR_TIM16SMEN_Msk
N#define RCC_APB2SMENR_SAI1SMEN_Pos           (21U)
N#define RCC_APB2SMENR_SAI1SMEN_Msk           (0x1UL << RCC_APB2SMENR_SAI1SMEN_Pos) /*!< 0x00200000 */
N#define RCC_APB2SMENR_SAI1SMEN               RCC_APB2SMENR_SAI1SMEN_Msk
N
N/********************  Bit definition for RCC_CCIPR register  ******************/
N#define RCC_CCIPR_USART1SEL_Pos              (0U)
N#define RCC_CCIPR_USART1SEL_Msk              (0x3UL << RCC_CCIPR_USART1SEL_Pos) /*!< 0x00000003 */
N#define RCC_CCIPR_USART1SEL                  RCC_CCIPR_USART1SEL_Msk
N#define RCC_CCIPR_USART1SEL_0                (0x1UL << RCC_CCIPR_USART1SEL_Pos) /*!< 0x00000001 */
N#define RCC_CCIPR_USART1SEL_1                (0x2UL << RCC_CCIPR_USART1SEL_Pos) /*!< 0x00000002 */
N
N#define RCC_CCIPR_USART2SEL_Pos              (2U)
N#define RCC_CCIPR_USART2SEL_Msk              (0x3UL << RCC_CCIPR_USART2SEL_Pos) /*!< 0x0000000C */
N#define RCC_CCIPR_USART2SEL                  RCC_CCIPR_USART2SEL_Msk
N#define RCC_CCIPR_USART2SEL_0                (0x1UL << RCC_CCIPR_USART2SEL_Pos) /*!< 0x00000004 */
N#define RCC_CCIPR_USART2SEL_1                (0x2UL << RCC_CCIPR_USART2SEL_Pos) /*!< 0x00000008 */
N
N#define RCC_CCIPR_USART3SEL_Pos              (4U)
N#define RCC_CCIPR_USART3SEL_Msk              (0x3UL << RCC_CCIPR_USART3SEL_Pos) /*!< 0x00000030 */
N#define RCC_CCIPR_USART3SEL                  RCC_CCIPR_USART3SEL_Msk
N#define RCC_CCIPR_USART3SEL_0                (0x1UL << RCC_CCIPR_USART3SEL_Pos) /*!< 0x00000010 */
N#define RCC_CCIPR_USART3SEL_1                (0x2UL << RCC_CCIPR_USART3SEL_Pos) /*!< 0x00000020 */
N
N#define RCC_CCIPR_LPUART1SEL_Pos             (10U)
N#define RCC_CCIPR_LPUART1SEL_Msk             (0x3UL << RCC_CCIPR_LPUART1SEL_Pos) /*!< 0x00000C00 */
N#define RCC_CCIPR_LPUART1SEL                 RCC_CCIPR_LPUART1SEL_Msk
N#define RCC_CCIPR_LPUART1SEL_0               (0x1UL << RCC_CCIPR_LPUART1SEL_Pos) /*!< 0x00000400 */
N#define RCC_CCIPR_LPUART1SEL_1               (0x2UL << RCC_CCIPR_LPUART1SEL_Pos) /*!< 0x00000800 */
N
N#define RCC_CCIPR_I2C1SEL_Pos                (12U)
N#define RCC_CCIPR_I2C1SEL_Msk                (0x3UL << RCC_CCIPR_I2C1SEL_Pos)  /*!< 0x00003000 */
N#define RCC_CCIPR_I2C1SEL                    RCC_CCIPR_I2C1SEL_Msk
N#define RCC_CCIPR_I2C1SEL_0                  (0x1UL << RCC_CCIPR_I2C1SEL_Pos)  /*!< 0x00001000 */
N#define RCC_CCIPR_I2C1SEL_1                  (0x2UL << RCC_CCIPR_I2C1SEL_Pos)  /*!< 0x00002000 */
N
N#define RCC_CCIPR_I2C2SEL_Pos                (14U)
N#define RCC_CCIPR_I2C2SEL_Msk                (0x3UL << RCC_CCIPR_I2C2SEL_Pos)  /*!< 0x0000C000 */
N#define RCC_CCIPR_I2C2SEL                    RCC_CCIPR_I2C2SEL_Msk
N#define RCC_CCIPR_I2C2SEL_0                  (0x1UL << RCC_CCIPR_I2C2SEL_Pos)  /*!< 0x00004000 */
N#define RCC_CCIPR_I2C2SEL_1                  (0x2UL << RCC_CCIPR_I2C2SEL_Pos)  /*!< 0x00008000 */
N
N#define RCC_CCIPR_I2C3SEL_Pos                (16U)
N#define RCC_CCIPR_I2C3SEL_Msk                (0x3UL << RCC_CCIPR_I2C3SEL_Pos)  /*!< 0x00030000 */
N#define RCC_CCIPR_I2C3SEL                    RCC_CCIPR_I2C3SEL_Msk
N#define RCC_CCIPR_I2C3SEL_0                  (0x1UL << RCC_CCIPR_I2C3SEL_Pos)  /*!< 0x00010000 */
N#define RCC_CCIPR_I2C3SEL_1                  (0x2UL << RCC_CCIPR_I2C3SEL_Pos)  /*!< 0x00020000 */
N
N#define RCC_CCIPR_LPTIM1SEL_Pos              (18U)
N#define RCC_CCIPR_LPTIM1SEL_Msk              (0x3UL << RCC_CCIPR_LPTIM1SEL_Pos) /*!< 0x000C0000 */
N#define RCC_CCIPR_LPTIM1SEL                  RCC_CCIPR_LPTIM1SEL_Msk
N#define RCC_CCIPR_LPTIM1SEL_0                (0x1UL << RCC_CCIPR_LPTIM1SEL_Pos) /*!< 0x00040000 */
N#define RCC_CCIPR_LPTIM1SEL_1                (0x2UL << RCC_CCIPR_LPTIM1SEL_Pos) /*!< 0x00080000 */
N
N#define RCC_CCIPR_LPTIM2SEL_Pos              (20U)
N#define RCC_CCIPR_LPTIM2SEL_Msk              (0x3UL << RCC_CCIPR_LPTIM2SEL_Pos) /*!< 0x00300000 */
N#define RCC_CCIPR_LPTIM2SEL                  RCC_CCIPR_LPTIM2SEL_Msk
N#define RCC_CCIPR_LPTIM2SEL_0                (0x1UL << RCC_CCIPR_LPTIM2SEL_Pos) /*!< 0x00100000 */
N#define RCC_CCIPR_LPTIM2SEL_1                (0x2UL << RCC_CCIPR_LPTIM2SEL_Pos) /*!< 0x00200000 */
N
N#define RCC_CCIPR_SAI1SEL_Pos                (22U)
N#define RCC_CCIPR_SAI1SEL_Msk                (0x3UL << RCC_CCIPR_SAI1SEL_Pos)  /*!< 0x00C00000 */
N#define RCC_CCIPR_SAI1SEL                    RCC_CCIPR_SAI1SEL_Msk
N#define RCC_CCIPR_SAI1SEL_0                  (0x1UL << RCC_CCIPR_SAI1SEL_Pos)  /*!< 0x00400000 */
N#define RCC_CCIPR_SAI1SEL_1                  (0x2UL << RCC_CCIPR_SAI1SEL_Pos)  /*!< 0x00800000 */
N
N#define RCC_CCIPR_CLK48SEL_Pos               (26U)
N#define RCC_CCIPR_CLK48SEL_Msk               (0x3UL << RCC_CCIPR_CLK48SEL_Pos) /*!< 0x0C000000 */
N#define RCC_CCIPR_CLK48SEL                   RCC_CCIPR_CLK48SEL_Msk
N#define RCC_CCIPR_CLK48SEL_0                 (0x1UL << RCC_CCIPR_CLK48SEL_Pos) /*!< 0x04000000 */
N#define RCC_CCIPR_CLK48SEL_1                 (0x2UL << RCC_CCIPR_CLK48SEL_Pos) /*!< 0x08000000 */
N
N#define RCC_CCIPR_ADCSEL_Pos                 (28U)
N#define RCC_CCIPR_ADCSEL_Msk                 (0x3UL << RCC_CCIPR_ADCSEL_Pos)   /*!< 0x30000000 */
N#define RCC_CCIPR_ADCSEL                     RCC_CCIPR_ADCSEL_Msk
N#define RCC_CCIPR_ADCSEL_0                   (0x1UL << RCC_CCIPR_ADCSEL_Pos)   /*!< 0x10000000 */
N#define RCC_CCIPR_ADCSEL_1                   (0x2UL << RCC_CCIPR_ADCSEL_Pos)   /*!< 0x20000000 */
N
N#define RCC_CCIPR_SWPMI1SEL_Pos              (30U)
N#define RCC_CCIPR_SWPMI1SEL_Msk              (0x1UL << RCC_CCIPR_SWPMI1SEL_Pos) /*!< 0x40000000 */
N#define RCC_CCIPR_SWPMI1SEL                  RCC_CCIPR_SWPMI1SEL_Msk
N
N/********************  Bit definition for RCC_BDCR register  ******************/
N#define RCC_BDCR_LSEON_Pos                   (0U)
N#define RCC_BDCR_LSEON_Msk                   (0x1UL << RCC_BDCR_LSEON_Pos)     /*!< 0x00000001 */
N#define RCC_BDCR_LSEON                       RCC_BDCR_LSEON_Msk
N#define RCC_BDCR_LSERDY_Pos                  (1U)
N#define RCC_BDCR_LSERDY_Msk                  (0x1UL << RCC_BDCR_LSERDY_Pos)    /*!< 0x00000002 */
N#define RCC_BDCR_LSERDY                      RCC_BDCR_LSERDY_Msk
N#define RCC_BDCR_LSEBYP_Pos                  (2U)
N#define RCC_BDCR_LSEBYP_Msk                  (0x1UL << RCC_BDCR_LSEBYP_Pos)    /*!< 0x00000004 */
N#define RCC_BDCR_LSEBYP                      RCC_BDCR_LSEBYP_Msk
N
N#define RCC_BDCR_LSEDRV_Pos                  (3U)
N#define RCC_BDCR_LSEDRV_Msk                  (0x3UL << RCC_BDCR_LSEDRV_Pos)    /*!< 0x00000018 */
N#define RCC_BDCR_LSEDRV                      RCC_BDCR_LSEDRV_Msk
N#define RCC_BDCR_LSEDRV_0                    (0x1UL << RCC_BDCR_LSEDRV_Pos)    /*!< 0x00000008 */
N#define RCC_BDCR_LSEDRV_1                    (0x2UL << RCC_BDCR_LSEDRV_Pos)    /*!< 0x00000010 */
N
N#define RCC_BDCR_LSECSSON_Pos                (5U)
N#define RCC_BDCR_LSECSSON_Msk                (0x1UL << RCC_BDCR_LSECSSON_Pos)  /*!< 0x00000020 */
N#define RCC_BDCR_LSECSSON                    RCC_BDCR_LSECSSON_Msk
N#define RCC_BDCR_LSECSSD_Pos                 (6U)
N#define RCC_BDCR_LSECSSD_Msk                 (0x1UL << RCC_BDCR_LSECSSD_Pos)   /*!< 0x00000040 */
N#define RCC_BDCR_LSECSSD                     RCC_BDCR_LSECSSD_Msk
N
N#define RCC_BDCR_RTCSEL_Pos                  (8U)
N#define RCC_BDCR_RTCSEL_Msk                  (0x3UL << RCC_BDCR_RTCSEL_Pos)    /*!< 0x00000300 */
N#define RCC_BDCR_RTCSEL                      RCC_BDCR_RTCSEL_Msk
N#define RCC_BDCR_RTCSEL_0                    (0x1UL << RCC_BDCR_RTCSEL_Pos)    /*!< 0x00000100 */
N#define RCC_BDCR_RTCSEL_1                    (0x2UL << RCC_BDCR_RTCSEL_Pos)    /*!< 0x00000200 */
N
N#define RCC_BDCR_RTCEN_Pos                   (15U)
N#define RCC_BDCR_RTCEN_Msk                   (0x1UL << RCC_BDCR_RTCEN_Pos)     /*!< 0x00008000 */
N#define RCC_BDCR_RTCEN                       RCC_BDCR_RTCEN_Msk
N#define RCC_BDCR_BDRST_Pos                   (16U)
N#define RCC_BDCR_BDRST_Msk                   (0x1UL << RCC_BDCR_BDRST_Pos)     /*!< 0x00010000 */
N#define RCC_BDCR_BDRST                       RCC_BDCR_BDRST_Msk
N#define RCC_BDCR_LSCOEN_Pos                  (24U)
N#define RCC_BDCR_LSCOEN_Msk                  (0x1UL << RCC_BDCR_LSCOEN_Pos)    /*!< 0x01000000 */
N#define RCC_BDCR_LSCOEN                      RCC_BDCR_LSCOEN_Msk
N#define RCC_BDCR_LSCOSEL_Pos                 (25U)
N#define RCC_BDCR_LSCOSEL_Msk                 (0x1UL << RCC_BDCR_LSCOSEL_Pos)   /*!< 0x02000000 */
N#define RCC_BDCR_LSCOSEL                     RCC_BDCR_LSCOSEL_Msk
N
N/********************  Bit definition for RCC_CSR register  *******************/
N#define RCC_CSR_LSION_Pos                    (0U)
N#define RCC_CSR_LSION_Msk                    (0x1UL << RCC_CSR_LSION_Pos)      /*!< 0x00000001 */
N#define RCC_CSR_LSION                        RCC_CSR_LSION_Msk
N#define RCC_CSR_LSIRDY_Pos                   (1U)
N#define RCC_CSR_LSIRDY_Msk                   (0x1UL << RCC_CSR_LSIRDY_Pos)     /*!< 0x00000002 */
N#define RCC_CSR_LSIRDY                       RCC_CSR_LSIRDY_Msk
N
N#define RCC_CSR_MSISRANGE_Pos                (8U)
N#define RCC_CSR_MSISRANGE_Msk                (0xFUL << RCC_CSR_MSISRANGE_Pos)  /*!< 0x00000F00 */
N#define RCC_CSR_MSISRANGE                    RCC_CSR_MSISRANGE_Msk
N#define RCC_CSR_MSISRANGE_1                  (0x4UL << RCC_CSR_MSISRANGE_Pos)  /*!< 0x00000400 */
N#define RCC_CSR_MSISRANGE_2                  (0x5UL << RCC_CSR_MSISRANGE_Pos)  /*!< 0x00000500 */
N#define RCC_CSR_MSISRANGE_4                  (0x6UL << RCC_CSR_MSISRANGE_Pos)  /*!< 0x00000600 */
N#define RCC_CSR_MSISRANGE_8                  (0x7UL << RCC_CSR_MSISRANGE_Pos)  /*!< 0x00000700 */
N
N#define RCC_CSR_RMVF_Pos                     (23U)
N#define RCC_CSR_RMVF_Msk                     (0x1UL << RCC_CSR_RMVF_Pos)       /*!< 0x00800000 */
N#define RCC_CSR_RMVF                         RCC_CSR_RMVF_Msk
N#define RCC_CSR_FWRSTF_Pos                   (24U)
N#define RCC_CSR_FWRSTF_Msk                   (0x1UL << RCC_CSR_FWRSTF_Pos)     /*!< 0x01000000 */
N#define RCC_CSR_FWRSTF                       RCC_CSR_FWRSTF_Msk
N#define RCC_CSR_OBLRSTF_Pos                  (25U)
N#define RCC_CSR_OBLRSTF_Msk                  (0x1UL << RCC_CSR_OBLRSTF_Pos)    /*!< 0x02000000 */
N#define RCC_CSR_OBLRSTF                      RCC_CSR_OBLRSTF_Msk
N#define RCC_CSR_PINRSTF_Pos                  (26U)
N#define RCC_CSR_PINRSTF_Msk                  (0x1UL << RCC_CSR_PINRSTF_Pos)    /*!< 0x04000000 */
N#define RCC_CSR_PINRSTF                      RCC_CSR_PINRSTF_Msk
N#define RCC_CSR_BORRSTF_Pos                  (27U)
N#define RCC_CSR_BORRSTF_Msk                  (0x1UL << RCC_CSR_BORRSTF_Pos)    /*!< 0x08000000 */
N#define RCC_CSR_BORRSTF                      RCC_CSR_BORRSTF_Msk
N#define RCC_CSR_SFTRSTF_Pos                  (28U)
N#define RCC_CSR_SFTRSTF_Msk                  (0x1UL << RCC_CSR_SFTRSTF_Pos)    /*!< 0x10000000 */
N#define RCC_CSR_SFTRSTF                      RCC_CSR_SFTRSTF_Msk
N#define RCC_CSR_IWDGRSTF_Pos                 (29U)
N#define RCC_CSR_IWDGRSTF_Msk                 (0x1UL << RCC_CSR_IWDGRSTF_Pos)   /*!< 0x20000000 */
N#define RCC_CSR_IWDGRSTF                     RCC_CSR_IWDGRSTF_Msk
N#define RCC_CSR_WWDGRSTF_Pos                 (30U)
N#define RCC_CSR_WWDGRSTF_Msk                 (0x1UL << RCC_CSR_WWDGRSTF_Pos)   /*!< 0x40000000 */
N#define RCC_CSR_WWDGRSTF                     RCC_CSR_WWDGRSTF_Msk
N#define RCC_CSR_LPWRRSTF_Pos                 (31U)
N#define RCC_CSR_LPWRRSTF_Msk                 (0x1UL << RCC_CSR_LPWRRSTF_Pos)   /*!< 0x80000000 */
N#define RCC_CSR_LPWRRSTF                     RCC_CSR_LPWRRSTF_Msk
N
N/********************  Bit definition for RCC_CRRCR register  *****************/
N#define RCC_CRRCR_HSI48ON_Pos                (0U)
N#define RCC_CRRCR_HSI48ON_Msk                (0x1UL << RCC_CRRCR_HSI48ON_Pos)  /*!< 0x00000001 */
N#define RCC_CRRCR_HSI48ON                    RCC_CRRCR_HSI48ON_Msk
N#define RCC_CRRCR_HSI48RDY_Pos               (1U)
N#define RCC_CRRCR_HSI48RDY_Msk               (0x1UL << RCC_CRRCR_HSI48RDY_Pos) /*!< 0x00000002 */
N#define RCC_CRRCR_HSI48RDY                   RCC_CRRCR_HSI48RDY_Msk
N
N/*!< HSI48CAL configuration */
N#define RCC_CRRCR_HSI48CAL_Pos               (7U)
N#define RCC_CRRCR_HSI48CAL_Msk               (0x1FFUL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x0000FF80 */
N#define RCC_CRRCR_HSI48CAL                   RCC_CRRCR_HSI48CAL_Msk             /*!< HSI48CAL[8:0] bits */
N#define RCC_CRRCR_HSI48CAL_0                 (0x001UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00000080 */
N#define RCC_CRRCR_HSI48CAL_1                 (0x002UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00000100 */
N#define RCC_CRRCR_HSI48CAL_2                 (0x004UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00000200 */
N#define RCC_CRRCR_HSI48CAL_3                 (0x008UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00000400 */
N#define RCC_CRRCR_HSI48CAL_4                 (0x010UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00000800 */
N#define RCC_CRRCR_HSI48CAL_5                 (0x020UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00001000 */
N#define RCC_CRRCR_HSI48CAL_6                 (0x040UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00002000 */
N#define RCC_CRRCR_HSI48CAL_7                 (0x080UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00004000 */
N#define RCC_CRRCR_HSI48CAL_8                 (0x100UL << RCC_CRRCR_HSI48CAL_Pos) /*!< 0x00008000 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    RNG                                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RNG_CR register  *******************/
N#define RNG_CR_RNGEN_Pos    (2U)
N#define RNG_CR_RNGEN_Msk    (0x1UL << RNG_CR_RNGEN_Pos)                        /*!< 0x00000004 */
N#define RNG_CR_RNGEN        RNG_CR_RNGEN_Msk
N#define RNG_CR_IE_Pos       (3U)
N#define RNG_CR_IE_Msk       (0x1UL << RNG_CR_IE_Pos)                           /*!< 0x00000008 */
N#define RNG_CR_IE           RNG_CR_IE_Msk
N
N/********************  Bits definition for RNG_SR register  *******************/
N#define RNG_SR_DRDY_Pos     (0U)
N#define RNG_SR_DRDY_Msk     (0x1UL << RNG_SR_DRDY_Pos)                         /*!< 0x00000001 */
N#define RNG_SR_DRDY         RNG_SR_DRDY_Msk
N#define RNG_SR_CECS_Pos     (1U)
N#define RNG_SR_CECS_Msk     (0x1UL << RNG_SR_CECS_Pos)                         /*!< 0x00000002 */
N#define RNG_SR_CECS         RNG_SR_CECS_Msk
N#define RNG_SR_SECS_Pos     (2U)
N#define RNG_SR_SECS_Msk     (0x1UL << RNG_SR_SECS_Pos)                         /*!< 0x00000004 */
N#define RNG_SR_SECS         RNG_SR_SECS_Msk
N#define RNG_SR_CEIS_Pos     (5U)
N#define RNG_SR_CEIS_Msk     (0x1UL << RNG_SR_CEIS_Pos)                         /*!< 0x00000020 */
N#define RNG_SR_CEIS         RNG_SR_CEIS_Msk
N#define RNG_SR_SEIS_Pos     (6U)
N#define RNG_SR_SEIS_Msk     (0x1UL << RNG_SR_SEIS_Pos)                         /*!< 0x00000040 */
N#define RNG_SR_SEIS         RNG_SR_SEIS_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/*
N* @brief Specific device feature definitions
N*/
N#define RTC_TAMPER1_SUPPORT
N#define RTC_TAMPER2_SUPPORT
N#define RTC_TAMPER3_SUPPORT
N#define RTC_WAKEUP_SUPPORT
N#define RTC_BACKUP_SUPPORT
N
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM_Pos                  (22U)
N#define RTC_TR_PM_Msk                  (0x1UL << RTC_TR_PM_Pos)                /*!< 0x00400000 */
N#define RTC_TR_PM                      RTC_TR_PM_Msk
N#define RTC_TR_HT_Pos                  (20U)
N#define RTC_TR_HT_Msk                  (0x3UL << RTC_TR_HT_Pos)                /*!< 0x00300000 */
N#define RTC_TR_HT                      RTC_TR_HT_Msk
N#define RTC_TR_HT_0                    (0x1UL << RTC_TR_HT_Pos)                /*!< 0x00100000 */
N#define RTC_TR_HT_1                    (0x2UL << RTC_TR_HT_Pos)                /*!< 0x00200000 */
N#define RTC_TR_HU_Pos                  (16U)
N#define RTC_TR_HU_Msk                  (0xFUL << RTC_TR_HU_Pos)                /*!< 0x000F0000 */
N#define RTC_TR_HU                      RTC_TR_HU_Msk
N#define RTC_TR_HU_0                    (0x1UL << RTC_TR_HU_Pos)                /*!< 0x00010000 */
N#define RTC_TR_HU_1                    (0x2UL << RTC_TR_HU_Pos)                /*!< 0x00020000 */
N#define RTC_TR_HU_2                    (0x4UL << RTC_TR_HU_Pos)                /*!< 0x00040000 */
N#define RTC_TR_HU_3                    (0x8UL << RTC_TR_HU_Pos)                /*!< 0x00080000 */
N#define RTC_TR_MNT_Pos                 (12U)
N#define RTC_TR_MNT_Msk                 (0x7UL << RTC_TR_MNT_Pos)               /*!< 0x00007000 */
N#define RTC_TR_MNT                     RTC_TR_MNT_Msk
N#define RTC_TR_MNT_0                   (0x1UL << RTC_TR_MNT_Pos)               /*!< 0x00001000 */
N#define RTC_TR_MNT_1                   (0x2UL << RTC_TR_MNT_Pos)               /*!< 0x00002000 */
N#define RTC_TR_MNT_2                   (0x4UL << RTC_TR_MNT_Pos)               /*!< 0x00004000 */
N#define RTC_TR_MNU_Pos                 (8U)
N#define RTC_TR_MNU_Msk                 (0xFUL << RTC_TR_MNU_Pos)               /*!< 0x00000F00 */
N#define RTC_TR_MNU                     RTC_TR_MNU_Msk
N#define RTC_TR_MNU_0                   (0x1UL << RTC_TR_MNU_Pos)               /*!< 0x00000100 */
N#define RTC_TR_MNU_1                   (0x2UL << RTC_TR_MNU_Pos)               /*!< 0x00000200 */
N#define RTC_TR_MNU_2                   (0x4UL << RTC_TR_MNU_Pos)               /*!< 0x00000400 */
N#define RTC_TR_MNU_3                   (0x8UL << RTC_TR_MNU_Pos)               /*!< 0x00000800 */
N#define RTC_TR_ST_Pos                  (4U)
N#define RTC_TR_ST_Msk                  (0x7UL << RTC_TR_ST_Pos)                /*!< 0x00000070 */
N#define RTC_TR_ST                      RTC_TR_ST_Msk
N#define RTC_TR_ST_0                    (0x1UL << RTC_TR_ST_Pos)                /*!< 0x00000010 */
N#define RTC_TR_ST_1                    (0x2UL << RTC_TR_ST_Pos)                /*!< 0x00000020 */
N#define RTC_TR_ST_2                    (0x4UL << RTC_TR_ST_Pos)                /*!< 0x00000040 */
N#define RTC_TR_SU_Pos                  (0U)
N#define RTC_TR_SU_Msk                  (0xFUL << RTC_TR_SU_Pos)                /*!< 0x0000000F */
N#define RTC_TR_SU                      RTC_TR_SU_Msk
N#define RTC_TR_SU_0                    (0x1UL << RTC_TR_SU_Pos)                /*!< 0x00000001 */
N#define RTC_TR_SU_1                    (0x2UL << RTC_TR_SU_Pos)                /*!< 0x00000002 */
N#define RTC_TR_SU_2                    (0x4UL << RTC_TR_SU_Pos)                /*!< 0x00000004 */
N#define RTC_TR_SU_3                    (0x8UL << RTC_TR_SU_Pos)                /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT_Pos                  (20U)
N#define RTC_DR_YT_Msk                  (0xFUL << RTC_DR_YT_Pos)                /*!< 0x00F00000 */
N#define RTC_DR_YT                      RTC_DR_YT_Msk
N#define RTC_DR_YT_0                    (0x1UL << RTC_DR_YT_Pos)                /*!< 0x00100000 */
N#define RTC_DR_YT_1                    (0x2UL << RTC_DR_YT_Pos)                /*!< 0x00200000 */
N#define RTC_DR_YT_2                    (0x4UL << RTC_DR_YT_Pos)                /*!< 0x00400000 */
N#define RTC_DR_YT_3                    (0x8UL << RTC_DR_YT_Pos)                /*!< 0x00800000 */
N#define RTC_DR_YU_Pos                  (16U)
N#define RTC_DR_YU_Msk                  (0xFUL << RTC_DR_YU_Pos)                /*!< 0x000F0000 */
N#define RTC_DR_YU                      RTC_DR_YU_Msk
N#define RTC_DR_YU_0                    (0x1UL << RTC_DR_YU_Pos)                /*!< 0x00010000 */
N#define RTC_DR_YU_1                    (0x2UL << RTC_DR_YU_Pos)                /*!< 0x00020000 */
N#define RTC_DR_YU_2                    (0x4UL << RTC_DR_YU_Pos)                /*!< 0x00040000 */
N#define RTC_DR_YU_3                    (0x8UL << RTC_DR_YU_Pos)                /*!< 0x00080000 */
N#define RTC_DR_WDU_Pos                 (13U)
N#define RTC_DR_WDU_Msk                 (0x7UL << RTC_DR_WDU_Pos)               /*!< 0x0000E000 */
N#define RTC_DR_WDU                     RTC_DR_WDU_Msk
N#define RTC_DR_WDU_0                   (0x1UL << RTC_DR_WDU_Pos)               /*!< 0x00002000 */
N#define RTC_DR_WDU_1                   (0x2UL << RTC_DR_WDU_Pos)               /*!< 0x00004000 */
N#define RTC_DR_WDU_2                   (0x4UL << RTC_DR_WDU_Pos)               /*!< 0x00008000 */
N#define RTC_DR_MT_Pos                  (12U)
N#define RTC_DR_MT_Msk                  (0x1UL << RTC_DR_MT_Pos)                /*!< 0x00001000 */
N#define RTC_DR_MT                      RTC_DR_MT_Msk
N#define RTC_DR_MU_Pos                  (8U)
N#define RTC_DR_MU_Msk                  (0xFUL << RTC_DR_MU_Pos)                /*!< 0x00000F00 */
N#define RTC_DR_MU                      RTC_DR_MU_Msk
N#define RTC_DR_MU_0                    (0x1UL << RTC_DR_MU_Pos)                /*!< 0x00000100 */
N#define RTC_DR_MU_1                    (0x2UL << RTC_DR_MU_Pos)                /*!< 0x00000200 */
N#define RTC_DR_MU_2                    (0x4UL << RTC_DR_MU_Pos)                /*!< 0x00000400 */
N#define RTC_DR_MU_3                    (0x8UL << RTC_DR_MU_Pos)                /*!< 0x00000800 */
N#define RTC_DR_DT_Pos                  (4U)
N#define RTC_DR_DT_Msk                  (0x3UL << RTC_DR_DT_Pos)                /*!< 0x00000030 */
N#define RTC_DR_DT                      RTC_DR_DT_Msk
N#define RTC_DR_DT_0                    (0x1UL << RTC_DR_DT_Pos)                /*!< 0x00000010 */
N#define RTC_DR_DT_1                    (0x2UL << RTC_DR_DT_Pos)                /*!< 0x00000020 */
N#define RTC_DR_DU_Pos                  (0U)
N#define RTC_DR_DU_Msk                  (0xFUL << RTC_DR_DU_Pos)                /*!< 0x0000000F */
N#define RTC_DR_DU                      RTC_DR_DU_Msk
N#define RTC_DR_DU_0                    (0x1UL << RTC_DR_DU_Pos)                /*!< 0x00000001 */
N#define RTC_DR_DU_1                    (0x2UL << RTC_DR_DU_Pos)                /*!< 0x00000002 */
N#define RTC_DR_DU_2                    (0x4UL << RTC_DR_DU_Pos)                /*!< 0x00000004 */
N#define RTC_DR_DU_3                    (0x8UL << RTC_DR_DU_Pos)                /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_ITSE_Pos                (24U)
N#define RTC_CR_ITSE_Msk                (0x1UL << RTC_CR_ITSE_Pos)              /*!< 0x01000000 */
N#define RTC_CR_ITSE                    RTC_CR_ITSE_Msk
N#define RTC_CR_COE_Pos                 (23U)
N#define RTC_CR_COE_Msk                 (0x1UL << RTC_CR_COE_Pos)               /*!< 0x00800000 */
N#define RTC_CR_COE                     RTC_CR_COE_Msk
N#define RTC_CR_OSEL_Pos                (21U)
N#define RTC_CR_OSEL_Msk                (0x3UL << RTC_CR_OSEL_Pos)              /*!< 0x00600000 */
N#define RTC_CR_OSEL                    RTC_CR_OSEL_Msk
N#define RTC_CR_OSEL_0                  (0x1UL << RTC_CR_OSEL_Pos)              /*!< 0x00200000 */
N#define RTC_CR_OSEL_1                  (0x2UL << RTC_CR_OSEL_Pos)              /*!< 0x00400000 */
N#define RTC_CR_POL_Pos                 (20U)
N#define RTC_CR_POL_Msk                 (0x1UL << RTC_CR_POL_Pos)               /*!< 0x00100000 */
N#define RTC_CR_POL                     RTC_CR_POL_Msk
N#define RTC_CR_COSEL_Pos               (19U)
N#define RTC_CR_COSEL_Msk               (0x1UL << RTC_CR_COSEL_Pos)             /*!< 0x00080000 */
N#define RTC_CR_COSEL                   RTC_CR_COSEL_Msk
N#define RTC_CR_BKP_Pos                 (18U)
N#define RTC_CR_BKP_Msk                 (0x1UL << RTC_CR_BKP_Pos)               /*!< 0x00040000 */
N#define RTC_CR_BKP                     RTC_CR_BKP_Msk
N#define RTC_CR_SUB1H_Pos               (17U)
N#define RTC_CR_SUB1H_Msk               (0x1UL << RTC_CR_SUB1H_Pos)             /*!< 0x00020000 */
N#define RTC_CR_SUB1H                   RTC_CR_SUB1H_Msk
N#define RTC_CR_ADD1H_Pos               (16U)
N#define RTC_CR_ADD1H_Msk               (0x1UL << RTC_CR_ADD1H_Pos)             /*!< 0x00010000 */
N#define RTC_CR_ADD1H                   RTC_CR_ADD1H_Msk
N#define RTC_CR_TSIE_Pos                (15U)
N#define RTC_CR_TSIE_Msk                (0x1UL << RTC_CR_TSIE_Pos)              /*!< 0x00008000 */
N#define RTC_CR_TSIE                    RTC_CR_TSIE_Msk
N#define RTC_CR_WUTIE_Pos               (14U)
N#define RTC_CR_WUTIE_Msk               (0x1UL << RTC_CR_WUTIE_Pos)             /*!< 0x00004000 */
N#define RTC_CR_WUTIE                   RTC_CR_WUTIE_Msk
N#define RTC_CR_ALRBIE_Pos              (13U)
N#define RTC_CR_ALRBIE_Msk              (0x1UL << RTC_CR_ALRBIE_Pos)            /*!< 0x00002000 */
N#define RTC_CR_ALRBIE                  RTC_CR_ALRBIE_Msk
N#define RTC_CR_ALRAIE_Pos              (12U)
N#define RTC_CR_ALRAIE_Msk              (0x1UL << RTC_CR_ALRAIE_Pos)            /*!< 0x00001000 */
N#define RTC_CR_ALRAIE                  RTC_CR_ALRAIE_Msk
N#define RTC_CR_TSE_Pos                 (11U)
N#define RTC_CR_TSE_Msk                 (0x1UL << RTC_CR_TSE_Pos)               /*!< 0x00000800 */
N#define RTC_CR_TSE                     RTC_CR_TSE_Msk
N#define RTC_CR_WUTE_Pos                (10U)
N#define RTC_CR_WUTE_Msk                (0x1UL << RTC_CR_WUTE_Pos)              /*!< 0x00000400 */
N#define RTC_CR_WUTE                    RTC_CR_WUTE_Msk
N#define RTC_CR_ALRBE_Pos               (9U)
N#define RTC_CR_ALRBE_Msk               (0x1UL << RTC_CR_ALRBE_Pos)             /*!< 0x00000200 */
N#define RTC_CR_ALRBE                   RTC_CR_ALRBE_Msk
N#define RTC_CR_ALRAE_Pos               (8U)
N#define RTC_CR_ALRAE_Msk               (0x1UL << RTC_CR_ALRAE_Pos)             /*!< 0x00000100 */
N#define RTC_CR_ALRAE                   RTC_CR_ALRAE_Msk
N#define RTC_CR_FMT_Pos                 (6U)
N#define RTC_CR_FMT_Msk                 (0x1UL << RTC_CR_FMT_Pos)               /*!< 0x00000040 */
N#define RTC_CR_FMT                     RTC_CR_FMT_Msk
N#define RTC_CR_BYPSHAD_Pos             (5U)
N#define RTC_CR_BYPSHAD_Msk             (0x1UL << RTC_CR_BYPSHAD_Pos)           /*!< 0x00000020 */
N#define RTC_CR_BYPSHAD                 RTC_CR_BYPSHAD_Msk
N#define RTC_CR_REFCKON_Pos             (4U)
N#define RTC_CR_REFCKON_Msk             (0x1UL << RTC_CR_REFCKON_Pos)           /*!< 0x00000010 */
N#define RTC_CR_REFCKON                 RTC_CR_REFCKON_Msk
N#define RTC_CR_TSEDGE_Pos              (3U)
N#define RTC_CR_TSEDGE_Msk              (0x1UL << RTC_CR_TSEDGE_Pos)            /*!< 0x00000008 */
N#define RTC_CR_TSEDGE                  RTC_CR_TSEDGE_Msk
N#define RTC_CR_WUCKSEL_Pos             (0U)
N#define RTC_CR_WUCKSEL_Msk             (0x7UL << RTC_CR_WUCKSEL_Pos)           /*!< 0x00000007 */
N#define RTC_CR_WUCKSEL                 RTC_CR_WUCKSEL_Msk
N#define RTC_CR_WUCKSEL_0               (0x1UL << RTC_CR_WUCKSEL_Pos)           /*!< 0x00000001 */
N#define RTC_CR_WUCKSEL_1               (0x2UL << RTC_CR_WUCKSEL_Pos)           /*!< 0x00000002 */
N#define RTC_CR_WUCKSEL_2               (0x4UL << RTC_CR_WUCKSEL_Pos)           /*!< 0x00000004 */
N
N/* Legacy defines */
N#define RTC_CR_BCK_Pos                 RTC_CR_BKP_Pos
N#define RTC_CR_BCK_Msk                 RTC_CR_BKP_Msk
N#define RTC_CR_BCK                     RTC_CR_BKP
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_ITSF_Pos               (17U)
N#define RTC_ISR_ITSF_Msk               (0x1UL << RTC_ISR_ITSF_Pos)             /*!< 0x00020000 */
N#define RTC_ISR_ITSF                   RTC_ISR_ITSF_Msk
N#define RTC_ISR_RECALPF_Pos            (16U)
N#define RTC_ISR_RECALPF_Msk            (0x1UL << RTC_ISR_RECALPF_Pos)          /*!< 0x00010000 */
N#define RTC_ISR_RECALPF                RTC_ISR_RECALPF_Msk
N#define RTC_ISR_TAMP3F_Pos             (15U)
N#define RTC_ISR_TAMP3F_Msk             (0x1UL << RTC_ISR_TAMP3F_Pos)           /*!< 0x00008000 */
N#define RTC_ISR_TAMP3F                 RTC_ISR_TAMP3F_Msk
N#define RTC_ISR_TAMP2F_Pos             (14U)
N#define RTC_ISR_TAMP2F_Msk             (0x1UL << RTC_ISR_TAMP2F_Pos)           /*!< 0x00004000 */
N#define RTC_ISR_TAMP2F                 RTC_ISR_TAMP2F_Msk
N#define RTC_ISR_TAMP1F_Pos             (13U)
N#define RTC_ISR_TAMP1F_Msk             (0x1UL << RTC_ISR_TAMP1F_Pos)           /*!< 0x00002000 */
N#define RTC_ISR_TAMP1F                 RTC_ISR_TAMP1F_Msk
N#define RTC_ISR_TSOVF_Pos              (12U)
N#define RTC_ISR_TSOVF_Msk              (0x1UL << RTC_ISR_TSOVF_Pos)            /*!< 0x00001000 */
N#define RTC_ISR_TSOVF                  RTC_ISR_TSOVF_Msk
N#define RTC_ISR_TSF_Pos                (11U)
N#define RTC_ISR_TSF_Msk                (0x1UL << RTC_ISR_TSF_Pos)              /*!< 0x00000800 */
N#define RTC_ISR_TSF                    RTC_ISR_TSF_Msk
N#define RTC_ISR_WUTF_Pos               (10U)
N#define RTC_ISR_WUTF_Msk               (0x1UL << RTC_ISR_WUTF_Pos)             /*!< 0x00000400 */
N#define RTC_ISR_WUTF                   RTC_ISR_WUTF_Msk
N#define RTC_ISR_ALRBF_Pos              (9U)
N#define RTC_ISR_ALRBF_Msk              (0x1UL << RTC_ISR_ALRBF_Pos)            /*!< 0x00000200 */
N#define RTC_ISR_ALRBF                  RTC_ISR_ALRBF_Msk
N#define RTC_ISR_ALRAF_Pos              (8U)
N#define RTC_ISR_ALRAF_Msk              (0x1UL << RTC_ISR_ALRAF_Pos)            /*!< 0x00000100 */
N#define RTC_ISR_ALRAF                  RTC_ISR_ALRAF_Msk
N#define RTC_ISR_INIT_Pos               (7U)
N#define RTC_ISR_INIT_Msk               (0x1UL << RTC_ISR_INIT_Pos)             /*!< 0x00000080 */
N#define RTC_ISR_INIT                   RTC_ISR_INIT_Msk
N#define RTC_ISR_INITF_Pos              (6U)
N#define RTC_ISR_INITF_Msk              (0x1UL << RTC_ISR_INITF_Pos)            /*!< 0x00000040 */
N#define RTC_ISR_INITF                  RTC_ISR_INITF_Msk
N#define RTC_ISR_RSF_Pos                (5U)
N#define RTC_ISR_RSF_Msk                (0x1UL << RTC_ISR_RSF_Pos)              /*!< 0x00000020 */
N#define RTC_ISR_RSF                    RTC_ISR_RSF_Msk
N#define RTC_ISR_INITS_Pos              (4U)
N#define RTC_ISR_INITS_Msk              (0x1UL << RTC_ISR_INITS_Pos)            /*!< 0x00000010 */
N#define RTC_ISR_INITS                  RTC_ISR_INITS_Msk
N#define RTC_ISR_SHPF_Pos               (3U)
N#define RTC_ISR_SHPF_Msk               (0x1UL << RTC_ISR_SHPF_Pos)             /*!< 0x00000008 */
N#define RTC_ISR_SHPF                   RTC_ISR_SHPF_Msk
N#define RTC_ISR_WUTWF_Pos              (2U)
N#define RTC_ISR_WUTWF_Msk              (0x1UL << RTC_ISR_WUTWF_Pos)            /*!< 0x00000004 */
N#define RTC_ISR_WUTWF                  RTC_ISR_WUTWF_Msk
N#define RTC_ISR_ALRBWF_Pos             (1U)
N#define RTC_ISR_ALRBWF_Msk             (0x1UL << RTC_ISR_ALRBWF_Pos)           /*!< 0x00000002 */
N#define RTC_ISR_ALRBWF                 RTC_ISR_ALRBWF_Msk
N#define RTC_ISR_ALRAWF_Pos             (0U)
N#define RTC_ISR_ALRAWF_Msk             (0x1UL << RTC_ISR_ALRAWF_Pos)           /*!< 0x00000001 */
N#define RTC_ISR_ALRAWF                 RTC_ISR_ALRAWF_Msk
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A_Pos          (16U)
N#define RTC_PRER_PREDIV_A_Msk          (0x7FUL << RTC_PRER_PREDIV_A_Pos)       /*!< 0x007F0000 */
N#define RTC_PRER_PREDIV_A              RTC_PRER_PREDIV_A_Msk
N#define RTC_PRER_PREDIV_S_Pos          (0U)
N#define RTC_PRER_PREDIV_S_Msk          (0x7FFFUL << RTC_PRER_PREDIV_S_Pos)     /*!< 0x00007FFF */
N#define RTC_PRER_PREDIV_S              RTC_PRER_PREDIV_S_Msk
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT_Pos               (0U)
N#define RTC_WUTR_WUT_Msk               (0xFFFFUL << RTC_WUTR_WUT_Pos)          /*!< 0x0000FFFF */
N#define RTC_WUTR_WUT                   RTC_WUTR_WUT_Msk
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4_Pos            (31U)
N#define RTC_ALRMAR_MSK4_Msk            (0x1UL << RTC_ALRMAR_MSK4_Pos)          /*!< 0x80000000 */
N#define RTC_ALRMAR_MSK4                RTC_ALRMAR_MSK4_Msk
N#define RTC_ALRMAR_WDSEL_Pos           (30U)
N#define RTC_ALRMAR_WDSEL_Msk           (0x1UL << RTC_ALRMAR_WDSEL_Pos)         /*!< 0x40000000 */
N#define RTC_ALRMAR_WDSEL               RTC_ALRMAR_WDSEL_Msk
N#define RTC_ALRMAR_DT_Pos              (28U)
N#define RTC_ALRMAR_DT_Msk              (0x3UL << RTC_ALRMAR_DT_Pos)            /*!< 0x30000000 */
N#define RTC_ALRMAR_DT                  RTC_ALRMAR_DT_Msk
N#define RTC_ALRMAR_DT_0                (0x1UL << RTC_ALRMAR_DT_Pos)            /*!< 0x10000000 */
N#define RTC_ALRMAR_DT_1                (0x2UL << RTC_ALRMAR_DT_Pos)            /*!< 0x20000000 */
N#define RTC_ALRMAR_DU_Pos              (24U)
N#define RTC_ALRMAR_DU_Msk              (0xFUL << RTC_ALRMAR_DU_Pos)            /*!< 0x0F000000 */
N#define RTC_ALRMAR_DU                  RTC_ALRMAR_DU_Msk
N#define RTC_ALRMAR_DU_0                (0x1UL << RTC_ALRMAR_DU_Pos)            /*!< 0x01000000 */
N#define RTC_ALRMAR_DU_1                (0x2UL << RTC_ALRMAR_DU_Pos)            /*!< 0x02000000 */
N#define RTC_ALRMAR_DU_2                (0x4UL << RTC_ALRMAR_DU_Pos)            /*!< 0x04000000 */
N#define RTC_ALRMAR_DU_3                (0x8UL << RTC_ALRMAR_DU_Pos)            /*!< 0x08000000 */
N#define RTC_ALRMAR_MSK3_Pos            (23U)
N#define RTC_ALRMAR_MSK3_Msk            (0x1UL << RTC_ALRMAR_MSK3_Pos)          /*!< 0x00800000 */
N#define RTC_ALRMAR_MSK3                RTC_ALRMAR_MSK3_Msk
N#define RTC_ALRMAR_PM_Pos              (22U)
N#define RTC_ALRMAR_PM_Msk              (0x1UL << RTC_ALRMAR_PM_Pos)            /*!< 0x00400000 */
N#define RTC_ALRMAR_PM                  RTC_ALRMAR_PM_Msk
N#define RTC_ALRMAR_HT_Pos              (20U)
N#define RTC_ALRMAR_HT_Msk              (0x3UL << RTC_ALRMAR_HT_Pos)            /*!< 0x00300000 */
N#define RTC_ALRMAR_HT                  RTC_ALRMAR_HT_Msk
N#define RTC_ALRMAR_HT_0                (0x1UL << RTC_ALRMAR_HT_Pos)            /*!< 0x00100000 */
N#define RTC_ALRMAR_HT_1                (0x2UL << RTC_ALRMAR_HT_Pos)            /*!< 0x00200000 */
N#define RTC_ALRMAR_HU_Pos              (16U)
N#define RTC_ALRMAR_HU_Msk              (0xFUL << RTC_ALRMAR_HU_Pos)            /*!< 0x000F0000 */
N#define RTC_ALRMAR_HU                  RTC_ALRMAR_HU_Msk
N#define RTC_ALRMAR_HU_0                (0x1UL << RTC_ALRMAR_HU_Pos)            /*!< 0x00010000 */
N#define RTC_ALRMAR_HU_1                (0x2UL << RTC_ALRMAR_HU_Pos)            /*!< 0x00020000 */
N#define RTC_ALRMAR_HU_2                (0x4UL << RTC_ALRMAR_HU_Pos)            /*!< 0x00040000 */
N#define RTC_ALRMAR_HU_3                (0x8UL << RTC_ALRMAR_HU_Pos)            /*!< 0x00080000 */
N#define RTC_ALRMAR_MSK2_Pos            (15U)
N#define RTC_ALRMAR_MSK2_Msk            (0x1UL << RTC_ALRMAR_MSK2_Pos)          /*!< 0x00008000 */
N#define RTC_ALRMAR_MSK2                RTC_ALRMAR_MSK2_Msk
N#define RTC_ALRMAR_MNT_Pos             (12U)
N#define RTC_ALRMAR_MNT_Msk             (0x7UL << RTC_ALRMAR_MNT_Pos)           /*!< 0x00007000 */
N#define RTC_ALRMAR_MNT                 RTC_ALRMAR_MNT_Msk
N#define RTC_ALRMAR_MNT_0               (0x1UL << RTC_ALRMAR_MNT_Pos)           /*!< 0x00001000 */
N#define RTC_ALRMAR_MNT_1               (0x2UL << RTC_ALRMAR_MNT_Pos)           /*!< 0x00002000 */
N#define RTC_ALRMAR_MNT_2               (0x4UL << RTC_ALRMAR_MNT_Pos)           /*!< 0x00004000 */
N#define RTC_ALRMAR_MNU_Pos             (8U)
N#define RTC_ALRMAR_MNU_Msk             (0xFUL << RTC_ALRMAR_MNU_Pos)           /*!< 0x00000F00 */
N#define RTC_ALRMAR_MNU                 RTC_ALRMAR_MNU_Msk
N#define RTC_ALRMAR_MNU_0               (0x1UL << RTC_ALRMAR_MNU_Pos)           /*!< 0x00000100 */
N#define RTC_ALRMAR_MNU_1               (0x2UL << RTC_ALRMAR_MNU_Pos)           /*!< 0x00000200 */
N#define RTC_ALRMAR_MNU_2               (0x4UL << RTC_ALRMAR_MNU_Pos)           /*!< 0x00000400 */
N#define RTC_ALRMAR_MNU_3               (0x8UL << RTC_ALRMAR_MNU_Pos)           /*!< 0x00000800 */
N#define RTC_ALRMAR_MSK1_Pos            (7U)
N#define RTC_ALRMAR_MSK1_Msk            (0x1UL << RTC_ALRMAR_MSK1_Pos)          /*!< 0x00000080 */
N#define RTC_ALRMAR_MSK1                RTC_ALRMAR_MSK1_Msk
N#define RTC_ALRMAR_ST_Pos              (4U)
N#define RTC_ALRMAR_ST_Msk              (0x7UL << RTC_ALRMAR_ST_Pos)            /*!< 0x00000070 */
N#define RTC_ALRMAR_ST                  RTC_ALRMAR_ST_Msk
N#define RTC_ALRMAR_ST_0                (0x1UL << RTC_ALRMAR_ST_Pos)            /*!< 0x00000010 */
N#define RTC_ALRMAR_ST_1                (0x2UL << RTC_ALRMAR_ST_Pos)            /*!< 0x00000020 */
N#define RTC_ALRMAR_ST_2                (0x4UL << RTC_ALRMAR_ST_Pos)            /*!< 0x00000040 */
N#define RTC_ALRMAR_SU_Pos              (0U)
N#define RTC_ALRMAR_SU_Msk              (0xFUL << RTC_ALRMAR_SU_Pos)            /*!< 0x0000000F */
N#define RTC_ALRMAR_SU                  RTC_ALRMAR_SU_Msk
N#define RTC_ALRMAR_SU_0                (0x1UL << RTC_ALRMAR_SU_Pos)            /*!< 0x00000001 */
N#define RTC_ALRMAR_SU_1                (0x2UL << RTC_ALRMAR_SU_Pos)            /*!< 0x00000002 */
N#define RTC_ALRMAR_SU_2                (0x4UL << RTC_ALRMAR_SU_Pos)            /*!< 0x00000004 */
N#define RTC_ALRMAR_SU_3                (0x8UL << RTC_ALRMAR_SU_Pos)            /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4_Pos            (31U)
N#define RTC_ALRMBR_MSK4_Msk            (0x1UL << RTC_ALRMBR_MSK4_Pos)          /*!< 0x80000000 */
N#define RTC_ALRMBR_MSK4                RTC_ALRMBR_MSK4_Msk
N#define RTC_ALRMBR_WDSEL_Pos           (30U)
N#define RTC_ALRMBR_WDSEL_Msk           (0x1UL << RTC_ALRMBR_WDSEL_Pos)         /*!< 0x40000000 */
N#define RTC_ALRMBR_WDSEL               RTC_ALRMBR_WDSEL_Msk
N#define RTC_ALRMBR_DT_Pos              (28U)
N#define RTC_ALRMBR_DT_Msk              (0x3UL << RTC_ALRMBR_DT_Pos)            /*!< 0x30000000 */
N#define RTC_ALRMBR_DT                  RTC_ALRMBR_DT_Msk
N#define RTC_ALRMBR_DT_0                (0x1UL << RTC_ALRMBR_DT_Pos)            /*!< 0x10000000 */
N#define RTC_ALRMBR_DT_1                (0x2UL << RTC_ALRMBR_DT_Pos)            /*!< 0x20000000 */
N#define RTC_ALRMBR_DU_Pos              (24U)
N#define RTC_ALRMBR_DU_Msk              (0xFUL << RTC_ALRMBR_DU_Pos)            /*!< 0x0F000000 */
N#define RTC_ALRMBR_DU                  RTC_ALRMBR_DU_Msk
N#define RTC_ALRMBR_DU_0                (0x1UL << RTC_ALRMBR_DU_Pos)            /*!< 0x01000000 */
N#define RTC_ALRMBR_DU_1                (0x2UL << RTC_ALRMBR_DU_Pos)            /*!< 0x02000000 */
N#define RTC_ALRMBR_DU_2                (0x4UL << RTC_ALRMBR_DU_Pos)            /*!< 0x04000000 */
N#define RTC_ALRMBR_DU_3                (0x8UL << RTC_ALRMBR_DU_Pos)            /*!< 0x08000000 */
N#define RTC_ALRMBR_MSK3_Pos            (23U)
N#define RTC_ALRMBR_MSK3_Msk            (0x1UL << RTC_ALRMBR_MSK3_Pos)          /*!< 0x00800000 */
N#define RTC_ALRMBR_MSK3                RTC_ALRMBR_MSK3_Msk
N#define RTC_ALRMBR_PM_Pos              (22U)
N#define RTC_ALRMBR_PM_Msk              (0x1UL << RTC_ALRMBR_PM_Pos)            /*!< 0x00400000 */
N#define RTC_ALRMBR_PM                  RTC_ALRMBR_PM_Msk
N#define RTC_ALRMBR_HT_Pos              (20U)
N#define RTC_ALRMBR_HT_Msk              (0x3UL << RTC_ALRMBR_HT_Pos)            /*!< 0x00300000 */
N#define RTC_ALRMBR_HT                  RTC_ALRMBR_HT_Msk
N#define RTC_ALRMBR_HT_0                (0x1UL << RTC_ALRMBR_HT_Pos)            /*!< 0x00100000 */
N#define RTC_ALRMBR_HT_1                (0x2UL << RTC_ALRMBR_HT_Pos)            /*!< 0x00200000 */
N#define RTC_ALRMBR_HU_Pos              (16U)
N#define RTC_ALRMBR_HU_Msk              (0xFUL << RTC_ALRMBR_HU_Pos)            /*!< 0x000F0000 */
N#define RTC_ALRMBR_HU                  RTC_ALRMBR_HU_Msk
N#define RTC_ALRMBR_HU_0                (0x1UL << RTC_ALRMBR_HU_Pos)            /*!< 0x00010000 */
N#define RTC_ALRMBR_HU_1                (0x2UL << RTC_ALRMBR_HU_Pos)            /*!< 0x00020000 */
N#define RTC_ALRMBR_HU_2                (0x4UL << RTC_ALRMBR_HU_Pos)            /*!< 0x00040000 */
N#define RTC_ALRMBR_HU_3                (0x8UL << RTC_ALRMBR_HU_Pos)            /*!< 0x00080000 */
N#define RTC_ALRMBR_MSK2_Pos            (15U)
N#define RTC_ALRMBR_MSK2_Msk            (0x1UL << RTC_ALRMBR_MSK2_Pos)          /*!< 0x00008000 */
N#define RTC_ALRMBR_MSK2                RTC_ALRMBR_MSK2_Msk
N#define RTC_ALRMBR_MNT_Pos             (12U)
N#define RTC_ALRMBR_MNT_Msk             (0x7UL << RTC_ALRMBR_MNT_Pos)           /*!< 0x00007000 */
N#define RTC_ALRMBR_MNT                 RTC_ALRMBR_MNT_Msk
N#define RTC_ALRMBR_MNT_0               (0x1UL << RTC_ALRMBR_MNT_Pos)           /*!< 0x00001000 */
N#define RTC_ALRMBR_MNT_1               (0x2UL << RTC_ALRMBR_MNT_Pos)           /*!< 0x00002000 */
N#define RTC_ALRMBR_MNT_2               (0x4UL << RTC_ALRMBR_MNT_Pos)           /*!< 0x00004000 */
N#define RTC_ALRMBR_MNU_Pos             (8U)
N#define RTC_ALRMBR_MNU_Msk             (0xFUL << RTC_ALRMBR_MNU_Pos)           /*!< 0x00000F00 */
N#define RTC_ALRMBR_MNU                 RTC_ALRMBR_MNU_Msk
N#define RTC_ALRMBR_MNU_0               (0x1UL << RTC_ALRMBR_MNU_Pos)           /*!< 0x00000100 */
N#define RTC_ALRMBR_MNU_1               (0x2UL << RTC_ALRMBR_MNU_Pos)           /*!< 0x00000200 */
N#define RTC_ALRMBR_MNU_2               (0x4UL << RTC_ALRMBR_MNU_Pos)           /*!< 0x00000400 */
N#define RTC_ALRMBR_MNU_3               (0x8UL << RTC_ALRMBR_MNU_Pos)           /*!< 0x00000800 */
N#define RTC_ALRMBR_MSK1_Pos            (7U)
N#define RTC_ALRMBR_MSK1_Msk            (0x1UL << RTC_ALRMBR_MSK1_Pos)          /*!< 0x00000080 */
N#define RTC_ALRMBR_MSK1                RTC_ALRMBR_MSK1_Msk
N#define RTC_ALRMBR_ST_Pos              (4U)
N#define RTC_ALRMBR_ST_Msk              (0x7UL << RTC_ALRMBR_ST_Pos)            /*!< 0x00000070 */
N#define RTC_ALRMBR_ST                  RTC_ALRMBR_ST_Msk
N#define RTC_ALRMBR_ST_0                (0x1UL << RTC_ALRMBR_ST_Pos)            /*!< 0x00000010 */
N#define RTC_ALRMBR_ST_1                (0x2UL << RTC_ALRMBR_ST_Pos)            /*!< 0x00000020 */
N#define RTC_ALRMBR_ST_2                (0x4UL << RTC_ALRMBR_ST_Pos)            /*!< 0x00000040 */
N#define RTC_ALRMBR_SU_Pos              (0U)
N#define RTC_ALRMBR_SU_Msk              (0xFUL << RTC_ALRMBR_SU_Pos)            /*!< 0x0000000F */
N#define RTC_ALRMBR_SU                  RTC_ALRMBR_SU_Msk
N#define RTC_ALRMBR_SU_0                (0x1UL << RTC_ALRMBR_SU_Pos)            /*!< 0x00000001 */
N#define RTC_ALRMBR_SU_1                (0x2UL << RTC_ALRMBR_SU_Pos)            /*!< 0x00000002 */
N#define RTC_ALRMBR_SU_2                (0x4UL << RTC_ALRMBR_SU_Pos)            /*!< 0x00000004 */
N#define RTC_ALRMBR_SU_3                (0x8UL << RTC_ALRMBR_SU_Pos)            /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY_Pos                (0U)
N#define RTC_WPR_KEY_Msk                (0xFFUL << RTC_WPR_KEY_Pos)             /*!< 0x000000FF */
N#define RTC_WPR_KEY                    RTC_WPR_KEY_Msk
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS_Pos                 (0U)
N#define RTC_SSR_SS_Msk                 (0xFFFFUL << RTC_SSR_SS_Pos)            /*!< 0x0000FFFF */
N#define RTC_SSR_SS                     RTC_SSR_SS_Msk
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS_Pos           (0U)
N#define RTC_SHIFTR_SUBFS_Msk           (0x7FFFUL << RTC_SHIFTR_SUBFS_Pos)      /*!< 0x00007FFF */
N#define RTC_SHIFTR_SUBFS               RTC_SHIFTR_SUBFS_Msk
N#define RTC_SHIFTR_ADD1S_Pos           (31U)
N#define RTC_SHIFTR_ADD1S_Msk           (0x1UL << RTC_SHIFTR_ADD1S_Pos)         /*!< 0x80000000 */
N#define RTC_SHIFTR_ADD1S               RTC_SHIFTR_ADD1S_Msk
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM_Pos                (22U)
N#define RTC_TSTR_PM_Msk                (0x1UL << RTC_TSTR_PM_Pos)              /*!< 0x00400000 */
N#define RTC_TSTR_PM                    RTC_TSTR_PM_Msk
N#define RTC_TSTR_HT_Pos                (20U)
N#define RTC_TSTR_HT_Msk                (0x3UL << RTC_TSTR_HT_Pos)              /*!< 0x00300000 */
N#define RTC_TSTR_HT                    RTC_TSTR_HT_Msk
N#define RTC_TSTR_HT_0                  (0x1UL << RTC_TSTR_HT_Pos)              /*!< 0x00100000 */
N#define RTC_TSTR_HT_1                  (0x2UL << RTC_TSTR_HT_Pos)              /*!< 0x00200000 */
N#define RTC_TSTR_HU_Pos                (16U)
N#define RTC_TSTR_HU_Msk                (0xFUL << RTC_TSTR_HU_Pos)              /*!< 0x000F0000 */
N#define RTC_TSTR_HU                    RTC_TSTR_HU_Msk
N#define RTC_TSTR_HU_0                  (0x1UL << RTC_TSTR_HU_Pos)              /*!< 0x00010000 */
N#define RTC_TSTR_HU_1                  (0x2UL << RTC_TSTR_HU_Pos)              /*!< 0x00020000 */
N#define RTC_TSTR_HU_2                  (0x4UL << RTC_TSTR_HU_Pos)              /*!< 0x00040000 */
N#define RTC_TSTR_HU_3                  (0x8UL << RTC_TSTR_HU_Pos)              /*!< 0x00080000 */
N#define RTC_TSTR_MNT_Pos               (12U)
N#define RTC_TSTR_MNT_Msk               (0x7UL << RTC_TSTR_MNT_Pos)             /*!< 0x00007000 */
N#define RTC_TSTR_MNT                   RTC_TSTR_MNT_Msk
N#define RTC_TSTR_MNT_0                 (0x1UL << RTC_TSTR_MNT_Pos)             /*!< 0x00001000 */
N#define RTC_TSTR_MNT_1                 (0x2UL << RTC_TSTR_MNT_Pos)             /*!< 0x00002000 */
N#define RTC_TSTR_MNT_2                 (0x4UL << RTC_TSTR_MNT_Pos)             /*!< 0x00004000 */
N#define RTC_TSTR_MNU_Pos               (8U)
N#define RTC_TSTR_MNU_Msk               (0xFUL << RTC_TSTR_MNU_Pos)             /*!< 0x00000F00 */
N#define RTC_TSTR_MNU                   RTC_TSTR_MNU_Msk
N#define RTC_TSTR_MNU_0                 (0x1UL << RTC_TSTR_MNU_Pos)             /*!< 0x00000100 */
N#define RTC_TSTR_MNU_1                 (0x2UL << RTC_TSTR_MNU_Pos)             /*!< 0x00000200 */
N#define RTC_TSTR_MNU_2                 (0x4UL << RTC_TSTR_MNU_Pos)             /*!< 0x00000400 */
N#define RTC_TSTR_MNU_3                 (0x8UL << RTC_TSTR_MNU_Pos)             /*!< 0x00000800 */
N#define RTC_TSTR_ST_Pos                (4U)
N#define RTC_TSTR_ST_Msk                (0x7UL << RTC_TSTR_ST_Pos)              /*!< 0x00000070 */
N#define RTC_TSTR_ST                    RTC_TSTR_ST_Msk
N#define RTC_TSTR_ST_0                  (0x1UL << RTC_TSTR_ST_Pos)              /*!< 0x00000010 */
N#define RTC_TSTR_ST_1                  (0x2UL << RTC_TSTR_ST_Pos)              /*!< 0x00000020 */
N#define RTC_TSTR_ST_2                  (0x4UL << RTC_TSTR_ST_Pos)              /*!< 0x00000040 */
N#define RTC_TSTR_SU_Pos                (0U)
N#define RTC_TSTR_SU_Msk                (0xFUL << RTC_TSTR_SU_Pos)              /*!< 0x0000000F */
N#define RTC_TSTR_SU                    RTC_TSTR_SU_Msk
N#define RTC_TSTR_SU_0                  (0x1UL << RTC_TSTR_SU_Pos)              /*!< 0x00000001 */
N#define RTC_TSTR_SU_1                  (0x2UL << RTC_TSTR_SU_Pos)              /*!< 0x00000002 */
N#define RTC_TSTR_SU_2                  (0x4UL << RTC_TSTR_SU_Pos)              /*!< 0x00000004 */
N#define RTC_TSTR_SU_3                  (0x8UL << RTC_TSTR_SU_Pos)              /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU_Pos               (13U)
N#define RTC_TSDR_WDU_Msk               (0x7UL << RTC_TSDR_WDU_Pos)             /*!< 0x0000E000 */
N#define RTC_TSDR_WDU                   RTC_TSDR_WDU_Msk
N#define RTC_TSDR_WDU_0                 (0x1UL << RTC_TSDR_WDU_Pos)             /*!< 0x00002000 */
N#define RTC_TSDR_WDU_1                 (0x2UL << RTC_TSDR_WDU_Pos)             /*!< 0x00004000 */
N#define RTC_TSDR_WDU_2                 (0x4UL << RTC_TSDR_WDU_Pos)             /*!< 0x00008000 */
N#define RTC_TSDR_MT_Pos                (12U)
N#define RTC_TSDR_MT_Msk                (0x1UL << RTC_TSDR_MT_Pos)              /*!< 0x00001000 */
N#define RTC_TSDR_MT                    RTC_TSDR_MT_Msk
N#define RTC_TSDR_MU_Pos                (8U)
N#define RTC_TSDR_MU_Msk                (0xFUL << RTC_TSDR_MU_Pos)              /*!< 0x00000F00 */
N#define RTC_TSDR_MU                    RTC_TSDR_MU_Msk
N#define RTC_TSDR_MU_0                  (0x1UL << RTC_TSDR_MU_Pos)              /*!< 0x00000100 */
N#define RTC_TSDR_MU_1                  (0x2UL << RTC_TSDR_MU_Pos)              /*!< 0x00000200 */
N#define RTC_TSDR_MU_2                  (0x4UL << RTC_TSDR_MU_Pos)              /*!< 0x00000400 */
N#define RTC_TSDR_MU_3                  (0x8UL << RTC_TSDR_MU_Pos)              /*!< 0x00000800 */
N#define RTC_TSDR_DT_Pos                (4U)
N#define RTC_TSDR_DT_Msk                (0x3UL << RTC_TSDR_DT_Pos)              /*!< 0x00000030 */
N#define RTC_TSDR_DT                    RTC_TSDR_DT_Msk
N#define RTC_TSDR_DT_0                  (0x1UL << RTC_TSDR_DT_Pos)              /*!< 0x00000010 */
N#define RTC_TSDR_DT_1                  (0x2UL << RTC_TSDR_DT_Pos)              /*!< 0x00000020 */
N#define RTC_TSDR_DU_Pos                (0U)
N#define RTC_TSDR_DU_Msk                (0xFUL << RTC_TSDR_DU_Pos)              /*!< 0x0000000F */
N#define RTC_TSDR_DU                    RTC_TSDR_DU_Msk
N#define RTC_TSDR_DU_0                  (0x1UL << RTC_TSDR_DU_Pos)              /*!< 0x00000001 */
N#define RTC_TSDR_DU_1                  (0x2UL << RTC_TSDR_DU_Pos)              /*!< 0x00000002 */
N#define RTC_TSDR_DU_2                  (0x4UL << RTC_TSDR_DU_Pos)              /*!< 0x00000004 */
N#define RTC_TSDR_DU_3                  (0x8UL << RTC_TSDR_DU_Pos)              /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS_Pos               (0U)
N#define RTC_TSSSR_SS_Msk               (0xFFFFUL << RTC_TSSSR_SS_Pos)          /*!< 0x0000FFFF */
N#define RTC_TSSSR_SS                   RTC_TSSSR_SS_Msk
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP_Pos              (15U)
N#define RTC_CALR_CALP_Msk              (0x1UL << RTC_CALR_CALP_Pos)            /*!< 0x00008000 */
N#define RTC_CALR_CALP                  RTC_CALR_CALP_Msk
N#define RTC_CALR_CALW8_Pos             (14U)
N#define RTC_CALR_CALW8_Msk             (0x1UL << RTC_CALR_CALW8_Pos)           /*!< 0x00004000 */
N#define RTC_CALR_CALW8                 RTC_CALR_CALW8_Msk
N#define RTC_CALR_CALW16_Pos            (13U)
N#define RTC_CALR_CALW16_Msk            (0x1UL << RTC_CALR_CALW16_Pos)          /*!< 0x00002000 */
N#define RTC_CALR_CALW16                RTC_CALR_CALW16_Msk
N#define RTC_CALR_CALM_Pos              (0U)
N#define RTC_CALR_CALM_Msk              (0x1FFUL << RTC_CALR_CALM_Pos)          /*!< 0x000001FF */
N#define RTC_CALR_CALM                  RTC_CALR_CALM_Msk
N#define RTC_CALR_CALM_0                (0x001UL << RTC_CALR_CALM_Pos)          /*!< 0x00000001 */
N#define RTC_CALR_CALM_1                (0x002UL << RTC_CALR_CALM_Pos)          /*!< 0x00000002 */
N#define RTC_CALR_CALM_2                (0x004UL << RTC_CALR_CALM_Pos)          /*!< 0x00000004 */
N#define RTC_CALR_CALM_3                (0x008UL << RTC_CALR_CALM_Pos)          /*!< 0x00000008 */
N#define RTC_CALR_CALM_4                (0x010UL << RTC_CALR_CALM_Pos)          /*!< 0x00000010 */
N#define RTC_CALR_CALM_5                (0x020UL << RTC_CALR_CALM_Pos)          /*!< 0x00000020 */
N#define RTC_CALR_CALM_6                (0x040UL << RTC_CALR_CALM_Pos)          /*!< 0x00000040 */
N#define RTC_CALR_CALM_7                (0x080UL << RTC_CALR_CALM_Pos)          /*!< 0x00000080 */
N#define RTC_CALR_CALM_8                (0x100UL << RTC_CALR_CALM_Pos)          /*!< 0x00000100 */
N
N/********************  Bits definition for RTC_TAMPCR register  ***************/
N#define RTC_TAMPCR_TAMP3MF_Pos         (24U)
N#define RTC_TAMPCR_TAMP3MF_Msk         (0x1UL << RTC_TAMPCR_TAMP3MF_Pos)       /*!< 0x01000000 */
N#define RTC_TAMPCR_TAMP3MF             RTC_TAMPCR_TAMP3MF_Msk
N#define RTC_TAMPCR_TAMP3NOERASE_Pos    (23U)
N#define RTC_TAMPCR_TAMP3NOERASE_Msk    (0x1UL << RTC_TAMPCR_TAMP3NOERASE_Pos)  /*!< 0x00800000 */
N#define RTC_TAMPCR_TAMP3NOERASE        RTC_TAMPCR_TAMP3NOERASE_Msk
N#define RTC_TAMPCR_TAMP3IE_Pos         (22U)
N#define RTC_TAMPCR_TAMP3IE_Msk         (0x1UL << RTC_TAMPCR_TAMP3IE_Pos)       /*!< 0x00400000 */
N#define RTC_TAMPCR_TAMP3IE             RTC_TAMPCR_TAMP3IE_Msk
N#define RTC_TAMPCR_TAMP2MF_Pos         (21U)
N#define RTC_TAMPCR_TAMP2MF_Msk         (0x1UL << RTC_TAMPCR_TAMP2MF_Pos)       /*!< 0x00200000 */
N#define RTC_TAMPCR_TAMP2MF             RTC_TAMPCR_TAMP2MF_Msk
N#define RTC_TAMPCR_TAMP2NOERASE_Pos    (20U)
N#define RTC_TAMPCR_TAMP2NOERASE_Msk    (0x1UL << RTC_TAMPCR_TAMP2NOERASE_Pos)  /*!< 0x00100000 */
N#define RTC_TAMPCR_TAMP2NOERASE        RTC_TAMPCR_TAMP2NOERASE_Msk
N#define RTC_TAMPCR_TAMP2IE_Pos         (19U)
N#define RTC_TAMPCR_TAMP2IE_Msk         (0x1UL << RTC_TAMPCR_TAMP2IE_Pos)       /*!< 0x00080000 */
N#define RTC_TAMPCR_TAMP2IE             RTC_TAMPCR_TAMP2IE_Msk
N#define RTC_TAMPCR_TAMP1MF_Pos         (18U)
N#define RTC_TAMPCR_TAMP1MF_Msk         (0x1UL << RTC_TAMPCR_TAMP1MF_Pos)       /*!< 0x00040000 */
N#define RTC_TAMPCR_TAMP1MF             RTC_TAMPCR_TAMP1MF_Msk
N#define RTC_TAMPCR_TAMP1NOERASE_Pos    (17U)
N#define RTC_TAMPCR_TAMP1NOERASE_Msk    (0x1UL << RTC_TAMPCR_TAMP1NOERASE_Pos)  /*!< 0x00020000 */
N#define RTC_TAMPCR_TAMP1NOERASE        RTC_TAMPCR_TAMP1NOERASE_Msk
N#define RTC_TAMPCR_TAMP1IE_Pos         (16U)
N#define RTC_TAMPCR_TAMP1IE_Msk         (0x1UL << RTC_TAMPCR_TAMP1IE_Pos)       /*!< 0x00010000 */
N#define RTC_TAMPCR_TAMP1IE             RTC_TAMPCR_TAMP1IE_Msk
N#define RTC_TAMPCR_TAMPPUDIS_Pos       (15U)
N#define RTC_TAMPCR_TAMPPUDIS_Msk       (0x1UL << RTC_TAMPCR_TAMPPUDIS_Pos)     /*!< 0x00008000 */
N#define RTC_TAMPCR_TAMPPUDIS           RTC_TAMPCR_TAMPPUDIS_Msk
N#define RTC_TAMPCR_TAMPPRCH_Pos        (13U)
N#define RTC_TAMPCR_TAMPPRCH_Msk        (0x3UL << RTC_TAMPCR_TAMPPRCH_Pos)      /*!< 0x00006000 */
N#define RTC_TAMPCR_TAMPPRCH            RTC_TAMPCR_TAMPPRCH_Msk
N#define RTC_TAMPCR_TAMPPRCH_0          (0x1UL << RTC_TAMPCR_TAMPPRCH_Pos)      /*!< 0x00002000 */
N#define RTC_TAMPCR_TAMPPRCH_1          (0x2UL << RTC_TAMPCR_TAMPPRCH_Pos)      /*!< 0x00004000 */
N#define RTC_TAMPCR_TAMPFLT_Pos         (11U)
N#define RTC_TAMPCR_TAMPFLT_Msk         (0x3UL << RTC_TAMPCR_TAMPFLT_Pos)       /*!< 0x00001800 */
N#define RTC_TAMPCR_TAMPFLT             RTC_TAMPCR_TAMPFLT_Msk
N#define RTC_TAMPCR_TAMPFLT_0           (0x1UL << RTC_TAMPCR_TAMPFLT_Pos)       /*!< 0x00000800 */
N#define RTC_TAMPCR_TAMPFLT_1           (0x2UL << RTC_TAMPCR_TAMPFLT_Pos)       /*!< 0x00001000 */
N#define RTC_TAMPCR_TAMPFREQ_Pos        (8U)
N#define RTC_TAMPCR_TAMPFREQ_Msk        (0x7UL << RTC_TAMPCR_TAMPFREQ_Pos)      /*!< 0x00000700 */
N#define RTC_TAMPCR_TAMPFREQ            RTC_TAMPCR_TAMPFREQ_Msk
N#define RTC_TAMPCR_TAMPFREQ_0          (0x1UL << RTC_TAMPCR_TAMPFREQ_Pos)      /*!< 0x00000100 */
N#define RTC_TAMPCR_TAMPFREQ_1          (0x2UL << RTC_TAMPCR_TAMPFREQ_Pos)      /*!< 0x00000200 */
N#define RTC_TAMPCR_TAMPFREQ_2          (0x4UL << RTC_TAMPCR_TAMPFREQ_Pos)      /*!< 0x00000400 */
N#define RTC_TAMPCR_TAMPTS_Pos          (7U)
N#define RTC_TAMPCR_TAMPTS_Msk          (0x1UL << RTC_TAMPCR_TAMPTS_Pos)        /*!< 0x00000080 */
N#define RTC_TAMPCR_TAMPTS              RTC_TAMPCR_TAMPTS_Msk
N#define RTC_TAMPCR_TAMP3TRG_Pos        (6U)
N#define RTC_TAMPCR_TAMP3TRG_Msk        (0x1UL << RTC_TAMPCR_TAMP3TRG_Pos)      /*!< 0x00000040 */
N#define RTC_TAMPCR_TAMP3TRG            RTC_TAMPCR_TAMP3TRG_Msk
N#define RTC_TAMPCR_TAMP3E_Pos          (5U)
N#define RTC_TAMPCR_TAMP3E_Msk          (0x1UL << RTC_TAMPCR_TAMP3E_Pos)        /*!< 0x00000020 */
N#define RTC_TAMPCR_TAMP3E              RTC_TAMPCR_TAMP3E_Msk
N#define RTC_TAMPCR_TAMP2TRG_Pos        (4U)
N#define RTC_TAMPCR_TAMP2TRG_Msk        (0x1UL << RTC_TAMPCR_TAMP2TRG_Pos)      /*!< 0x00000010 */
N#define RTC_TAMPCR_TAMP2TRG            RTC_TAMPCR_TAMP2TRG_Msk
N#define RTC_TAMPCR_TAMP2E_Pos          (3U)
N#define RTC_TAMPCR_TAMP2E_Msk          (0x1UL << RTC_TAMPCR_TAMP2E_Pos)        /*!< 0x00000008 */
N#define RTC_TAMPCR_TAMP2E              RTC_TAMPCR_TAMP2E_Msk
N#define RTC_TAMPCR_TAMPIE_Pos          (2U)
N#define RTC_TAMPCR_TAMPIE_Msk          (0x1UL << RTC_TAMPCR_TAMPIE_Pos)        /*!< 0x00000004 */
N#define RTC_TAMPCR_TAMPIE              RTC_TAMPCR_TAMPIE_Msk
N#define RTC_TAMPCR_TAMP1TRG_Pos        (1U)
N#define RTC_TAMPCR_TAMP1TRG_Msk        (0x1UL << RTC_TAMPCR_TAMP1TRG_Pos)      /*!< 0x00000002 */
N#define RTC_TAMPCR_TAMP1TRG            RTC_TAMPCR_TAMP1TRG_Msk
N#define RTC_TAMPCR_TAMP1E_Pos          (0U)
N#define RTC_TAMPCR_TAMP1E_Msk          (0x1UL << RTC_TAMPCR_TAMP1E_Pos)        /*!< 0x00000001 */
N#define RTC_TAMPCR_TAMP1E              RTC_TAMPCR_TAMP1E_Msk
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS_Pos        (24U)
N#define RTC_ALRMASSR_MASKSS_Msk        (0xFUL << RTC_ALRMASSR_MASKSS_Pos)      /*!< 0x0F000000 */
N#define RTC_ALRMASSR_MASKSS            RTC_ALRMASSR_MASKSS_Msk
N#define RTC_ALRMASSR_MASKSS_0          (0x1UL << RTC_ALRMASSR_MASKSS_Pos)      /*!< 0x01000000 */
N#define RTC_ALRMASSR_MASKSS_1          (0x2UL << RTC_ALRMASSR_MASKSS_Pos)      /*!< 0x02000000 */
N#define RTC_ALRMASSR_MASKSS_2          (0x4UL << RTC_ALRMASSR_MASKSS_Pos)      /*!< 0x04000000 */
N#define RTC_ALRMASSR_MASKSS_3          (0x8UL << RTC_ALRMASSR_MASKSS_Pos)      /*!< 0x08000000 */
N#define RTC_ALRMASSR_SS_Pos            (0U)
N#define RTC_ALRMASSR_SS_Msk            (0x7FFFUL << RTC_ALRMASSR_SS_Pos)       /*!< 0x00007FFF */
N#define RTC_ALRMASSR_SS                RTC_ALRMASSR_SS_Msk
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS_Pos        (24U)
N#define RTC_ALRMBSSR_MASKSS_Msk        (0xFUL << RTC_ALRMBSSR_MASKSS_Pos)      /*!< 0x0F000000 */
N#define RTC_ALRMBSSR_MASKSS            RTC_ALRMBSSR_MASKSS_Msk
N#define RTC_ALRMBSSR_MASKSS_0          (0x1UL << RTC_ALRMBSSR_MASKSS_Pos)      /*!< 0x01000000 */
N#define RTC_ALRMBSSR_MASKSS_1          (0x2UL << RTC_ALRMBSSR_MASKSS_Pos)      /*!< 0x02000000 */
N#define RTC_ALRMBSSR_MASKSS_2          (0x4UL << RTC_ALRMBSSR_MASKSS_Pos)      /*!< 0x04000000 */
N#define RTC_ALRMBSSR_MASKSS_3          (0x8UL << RTC_ALRMBSSR_MASKSS_Pos)      /*!< 0x08000000 */
N#define RTC_ALRMBSSR_SS_Pos            (0U)
N#define RTC_ALRMBSSR_SS_Msk            (0x7FFFUL << RTC_ALRMBSSR_SS_Pos)       /*!< 0x00007FFF */
N#define RTC_ALRMBSSR_SS                RTC_ALRMBSSR_SS_Msk
N
N/********************  Bits definition for RTC_0R register  *******************/
N#define RTC_OR_OUT_RMP_Pos             (1U)
N#define RTC_OR_OUT_RMP_Msk             (0x1UL << RTC_OR_OUT_RMP_Pos)           /*!< 0x00000002 */
N#define RTC_OR_OUT_RMP                 RTC_OR_OUT_RMP_Msk
N#define RTC_OR_ALARMOUTTYPE_Pos        (0U)
N#define RTC_OR_ALARMOUTTYPE_Msk        (0x1UL << RTC_OR_ALARMOUTTYPE_Pos)      /*!< 0x00000001 */
N#define RTC_OR_ALARMOUTTYPE            RTC_OR_ALARMOUTTYPE_Msk
N
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R_Pos                  (0U)
N#define RTC_BKP0R_Msk                  (0xFFFFFFFFUL << RTC_BKP0R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP0R                      RTC_BKP0R_Msk
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R_Pos                  (0U)
N#define RTC_BKP1R_Msk                  (0xFFFFFFFFUL << RTC_BKP1R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP1R                      RTC_BKP1R_Msk
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R_Pos                  (0U)
N#define RTC_BKP2R_Msk                  (0xFFFFFFFFUL << RTC_BKP2R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP2R                      RTC_BKP2R_Msk
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R_Pos                  (0U)
N#define RTC_BKP3R_Msk                  (0xFFFFFFFFUL << RTC_BKP3R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP3R                      RTC_BKP3R_Msk
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R_Pos                  (0U)
N#define RTC_BKP4R_Msk                  (0xFFFFFFFFUL << RTC_BKP4R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP4R                      RTC_BKP4R_Msk
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R_Pos                  (0U)
N#define RTC_BKP5R_Msk                  (0xFFFFFFFFUL << RTC_BKP5R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP5R                      RTC_BKP5R_Msk
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R_Pos                  (0U)
N#define RTC_BKP6R_Msk                  (0xFFFFFFFFUL << RTC_BKP6R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP6R                      RTC_BKP6R_Msk
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R_Pos                  (0U)
N#define RTC_BKP7R_Msk                  (0xFFFFFFFFUL << RTC_BKP7R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP7R                      RTC_BKP7R_Msk
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R_Pos                  (0U)
N#define RTC_BKP8R_Msk                  (0xFFFFFFFFUL << RTC_BKP8R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP8R                      RTC_BKP8R_Msk
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R_Pos                  (0U)
N#define RTC_BKP9R_Msk                  (0xFFFFFFFFUL << RTC_BKP9R_Pos)         /*!< 0xFFFFFFFF */
N#define RTC_BKP9R                      RTC_BKP9R_Msk
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R_Pos                 (0U)
N#define RTC_BKP10R_Msk                 (0xFFFFFFFFUL << RTC_BKP10R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP10R                     RTC_BKP10R_Msk
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R_Pos                 (0U)
N#define RTC_BKP11R_Msk                 (0xFFFFFFFFUL << RTC_BKP11R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP11R                     RTC_BKP11R_Msk
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R_Pos                 (0U)
N#define RTC_BKP12R_Msk                 (0xFFFFFFFFUL << RTC_BKP12R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP12R                     RTC_BKP12R_Msk
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R_Pos                 (0U)
N#define RTC_BKP13R_Msk                 (0xFFFFFFFFUL << RTC_BKP13R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP13R                     RTC_BKP13R_Msk
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R_Pos                 (0U)
N#define RTC_BKP14R_Msk                 (0xFFFFFFFFUL << RTC_BKP14R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP14R                     RTC_BKP14R_Msk
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R_Pos                 (0U)
N#define RTC_BKP15R_Msk                 (0xFFFFFFFFUL << RTC_BKP15R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP15R                     RTC_BKP15R_Msk
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R_Pos                 (0U)
N#define RTC_BKP16R_Msk                 (0xFFFFFFFFUL << RTC_BKP16R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP16R                     RTC_BKP16R_Msk
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R_Pos                 (0U)
N#define RTC_BKP17R_Msk                 (0xFFFFFFFFUL << RTC_BKP17R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP17R                     RTC_BKP17R_Msk
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R_Pos                 (0U)
N#define RTC_BKP18R_Msk                 (0xFFFFFFFFUL << RTC_BKP18R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP18R                     RTC_BKP18R_Msk
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R_Pos                 (0U)
N#define RTC_BKP19R_Msk                 (0xFFFFFFFFUL << RTC_BKP19R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP19R                     RTC_BKP19R_Msk
N
N/********************  Bits definition for RTC_BKP20R register  ***************/
N#define RTC_BKP20R_Pos                 (0U)
N#define RTC_BKP20R_Msk                 (0xFFFFFFFFUL << RTC_BKP20R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP20R                     RTC_BKP20R_Msk
N
N/********************  Bits definition for RTC_BKP21R register  ***************/
N#define RTC_BKP21R_Pos                 (0U)
N#define RTC_BKP21R_Msk                 (0xFFFFFFFFUL << RTC_BKP21R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP21R                     RTC_BKP21R_Msk
N
N/********************  Bits definition for RTC_BKP22R register  ***************/
N#define RTC_BKP22R_Pos                 (0U)
N#define RTC_BKP22R_Msk                 (0xFFFFFFFFUL << RTC_BKP22R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP22R                     RTC_BKP22R_Msk
N
N/********************  Bits definition for RTC_BKP23R register  ***************/
N#define RTC_BKP23R_Pos                 (0U)
N#define RTC_BKP23R_Msk                 (0xFFFFFFFFUL << RTC_BKP23R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP23R                     RTC_BKP23R_Msk
N
N/********************  Bits definition for RTC_BKP24R register  ***************/
N#define RTC_BKP24R_Pos                 (0U)
N#define RTC_BKP24R_Msk                 (0xFFFFFFFFUL << RTC_BKP24R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP24R                     RTC_BKP24R_Msk
N
N/********************  Bits definition for RTC_BKP25R register  ***************/
N#define RTC_BKP25R_Pos                 (0U)
N#define RTC_BKP25R_Msk                 (0xFFFFFFFFUL << RTC_BKP25R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP25R                     RTC_BKP25R_Msk
N
N/********************  Bits definition for RTC_BKP26R register  ***************/
N#define RTC_BKP26R_Pos                 (0U)
N#define RTC_BKP26R_Msk                 (0xFFFFFFFFUL << RTC_BKP26R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP26R                     RTC_BKP26R_Msk
N
N/********************  Bits definition for RTC_BKP27R register  ***************/
N#define RTC_BKP27R_Pos                 (0U)
N#define RTC_BKP27R_Msk                 (0xFFFFFFFFUL << RTC_BKP27R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP27R                     RTC_BKP27R_Msk
N
N/********************  Bits definition for RTC_BKP28R register  ***************/
N#define RTC_BKP28R_Pos                 (0U)
N#define RTC_BKP28R_Msk                 (0xFFFFFFFFUL << RTC_BKP28R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP28R                     RTC_BKP28R_Msk
N
N/********************  Bits definition for RTC_BKP29R register  ***************/
N#define RTC_BKP29R_Pos                 (0U)
N#define RTC_BKP29R_Msk                 (0xFFFFFFFFUL << RTC_BKP29R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP29R                     RTC_BKP29R_Msk
N
N/********************  Bits definition for RTC_BKP30R register  ***************/
N#define RTC_BKP30R_Pos                 (0U)
N#define RTC_BKP30R_Msk                 (0xFFFFFFFFUL << RTC_BKP30R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP30R                     RTC_BKP30R_Msk
N
N/********************  Bits definition for RTC_BKP31R register  ***************/
N#define RTC_BKP31R_Pos                 (0U)
N#define RTC_BKP31R_Msk                 (0xFFFFFFFFUL << RTC_BKP31R_Pos)        /*!< 0xFFFFFFFF */
N#define RTC_BKP31R                     RTC_BKP31R_Msk
N
N/******************** Number of backup registers ******************************/
N#define RTC_BKP_NUMBER                       32U
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Serial Audio Interface                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for SAI_GCR register  *******************/
N#define SAI_GCR_SYNCIN_Pos         (0U)
N#define SAI_GCR_SYNCIN_Msk         (0x3UL << SAI_GCR_SYNCIN_Pos)               /*!< 0x00000003 */
N#define SAI_GCR_SYNCIN             SAI_GCR_SYNCIN_Msk                          /*!<SYNCIN[1:0] bits (Synchronization Inputs)   */
N#define SAI_GCR_SYNCIN_0           (0x1UL << SAI_GCR_SYNCIN_Pos)               /*!< 0x00000001 */
N#define SAI_GCR_SYNCIN_1           (0x2UL << SAI_GCR_SYNCIN_Pos)               /*!< 0x00000002 */
N
N#define SAI_GCR_SYNCOUT_Pos        (4U)
N#define SAI_GCR_SYNCOUT_Msk        (0x3UL << SAI_GCR_SYNCOUT_Pos)              /*!< 0x00000030 */
N#define SAI_GCR_SYNCOUT            SAI_GCR_SYNCOUT_Msk                         /*!<SYNCOUT[1:0] bits (Synchronization Outputs) */
N#define SAI_GCR_SYNCOUT_0          (0x1UL << SAI_GCR_SYNCOUT_Pos)              /*!< 0x00000010 */
N#define SAI_GCR_SYNCOUT_1          (0x2UL << SAI_GCR_SYNCOUT_Pos)              /*!< 0x00000020 */
N
N/*******************  Bit definition for SAI_xCR1 register  *******************/
N#define SAI_xCR1_MODE_Pos          (0U)
N#define SAI_xCR1_MODE_Msk          (0x3UL << SAI_xCR1_MODE_Pos)                /*!< 0x00000003 */
N#define SAI_xCR1_MODE              SAI_xCR1_MODE_Msk                           /*!<MODE[1:0] bits (Audio Block Mode)           */
N#define SAI_xCR1_MODE_0            (0x1UL << SAI_xCR1_MODE_Pos)                /*!< 0x00000001 */
N#define SAI_xCR1_MODE_1            (0x2UL << SAI_xCR1_MODE_Pos)                /*!< 0x00000002 */
N
N#define SAI_xCR1_PRTCFG_Pos        (2U)
N#define SAI_xCR1_PRTCFG_Msk        (0x3UL << SAI_xCR1_PRTCFG_Pos)              /*!< 0x0000000C */
N#define SAI_xCR1_PRTCFG            SAI_xCR1_PRTCFG_Msk                         /*!<PRTCFG[1:0] bits (Protocol Configuration)   */
N#define SAI_xCR1_PRTCFG_0          (0x1UL << SAI_xCR1_PRTCFG_Pos)              /*!< 0x00000004 */
N#define SAI_xCR1_PRTCFG_1          (0x2UL << SAI_xCR1_PRTCFG_Pos)              /*!< 0x00000008 */
N
N#define SAI_xCR1_DS_Pos            (5U)
N#define SAI_xCR1_DS_Msk            (0x7UL << SAI_xCR1_DS_Pos)                  /*!< 0x000000E0 */
N#define SAI_xCR1_DS                SAI_xCR1_DS_Msk                             /*!<DS[1:0] bits (Data Size) */
N#define SAI_xCR1_DS_0              (0x1UL << SAI_xCR1_DS_Pos)                  /*!< 0x00000020 */
N#define SAI_xCR1_DS_1              (0x2UL << SAI_xCR1_DS_Pos)                  /*!< 0x00000040 */
N#define SAI_xCR1_DS_2              (0x4UL << SAI_xCR1_DS_Pos)                  /*!< 0x00000080 */
N
N#define SAI_xCR1_LSBFIRST_Pos      (8U)
N#define SAI_xCR1_LSBFIRST_Msk      (0x1UL << SAI_xCR1_LSBFIRST_Pos)            /*!< 0x00000100 */
N#define SAI_xCR1_LSBFIRST          SAI_xCR1_LSBFIRST_Msk                       /*!<LSB First Configuration  */
N#define SAI_xCR1_CKSTR_Pos         (9U)
N#define SAI_xCR1_CKSTR_Msk         (0x1UL << SAI_xCR1_CKSTR_Pos)               /*!< 0x00000200 */
N#define SAI_xCR1_CKSTR             SAI_xCR1_CKSTR_Msk                          /*!<ClocK STRobing edge      */
N
N#define SAI_xCR1_SYNCEN_Pos        (10U)
N#define SAI_xCR1_SYNCEN_Msk        (0x3UL << SAI_xCR1_SYNCEN_Pos)              /*!< 0x00000C00 */
N#define SAI_xCR1_SYNCEN            SAI_xCR1_SYNCEN_Msk                         /*!<SYNCEN[1:0](SYNChronization ENable) */
N#define SAI_xCR1_SYNCEN_0          (0x1UL << SAI_xCR1_SYNCEN_Pos)              /*!< 0x00000400 */
N#define SAI_xCR1_SYNCEN_1          (0x2UL << SAI_xCR1_SYNCEN_Pos)              /*!< 0x00000800 */
N
N#define SAI_xCR1_MONO_Pos          (12U)
N#define SAI_xCR1_MONO_Msk          (0x1UL << SAI_xCR1_MONO_Pos)                /*!< 0x00001000 */
N#define SAI_xCR1_MONO              SAI_xCR1_MONO_Msk                           /*!<Mono mode                  */
N#define SAI_xCR1_OUTDRIV_Pos       (13U)
N#define SAI_xCR1_OUTDRIV_Msk       (0x1UL << SAI_xCR1_OUTDRIV_Pos)             /*!< 0x00002000 */
N#define SAI_xCR1_OUTDRIV           SAI_xCR1_OUTDRIV_Msk                        /*!<Output Drive               */
N#define SAI_xCR1_SAIEN_Pos         (16U)
N#define SAI_xCR1_SAIEN_Msk         (0x1UL << SAI_xCR1_SAIEN_Pos)               /*!< 0x00010000 */
N#define SAI_xCR1_SAIEN             SAI_xCR1_SAIEN_Msk                          /*!<Audio Block enable         */
N#define SAI_xCR1_DMAEN_Pos         (17U)
N#define SAI_xCR1_DMAEN_Msk         (0x1UL << SAI_xCR1_DMAEN_Pos)               /*!< 0x00020000 */
N#define SAI_xCR1_DMAEN             SAI_xCR1_DMAEN_Msk                          /*!<DMA enable                 */
N#define SAI_xCR1_NODIV_Pos         (19U)
N#define SAI_xCR1_NODIV_Msk         (0x1UL << SAI_xCR1_NODIV_Pos)               /*!< 0x00080000 */
N#define SAI_xCR1_NODIV             SAI_xCR1_NODIV_Msk                          /*!<No Divider Configuration   */
N
N#define SAI_xCR1_MCKDIV_Pos        (20U)
N#define SAI_xCR1_MCKDIV_Msk        (0xFUL << SAI_xCR1_MCKDIV_Pos)              /*!< 0x00F00000 */
N#define SAI_xCR1_MCKDIV            SAI_xCR1_MCKDIV_Msk                         /*!<MCKDIV[3:0] (Master ClocK Divider)  */
N#define SAI_xCR1_MCKDIV_0          (0x1UL << SAI_xCR1_MCKDIV_Pos)              /*!< 0x00100000 */
N#define SAI_xCR1_MCKDIV_1          (0x2UL << SAI_xCR1_MCKDIV_Pos)              /*!< 0x00200000 */
N#define SAI_xCR1_MCKDIV_2          (0x4UL << SAI_xCR1_MCKDIV_Pos)              /*!< 0x00400000 */
N#define SAI_xCR1_MCKDIV_3          (0x8UL << SAI_xCR1_MCKDIV_Pos)              /*!< 0x00800000 */
N
N/*******************  Bit definition for SAI_xCR2 register  *******************/
N#define SAI_xCR2_FTH_Pos           (0U)
N#define SAI_xCR2_FTH_Msk           (0x7UL << SAI_xCR2_FTH_Pos)                 /*!< 0x00000007 */
N#define SAI_xCR2_FTH               SAI_xCR2_FTH_Msk                            /*!<FTH[2:0](Fifo THreshold)  */
N#define SAI_xCR2_FTH_0             (0x1UL << SAI_xCR2_FTH_Pos)                 /*!< 0x00000001 */
N#define SAI_xCR2_FTH_1             (0x2UL << SAI_xCR2_FTH_Pos)                 /*!< 0x00000002 */
N#define SAI_xCR2_FTH_2             (0x4UL << SAI_xCR2_FTH_Pos)                 /*!< 0x00000004 */
N
N#define SAI_xCR2_FFLUSH_Pos        (3U)
N#define SAI_xCR2_FFLUSH_Msk        (0x1UL << SAI_xCR2_FFLUSH_Pos)              /*!< 0x00000008 */
N#define SAI_xCR2_FFLUSH            SAI_xCR2_FFLUSH_Msk                         /*!<Fifo FLUSH                       */
N#define SAI_xCR2_TRIS_Pos          (4U)
N#define SAI_xCR2_TRIS_Msk          (0x1UL << SAI_xCR2_TRIS_Pos)                /*!< 0x00000010 */
N#define SAI_xCR2_TRIS              SAI_xCR2_TRIS_Msk                           /*!<TRIState Management on data line */
N#define SAI_xCR2_MUTE_Pos          (5U)
N#define SAI_xCR2_MUTE_Msk          (0x1UL << SAI_xCR2_MUTE_Pos)                /*!< 0x00000020 */
N#define SAI_xCR2_MUTE              SAI_xCR2_MUTE_Msk                           /*!<Mute mode                        */
N#define SAI_xCR2_MUTEVAL_Pos       (6U)
N#define SAI_xCR2_MUTEVAL_Msk       (0x1UL << SAI_xCR2_MUTEVAL_Pos)             /*!< 0x00000040 */
N#define SAI_xCR2_MUTEVAL           SAI_xCR2_MUTEVAL_Msk                        /*!<Muate value                      */
N
N
N#define SAI_xCR2_MUTECNT_Pos       (7U)
N#define SAI_xCR2_MUTECNT_Msk       (0x3FUL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00001F80 */
N#define SAI_xCR2_MUTECNT           SAI_xCR2_MUTECNT_Msk                        /*!<MUTECNT[5:0] (MUTE counter) */
N#define SAI_xCR2_MUTECNT_0         (0x01UL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00000080 */
N#define SAI_xCR2_MUTECNT_1         (0x02UL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00000100 */
N#define SAI_xCR2_MUTECNT_2         (0x04UL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00000200 */
N#define SAI_xCR2_MUTECNT_3         (0x08UL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00000400 */
N#define SAI_xCR2_MUTECNT_4         (0x10UL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00000800 */
N#define SAI_xCR2_MUTECNT_5         (0x20UL << SAI_xCR2_MUTECNT_Pos)            /*!< 0x00001000 */
N
N#define SAI_xCR2_CPL_Pos           (13U)
N#define SAI_xCR2_CPL_Msk           (0x1UL << SAI_xCR2_CPL_Pos)                 /*!< 0x00002000 */
N#define SAI_xCR2_CPL               SAI_xCR2_CPL_Msk                            /*!<CPL mode                    */
N#define SAI_xCR2_COMP_Pos          (14U)
N#define SAI_xCR2_COMP_Msk          (0x3UL << SAI_xCR2_COMP_Pos)                /*!< 0x0000C000 */
N#define SAI_xCR2_COMP              SAI_xCR2_COMP_Msk                           /*!<COMP[1:0] (Companding mode) */
N#define SAI_xCR2_COMP_0            (0x1UL << SAI_xCR2_COMP_Pos)                /*!< 0x00004000 */
N#define SAI_xCR2_COMP_1            (0x2UL << SAI_xCR2_COMP_Pos)                /*!< 0x00008000 */
N
N
N/******************  Bit definition for SAI_xFRCR register  *******************/
N#define SAI_xFRCR_FRL_Pos          (0U)
N#define SAI_xFRCR_FRL_Msk          (0xFFUL << SAI_xFRCR_FRL_Pos)               /*!< 0x000000FF */
N#define SAI_xFRCR_FRL              SAI_xFRCR_FRL_Msk                           /*!<FRL[7:0](Frame length)  */
N#define SAI_xFRCR_FRL_0            (0x01UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000001 */
N#define SAI_xFRCR_FRL_1            (0x02UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000002 */
N#define SAI_xFRCR_FRL_2            (0x04UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000004 */
N#define SAI_xFRCR_FRL_3            (0x08UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000008 */
N#define SAI_xFRCR_FRL_4            (0x10UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000010 */
N#define SAI_xFRCR_FRL_5            (0x20UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000020 */
N#define SAI_xFRCR_FRL_6            (0x40UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000040 */
N#define SAI_xFRCR_FRL_7            (0x80UL << SAI_xFRCR_FRL_Pos)               /*!< 0x00000080 */
N
N#define SAI_xFRCR_FSALL_Pos        (8U)
N#define SAI_xFRCR_FSALL_Msk        (0x7FUL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00007F00 */
N#define SAI_xFRCR_FSALL            SAI_xFRCR_FSALL_Msk                         /*!<FRL[6:0] (Frame synchronization active level length)  */
N#define SAI_xFRCR_FSALL_0          (0x01UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00000100 */
N#define SAI_xFRCR_FSALL_1          (0x02UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00000200 */
N#define SAI_xFRCR_FSALL_2          (0x04UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00000400 */
N#define SAI_xFRCR_FSALL_3          (0x08UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00000800 */
N#define SAI_xFRCR_FSALL_4          (0x10UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00001000 */
N#define SAI_xFRCR_FSALL_5          (0x20UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00002000 */
N#define SAI_xFRCR_FSALL_6          (0x40UL << SAI_xFRCR_FSALL_Pos)             /*!< 0x00004000 */
N
N#define SAI_xFRCR_FSDEF_Pos        (16U)
N#define SAI_xFRCR_FSDEF_Msk        (0x1UL << SAI_xFRCR_FSDEF_Pos)              /*!< 0x00010000 */
N#define SAI_xFRCR_FSDEF            SAI_xFRCR_FSDEF_Msk                         /*!< Frame Synchronization Definition */
N#define SAI_xFRCR_FSPOL_Pos        (17U)
N#define SAI_xFRCR_FSPOL_Msk        (0x1UL << SAI_xFRCR_FSPOL_Pos)              /*!< 0x00020000 */
N#define SAI_xFRCR_FSPOL            SAI_xFRCR_FSPOL_Msk                         /*!<Frame Synchronization POLarity    */
N#define SAI_xFRCR_FSOFF_Pos        (18U)
N#define SAI_xFRCR_FSOFF_Msk        (0x1UL << SAI_xFRCR_FSOFF_Pos)              /*!< 0x00040000 */
N#define SAI_xFRCR_FSOFF            SAI_xFRCR_FSOFF_Msk                         /*!<Frame Synchronization OFFset      */
N
N/******************  Bit definition for SAI_xSLOTR register  *******************/
N#define SAI_xSLOTR_FBOFF_Pos       (0U)
N#define SAI_xSLOTR_FBOFF_Msk       (0x1FUL << SAI_xSLOTR_FBOFF_Pos)            /*!< 0x0000001F */
N#define SAI_xSLOTR_FBOFF           SAI_xSLOTR_FBOFF_Msk                        /*!<FRL[4:0](First Bit Offset)  */
N#define SAI_xSLOTR_FBOFF_0         (0x01UL << SAI_xSLOTR_FBOFF_Pos)            /*!< 0x00000001 */
N#define SAI_xSLOTR_FBOFF_1         (0x02UL << SAI_xSLOTR_FBOFF_Pos)            /*!< 0x00000002 */
N#define SAI_xSLOTR_FBOFF_2         (0x04UL << SAI_xSLOTR_FBOFF_Pos)            /*!< 0x00000004 */
N#define SAI_xSLOTR_FBOFF_3         (0x08UL << SAI_xSLOTR_FBOFF_Pos)            /*!< 0x00000008 */
N#define SAI_xSLOTR_FBOFF_4         (0x10UL << SAI_xSLOTR_FBOFF_Pos)            /*!< 0x00000010 */
N
N#define SAI_xSLOTR_SLOTSZ_Pos      (6U)
N#define SAI_xSLOTR_SLOTSZ_Msk      (0x3UL << SAI_xSLOTR_SLOTSZ_Pos)            /*!< 0x000000C0 */
N#define SAI_xSLOTR_SLOTSZ          SAI_xSLOTR_SLOTSZ_Msk                       /*!<SLOTSZ[1:0] (Slot size)  */
N#define SAI_xSLOTR_SLOTSZ_0        (0x1UL << SAI_xSLOTR_SLOTSZ_Pos)            /*!< 0x00000040 */
N#define SAI_xSLOTR_SLOTSZ_1        (0x2UL << SAI_xSLOTR_SLOTSZ_Pos)            /*!< 0x00000080 */
N
N#define SAI_xSLOTR_NBSLOT_Pos      (8U)
N#define SAI_xSLOTR_NBSLOT_Msk      (0xFUL << SAI_xSLOTR_NBSLOT_Pos)            /*!< 0x00000F00 */
N#define SAI_xSLOTR_NBSLOT          SAI_xSLOTR_NBSLOT_Msk                       /*!<NBSLOT[3:0] (Number of Slot in audio Frame)  */
N#define SAI_xSLOTR_NBSLOT_0        (0x1UL << SAI_xSLOTR_NBSLOT_Pos)            /*!< 0x00000100 */
N#define SAI_xSLOTR_NBSLOT_1        (0x2UL << SAI_xSLOTR_NBSLOT_Pos)            /*!< 0x00000200 */
N#define SAI_xSLOTR_NBSLOT_2        (0x4UL << SAI_xSLOTR_NBSLOT_Pos)            /*!< 0x00000400 */
N#define SAI_xSLOTR_NBSLOT_3        (0x8UL << SAI_xSLOTR_NBSLOT_Pos)            /*!< 0x00000800 */
N
N#define SAI_xSLOTR_SLOTEN_Pos      (16U)
N#define SAI_xSLOTR_SLOTEN_Msk      (0xFFFFUL << SAI_xSLOTR_SLOTEN_Pos)         /*!< 0xFFFF0000 */
N#define SAI_xSLOTR_SLOTEN          SAI_xSLOTR_SLOTEN_Msk                       /*!<SLOTEN[15:0] (Slot Enable)  */
N
N/*******************  Bit definition for SAI_xIMR register  *******************/
N#define SAI_xIMR_OVRUDRIE_Pos      (0U)
N#define SAI_xIMR_OVRUDRIE_Msk      (0x1UL << SAI_xIMR_OVRUDRIE_Pos)            /*!< 0x00000001 */
N#define SAI_xIMR_OVRUDRIE          SAI_xIMR_OVRUDRIE_Msk                       /*!<Overrun underrun interrupt enable                              */
N#define SAI_xIMR_MUTEDETIE_Pos     (1U)
N#define SAI_xIMR_MUTEDETIE_Msk     (0x1UL << SAI_xIMR_MUTEDETIE_Pos)           /*!< 0x00000002 */
N#define SAI_xIMR_MUTEDETIE         SAI_xIMR_MUTEDETIE_Msk                      /*!<Mute detection interrupt enable                                */
N#define SAI_xIMR_WCKCFGIE_Pos      (2U)
N#define SAI_xIMR_WCKCFGIE_Msk      (0x1UL << SAI_xIMR_WCKCFGIE_Pos)            /*!< 0x00000004 */
N#define SAI_xIMR_WCKCFGIE          SAI_xIMR_WCKCFGIE_Msk                       /*!<Wrong Clock Configuration interrupt enable                     */
N#define SAI_xIMR_FREQIE_Pos        (3U)
N#define SAI_xIMR_FREQIE_Msk        (0x1UL << SAI_xIMR_FREQIE_Pos)              /*!< 0x00000008 */
N#define SAI_xIMR_FREQIE            SAI_xIMR_FREQIE_Msk                         /*!<FIFO request interrupt enable                                  */
N#define SAI_xIMR_CNRDYIE_Pos       (4U)
N#define SAI_xIMR_CNRDYIE_Msk       (0x1UL << SAI_xIMR_CNRDYIE_Pos)             /*!< 0x00000010 */
N#define SAI_xIMR_CNRDYIE           SAI_xIMR_CNRDYIE_Msk                        /*!<Codec not ready interrupt enable                               */
N#define SAI_xIMR_AFSDETIE_Pos      (5U)
N#define SAI_xIMR_AFSDETIE_Msk      (0x1UL << SAI_xIMR_AFSDETIE_Pos)            /*!< 0x00000020 */
N#define SAI_xIMR_AFSDETIE          SAI_xIMR_AFSDETIE_Msk                       /*!<Anticipated frame synchronization detection interrupt enable   */
N#define SAI_xIMR_LFSDETIE_Pos      (6U)
N#define SAI_xIMR_LFSDETIE_Msk      (0x1UL << SAI_xIMR_LFSDETIE_Pos)            /*!< 0x00000040 */
N#define SAI_xIMR_LFSDETIE          SAI_xIMR_LFSDETIE_Msk                       /*!<Late frame synchronization detection interrupt enable          */
N
N/********************  Bit definition for SAI_xSR register  *******************/
N#define SAI_xSR_OVRUDR_Pos         (0U)
N#define SAI_xSR_OVRUDR_Msk         (0x1UL << SAI_xSR_OVRUDR_Pos)               /*!< 0x00000001 */
N#define SAI_xSR_OVRUDR             SAI_xSR_OVRUDR_Msk                          /*!<Overrun underrun                               */
N#define SAI_xSR_MUTEDET_Pos        (1U)
N#define SAI_xSR_MUTEDET_Msk        (0x1UL << SAI_xSR_MUTEDET_Pos)              /*!< 0x00000002 */
N#define SAI_xSR_MUTEDET            SAI_xSR_MUTEDET_Msk                         /*!<Mute detection                                 */
N#define SAI_xSR_WCKCFG_Pos         (2U)
N#define SAI_xSR_WCKCFG_Msk         (0x1UL << SAI_xSR_WCKCFG_Pos)               /*!< 0x00000004 */
N#define SAI_xSR_WCKCFG             SAI_xSR_WCKCFG_Msk                          /*!<Wrong Clock Configuration                      */
N#define SAI_xSR_FREQ_Pos           (3U)
N#define SAI_xSR_FREQ_Msk           (0x1UL << SAI_xSR_FREQ_Pos)                 /*!< 0x00000008 */
N#define SAI_xSR_FREQ               SAI_xSR_FREQ_Msk                            /*!<FIFO request                                   */
N#define SAI_xSR_CNRDY_Pos          (4U)
N#define SAI_xSR_CNRDY_Msk          (0x1UL << SAI_xSR_CNRDY_Pos)                /*!< 0x00000010 */
N#define SAI_xSR_CNRDY              SAI_xSR_CNRDY_Msk                           /*!<Codec not ready                                */
N#define SAI_xSR_AFSDET_Pos         (5U)
N#define SAI_xSR_AFSDET_Msk         (0x1UL << SAI_xSR_AFSDET_Pos)               /*!< 0x00000020 */
N#define SAI_xSR_AFSDET             SAI_xSR_AFSDET_Msk                          /*!<Anticipated frame synchronization detection    */
N#define SAI_xSR_LFSDET_Pos         (6U)
N#define SAI_xSR_LFSDET_Msk         (0x1UL << SAI_xSR_LFSDET_Pos)               /*!< 0x00000040 */
N#define SAI_xSR_LFSDET             SAI_xSR_LFSDET_Msk                          /*!<Late frame synchronization detection           */
N
N#define SAI_xSR_FLVL_Pos           (16U)
N#define SAI_xSR_FLVL_Msk           (0x7UL << SAI_xSR_FLVL_Pos)                 /*!< 0x00070000 */
N#define SAI_xSR_FLVL               SAI_xSR_FLVL_Msk                            /*!<FLVL[2:0] (FIFO Level Threshold)               */
N#define SAI_xSR_FLVL_0             (0x1UL << SAI_xSR_FLVL_Pos)                 /*!< 0x00010000 */
N#define SAI_xSR_FLVL_1             (0x2UL << SAI_xSR_FLVL_Pos)                 /*!< 0x00020000 */
N#define SAI_xSR_FLVL_2             (0x4UL << SAI_xSR_FLVL_Pos)                 /*!< 0x00040000 */
N
N/******************  Bit definition for SAI_xCLRFR register  ******************/
N#define SAI_xCLRFR_COVRUDR_Pos     (0U)
N#define SAI_xCLRFR_COVRUDR_Msk     (0x1UL << SAI_xCLRFR_COVRUDR_Pos)           /*!< 0x00000001 */
N#define SAI_xCLRFR_COVRUDR         SAI_xCLRFR_COVRUDR_Msk                      /*!<Clear Overrun underrun                               */
N#define SAI_xCLRFR_CMUTEDET_Pos    (1U)
N#define SAI_xCLRFR_CMUTEDET_Msk    (0x1UL << SAI_xCLRFR_CMUTEDET_Pos)          /*!< 0x00000002 */
N#define SAI_xCLRFR_CMUTEDET        SAI_xCLRFR_CMUTEDET_Msk                     /*!<Clear Mute detection                                 */
N#define SAI_xCLRFR_CWCKCFG_Pos     (2U)
N#define SAI_xCLRFR_CWCKCFG_Msk     (0x1UL << SAI_xCLRFR_CWCKCFG_Pos)           /*!< 0x00000004 */
N#define SAI_xCLRFR_CWCKCFG         SAI_xCLRFR_CWCKCFG_Msk                      /*!<Clear Wrong Clock Configuration                      */
N#define SAI_xCLRFR_CFREQ_Pos       (3U)
N#define SAI_xCLRFR_CFREQ_Msk       (0x1UL << SAI_xCLRFR_CFREQ_Pos)             /*!< 0x00000008 */
N#define SAI_xCLRFR_CFREQ           SAI_xCLRFR_CFREQ_Msk                        /*!<Clear FIFO request                                   */
N#define SAI_xCLRFR_CCNRDY_Pos      (4U)
N#define SAI_xCLRFR_CCNRDY_Msk      (0x1UL << SAI_xCLRFR_CCNRDY_Pos)            /*!< 0x00000010 */
N#define SAI_xCLRFR_CCNRDY          SAI_xCLRFR_CCNRDY_Msk                       /*!<Clear Codec not ready                                */
N#define SAI_xCLRFR_CAFSDET_Pos     (5U)
N#define SAI_xCLRFR_CAFSDET_Msk     (0x1UL << SAI_xCLRFR_CAFSDET_Pos)           /*!< 0x00000020 */
N#define SAI_xCLRFR_CAFSDET         SAI_xCLRFR_CAFSDET_Msk                      /*!<Clear Anticipated frame synchronization detection    */
N#define SAI_xCLRFR_CLFSDET_Pos     (6U)
N#define SAI_xCLRFR_CLFSDET_Msk     (0x1UL << SAI_xCLRFR_CLFSDET_Pos)           /*!< 0x00000040 */
N#define SAI_xCLRFR_CLFSDET         SAI_xCLRFR_CLFSDET_Msk                      /*!<Clear Late frame synchronization detection           */
N
N/******************  Bit definition for SAI_xDR register  ******************/
N#define SAI_xDR_DATA_Pos           (0U)
N#define SAI_xDR_DATA_Msk           (0xFFFFFFFFUL << SAI_xDR_DATA_Pos)          /*!< 0xFFFFFFFF */
N#define SAI_xDR_DATA               SAI_xDR_DATA_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                           SDMMC Interface                                  */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SDMMC_POWER register  ******************/
N#define SDMMC_POWER_PWRCTRL_Pos         (0U)
N#define SDMMC_POWER_PWRCTRL_Msk         (0x3UL << SDMMC_POWER_PWRCTRL_Pos)     /*!< 0x00000003 */
N#define SDMMC_POWER_PWRCTRL             SDMMC_POWER_PWRCTRL_Msk                /*!<PWRCTRL[1:0] bits (Power supply control bits) */
N#define SDMMC_POWER_PWRCTRL_0           (0x1UL << SDMMC_POWER_PWRCTRL_Pos)     /*!< 0x00000001 */
N#define SDMMC_POWER_PWRCTRL_1           (0x2UL << SDMMC_POWER_PWRCTRL_Pos)     /*!< 0x00000002 */
N
N/******************  Bit definition for SDMMC_CLKCR register  ******************/
N#define SDMMC_CLKCR_CLKDIV_Pos          (0U)
N#define SDMMC_CLKCR_CLKDIV_Msk          (0xFFUL << SDMMC_CLKCR_CLKDIV_Pos)     /*!< 0x000000FF */
N#define SDMMC_CLKCR_CLKDIV              SDMMC_CLKCR_CLKDIV_Msk                 /*!<Clock divide factor             */
N#define SDMMC_CLKCR_CLKEN_Pos           (8U)
N#define SDMMC_CLKCR_CLKEN_Msk           (0x1UL << SDMMC_CLKCR_CLKEN_Pos)       /*!< 0x00000100 */
N#define SDMMC_CLKCR_CLKEN               SDMMC_CLKCR_CLKEN_Msk                  /*!<Clock enable bit                */
N#define SDMMC_CLKCR_PWRSAV_Pos          (9U)
N#define SDMMC_CLKCR_PWRSAV_Msk          (0x1UL << SDMMC_CLKCR_PWRSAV_Pos)      /*!< 0x00000200 */
N#define SDMMC_CLKCR_PWRSAV              SDMMC_CLKCR_PWRSAV_Msk                 /*!<Power saving configuration bit  */
N#define SDMMC_CLKCR_BYPASS_Pos          (10U)
N#define SDMMC_CLKCR_BYPASS_Msk          (0x1UL << SDMMC_CLKCR_BYPASS_Pos)      /*!< 0x00000400 */
N#define SDMMC_CLKCR_BYPASS              SDMMC_CLKCR_BYPASS_Msk                 /*!<Clock divider bypass enable bit */
N
N#define SDMMC_CLKCR_WIDBUS_Pos          (11U)
N#define SDMMC_CLKCR_WIDBUS_Msk          (0x3UL << SDMMC_CLKCR_WIDBUS_Pos)      /*!< 0x00001800 */
N#define SDMMC_CLKCR_WIDBUS              SDMMC_CLKCR_WIDBUS_Msk                 /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define SDMMC_CLKCR_WIDBUS_0            (0x1UL << SDMMC_CLKCR_WIDBUS_Pos)      /*!< 0x00000800 */
N#define SDMMC_CLKCR_WIDBUS_1            (0x2UL << SDMMC_CLKCR_WIDBUS_Pos)      /*!< 0x00001000 */
N
N#define SDMMC_CLKCR_NEGEDGE_Pos         (13U)
N#define SDMMC_CLKCR_NEGEDGE_Msk         (0x1UL << SDMMC_CLKCR_NEGEDGE_Pos)     /*!< 0x00002000 */
N#define SDMMC_CLKCR_NEGEDGE             SDMMC_CLKCR_NEGEDGE_Msk                /*!<SDMMC_CK dephasing selection bit */
N#define SDMMC_CLKCR_HWFC_EN_Pos         (14U)
N#define SDMMC_CLKCR_HWFC_EN_Msk         (0x1UL << SDMMC_CLKCR_HWFC_EN_Pos)     /*!< 0x00004000 */
N#define SDMMC_CLKCR_HWFC_EN             SDMMC_CLKCR_HWFC_EN_Msk                /*!<HW Flow Control enable          */
N
N/*******************  Bit definition for SDMMC_ARG register  *******************/
N#define SDMMC_ARG_CMDARG_Pos            (0U)
N#define SDMMC_ARG_CMDARG_Msk            (0xFFFFFFFFUL << SDMMC_ARG_CMDARG_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_ARG_CMDARG                SDMMC_ARG_CMDARG_Msk                   /*!<Command argument */
N
N/*******************  Bit definition for SDMMC_CMD register  *******************/
N#define SDMMC_CMD_CMDINDEX_Pos          (0U)
N#define SDMMC_CMD_CMDINDEX_Msk          (0x3FUL << SDMMC_CMD_CMDINDEX_Pos)     /*!< 0x0000003F */
N#define SDMMC_CMD_CMDINDEX              SDMMC_CMD_CMDINDEX_Msk                 /*!<Command Index                               */
N
N#define SDMMC_CMD_WAITRESP_Pos          (6U)
N#define SDMMC_CMD_WAITRESP_Msk          (0x3UL << SDMMC_CMD_WAITRESP_Pos)      /*!< 0x000000C0 */
N#define SDMMC_CMD_WAITRESP              SDMMC_CMD_WAITRESP_Msk                 /*!<WAITRESP[1:0] bits (Wait for response bits) */
N#define SDMMC_CMD_WAITRESP_0            (0x1UL << SDMMC_CMD_WAITRESP_Pos)      /*!< 0x00000040 */
N#define SDMMC_CMD_WAITRESP_1            (0x2UL << SDMMC_CMD_WAITRESP_Pos)      /*!< 0x00000080 */
N
N#define SDMMC_CMD_WAITINT_Pos           (8U)
N#define SDMMC_CMD_WAITINT_Msk           (0x1UL << SDMMC_CMD_WAITINT_Pos)       /*!< 0x00000100 */
N#define SDMMC_CMD_WAITINT               SDMMC_CMD_WAITINT_Msk                  /*!<CPSM Waits for Interrupt Request                               */
N#define SDMMC_CMD_WAITPEND_Pos          (9U)
N#define SDMMC_CMD_WAITPEND_Msk          (0x1UL << SDMMC_CMD_WAITPEND_Pos)      /*!< 0x00000200 */
N#define SDMMC_CMD_WAITPEND              SDMMC_CMD_WAITPEND_Msk                 /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define SDMMC_CMD_CPSMEN_Pos            (10U)
N#define SDMMC_CMD_CPSMEN_Msk            (0x1UL << SDMMC_CMD_CPSMEN_Pos)        /*!< 0x00000400 */
N#define SDMMC_CMD_CPSMEN                SDMMC_CMD_CPSMEN_Msk                   /*!<Command path state machine (CPSM) Enable bit                   */
N#define SDMMC_CMD_SDIOSUSPEND_Pos       (11U)
N#define SDMMC_CMD_SDIOSUSPEND_Msk       (0x1UL << SDMMC_CMD_SDIOSUSPEND_Pos)   /*!< 0x00000800 */
N#define SDMMC_CMD_SDIOSUSPEND           SDMMC_CMD_SDIOSUSPEND_Msk              /*!<SD I/O suspend command                                         */
N
N/*****************  Bit definition for SDMMC_RESPCMD register  *****************/
N#define SDMMC_RESPCMD_RESPCMD_Pos       (0U)
N#define SDMMC_RESPCMD_RESPCMD_Msk       (0x3FUL << SDMMC_RESPCMD_RESPCMD_Pos)  /*!< 0x0000003F */
N#define SDMMC_RESPCMD_RESPCMD           SDMMC_RESPCMD_RESPCMD_Msk              /*!<Response command index */
N
N/******************  Bit definition for SDMMC_RESP1 register  ******************/
N#define SDMMC_RESP1_CARDSTATUS1_Pos     (0U)
N#define SDMMC_RESP1_CARDSTATUS1_Msk     (0xFFFFFFFFUL << SDMMC_RESP1_CARDSTATUS1_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_RESP1_CARDSTATUS1         SDMMC_RESP1_CARDSTATUS1_Msk            /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP2 register  ******************/
N#define SDMMC_RESP2_CARDSTATUS2_Pos     (0U)
N#define SDMMC_RESP2_CARDSTATUS2_Msk     (0xFFFFFFFFUL << SDMMC_RESP2_CARDSTATUS2_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_RESP2_CARDSTATUS2         SDMMC_RESP2_CARDSTATUS2_Msk            /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP3 register  ******************/
N#define SDMMC_RESP3_CARDSTATUS3_Pos     (0U)
N#define SDMMC_RESP3_CARDSTATUS3_Msk     (0xFFFFFFFFUL << SDMMC_RESP3_CARDSTATUS3_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_RESP3_CARDSTATUS3         SDMMC_RESP3_CARDSTATUS3_Msk            /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP4 register  ******************/
N#define SDMMC_RESP4_CARDSTATUS4_Pos     (0U)
N#define SDMMC_RESP4_CARDSTATUS4_Msk     (0xFFFFFFFFUL << SDMMC_RESP4_CARDSTATUS4_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_RESP4_CARDSTATUS4         SDMMC_RESP4_CARDSTATUS4_Msk            /*!<Card Status */
N
N/******************  Bit definition for SDMMC_DTIMER register  *****************/
N#define SDMMC_DTIMER_DATATIME_Pos       (0U)
N#define SDMMC_DTIMER_DATATIME_Msk       (0xFFFFFFFFUL << SDMMC_DTIMER_DATATIME_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_DTIMER_DATATIME           SDMMC_DTIMER_DATATIME_Msk              /*!<Data timeout period. */
N
N/******************  Bit definition for SDMMC_DLEN register  *******************/
N#define SDMMC_DLEN_DATALENGTH_Pos       (0U)
N#define SDMMC_DLEN_DATALENGTH_Msk       (0x1FFFFFFUL << SDMMC_DLEN_DATALENGTH_Pos) /*!< 0x01FFFFFF */
N#define SDMMC_DLEN_DATALENGTH           SDMMC_DLEN_DATALENGTH_Msk              /*!<Data length value    */
N
N/******************  Bit definition for SDMMC_DCTRL register  ******************/
N#define SDMMC_DCTRL_DTEN_Pos            (0U)
N#define SDMMC_DCTRL_DTEN_Msk            (0x1UL << SDMMC_DCTRL_DTEN_Pos)        /*!< 0x00000001 */
N#define SDMMC_DCTRL_DTEN                SDMMC_DCTRL_DTEN_Msk                   /*!<Data transfer enabled bit         */
N#define SDMMC_DCTRL_DTDIR_Pos           (1U)
N#define SDMMC_DCTRL_DTDIR_Msk           (0x1UL << SDMMC_DCTRL_DTDIR_Pos)       /*!< 0x00000002 */
N#define SDMMC_DCTRL_DTDIR               SDMMC_DCTRL_DTDIR_Msk                  /*!<Data transfer direction selection */
N#define SDMMC_DCTRL_DTMODE_Pos          (2U)
N#define SDMMC_DCTRL_DTMODE_Msk          (0x1UL << SDMMC_DCTRL_DTMODE_Pos)      /*!< 0x00000004 */
N#define SDMMC_DCTRL_DTMODE              SDMMC_DCTRL_DTMODE_Msk                 /*!<Data transfer mode selection      */
N#define SDMMC_DCTRL_DMAEN_Pos           (3U)
N#define SDMMC_DCTRL_DMAEN_Msk           (0x1UL << SDMMC_DCTRL_DMAEN_Pos)       /*!< 0x00000008 */
N#define SDMMC_DCTRL_DMAEN               SDMMC_DCTRL_DMAEN_Msk                  /*!<DMA enabled bit                   */
N
N#define SDMMC_DCTRL_DBLOCKSIZE_Pos      (4U)
N#define SDMMC_DCTRL_DBLOCKSIZE_Msk      (0xFUL << SDMMC_DCTRL_DBLOCKSIZE_Pos)  /*!< 0x000000F0 */
N#define SDMMC_DCTRL_DBLOCKSIZE          SDMMC_DCTRL_DBLOCKSIZE_Msk             /*!<DBLOCKSIZE[3:0] bits (Data block size) */
N#define SDMMC_DCTRL_DBLOCKSIZE_0        (0x1UL << SDMMC_DCTRL_DBLOCKSIZE_Pos)  /*!< 0x00000010 */
N#define SDMMC_DCTRL_DBLOCKSIZE_1        (0x2UL << SDMMC_DCTRL_DBLOCKSIZE_Pos)  /*!< 0x00000020 */
N#define SDMMC_DCTRL_DBLOCKSIZE_2        (0x4UL << SDMMC_DCTRL_DBLOCKSIZE_Pos)  /*!< 0x00000040 */
N#define SDMMC_DCTRL_DBLOCKSIZE_3        (0x8UL << SDMMC_DCTRL_DBLOCKSIZE_Pos)  /*!< 0x00000080 */
N
N#define SDMMC_DCTRL_RWSTART_Pos         (8U)
N#define SDMMC_DCTRL_RWSTART_Msk         (0x1UL << SDMMC_DCTRL_RWSTART_Pos)     /*!< 0x00000100 */
N#define SDMMC_DCTRL_RWSTART             SDMMC_DCTRL_RWSTART_Msk                /*!<Read wait start         */
N#define SDMMC_DCTRL_RWSTOP_Pos          (9U)
N#define SDMMC_DCTRL_RWSTOP_Msk          (0x1UL << SDMMC_DCTRL_RWSTOP_Pos)      /*!< 0x00000200 */
N#define SDMMC_DCTRL_RWSTOP              SDMMC_DCTRL_RWSTOP_Msk                 /*!<Read wait stop          */
N#define SDMMC_DCTRL_RWMOD_Pos           (10U)
N#define SDMMC_DCTRL_RWMOD_Msk           (0x1UL << SDMMC_DCTRL_RWMOD_Pos)       /*!< 0x00000400 */
N#define SDMMC_DCTRL_RWMOD               SDMMC_DCTRL_RWMOD_Msk                  /*!<Read wait mode          */
N#define SDMMC_DCTRL_SDIOEN_Pos          (11U)
N#define SDMMC_DCTRL_SDIOEN_Msk          (0x1UL << SDMMC_DCTRL_SDIOEN_Pos)      /*!< 0x00000800 */
N#define SDMMC_DCTRL_SDIOEN              SDMMC_DCTRL_SDIOEN_Msk                 /*!<SD I/O enable functions */
N
N/******************  Bit definition for SDMMC_DCOUNT register  *****************/
N#define SDMMC_DCOUNT_DATACOUNT_Pos      (0U)
N#define SDMMC_DCOUNT_DATACOUNT_Msk      (0x1FFFFFFUL << SDMMC_DCOUNT_DATACOUNT_Pos) /*!< 0x01FFFFFF */
N#define SDMMC_DCOUNT_DATACOUNT          SDMMC_DCOUNT_DATACOUNT_Msk             /*!<Data count value */
N
N/******************  Bit definition for SDMMC_STA register  ********************/
N#define SDMMC_STA_CCRCFAIL_Pos          (0U)
N#define SDMMC_STA_CCRCFAIL_Msk          (0x1UL << SDMMC_STA_CCRCFAIL_Pos)      /*!< 0x00000001 */
N#define SDMMC_STA_CCRCFAIL              SDMMC_STA_CCRCFAIL_Msk                 /*!<Command response received (CRC check failed)  */
N#define SDMMC_STA_DCRCFAIL_Pos          (1U)
N#define SDMMC_STA_DCRCFAIL_Msk          (0x1UL << SDMMC_STA_DCRCFAIL_Pos)      /*!< 0x00000002 */
N#define SDMMC_STA_DCRCFAIL              SDMMC_STA_DCRCFAIL_Msk                 /*!<Data block sent/received (CRC check failed)   */
N#define SDMMC_STA_CTIMEOUT_Pos          (2U)
N#define SDMMC_STA_CTIMEOUT_Msk          (0x1UL << SDMMC_STA_CTIMEOUT_Pos)      /*!< 0x00000004 */
N#define SDMMC_STA_CTIMEOUT              SDMMC_STA_CTIMEOUT_Msk                 /*!<Command response timeout                      */
N#define SDMMC_STA_DTIMEOUT_Pos          (3U)
N#define SDMMC_STA_DTIMEOUT_Msk          (0x1UL << SDMMC_STA_DTIMEOUT_Pos)      /*!< 0x00000008 */
N#define SDMMC_STA_DTIMEOUT              SDMMC_STA_DTIMEOUT_Msk                 /*!<Data timeout                                  */
N#define SDMMC_STA_TXUNDERR_Pos          (4U)
N#define SDMMC_STA_TXUNDERR_Msk          (0x1UL << SDMMC_STA_TXUNDERR_Pos)      /*!< 0x00000010 */
N#define SDMMC_STA_TXUNDERR              SDMMC_STA_TXUNDERR_Msk                 /*!<Transmit FIFO underrun error                  */
N#define SDMMC_STA_RXOVERR_Pos           (5U)
N#define SDMMC_STA_RXOVERR_Msk           (0x1UL << SDMMC_STA_RXOVERR_Pos)       /*!< 0x00000020 */
N#define SDMMC_STA_RXOVERR               SDMMC_STA_RXOVERR_Msk                  /*!<Received FIFO overrun error                   */
N#define SDMMC_STA_CMDREND_Pos           (6U)
N#define SDMMC_STA_CMDREND_Msk           (0x1UL << SDMMC_STA_CMDREND_Pos)       /*!< 0x00000040 */
N#define SDMMC_STA_CMDREND               SDMMC_STA_CMDREND_Msk                  /*!<Command response received (CRC check passed)  */
N#define SDMMC_STA_CMDSENT_Pos           (7U)
N#define SDMMC_STA_CMDSENT_Msk           (0x1UL << SDMMC_STA_CMDSENT_Pos)       /*!< 0x00000080 */
N#define SDMMC_STA_CMDSENT               SDMMC_STA_CMDSENT_Msk                  /*!<Command sent (no response required)           */
N#define SDMMC_STA_DATAEND_Pos           (8U)
N#define SDMMC_STA_DATAEND_Msk           (0x1UL << SDMMC_STA_DATAEND_Pos)       /*!< 0x00000100 */
N#define SDMMC_STA_DATAEND               SDMMC_STA_DATAEND_Msk                  /*!<Data end (data counter, SDIDCOUNT, is zero)   */
N#define SDMMC_STA_STBITERR_Pos          (9U)
N#define SDMMC_STA_STBITERR_Msk          (0x1UL << SDMMC_STA_STBITERR_Pos)      /*!< 0x00000200 */
N#define SDMMC_STA_STBITERR              SDMMC_STA_STBITERR_Msk                 /*!<Start bit not detected on all data signals in wide bus mode */
N#define SDMMC_STA_DBCKEND_Pos           (10U)
N#define SDMMC_STA_DBCKEND_Msk           (0x1UL << SDMMC_STA_DBCKEND_Pos)       /*!< 0x00000400 */
N#define SDMMC_STA_DBCKEND               SDMMC_STA_DBCKEND_Msk                  /*!<Data block sent/received (CRC check passed)   */
N#define SDMMC_STA_CMDACT_Pos            (11U)
N#define SDMMC_STA_CMDACT_Msk            (0x1UL << SDMMC_STA_CMDACT_Pos)        /*!< 0x00000800 */
N#define SDMMC_STA_CMDACT                SDMMC_STA_CMDACT_Msk                   /*!<Command transfer in progress                  */
N#define SDMMC_STA_TXACT_Pos             (12U)
N#define SDMMC_STA_TXACT_Msk             (0x1UL << SDMMC_STA_TXACT_Pos)         /*!< 0x00001000 */
N#define SDMMC_STA_TXACT                 SDMMC_STA_TXACT_Msk                    /*!<Data transmit in progress                     */
N#define SDMMC_STA_RXACT_Pos             (13U)
N#define SDMMC_STA_RXACT_Msk             (0x1UL << SDMMC_STA_RXACT_Pos)         /*!< 0x00002000 */
N#define SDMMC_STA_RXACT                 SDMMC_STA_RXACT_Msk                    /*!<Data receive in progress                      */
N#define SDMMC_STA_TXFIFOHE_Pos          (14U)
N#define SDMMC_STA_TXFIFOHE_Msk          (0x1UL << SDMMC_STA_TXFIFOHE_Pos)      /*!< 0x00004000 */
N#define SDMMC_STA_TXFIFOHE              SDMMC_STA_TXFIFOHE_Msk                 /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define SDMMC_STA_RXFIFOHF_Pos          (15U)
N#define SDMMC_STA_RXFIFOHF_Msk          (0x1UL << SDMMC_STA_RXFIFOHF_Pos)      /*!< 0x00008000 */
N#define SDMMC_STA_RXFIFOHF              SDMMC_STA_RXFIFOHF_Msk                 /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define SDMMC_STA_TXFIFOF_Pos           (16U)
N#define SDMMC_STA_TXFIFOF_Msk           (0x1UL << SDMMC_STA_TXFIFOF_Pos)       /*!< 0x00010000 */
N#define SDMMC_STA_TXFIFOF               SDMMC_STA_TXFIFOF_Msk                  /*!<Transmit FIFO full                            */
N#define SDMMC_STA_RXFIFOF_Pos           (17U)
N#define SDMMC_STA_RXFIFOF_Msk           (0x1UL << SDMMC_STA_RXFIFOF_Pos)       /*!< 0x00020000 */
N#define SDMMC_STA_RXFIFOF               SDMMC_STA_RXFIFOF_Msk                  /*!<Receive FIFO full                             */
N#define SDMMC_STA_TXFIFOE_Pos           (18U)
N#define SDMMC_STA_TXFIFOE_Msk           (0x1UL << SDMMC_STA_TXFIFOE_Pos)       /*!< 0x00040000 */
N#define SDMMC_STA_TXFIFOE               SDMMC_STA_TXFIFOE_Msk                  /*!<Transmit FIFO empty                           */
N#define SDMMC_STA_RXFIFOE_Pos           (19U)
N#define SDMMC_STA_RXFIFOE_Msk           (0x1UL << SDMMC_STA_RXFIFOE_Pos)       /*!< 0x00080000 */
N#define SDMMC_STA_RXFIFOE               SDMMC_STA_RXFIFOE_Msk                  /*!<Receive FIFO empty                            */
N#define SDMMC_STA_TXDAVL_Pos            (20U)
N#define SDMMC_STA_TXDAVL_Msk            (0x1UL << SDMMC_STA_TXDAVL_Pos)        /*!< 0x00100000 */
N#define SDMMC_STA_TXDAVL                SDMMC_STA_TXDAVL_Msk                   /*!<Data available in transmit FIFO               */
N#define SDMMC_STA_RXDAVL_Pos            (21U)
N#define SDMMC_STA_RXDAVL_Msk            (0x1UL << SDMMC_STA_RXDAVL_Pos)        /*!< 0x00200000 */
N#define SDMMC_STA_RXDAVL                SDMMC_STA_RXDAVL_Msk                   /*!<Data available in receive FIFO                */
N#define SDMMC_STA_SDIOIT_Pos            (22U)
N#define SDMMC_STA_SDIOIT_Msk            (0x1UL << SDMMC_STA_SDIOIT_Pos)        /*!< 0x00400000 */
N#define SDMMC_STA_SDIOIT                SDMMC_STA_SDIOIT_Msk                   /*!<SDIO interrupt received                       */
N
N/*******************  Bit definition for SDMMC_ICR register  *******************/
N#define SDMMC_ICR_CCRCFAILC_Pos         (0U)
N#define SDMMC_ICR_CCRCFAILC_Msk         (0x1UL << SDMMC_ICR_CCRCFAILC_Pos)     /*!< 0x00000001 */
N#define SDMMC_ICR_CCRCFAILC             SDMMC_ICR_CCRCFAILC_Msk                /*!<CCRCFAIL flag clear bit */
N#define SDMMC_ICR_DCRCFAILC_Pos         (1U)
N#define SDMMC_ICR_DCRCFAILC_Msk         (0x1UL << SDMMC_ICR_DCRCFAILC_Pos)     /*!< 0x00000002 */
N#define SDMMC_ICR_DCRCFAILC             SDMMC_ICR_DCRCFAILC_Msk                /*!<DCRCFAIL flag clear bit */
N#define SDMMC_ICR_CTIMEOUTC_Pos         (2U)
N#define SDMMC_ICR_CTIMEOUTC_Msk         (0x1UL << SDMMC_ICR_CTIMEOUTC_Pos)     /*!< 0x00000004 */
N#define SDMMC_ICR_CTIMEOUTC             SDMMC_ICR_CTIMEOUTC_Msk                /*!<CTIMEOUT flag clear bit */
N#define SDMMC_ICR_DTIMEOUTC_Pos         (3U)
N#define SDMMC_ICR_DTIMEOUTC_Msk         (0x1UL << SDMMC_ICR_DTIMEOUTC_Pos)     /*!< 0x00000008 */
N#define SDMMC_ICR_DTIMEOUTC             SDMMC_ICR_DTIMEOUTC_Msk                /*!<DTIMEOUT flag clear bit */
N#define SDMMC_ICR_TXUNDERRC_Pos         (4U)
N#define SDMMC_ICR_TXUNDERRC_Msk         (0x1UL << SDMMC_ICR_TXUNDERRC_Pos)     /*!< 0x00000010 */
N#define SDMMC_ICR_TXUNDERRC             SDMMC_ICR_TXUNDERRC_Msk                /*!<TXUNDERR flag clear bit */
N#define SDMMC_ICR_RXOVERRC_Pos          (5U)
N#define SDMMC_ICR_RXOVERRC_Msk          (0x1UL << SDMMC_ICR_RXOVERRC_Pos)      /*!< 0x00000020 */
N#define SDMMC_ICR_RXOVERRC              SDMMC_ICR_RXOVERRC_Msk                 /*!<RXOVERR flag clear bit  */
N#define SDMMC_ICR_CMDRENDC_Pos          (6U)
N#define SDMMC_ICR_CMDRENDC_Msk          (0x1UL << SDMMC_ICR_CMDRENDC_Pos)      /*!< 0x00000040 */
N#define SDMMC_ICR_CMDRENDC              SDMMC_ICR_CMDRENDC_Msk                 /*!<CMDREND flag clear bit  */
N#define SDMMC_ICR_CMDSENTC_Pos          (7U)
N#define SDMMC_ICR_CMDSENTC_Msk          (0x1UL << SDMMC_ICR_CMDSENTC_Pos)      /*!< 0x00000080 */
N#define SDMMC_ICR_CMDSENTC              SDMMC_ICR_CMDSENTC_Msk                 /*!<CMDSENT flag clear bit  */
N#define SDMMC_ICR_DATAENDC_Pos          (8U)
N#define SDMMC_ICR_DATAENDC_Msk          (0x1UL << SDMMC_ICR_DATAENDC_Pos)      /*!< 0x00000100 */
N#define SDMMC_ICR_DATAENDC              SDMMC_ICR_DATAENDC_Msk                 /*!<DATAEND flag clear bit  */
N#define SDMMC_ICR_STBITERRC_Pos         (9U)
N#define SDMMC_ICR_STBITERRC_Msk         (0x1UL << SDMMC_ICR_STBITERRC_Pos)     /*!< 0x00000200 */
N#define SDMMC_ICR_STBITERRC             SDMMC_ICR_STBITERRC_Msk                /*!<STBITERR flag clear bit */
N#define SDMMC_ICR_DBCKENDC_Pos          (10U)
N#define SDMMC_ICR_DBCKENDC_Msk          (0x1UL << SDMMC_ICR_DBCKENDC_Pos)      /*!< 0x00000400 */
N#define SDMMC_ICR_DBCKENDC              SDMMC_ICR_DBCKENDC_Msk                 /*!<DBCKEND flag clear bit  */
N#define SDMMC_ICR_SDIOITC_Pos           (22U)
N#define SDMMC_ICR_SDIOITC_Msk           (0x1UL << SDMMC_ICR_SDIOITC_Pos)       /*!< 0x00400000 */
N#define SDMMC_ICR_SDIOITC               SDMMC_ICR_SDIOITC_Msk                  /*!<SDIOIT flag clear bit   */
N
N/******************  Bit definition for SDMMC_MASK register  *******************/
N#define SDMMC_MASK_CCRCFAILIE_Pos       (0U)
N#define SDMMC_MASK_CCRCFAILIE_Msk       (0x1UL << SDMMC_MASK_CCRCFAILIE_Pos)   /*!< 0x00000001 */
N#define SDMMC_MASK_CCRCFAILIE           SDMMC_MASK_CCRCFAILIE_Msk              /*!<Command CRC Fail Interrupt Enable          */
N#define SDMMC_MASK_DCRCFAILIE_Pos       (1U)
N#define SDMMC_MASK_DCRCFAILIE_Msk       (0x1UL << SDMMC_MASK_DCRCFAILIE_Pos)   /*!< 0x00000002 */
N#define SDMMC_MASK_DCRCFAILIE           SDMMC_MASK_DCRCFAILIE_Msk              /*!<Data CRC Fail Interrupt Enable             */
N#define SDMMC_MASK_CTIMEOUTIE_Pos       (2U)
N#define SDMMC_MASK_CTIMEOUTIE_Msk       (0x1UL << SDMMC_MASK_CTIMEOUTIE_Pos)   /*!< 0x00000004 */
N#define SDMMC_MASK_CTIMEOUTIE           SDMMC_MASK_CTIMEOUTIE_Msk              /*!<Command TimeOut Interrupt Enable           */
N#define SDMMC_MASK_DTIMEOUTIE_Pos       (3U)
N#define SDMMC_MASK_DTIMEOUTIE_Msk       (0x1UL << SDMMC_MASK_DTIMEOUTIE_Pos)   /*!< 0x00000008 */
N#define SDMMC_MASK_DTIMEOUTIE           SDMMC_MASK_DTIMEOUTIE_Msk              /*!<Data TimeOut Interrupt Enable              */
N#define SDMMC_MASK_TXUNDERRIE_Pos       (4U)
N#define SDMMC_MASK_TXUNDERRIE_Msk       (0x1UL << SDMMC_MASK_TXUNDERRIE_Pos)   /*!< 0x00000010 */
N#define SDMMC_MASK_TXUNDERRIE           SDMMC_MASK_TXUNDERRIE_Msk              /*!<Tx FIFO UnderRun Error Interrupt Enable    */
N#define SDMMC_MASK_RXOVERRIE_Pos        (5U)
N#define SDMMC_MASK_RXOVERRIE_Msk        (0x1UL << SDMMC_MASK_RXOVERRIE_Pos)    /*!< 0x00000020 */
N#define SDMMC_MASK_RXOVERRIE            SDMMC_MASK_RXOVERRIE_Msk               /*!<Rx FIFO OverRun Error Interrupt Enable     */
N#define SDMMC_MASK_CMDRENDIE_Pos        (6U)
N#define SDMMC_MASK_CMDRENDIE_Msk        (0x1UL << SDMMC_MASK_CMDRENDIE_Pos)    /*!< 0x00000040 */
N#define SDMMC_MASK_CMDRENDIE            SDMMC_MASK_CMDRENDIE_Msk               /*!<Command Response Received Interrupt Enable */
N#define SDMMC_MASK_CMDSENTIE_Pos        (7U)
N#define SDMMC_MASK_CMDSENTIE_Msk        (0x1UL << SDMMC_MASK_CMDSENTIE_Pos)    /*!< 0x00000080 */
N#define SDMMC_MASK_CMDSENTIE            SDMMC_MASK_CMDSENTIE_Msk               /*!<Command Sent Interrupt Enable              */
N#define SDMMC_MASK_DATAENDIE_Pos        (8U)
N#define SDMMC_MASK_DATAENDIE_Msk        (0x1UL << SDMMC_MASK_DATAENDIE_Pos)    /*!< 0x00000100 */
N#define SDMMC_MASK_DATAENDIE            SDMMC_MASK_DATAENDIE_Msk               /*!<Data End Interrupt Enable                  */
N#define SDMMC_MASK_DBCKENDIE_Pos        (10U)
N#define SDMMC_MASK_DBCKENDIE_Msk        (0x1UL << SDMMC_MASK_DBCKENDIE_Pos)    /*!< 0x00000400 */
N#define SDMMC_MASK_DBCKENDIE            SDMMC_MASK_DBCKENDIE_Msk               /*!<Data Block End Interrupt Enable            */
N#define SDMMC_MASK_CMDACTIE_Pos         (11U)
N#define SDMMC_MASK_CMDACTIE_Msk         (0x1UL << SDMMC_MASK_CMDACTIE_Pos)     /*!< 0x00000800 */
N#define SDMMC_MASK_CMDACTIE             SDMMC_MASK_CMDACTIE_Msk                /*!<CCommand Acting Interrupt Enable           */
N#define SDMMC_MASK_TXACTIE_Pos          (12U)
N#define SDMMC_MASK_TXACTIE_Msk          (0x1UL << SDMMC_MASK_TXACTIE_Pos)      /*!< 0x00001000 */
N#define SDMMC_MASK_TXACTIE              SDMMC_MASK_TXACTIE_Msk                 /*!<Data Transmit Acting Interrupt Enable      */
N#define SDMMC_MASK_RXACTIE_Pos          (13U)
N#define SDMMC_MASK_RXACTIE_Msk          (0x1UL << SDMMC_MASK_RXACTIE_Pos)      /*!< 0x00002000 */
N#define SDMMC_MASK_RXACTIE              SDMMC_MASK_RXACTIE_Msk                 /*!<Data receive acting interrupt enabled      */
N#define SDMMC_MASK_TXFIFOHEIE_Pos       (14U)
N#define SDMMC_MASK_TXFIFOHEIE_Msk       (0x1UL << SDMMC_MASK_TXFIFOHEIE_Pos)   /*!< 0x00004000 */
N#define SDMMC_MASK_TXFIFOHEIE           SDMMC_MASK_TXFIFOHEIE_Msk              /*!<Tx FIFO Half Empty interrupt Enable        */
N#define SDMMC_MASK_RXFIFOHFIE_Pos       (15U)
N#define SDMMC_MASK_RXFIFOHFIE_Msk       (0x1UL << SDMMC_MASK_RXFIFOHFIE_Pos)   /*!< 0x00008000 */
N#define SDMMC_MASK_RXFIFOHFIE           SDMMC_MASK_RXFIFOHFIE_Msk              /*!<Rx FIFO Half Full interrupt Enable         */
N#define SDMMC_MASK_TXFIFOFIE_Pos        (16U)
N#define SDMMC_MASK_TXFIFOFIE_Msk        (0x1UL << SDMMC_MASK_TXFIFOFIE_Pos)    /*!< 0x00010000 */
N#define SDMMC_MASK_TXFIFOFIE            SDMMC_MASK_TXFIFOFIE_Msk               /*!<Tx FIFO Full interrupt Enable              */
N#define SDMMC_MASK_RXFIFOFIE_Pos        (17U)
N#define SDMMC_MASK_RXFIFOFIE_Msk        (0x1UL << SDMMC_MASK_RXFIFOFIE_Pos)    /*!< 0x00020000 */
N#define SDMMC_MASK_RXFIFOFIE            SDMMC_MASK_RXFIFOFIE_Msk               /*!<Rx FIFO Full interrupt Enable              */
N#define SDMMC_MASK_TXFIFOEIE_Pos        (18U)
N#define SDMMC_MASK_TXFIFOEIE_Msk        (0x1UL << SDMMC_MASK_TXFIFOEIE_Pos)    /*!< 0x00040000 */
N#define SDMMC_MASK_TXFIFOEIE            SDMMC_MASK_TXFIFOEIE_Msk               /*!<Tx FIFO Empty interrupt Enable             */
N#define SDMMC_MASK_RXFIFOEIE_Pos        (19U)
N#define SDMMC_MASK_RXFIFOEIE_Msk        (0x1UL << SDMMC_MASK_RXFIFOEIE_Pos)    /*!< 0x00080000 */
N#define SDMMC_MASK_RXFIFOEIE            SDMMC_MASK_RXFIFOEIE_Msk               /*!<Rx FIFO Empty interrupt Enable             */
N#define SDMMC_MASK_TXDAVLIE_Pos         (20U)
N#define SDMMC_MASK_TXDAVLIE_Msk         (0x1UL << SDMMC_MASK_TXDAVLIE_Pos)     /*!< 0x00100000 */
N#define SDMMC_MASK_TXDAVLIE             SDMMC_MASK_TXDAVLIE_Msk                /*!<Data available in Tx FIFO interrupt Enable */
N#define SDMMC_MASK_RXDAVLIE_Pos         (21U)
N#define SDMMC_MASK_RXDAVLIE_Msk         (0x1UL << SDMMC_MASK_RXDAVLIE_Pos)     /*!< 0x00200000 */
N#define SDMMC_MASK_RXDAVLIE             SDMMC_MASK_RXDAVLIE_Msk                /*!<Data available in Rx FIFO interrupt Enable */
N#define SDMMC_MASK_SDIOITIE_Pos         (22U)
N#define SDMMC_MASK_SDIOITIE_Msk         (0x1UL << SDMMC_MASK_SDIOITIE_Pos)     /*!< 0x00400000 */
N#define SDMMC_MASK_SDIOITIE             SDMMC_MASK_SDIOITIE_Msk                /*!<SDIO Mode Interrupt Received interrupt Enable */
N
N/*****************  Bit definition for SDMMC_FIFOCNT register  *****************/
N#define SDMMC_FIFOCNT_FIFOCOUNT_Pos     (0U)
N#define SDMMC_FIFOCNT_FIFOCOUNT_Msk     (0xFFFFFFUL << SDMMC_FIFOCNT_FIFOCOUNT_Pos) /*!< 0x00FFFFFF */
N#define SDMMC_FIFOCNT_FIFOCOUNT         SDMMC_FIFOCNT_FIFOCOUNT_Msk            /*!<Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDMMC_FIFO register  *******************/
N#define SDMMC_FIFO_FIFODATA_Pos         (0U)
N#define SDMMC_FIFO_FIFODATA_Msk         (0xFFFFFFFFUL << SDMMC_FIFO_FIFODATA_Pos) /*!< 0xFFFFFFFF */
N#define SDMMC_FIFO_FIFODATA             SDMMC_FIFO_FIFODATA_Msk                /*!<Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface (SPI)                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define SPI_CR1_CPHA_Pos         (0U)
N#define SPI_CR1_CPHA_Msk         (0x1UL << SPI_CR1_CPHA_Pos)                   /*!< 0x00000001 */
N#define SPI_CR1_CPHA             SPI_CR1_CPHA_Msk                              /*!<Clock Phase      */
N#define SPI_CR1_CPOL_Pos         (1U)
N#define SPI_CR1_CPOL_Msk         (0x1UL << SPI_CR1_CPOL_Pos)                   /*!< 0x00000002 */
N#define SPI_CR1_CPOL             SPI_CR1_CPOL_Msk                              /*!<Clock Polarity   */
N#define SPI_CR1_MSTR_Pos         (2U)
N#define SPI_CR1_MSTR_Msk         (0x1UL << SPI_CR1_MSTR_Pos)                   /*!< 0x00000004 */
N#define SPI_CR1_MSTR             SPI_CR1_MSTR_Msk                              /*!<Master Selection */
N
N#define SPI_CR1_BR_Pos           (3U)
N#define SPI_CR1_BR_Msk           (0x7UL << SPI_CR1_BR_Pos)                     /*!< 0x00000038 */
N#define SPI_CR1_BR               SPI_CR1_BR_Msk                                /*!<BR[2:0] bits (Baud Rate Control) */
N#define SPI_CR1_BR_0             (0x1UL << SPI_CR1_BR_Pos)                     /*!< 0x00000008 */
N#define SPI_CR1_BR_1             (0x2UL << SPI_CR1_BR_Pos)                     /*!< 0x00000010 */
N#define SPI_CR1_BR_2             (0x4UL << SPI_CR1_BR_Pos)                     /*!< 0x00000020 */
N
N#define SPI_CR1_SPE_Pos          (6U)
N#define SPI_CR1_SPE_Msk          (0x1UL << SPI_CR1_SPE_Pos)                    /*!< 0x00000040 */
N#define SPI_CR1_SPE              SPI_CR1_SPE_Msk                               /*!<SPI Enable                          */
N#define SPI_CR1_LSBFIRST_Pos     (7U)
N#define SPI_CR1_LSBFIRST_Msk     (0x1UL << SPI_CR1_LSBFIRST_Pos)               /*!< 0x00000080 */
N#define SPI_CR1_LSBFIRST         SPI_CR1_LSBFIRST_Msk                          /*!<Frame Format                        */
N#define SPI_CR1_SSI_Pos          (8U)
N#define SPI_CR1_SSI_Msk          (0x1UL << SPI_CR1_SSI_Pos)                    /*!< 0x00000100 */
N#define SPI_CR1_SSI              SPI_CR1_SSI_Msk                               /*!<Internal slave select               */
N#define SPI_CR1_SSM_Pos          (9U)
N#define SPI_CR1_SSM_Msk          (0x1UL << SPI_CR1_SSM_Pos)                    /*!< 0x00000200 */
N#define SPI_CR1_SSM              SPI_CR1_SSM_Msk                               /*!<Software slave management           */
N#define SPI_CR1_RXONLY_Pos       (10U)
N#define SPI_CR1_RXONLY_Msk       (0x1UL << SPI_CR1_RXONLY_Pos)                 /*!< 0x00000400 */
N#define SPI_CR1_RXONLY           SPI_CR1_RXONLY_Msk                            /*!<Receive only                        */
N#define SPI_CR1_CRCL_Pos         (11U)
N#define SPI_CR1_CRCL_Msk         (0x1UL << SPI_CR1_CRCL_Pos)                   /*!< 0x00000800 */
N#define SPI_CR1_CRCL             SPI_CR1_CRCL_Msk                              /*!< CRC Length */
N#define SPI_CR1_CRCNEXT_Pos      (12U)
N#define SPI_CR1_CRCNEXT_Msk      (0x1UL << SPI_CR1_CRCNEXT_Pos)                /*!< 0x00001000 */
N#define SPI_CR1_CRCNEXT          SPI_CR1_CRCNEXT_Msk                           /*!<Transmit CRC next                   */
N#define SPI_CR1_CRCEN_Pos        (13U)
N#define SPI_CR1_CRCEN_Msk        (0x1UL << SPI_CR1_CRCEN_Pos)                  /*!< 0x00002000 */
N#define SPI_CR1_CRCEN            SPI_CR1_CRCEN_Msk                             /*!<Hardware CRC calculation enable     */
N#define SPI_CR1_BIDIOE_Pos       (14U)
N#define SPI_CR1_BIDIOE_Msk       (0x1UL << SPI_CR1_BIDIOE_Pos)                 /*!< 0x00004000 */
N#define SPI_CR1_BIDIOE           SPI_CR1_BIDIOE_Msk                            /*!<Output enable in bidirectional mode */
N#define SPI_CR1_BIDIMODE_Pos     (15U)
N#define SPI_CR1_BIDIMODE_Msk     (0x1UL << SPI_CR1_BIDIMODE_Pos)               /*!< 0x00008000 */
N#define SPI_CR1_BIDIMODE         SPI_CR1_BIDIMODE_Msk                          /*!<Bidirectional data mode enable      */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define SPI_CR2_RXDMAEN_Pos      (0U)
N#define SPI_CR2_RXDMAEN_Msk      (0x1UL << SPI_CR2_RXDMAEN_Pos)                /*!< 0x00000001 */
N#define SPI_CR2_RXDMAEN          SPI_CR2_RXDMAEN_Msk                           /*!< Rx Buffer DMA Enable */
N#define SPI_CR2_TXDMAEN_Pos      (1U)
N#define SPI_CR2_TXDMAEN_Msk      (0x1UL << SPI_CR2_TXDMAEN_Pos)                /*!< 0x00000002 */
N#define SPI_CR2_TXDMAEN          SPI_CR2_TXDMAEN_Msk                           /*!< Tx Buffer DMA Enable */
N#define SPI_CR2_SSOE_Pos         (2U)
N#define SPI_CR2_SSOE_Msk         (0x1UL << SPI_CR2_SSOE_Pos)                   /*!< 0x00000004 */
N#define SPI_CR2_SSOE             SPI_CR2_SSOE_Msk                              /*!< SS Output Enable */
N#define SPI_CR2_NSSP_Pos         (3U)
N#define SPI_CR2_NSSP_Msk         (0x1UL << SPI_CR2_NSSP_Pos)                   /*!< 0x00000008 */
N#define SPI_CR2_NSSP             SPI_CR2_NSSP_Msk                              /*!< NSS pulse management Enable */
N#define SPI_CR2_FRF_Pos          (4U)
N#define SPI_CR2_FRF_Msk          (0x1UL << SPI_CR2_FRF_Pos)                    /*!< 0x00000010 */
N#define SPI_CR2_FRF              SPI_CR2_FRF_Msk                               /*!< Frame Format Enable */
N#define SPI_CR2_ERRIE_Pos        (5U)
N#define SPI_CR2_ERRIE_Msk        (0x1UL << SPI_CR2_ERRIE_Pos)                  /*!< 0x00000020 */
N#define SPI_CR2_ERRIE            SPI_CR2_ERRIE_Msk                             /*!< Error Interrupt Enable */
N#define SPI_CR2_RXNEIE_Pos       (6U)
N#define SPI_CR2_RXNEIE_Msk       (0x1UL << SPI_CR2_RXNEIE_Pos)                 /*!< 0x00000040 */
N#define SPI_CR2_RXNEIE           SPI_CR2_RXNEIE_Msk                            /*!< RX buffer Not Empty Interrupt Enable */
N#define SPI_CR2_TXEIE_Pos        (7U)
N#define SPI_CR2_TXEIE_Msk        (0x1UL << SPI_CR2_TXEIE_Pos)                  /*!< 0x00000080 */
N#define SPI_CR2_TXEIE            SPI_CR2_TXEIE_Msk                             /*!< Tx buffer Empty Interrupt Enable */
N#define SPI_CR2_DS_Pos           (8U)
N#define SPI_CR2_DS_Msk           (0xFUL << SPI_CR2_DS_Pos)                     /*!< 0x00000F00 */
N#define SPI_CR2_DS               SPI_CR2_DS_Msk                                /*!< DS[3:0] Data Size */
N#define SPI_CR2_DS_0             (0x1UL << SPI_CR2_DS_Pos)                     /*!< 0x00000100 */
N#define SPI_CR2_DS_1             (0x2UL << SPI_CR2_DS_Pos)                     /*!< 0x00000200 */
N#define SPI_CR2_DS_2             (0x4UL << SPI_CR2_DS_Pos)                     /*!< 0x00000400 */
N#define SPI_CR2_DS_3             (0x8UL << SPI_CR2_DS_Pos)                     /*!< 0x00000800 */
N#define SPI_CR2_FRXTH_Pos        (12U)
N#define SPI_CR2_FRXTH_Msk        (0x1UL << SPI_CR2_FRXTH_Pos)                  /*!< 0x00001000 */
N#define SPI_CR2_FRXTH            SPI_CR2_FRXTH_Msk                             /*!< FIFO reception Threshold */
N#define SPI_CR2_LDMARX_Pos       (13U)
N#define SPI_CR2_LDMARX_Msk       (0x1UL << SPI_CR2_LDMARX_Pos)                 /*!< 0x00002000 */
N#define SPI_CR2_LDMARX           SPI_CR2_LDMARX_Msk                            /*!< Last DMA transfer for reception */
N#define SPI_CR2_LDMATX_Pos       (14U)
N#define SPI_CR2_LDMATX_Msk       (0x1UL << SPI_CR2_LDMATX_Pos)                 /*!< 0x00004000 */
N#define SPI_CR2_LDMATX           SPI_CR2_LDMATX_Msk                            /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define SPI_SR_RXNE_Pos          (0U)
N#define SPI_SR_RXNE_Msk          (0x1UL << SPI_SR_RXNE_Pos)                    /*!< 0x00000001 */
N#define SPI_SR_RXNE              SPI_SR_RXNE_Msk                               /*!< Receive buffer Not Empty */
N#define SPI_SR_TXE_Pos           (1U)
N#define SPI_SR_TXE_Msk           (0x1UL << SPI_SR_TXE_Pos)                     /*!< 0x00000002 */
N#define SPI_SR_TXE               SPI_SR_TXE_Msk                                /*!< Transmit buffer Empty */
N#define SPI_SR_CHSIDE_Pos        (2U)
N#define SPI_SR_CHSIDE_Msk        (0x1UL << SPI_SR_CHSIDE_Pos)                  /*!< 0x00000004 */
N#define SPI_SR_CHSIDE            SPI_SR_CHSIDE_Msk                             /*!< Channel side */
N#define SPI_SR_UDR_Pos           (3U)
N#define SPI_SR_UDR_Msk           (0x1UL << SPI_SR_UDR_Pos)                     /*!< 0x00000008 */
N#define SPI_SR_UDR               SPI_SR_UDR_Msk                                /*!< Underrun flag */
N#define SPI_SR_CRCERR_Pos        (4U)
N#define SPI_SR_CRCERR_Msk        (0x1UL << SPI_SR_CRCERR_Pos)                  /*!< 0x00000010 */
N#define SPI_SR_CRCERR            SPI_SR_CRCERR_Msk                             /*!< CRC Error flag */
N#define SPI_SR_MODF_Pos          (5U)
N#define SPI_SR_MODF_Msk          (0x1UL << SPI_SR_MODF_Pos)                    /*!< 0x00000020 */
N#define SPI_SR_MODF              SPI_SR_MODF_Msk                               /*!< Mode fault */
N#define SPI_SR_OVR_Pos           (6U)
N#define SPI_SR_OVR_Msk           (0x1UL << SPI_SR_OVR_Pos)                     /*!< 0x00000040 */
N#define SPI_SR_OVR               SPI_SR_OVR_Msk                                /*!< Overrun flag */
N#define SPI_SR_BSY_Pos           (7U)
N#define SPI_SR_BSY_Msk           (0x1UL << SPI_SR_BSY_Pos)                     /*!< 0x00000080 */
N#define SPI_SR_BSY               SPI_SR_BSY_Msk                                /*!< Busy flag */
N#define SPI_SR_FRE_Pos           (8U)
N#define SPI_SR_FRE_Msk           (0x1UL << SPI_SR_FRE_Pos)                     /*!< 0x00000100 */
N#define SPI_SR_FRE               SPI_SR_FRE_Msk                                /*!< TI frame format error */
N#define SPI_SR_FRLVL_Pos         (9U)
N#define SPI_SR_FRLVL_Msk         (0x3UL << SPI_SR_FRLVL_Pos)                   /*!< 0x00000600 */
N#define SPI_SR_FRLVL             SPI_SR_FRLVL_Msk                              /*!< FIFO Reception Level */
N#define SPI_SR_FRLVL_0           (0x1UL << SPI_SR_FRLVL_Pos)                   /*!< 0x00000200 */
N#define SPI_SR_FRLVL_1           (0x2UL << SPI_SR_FRLVL_Pos)                   /*!< 0x00000400 */
N#define SPI_SR_FTLVL_Pos         (11U)
N#define SPI_SR_FTLVL_Msk         (0x3UL << SPI_SR_FTLVL_Pos)                   /*!< 0x00001800 */
N#define SPI_SR_FTLVL             SPI_SR_FTLVL_Msk                              /*!< FIFO Transmission Level */
N#define SPI_SR_FTLVL_0           (0x1UL << SPI_SR_FTLVL_Pos)                   /*!< 0x00000800 */
N#define SPI_SR_FTLVL_1           (0x2UL << SPI_SR_FTLVL_Pos)                   /*!< 0x00001000 */
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define SPI_DR_DR_Pos            (0U)
N#define SPI_DR_DR_Msk            (0xFFFFUL << SPI_DR_DR_Pos)                   /*!< 0x0000FFFF */
N#define SPI_DR_DR                SPI_DR_DR_Msk                                 /*!<Data Register           */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define SPI_CRCPR_CRCPOLY_Pos    (0U)
N#define SPI_CRCPR_CRCPOLY_Msk    (0xFFFFUL << SPI_CRCPR_CRCPOLY_Pos)           /*!< 0x0000FFFF */
N#define SPI_CRCPR_CRCPOLY        SPI_CRCPR_CRCPOLY_Msk                         /*!<CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define SPI_RXCRCR_RXCRC_Pos     (0U)
N#define SPI_RXCRCR_RXCRC_Msk     (0xFFFFUL << SPI_RXCRCR_RXCRC_Pos)            /*!< 0x0000FFFF */
N#define SPI_RXCRCR_RXCRC         SPI_RXCRCR_RXCRC_Msk                          /*!<Rx CRC Register         */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define SPI_TXCRCR_TXCRC_Pos     (0U)
N#define SPI_TXCRCR_TXCRC_Msk     (0xFFFFUL << SPI_TXCRCR_TXCRC_Pos)            /*!< 0x0000FFFF */
N#define SPI_TXCRCR_TXCRC         SPI_TXCRCR_TXCRC_Msk                          /*!<Tx CRC Register         */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    QUADSPI                                 */
N/*                                                                            */
N/******************************************************************************/
N/*****************  Bit definition for QUADSPI_CR register  *******************/
N#define QUADSPI_CR_EN_Pos              (0U)
N#define QUADSPI_CR_EN_Msk              (0x1UL << QUADSPI_CR_EN_Pos)            /*!< 0x00000001 */
N#define QUADSPI_CR_EN                  QUADSPI_CR_EN_Msk                       /*!< Enable */
N#define QUADSPI_CR_ABORT_Pos           (1U)
N#define QUADSPI_CR_ABORT_Msk           (0x1UL << QUADSPI_CR_ABORT_Pos)         /*!< 0x00000002 */
N#define QUADSPI_CR_ABORT               QUADSPI_CR_ABORT_Msk                    /*!< Abort request */
N#define QUADSPI_CR_DMAEN_Pos           (2U)
N#define QUADSPI_CR_DMAEN_Msk           (0x1UL << QUADSPI_CR_DMAEN_Pos)         /*!< 0x00000004 */
N#define QUADSPI_CR_DMAEN               QUADSPI_CR_DMAEN_Msk                    /*!< DMA Enable */
N#define QUADSPI_CR_TCEN_Pos            (3U)
N#define QUADSPI_CR_TCEN_Msk            (0x1UL << QUADSPI_CR_TCEN_Pos)          /*!< 0x00000008 */
N#define QUADSPI_CR_TCEN                QUADSPI_CR_TCEN_Msk                     /*!< Timeout Counter Enable */
N#define QUADSPI_CR_SSHIFT_Pos          (4U)
N#define QUADSPI_CR_SSHIFT_Msk          (0x1UL << QUADSPI_CR_SSHIFT_Pos)        /*!< 0x00000010 */
N#define QUADSPI_CR_SSHIFT              QUADSPI_CR_SSHIFT_Msk                   /*!< Sample Shift */
N#define QUADSPI_CR_DFM_Pos             (6U)
N#define QUADSPI_CR_DFM_Msk             (0x1UL << QUADSPI_CR_DFM_Pos)           /*!< 0x00000040 */
N#define QUADSPI_CR_DFM                 QUADSPI_CR_DFM_Msk                      /*!< Dual-flash mode */
N#define QUADSPI_CR_FSEL_Pos            (7U)
N#define QUADSPI_CR_FSEL_Msk            (0x1UL << QUADSPI_CR_FSEL_Pos)          /*!< 0x00000080 */
N#define QUADSPI_CR_FSEL                QUADSPI_CR_FSEL_Msk                     /*!< Flash memory selection */
N#define QUADSPI_CR_FTHRES_Pos          (8U)
N#define QUADSPI_CR_FTHRES_Msk          (0xFUL << QUADSPI_CR_FTHRES_Pos)        /*!< 0x00000F00 */
N#define QUADSPI_CR_FTHRES              QUADSPI_CR_FTHRES_Msk                   /*!< FTHRES[3:0] FIFO Level */
N#define QUADSPI_CR_TEIE_Pos            (16U)
N#define QUADSPI_CR_TEIE_Msk            (0x1UL << QUADSPI_CR_TEIE_Pos)          /*!< 0x00010000 */
N#define QUADSPI_CR_TEIE                QUADSPI_CR_TEIE_Msk                     /*!< Transfer Error Interrupt Enable */
N#define QUADSPI_CR_TCIE_Pos            (17U)
N#define QUADSPI_CR_TCIE_Msk            (0x1UL << QUADSPI_CR_TCIE_Pos)          /*!< 0x00020000 */
N#define QUADSPI_CR_TCIE                QUADSPI_CR_TCIE_Msk                     /*!< Transfer Complete Interrupt Enable */
N#define QUADSPI_CR_FTIE_Pos            (18U)
N#define QUADSPI_CR_FTIE_Msk            (0x1UL << QUADSPI_CR_FTIE_Pos)          /*!< 0x00040000 */
N#define QUADSPI_CR_FTIE                QUADSPI_CR_FTIE_Msk                     /*!< FIFO Threshold Interrupt Enable */
N#define QUADSPI_CR_SMIE_Pos            (19U)
N#define QUADSPI_CR_SMIE_Msk            (0x1UL << QUADSPI_CR_SMIE_Pos)          /*!< 0x00080000 */
N#define QUADSPI_CR_SMIE                QUADSPI_CR_SMIE_Msk                     /*!< Status Match Interrupt Enable */
N#define QUADSPI_CR_TOIE_Pos            (20U)
N#define QUADSPI_CR_TOIE_Msk            (0x1UL << QUADSPI_CR_TOIE_Pos)          /*!< 0x00100000 */
N#define QUADSPI_CR_TOIE                QUADSPI_CR_TOIE_Msk                     /*!< TimeOut Interrupt Enable */
N#define QUADSPI_CR_APMS_Pos            (22U)
N#define QUADSPI_CR_APMS_Msk            (0x1UL << QUADSPI_CR_APMS_Pos)          /*!< 0x00400000 */
N#define QUADSPI_CR_APMS                QUADSPI_CR_APMS_Msk                     /*!< Automatic Polling Mode Stop */
N#define QUADSPI_CR_PMM_Pos             (23U)
N#define QUADSPI_CR_PMM_Msk             (0x1UL << QUADSPI_CR_PMM_Pos)           /*!< 0x00800000 */
N#define QUADSPI_CR_PMM                 QUADSPI_CR_PMM_Msk                      /*!< Polling Match Mode */
N#define QUADSPI_CR_PRESCALER_Pos       (24U)
N#define QUADSPI_CR_PRESCALER_Msk       (0xFFUL << QUADSPI_CR_PRESCALER_Pos)    /*!< 0xFF000000 */
N#define QUADSPI_CR_PRESCALER           QUADSPI_CR_PRESCALER_Msk                /*!< PRESCALER[7:0] Clock prescaler */
N
N/*****************  Bit definition for QUADSPI_DCR register  ******************/
N#define QUADSPI_DCR_CKMODE_Pos         (0U)
N#define QUADSPI_DCR_CKMODE_Msk         (0x1UL << QUADSPI_DCR_CKMODE_Pos)       /*!< 0x00000001 */
N#define QUADSPI_DCR_CKMODE             QUADSPI_DCR_CKMODE_Msk                  /*!< Mode 0 / Mode 3 */
N#define QUADSPI_DCR_CSHT_Pos           (8U)
N#define QUADSPI_DCR_CSHT_Msk           (0x7UL << QUADSPI_DCR_CSHT_Pos)         /*!< 0x00000700 */
N#define QUADSPI_DCR_CSHT               QUADSPI_DCR_CSHT_Msk                    /*!< CSHT[2:0]: ChipSelect High Time */
N#define QUADSPI_DCR_CSHT_0             (0x1UL << QUADSPI_DCR_CSHT_Pos)         /*!< 0x00000100 */
N#define QUADSPI_DCR_CSHT_1             (0x2UL << QUADSPI_DCR_CSHT_Pos)         /*!< 0x00000200 */
N#define QUADSPI_DCR_CSHT_2             (0x4UL << QUADSPI_DCR_CSHT_Pos)         /*!< 0x00000400 */
N#define QUADSPI_DCR_FSIZE_Pos          (16U)
N#define QUADSPI_DCR_FSIZE_Msk          (0x1FUL << QUADSPI_DCR_FSIZE_Pos)       /*!< 0x001F0000 */
N#define QUADSPI_DCR_FSIZE              QUADSPI_DCR_FSIZE_Msk                   /*!< FSIZE[4:0]: Flash Size */
N
N/******************  Bit definition for QUADSPI_SR register  *******************/
N#define QUADSPI_SR_TEF_Pos             (0U)
N#define QUADSPI_SR_TEF_Msk             (0x1UL << QUADSPI_SR_TEF_Pos)           /*!< 0x00000001 */
N#define QUADSPI_SR_TEF                 QUADSPI_SR_TEF_Msk                      /*!< Transfer Error Flag */
N#define QUADSPI_SR_TCF_Pos             (1U)
N#define QUADSPI_SR_TCF_Msk             (0x1UL << QUADSPI_SR_TCF_Pos)           /*!< 0x00000002 */
N#define QUADSPI_SR_TCF                 QUADSPI_SR_TCF_Msk                      /*!< Transfer Complete Flag */
N#define QUADSPI_SR_FTF_Pos             (2U)
N#define QUADSPI_SR_FTF_Msk             (0x1UL << QUADSPI_SR_FTF_Pos)           /*!< 0x00000004 */
N#define QUADSPI_SR_FTF                 QUADSPI_SR_FTF_Msk                      /*!< FIFO Threshlod Flag */
N#define QUADSPI_SR_SMF_Pos             (3U)
N#define QUADSPI_SR_SMF_Msk             (0x1UL << QUADSPI_SR_SMF_Pos)           /*!< 0x00000008 */
N#define QUADSPI_SR_SMF                 QUADSPI_SR_SMF_Msk                      /*!< Status Match Flag */
N#define QUADSPI_SR_TOF_Pos             (4U)
N#define QUADSPI_SR_TOF_Msk             (0x1UL << QUADSPI_SR_TOF_Pos)           /*!< 0x00000010 */
N#define QUADSPI_SR_TOF                 QUADSPI_SR_TOF_Msk                      /*!< Timeout Flag */
N#define QUADSPI_SR_BUSY_Pos            (5U)
N#define QUADSPI_SR_BUSY_Msk            (0x1UL << QUADSPI_SR_BUSY_Pos)          /*!< 0x00000020 */
N#define QUADSPI_SR_BUSY                QUADSPI_SR_BUSY_Msk                     /*!< Busy */
N#define QUADSPI_SR_FLEVEL_Pos          (8U)
N#define QUADSPI_SR_FLEVEL_Msk          (0x1FUL << QUADSPI_SR_FLEVEL_Pos)       /*!< 0x00001F00 */
N#define QUADSPI_SR_FLEVEL              QUADSPI_SR_FLEVEL_Msk                   /*!< FIFO Threshlod Flag */
N
N/******************  Bit definition for QUADSPI_FCR register  ******************/
N#define QUADSPI_FCR_CTEF_Pos           (0U)
N#define QUADSPI_FCR_CTEF_Msk           (0x1UL << QUADSPI_FCR_CTEF_Pos)         /*!< 0x00000001 */
N#define QUADSPI_FCR_CTEF               QUADSPI_FCR_CTEF_Msk                    /*!< Clear Transfer Error Flag */
N#define QUADSPI_FCR_CTCF_Pos           (1U)
N#define QUADSPI_FCR_CTCF_Msk           (0x1UL << QUADSPI_FCR_CTCF_Pos)         /*!< 0x00000002 */
N#define QUADSPI_FCR_CTCF               QUADSPI_FCR_CTCF_Msk                    /*!< Clear Transfer Complete Flag */
N#define QUADSPI_FCR_CSMF_Pos           (3U)
N#define QUADSPI_FCR_CSMF_Msk           (0x1UL << QUADSPI_FCR_CSMF_Pos)         /*!< 0x00000008 */
N#define QUADSPI_FCR_CSMF               QUADSPI_FCR_CSMF_Msk                    /*!< Clear Status Match Flag */
N#define QUADSPI_FCR_CTOF_Pos           (4U)
N#define QUADSPI_FCR_CTOF_Msk           (0x1UL << QUADSPI_FCR_CTOF_Pos)         /*!< 0x00000010 */
N#define QUADSPI_FCR_CTOF               QUADSPI_FCR_CTOF_Msk                    /*!< Clear Timeout Flag */
N
N/******************  Bit definition for QUADSPI_DLR register  ******************/
N#define QUADSPI_DLR_DL_Pos             (0U)
N#define QUADSPI_DLR_DL_Msk             (0xFFFFFFFFUL << QUADSPI_DLR_DL_Pos)    /*!< 0xFFFFFFFF */
N#define QUADSPI_DLR_DL                 QUADSPI_DLR_DL_Msk                      /*!< DL[31:0]: Data Length */
N
N/******************  Bit definition for QUADSPI_CCR register  ******************/
N#define QUADSPI_CCR_INSTRUCTION_Pos    (0U)
N#define QUADSPI_CCR_INSTRUCTION_Msk    (0xFFUL << QUADSPI_CCR_INSTRUCTION_Pos) /*!< 0x000000FF */
N#define QUADSPI_CCR_INSTRUCTION        QUADSPI_CCR_INSTRUCTION_Msk             /*!< INSTRUCTION[7:0]: Instruction */
N#define QUADSPI_CCR_IMODE_Pos          (8U)
N#define QUADSPI_CCR_IMODE_Msk          (0x3UL << QUADSPI_CCR_IMODE_Pos)        /*!< 0x00000300 */
N#define QUADSPI_CCR_IMODE              QUADSPI_CCR_IMODE_Msk                   /*!< IMODE[1:0]: Instruction Mode */
N#define QUADSPI_CCR_IMODE_0            (0x1UL << QUADSPI_CCR_IMODE_Pos)        /*!< 0x00000100 */
N#define QUADSPI_CCR_IMODE_1            (0x2UL << QUADSPI_CCR_IMODE_Pos)        /*!< 0x00000200 */
N#define QUADSPI_CCR_ADMODE_Pos         (10U)
N#define QUADSPI_CCR_ADMODE_Msk         (0x3UL << QUADSPI_CCR_ADMODE_Pos)       /*!< 0x00000C00 */
N#define QUADSPI_CCR_ADMODE             QUADSPI_CCR_ADMODE_Msk                  /*!< ADMODE[1:0]: Address Mode */
N#define QUADSPI_CCR_ADMODE_0           (0x1UL << QUADSPI_CCR_ADMODE_Pos)       /*!< 0x00000400 */
N#define QUADSPI_CCR_ADMODE_1           (0x2UL << QUADSPI_CCR_ADMODE_Pos)       /*!< 0x00000800 */
N#define QUADSPI_CCR_ADSIZE_Pos         (12U)
N#define QUADSPI_CCR_ADSIZE_Msk         (0x3UL << QUADSPI_CCR_ADSIZE_Pos)       /*!< 0x00003000 */
N#define QUADSPI_CCR_ADSIZE             QUADSPI_CCR_ADSIZE_Msk                  /*!< ADSIZE[1:0]: Address Size */
N#define QUADSPI_CCR_ADSIZE_0           (0x1UL << QUADSPI_CCR_ADSIZE_Pos)       /*!< 0x00001000 */
N#define QUADSPI_CCR_ADSIZE_1           (0x2UL << QUADSPI_CCR_ADSIZE_Pos)       /*!< 0x00002000 */
N#define QUADSPI_CCR_ABMODE_Pos         (14U)
N#define QUADSPI_CCR_ABMODE_Msk         (0x3UL << QUADSPI_CCR_ABMODE_Pos)       /*!< 0x0000C000 */
N#define QUADSPI_CCR_ABMODE             QUADSPI_CCR_ABMODE_Msk                  /*!< ABMODE[1:0]: Alternate Bytes Mode */
N#define QUADSPI_CCR_ABMODE_0           (0x1UL << QUADSPI_CCR_ABMODE_Pos)       /*!< 0x00004000 */
N#define QUADSPI_CCR_ABMODE_1           (0x2UL << QUADSPI_CCR_ABMODE_Pos)       /*!< 0x00008000 */
N#define QUADSPI_CCR_ABSIZE_Pos         (16U)
N#define QUADSPI_CCR_ABSIZE_Msk         (0x3UL << QUADSPI_CCR_ABSIZE_Pos)       /*!< 0x00030000 */
N#define QUADSPI_CCR_ABSIZE             QUADSPI_CCR_ABSIZE_Msk                  /*!< ABSIZE[1:0]: Instruction Mode */
N#define QUADSPI_CCR_ABSIZE_0           (0x1UL << QUADSPI_CCR_ABSIZE_Pos)       /*!< 0x00010000 */
N#define QUADSPI_CCR_ABSIZE_1           (0x2UL << QUADSPI_CCR_ABSIZE_Pos)       /*!< 0x00020000 */
N#define QUADSPI_CCR_DCYC_Pos           (18U)
N#define QUADSPI_CCR_DCYC_Msk           (0x1FUL << QUADSPI_CCR_DCYC_Pos)        /*!< 0x007C0000 */
N#define QUADSPI_CCR_DCYC               QUADSPI_CCR_DCYC_Msk                    /*!< DCYC[4:0]: Dummy Cycles */
N#define QUADSPI_CCR_DMODE_Pos          (24U)
N#define QUADSPI_CCR_DMODE_Msk          (0x3UL << QUADSPI_CCR_DMODE_Pos)        /*!< 0x03000000 */
N#define QUADSPI_CCR_DMODE              QUADSPI_CCR_DMODE_Msk                   /*!< DMODE[1:0]: Data Mode */
N#define QUADSPI_CCR_DMODE_0            (0x1UL << QUADSPI_CCR_DMODE_Pos)        /*!< 0x01000000 */
N#define QUADSPI_CCR_DMODE_1            (0x2UL << QUADSPI_CCR_DMODE_Pos)        /*!< 0x02000000 */
N#define QUADSPI_CCR_FMODE_Pos          (26U)
N#define QUADSPI_CCR_FMODE_Msk          (0x3UL << QUADSPI_CCR_FMODE_Pos)        /*!< 0x0C000000 */
N#define QUADSPI_CCR_FMODE              QUADSPI_CCR_FMODE_Msk                   /*!< FMODE[1:0]: Functional Mode */
N#define QUADSPI_CCR_FMODE_0            (0x1UL << QUADSPI_CCR_FMODE_Pos)        /*!< 0x04000000 */
N#define QUADSPI_CCR_FMODE_1            (0x2UL << QUADSPI_CCR_FMODE_Pos)        /*!< 0x08000000 */
N#define QUADSPI_CCR_SIOO_Pos           (28U)
N#define QUADSPI_CCR_SIOO_Msk           (0x1UL << QUADSPI_CCR_SIOO_Pos)         /*!< 0x10000000 */
N#define QUADSPI_CCR_SIOO               QUADSPI_CCR_SIOO_Msk                    /*!< SIOO: Send Instruction Only Once Mode */
N#define QUADSPI_CCR_DHHC_Pos           (30U)
N#define QUADSPI_CCR_DHHC_Msk           (0x1UL << QUADSPI_CCR_DHHC_Pos)         /*!< 0x40000000 */
N#define QUADSPI_CCR_DHHC               QUADSPI_CCR_DHHC_Msk                    /*!< DHHC: DDR hold */
N#define QUADSPI_CCR_DDRM_Pos           (31U)
N#define QUADSPI_CCR_DDRM_Msk           (0x1UL << QUADSPI_CCR_DDRM_Pos)         /*!< 0x80000000 */
N#define QUADSPI_CCR_DDRM               QUADSPI_CCR_DDRM_Msk                    /*!< DDRM: Double Data Rate Mode */
N
N/******************  Bit definition for QUADSPI_AR register  *******************/
N#define QUADSPI_AR_ADDRESS_Pos         (0U)
N#define QUADSPI_AR_ADDRESS_Msk         (0xFFFFFFFFUL << QUADSPI_AR_ADDRESS_Pos) /*!< 0xFFFFFFFF */
N#define QUADSPI_AR_ADDRESS             QUADSPI_AR_ADDRESS_Msk                  /*!< ADDRESS[31:0]: Address */
N
N/******************  Bit definition for QUADSPI_ABR register  ******************/
N#define QUADSPI_ABR_ALTERNATE_Pos      (0U)
N#define QUADSPI_ABR_ALTERNATE_Msk      (0xFFFFFFFFUL << QUADSPI_ABR_ALTERNATE_Pos) /*!< 0xFFFFFFFF */
N#define QUADSPI_ABR_ALTERNATE          QUADSPI_ABR_ALTERNATE_Msk               /*!< ALTERNATE[31:0]: Alternate Bytes */
N
N/******************  Bit definition for QUADSPI_DR register  *******************/
N#define QUADSPI_DR_DATA_Pos            (0U)
N#define QUADSPI_DR_DATA_Msk            (0xFFFFFFFFUL << QUADSPI_DR_DATA_Pos)   /*!< 0xFFFFFFFF */
N#define QUADSPI_DR_DATA                QUADSPI_DR_DATA_Msk                     /*!< DATA[31:0]: Data */
N
N/******************  Bit definition for QUADSPI_PSMKR register  ****************/
N#define QUADSPI_PSMKR_MASK_Pos         (0U)
N#define QUADSPI_PSMKR_MASK_Msk         (0xFFFFFFFFUL << QUADSPI_PSMKR_MASK_Pos) /*!< 0xFFFFFFFF */
N#define QUADSPI_PSMKR_MASK             QUADSPI_PSMKR_MASK_Msk                  /*!< MASK[31:0]: Status Mask */
N
N/******************  Bit definition for QUADSPI_PSMAR register  ****************/
N#define QUADSPI_PSMAR_MATCH_Pos        (0U)
N#define QUADSPI_PSMAR_MATCH_Msk        (0xFFFFFFFFUL << QUADSPI_PSMAR_MATCH_Pos) /*!< 0xFFFFFFFF */
N#define QUADSPI_PSMAR_MATCH            QUADSPI_PSMAR_MATCH_Msk                 /*!< MATCH[31:0]: Status Match */
N
N/******************  Bit definition for QUADSPI_PIR register  *****************/
N#define QUADSPI_PIR_INTERVAL_Pos       (0U)
N#define QUADSPI_PIR_INTERVAL_Msk       (0xFFFFUL << QUADSPI_PIR_INTERVAL_Pos)  /*!< 0x0000FFFF */
N#define QUADSPI_PIR_INTERVAL           QUADSPI_PIR_INTERVAL_Msk                /*!< INTERVAL[15:0]: Polling Interval */
N
N/******************  Bit definition for QUADSPI_LPTR register  *****************/
N#define QUADSPI_LPTR_TIMEOUT_Pos       (0U)
N#define QUADSPI_LPTR_TIMEOUT_Msk       (0xFFFFUL << QUADSPI_LPTR_TIMEOUT_Pos)  /*!< 0x0000FFFF */
N#define QUADSPI_LPTR_TIMEOUT           QUADSPI_LPTR_TIMEOUT_Msk                /*!< TIMEOUT[15:0]: Timeout period */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 SYSCFG                                     */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SYSCFG_MEMRMP register  ***************/
N#define SYSCFG_MEMRMP_MEM_MODE_Pos      (0U)
N#define SYSCFG_MEMRMP_MEM_MODE_Msk      (0x7UL << SYSCFG_MEMRMP_MEM_MODE_Pos)  /*!< 0x00000007 */
N#define SYSCFG_MEMRMP_MEM_MODE          SYSCFG_MEMRMP_MEM_MODE_Msk             /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_MEMRMP_MEM_MODE_0        (0x1UL << SYSCFG_MEMRMP_MEM_MODE_Pos)  /*!< 0x00000001 */
N#define SYSCFG_MEMRMP_MEM_MODE_1        (0x2UL << SYSCFG_MEMRMP_MEM_MODE_Pos)  /*!< 0x00000002 */
N#define SYSCFG_MEMRMP_MEM_MODE_2        (0x4UL << SYSCFG_MEMRMP_MEM_MODE_Pos)  /*!< 0x00000004 */
N
N/******************  Bit definition for SYSCFG_CFGR1 register  ******************/
N#define SYSCFG_CFGR1_FWDIS_Pos          (0U)
N#define SYSCFG_CFGR1_FWDIS_Msk          (0x1UL << SYSCFG_CFGR1_FWDIS_Pos)      /*!< 0x00000001 */
N#define SYSCFG_CFGR1_FWDIS              SYSCFG_CFGR1_FWDIS_Msk                 /*!< FIREWALL access enable*/
N#define SYSCFG_CFGR1_BOOSTEN_Pos        (8U)
N#define SYSCFG_CFGR1_BOOSTEN_Msk        (0x1UL << SYSCFG_CFGR1_BOOSTEN_Pos)    /*!< 0x00000100 */
N#define SYSCFG_CFGR1_BOOSTEN            SYSCFG_CFGR1_BOOSTEN_Msk               /*!< I/O analog switch voltage booster enable */
N#define SYSCFG_CFGR1_I2C_PB6_FMP_Pos    (16U)
N#define SYSCFG_CFGR1_I2C_PB6_FMP_Msk    (0x1UL << SYSCFG_CFGR1_I2C_PB6_FMP_Pos) /*!< 0x00010000 */
N#define SYSCFG_CFGR1_I2C_PB6_FMP        SYSCFG_CFGR1_I2C_PB6_FMP_Msk           /*!< I2C PB6 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB7_FMP_Pos    (17U)
N#define SYSCFG_CFGR1_I2C_PB7_FMP_Msk    (0x1UL << SYSCFG_CFGR1_I2C_PB7_FMP_Pos) /*!< 0x00020000 */
N#define SYSCFG_CFGR1_I2C_PB7_FMP        SYSCFG_CFGR1_I2C_PB7_FMP_Msk           /*!< I2C PB7 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB8_FMP_Pos    (18U)
N#define SYSCFG_CFGR1_I2C_PB8_FMP_Msk    (0x1UL << SYSCFG_CFGR1_I2C_PB8_FMP_Pos) /*!< 0x00040000 */
N#define SYSCFG_CFGR1_I2C_PB8_FMP        SYSCFG_CFGR1_I2C_PB8_FMP_Msk           /*!< I2C PB8 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB9_FMP_Pos    (19U)
N#define SYSCFG_CFGR1_I2C_PB9_FMP_Msk    (0x1UL << SYSCFG_CFGR1_I2C_PB9_FMP_Pos) /*!< 0x00080000 */
N#define SYSCFG_CFGR1_I2C_PB9_FMP        SYSCFG_CFGR1_I2C_PB9_FMP_Msk           /*!< I2C PB9 Fast mode plus */
N#define SYSCFG_CFGR1_I2C1_FMP_Pos       (20U)
N#define SYSCFG_CFGR1_I2C1_FMP_Msk       (0x1UL << SYSCFG_CFGR1_I2C1_FMP_Pos)   /*!< 0x00100000 */
N#define SYSCFG_CFGR1_I2C1_FMP           SYSCFG_CFGR1_I2C1_FMP_Msk              /*!< I2C1 Fast mode plus */
N#define SYSCFG_CFGR1_I2C2_FMP_Pos       (21U)
N#define SYSCFG_CFGR1_I2C2_FMP_Msk       (0x1UL << SYSCFG_CFGR1_I2C2_FMP_Pos)   /*!< 0x00200000 */
N#define SYSCFG_CFGR1_I2C2_FMP           SYSCFG_CFGR1_I2C2_FMP_Msk              /*!< I2C2 Fast mode plus */
N#define SYSCFG_CFGR1_I2C3_FMP_Pos       (22U)
N#define SYSCFG_CFGR1_I2C3_FMP_Msk       (0x1UL << SYSCFG_CFGR1_I2C3_FMP_Pos)   /*!< 0x00400000 */
N#define SYSCFG_CFGR1_I2C3_FMP           SYSCFG_CFGR1_I2C3_FMP_Msk              /*!< I2C3 Fast mode plus */
N#define SYSCFG_CFGR1_FPU_IE_0           (0x04000000UL)                         /*!<  Invalid operation Interrupt enable */
N#define SYSCFG_CFGR1_FPU_IE_1           (0x08000000UL)                         /*!<  Divide-by-zero Interrupt enable */
N#define SYSCFG_CFGR1_FPU_IE_2           (0x10000000UL)                         /*!<  Underflow Interrupt enable */
N#define SYSCFG_CFGR1_FPU_IE_3           (0x20000000UL)                         /*!<  Overflow Interrupt enable */
N#define SYSCFG_CFGR1_FPU_IE_4           (0x40000000UL)                         /*!<  Input denormal Interrupt enable */
N#define SYSCFG_CFGR1_FPU_IE_5           (0x80000000UL)                         /*!<  Inexact Interrupt enable (interrupt disabled at reset) */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0_Pos        (0U)
N#define SYSCFG_EXTICR1_EXTI0_Msk        (0x7UL << SYSCFG_EXTICR1_EXTI0_Pos)    /*!< 0x00000007 */
N#define SYSCFG_EXTICR1_EXTI0            SYSCFG_EXTICR1_EXTI0_Msk               /*!<EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1_Pos        (4U)
N#define SYSCFG_EXTICR1_EXTI1_Msk        (0x7UL << SYSCFG_EXTICR1_EXTI1_Pos)    /*!< 0x00000070 */
N#define SYSCFG_EXTICR1_EXTI1            SYSCFG_EXTICR1_EXTI1_Msk               /*!<EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2_Pos        (8U)
N#define SYSCFG_EXTICR1_EXTI2_Msk        (0x7UL << SYSCFG_EXTICR1_EXTI2_Pos)    /*!< 0x00000700 */
N#define SYSCFG_EXTICR1_EXTI2            SYSCFG_EXTICR1_EXTI2_Msk               /*!<EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3_Pos        (12U)
N#define SYSCFG_EXTICR1_EXTI3_Msk        (0x7UL << SYSCFG_EXTICR1_EXTI3_Pos)    /*!< 0x00007000 */
N#define SYSCFG_EXTICR1_EXTI3            SYSCFG_EXTICR1_EXTI3_Msk               /*!<EXTI 3 configuration */
N
N/**
N  * @brief   EXTI0 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA             (0x00000000UL)                     /*!<PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB             (0x00000001UL)                     /*!<PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC             (0x00000002UL)                     /*!<PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD             (0x00000003UL)                     /*!<PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE             (0x00000004UL)                     /*!<PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PH             (0x00000007UL)                     /*!<PH[0] pin */
N
N/**
N  * @brief   EXTI1 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI1_PA             (0x00000000UL)                     /*!<PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB             (0x00000010UL)                     /*!<PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC             (0x00000020UL)                     /*!<PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD             (0x00000030UL)                     /*!<PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE             (0x00000040UL)                     /*!<PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PH             (0x00000070UL)                     /*!<PH[1] pin */
N
N/**
N  * @brief   EXTI2 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA             (0x00000000UL)                     /*!<PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB             (0x00000100UL)                     /*!<PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC             (0x00000200UL)                     /*!<PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD             (0x00000300UL)                     /*!<PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE             (0x00000400UL)                     /*!<PE[2] pin */
N
N/**
N  * @brief   EXTI3 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA             (0x00000000UL)                     /*!<PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB             (0x00001000UL)                     /*!<PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC             (0x00002000UL)                     /*!<PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD             (0x00003000UL)                     /*!<PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE             (0x00004000UL)                     /*!<PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PG             (0x00006000UL)                     /*!<PG[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
N#define SYSCFG_EXTICR2_EXTI4_Pos        (0U)
N#define SYSCFG_EXTICR2_EXTI4_Msk        (0x7UL << SYSCFG_EXTICR2_EXTI4_Pos)    /*!< 0x00000007 */
N#define SYSCFG_EXTICR2_EXTI4            SYSCFG_EXTICR2_EXTI4_Msk               /*!<EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5_Pos        (4U)
N#define SYSCFG_EXTICR2_EXTI5_Msk        (0x7UL << SYSCFG_EXTICR2_EXTI5_Pos)    /*!< 0x00000070 */
N#define SYSCFG_EXTICR2_EXTI5            SYSCFG_EXTICR2_EXTI5_Msk               /*!<EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6_Pos        (8U)
N#define SYSCFG_EXTICR2_EXTI6_Msk        (0x7UL << SYSCFG_EXTICR2_EXTI6_Pos)    /*!< 0x00000700 */
N#define SYSCFG_EXTICR2_EXTI6            SYSCFG_EXTICR2_EXTI6_Msk               /*!<EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7_Pos        (12U)
N#define SYSCFG_EXTICR2_EXTI7_Msk        (0x7UL << SYSCFG_EXTICR2_EXTI7_Pos)    /*!< 0x00007000 */
N#define SYSCFG_EXTICR2_EXTI7            SYSCFG_EXTICR2_EXTI7_Msk               /*!<EXTI 7 configuration */
N/**
N  * @brief   EXTI4 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA             (0x00000000UL)                     /*!<PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB             (0x00000001UL)                     /*!<PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC             (0x00000002UL)                     /*!<PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD             (0x00000003UL)                     /*!<PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE             (0x00000004UL)                     /*!<PE[4] pin */
N
N/**
N  * @brief   EXTI5 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA             (0x00000000UL)                     /*!<PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB             (0x00000010UL)                     /*!<PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC             (0x00000020UL)                     /*!<PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD             (0x00000030UL)                     /*!<PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE             (0x00000040UL)                     /*!<PE[5] pin */
N
N/**
N  * @brief   EXTI6 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA             (0x00000000UL)                     /*!<PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB             (0x00000100UL)                     /*!<PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC             (0x00000200UL)                     /*!<PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD             (0x00000300UL)                     /*!<PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE             (0x00000400UL)                     /*!<PE[6] pin */
N
N/**
N  * @brief   EXTI7 configuration
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA             (0x00000000UL)                     /*!<PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB             (0x00001000UL)                     /*!<PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC             (0x00002000UL)                     /*!<PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD             (0x00003000UL)                     /*!<PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE             (0x00004000UL)                     /*!<PE[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
N#define SYSCFG_EXTICR3_EXTI8_Pos        (0U)
N#define SYSCFG_EXTICR3_EXTI8_Msk        (0x7UL << SYSCFG_EXTICR3_EXTI8_Pos)    /*!< 0x00000007 */
N#define SYSCFG_EXTICR3_EXTI8            SYSCFG_EXTICR3_EXTI8_Msk               /*!<EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9_Pos        (4U)
N#define SYSCFG_EXTICR3_EXTI9_Msk        (0x7UL << SYSCFG_EXTICR3_EXTI9_Pos)    /*!< 0x00000070 */
N#define SYSCFG_EXTICR3_EXTI9            SYSCFG_EXTICR3_EXTI9_Msk               /*!<EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10_Pos       (8U)
N#define SYSCFG_EXTICR3_EXTI10_Msk       (0x7UL << SYSCFG_EXTICR3_EXTI10_Pos)   /*!< 0x00000700 */
N#define SYSCFG_EXTICR3_EXTI10           SYSCFG_EXTICR3_EXTI10_Msk              /*!<EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11_Pos       (12U)
N#define SYSCFG_EXTICR3_EXTI11_Msk       (0x7UL << SYSCFG_EXTICR3_EXTI11_Pos)   /*!< 0x00007000 */
N#define SYSCFG_EXTICR3_EXTI11           SYSCFG_EXTICR3_EXTI11_Msk              /*!<EXTI 11 configuration */
N
N/**
N  * @brief   EXTI8 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA             (0x00000000UL)                     /*!<PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB             (0x00000001UL)                     /*!<PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC             (0x00000002UL)                     /*!<PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD             (0x00000003UL)                     /*!<PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE             (0x00000004UL)                     /*!<PE[8] pin */
N
N/**
N  * @brief   EXTI9 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA             (0x00000000UL)                     /*!<PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB             (0x00000010UL)                     /*!<PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC             (0x00000020UL)                     /*!<PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD             (0x00000030UL)                     /*!<PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE             (0x00000040UL)                     /*!<PE[9] pin */
N
N/**
N  * @brief   EXTI10 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA            (0x00000000UL)                     /*!<PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB            (0x00000100UL)                     /*!<PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC            (0x00000200UL)                     /*!<PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD            (0x00000300UL)                     /*!<PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE            (0x00000400UL)                     /*!<PE[10] pin */
N
N/**
N  * @brief   EXTI11 configuration
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA            (0x00000000UL)                     /*!<PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB            (0x00001000UL)                     /*!<PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC            (0x00002000UL)                     /*!<PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD            (0x00003000UL)                     /*!<PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE            (0x00004000UL)                     /*!<PE[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
N#define SYSCFG_EXTICR4_EXTI12_Pos       (0U)
N#define SYSCFG_EXTICR4_EXTI12_Msk       (0x7UL << SYSCFG_EXTICR4_EXTI12_Pos)   /*!< 0x00000007 */
N#define SYSCFG_EXTICR4_EXTI12           SYSCFG_EXTICR4_EXTI12_Msk              /*!<EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13_Pos       (4U)
N#define SYSCFG_EXTICR4_EXTI13_Msk       (0x7UL << SYSCFG_EXTICR4_EXTI13_Pos)   /*!< 0x00000070 */
N#define SYSCFG_EXTICR4_EXTI13           SYSCFG_EXTICR4_EXTI13_Msk              /*!<EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14_Pos       (8U)
N#define SYSCFG_EXTICR4_EXTI14_Msk       (0x7UL << SYSCFG_EXTICR4_EXTI14_Pos)   /*!< 0x00000700 */
N#define SYSCFG_EXTICR4_EXTI14           SYSCFG_EXTICR4_EXTI14_Msk              /*!<EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15_Pos       (12U)
N#define SYSCFG_EXTICR4_EXTI15_Msk       (0x7UL << SYSCFG_EXTICR4_EXTI15_Pos)   /*!< 0x00007000 */
N#define SYSCFG_EXTICR4_EXTI15           SYSCFG_EXTICR4_EXTI15_Msk              /*!<EXTI 15 configuration */
N
N/**
N  * @brief   EXTI12 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA            (0x00000000UL)                     /*!<PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB            (0x00000001UL)                     /*!<PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC            (0x00000002UL)                     /*!<PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD            (0x00000003UL)                     /*!<PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE            (0x00000004UL)                     /*!<PE[12] pin */
N
N/**
N  * @brief   EXTI13 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA            (0x00000000UL)                     /*!<PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB            (0x00000010UL)                     /*!<PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC            (0x00000020UL)                     /*!<PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD            (0x00000030UL)                     /*!<PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE            (0x00000040UL)                     /*!<PE[13] pin */
N
N/**
N  * @brief   EXTI14 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA            (0x00000000UL)                     /*!<PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB            (0x00000100UL)                     /*!<PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC            (0x00000200UL)                     /*!<PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD            (0x00000300UL)                     /*!<PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE            (0x00000400UL)                     /*!<PE[14] pin */
N
N/**
N  * @brief   EXTI15 configuration
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA            (0x00000000UL)                     /*!<PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB            (0x00001000UL)                     /*!<PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC            (0x00002000UL)                     /*!<PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD            (0x00003000UL)                     /*!<PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE            (0x00004000UL)                     /*!<PE[15] pin */
N
N/******************  Bit definition for SYSCFG_SCSR register  ****************/
N#define SYSCFG_SCSR_SRAM2ER_Pos         (0U)
N#define SYSCFG_SCSR_SRAM2ER_Msk         (0x1UL << SYSCFG_SCSR_SRAM2ER_Pos)     /*!< 0x00000001 */
N#define SYSCFG_SCSR_SRAM2ER             SYSCFG_SCSR_SRAM2ER_Msk                /*!< SRAM2 Erase Request */
N#define SYSCFG_SCSR_SRAM2BSY_Pos        (1U)
N#define SYSCFG_SCSR_SRAM2BSY_Msk        (0x1UL << SYSCFG_SCSR_SRAM2BSY_Pos)    /*!< 0x00000002 */
N#define SYSCFG_SCSR_SRAM2BSY            SYSCFG_SCSR_SRAM2BSY_Msk               /*!< SRAM2 Erase Ongoing */
N
N/******************  Bit definition for SYSCFG_CFGR2 register  ****************/
N#define SYSCFG_CFGR2_CLL_Pos            (0U)
N#define SYSCFG_CFGR2_CLL_Msk            (0x1UL << SYSCFG_CFGR2_CLL_Pos)        /*!< 0x00000001 */
N#define SYSCFG_CFGR2_CLL                SYSCFG_CFGR2_CLL_Msk                   /*!< Core Lockup Lock */
N#define SYSCFG_CFGR2_SPL_Pos            (1U)
N#define SYSCFG_CFGR2_SPL_Msk            (0x1UL << SYSCFG_CFGR2_SPL_Pos)        /*!< 0x00000002 */
N#define SYSCFG_CFGR2_SPL                SYSCFG_CFGR2_SPL_Msk                   /*!< SRAM Parity Lock*/
N#define SYSCFG_CFGR2_PVDL_Pos           (2U)
N#define SYSCFG_CFGR2_PVDL_Msk           (0x1UL << SYSCFG_CFGR2_PVDL_Pos)       /*!< 0x00000004 */
N#define SYSCFG_CFGR2_PVDL               SYSCFG_CFGR2_PVDL_Msk                  /*!<  PVD Lock */
N#define SYSCFG_CFGR2_ECCL_Pos           (3U)
N#define SYSCFG_CFGR2_ECCL_Msk           (0x1UL << SYSCFG_CFGR2_ECCL_Pos)       /*!< 0x00000008 */
N#define SYSCFG_CFGR2_ECCL               SYSCFG_CFGR2_ECCL_Msk                  /*!< ECC Lock*/
N#define SYSCFG_CFGR2_SPF_Pos            (8U)
N#define SYSCFG_CFGR2_SPF_Msk            (0x1UL << SYSCFG_CFGR2_SPF_Pos)        /*!< 0x00000100 */
N#define SYSCFG_CFGR2_SPF                SYSCFG_CFGR2_SPF_Msk                   /*!< SRAM Parity Flag */
N
N/******************  Bit definition for SYSCFG_SWPR register  ****************/
N#define SYSCFG_SWPR_PAGE0_Pos           (0U)
N#define SYSCFG_SWPR_PAGE0_Msk           (0x1UL << SYSCFG_SWPR_PAGE0_Pos)       /*!< 0x00000001 */
N#define SYSCFG_SWPR_PAGE0               SYSCFG_SWPR_PAGE0_Msk                  /*!< SRAM2 Write protection page 0 */
N#define SYSCFG_SWPR_PAGE1_Pos           (1U)
N#define SYSCFG_SWPR_PAGE1_Msk           (0x1UL << SYSCFG_SWPR_PAGE1_Pos)       /*!< 0x00000002 */
N#define SYSCFG_SWPR_PAGE1               SYSCFG_SWPR_PAGE1_Msk                  /*!< SRAM2 Write protection page 1 */
N#define SYSCFG_SWPR_PAGE2_Pos           (2U)
N#define SYSCFG_SWPR_PAGE2_Msk           (0x1UL << SYSCFG_SWPR_PAGE2_Pos)       /*!< 0x00000004 */
N#define SYSCFG_SWPR_PAGE2               SYSCFG_SWPR_PAGE2_Msk                  /*!< SRAM2 Write protection page 2 */
N#define SYSCFG_SWPR_PAGE3_Pos           (3U)
N#define SYSCFG_SWPR_PAGE3_Msk           (0x1UL << SYSCFG_SWPR_PAGE3_Pos)       /*!< 0x00000008 */
N#define SYSCFG_SWPR_PAGE3               SYSCFG_SWPR_PAGE3_Msk                  /*!< SRAM2 Write protection page 3 */
N#define SYSCFG_SWPR_PAGE4_Pos           (4U)
N#define SYSCFG_SWPR_PAGE4_Msk           (0x1UL << SYSCFG_SWPR_PAGE4_Pos)       /*!< 0x00000010 */
N#define SYSCFG_SWPR_PAGE4               SYSCFG_SWPR_PAGE4_Msk                  /*!< SRAM2 Write protection page 4 */
N#define SYSCFG_SWPR_PAGE5_Pos           (5U)
N#define SYSCFG_SWPR_PAGE5_Msk           (0x1UL << SYSCFG_SWPR_PAGE5_Pos)       /*!< 0x00000020 */
N#define SYSCFG_SWPR_PAGE5               SYSCFG_SWPR_PAGE5_Msk                  /*!< SRAM2 Write protection page 5 */
N#define SYSCFG_SWPR_PAGE6_Pos           (6U)
N#define SYSCFG_SWPR_PAGE6_Msk           (0x1UL << SYSCFG_SWPR_PAGE6_Pos)       /*!< 0x00000040 */
N#define SYSCFG_SWPR_PAGE6               SYSCFG_SWPR_PAGE6_Msk                  /*!< SRAM2 Write protection page 6 */
N#define SYSCFG_SWPR_PAGE7_Pos           (7U)
N#define SYSCFG_SWPR_PAGE7_Msk           (0x1UL << SYSCFG_SWPR_PAGE7_Pos)       /*!< 0x00000080 */
N#define SYSCFG_SWPR_PAGE7               SYSCFG_SWPR_PAGE7_Msk                  /*!< SRAM2 Write protection page 7 */
N#define SYSCFG_SWPR_PAGE8_Pos           (8U)
N#define SYSCFG_SWPR_PAGE8_Msk           (0x1UL << SYSCFG_SWPR_PAGE8_Pos)       /*!< 0x00000100 */
N#define SYSCFG_SWPR_PAGE8               SYSCFG_SWPR_PAGE8_Msk                  /*!< SRAM2 Write protection page 8 */
N#define SYSCFG_SWPR_PAGE9_Pos           (9U)
N#define SYSCFG_SWPR_PAGE9_Msk           (0x1UL << SYSCFG_SWPR_PAGE9_Pos)       /*!< 0x00000200 */
N#define SYSCFG_SWPR_PAGE9               SYSCFG_SWPR_PAGE9_Msk                  /*!< SRAM2 Write protection page 9 */
N#define SYSCFG_SWPR_PAGE10_Pos          (10U)
N#define SYSCFG_SWPR_PAGE10_Msk          (0x1UL << SYSCFG_SWPR_PAGE10_Pos)      /*!< 0x00000400 */
N#define SYSCFG_SWPR_PAGE10              SYSCFG_SWPR_PAGE10_Msk                 /*!< SRAM2 Write protection page 10*/
N#define SYSCFG_SWPR_PAGE11_Pos          (11U)
N#define SYSCFG_SWPR_PAGE11_Msk          (0x1UL << SYSCFG_SWPR_PAGE11_Pos)      /*!< 0x00000800 */
N#define SYSCFG_SWPR_PAGE11              SYSCFG_SWPR_PAGE11_Msk                 /*!< SRAM2 Write protection page 11*/
N#define SYSCFG_SWPR_PAGE12_Pos          (12U)
N#define SYSCFG_SWPR_PAGE12_Msk          (0x1UL << SYSCFG_SWPR_PAGE12_Pos)      /*!< 0x00001000 */
N#define SYSCFG_SWPR_PAGE12              SYSCFG_SWPR_PAGE12_Msk                 /*!< SRAM2 Write protection page 12*/
N#define SYSCFG_SWPR_PAGE13_Pos          (13U)
N#define SYSCFG_SWPR_PAGE13_Msk          (0x1UL << SYSCFG_SWPR_PAGE13_Pos)      /*!< 0x00002000 */
N#define SYSCFG_SWPR_PAGE13              SYSCFG_SWPR_PAGE13_Msk                 /*!< SRAM2 Write protection page 13*/
N#define SYSCFG_SWPR_PAGE14_Pos          (14U)
N#define SYSCFG_SWPR_PAGE14_Msk          (0x1UL << SYSCFG_SWPR_PAGE14_Pos)      /*!< 0x00004000 */
N#define SYSCFG_SWPR_PAGE14              SYSCFG_SWPR_PAGE14_Msk                 /*!< SRAM2 Write protection page 14*/
N#define SYSCFG_SWPR_PAGE15_Pos          (15U)
N#define SYSCFG_SWPR_PAGE15_Msk          (0x1UL << SYSCFG_SWPR_PAGE15_Pos)      /*!< 0x00008000 */
N#define SYSCFG_SWPR_PAGE15              SYSCFG_SWPR_PAGE15_Msk                 /*!< SRAM2 Write protection page 15*/
N
N/******************  Bit definition for SYSCFG_SKR register  ****************/
N#define SYSCFG_SKR_KEY_Pos              (0U)
N#define SYSCFG_SKR_KEY_Msk              (0xFFUL << SYSCFG_SKR_KEY_Pos)         /*!< 0x000000FF */
N#define SYSCFG_SKR_KEY                  SYSCFG_SKR_KEY_Msk                     /*!<  SRAM2 write protection key for software erase  */
N
N
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define TIM_CR1_CEN_Pos           (0U)
N#define TIM_CR1_CEN_Msk           (0x1UL << TIM_CR1_CEN_Pos)                   /*!< 0x00000001 */
N#define TIM_CR1_CEN               TIM_CR1_CEN_Msk                              /*!<Counter enable */
N#define TIM_CR1_UDIS_Pos          (1U)
N#define TIM_CR1_UDIS_Msk          (0x1UL << TIM_CR1_UDIS_Pos)                  /*!< 0x00000002 */
N#define TIM_CR1_UDIS              TIM_CR1_UDIS_Msk                             /*!<Update disable */
N#define TIM_CR1_URS_Pos           (2U)
N#define TIM_CR1_URS_Msk           (0x1UL << TIM_CR1_URS_Pos)                   /*!< 0x00000004 */
N#define TIM_CR1_URS               TIM_CR1_URS_Msk                              /*!<Update request source */
N#define TIM_CR1_OPM_Pos           (3U)
N#define TIM_CR1_OPM_Msk           (0x1UL << TIM_CR1_OPM_Pos)                   /*!< 0x00000008 */
N#define TIM_CR1_OPM               TIM_CR1_OPM_Msk                              /*!<One pulse mode */
N#define TIM_CR1_DIR_Pos           (4U)
N#define TIM_CR1_DIR_Msk           (0x1UL << TIM_CR1_DIR_Pos)                   /*!< 0x00000010 */
N#define TIM_CR1_DIR               TIM_CR1_DIR_Msk                              /*!<Direction */
N
N#define TIM_CR1_CMS_Pos           (5U)
N#define TIM_CR1_CMS_Msk           (0x3UL << TIM_CR1_CMS_Pos)                   /*!< 0x00000060 */
N#define TIM_CR1_CMS               TIM_CR1_CMS_Msk                              /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define TIM_CR1_CMS_0             (0x1UL << TIM_CR1_CMS_Pos)                   /*!< 0x00000020 */
N#define TIM_CR1_CMS_1             (0x2UL << TIM_CR1_CMS_Pos)                   /*!< 0x00000040 */
N
N#define TIM_CR1_ARPE_Pos          (7U)
N#define TIM_CR1_ARPE_Msk          (0x1UL << TIM_CR1_ARPE_Pos)                  /*!< 0x00000080 */
N#define TIM_CR1_ARPE              TIM_CR1_ARPE_Msk                             /*!<Auto-reload preload enable */
N
N#define TIM_CR1_CKD_Pos           (8U)
N#define TIM_CR1_CKD_Msk           (0x3UL << TIM_CR1_CKD_Pos)                   /*!< 0x00000300 */
N#define TIM_CR1_CKD               TIM_CR1_CKD_Msk                              /*!<CKD[1:0] bits (clock division) */
N#define TIM_CR1_CKD_0             (0x1UL << TIM_CR1_CKD_Pos)                   /*!< 0x00000100 */
N#define TIM_CR1_CKD_1             (0x2UL << TIM_CR1_CKD_Pos)                   /*!< 0x00000200 */
N
N#define TIM_CR1_UIFREMAP_Pos      (11U)
N#define TIM_CR1_UIFREMAP_Msk      (0x1UL << TIM_CR1_UIFREMAP_Pos)              /*!< 0x00000800 */
N#define TIM_CR1_UIFREMAP          TIM_CR1_UIFREMAP_Msk                         /*!<Update interrupt flag remap */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define TIM_CR2_CCPC_Pos          (0U)
N#define TIM_CR2_CCPC_Msk          (0x1UL << TIM_CR2_CCPC_Pos)                  /*!< 0x00000001 */
N#define TIM_CR2_CCPC              TIM_CR2_CCPC_Msk                             /*!<Capture/Compare Preloaded Control */
N#define TIM_CR2_CCUS_Pos          (2U)
N#define TIM_CR2_CCUS_Msk          (0x1UL << TIM_CR2_CCUS_Pos)                  /*!< 0x00000004 */
N#define TIM_CR2_CCUS              TIM_CR2_CCUS_Msk                             /*!<Capture/Compare Control Update Selection */
N#define TIM_CR2_CCDS_Pos          (3U)
N#define TIM_CR2_CCDS_Msk          (0x1UL << TIM_CR2_CCDS_Pos)                  /*!< 0x00000008 */
N#define TIM_CR2_CCDS              TIM_CR2_CCDS_Msk                             /*!<Capture/Compare DMA Selection */
N
N#define TIM_CR2_MMS_Pos           (4U)
N#define TIM_CR2_MMS_Msk           (0x7UL << TIM_CR2_MMS_Pos)                   /*!< 0x00000070 */
N#define TIM_CR2_MMS               TIM_CR2_MMS_Msk                              /*!<MMS[2:0] bits (Master Mode Selection) */
N#define TIM_CR2_MMS_0             (0x1UL << TIM_CR2_MMS_Pos)                   /*!< 0x00000010 */
N#define TIM_CR2_MMS_1             (0x2UL << TIM_CR2_MMS_Pos)                   /*!< 0x00000020 */
N#define TIM_CR2_MMS_2             (0x4UL << TIM_CR2_MMS_Pos)                   /*!< 0x00000040 */
N
N#define TIM_CR2_TI1S_Pos          (7U)
N#define TIM_CR2_TI1S_Msk          (0x1UL << TIM_CR2_TI1S_Pos)                  /*!< 0x00000080 */
N#define TIM_CR2_TI1S              TIM_CR2_TI1S_Msk                             /*!<TI1 Selection */
N#define TIM_CR2_OIS1_Pos          (8U)
N#define TIM_CR2_OIS1_Msk          (0x1UL << TIM_CR2_OIS1_Pos)                  /*!< 0x00000100 */
N#define TIM_CR2_OIS1              TIM_CR2_OIS1_Msk                             /*!<Output Idle state 1 (OC1 output) */
N#define TIM_CR2_OIS1N_Pos         (9U)
N#define TIM_CR2_OIS1N_Msk         (0x1UL << TIM_CR2_OIS1N_Pos)                 /*!< 0x00000200 */
N#define TIM_CR2_OIS1N             TIM_CR2_OIS1N_Msk                            /*!<Output Idle state 1 (OC1N output) */
N#define TIM_CR2_OIS2_Pos          (10U)
N#define TIM_CR2_OIS2_Msk          (0x1UL << TIM_CR2_OIS2_Pos)                  /*!< 0x00000400 */
N#define TIM_CR2_OIS2              TIM_CR2_OIS2_Msk                             /*!<Output Idle state 2 (OC2 output) */
N#define TIM_CR2_OIS2N_Pos         (11U)
N#define TIM_CR2_OIS2N_Msk         (0x1UL << TIM_CR2_OIS2N_Pos)                 /*!< 0x00000800 */
N#define TIM_CR2_OIS2N             TIM_CR2_OIS2N_Msk                            /*!<Output Idle state 2 (OC2N output) */
N#define TIM_CR2_OIS3_Pos          (12U)
N#define TIM_CR2_OIS3_Msk          (0x1UL << TIM_CR2_OIS3_Pos)                  /*!< 0x00001000 */
N#define TIM_CR2_OIS3              TIM_CR2_OIS3_Msk                             /*!<Output Idle state 3 (OC3 output) */
N#define TIM_CR2_OIS3N_Pos         (13U)
N#define TIM_CR2_OIS3N_Msk         (0x1UL << TIM_CR2_OIS3N_Pos)                 /*!< 0x00002000 */
N#define TIM_CR2_OIS3N             TIM_CR2_OIS3N_Msk                            /*!<Output Idle state 3 (OC3N output) */
N#define TIM_CR2_OIS4_Pos          (14U)
N#define TIM_CR2_OIS4_Msk          (0x1UL << TIM_CR2_OIS4_Pos)                  /*!< 0x00004000 */
N#define TIM_CR2_OIS4              TIM_CR2_OIS4_Msk                             /*!<Output Idle state 4 (OC4 output) */
N#define TIM_CR2_OIS5_Pos          (16U)
N#define TIM_CR2_OIS5_Msk          (0x1UL << TIM_CR2_OIS5_Pos)                  /*!< 0x00010000 */
N#define TIM_CR2_OIS5              TIM_CR2_OIS5_Msk                             /*!<Output Idle state 5 (OC5 output) */
N#define TIM_CR2_OIS6_Pos          (18U)
N#define TIM_CR2_OIS6_Msk          (0x1UL << TIM_CR2_OIS6_Pos)                  /*!< 0x00040000 */
N#define TIM_CR2_OIS6              TIM_CR2_OIS6_Msk                             /*!<Output Idle state 6 (OC6 output) */
N
N#define TIM_CR2_MMS2_Pos          (20U)
N#define TIM_CR2_MMS2_Msk          (0xFUL << TIM_CR2_MMS2_Pos)                  /*!< 0x00F00000 */
N#define TIM_CR2_MMS2              TIM_CR2_MMS2_Msk                             /*!<MMS[2:0] bits (Master Mode Selection) */
N#define TIM_CR2_MMS2_0            (0x1UL << TIM_CR2_MMS2_Pos)                  /*!< 0x00100000 */
N#define TIM_CR2_MMS2_1            (0x2UL << TIM_CR2_MMS2_Pos)                  /*!< 0x00200000 */
N#define TIM_CR2_MMS2_2            (0x4UL << TIM_CR2_MMS2_Pos)                  /*!< 0x00400000 */
N#define TIM_CR2_MMS2_3            (0x8UL << TIM_CR2_MMS2_Pos)                  /*!< 0x00800000 */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define TIM_SMCR_SMS_Pos          (0U)
N#define TIM_SMCR_SMS_Msk          (0x10007UL << TIM_SMCR_SMS_Pos)              /*!< 0x00010007 */
N#define TIM_SMCR_SMS              TIM_SMCR_SMS_Msk                             /*!<SMS[2:0] bits (Slave mode selection) */
N#define TIM_SMCR_SMS_0            (0x00001UL << TIM_SMCR_SMS_Pos)              /*!< 0x00000001 */
N#define TIM_SMCR_SMS_1            (0x00002UL << TIM_SMCR_SMS_Pos)              /*!< 0x00000002 */
N#define TIM_SMCR_SMS_2            (0x00004UL << TIM_SMCR_SMS_Pos)              /*!< 0x00000004 */
N#define TIM_SMCR_SMS_3            (0x10000UL << TIM_SMCR_SMS_Pos)              /*!< 0x00010000 */
N
N#define TIM_SMCR_OCCS_Pos         (3U)
N#define TIM_SMCR_OCCS_Msk         (0x1UL << TIM_SMCR_OCCS_Pos)                 /*!< 0x00000008 */
N#define TIM_SMCR_OCCS             TIM_SMCR_OCCS_Msk                            /*!< OCREF clear selection */
N
N#define TIM_SMCR_TS_Pos           (4U)
N#define TIM_SMCR_TS_Msk           (0x7UL << TIM_SMCR_TS_Pos)                   /*!< 0x00000070 */
N#define TIM_SMCR_TS               TIM_SMCR_TS_Msk                              /*!<TS[2:0] bits (Trigger selection) */
N#define TIM_SMCR_TS_0             (0x1UL << TIM_SMCR_TS_Pos)                   /*!< 0x00000010 */
N#define TIM_SMCR_TS_1             (0x2UL << TIM_SMCR_TS_Pos)                   /*!< 0x00000020 */
N#define TIM_SMCR_TS_2             (0x4UL << TIM_SMCR_TS_Pos)                   /*!< 0x00000040 */
N
N#define TIM_SMCR_MSM_Pos          (7U)
N#define TIM_SMCR_MSM_Msk          (0x1UL << TIM_SMCR_MSM_Pos)                  /*!< 0x00000080 */
N#define TIM_SMCR_MSM              TIM_SMCR_MSM_Msk                             /*!<Master/slave mode */
N
N#define TIM_SMCR_ETF_Pos          (8U)
N#define TIM_SMCR_ETF_Msk          (0xFUL << TIM_SMCR_ETF_Pos)                  /*!< 0x00000F00 */
N#define TIM_SMCR_ETF              TIM_SMCR_ETF_Msk                             /*!<ETF[3:0] bits (External trigger filter) */
N#define TIM_SMCR_ETF_0            (0x1UL << TIM_SMCR_ETF_Pos)                  /*!< 0x00000100 */
N#define TIM_SMCR_ETF_1            (0x2UL << TIM_SMCR_ETF_Pos)                  /*!< 0x00000200 */
N#define TIM_SMCR_ETF_2            (0x4UL << TIM_SMCR_ETF_Pos)                  /*!< 0x00000400 */
N#define TIM_SMCR_ETF_3            (0x8UL << TIM_SMCR_ETF_Pos)                  /*!< 0x00000800 */
N
N#define TIM_SMCR_ETPS_Pos         (12U)
N#define TIM_SMCR_ETPS_Msk         (0x3UL << TIM_SMCR_ETPS_Pos)                 /*!< 0x00003000 */
N#define TIM_SMCR_ETPS             TIM_SMCR_ETPS_Msk                            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define TIM_SMCR_ETPS_0           (0x1UL << TIM_SMCR_ETPS_Pos)                 /*!< 0x00001000 */
N#define TIM_SMCR_ETPS_1           (0x2UL << TIM_SMCR_ETPS_Pos)                 /*!< 0x00002000 */
N
N#define TIM_SMCR_ECE_Pos          (14U)
N#define TIM_SMCR_ECE_Msk          (0x1UL << TIM_SMCR_ECE_Pos)                  /*!< 0x00004000 */
N#define TIM_SMCR_ECE              TIM_SMCR_ECE_Msk                             /*!<External clock enable */
N#define TIM_SMCR_ETP_Pos          (15U)
N#define TIM_SMCR_ETP_Msk          (0x1UL << TIM_SMCR_ETP_Pos)                  /*!< 0x00008000 */
N#define TIM_SMCR_ETP              TIM_SMCR_ETP_Msk                             /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define TIM_DIER_UIE_Pos          (0U)
N#define TIM_DIER_UIE_Msk          (0x1UL << TIM_DIER_UIE_Pos)                  /*!< 0x00000001 */
N#define TIM_DIER_UIE              TIM_DIER_UIE_Msk                             /*!<Update interrupt enable */
N#define TIM_DIER_CC1IE_Pos        (1U)
N#define TIM_DIER_CC1IE_Msk        (0x1UL << TIM_DIER_CC1IE_Pos)                /*!< 0x00000002 */
N#define TIM_DIER_CC1IE            TIM_DIER_CC1IE_Msk                           /*!<Capture/Compare 1 interrupt enable */
N#define TIM_DIER_CC2IE_Pos        (2U)
N#define TIM_DIER_CC2IE_Msk        (0x1UL << TIM_DIER_CC2IE_Pos)                /*!< 0x00000004 */
N#define TIM_DIER_CC2IE            TIM_DIER_CC2IE_Msk                           /*!<Capture/Compare 2 interrupt enable */
N#define TIM_DIER_CC3IE_Pos        (3U)
N#define TIM_DIER_CC3IE_Msk        (0x1UL << TIM_DIER_CC3IE_Pos)                /*!< 0x00000008 */
N#define TIM_DIER_CC3IE            TIM_DIER_CC3IE_Msk                           /*!<Capture/Compare 3 interrupt enable */
N#define TIM_DIER_CC4IE_Pos        (4U)
N#define TIM_DIER_CC4IE_Msk        (0x1UL << TIM_DIER_CC4IE_Pos)                /*!< 0x00000010 */
N#define TIM_DIER_CC4IE            TIM_DIER_CC4IE_Msk                           /*!<Capture/Compare 4 interrupt enable */
N#define TIM_DIER_COMIE_Pos        (5U)
N#define TIM_DIER_COMIE_Msk        (0x1UL << TIM_DIER_COMIE_Pos)                /*!< 0x00000020 */
N#define TIM_DIER_COMIE            TIM_DIER_COMIE_Msk                           /*!<COM interrupt enable */
N#define TIM_DIER_TIE_Pos          (6U)
N#define TIM_DIER_TIE_Msk          (0x1UL << TIM_DIER_TIE_Pos)                  /*!< 0x00000040 */
N#define TIM_DIER_TIE              TIM_DIER_TIE_Msk                             /*!<Trigger interrupt enable */
N#define TIM_DIER_BIE_Pos          (7U)
N#define TIM_DIER_BIE_Msk          (0x1UL << TIM_DIER_BIE_Pos)                  /*!< 0x00000080 */
N#define TIM_DIER_BIE              TIM_DIER_BIE_Msk                             /*!<Break interrupt enable */
N#define TIM_DIER_UDE_Pos          (8U)
N#define TIM_DIER_UDE_Msk          (0x1UL << TIM_DIER_UDE_Pos)                  /*!< 0x00000100 */
N#define TIM_DIER_UDE              TIM_DIER_UDE_Msk                             /*!<Update DMA request enable */
N#define TIM_DIER_CC1DE_Pos        (9U)
N#define TIM_DIER_CC1DE_Msk        (0x1UL << TIM_DIER_CC1DE_Pos)                /*!< 0x00000200 */
N#define TIM_DIER_CC1DE            TIM_DIER_CC1DE_Msk                           /*!<Capture/Compare 1 DMA request enable */
N#define TIM_DIER_CC2DE_Pos        (10U)
N#define TIM_DIER_CC2DE_Msk        (0x1UL << TIM_DIER_CC2DE_Pos)                /*!< 0x00000400 */
N#define TIM_DIER_CC2DE            TIM_DIER_CC2DE_Msk                           /*!<Capture/Compare 2 DMA request enable */
N#define TIM_DIER_CC3DE_Pos        (11U)
N#define TIM_DIER_CC3DE_Msk        (0x1UL << TIM_DIER_CC3DE_Pos)                /*!< 0x00000800 */
N#define TIM_DIER_CC3DE            TIM_DIER_CC3DE_Msk                           /*!<Capture/Compare 3 DMA request enable */
N#define TIM_DIER_CC4DE_Pos        (12U)
N#define TIM_DIER_CC4DE_Msk        (0x1UL << TIM_DIER_CC4DE_Pos)                /*!< 0x00001000 */
N#define TIM_DIER_CC4DE            TIM_DIER_CC4DE_Msk                           /*!<Capture/Compare 4 DMA request enable */
N#define TIM_DIER_COMDE_Pos        (13U)
N#define TIM_DIER_COMDE_Msk        (0x1UL << TIM_DIER_COMDE_Pos)                /*!< 0x00002000 */
N#define TIM_DIER_COMDE            TIM_DIER_COMDE_Msk                           /*!<COM DMA request enable */
N#define TIM_DIER_TDE_Pos          (14U)
N#define TIM_DIER_TDE_Msk          (0x1UL << TIM_DIER_TDE_Pos)                  /*!< 0x00004000 */
N#define TIM_DIER_TDE              TIM_DIER_TDE_Msk                             /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define TIM_SR_UIF_Pos            (0U)
N#define TIM_SR_UIF_Msk            (0x1UL << TIM_SR_UIF_Pos)                    /*!< 0x00000001 */
N#define TIM_SR_UIF                TIM_SR_UIF_Msk                               /*!<Update interrupt Flag */
N#define TIM_SR_CC1IF_Pos          (1U)
N#define TIM_SR_CC1IF_Msk          (0x1UL << TIM_SR_CC1IF_Pos)                  /*!< 0x00000002 */
N#define TIM_SR_CC1IF              TIM_SR_CC1IF_Msk                             /*!<Capture/Compare 1 interrupt Flag */
N#define TIM_SR_CC2IF_Pos          (2U)
N#define TIM_SR_CC2IF_Msk          (0x1UL << TIM_SR_CC2IF_Pos)                  /*!< 0x00000004 */
N#define TIM_SR_CC2IF              TIM_SR_CC2IF_Msk                             /*!<Capture/Compare 2 interrupt Flag */
N#define TIM_SR_CC3IF_Pos          (3U)
N#define TIM_SR_CC3IF_Msk          (0x1UL << TIM_SR_CC3IF_Pos)                  /*!< 0x00000008 */
N#define TIM_SR_CC3IF              TIM_SR_CC3IF_Msk                             /*!<Capture/Compare 3 interrupt Flag */
N#define TIM_SR_CC4IF_Pos          (4U)
N#define TIM_SR_CC4IF_Msk          (0x1UL << TIM_SR_CC4IF_Pos)                  /*!< 0x00000010 */
N#define TIM_SR_CC4IF              TIM_SR_CC4IF_Msk                             /*!<Capture/Compare 4 interrupt Flag */
N#define TIM_SR_COMIF_Pos          (5U)
N#define TIM_SR_COMIF_Msk          (0x1UL << TIM_SR_COMIF_Pos)                  /*!< 0x00000020 */
N#define TIM_SR_COMIF              TIM_SR_COMIF_Msk                             /*!<COM interrupt Flag */
N#define TIM_SR_TIF_Pos            (6U)
N#define TIM_SR_TIF_Msk            (0x1UL << TIM_SR_TIF_Pos)                    /*!< 0x00000040 */
N#define TIM_SR_TIF                TIM_SR_TIF_Msk                               /*!<Trigger interrupt Flag */
N#define TIM_SR_BIF_Pos            (7U)
N#define TIM_SR_BIF_Msk            (0x1UL << TIM_SR_BIF_Pos)                    /*!< 0x00000080 */
N#define TIM_SR_BIF                TIM_SR_BIF_Msk                               /*!<Break interrupt Flag */
N#define TIM_SR_B2IF_Pos           (8U)
N#define TIM_SR_B2IF_Msk           (0x1UL << TIM_SR_B2IF_Pos)                   /*!< 0x00000100 */
N#define TIM_SR_B2IF               TIM_SR_B2IF_Msk                              /*!<Break 2 interrupt Flag */
N#define TIM_SR_CC1OF_Pos          (9U)
N#define TIM_SR_CC1OF_Msk          (0x1UL << TIM_SR_CC1OF_Pos)                  /*!< 0x00000200 */
N#define TIM_SR_CC1OF              TIM_SR_CC1OF_Msk                             /*!<Capture/Compare 1 Overcapture Flag */
N#define TIM_SR_CC2OF_Pos          (10U)
N#define TIM_SR_CC2OF_Msk          (0x1UL << TIM_SR_CC2OF_Pos)                  /*!< 0x00000400 */
N#define TIM_SR_CC2OF              TIM_SR_CC2OF_Msk                             /*!<Capture/Compare 2 Overcapture Flag */
N#define TIM_SR_CC3OF_Pos          (11U)
N#define TIM_SR_CC3OF_Msk          (0x1UL << TIM_SR_CC3OF_Pos)                  /*!< 0x00000800 */
N#define TIM_SR_CC3OF              TIM_SR_CC3OF_Msk                             /*!<Capture/Compare 3 Overcapture Flag */
N#define TIM_SR_CC4OF_Pos          (12U)
N#define TIM_SR_CC4OF_Msk          (0x1UL << TIM_SR_CC4OF_Pos)                  /*!< 0x00001000 */
N#define TIM_SR_CC4OF              TIM_SR_CC4OF_Msk                             /*!<Capture/Compare 4 Overcapture Flag */
N#define TIM_SR_SBIF_Pos           (13U)
N#define TIM_SR_SBIF_Msk           (0x1UL << TIM_SR_SBIF_Pos)                   /*!< 0x00002000 */
N#define TIM_SR_SBIF               TIM_SR_SBIF_Msk                              /*!<System Break interrupt Flag */
N#define TIM_SR_CC5IF_Pos          (16U)
N#define TIM_SR_CC5IF_Msk          (0x1UL << TIM_SR_CC5IF_Pos)                  /*!< 0x00010000 */
N#define TIM_SR_CC5IF              TIM_SR_CC5IF_Msk                             /*!<Capture/Compare 5 interrupt Flag */
N#define TIM_SR_CC6IF_Pos          (17U)
N#define TIM_SR_CC6IF_Msk          (0x1UL << TIM_SR_CC6IF_Pos)                  /*!< 0x00020000 */
N#define TIM_SR_CC6IF              TIM_SR_CC6IF_Msk                             /*!<Capture/Compare 6 interrupt Flag */
N
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define TIM_EGR_UG_Pos            (0U)
N#define TIM_EGR_UG_Msk            (0x1UL << TIM_EGR_UG_Pos)                    /*!< 0x00000001 */
N#define TIM_EGR_UG                TIM_EGR_UG_Msk                               /*!<Update Generation */
N#define TIM_EGR_CC1G_Pos          (1U)
N#define TIM_EGR_CC1G_Msk          (0x1UL << TIM_EGR_CC1G_Pos)                  /*!< 0x00000002 */
N#define TIM_EGR_CC1G              TIM_EGR_CC1G_Msk                             /*!<Capture/Compare 1 Generation */
N#define TIM_EGR_CC2G_Pos          (2U)
N#define TIM_EGR_CC2G_Msk          (0x1UL << TIM_EGR_CC2G_Pos)                  /*!< 0x00000004 */
N#define TIM_EGR_CC2G              TIM_EGR_CC2G_Msk                             /*!<Capture/Compare 2 Generation */
N#define TIM_EGR_CC3G_Pos          (3U)
N#define TIM_EGR_CC3G_Msk          (0x1UL << TIM_EGR_CC3G_Pos)                  /*!< 0x00000008 */
N#define TIM_EGR_CC3G              TIM_EGR_CC3G_Msk                             /*!<Capture/Compare 3 Generation */
N#define TIM_EGR_CC4G_Pos          (4U)
N#define TIM_EGR_CC4G_Msk          (0x1UL << TIM_EGR_CC4G_Pos)                  /*!< 0x00000010 */
N#define TIM_EGR_CC4G              TIM_EGR_CC4G_Msk                             /*!<Capture/Compare 4 Generation */
N#define TIM_EGR_COMG_Pos          (5U)
N#define TIM_EGR_COMG_Msk          (0x1UL << TIM_EGR_COMG_Pos)                  /*!< 0x00000020 */
N#define TIM_EGR_COMG              TIM_EGR_COMG_Msk                             /*!<Capture/Compare Control Update Generation */
N#define TIM_EGR_TG_Pos            (6U)
N#define TIM_EGR_TG_Msk            (0x1UL << TIM_EGR_TG_Pos)                    /*!< 0x00000040 */
N#define TIM_EGR_TG                TIM_EGR_TG_Msk                               /*!<Trigger Generation */
N#define TIM_EGR_BG_Pos            (7U)
N#define TIM_EGR_BG_Msk            (0x1UL << TIM_EGR_BG_Pos)                    /*!< 0x00000080 */
N#define TIM_EGR_BG                TIM_EGR_BG_Msk                               /*!<Break Generation */
N#define TIM_EGR_B2G_Pos           (8U)
N#define TIM_EGR_B2G_Msk           (0x1UL << TIM_EGR_B2G_Pos)                   /*!< 0x00000100 */
N#define TIM_EGR_B2G               TIM_EGR_B2G_Msk                              /*!<Break 2 Generation */
N
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define TIM_CCMR1_CC1S_Pos        (0U)
N#define TIM_CCMR1_CC1S_Msk        (0x3UL << TIM_CCMR1_CC1S_Pos)                /*!< 0x00000003 */
N#define TIM_CCMR1_CC1S            TIM_CCMR1_CC1S_Msk                           /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define TIM_CCMR1_CC1S_0          (0x1UL << TIM_CCMR1_CC1S_Pos)                /*!< 0x00000001 */
N#define TIM_CCMR1_CC1S_1          (0x2UL << TIM_CCMR1_CC1S_Pos)                /*!< 0x00000002 */
N
N#define TIM_CCMR1_OC1FE_Pos       (2U)
N#define TIM_CCMR1_OC1FE_Msk       (0x1UL << TIM_CCMR1_OC1FE_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR1_OC1FE           TIM_CCMR1_OC1FE_Msk                          /*!<Output Compare 1 Fast enable */
N#define TIM_CCMR1_OC1PE_Pos       (3U)
N#define TIM_CCMR1_OC1PE_Msk       (0x1UL << TIM_CCMR1_OC1PE_Pos)               /*!< 0x00000008 */
N#define TIM_CCMR1_OC1PE           TIM_CCMR1_OC1PE_Msk                          /*!<Output Compare 1 Preload enable */
N
N#define TIM_CCMR1_OC1M_Pos        (4U)
N#define TIM_CCMR1_OC1M_Msk        (0x1007UL << TIM_CCMR1_OC1M_Pos)             /*!< 0x00010070 */
N#define TIM_CCMR1_OC1M            TIM_CCMR1_OC1M_Msk                           /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define TIM_CCMR1_OC1M_0          (0x0001UL << TIM_CCMR1_OC1M_Pos)             /*!< 0x00000010 */
N#define TIM_CCMR1_OC1M_1          (0x0002UL << TIM_CCMR1_OC1M_Pos)             /*!< 0x00000020 */
N#define TIM_CCMR1_OC1M_2          (0x0004UL << TIM_CCMR1_OC1M_Pos)             /*!< 0x00000040 */
N#define TIM_CCMR1_OC1M_3          (0x1000UL << TIM_CCMR1_OC1M_Pos)             /*!< 0x00010000 */
N
N#define TIM_CCMR1_OC1CE_Pos       (7U)
N#define TIM_CCMR1_OC1CE_Msk       (0x1UL << TIM_CCMR1_OC1CE_Pos)               /*!< 0x00000080 */
N#define TIM_CCMR1_OC1CE           TIM_CCMR1_OC1CE_Msk                          /*!<Output Compare 1 Clear Enable */
N
N#define TIM_CCMR1_CC2S_Pos        (8U)
N#define TIM_CCMR1_CC2S_Msk        (0x3UL << TIM_CCMR1_CC2S_Pos)                /*!< 0x00000300 */
N#define TIM_CCMR1_CC2S            TIM_CCMR1_CC2S_Msk                           /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define TIM_CCMR1_CC2S_0          (0x1UL << TIM_CCMR1_CC2S_Pos)                /*!< 0x00000100 */
N#define TIM_CCMR1_CC2S_1          (0x2UL << TIM_CCMR1_CC2S_Pos)                /*!< 0x00000200 */
N
N#define TIM_CCMR1_OC2FE_Pos       (10U)
N#define TIM_CCMR1_OC2FE_Msk       (0x1UL << TIM_CCMR1_OC2FE_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR1_OC2FE           TIM_CCMR1_OC2FE_Msk                          /*!<Output Compare 2 Fast enable */
N#define TIM_CCMR1_OC2PE_Pos       (11U)
N#define TIM_CCMR1_OC2PE_Msk       (0x1UL << TIM_CCMR1_OC2PE_Pos)               /*!< 0x00000800 */
N#define TIM_CCMR1_OC2PE           TIM_CCMR1_OC2PE_Msk                          /*!<Output Compare 2 Preload enable */
N
N#define TIM_CCMR1_OC2M_Pos        (12U)
N#define TIM_CCMR1_OC2M_Msk        (0x1007UL << TIM_CCMR1_OC2M_Pos)             /*!< 0x01007000 */
N#define TIM_CCMR1_OC2M            TIM_CCMR1_OC2M_Msk                           /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define TIM_CCMR1_OC2M_0          (0x0001UL << TIM_CCMR1_OC2M_Pos)             /*!< 0x00001000 */
N#define TIM_CCMR1_OC2M_1          (0x0002UL << TIM_CCMR1_OC2M_Pos)             /*!< 0x00002000 */
N#define TIM_CCMR1_OC2M_2          (0x0004UL << TIM_CCMR1_OC2M_Pos)             /*!< 0x00004000 */
N#define TIM_CCMR1_OC2M_3          (0x1000UL << TIM_CCMR1_OC2M_Pos)             /*!< 0x01000000 */
N
N#define TIM_CCMR1_OC2CE_Pos       (15U)
N#define TIM_CCMR1_OC2CE_Msk       (0x1UL << TIM_CCMR1_OC2CE_Pos)               /*!< 0x00008000 */
N#define TIM_CCMR1_OC2CE           TIM_CCMR1_OC2CE_Msk                          /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N#define TIM_CCMR1_IC1PSC_Pos      (2U)
N#define TIM_CCMR1_IC1PSC_Msk      (0x3UL << TIM_CCMR1_IC1PSC_Pos)              /*!< 0x0000000C */
N#define TIM_CCMR1_IC1PSC          TIM_CCMR1_IC1PSC_Msk                         /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define TIM_CCMR1_IC1PSC_0        (0x1UL << TIM_CCMR1_IC1PSC_Pos)              /*!< 0x00000004 */
N#define TIM_CCMR1_IC1PSC_1        (0x2UL << TIM_CCMR1_IC1PSC_Pos)              /*!< 0x00000008 */
N
N#define TIM_CCMR1_IC1F_Pos        (4U)
N#define TIM_CCMR1_IC1F_Msk        (0xFUL << TIM_CCMR1_IC1F_Pos)                /*!< 0x000000F0 */
N#define TIM_CCMR1_IC1F            TIM_CCMR1_IC1F_Msk                           /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define TIM_CCMR1_IC1F_0          (0x1UL << TIM_CCMR1_IC1F_Pos)                /*!< 0x00000010 */
N#define TIM_CCMR1_IC1F_1          (0x2UL << TIM_CCMR1_IC1F_Pos)                /*!< 0x00000020 */
N#define TIM_CCMR1_IC1F_2          (0x4UL << TIM_CCMR1_IC1F_Pos)                /*!< 0x00000040 */
N#define TIM_CCMR1_IC1F_3          (0x8UL << TIM_CCMR1_IC1F_Pos)                /*!< 0x00000080 */
N
N#define TIM_CCMR1_IC2PSC_Pos      (10U)
N#define TIM_CCMR1_IC2PSC_Msk      (0x3UL << TIM_CCMR1_IC2PSC_Pos)              /*!< 0x00000C00 */
N#define TIM_CCMR1_IC2PSC          TIM_CCMR1_IC2PSC_Msk                         /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define TIM_CCMR1_IC2PSC_0        (0x1UL << TIM_CCMR1_IC2PSC_Pos)              /*!< 0x00000400 */
N#define TIM_CCMR1_IC2PSC_1        (0x2UL << TIM_CCMR1_IC2PSC_Pos)              /*!< 0x00000800 */
N
N#define TIM_CCMR1_IC2F_Pos        (12U)
N#define TIM_CCMR1_IC2F_Msk        (0xFUL << TIM_CCMR1_IC2F_Pos)                /*!< 0x0000F000 */
N#define TIM_CCMR1_IC2F            TIM_CCMR1_IC2F_Msk                           /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define TIM_CCMR1_IC2F_0          (0x1UL << TIM_CCMR1_IC2F_Pos)                /*!< 0x00001000 */
N#define TIM_CCMR1_IC2F_1          (0x2UL << TIM_CCMR1_IC2F_Pos)                /*!< 0x00002000 */
N#define TIM_CCMR1_IC2F_2          (0x4UL << TIM_CCMR1_IC2F_Pos)                /*!< 0x00004000 */
N#define TIM_CCMR1_IC2F_3          (0x8UL << TIM_CCMR1_IC2F_Pos)                /*!< 0x00008000 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define TIM_CCMR2_CC3S_Pos        (0U)
N#define TIM_CCMR2_CC3S_Msk        (0x3UL << TIM_CCMR2_CC3S_Pos)                /*!< 0x00000003 */
N#define TIM_CCMR2_CC3S            TIM_CCMR2_CC3S_Msk                           /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define TIM_CCMR2_CC3S_0          (0x1UL << TIM_CCMR2_CC3S_Pos)                /*!< 0x00000001 */
N#define TIM_CCMR2_CC3S_1          (0x2UL << TIM_CCMR2_CC3S_Pos)                /*!< 0x00000002 */
N
N#define TIM_CCMR2_OC3FE_Pos       (2U)
N#define TIM_CCMR2_OC3FE_Msk       (0x1UL << TIM_CCMR2_OC3FE_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR2_OC3FE           TIM_CCMR2_OC3FE_Msk                          /*!<Output Compare 3 Fast enable */
N#define TIM_CCMR2_OC3PE_Pos       (3U)
N#define TIM_CCMR2_OC3PE_Msk       (0x1UL << TIM_CCMR2_OC3PE_Pos)               /*!< 0x00000008 */
N#define TIM_CCMR2_OC3PE           TIM_CCMR2_OC3PE_Msk                          /*!<Output Compare 3 Preload enable */
N
N#define TIM_CCMR2_OC3M_Pos        (4U)
N#define TIM_CCMR2_OC3M_Msk        (0x1007UL << TIM_CCMR2_OC3M_Pos)             /*!< 0x00010070 */
N#define TIM_CCMR2_OC3M            TIM_CCMR2_OC3M_Msk                           /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define TIM_CCMR2_OC3M_0          (0x0001UL << TIM_CCMR2_OC3M_Pos)             /*!< 0x00000010 */
N#define TIM_CCMR2_OC3M_1          (0x0002UL << TIM_CCMR2_OC3M_Pos)             /*!< 0x00000020 */
N#define TIM_CCMR2_OC3M_2          (0x0004UL << TIM_CCMR2_OC3M_Pos)             /*!< 0x00000040 */
N#define TIM_CCMR2_OC3M_3          (0x1000UL << TIM_CCMR2_OC3M_Pos)             /*!< 0x00010000 */
N
N#define TIM_CCMR2_OC3CE_Pos       (7U)
N#define TIM_CCMR2_OC3CE_Msk       (0x1UL << TIM_CCMR2_OC3CE_Pos)               /*!< 0x00000080 */
N#define TIM_CCMR2_OC3CE           TIM_CCMR2_OC3CE_Msk                          /*!<Output Compare 3 Clear Enable */
N
N#define TIM_CCMR2_CC4S_Pos        (8U)
N#define TIM_CCMR2_CC4S_Msk        (0x3UL << TIM_CCMR2_CC4S_Pos)                /*!< 0x00000300 */
N#define TIM_CCMR2_CC4S            TIM_CCMR2_CC4S_Msk                           /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define TIM_CCMR2_CC4S_0          (0x1UL << TIM_CCMR2_CC4S_Pos)                /*!< 0x00000100 */
N#define TIM_CCMR2_CC4S_1          (0x2UL << TIM_CCMR2_CC4S_Pos)                /*!< 0x00000200 */
N
N#define TIM_CCMR2_OC4FE_Pos       (10U)
N#define TIM_CCMR2_OC4FE_Msk       (0x1UL << TIM_CCMR2_OC4FE_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR2_OC4FE           TIM_CCMR2_OC4FE_Msk                          /*!<Output Compare 4 Fast enable */
N#define TIM_CCMR2_OC4PE_Pos       (11U)
N#define TIM_CCMR2_OC4PE_Msk       (0x1UL << TIM_CCMR2_OC4PE_Pos)               /*!< 0x00000800 */
N#define TIM_CCMR2_OC4PE           TIM_CCMR2_OC4PE_Msk                          /*!<Output Compare 4 Preload enable */
N
N#define TIM_CCMR2_OC4M_Pos        (12U)
N#define TIM_CCMR2_OC4M_Msk        (0x1007UL << TIM_CCMR2_OC4M_Pos)             /*!< 0x01007000 */
N#define TIM_CCMR2_OC4M            TIM_CCMR2_OC4M_Msk                           /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define TIM_CCMR2_OC4M_0          (0x0001UL << TIM_CCMR2_OC4M_Pos)             /*!< 0x00001000 */
N#define TIM_CCMR2_OC4M_1          (0x0002UL << TIM_CCMR2_OC4M_Pos)             /*!< 0x00002000 */
N#define TIM_CCMR2_OC4M_2          (0x0004UL << TIM_CCMR2_OC4M_Pos)             /*!< 0x00004000 */
N#define TIM_CCMR2_OC4M_3          (0x1000UL << TIM_CCMR2_OC4M_Pos)             /*!< 0x01000000 */
N
N#define TIM_CCMR2_OC4CE_Pos       (15U)
N#define TIM_CCMR2_OC4CE_Msk       (0x1UL << TIM_CCMR2_OC4CE_Pos)               /*!< 0x00008000 */
N#define TIM_CCMR2_OC4CE           TIM_CCMR2_OC4CE_Msk                          /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N#define TIM_CCMR2_IC3PSC_Pos      (2U)
N#define TIM_CCMR2_IC3PSC_Msk      (0x3UL << TIM_CCMR2_IC3PSC_Pos)              /*!< 0x0000000C */
N#define TIM_CCMR2_IC3PSC          TIM_CCMR2_IC3PSC_Msk                         /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define TIM_CCMR2_IC3PSC_0        (0x1UL << TIM_CCMR2_IC3PSC_Pos)              /*!< 0x00000004 */
N#define TIM_CCMR2_IC3PSC_1        (0x2UL << TIM_CCMR2_IC3PSC_Pos)              /*!< 0x00000008 */
N
N#define TIM_CCMR2_IC3F_Pos        (4U)
N#define TIM_CCMR2_IC3F_Msk        (0xFUL << TIM_CCMR2_IC3F_Pos)                /*!< 0x000000F0 */
N#define TIM_CCMR2_IC3F            TIM_CCMR2_IC3F_Msk                           /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define TIM_CCMR2_IC3F_0          (0x1UL << TIM_CCMR2_IC3F_Pos)                /*!< 0x00000010 */
N#define TIM_CCMR2_IC3F_1          (0x2UL << TIM_CCMR2_IC3F_Pos)                /*!< 0x00000020 */
N#define TIM_CCMR2_IC3F_2          (0x4UL << TIM_CCMR2_IC3F_Pos)                /*!< 0x00000040 */
N#define TIM_CCMR2_IC3F_3          (0x8UL << TIM_CCMR2_IC3F_Pos)                /*!< 0x00000080 */
N
N#define TIM_CCMR2_IC4PSC_Pos      (10U)
N#define TIM_CCMR2_IC4PSC_Msk      (0x3UL << TIM_CCMR2_IC4PSC_Pos)              /*!< 0x00000C00 */
N#define TIM_CCMR2_IC4PSC          TIM_CCMR2_IC4PSC_Msk                         /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define TIM_CCMR2_IC4PSC_0        (0x1UL << TIM_CCMR2_IC4PSC_Pos)              /*!< 0x00000400 */
N#define TIM_CCMR2_IC4PSC_1        (0x2UL << TIM_CCMR2_IC4PSC_Pos)              /*!< 0x00000800 */
N
N#define TIM_CCMR2_IC4F_Pos        (12U)
N#define TIM_CCMR2_IC4F_Msk        (0xFUL << TIM_CCMR2_IC4F_Pos)                /*!< 0x0000F000 */
N#define TIM_CCMR2_IC4F            TIM_CCMR2_IC4F_Msk                           /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define TIM_CCMR2_IC4F_0          (0x1UL << TIM_CCMR2_IC4F_Pos)                /*!< 0x00001000 */
N#define TIM_CCMR2_IC4F_1          (0x2UL << TIM_CCMR2_IC4F_Pos)                /*!< 0x00002000 */
N#define TIM_CCMR2_IC4F_2          (0x4UL << TIM_CCMR2_IC4F_Pos)                /*!< 0x00004000 */
N#define TIM_CCMR2_IC4F_3          (0x8UL << TIM_CCMR2_IC4F_Pos)                /*!< 0x00008000 */
N
N/******************  Bit definition for TIM_CCMR3 register  *******************/
N#define TIM_CCMR3_OC5FE_Pos       (2U)
N#define TIM_CCMR3_OC5FE_Msk       (0x1UL << TIM_CCMR3_OC5FE_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR3_OC5FE           TIM_CCMR3_OC5FE_Msk                          /*!<Output Compare 5 Fast enable */
N#define TIM_CCMR3_OC5PE_Pos       (3U)
N#define TIM_CCMR3_OC5PE_Msk       (0x1UL << TIM_CCMR3_OC5PE_Pos)               /*!< 0x00000008 */
N#define TIM_CCMR3_OC5PE           TIM_CCMR3_OC5PE_Msk                          /*!<Output Compare 5 Preload enable */
N
N#define TIM_CCMR3_OC5M_Pos        (4U)
N#define TIM_CCMR3_OC5M_Msk        (0x1007UL << TIM_CCMR3_OC5M_Pos)             /*!< 0x00010070 */
N#define TIM_CCMR3_OC5M            TIM_CCMR3_OC5M_Msk                           /*!<OC5M[3:0] bits (Output Compare 5 Mode) */
N#define TIM_CCMR3_OC5M_0          (0x0001UL << TIM_CCMR3_OC5M_Pos)             /*!< 0x00000010 */
N#define TIM_CCMR3_OC5M_1          (0x0002UL << TIM_CCMR3_OC5M_Pos)             /*!< 0x00000020 */
N#define TIM_CCMR3_OC5M_2          (0x0004UL << TIM_CCMR3_OC5M_Pos)             /*!< 0x00000040 */
N#define TIM_CCMR3_OC5M_3          (0x1000UL << TIM_CCMR3_OC5M_Pos)             /*!< 0x00010000 */
N
N#define TIM_CCMR3_OC5CE_Pos       (7U)
N#define TIM_CCMR3_OC5CE_Msk       (0x1UL << TIM_CCMR3_OC5CE_Pos)               /*!< 0x00000080 */
N#define TIM_CCMR3_OC5CE           TIM_CCMR3_OC5CE_Msk                          /*!<Output Compare 5 Clear Enable */
N
N#define TIM_CCMR3_OC6FE_Pos       (10U)
N#define TIM_CCMR3_OC6FE_Msk       (0x1UL << TIM_CCMR3_OC6FE_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR3_OC6FE           TIM_CCMR3_OC6FE_Msk                          /*!<Output Compare 6 Fast enable */
N#define TIM_CCMR3_OC6PE_Pos       (11U)
N#define TIM_CCMR3_OC6PE_Msk       (0x1UL << TIM_CCMR3_OC6PE_Pos)               /*!< 0x00000800 */
N#define TIM_CCMR3_OC6PE           TIM_CCMR3_OC6PE_Msk                          /*!<Output Compare 6 Preload enable */
N
N#define TIM_CCMR3_OC6M_Pos        (12U)
N#define TIM_CCMR3_OC6M_Msk        (0x1007UL << TIM_CCMR3_OC6M_Pos)             /*!< 0x01007000 */
N#define TIM_CCMR3_OC6M            TIM_CCMR3_OC6M_Msk                           /*!<OC6M[3:0] bits (Output Compare 6 Mode) */
N#define TIM_CCMR3_OC6M_0          (0x0001UL << TIM_CCMR3_OC6M_Pos)             /*!< 0x00001000 */
N#define TIM_CCMR3_OC6M_1          (0x0002UL << TIM_CCMR3_OC6M_Pos)             /*!< 0x00002000 */
N#define TIM_CCMR3_OC6M_2          (0x0004UL << TIM_CCMR3_OC6M_Pos)             /*!< 0x00004000 */
N#define TIM_CCMR3_OC6M_3          (0x1000UL << TIM_CCMR3_OC6M_Pos)             /*!< 0x01000000 */
N
N#define TIM_CCMR3_OC6CE_Pos       (15U)
N#define TIM_CCMR3_OC6CE_Msk       (0x1UL << TIM_CCMR3_OC6CE_Pos)               /*!< 0x00008000 */
N#define TIM_CCMR3_OC6CE           TIM_CCMR3_OC6CE_Msk                          /*!<Output Compare 6 Clear Enable */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define TIM_CCER_CC1E_Pos         (0U)
N#define TIM_CCER_CC1E_Msk         (0x1UL << TIM_CCER_CC1E_Pos)                 /*!< 0x00000001 */
N#define TIM_CCER_CC1E             TIM_CCER_CC1E_Msk                            /*!<Capture/Compare 1 output enable */
N#define TIM_CCER_CC1P_Pos         (1U)
N#define TIM_CCER_CC1P_Msk         (0x1UL << TIM_CCER_CC1P_Pos)                 /*!< 0x00000002 */
N#define TIM_CCER_CC1P             TIM_CCER_CC1P_Msk                            /*!<Capture/Compare 1 output Polarity */
N#define TIM_CCER_CC1NE_Pos        (2U)
N#define TIM_CCER_CC1NE_Msk        (0x1UL << TIM_CCER_CC1NE_Pos)                /*!< 0x00000004 */
N#define TIM_CCER_CC1NE            TIM_CCER_CC1NE_Msk                           /*!<Capture/Compare 1 Complementary output enable */
N#define TIM_CCER_CC1NP_Pos        (3U)
N#define TIM_CCER_CC1NP_Msk        (0x1UL << TIM_CCER_CC1NP_Pos)                /*!< 0x00000008 */
N#define TIM_CCER_CC1NP            TIM_CCER_CC1NP_Msk                           /*!<Capture/Compare 1 Complementary output Polarity */
N#define TIM_CCER_CC2E_Pos         (4U)
N#define TIM_CCER_CC2E_Msk         (0x1UL << TIM_CCER_CC2E_Pos)                 /*!< 0x00000010 */
N#define TIM_CCER_CC2E             TIM_CCER_CC2E_Msk                            /*!<Capture/Compare 2 output enable */
N#define TIM_CCER_CC2P_Pos         (5U)
N#define TIM_CCER_CC2P_Msk         (0x1UL << TIM_CCER_CC2P_Pos)                 /*!< 0x00000020 */
N#define TIM_CCER_CC2P             TIM_CCER_CC2P_Msk                            /*!<Capture/Compare 2 output Polarity */
N#define TIM_CCER_CC2NE_Pos        (6U)
N#define TIM_CCER_CC2NE_Msk        (0x1UL << TIM_CCER_CC2NE_Pos)                /*!< 0x00000040 */
N#define TIM_CCER_CC2NE            TIM_CCER_CC2NE_Msk                           /*!<Capture/Compare 2 Complementary output enable */
N#define TIM_CCER_CC2NP_Pos        (7U)
N#define TIM_CCER_CC2NP_Msk        (0x1UL << TIM_CCER_CC2NP_Pos)                /*!< 0x00000080 */
N#define TIM_CCER_CC2NP            TIM_CCER_CC2NP_Msk                           /*!<Capture/Compare 2 Complementary output Polarity */
N#define TIM_CCER_CC3E_Pos         (8U)
N#define TIM_CCER_CC3E_Msk         (0x1UL << TIM_CCER_CC3E_Pos)                 /*!< 0x00000100 */
N#define TIM_CCER_CC3E             TIM_CCER_CC3E_Msk                            /*!<Capture/Compare 3 output enable */
N#define TIM_CCER_CC3P_Pos         (9U)
N#define TIM_CCER_CC3P_Msk         (0x1UL << TIM_CCER_CC3P_Pos)                 /*!< 0x00000200 */
N#define TIM_CCER_CC3P             TIM_CCER_CC3P_Msk                            /*!<Capture/Compare 3 output Polarity */
N#define TIM_CCER_CC3NE_Pos        (10U)
N#define TIM_CCER_CC3NE_Msk        (0x1UL << TIM_CCER_CC3NE_Pos)                /*!< 0x00000400 */
N#define TIM_CCER_CC3NE            TIM_CCER_CC3NE_Msk                           /*!<Capture/Compare 3 Complementary output enable */
N#define TIM_CCER_CC3NP_Pos        (11U)
N#define TIM_CCER_CC3NP_Msk        (0x1UL << TIM_CCER_CC3NP_Pos)                /*!< 0x00000800 */
N#define TIM_CCER_CC3NP            TIM_CCER_CC3NP_Msk                           /*!<Capture/Compare 3 Complementary output Polarity */
N#define TIM_CCER_CC4E_Pos         (12U)
N#define TIM_CCER_CC4E_Msk         (0x1UL << TIM_CCER_CC4E_Pos)                 /*!< 0x00001000 */
N#define TIM_CCER_CC4E             TIM_CCER_CC4E_Msk                            /*!<Capture/Compare 4 output enable */
N#define TIM_CCER_CC4P_Pos         (13U)
N#define TIM_CCER_CC4P_Msk         (0x1UL << TIM_CCER_CC4P_Pos)                 /*!< 0x00002000 */
N#define TIM_CCER_CC4P             TIM_CCER_CC4P_Msk                            /*!<Capture/Compare 4 output Polarity */
N#define TIM_CCER_CC4NP_Pos        (15U)
N#define TIM_CCER_CC4NP_Msk        (0x1UL << TIM_CCER_CC4NP_Pos)                /*!< 0x00008000 */
N#define TIM_CCER_CC4NP            TIM_CCER_CC4NP_Msk                           /*!<Capture/Compare 4 Complementary output Polarity */
N#define TIM_CCER_CC5E_Pos         (16U)
N#define TIM_CCER_CC5E_Msk         (0x1UL << TIM_CCER_CC5E_Pos)                 /*!< 0x00010000 */
N#define TIM_CCER_CC5E             TIM_CCER_CC5E_Msk                            /*!<Capture/Compare 5 output enable */
N#define TIM_CCER_CC5P_Pos         (17U)
N#define TIM_CCER_CC5P_Msk         (0x1UL << TIM_CCER_CC5P_Pos)                 /*!< 0x00020000 */
N#define TIM_CCER_CC5P             TIM_CCER_CC5P_Msk                            /*!<Capture/Compare 5 output Polarity */
N#define TIM_CCER_CC6E_Pos         (20U)
N#define TIM_CCER_CC6E_Msk         (0x1UL << TIM_CCER_CC6E_Pos)                 /*!< 0x00100000 */
N#define TIM_CCER_CC6E             TIM_CCER_CC6E_Msk                            /*!<Capture/Compare 6 output enable */
N#define TIM_CCER_CC6P_Pos         (21U)
N#define TIM_CCER_CC6P_Msk         (0x1UL << TIM_CCER_CC6P_Pos)                 /*!< 0x00200000 */
N#define TIM_CCER_CC6P             TIM_CCER_CC6P_Msk                            /*!<Capture/Compare 6 output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define TIM_CNT_CNT_Pos           (0U)
N#define TIM_CNT_CNT_Msk           (0xFFFFFFFFUL << TIM_CNT_CNT_Pos)            /*!< 0xFFFFFFFF */
N#define TIM_CNT_CNT               TIM_CNT_CNT_Msk                              /*!<Counter Value */
N#define TIM_CNT_UIFCPY_Pos        (31U)
N#define TIM_CNT_UIFCPY_Msk        (0x1UL << TIM_CNT_UIFCPY_Pos)                /*!< 0x80000000 */
N#define TIM_CNT_UIFCPY            TIM_CNT_UIFCPY_Msk                           /*!<Update interrupt flag copy (if UIFREMAP=1) */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define TIM_PSC_PSC_Pos           (0U)
N#define TIM_PSC_PSC_Msk           (0xFFFFUL << TIM_PSC_PSC_Pos)                /*!< 0x0000FFFF */
N#define TIM_PSC_PSC               TIM_PSC_PSC_Msk                              /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define TIM_ARR_ARR_Pos           (0U)
N#define TIM_ARR_ARR_Msk           (0xFFFFFFFFUL << TIM_ARR_ARR_Pos)            /*!< 0xFFFFFFFF */
N#define TIM_ARR_ARR               TIM_ARR_ARR_Msk                              /*!<Actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define TIM_RCR_REP_Pos           (0U)
N#define TIM_RCR_REP_Msk           (0xFFFFUL << TIM_RCR_REP_Pos)                /*!< 0x0000FFFF */
N#define TIM_RCR_REP               TIM_RCR_REP_Msk                              /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define TIM_CCR1_CCR1_Pos         (0U)
N#define TIM_CCR1_CCR1_Msk         (0xFFFFUL << TIM_CCR1_CCR1_Pos)              /*!< 0x0000FFFF */
N#define TIM_CCR1_CCR1             TIM_CCR1_CCR1_Msk                            /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define TIM_CCR2_CCR2_Pos         (0U)
N#define TIM_CCR2_CCR2_Msk         (0xFFFFUL << TIM_CCR2_CCR2_Pos)              /*!< 0x0000FFFF */
N#define TIM_CCR2_CCR2             TIM_CCR2_CCR2_Msk                            /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define TIM_CCR3_CCR3_Pos         (0U)
N#define TIM_CCR3_CCR3_Msk         (0xFFFFUL << TIM_CCR3_CCR3_Pos)              /*!< 0x0000FFFF */
N#define TIM_CCR3_CCR3             TIM_CCR3_CCR3_Msk                            /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define TIM_CCR4_CCR4_Pos         (0U)
N#define TIM_CCR4_CCR4_Msk         (0xFFFFUL << TIM_CCR4_CCR4_Pos)              /*!< 0x0000FFFF */
N#define TIM_CCR4_CCR4             TIM_CCR4_CCR4_Msk                            /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_CCR5 register  *******************/
N#define TIM_CCR5_CCR5_Pos         (0U)
N#define TIM_CCR5_CCR5_Msk         (0xFFFFFFFFUL << TIM_CCR5_CCR5_Pos)          /*!< 0xFFFFFFFF */
N#define TIM_CCR5_CCR5             TIM_CCR5_CCR5_Msk                            /*!<Capture/Compare 5 Value */
N#define TIM_CCR5_GC5C1_Pos        (29U)
N#define TIM_CCR5_GC5C1_Msk        (0x1UL << TIM_CCR5_GC5C1_Pos)                /*!< 0x20000000 */
N#define TIM_CCR5_GC5C1            TIM_CCR5_GC5C1_Msk                           /*!<Group Channel 5 and Channel 1 */
N#define TIM_CCR5_GC5C2_Pos        (30U)
N#define TIM_CCR5_GC5C2_Msk        (0x1UL << TIM_CCR5_GC5C2_Pos)                /*!< 0x40000000 */
N#define TIM_CCR5_GC5C2            TIM_CCR5_GC5C2_Msk                           /*!<Group Channel 5 and Channel 2 */
N#define TIM_CCR5_GC5C3_Pos        (31U)
N#define TIM_CCR5_GC5C3_Msk        (0x1UL << TIM_CCR5_GC5C3_Pos)                /*!< 0x80000000 */
N#define TIM_CCR5_GC5C3            TIM_CCR5_GC5C3_Msk                           /*!<Group Channel 5 and Channel 3 */
N
N/*******************  Bit definition for TIM_CCR6 register  *******************/
N#define TIM_CCR6_CCR6_Pos         (0U)
N#define TIM_CCR6_CCR6_Msk         (0xFFFFUL << TIM_CCR6_CCR6_Pos)              /*!< 0x0000FFFF */
N#define TIM_CCR6_CCR6             TIM_CCR6_CCR6_Msk                            /*!<Capture/Compare 6 Value */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define TIM_BDTR_DTG_Pos          (0U)
N#define TIM_BDTR_DTG_Msk          (0xFFUL << TIM_BDTR_DTG_Pos)                 /*!< 0x000000FF */
N#define TIM_BDTR_DTG              TIM_BDTR_DTG_Msk                             /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define TIM_BDTR_DTG_0            (0x01UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000001 */
N#define TIM_BDTR_DTG_1            (0x02UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000002 */
N#define TIM_BDTR_DTG_2            (0x04UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000004 */
N#define TIM_BDTR_DTG_3            (0x08UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000008 */
N#define TIM_BDTR_DTG_4            (0x10UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000010 */
N#define TIM_BDTR_DTG_5            (0x20UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000020 */
N#define TIM_BDTR_DTG_6            (0x40UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000040 */
N#define TIM_BDTR_DTG_7            (0x80UL << TIM_BDTR_DTG_Pos)                 /*!< 0x00000080 */
N
N#define TIM_BDTR_LOCK_Pos         (8U)
N#define TIM_BDTR_LOCK_Msk         (0x3UL << TIM_BDTR_LOCK_Pos)                 /*!< 0x00000300 */
N#define TIM_BDTR_LOCK             TIM_BDTR_LOCK_Msk                            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define TIM_BDTR_LOCK_0           (0x1UL << TIM_BDTR_LOCK_Pos)                 /*!< 0x00000100 */
N#define TIM_BDTR_LOCK_1           (0x2UL << TIM_BDTR_LOCK_Pos)                 /*!< 0x00000200 */
N
N#define TIM_BDTR_OSSI_Pos         (10U)
N#define TIM_BDTR_OSSI_Msk         (0x1UL << TIM_BDTR_OSSI_Pos)                 /*!< 0x00000400 */
N#define TIM_BDTR_OSSI             TIM_BDTR_OSSI_Msk                            /*!<Off-State Selection for Idle mode */
N#define TIM_BDTR_OSSR_Pos         (11U)
N#define TIM_BDTR_OSSR_Msk         (0x1UL << TIM_BDTR_OSSR_Pos)                 /*!< 0x00000800 */
N#define TIM_BDTR_OSSR             TIM_BDTR_OSSR_Msk                            /*!<Off-State Selection for Run mode */
N#define TIM_BDTR_BKE_Pos          (12U)
N#define TIM_BDTR_BKE_Msk          (0x1UL << TIM_BDTR_BKE_Pos)                  /*!< 0x00001000 */
N#define TIM_BDTR_BKE              TIM_BDTR_BKE_Msk                             /*!<Break enable for Break 1 */
N#define TIM_BDTR_BKP_Pos          (13U)
N#define TIM_BDTR_BKP_Msk          (0x1UL << TIM_BDTR_BKP_Pos)                  /*!< 0x00002000 */
N#define TIM_BDTR_BKP              TIM_BDTR_BKP_Msk                             /*!<Break Polarity for Break 1 */
N#define TIM_BDTR_AOE_Pos          (14U)
N#define TIM_BDTR_AOE_Msk          (0x1UL << TIM_BDTR_AOE_Pos)                  /*!< 0x00004000 */
N#define TIM_BDTR_AOE              TIM_BDTR_AOE_Msk                             /*!<Automatic Output enable */
N#define TIM_BDTR_MOE_Pos          (15U)
N#define TIM_BDTR_MOE_Msk          (0x1UL << TIM_BDTR_MOE_Pos)                  /*!< 0x00008000 */
N#define TIM_BDTR_MOE              TIM_BDTR_MOE_Msk                             /*!<Main Output enable */
N
N#define TIM_BDTR_BKF_Pos          (16U)
N#define TIM_BDTR_BKF_Msk          (0xFUL << TIM_BDTR_BKF_Pos)                  /*!< 0x000F0000 */
N#define TIM_BDTR_BKF              TIM_BDTR_BKF_Msk                             /*!<Break Filter for Break 1 */
N#define TIM_BDTR_BK2F_Pos         (20U)
N#define TIM_BDTR_BK2F_Msk         (0xFUL << TIM_BDTR_BK2F_Pos)                 /*!< 0x00F00000 */
N#define TIM_BDTR_BK2F             TIM_BDTR_BK2F_Msk                            /*!<Break Filter for Break 2 */
N
N#define TIM_BDTR_BK2E_Pos         (24U)
N#define TIM_BDTR_BK2E_Msk         (0x1UL << TIM_BDTR_BK2E_Pos)                 /*!< 0x01000000 */
N#define TIM_BDTR_BK2E             TIM_BDTR_BK2E_Msk                            /*!<Break enable for Break 2 */
N#define TIM_BDTR_BK2P_Pos         (25U)
N#define TIM_BDTR_BK2P_Msk         (0x1UL << TIM_BDTR_BK2P_Pos)                 /*!< 0x02000000 */
N#define TIM_BDTR_BK2P             TIM_BDTR_BK2P_Msk                            /*!<Break Polarity for Break 2 */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define TIM_DCR_DBA_Pos           (0U)
N#define TIM_DCR_DBA_Msk           (0x1FUL << TIM_DCR_DBA_Pos)                  /*!< 0x0000001F */
N#define TIM_DCR_DBA               TIM_DCR_DBA_Msk                              /*!<DBA[4:0] bits (DMA Base Address) */
N#define TIM_DCR_DBA_0             (0x01UL << TIM_DCR_DBA_Pos)                  /*!< 0x00000001 */
N#define TIM_DCR_DBA_1             (0x02UL << TIM_DCR_DBA_Pos)                  /*!< 0x00000002 */
N#define TIM_DCR_DBA_2             (0x04UL << TIM_DCR_DBA_Pos)                  /*!< 0x00000004 */
N#define TIM_DCR_DBA_3             (0x08UL << TIM_DCR_DBA_Pos)                  /*!< 0x00000008 */
N#define TIM_DCR_DBA_4             (0x10UL << TIM_DCR_DBA_Pos)                  /*!< 0x00000010 */
N
N#define TIM_DCR_DBL_Pos           (8U)
N#define TIM_DCR_DBL_Msk           (0x1FUL << TIM_DCR_DBL_Pos)                  /*!< 0x00001F00 */
N#define TIM_DCR_DBL               TIM_DCR_DBL_Msk                              /*!<DBL[4:0] bits (DMA Burst Length) */
N#define TIM_DCR_DBL_0             (0x01UL << TIM_DCR_DBL_Pos)                  /*!< 0x00000100 */
N#define TIM_DCR_DBL_1             (0x02UL << TIM_DCR_DBL_Pos)                  /*!< 0x00000200 */
N#define TIM_DCR_DBL_2             (0x04UL << TIM_DCR_DBL_Pos)                  /*!< 0x00000400 */
N#define TIM_DCR_DBL_3             (0x08UL << TIM_DCR_DBL_Pos)                  /*!< 0x00000800 */
N#define TIM_DCR_DBL_4             (0x10UL << TIM_DCR_DBL_Pos)                  /*!< 0x00001000 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define TIM_DMAR_DMAB_Pos         (0U)
N#define TIM_DMAR_DMAB_Msk         (0xFFFFUL << TIM_DMAR_DMAB_Pos)              /*!< 0x0000FFFF */
N#define TIM_DMAR_DMAB             TIM_DMAR_DMAB_Msk                            /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM1_OR1 register  *******************/
N#define TIM1_OR1_ETR_ADC1_RMP_Pos      (0U)
N#define TIM1_OR1_ETR_ADC1_RMP_Msk      (0x3UL << TIM1_OR1_ETR_ADC1_RMP_Pos)    /*!< 0x00000003 */
N#define TIM1_OR1_ETR_ADC1_RMP          TIM1_OR1_ETR_ADC1_RMP_Msk               /*!<ETR_ADC1_RMP[1:0] bits (TIM1 ETR remap on ADC1) */
N#define TIM1_OR1_ETR_ADC1_RMP_0        (0x1UL << TIM1_OR1_ETR_ADC1_RMP_Pos)    /*!< 0x00000001 */
N#define TIM1_OR1_ETR_ADC1_RMP_1        (0x2UL << TIM1_OR1_ETR_ADC1_RMP_Pos)    /*!< 0x00000002 */
N
N#define TIM1_OR1_TI1_RMP_Pos           (4U)
N#define TIM1_OR1_TI1_RMP_Msk           (0x1UL << TIM1_OR1_TI1_RMP_Pos)         /*!< 0x00000010 */
N#define TIM1_OR1_TI1_RMP               TIM1_OR1_TI1_RMP_Msk                    /*!<TIM1 Input Capture 1 remap */
N
N/*******************  Bit definition for TIM1_OR2 register  *******************/
N#define TIM1_OR2_BKINE_Pos             (0U)
N#define TIM1_OR2_BKINE_Msk             (0x1UL << TIM1_OR2_BKINE_Pos)           /*!< 0x00000001 */
N#define TIM1_OR2_BKINE                 TIM1_OR2_BKINE_Msk                      /*!<BRK BKIN input enable */
N#define TIM1_OR2_BKCMP1E_Pos           (1U)
N#define TIM1_OR2_BKCMP1E_Msk           (0x1UL << TIM1_OR2_BKCMP1E_Pos)         /*!< 0x00000002 */
N#define TIM1_OR2_BKCMP1E               TIM1_OR2_BKCMP1E_Msk                    /*!<BRK COMP1 enable */
N#define TIM1_OR2_BKCMP2E_Pos           (2U)
N#define TIM1_OR2_BKCMP2E_Msk           (0x1UL << TIM1_OR2_BKCMP2E_Pos)         /*!< 0x00000004 */
N#define TIM1_OR2_BKCMP2E               TIM1_OR2_BKCMP2E_Msk                    /*!<BRK COMP2 enable */
N#define TIM1_OR2_BKINP_Pos             (9U)
N#define TIM1_OR2_BKINP_Msk             (0x1UL << TIM1_OR2_BKINP_Pos)           /*!< 0x00000200 */
N#define TIM1_OR2_BKINP                 TIM1_OR2_BKINP_Msk                      /*!<BRK BKIN input polarity */
N#define TIM1_OR2_BKCMP1P_Pos           (10U)
N#define TIM1_OR2_BKCMP1P_Msk           (0x1UL << TIM1_OR2_BKCMP1P_Pos)         /*!< 0x00000400 */
N#define TIM1_OR2_BKCMP1P               TIM1_OR2_BKCMP1P_Msk                    /*!<BRK COMP1 input polarity */
N#define TIM1_OR2_BKCMP2P_Pos           (11U)
N#define TIM1_OR2_BKCMP2P_Msk           (0x1UL << TIM1_OR2_BKCMP2P_Pos)         /*!< 0x00000800 */
N#define TIM1_OR2_BKCMP2P               TIM1_OR2_BKCMP2P_Msk                    /*!<BRK COMP2 input polarity */
N
N#define TIM1_OR2_ETRSEL_Pos            (14U)
N#define TIM1_OR2_ETRSEL_Msk            (0x7UL << TIM1_OR2_ETRSEL_Pos)          /*!< 0x0001C000 */
N#define TIM1_OR2_ETRSEL                TIM1_OR2_ETRSEL_Msk                     /*!<ETRSEL[2:0] bits (TIM1 ETR source selection) */
N#define TIM1_OR2_ETRSEL_0              (0x1UL << TIM1_OR2_ETRSEL_Pos)          /*!< 0x00004000 */
N#define TIM1_OR2_ETRSEL_1              (0x2UL << TIM1_OR2_ETRSEL_Pos)          /*!< 0x00008000 */
N#define TIM1_OR2_ETRSEL_2              (0x4UL << TIM1_OR2_ETRSEL_Pos)          /*!< 0x00010000 */
N
N/*******************  Bit definition for TIM1_OR3 register  *******************/
N#define TIM1_OR3_BK2INE_Pos            (0U)
N#define TIM1_OR3_BK2INE_Msk            (0x1UL << TIM1_OR3_BK2INE_Pos)          /*!< 0x00000001 */
N#define TIM1_OR3_BK2INE                TIM1_OR3_BK2INE_Msk                     /*!<BRK2 BKIN2 input enable */
N#define TIM1_OR3_BK2CMP1E_Pos          (1U)
N#define TIM1_OR3_BK2CMP1E_Msk          (0x1UL << TIM1_OR3_BK2CMP1E_Pos)        /*!< 0x00000002 */
N#define TIM1_OR3_BK2CMP1E              TIM1_OR3_BK2CMP1E_Msk                   /*!<BRK2 COMP1 enable */
N#define TIM1_OR3_BK2CMP2E_Pos          (2U)
N#define TIM1_OR3_BK2CMP2E_Msk          (0x1UL << TIM1_OR3_BK2CMP2E_Pos)        /*!< 0x00000004 */
N#define TIM1_OR3_BK2CMP2E              TIM1_OR3_BK2CMP2E_Msk                   /*!<BRK2 COMP2 enable */
N#define TIM1_OR3_BK2INP_Pos            (9U)
N#define TIM1_OR3_BK2INP_Msk            (0x1UL << TIM1_OR3_BK2INP_Pos)          /*!< 0x00000200 */
N#define TIM1_OR3_BK2INP                TIM1_OR3_BK2INP_Msk                     /*!<BRK2 BKIN2 input polarity */
N#define TIM1_OR3_BK2CMP1P_Pos          (10U)
N#define TIM1_OR3_BK2CMP1P_Msk          (0x1UL << TIM1_OR3_BK2CMP1P_Pos)        /*!< 0x00000400 */
N#define TIM1_OR3_BK2CMP1P              TIM1_OR3_BK2CMP1P_Msk                   /*!<BRK2 COMP1 input polarity */
N#define TIM1_OR3_BK2CMP2P_Pos          (11U)
N#define TIM1_OR3_BK2CMP2P_Msk          (0x1UL << TIM1_OR3_BK2CMP2P_Pos)        /*!< 0x00000800 */
N#define TIM1_OR3_BK2CMP2P              TIM1_OR3_BK2CMP2P_Msk                   /*!<BRK2 COMP2 input polarity */
N
N
N/*******************  Bit definition for TIM2_OR1 register  *******************/
N#define TIM2_OR1_ITR1_RMP_Pos     (0U)
N#define TIM2_OR1_ITR1_RMP_Msk     (0x1UL << TIM2_OR1_ITR1_RMP_Pos)             /*!< 0x00000001 */
N#define TIM2_OR1_ITR1_RMP         TIM2_OR1_ITR1_RMP_Msk                        /*!<TIM2 Internal trigger 1 remap */
N#define TIM2_OR1_ETR1_RMP_Pos     (1U)
N#define TIM2_OR1_ETR1_RMP_Msk     (0x1UL << TIM2_OR1_ETR1_RMP_Pos)             /*!< 0x00000002 */
N#define TIM2_OR1_ETR1_RMP         TIM2_OR1_ETR1_RMP_Msk                        /*!<TIM2 External trigger 1 remap */
N
N#define TIM2_OR1_TI4_RMP_Pos      (2U)
N#define TIM2_OR1_TI4_RMP_Msk      (0x3UL << TIM2_OR1_TI4_RMP_Pos)              /*!< 0x0000000C */
N#define TIM2_OR1_TI4_RMP          TIM2_OR1_TI4_RMP_Msk                         /*!<TI4_RMP[1:0] bits (TIM2 Input Capture 4 remap) */
N#define TIM2_OR1_TI4_RMP_0        (0x1UL << TIM2_OR1_TI4_RMP_Pos)              /*!< 0x00000004 */
N#define TIM2_OR1_TI4_RMP_1        (0x2UL << TIM2_OR1_TI4_RMP_Pos)              /*!< 0x00000008 */
N
N/*******************  Bit definition for TIM2_OR2 register  *******************/
N#define TIM2_OR2_ETRSEL_Pos       (14U)
N#define TIM2_OR2_ETRSEL_Msk       (0x7UL << TIM2_OR2_ETRSEL_Pos)               /*!< 0x0001C000 */
N#define TIM2_OR2_ETRSEL           TIM2_OR2_ETRSEL_Msk                          /*!<ETRSEL[2:0] bits (TIM2 ETR source selection) */
N#define TIM2_OR2_ETRSEL_0         (0x1UL << TIM2_OR2_ETRSEL_Pos)               /*!< 0x00004000 */
N#define TIM2_OR2_ETRSEL_1         (0x2UL << TIM2_OR2_ETRSEL_Pos)               /*!< 0x00008000 */
N#define TIM2_OR2_ETRSEL_2         (0x4UL << TIM2_OR2_ETRSEL_Pos)               /*!< 0x00010000 */
N
N
N/*******************  Bit definition for TIM15_OR1 register  ******************/
N#define TIM15_OR1_TI1_RMP_Pos           (0U)
N#define TIM15_OR1_TI1_RMP_Msk           (0x1UL << TIM15_OR1_TI1_RMP_Pos)       /*!< 0x00000001 */
N#define TIM15_OR1_TI1_RMP               TIM15_OR1_TI1_RMP_Msk                  /*!<TIM15 Input Capture 1 remap */
N
N#define TIM15_OR1_ENCODER_MODE_Pos      (1U)
N#define TIM15_OR1_ENCODER_MODE_Msk      (0x3UL << TIM15_OR1_ENCODER_MODE_Pos)  /*!< 0x00000006 */
N#define TIM15_OR1_ENCODER_MODE          TIM15_OR1_ENCODER_MODE_Msk             /*!<ENCODER_MODE[1:0] bits (TIM15 Encoder mode) */
N#define TIM15_OR1_ENCODER_MODE_0        (0x1UL << TIM15_OR1_ENCODER_MODE_Pos)  /*!< 0x00000002 */
N#define TIM15_OR1_ENCODER_MODE_1        (0x2UL << TIM15_OR1_ENCODER_MODE_Pos)  /*!< 0x00000004 */
N
N/*******************  Bit definition for TIM15_OR2 register  ******************/
N#define TIM15_OR2_BKINE_Pos             (0U)
N#define TIM15_OR2_BKINE_Msk             (0x1UL << TIM15_OR2_BKINE_Pos)         /*!< 0x00000001 */
N#define TIM15_OR2_BKINE                 TIM15_OR2_BKINE_Msk                    /*!<BRK BKIN input enable */
N#define TIM15_OR2_BKCMP1E_Pos           (1U)
N#define TIM15_OR2_BKCMP1E_Msk           (0x1UL << TIM15_OR2_BKCMP1E_Pos)       /*!< 0x00000002 */
N#define TIM15_OR2_BKCMP1E               TIM15_OR2_BKCMP1E_Msk                  /*!<BRK COMP1 enable */
N#define TIM15_OR2_BKCMP2E_Pos           (2U)
N#define TIM15_OR2_BKCMP2E_Msk           (0x1UL << TIM15_OR2_BKCMP2E_Pos)       /*!< 0x00000004 */
N#define TIM15_OR2_BKCMP2E               TIM15_OR2_BKCMP2E_Msk                  /*!<BRK COMP2 enable */
N#define TIM15_OR2_BKINP_Pos             (9U)
N#define TIM15_OR2_BKINP_Msk             (0x1UL << TIM15_OR2_BKINP_Pos)         /*!< 0x00000200 */
N#define TIM15_OR2_BKINP                 TIM15_OR2_BKINP_Msk                    /*!<BRK BKIN input polarity */
N#define TIM15_OR2_BKCMP1P_Pos           (10U)
N#define TIM15_OR2_BKCMP1P_Msk           (0x1UL << TIM15_OR2_BKCMP1P_Pos)       /*!< 0x00000400 */
N#define TIM15_OR2_BKCMP1P               TIM15_OR2_BKCMP1P_Msk                  /*!<BRK COMP1 input polarity */
N#define TIM15_OR2_BKCMP2P_Pos           (11U)
N#define TIM15_OR2_BKCMP2P_Msk           (0x1UL << TIM15_OR2_BKCMP2P_Pos)       /*!< 0x00000800 */
N#define TIM15_OR2_BKCMP2P               TIM15_OR2_BKCMP2P_Msk                  /*!<BRK COMP2 input polarity */
N
N/*******************  Bit definition for TIM16_OR1 register  ******************/
N#define TIM16_OR1_TI1_RMP_Pos      (0U)
N#define TIM16_OR1_TI1_RMP_Msk      (0x7UL << TIM16_OR1_TI1_RMP_Pos)            /*!< 0x00000007 */
N#define TIM16_OR1_TI1_RMP          TIM16_OR1_TI1_RMP_Msk                       /*!<TI1_RMP[2:0] bits (TIM16 Input Capture 1 remap) */
N#define TIM16_OR1_TI1_RMP_0        (0x1UL << TIM16_OR1_TI1_RMP_Pos)            /*!< 0x00000001 */
N#define TIM16_OR1_TI1_RMP_1        (0x2UL << TIM16_OR1_TI1_RMP_Pos)            /*!< 0x00000002 */
N#define TIM16_OR1_TI1_RMP_2        (0x4UL << TIM16_OR1_TI1_RMP_Pos)            /*!< 0x00000004 */
N
N/*******************  Bit definition for TIM16_OR2 register  ******************/
N#define TIM16_OR2_BKINE_Pos        (0U)
N#define TIM16_OR2_BKINE_Msk        (0x1UL << TIM16_OR2_BKINE_Pos)              /*!< 0x00000001 */
N#define TIM16_OR2_BKINE            TIM16_OR2_BKINE_Msk                         /*!<BRK BKIN input enable */
N#define TIM16_OR2_BKCMP1E_Pos      (1U)
N#define TIM16_OR2_BKCMP1E_Msk      (0x1UL << TIM16_OR2_BKCMP1E_Pos)            /*!< 0x00000002 */
N#define TIM16_OR2_BKCMP1E          TIM16_OR2_BKCMP1E_Msk                       /*!<BRK COMP1 enable */
N#define TIM16_OR2_BKCMP2E_Pos      (2U)
N#define TIM16_OR2_BKCMP2E_Msk      (0x1UL << TIM16_OR2_BKCMP2E_Pos)            /*!< 0x00000004 */
N#define TIM16_OR2_BKCMP2E          TIM16_OR2_BKCMP2E_Msk                       /*!<BRK COMP2 enable */
N#define TIM16_OR2_BKINP_Pos        (9U)
N#define TIM16_OR2_BKINP_Msk        (0x1UL << TIM16_OR2_BKINP_Pos)              /*!< 0x00000200 */
N#define TIM16_OR2_BKINP            TIM16_OR2_BKINP_Msk                         /*!<BRK BKIN input polarity */
N#define TIM16_OR2_BKCMP1P_Pos      (10U)
N#define TIM16_OR2_BKCMP1P_Msk      (0x1UL << TIM16_OR2_BKCMP1P_Pos)            /*!< 0x00000400 */
N#define TIM16_OR2_BKCMP1P          TIM16_OR2_BKCMP1P_Msk                       /*!<BRK COMP1 input polarity */
N#define TIM16_OR2_BKCMP2P_Pos      (11U)
N#define TIM16_OR2_BKCMP2P_Msk      (0x1UL << TIM16_OR2_BKCMP2P_Pos)            /*!< 0x00000800 */
N#define TIM16_OR2_BKCMP2P          TIM16_OR2_BKCMP2P_Msk                       /*!<BRK COMP2 input polarity */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Low Power Timer (LPTTIM)                           */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for LPTIM_ISR register  *******************/
N#define LPTIM_ISR_CMPM_Pos          (0U)
N#define LPTIM_ISR_CMPM_Msk          (0x1UL << LPTIM_ISR_CMPM_Pos)              /*!< 0x00000001 */
N#define LPTIM_ISR_CMPM              LPTIM_ISR_CMPM_Msk                         /*!< Compare match */
N#define LPTIM_ISR_ARRM_Pos          (1U)
N#define LPTIM_ISR_ARRM_Msk          (0x1UL << LPTIM_ISR_ARRM_Pos)              /*!< 0x00000002 */
N#define LPTIM_ISR_ARRM              LPTIM_ISR_ARRM_Msk                         /*!< Autoreload match */
N#define LPTIM_ISR_EXTTRIG_Pos       (2U)
N#define LPTIM_ISR_EXTTRIG_Msk       (0x1UL << LPTIM_ISR_EXTTRIG_Pos)           /*!< 0x00000004 */
N#define LPTIM_ISR_EXTTRIG           LPTIM_ISR_EXTTRIG_Msk                      /*!< External trigger edge event */
N#define LPTIM_ISR_CMPOK_Pos         (3U)
N#define LPTIM_ISR_CMPOK_Msk         (0x1UL << LPTIM_ISR_CMPOK_Pos)             /*!< 0x00000008 */
N#define LPTIM_ISR_CMPOK             LPTIM_ISR_CMPOK_Msk                        /*!< Compare register update OK */
N#define LPTIM_ISR_ARROK_Pos         (4U)
N#define LPTIM_ISR_ARROK_Msk         (0x1UL << LPTIM_ISR_ARROK_Pos)             /*!< 0x00000010 */
N#define LPTIM_ISR_ARROK             LPTIM_ISR_ARROK_Msk                        /*!< Autoreload register update OK */
N#define LPTIM_ISR_UP_Pos            (5U)
N#define LPTIM_ISR_UP_Msk            (0x1UL << LPTIM_ISR_UP_Pos)                /*!< 0x00000020 */
N#define LPTIM_ISR_UP                LPTIM_ISR_UP_Msk                           /*!< Counter direction change down to up */
N#define LPTIM_ISR_DOWN_Pos          (6U)
N#define LPTIM_ISR_DOWN_Msk          (0x1UL << LPTIM_ISR_DOWN_Pos)              /*!< 0x00000040 */
N#define LPTIM_ISR_DOWN              LPTIM_ISR_DOWN_Msk                         /*!< Counter direction change up to down */
N
N/******************  Bit definition for LPTIM_ICR register  *******************/
N#define LPTIM_ICR_CMPMCF_Pos        (0U)
N#define LPTIM_ICR_CMPMCF_Msk        (0x1UL << LPTIM_ICR_CMPMCF_Pos)            /*!< 0x00000001 */
N#define LPTIM_ICR_CMPMCF            LPTIM_ICR_CMPMCF_Msk                       /*!< Compare match Clear Flag */
N#define LPTIM_ICR_ARRMCF_Pos        (1U)
N#define LPTIM_ICR_ARRMCF_Msk        (0x1UL << LPTIM_ICR_ARRMCF_Pos)            /*!< 0x00000002 */
N#define LPTIM_ICR_ARRMCF            LPTIM_ICR_ARRMCF_Msk                       /*!< Autoreload match Clear Flag */
N#define LPTIM_ICR_EXTTRIGCF_Pos     (2U)
N#define LPTIM_ICR_EXTTRIGCF_Msk     (0x1UL << LPTIM_ICR_EXTTRIGCF_Pos)         /*!< 0x00000004 */
N#define LPTIM_ICR_EXTTRIGCF         LPTIM_ICR_EXTTRIGCF_Msk                    /*!< External trigger edge event Clear Flag */
N#define LPTIM_ICR_CMPOKCF_Pos       (3U)
N#define LPTIM_ICR_CMPOKCF_Msk       (0x1UL << LPTIM_ICR_CMPOKCF_Pos)           /*!< 0x00000008 */
N#define LPTIM_ICR_CMPOKCF           LPTIM_ICR_CMPOKCF_Msk                      /*!< Compare register update OK Clear Flag */
N#define LPTIM_ICR_ARROKCF_Pos       (4U)
N#define LPTIM_ICR_ARROKCF_Msk       (0x1UL << LPTIM_ICR_ARROKCF_Pos)           /*!< 0x00000010 */
N#define LPTIM_ICR_ARROKCF           LPTIM_ICR_ARROKCF_Msk                      /*!< Autoreload register update OK Clear Flag */
N#define LPTIM_ICR_UPCF_Pos          (5U)
N#define LPTIM_ICR_UPCF_Msk          (0x1UL << LPTIM_ICR_UPCF_Pos)              /*!< 0x00000020 */
N#define LPTIM_ICR_UPCF              LPTIM_ICR_UPCF_Msk                         /*!< Counter direction change down to up Clear Flag */
N#define LPTIM_ICR_DOWNCF_Pos        (6U)
N#define LPTIM_ICR_DOWNCF_Msk        (0x1UL << LPTIM_ICR_DOWNCF_Pos)            /*!< 0x00000040 */
N#define LPTIM_ICR_DOWNCF            LPTIM_ICR_DOWNCF_Msk                       /*!< Counter direction change up to down Clear Flag */
N
N/******************  Bit definition for LPTIM_IER register ********************/
N#define LPTIM_IER_CMPMIE_Pos        (0U)
N#define LPTIM_IER_CMPMIE_Msk        (0x1UL << LPTIM_IER_CMPMIE_Pos)            /*!< 0x00000001 */
N#define LPTIM_IER_CMPMIE            LPTIM_IER_CMPMIE_Msk                       /*!< Compare match Interrupt Enable */
N#define LPTIM_IER_ARRMIE_Pos        (1U)
N#define LPTIM_IER_ARRMIE_Msk        (0x1UL << LPTIM_IER_ARRMIE_Pos)            /*!< 0x00000002 */
N#define LPTIM_IER_ARRMIE            LPTIM_IER_ARRMIE_Msk                       /*!< Autoreload match Interrupt Enable */
N#define LPTIM_IER_EXTTRIGIE_Pos     (2U)
N#define LPTIM_IER_EXTTRIGIE_Msk     (0x1UL << LPTIM_IER_EXTTRIGIE_Pos)         /*!< 0x00000004 */
N#define LPTIM_IER_EXTTRIGIE         LPTIM_IER_EXTTRIGIE_Msk                    /*!< External trigger edge event Interrupt Enable */
N#define LPTIM_IER_CMPOKIE_Pos       (3U)
N#define LPTIM_IER_CMPOKIE_Msk       (0x1UL << LPTIM_IER_CMPOKIE_Pos)           /*!< 0x00000008 */
N#define LPTIM_IER_CMPOKIE           LPTIM_IER_CMPOKIE_Msk                      /*!< Compare register update OK Interrupt Enable */
N#define LPTIM_IER_ARROKIE_Pos       (4U)
N#define LPTIM_IER_ARROKIE_Msk       (0x1UL << LPTIM_IER_ARROKIE_Pos)           /*!< 0x00000010 */
N#define LPTIM_IER_ARROKIE           LPTIM_IER_ARROKIE_Msk                      /*!< Autoreload register update OK Interrupt Enable */
N#define LPTIM_IER_UPIE_Pos          (5U)
N#define LPTIM_IER_UPIE_Msk          (0x1UL << LPTIM_IER_UPIE_Pos)              /*!< 0x00000020 */
N#define LPTIM_IER_UPIE              LPTIM_IER_UPIE_Msk                         /*!< Counter direction change down to up Interrupt Enable */
N#define LPTIM_IER_DOWNIE_Pos        (6U)
N#define LPTIM_IER_DOWNIE_Msk        (0x1UL << LPTIM_IER_DOWNIE_Pos)            /*!< 0x00000040 */
N#define LPTIM_IER_DOWNIE            LPTIM_IER_DOWNIE_Msk                       /*!< Counter direction change up to down Interrupt Enable */
N
N/******************  Bit definition for LPTIM_CFGR register *******************/
N#define LPTIM_CFGR_CKSEL_Pos        (0U)
N#define LPTIM_CFGR_CKSEL_Msk        (0x1UL << LPTIM_CFGR_CKSEL_Pos)            /*!< 0x00000001 */
N#define LPTIM_CFGR_CKSEL            LPTIM_CFGR_CKSEL_Msk                       /*!< Clock selector */
N
N#define LPTIM_CFGR_CKPOL_Pos        (1U)
N#define LPTIM_CFGR_CKPOL_Msk        (0x3UL << LPTIM_CFGR_CKPOL_Pos)            /*!< 0x00000006 */
N#define LPTIM_CFGR_CKPOL            LPTIM_CFGR_CKPOL_Msk                       /*!< CKPOL[1:0] bits (Clock polarity) */
N#define LPTIM_CFGR_CKPOL_0          (0x1UL << LPTIM_CFGR_CKPOL_Pos)            /*!< 0x00000002 */
N#define LPTIM_CFGR_CKPOL_1          (0x2UL << LPTIM_CFGR_CKPOL_Pos)            /*!< 0x00000004 */
N
N#define LPTIM_CFGR_CKFLT_Pos        (3U)
N#define LPTIM_CFGR_CKFLT_Msk        (0x3UL << LPTIM_CFGR_CKFLT_Pos)            /*!< 0x00000018 */
N#define LPTIM_CFGR_CKFLT            LPTIM_CFGR_CKFLT_Msk                       /*!< CKFLT[1:0] bits (Configurable digital filter for external clock) */
N#define LPTIM_CFGR_CKFLT_0          (0x1UL << LPTIM_CFGR_CKFLT_Pos)            /*!< 0x00000008 */
N#define LPTIM_CFGR_CKFLT_1          (0x2UL << LPTIM_CFGR_CKFLT_Pos)            /*!< 0x00000010 */
N
N#define LPTIM_CFGR_TRGFLT_Pos       (6U)
N#define LPTIM_CFGR_TRGFLT_Msk       (0x3UL << LPTIM_CFGR_TRGFLT_Pos)           /*!< 0x000000C0 */
N#define LPTIM_CFGR_TRGFLT           LPTIM_CFGR_TRGFLT_Msk                      /*!< TRGFLT[1:0] bits (Configurable digital filter for trigger) */
N#define LPTIM_CFGR_TRGFLT_0         (0x1UL << LPTIM_CFGR_TRGFLT_Pos)           /*!< 0x00000040 */
N#define LPTIM_CFGR_TRGFLT_1         (0x2UL << LPTIM_CFGR_TRGFLT_Pos)           /*!< 0x00000080 */
N
N#define LPTIM_CFGR_PRESC_Pos        (9U)
N#define LPTIM_CFGR_PRESC_Msk        (0x7UL << LPTIM_CFGR_PRESC_Pos)            /*!< 0x00000E00 */
N#define LPTIM_CFGR_PRESC            LPTIM_CFGR_PRESC_Msk                       /*!< PRESC[2:0] bits (Clock prescaler) */
N#define LPTIM_CFGR_PRESC_0          (0x1UL << LPTIM_CFGR_PRESC_Pos)            /*!< 0x00000200 */
N#define LPTIM_CFGR_PRESC_1          (0x2UL << LPTIM_CFGR_PRESC_Pos)            /*!< 0x00000400 */
N#define LPTIM_CFGR_PRESC_2          (0x4UL << LPTIM_CFGR_PRESC_Pos)            /*!< 0x00000800 */
N
N#define LPTIM_CFGR_TRIGSEL_Pos      (13U)
N#define LPTIM_CFGR_TRIGSEL_Msk      (0x7UL << LPTIM_CFGR_TRIGSEL_Pos)          /*!< 0x0000E000 */
N#define LPTIM_CFGR_TRIGSEL          LPTIM_CFGR_TRIGSEL_Msk                     /*!< TRIGSEL[2:0]] bits (Trigger selector) */
N#define LPTIM_CFGR_TRIGSEL_0        (0x1UL << LPTIM_CFGR_TRIGSEL_Pos)          /*!< 0x00002000 */
N#define LPTIM_CFGR_TRIGSEL_1        (0x2UL << LPTIM_CFGR_TRIGSEL_Pos)          /*!< 0x00004000 */
N#define LPTIM_CFGR_TRIGSEL_2        (0x4UL << LPTIM_CFGR_TRIGSEL_Pos)          /*!< 0x00008000 */
N
N#define LPTIM_CFGR_TRIGEN_Pos       (17U)
N#define LPTIM_CFGR_TRIGEN_Msk       (0x3UL << LPTIM_CFGR_TRIGEN_Pos)           /*!< 0x00060000 */
N#define LPTIM_CFGR_TRIGEN           LPTIM_CFGR_TRIGEN_Msk                      /*!< TRIGEN[1:0] bits (Trigger enable and polarity) */
N#define LPTIM_CFGR_TRIGEN_0         (0x1UL << LPTIM_CFGR_TRIGEN_Pos)           /*!< 0x00020000 */
N#define LPTIM_CFGR_TRIGEN_1         (0x2UL << LPTIM_CFGR_TRIGEN_Pos)           /*!< 0x00040000 */
N
N#define LPTIM_CFGR_TIMOUT_Pos       (19U)
N#define LPTIM_CFGR_TIMOUT_Msk       (0x1UL << LPTIM_CFGR_TIMOUT_Pos)           /*!< 0x00080000 */
N#define LPTIM_CFGR_TIMOUT           LPTIM_CFGR_TIMOUT_Msk                      /*!< Timout enable */
N#define LPTIM_CFGR_WAVE_Pos         (20U)
N#define LPTIM_CFGR_WAVE_Msk         (0x1UL << LPTIM_CFGR_WAVE_Pos)             /*!< 0x00100000 */
N#define LPTIM_CFGR_WAVE             LPTIM_CFGR_WAVE_Msk                        /*!< Waveform shape */
N#define LPTIM_CFGR_WAVPOL_Pos       (21U)
N#define LPTIM_CFGR_WAVPOL_Msk       (0x1UL << LPTIM_CFGR_WAVPOL_Pos)           /*!< 0x00200000 */
N#define LPTIM_CFGR_WAVPOL           LPTIM_CFGR_WAVPOL_Msk                      /*!< Waveform shape polarity */
N#define LPTIM_CFGR_PRELOAD_Pos      (22U)
N#define LPTIM_CFGR_PRELOAD_Msk      (0x1UL << LPTIM_CFGR_PRELOAD_Pos)          /*!< 0x00400000 */
N#define LPTIM_CFGR_PRELOAD          LPTIM_CFGR_PRELOAD_Msk                     /*!< Reg update mode */
N#define LPTIM_CFGR_COUNTMODE_Pos    (23U)
N#define LPTIM_CFGR_COUNTMODE_Msk    (0x1UL << LPTIM_CFGR_COUNTMODE_Pos)        /*!< 0x00800000 */
N#define LPTIM_CFGR_COUNTMODE        LPTIM_CFGR_COUNTMODE_Msk                   /*!< Counter mode enable */
N#define LPTIM_CFGR_ENC_Pos          (24U)
N#define LPTIM_CFGR_ENC_Msk          (0x1UL << LPTIM_CFGR_ENC_Pos)              /*!< 0x01000000 */
N#define LPTIM_CFGR_ENC              LPTIM_CFGR_ENC_Msk                         /*!< Encoder mode enable */
N
N/******************  Bit definition for LPTIM_CR register  ********************/
N#define LPTIM_CR_ENABLE_Pos         (0U)
N#define LPTIM_CR_ENABLE_Msk         (0x1UL << LPTIM_CR_ENABLE_Pos)             /*!< 0x00000001 */
N#define LPTIM_CR_ENABLE             LPTIM_CR_ENABLE_Msk                        /*!< LPTIMer enable */
N#define LPTIM_CR_SNGSTRT_Pos        (1U)
N#define LPTIM_CR_SNGSTRT_Msk        (0x1UL << LPTIM_CR_SNGSTRT_Pos)            /*!< 0x00000002 */
N#define LPTIM_CR_SNGSTRT            LPTIM_CR_SNGSTRT_Msk                       /*!< Timer start in single mode */
N#define LPTIM_CR_CNTSTRT_Pos        (2U)
N#define LPTIM_CR_CNTSTRT_Msk        (0x1UL << LPTIM_CR_CNTSTRT_Pos)            /*!< 0x00000004 */
N#define LPTIM_CR_CNTSTRT            LPTIM_CR_CNTSTRT_Msk                       /*!< Timer start in continuous mode */
N
N/******************  Bit definition for LPTIM_CMP register  *******************/
N#define LPTIM_CMP_CMP_Pos           (0U)
N#define LPTIM_CMP_CMP_Msk           (0xFFFFUL << LPTIM_CMP_CMP_Pos)            /*!< 0x0000FFFF */
N#define LPTIM_CMP_CMP               LPTIM_CMP_CMP_Msk                          /*!< Compare register */
N
N/******************  Bit definition for LPTIM_ARR register  *******************/
N#define LPTIM_ARR_ARR_Pos           (0U)
N#define LPTIM_ARR_ARR_Msk           (0xFFFFUL << LPTIM_ARR_ARR_Pos)            /*!< 0x0000FFFF */
N#define LPTIM_ARR_ARR               LPTIM_ARR_ARR_Msk                          /*!< Auto reload register */
N
N/******************  Bit definition for LPTIM_CNT register  *******************/
N#define LPTIM_CNT_CNT_Pos           (0U)
N#define LPTIM_CNT_CNT_Msk           (0xFFFFUL << LPTIM_CNT_CNT_Pos)            /*!< 0x0000FFFF */
N#define LPTIM_CNT_CNT               LPTIM_CNT_CNT_Msk                          /*!< Counter register */
N
N/******************  Bit definition for LPTIM_OR register  ********************/
N#define LPTIM_OR_OR_Pos             (0U)
N#define LPTIM_OR_OR_Msk             (0x3UL << LPTIM_OR_OR_Pos)                 /*!< 0x00000003 */
N#define LPTIM_OR_OR                 LPTIM_OR_OR_Msk                            /*!< OR[1:0] bits (Remap selection) */
N#define LPTIM_OR_OR_0               (0x1UL << LPTIM_OR_OR_Pos)                 /*!< 0x00000001 */
N#define LPTIM_OR_OR_1               (0x2UL << LPTIM_OR_OR_Pos)                 /*!< 0x00000002 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog Comparators (COMP)                             */
N/*                                                                            */
N/******************************************************************************/
N/**********************  Bit definition for COMP_CSR register  ****************/
N#define COMP_CSR_EN_Pos            (0U)
N#define COMP_CSR_EN_Msk            (0x1UL << COMP_CSR_EN_Pos)                  /*!< 0x00000001 */
N#define COMP_CSR_EN                COMP_CSR_EN_Msk                             /*!< Comparator enable */
N
N#define COMP_CSR_PWRMODE_Pos       (2U)
N#define COMP_CSR_PWRMODE_Msk       (0x3UL << COMP_CSR_PWRMODE_Pos)             /*!< 0x0000000C */
N#define COMP_CSR_PWRMODE           COMP_CSR_PWRMODE_Msk                        /*!< Comparator power mode */
N#define COMP_CSR_PWRMODE_0         (0x1UL << COMP_CSR_PWRMODE_Pos)             /*!< 0x00000004 */
N#define COMP_CSR_PWRMODE_1         (0x2UL << COMP_CSR_PWRMODE_Pos)             /*!< 0x00000008 */
N
N#define COMP_CSR_INMSEL_Pos        (4U)
N#define COMP_CSR_INMSEL_Msk        (0x7UL << COMP_CSR_INMSEL_Pos)              /*!< 0x00000070 */
N#define COMP_CSR_INMSEL            COMP_CSR_INMSEL_Msk                         /*!< Comparator input minus selection */
N#define COMP_CSR_INMSEL_0          (0x1UL << COMP_CSR_INMSEL_Pos)              /*!< 0x00000010 */
N#define COMP_CSR_INMSEL_1          (0x2UL << COMP_CSR_INMSEL_Pos)              /*!< 0x00000020 */
N#define COMP_CSR_INMSEL_2          (0x4UL << COMP_CSR_INMSEL_Pos)              /*!< 0x00000040 */
N
N#define COMP_CSR_INPSEL_Pos        (7U)
N#define COMP_CSR_INPSEL_Msk        (0x3UL << COMP_CSR_INPSEL_Pos)              /*!< 0x00000180 */
N#define COMP_CSR_INPSEL            COMP_CSR_INPSEL_Msk                         /*!< Comparator input plus selection */
N#define COMP_CSR_INPSEL_0          (0x1UL << COMP_CSR_INPSEL_Pos)              /*!< 0x00000080 */
N#define COMP_CSR_INPSEL_1          (0x2UL << COMP_CSR_INPSEL_Pos)              /*!< 0x00000100 */
N
N#define COMP_CSR_WINMODE_Pos       (9U)
N#define COMP_CSR_WINMODE_Msk       (0x1UL << COMP_CSR_WINMODE_Pos)             /*!< 0x00000200 */
N#define COMP_CSR_WINMODE           COMP_CSR_WINMODE_Msk                        /*!< Pair of comparators window mode. Bit intended to be used with COMP common instance (COMP_Common_TypeDef)  */
N
N#define COMP_CSR_POLARITY_Pos      (15U)
N#define COMP_CSR_POLARITY_Msk      (0x1UL << COMP_CSR_POLARITY_Pos)            /*!< 0x00008000 */
N#define COMP_CSR_POLARITY          COMP_CSR_POLARITY_Msk                       /*!< Comparator output polarity */
N
N#define COMP_CSR_HYST_Pos          (16U)
N#define COMP_CSR_HYST_Msk          (0x3UL << COMP_CSR_HYST_Pos)                /*!< 0x00030000 */
N#define COMP_CSR_HYST              COMP_CSR_HYST_Msk                           /*!< Comparator hysteresis */
N#define COMP_CSR_HYST_0            (0x1UL << COMP_CSR_HYST_Pos)                /*!< 0x00010000 */
N#define COMP_CSR_HYST_1            (0x2UL << COMP_CSR_HYST_Pos)                /*!< 0x00020000 */
N
N#define COMP_CSR_BLANKING_Pos      (18U)
N#define COMP_CSR_BLANKING_Msk      (0x7UL << COMP_CSR_BLANKING_Pos)            /*!< 0x001C0000 */
N#define COMP_CSR_BLANKING          COMP_CSR_BLANKING_Msk                       /*!< Comparator blanking source */
N#define COMP_CSR_BLANKING_0        (0x1UL << COMP_CSR_BLANKING_Pos)            /*!< 0x00040000 */
N#define COMP_CSR_BLANKING_1        (0x2UL << COMP_CSR_BLANKING_Pos)            /*!< 0x00080000 */
N#define COMP_CSR_BLANKING_2        (0x4UL << COMP_CSR_BLANKING_Pos)            /*!< 0x00100000 */
N
N#define COMP_CSR_BRGEN_Pos         (22U)
N#define COMP_CSR_BRGEN_Msk         (0x1UL << COMP_CSR_BRGEN_Pos)               /*!< 0x00400000 */
N#define COMP_CSR_BRGEN             COMP_CSR_BRGEN_Msk                          /*!< Comparator voltage scaler enable */
N#define COMP_CSR_SCALEN_Pos        (23U)
N#define COMP_CSR_SCALEN_Msk        (0x1UL << COMP_CSR_SCALEN_Pos)              /*!< 0x00800000 */
N#define COMP_CSR_SCALEN            COMP_CSR_SCALEN_Msk                         /*!< Comparator scaler bridge enable */
N
N#define COMP_CSR_INMESEL_Pos       (25U)
N#define COMP_CSR_INMESEL_Msk       (0x3UL << COMP_CSR_INMESEL_Pos)             /*!< 0x06000000 */
N#define COMP_CSR_INMESEL           COMP_CSR_INMESEL_Msk                        /*!< Comparator input minus extended selection */
N#define COMP_CSR_INMESEL_0         (0x1UL << COMP_CSR_INMESEL_Pos)             /*!< 0x02000000 */
N#define COMP_CSR_INMESEL_1         (0x2UL << COMP_CSR_INMESEL_Pos)             /*!< 0x04000000 */
N
N#define COMP_CSR_VALUE_Pos         (30U)
N#define COMP_CSR_VALUE_Msk         (0x1UL << COMP_CSR_VALUE_Pos)               /*!< 0x40000000 */
N#define COMP_CSR_VALUE             COMP_CSR_VALUE_Msk                          /*!< Comparator output level */
N
N#define COMP_CSR_LOCK_Pos          (31U)
N#define COMP_CSR_LOCK_Msk          (0x1UL << COMP_CSR_LOCK_Pos)                /*!< 0x80000000 */
N#define COMP_CSR_LOCK              COMP_CSR_LOCK_Msk                           /*!< Comparator lock */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Operational Amplifier (OPAMP)                      */
N/*                                                                            */
N/******************************************************************************/
N/*********************  Bit definition for OPAMPx_CSR register  ***************/
N#define OPAMP_CSR_OPAMPxEN_Pos           (0U)
N#define OPAMP_CSR_OPAMPxEN_Msk           (0x1UL << OPAMP_CSR_OPAMPxEN_Pos)     /*!< 0x00000001 */
N#define OPAMP_CSR_OPAMPxEN               OPAMP_CSR_OPAMPxEN_Msk                /*!< OPAMP enable */
N#define OPAMP_CSR_OPALPM_Pos             (1U)
N#define OPAMP_CSR_OPALPM_Msk             (0x1UL << OPAMP_CSR_OPALPM_Pos)       /*!< 0x00000002 */
N#define OPAMP_CSR_OPALPM                 OPAMP_CSR_OPALPM_Msk                  /*!< Operational amplifier Low Power Mode */
N
N#define OPAMP_CSR_OPAMODE_Pos            (2U)
N#define OPAMP_CSR_OPAMODE_Msk            (0x3UL << OPAMP_CSR_OPAMODE_Pos)      /*!< 0x0000000C */
N#define OPAMP_CSR_OPAMODE                OPAMP_CSR_OPAMODE_Msk                 /*!< Operational amplifier PGA mode */
N#define OPAMP_CSR_OPAMODE_0              (0x1UL << OPAMP_CSR_OPAMODE_Pos)      /*!< 0x00000004 */
N#define OPAMP_CSR_OPAMODE_1              (0x2UL << OPAMP_CSR_OPAMODE_Pos)      /*!< 0x00000008 */
N
N#define OPAMP_CSR_PGGAIN_Pos             (4U)
N#define OPAMP_CSR_PGGAIN_Msk             (0x3UL << OPAMP_CSR_PGGAIN_Pos)       /*!< 0x00000030 */
N#define OPAMP_CSR_PGGAIN                 OPAMP_CSR_PGGAIN_Msk                  /*!< Operational amplifier Programmable amplifier gain value */
N#define OPAMP_CSR_PGGAIN_0               (0x1UL << OPAMP_CSR_PGGAIN_Pos)       /*!< 0x00000010 */
N#define OPAMP_CSR_PGGAIN_1               (0x2UL << OPAMP_CSR_PGGAIN_Pos)       /*!< 0x00000020 */
N
N#define OPAMP_CSR_VMSEL_Pos              (8U)
N#define OPAMP_CSR_VMSEL_Msk              (0x3UL << OPAMP_CSR_VMSEL_Pos)        /*!< 0x00000300 */
N#define OPAMP_CSR_VMSEL                  OPAMP_CSR_VMSEL_Msk                   /*!< Inverting input selection */
N#define OPAMP_CSR_VMSEL_0                (0x1UL << OPAMP_CSR_VMSEL_Pos)        /*!< 0x00000100 */
N#define OPAMP_CSR_VMSEL_1                (0x2UL << OPAMP_CSR_VMSEL_Pos)        /*!< 0x00000200 */
N
N#define OPAMP_CSR_VPSEL_Pos              (10U)
N#define OPAMP_CSR_VPSEL_Msk              (0x1UL << OPAMP_CSR_VPSEL_Pos)        /*!< 0x00000400 */
N#define OPAMP_CSR_VPSEL                  OPAMP_CSR_VPSEL_Msk                   /*!< Non inverted input selection */
N#define OPAMP_CSR_CALON_Pos              (12U)
N#define OPAMP_CSR_CALON_Msk              (0x1UL << OPAMP_CSR_CALON_Pos)        /*!< 0x00001000 */
N#define OPAMP_CSR_CALON                  OPAMP_CSR_CALON_Msk                   /*!< Calibration mode enable */
N#define OPAMP_CSR_CALSEL_Pos             (13U)
N#define OPAMP_CSR_CALSEL_Msk             (0x1UL << OPAMP_CSR_CALSEL_Pos)       /*!< 0x00002000 */
N#define OPAMP_CSR_CALSEL                 OPAMP_CSR_CALSEL_Msk                  /*!< Calibration selection */
N#define OPAMP_CSR_USERTRIM_Pos           (14U)
N#define OPAMP_CSR_USERTRIM_Msk           (0x1UL << OPAMP_CSR_USERTRIM_Pos)     /*!< 0x00004000 */
N#define OPAMP_CSR_USERTRIM               OPAMP_CSR_USERTRIM_Msk                /*!< User trimming enable */
N#define OPAMP_CSR_CALOUT_Pos             (15U)
N#define OPAMP_CSR_CALOUT_Msk             (0x1UL << OPAMP_CSR_CALOUT_Pos)       /*!< 0x00008000 */
N#define OPAMP_CSR_CALOUT                 OPAMP_CSR_CALOUT_Msk                  /*!< Operational amplifier1 calibration output */
N
N/*********************  Bit definition for OPAMP1_CSR register  ***************/
N#define OPAMP1_CSR_OPAEN_Pos              (0U)
N#define OPAMP1_CSR_OPAEN_Msk              (0x1UL << OPAMP1_CSR_OPAEN_Pos)      /*!< 0x00000001 */
N#define OPAMP1_CSR_OPAEN                  OPAMP1_CSR_OPAEN_Msk                 /*!< Operational amplifier1 Enable */
N#define OPAMP1_CSR_OPALPM_Pos             (1U)
N#define OPAMP1_CSR_OPALPM_Msk             (0x1UL << OPAMP1_CSR_OPALPM_Pos)     /*!< 0x00000002 */
N#define OPAMP1_CSR_OPALPM                 OPAMP1_CSR_OPALPM_Msk                /*!< Operational amplifier1 Low Power Mode */
N
N#define OPAMP1_CSR_OPAMODE_Pos            (2U)
N#define OPAMP1_CSR_OPAMODE_Msk            (0x3UL << OPAMP1_CSR_OPAMODE_Pos)    /*!< 0x0000000C */
N#define OPAMP1_CSR_OPAMODE                OPAMP1_CSR_OPAMODE_Msk               /*!< Operational amplifier1 PGA mode */
N#define OPAMP1_CSR_OPAMODE_0              (0x1UL << OPAMP1_CSR_OPAMODE_Pos)    /*!< 0x00000004 */
N#define OPAMP1_CSR_OPAMODE_1              (0x2UL << OPAMP1_CSR_OPAMODE_Pos)    /*!< 0x00000008 */
N
N#define OPAMP1_CSR_PGAGAIN_Pos            (4U)
N#define OPAMP1_CSR_PGAGAIN_Msk            (0x3UL << OPAMP1_CSR_PGAGAIN_Pos)    /*!< 0x00000030 */
N#define OPAMP1_CSR_PGAGAIN                OPAMP1_CSR_PGAGAIN_Msk               /*!< Operational amplifier1 Programmable amplifier gain value */
N#define OPAMP1_CSR_PGAGAIN_0              (0x1UL << OPAMP1_CSR_PGAGAIN_Pos)    /*!< 0x00000010 */
N#define OPAMP1_CSR_PGAGAIN_1              (0x2UL << OPAMP1_CSR_PGAGAIN_Pos)    /*!< 0x00000020 */
N
N#define OPAMP1_CSR_VMSEL_Pos              (8U)
N#define OPAMP1_CSR_VMSEL_Msk              (0x3UL << OPAMP1_CSR_VMSEL_Pos)      /*!< 0x00000300 */
N#define OPAMP1_CSR_VMSEL                  OPAMP1_CSR_VMSEL_Msk                 /*!< Inverting input selection */
N#define OPAMP1_CSR_VMSEL_0                (0x1UL << OPAMP1_CSR_VMSEL_Pos)      /*!< 0x00000100 */
N#define OPAMP1_CSR_VMSEL_1                (0x2UL << OPAMP1_CSR_VMSEL_Pos)      /*!< 0x00000200 */
N
N#define OPAMP1_CSR_VPSEL_Pos              (10U)
N#define OPAMP1_CSR_VPSEL_Msk              (0x1UL << OPAMP1_CSR_VPSEL_Pos)      /*!< 0x00000400 */
N#define OPAMP1_CSR_VPSEL                  OPAMP1_CSR_VPSEL_Msk                 /*!< Non inverted input selection */
N#define OPAMP1_CSR_CALON_Pos              (12U)
N#define OPAMP1_CSR_CALON_Msk              (0x1UL << OPAMP1_CSR_CALON_Pos)      /*!< 0x00001000 */
N#define OPAMP1_CSR_CALON                  OPAMP1_CSR_CALON_Msk                 /*!< Calibration mode enable */
N#define OPAMP1_CSR_CALSEL_Pos             (13U)
N#define OPAMP1_CSR_CALSEL_Msk             (0x1UL << OPAMP1_CSR_CALSEL_Pos)     /*!< 0x00002000 */
N#define OPAMP1_CSR_CALSEL                 OPAMP1_CSR_CALSEL_Msk                /*!< Calibration selection */
N#define OPAMP1_CSR_USERTRIM_Pos           (14U)
N#define OPAMP1_CSR_USERTRIM_Msk           (0x1UL << OPAMP1_CSR_USERTRIM_Pos)   /*!< 0x00004000 */
N#define OPAMP1_CSR_USERTRIM               OPAMP1_CSR_USERTRIM_Msk              /*!< User trimming enable */
N#define OPAMP1_CSR_CALOUT_Pos             (15U)
N#define OPAMP1_CSR_CALOUT_Msk             (0x1UL << OPAMP1_CSR_CALOUT_Pos)     /*!< 0x00008000 */
N#define OPAMP1_CSR_CALOUT                 OPAMP1_CSR_CALOUT_Msk                /*!< Operational amplifier1 calibration output */
N
N#define OPAMP1_CSR_OPARANGE_Pos           (31U)
N#define OPAMP1_CSR_OPARANGE_Msk           (0x1UL << OPAMP1_CSR_OPARANGE_Pos)   /*!< 0x80000000 */
N#define OPAMP1_CSR_OPARANGE               OPAMP1_CSR_OPARANGE_Msk              /*!< Common to several OPAMP instances: Operational amplifier voltage supply range. Bit intended to be used with OPAMP common instance (OPAMP_Common_TypeDef) */
N
N/*******************  Bit definition for OPAMP_OTR register  ******************/
N#define OPAMP_OTR_TRIMOFFSETN_Pos        (0U)
N#define OPAMP_OTR_TRIMOFFSETN_Msk        (0x1FUL << OPAMP_OTR_TRIMOFFSETN_Pos) /*!< 0x0000001F */
N#define OPAMP_OTR_TRIMOFFSETN            OPAMP_OTR_TRIMOFFSETN_Msk             /*!< Trim for NMOS differential pairs */
N#define OPAMP_OTR_TRIMOFFSETP_Pos        (8U)
N#define OPAMP_OTR_TRIMOFFSETP_Msk        (0x1FUL << OPAMP_OTR_TRIMOFFSETP_Pos) /*!< 0x00001F00 */
N#define OPAMP_OTR_TRIMOFFSETP            OPAMP_OTR_TRIMOFFSETP_Msk             /*!< Trim for PMOS differential pairs */
N
N/*******************  Bit definition for OPAMP1_OTR register  ******************/
N#define OPAMP1_OTR_TRIMOFFSETN_Pos        (0U)
N#define OPAMP1_OTR_TRIMOFFSETN_Msk        (0x1FUL << OPAMP1_OTR_TRIMOFFSETN_Pos) /*!< 0x0000001F */
N#define OPAMP1_OTR_TRIMOFFSETN            OPAMP1_OTR_TRIMOFFSETN_Msk           /*!< Trim for NMOS differential pairs */
N#define OPAMP1_OTR_TRIMOFFSETP_Pos        (8U)
N#define OPAMP1_OTR_TRIMOFFSETP_Msk        (0x1FUL << OPAMP1_OTR_TRIMOFFSETP_Pos) /*!< 0x00001F00 */
N#define OPAMP1_OTR_TRIMOFFSETP            OPAMP1_OTR_TRIMOFFSETP_Msk           /*!< Trim for PMOS differential pairs */
N
N/*******************  Bit definition for OPAMP_LPOTR register  ****************/
N#define OPAMP_LPOTR_TRIMLPOFFSETN_Pos    (0U)
N#define OPAMP_LPOTR_TRIMLPOFFSETN_Msk    (0x1FUL << OPAMP_LPOTR_TRIMLPOFFSETN_Pos) /*!< 0x0000001F */
N#define OPAMP_LPOTR_TRIMLPOFFSETN        OPAMP_LPOTR_TRIMLPOFFSETN_Msk         /*!< Trim for NMOS differential pairs */
N#define OPAMP_LPOTR_TRIMLPOFFSETP_Pos    (8U)
N#define OPAMP_LPOTR_TRIMLPOFFSETP_Msk    (0x1FUL << OPAMP_LPOTR_TRIMLPOFFSETP_Pos) /*!< 0x00001F00 */
N#define OPAMP_LPOTR_TRIMLPOFFSETP        OPAMP_LPOTR_TRIMLPOFFSETP_Msk         /*!< Trim for PMOS differential pairs */
N
N/*******************  Bit definition for OPAMP1_LPOTR register  ****************/
N#define OPAMP1_LPOTR_TRIMLPOFFSETN_Pos    (0U)
N#define OPAMP1_LPOTR_TRIMLPOFFSETN_Msk    (0x1FUL << OPAMP1_LPOTR_TRIMLPOFFSETN_Pos) /*!< 0x0000001F */
N#define OPAMP1_LPOTR_TRIMLPOFFSETN        OPAMP1_LPOTR_TRIMLPOFFSETN_Msk       /*!< Trim for NMOS differential pairs */
N#define OPAMP1_LPOTR_TRIMLPOFFSETP_Pos    (8U)
N#define OPAMP1_LPOTR_TRIMLPOFFSETP_Msk    (0x1FUL << OPAMP1_LPOTR_TRIMLPOFFSETP_Pos) /*!< 0x00001F00 */
N#define OPAMP1_LPOTR_TRIMLPOFFSETP        OPAMP1_LPOTR_TRIMLPOFFSETP_Msk       /*!< Trim for PMOS differential pairs */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Touch Sensing Controller (TSC)                    */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TSC_CR register  *********************/
N#define TSC_CR_TSCE_Pos          (0U)
N#define TSC_CR_TSCE_Msk          (0x1UL << TSC_CR_TSCE_Pos)                    /*!< 0x00000001 */
N#define TSC_CR_TSCE              TSC_CR_TSCE_Msk                               /*!<Touch sensing controller enable */
N#define TSC_CR_START_Pos         (1U)
N#define TSC_CR_START_Msk         (0x1UL << TSC_CR_START_Pos)                   /*!< 0x00000002 */
N#define TSC_CR_START             TSC_CR_START_Msk                              /*!<Start acquisition */
N#define TSC_CR_AM_Pos            (2U)
N#define TSC_CR_AM_Msk            (0x1UL << TSC_CR_AM_Pos)                      /*!< 0x00000004 */
N#define TSC_CR_AM                TSC_CR_AM_Msk                                 /*!<Acquisition mode */
N#define TSC_CR_SYNCPOL_Pos       (3U)
N#define TSC_CR_SYNCPOL_Msk       (0x1UL << TSC_CR_SYNCPOL_Pos)                 /*!< 0x00000008 */
N#define TSC_CR_SYNCPOL           TSC_CR_SYNCPOL_Msk                            /*!<Synchronization pin polarity */
N#define TSC_CR_IODEF_Pos         (4U)
N#define TSC_CR_IODEF_Msk         (0x1UL << TSC_CR_IODEF_Pos)                   /*!< 0x00000010 */
N#define TSC_CR_IODEF             TSC_CR_IODEF_Msk                              /*!<IO default mode */
N
N#define TSC_CR_MCV_Pos           (5U)
N#define TSC_CR_MCV_Msk           (0x7UL << TSC_CR_MCV_Pos)                     /*!< 0x000000E0 */
N#define TSC_CR_MCV               TSC_CR_MCV_Msk                                /*!<MCV[2:0] bits (Max Count Value) */
N#define TSC_CR_MCV_0             (0x1UL << TSC_CR_MCV_Pos)                     /*!< 0x00000020 */
N#define TSC_CR_MCV_1             (0x2UL << TSC_CR_MCV_Pos)                     /*!< 0x00000040 */
N#define TSC_CR_MCV_2             (0x4UL << TSC_CR_MCV_Pos)                     /*!< 0x00000080 */
N
N#define TSC_CR_PGPSC_Pos         (12U)
N#define TSC_CR_PGPSC_Msk         (0x7UL << TSC_CR_PGPSC_Pos)                   /*!< 0x00007000 */
N#define TSC_CR_PGPSC             TSC_CR_PGPSC_Msk                              /*!<PGPSC[2:0] bits (Pulse Generator Prescaler) */
N#define TSC_CR_PGPSC_0           (0x1UL << TSC_CR_PGPSC_Pos)                   /*!< 0x00001000 */
N#define TSC_CR_PGPSC_1           (0x2UL << TSC_CR_PGPSC_Pos)                   /*!< 0x00002000 */
N#define TSC_CR_PGPSC_2           (0x4UL << TSC_CR_PGPSC_Pos)                   /*!< 0x00004000 */
N
N#define TSC_CR_SSPSC_Pos         (15U)
N#define TSC_CR_SSPSC_Msk         (0x1UL << TSC_CR_SSPSC_Pos)                   /*!< 0x00008000 */
N#define TSC_CR_SSPSC             TSC_CR_SSPSC_Msk                              /*!<Spread Spectrum Prescaler */
N#define TSC_CR_SSE_Pos           (16U)
N#define TSC_CR_SSE_Msk           (0x1UL << TSC_CR_SSE_Pos)                     /*!< 0x00010000 */
N#define TSC_CR_SSE               TSC_CR_SSE_Msk                                /*!<Spread Spectrum Enable */
N
N#define TSC_CR_SSD_Pos           (17U)
N#define TSC_CR_SSD_Msk           (0x7FUL << TSC_CR_SSD_Pos)                    /*!< 0x00FE0000 */
N#define TSC_CR_SSD               TSC_CR_SSD_Msk                                /*!<SSD[6:0] bits (Spread Spectrum Deviation) */
N#define TSC_CR_SSD_0             (0x01UL << TSC_CR_SSD_Pos)                    /*!< 0x00020000 */
N#define TSC_CR_SSD_1             (0x02UL << TSC_CR_SSD_Pos)                    /*!< 0x00040000 */
N#define TSC_CR_SSD_2             (0x04UL << TSC_CR_SSD_Pos)                    /*!< 0x00080000 */
N#define TSC_CR_SSD_3             (0x08UL << TSC_CR_SSD_Pos)                    /*!< 0x00100000 */
N#define TSC_CR_SSD_4             (0x10UL << TSC_CR_SSD_Pos)                    /*!< 0x00200000 */
N#define TSC_CR_SSD_5             (0x20UL << TSC_CR_SSD_Pos)                    /*!< 0x00400000 */
N#define TSC_CR_SSD_6             (0x40UL << TSC_CR_SSD_Pos)                    /*!< 0x00800000 */
N
N#define TSC_CR_CTPL_Pos          (24U)
N#define TSC_CR_CTPL_Msk          (0xFUL << TSC_CR_CTPL_Pos)                    /*!< 0x0F000000 */
N#define TSC_CR_CTPL              TSC_CR_CTPL_Msk                               /*!<CTPL[3:0] bits (Charge Transfer pulse low) */
N#define TSC_CR_CTPL_0            (0x1UL << TSC_CR_CTPL_Pos)                    /*!< 0x01000000 */
N#define TSC_CR_CTPL_1            (0x2UL << TSC_CR_CTPL_Pos)                    /*!< 0x02000000 */
N#define TSC_CR_CTPL_2            (0x4UL << TSC_CR_CTPL_Pos)                    /*!< 0x04000000 */
N#define TSC_CR_CTPL_3            (0x8UL << TSC_CR_CTPL_Pos)                    /*!< 0x08000000 */
N
N#define TSC_CR_CTPH_Pos          (28U)
N#define TSC_CR_CTPH_Msk          (0xFUL << TSC_CR_CTPH_Pos)                    /*!< 0xF0000000 */
N#define TSC_CR_CTPH              TSC_CR_CTPH_Msk                               /*!<CTPH[3:0] bits (Charge Transfer pulse high) */
N#define TSC_CR_CTPH_0            (0x1UL << TSC_CR_CTPH_Pos)                    /*!< 0x10000000 */
N#define TSC_CR_CTPH_1            (0x2UL << TSC_CR_CTPH_Pos)                    /*!< 0x20000000 */
N#define TSC_CR_CTPH_2            (0x4UL << TSC_CR_CTPH_Pos)                    /*!< 0x40000000 */
N#define TSC_CR_CTPH_3            (0x8UL << TSC_CR_CTPH_Pos)                    /*!< 0x80000000 */
N
N/*******************  Bit definition for TSC_IER register  ********************/
N#define TSC_IER_EOAIE_Pos        (0U)
N#define TSC_IER_EOAIE_Msk        (0x1UL << TSC_IER_EOAIE_Pos)                  /*!< 0x00000001 */
N#define TSC_IER_EOAIE            TSC_IER_EOAIE_Msk                             /*!<End of acquisition interrupt enable */
N#define TSC_IER_MCEIE_Pos        (1U)
N#define TSC_IER_MCEIE_Msk        (0x1UL << TSC_IER_MCEIE_Pos)                  /*!< 0x00000002 */
N#define TSC_IER_MCEIE            TSC_IER_MCEIE_Msk                             /*!<Max count error interrupt enable */
N
N/*******************  Bit definition for TSC_ICR register  ********************/
N#define TSC_ICR_EOAIC_Pos        (0U)
N#define TSC_ICR_EOAIC_Msk        (0x1UL << TSC_ICR_EOAIC_Pos)                  /*!< 0x00000001 */
N#define TSC_ICR_EOAIC            TSC_ICR_EOAIC_Msk                             /*!<End of acquisition interrupt clear */
N#define TSC_ICR_MCEIC_Pos        (1U)
N#define TSC_ICR_MCEIC_Msk        (0x1UL << TSC_ICR_MCEIC_Pos)                  /*!< 0x00000002 */
N#define TSC_ICR_MCEIC            TSC_ICR_MCEIC_Msk                             /*!<Max count error interrupt clear */
N
N/*******************  Bit definition for TSC_ISR register  ********************/
N#define TSC_ISR_EOAF_Pos         (0U)
N#define TSC_ISR_EOAF_Msk         (0x1UL << TSC_ISR_EOAF_Pos)                   /*!< 0x00000001 */
N#define TSC_ISR_EOAF             TSC_ISR_EOAF_Msk                              /*!<End of acquisition flag */
N#define TSC_ISR_MCEF_Pos         (1U)
N#define TSC_ISR_MCEF_Msk         (0x1UL << TSC_ISR_MCEF_Pos)                   /*!< 0x00000002 */
N#define TSC_ISR_MCEF             TSC_ISR_MCEF_Msk                              /*!<Max count error flag */
N
N/*******************  Bit definition for TSC_IOHCR register  ******************/
N#define TSC_IOHCR_G1_IO1_Pos     (0U)
N#define TSC_IOHCR_G1_IO1_Msk     (0x1UL << TSC_IOHCR_G1_IO1_Pos)               /*!< 0x00000001 */
N#define TSC_IOHCR_G1_IO1         TSC_IOHCR_G1_IO1_Msk                          /*!<GROUP1_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G1_IO2_Pos     (1U)
N#define TSC_IOHCR_G1_IO2_Msk     (0x1UL << TSC_IOHCR_G1_IO2_Pos)               /*!< 0x00000002 */
N#define TSC_IOHCR_G1_IO2         TSC_IOHCR_G1_IO2_Msk                          /*!<GROUP1_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G1_IO3_Pos     (2U)
N#define TSC_IOHCR_G1_IO3_Msk     (0x1UL << TSC_IOHCR_G1_IO3_Pos)               /*!< 0x00000004 */
N#define TSC_IOHCR_G1_IO3         TSC_IOHCR_G1_IO3_Msk                          /*!<GROUP1_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G1_IO4_Pos     (3U)
N#define TSC_IOHCR_G1_IO4_Msk     (0x1UL << TSC_IOHCR_G1_IO4_Pos)               /*!< 0x00000008 */
N#define TSC_IOHCR_G1_IO4         TSC_IOHCR_G1_IO4_Msk                          /*!<GROUP1_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO1_Pos     (4U)
N#define TSC_IOHCR_G2_IO1_Msk     (0x1UL << TSC_IOHCR_G2_IO1_Pos)               /*!< 0x00000010 */
N#define TSC_IOHCR_G2_IO1         TSC_IOHCR_G2_IO1_Msk                          /*!<GROUP2_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO2_Pos     (5U)
N#define TSC_IOHCR_G2_IO2_Msk     (0x1UL << TSC_IOHCR_G2_IO2_Pos)               /*!< 0x00000020 */
N#define TSC_IOHCR_G2_IO2         TSC_IOHCR_G2_IO2_Msk                          /*!<GROUP2_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO3_Pos     (6U)
N#define TSC_IOHCR_G2_IO3_Msk     (0x1UL << TSC_IOHCR_G2_IO3_Pos)               /*!< 0x00000040 */
N#define TSC_IOHCR_G2_IO3         TSC_IOHCR_G2_IO3_Msk                          /*!<GROUP2_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO4_Pos     (7U)
N#define TSC_IOHCR_G2_IO4_Msk     (0x1UL << TSC_IOHCR_G2_IO4_Pos)               /*!< 0x00000080 */
N#define TSC_IOHCR_G2_IO4         TSC_IOHCR_G2_IO4_Msk                          /*!<GROUP2_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO1_Pos     (8U)
N#define TSC_IOHCR_G3_IO1_Msk     (0x1UL << TSC_IOHCR_G3_IO1_Pos)               /*!< 0x00000100 */
N#define TSC_IOHCR_G3_IO1         TSC_IOHCR_G3_IO1_Msk                          /*!<GROUP3_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO2_Pos     (9U)
N#define TSC_IOHCR_G3_IO2_Msk     (0x1UL << TSC_IOHCR_G3_IO2_Pos)               /*!< 0x00000200 */
N#define TSC_IOHCR_G3_IO2         TSC_IOHCR_G3_IO2_Msk                          /*!<GROUP3_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO3_Pos     (10U)
N#define TSC_IOHCR_G3_IO3_Msk     (0x1UL << TSC_IOHCR_G3_IO3_Pos)               /*!< 0x00000400 */
N#define TSC_IOHCR_G3_IO3         TSC_IOHCR_G3_IO3_Msk                          /*!<GROUP3_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO4_Pos     (11U)
N#define TSC_IOHCR_G3_IO4_Msk     (0x1UL << TSC_IOHCR_G3_IO4_Pos)               /*!< 0x00000800 */
N#define TSC_IOHCR_G3_IO4         TSC_IOHCR_G3_IO4_Msk                          /*!<GROUP3_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO1_Pos     (12U)
N#define TSC_IOHCR_G4_IO1_Msk     (0x1UL << TSC_IOHCR_G4_IO1_Pos)               /*!< 0x00001000 */
N#define TSC_IOHCR_G4_IO1         TSC_IOHCR_G4_IO1_Msk                          /*!<GROUP4_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO2_Pos     (13U)
N#define TSC_IOHCR_G4_IO2_Msk     (0x1UL << TSC_IOHCR_G4_IO2_Pos)               /*!< 0x00002000 */
N#define TSC_IOHCR_G4_IO2         TSC_IOHCR_G4_IO2_Msk                          /*!<GROUP4_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO3_Pos     (14U)
N#define TSC_IOHCR_G4_IO3_Msk     (0x1UL << TSC_IOHCR_G4_IO3_Pos)               /*!< 0x00004000 */
N#define TSC_IOHCR_G4_IO3         TSC_IOHCR_G4_IO3_Msk                          /*!<GROUP4_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO4_Pos     (15U)
N#define TSC_IOHCR_G4_IO4_Msk     (0x1UL << TSC_IOHCR_G4_IO4_Pos)               /*!< 0x00008000 */
N#define TSC_IOHCR_G4_IO4         TSC_IOHCR_G4_IO4_Msk                          /*!<GROUP4_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO1_Pos     (16U)
N#define TSC_IOHCR_G5_IO1_Msk     (0x1UL << TSC_IOHCR_G5_IO1_Pos)               /*!< 0x00010000 */
N#define TSC_IOHCR_G5_IO1         TSC_IOHCR_G5_IO1_Msk                          /*!<GROUP5_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO2_Pos     (17U)
N#define TSC_IOHCR_G5_IO2_Msk     (0x1UL << TSC_IOHCR_G5_IO2_Pos)               /*!< 0x00020000 */
N#define TSC_IOHCR_G5_IO2         TSC_IOHCR_G5_IO2_Msk                          /*!<GROUP5_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO3_Pos     (18U)
N#define TSC_IOHCR_G5_IO3_Msk     (0x1UL << TSC_IOHCR_G5_IO3_Pos)               /*!< 0x00040000 */
N#define TSC_IOHCR_G5_IO3         TSC_IOHCR_G5_IO3_Msk                          /*!<GROUP5_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO4_Pos     (19U)
N#define TSC_IOHCR_G5_IO4_Msk     (0x1UL << TSC_IOHCR_G5_IO4_Pos)               /*!< 0x00080000 */
N#define TSC_IOHCR_G5_IO4         TSC_IOHCR_G5_IO4_Msk                          /*!<GROUP5_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO1_Pos     (20U)
N#define TSC_IOHCR_G6_IO1_Msk     (0x1UL << TSC_IOHCR_G6_IO1_Pos)               /*!< 0x00100000 */
N#define TSC_IOHCR_G6_IO1         TSC_IOHCR_G6_IO1_Msk                          /*!<GROUP6_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO2_Pos     (21U)
N#define TSC_IOHCR_G6_IO2_Msk     (0x1UL << TSC_IOHCR_G6_IO2_Pos)               /*!< 0x00200000 */
N#define TSC_IOHCR_G6_IO2         TSC_IOHCR_G6_IO2_Msk                          /*!<GROUP6_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO3_Pos     (22U)
N#define TSC_IOHCR_G6_IO3_Msk     (0x1UL << TSC_IOHCR_G6_IO3_Pos)               /*!< 0x00400000 */
N#define TSC_IOHCR_G6_IO3         TSC_IOHCR_G6_IO3_Msk                          /*!<GROUP6_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO4_Pos     (23U)
N#define TSC_IOHCR_G6_IO4_Msk     (0x1UL << TSC_IOHCR_G6_IO4_Pos)               /*!< 0x00800000 */
N#define TSC_IOHCR_G6_IO4         TSC_IOHCR_G6_IO4_Msk                          /*!<GROUP6_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO1_Pos     (24U)
N#define TSC_IOHCR_G7_IO1_Msk     (0x1UL << TSC_IOHCR_G7_IO1_Pos)               /*!< 0x01000000 */
N#define TSC_IOHCR_G7_IO1         TSC_IOHCR_G7_IO1_Msk                          /*!<GROUP7_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO2_Pos     (25U)
N#define TSC_IOHCR_G7_IO2_Msk     (0x1UL << TSC_IOHCR_G7_IO2_Pos)               /*!< 0x02000000 */
N#define TSC_IOHCR_G7_IO2         TSC_IOHCR_G7_IO2_Msk                          /*!<GROUP7_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO3_Pos     (26U)
N#define TSC_IOHCR_G7_IO3_Msk     (0x1UL << TSC_IOHCR_G7_IO3_Pos)               /*!< 0x04000000 */
N#define TSC_IOHCR_G7_IO3         TSC_IOHCR_G7_IO3_Msk                          /*!<GROUP7_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO4_Pos     (27U)
N#define TSC_IOHCR_G7_IO4_Msk     (0x1UL << TSC_IOHCR_G7_IO4_Pos)               /*!< 0x08000000 */
N#define TSC_IOHCR_G7_IO4         TSC_IOHCR_G7_IO4_Msk                          /*!<GROUP7_IO4 schmitt trigger hysteresis mode */
N
N/*******************  Bit definition for TSC_IOASCR register  *****************/
N#define TSC_IOASCR_G1_IO1_Pos    (0U)
N#define TSC_IOASCR_G1_IO1_Msk    (0x1UL << TSC_IOASCR_G1_IO1_Pos)              /*!< 0x00000001 */
N#define TSC_IOASCR_G1_IO1        TSC_IOASCR_G1_IO1_Msk                         /*!<GROUP1_IO1 analog switch enable */
N#define TSC_IOASCR_G1_IO2_Pos    (1U)
N#define TSC_IOASCR_G1_IO2_Msk    (0x1UL << TSC_IOASCR_G1_IO2_Pos)              /*!< 0x00000002 */
N#define TSC_IOASCR_G1_IO2        TSC_IOASCR_G1_IO2_Msk                         /*!<GROUP1_IO2 analog switch enable */
N#define TSC_IOASCR_G1_IO3_Pos    (2U)
N#define TSC_IOASCR_G1_IO3_Msk    (0x1UL << TSC_IOASCR_G1_IO3_Pos)              /*!< 0x00000004 */
N#define TSC_IOASCR_G1_IO3        TSC_IOASCR_G1_IO3_Msk                         /*!<GROUP1_IO3 analog switch enable */
N#define TSC_IOASCR_G1_IO4_Pos    (3U)
N#define TSC_IOASCR_G1_IO4_Msk    (0x1UL << TSC_IOASCR_G1_IO4_Pos)              /*!< 0x00000008 */
N#define TSC_IOASCR_G1_IO4        TSC_IOASCR_G1_IO4_Msk                         /*!<GROUP1_IO4 analog switch enable */
N#define TSC_IOASCR_G2_IO1_Pos    (4U)
N#define TSC_IOASCR_G2_IO1_Msk    (0x1UL << TSC_IOASCR_G2_IO1_Pos)              /*!< 0x00000010 */
N#define TSC_IOASCR_G2_IO1        TSC_IOASCR_G2_IO1_Msk                         /*!<GROUP2_IO1 analog switch enable */
N#define TSC_IOASCR_G2_IO2_Pos    (5U)
N#define TSC_IOASCR_G2_IO2_Msk    (0x1UL << TSC_IOASCR_G2_IO2_Pos)              /*!< 0x00000020 */
N#define TSC_IOASCR_G2_IO2        TSC_IOASCR_G2_IO2_Msk                         /*!<GROUP2_IO2 analog switch enable */
N#define TSC_IOASCR_G2_IO3_Pos    (6U)
N#define TSC_IOASCR_G2_IO3_Msk    (0x1UL << TSC_IOASCR_G2_IO3_Pos)              /*!< 0x00000040 */
N#define TSC_IOASCR_G2_IO3        TSC_IOASCR_G2_IO3_Msk                         /*!<GROUP2_IO3 analog switch enable */
N#define TSC_IOASCR_G2_IO4_Pos    (7U)
N#define TSC_IOASCR_G2_IO4_Msk    (0x1UL << TSC_IOASCR_G2_IO4_Pos)              /*!< 0x00000080 */
N#define TSC_IOASCR_G2_IO4        TSC_IOASCR_G2_IO4_Msk                         /*!<GROUP2_IO4 analog switch enable */
N#define TSC_IOASCR_G3_IO1_Pos    (8U)
N#define TSC_IOASCR_G3_IO1_Msk    (0x1UL << TSC_IOASCR_G3_IO1_Pos)              /*!< 0x00000100 */
N#define TSC_IOASCR_G3_IO1        TSC_IOASCR_G3_IO1_Msk                         /*!<GROUP3_IO1 analog switch enable */
N#define TSC_IOASCR_G3_IO2_Pos    (9U)
N#define TSC_IOASCR_G3_IO2_Msk    (0x1UL << TSC_IOASCR_G3_IO2_Pos)              /*!< 0x00000200 */
N#define TSC_IOASCR_G3_IO2        TSC_IOASCR_G3_IO2_Msk                         /*!<GROUP3_IO2 analog switch enable */
N#define TSC_IOASCR_G3_IO3_Pos    (10U)
N#define TSC_IOASCR_G3_IO3_Msk    (0x1UL << TSC_IOASCR_G3_IO3_Pos)              /*!< 0x00000400 */
N#define TSC_IOASCR_G3_IO3        TSC_IOASCR_G3_IO3_Msk                         /*!<GROUP3_IO3 analog switch enable */
N#define TSC_IOASCR_G3_IO4_Pos    (11U)
N#define TSC_IOASCR_G3_IO4_Msk    (0x1UL << TSC_IOASCR_G3_IO4_Pos)              /*!< 0x00000800 */
N#define TSC_IOASCR_G3_IO4        TSC_IOASCR_G3_IO4_Msk                         /*!<GROUP3_IO4 analog switch enable */
N#define TSC_IOASCR_G4_IO1_Pos    (12U)
N#define TSC_IOASCR_G4_IO1_Msk    (0x1UL << TSC_IOASCR_G4_IO1_Pos)              /*!< 0x00001000 */
N#define TSC_IOASCR_G4_IO1        TSC_IOASCR_G4_IO1_Msk                         /*!<GROUP4_IO1 analog switch enable */
N#define TSC_IOASCR_G4_IO2_Pos    (13U)
N#define TSC_IOASCR_G4_IO2_Msk    (0x1UL << TSC_IOASCR_G4_IO2_Pos)              /*!< 0x00002000 */
N#define TSC_IOASCR_G4_IO2        TSC_IOASCR_G4_IO2_Msk                         /*!<GROUP4_IO2 analog switch enable */
N#define TSC_IOASCR_G4_IO3_Pos    (14U)
N#define TSC_IOASCR_G4_IO3_Msk    (0x1UL << TSC_IOASCR_G4_IO3_Pos)              /*!< 0x00004000 */
N#define TSC_IOASCR_G4_IO3        TSC_IOASCR_G4_IO3_Msk                         /*!<GROUP4_IO3 analog switch enable */
N#define TSC_IOASCR_G4_IO4_Pos    (15U)
N#define TSC_IOASCR_G4_IO4_Msk    (0x1UL << TSC_IOASCR_G4_IO4_Pos)              /*!< 0x00008000 */
N#define TSC_IOASCR_G4_IO4        TSC_IOASCR_G4_IO4_Msk                         /*!<GROUP4_IO4 analog switch enable */
N#define TSC_IOASCR_G5_IO1_Pos    (16U)
N#define TSC_IOASCR_G5_IO1_Msk    (0x1UL << TSC_IOASCR_G5_IO1_Pos)              /*!< 0x00010000 */
N#define TSC_IOASCR_G5_IO1        TSC_IOASCR_G5_IO1_Msk                         /*!<GROUP5_IO1 analog switch enable */
N#define TSC_IOASCR_G5_IO2_Pos    (17U)
N#define TSC_IOASCR_G5_IO2_Msk    (0x1UL << TSC_IOASCR_G5_IO2_Pos)              /*!< 0x00020000 */
N#define TSC_IOASCR_G5_IO2        TSC_IOASCR_G5_IO2_Msk                         /*!<GROUP5_IO2 analog switch enable */
N#define TSC_IOASCR_G5_IO3_Pos    (18U)
N#define TSC_IOASCR_G5_IO3_Msk    (0x1UL << TSC_IOASCR_G5_IO3_Pos)              /*!< 0x00040000 */
N#define TSC_IOASCR_G5_IO3        TSC_IOASCR_G5_IO3_Msk                         /*!<GROUP5_IO3 analog switch enable */
N#define TSC_IOASCR_G5_IO4_Pos    (19U)
N#define TSC_IOASCR_G5_IO4_Msk    (0x1UL << TSC_IOASCR_G5_IO4_Pos)              /*!< 0x00080000 */
N#define TSC_IOASCR_G5_IO4        TSC_IOASCR_G5_IO4_Msk                         /*!<GROUP5_IO4 analog switch enable */
N#define TSC_IOASCR_G6_IO1_Pos    (20U)
N#define TSC_IOASCR_G6_IO1_Msk    (0x1UL << TSC_IOASCR_G6_IO1_Pos)              /*!< 0x00100000 */
N#define TSC_IOASCR_G6_IO1        TSC_IOASCR_G6_IO1_Msk                         /*!<GROUP6_IO1 analog switch enable */
N#define TSC_IOASCR_G6_IO2_Pos    (21U)
N#define TSC_IOASCR_G6_IO2_Msk    (0x1UL << TSC_IOASCR_G6_IO2_Pos)              /*!< 0x00200000 */
N#define TSC_IOASCR_G6_IO2        TSC_IOASCR_G6_IO2_Msk                         /*!<GROUP6_IO2 analog switch enable */
N#define TSC_IOASCR_G6_IO3_Pos    (22U)
N#define TSC_IOASCR_G6_IO3_Msk    (0x1UL << TSC_IOASCR_G6_IO3_Pos)              /*!< 0x00400000 */
N#define TSC_IOASCR_G6_IO3        TSC_IOASCR_G6_IO3_Msk                         /*!<GROUP6_IO3 analog switch enable */
N#define TSC_IOASCR_G6_IO4_Pos    (23U)
N#define TSC_IOASCR_G6_IO4_Msk    (0x1UL << TSC_IOASCR_G6_IO4_Pos)              /*!< 0x00800000 */
N#define TSC_IOASCR_G6_IO4        TSC_IOASCR_G6_IO4_Msk                         /*!<GROUP6_IO4 analog switch enable */
N#define TSC_IOASCR_G7_IO1_Pos    (24U)
N#define TSC_IOASCR_G7_IO1_Msk    (0x1UL << TSC_IOASCR_G7_IO1_Pos)              /*!< 0x01000000 */
N#define TSC_IOASCR_G7_IO1        TSC_IOASCR_G7_IO1_Msk                         /*!<GROUP7_IO1 analog switch enable */
N#define TSC_IOASCR_G7_IO2_Pos    (25U)
N#define TSC_IOASCR_G7_IO2_Msk    (0x1UL << TSC_IOASCR_G7_IO2_Pos)              /*!< 0x02000000 */
N#define TSC_IOASCR_G7_IO2        TSC_IOASCR_G7_IO2_Msk                         /*!<GROUP7_IO2 analog switch enable */
N#define TSC_IOASCR_G7_IO3_Pos    (26U)
N#define TSC_IOASCR_G7_IO3_Msk    (0x1UL << TSC_IOASCR_G7_IO3_Pos)              /*!< 0x04000000 */
N#define TSC_IOASCR_G7_IO3        TSC_IOASCR_G7_IO3_Msk                         /*!<GROUP7_IO3 analog switch enable */
N#define TSC_IOASCR_G7_IO4_Pos    (27U)
N#define TSC_IOASCR_G7_IO4_Msk    (0x1UL << TSC_IOASCR_G7_IO4_Pos)              /*!< 0x08000000 */
N#define TSC_IOASCR_G7_IO4        TSC_IOASCR_G7_IO4_Msk                         /*!<GROUP7_IO4 analog switch enable */
N
N/*******************  Bit definition for TSC_IOSCR register  ******************/
N#define TSC_IOSCR_G1_IO1_Pos     (0U)
N#define TSC_IOSCR_G1_IO1_Msk     (0x1UL << TSC_IOSCR_G1_IO1_Pos)               /*!< 0x00000001 */
N#define TSC_IOSCR_G1_IO1         TSC_IOSCR_G1_IO1_Msk                          /*!<GROUP1_IO1 sampling mode */
N#define TSC_IOSCR_G1_IO2_Pos     (1U)
N#define TSC_IOSCR_G1_IO2_Msk     (0x1UL << TSC_IOSCR_G1_IO2_Pos)               /*!< 0x00000002 */
N#define TSC_IOSCR_G1_IO2         TSC_IOSCR_G1_IO2_Msk                          /*!<GROUP1_IO2 sampling mode */
N#define TSC_IOSCR_G1_IO3_Pos     (2U)
N#define TSC_IOSCR_G1_IO3_Msk     (0x1UL << TSC_IOSCR_G1_IO3_Pos)               /*!< 0x00000004 */
N#define TSC_IOSCR_G1_IO3         TSC_IOSCR_G1_IO3_Msk                          /*!<GROUP1_IO3 sampling mode */
N#define TSC_IOSCR_G1_IO4_Pos     (3U)
N#define TSC_IOSCR_G1_IO4_Msk     (0x1UL << TSC_IOSCR_G1_IO4_Pos)               /*!< 0x00000008 */
N#define TSC_IOSCR_G1_IO4         TSC_IOSCR_G1_IO4_Msk                          /*!<GROUP1_IO4 sampling mode */
N#define TSC_IOSCR_G2_IO1_Pos     (4U)
N#define TSC_IOSCR_G2_IO1_Msk     (0x1UL << TSC_IOSCR_G2_IO1_Pos)               /*!< 0x00000010 */
N#define TSC_IOSCR_G2_IO1         TSC_IOSCR_G2_IO1_Msk                          /*!<GROUP2_IO1 sampling mode */
N#define TSC_IOSCR_G2_IO2_Pos     (5U)
N#define TSC_IOSCR_G2_IO2_Msk     (0x1UL << TSC_IOSCR_G2_IO2_Pos)               /*!< 0x00000020 */
N#define TSC_IOSCR_G2_IO2         TSC_IOSCR_G2_IO2_Msk                          /*!<GROUP2_IO2 sampling mode */
N#define TSC_IOSCR_G2_IO3_Pos     (6U)
N#define TSC_IOSCR_G2_IO3_Msk     (0x1UL << TSC_IOSCR_G2_IO3_Pos)               /*!< 0x00000040 */
N#define TSC_IOSCR_G2_IO3         TSC_IOSCR_G2_IO3_Msk                          /*!<GROUP2_IO3 sampling mode */
N#define TSC_IOSCR_G2_IO4_Pos     (7U)
N#define TSC_IOSCR_G2_IO4_Msk     (0x1UL << TSC_IOSCR_G2_IO4_Pos)               /*!< 0x00000080 */
N#define TSC_IOSCR_G2_IO4         TSC_IOSCR_G2_IO4_Msk                          /*!<GROUP2_IO4 sampling mode */
N#define TSC_IOSCR_G3_IO1_Pos     (8U)
N#define TSC_IOSCR_G3_IO1_Msk     (0x1UL << TSC_IOSCR_G3_IO1_Pos)               /*!< 0x00000100 */
N#define TSC_IOSCR_G3_IO1         TSC_IOSCR_G3_IO1_Msk                          /*!<GROUP3_IO1 sampling mode */
N#define TSC_IOSCR_G3_IO2_Pos     (9U)
N#define TSC_IOSCR_G3_IO2_Msk     (0x1UL << TSC_IOSCR_G3_IO2_Pos)               /*!< 0x00000200 */
N#define TSC_IOSCR_G3_IO2         TSC_IOSCR_G3_IO2_Msk                          /*!<GROUP3_IO2 sampling mode */
N#define TSC_IOSCR_G3_IO3_Pos     (10U)
N#define TSC_IOSCR_G3_IO3_Msk     (0x1UL << TSC_IOSCR_G3_IO3_Pos)               /*!< 0x00000400 */
N#define TSC_IOSCR_G3_IO3         TSC_IOSCR_G3_IO3_Msk                          /*!<GROUP3_IO3 sampling mode */
N#define TSC_IOSCR_G3_IO4_Pos     (11U)
N#define TSC_IOSCR_G3_IO4_Msk     (0x1UL << TSC_IOSCR_G3_IO4_Pos)               /*!< 0x00000800 */
N#define TSC_IOSCR_G3_IO4         TSC_IOSCR_G3_IO4_Msk                          /*!<GROUP3_IO4 sampling mode */
N#define TSC_IOSCR_G4_IO1_Pos     (12U)
N#define TSC_IOSCR_G4_IO1_Msk     (0x1UL << TSC_IOSCR_G4_IO1_Pos)               /*!< 0x00001000 */
N#define TSC_IOSCR_G4_IO1         TSC_IOSCR_G4_IO1_Msk                          /*!<GROUP4_IO1 sampling mode */
N#define TSC_IOSCR_G4_IO2_Pos     (13U)
N#define TSC_IOSCR_G4_IO2_Msk     (0x1UL << TSC_IOSCR_G4_IO2_Pos)               /*!< 0x00002000 */
N#define TSC_IOSCR_G4_IO2         TSC_IOSCR_G4_IO2_Msk                          /*!<GROUP4_IO2 sampling mode */
N#define TSC_IOSCR_G4_IO3_Pos     (14U)
N#define TSC_IOSCR_G4_IO3_Msk     (0x1UL << TSC_IOSCR_G4_IO3_Pos)               /*!< 0x00004000 */
N#define TSC_IOSCR_G4_IO3         TSC_IOSCR_G4_IO3_Msk                          /*!<GROUP4_IO3 sampling mode */
N#define TSC_IOSCR_G4_IO4_Pos     (15U)
N#define TSC_IOSCR_G4_IO4_Msk     (0x1UL << TSC_IOSCR_G4_IO4_Pos)               /*!< 0x00008000 */
N#define TSC_IOSCR_G4_IO4         TSC_IOSCR_G4_IO4_Msk                          /*!<GROUP4_IO4 sampling mode */
N#define TSC_IOSCR_G5_IO1_Pos     (16U)
N#define TSC_IOSCR_G5_IO1_Msk     (0x1UL << TSC_IOSCR_G5_IO1_Pos)               /*!< 0x00010000 */
N#define TSC_IOSCR_G5_IO1         TSC_IOSCR_G5_IO1_Msk                          /*!<GROUP5_IO1 sampling mode */
N#define TSC_IOSCR_G5_IO2_Pos     (17U)
N#define TSC_IOSCR_G5_IO2_Msk     (0x1UL << TSC_IOSCR_G5_IO2_Pos)               /*!< 0x00020000 */
N#define TSC_IOSCR_G5_IO2         TSC_IOSCR_G5_IO2_Msk                          /*!<GROUP5_IO2 sampling mode */
N#define TSC_IOSCR_G5_IO3_Pos     (18U)
N#define TSC_IOSCR_G5_IO3_Msk     (0x1UL << TSC_IOSCR_G5_IO3_Pos)               /*!< 0x00040000 */
N#define TSC_IOSCR_G5_IO3         TSC_IOSCR_G5_IO3_Msk                          /*!<GROUP5_IO3 sampling mode */
N#define TSC_IOSCR_G5_IO4_Pos     (19U)
N#define TSC_IOSCR_G5_IO4_Msk     (0x1UL << TSC_IOSCR_G5_IO4_Pos)               /*!< 0x00080000 */
N#define TSC_IOSCR_G5_IO4         TSC_IOSCR_G5_IO4_Msk                          /*!<GROUP5_IO4 sampling mode */
N#define TSC_IOSCR_G6_IO1_Pos     (20U)
N#define TSC_IOSCR_G6_IO1_Msk     (0x1UL << TSC_IOSCR_G6_IO1_Pos)               /*!< 0x00100000 */
N#define TSC_IOSCR_G6_IO1         TSC_IOSCR_G6_IO1_Msk                          /*!<GROUP6_IO1 sampling mode */
N#define TSC_IOSCR_G6_IO2_Pos     (21U)
N#define TSC_IOSCR_G6_IO2_Msk     (0x1UL << TSC_IOSCR_G6_IO2_Pos)               /*!< 0x00200000 */
N#define TSC_IOSCR_G6_IO2         TSC_IOSCR_G6_IO2_Msk                          /*!<GROUP6_IO2 sampling mode */
N#define TSC_IOSCR_G6_IO3_Pos     (22U)
N#define TSC_IOSCR_G6_IO3_Msk     (0x1UL << TSC_IOSCR_G6_IO3_Pos)               /*!< 0x00400000 */
N#define TSC_IOSCR_G6_IO3         TSC_IOSCR_G6_IO3_Msk                          /*!<GROUP6_IO3 sampling mode */
N#define TSC_IOSCR_G6_IO4_Pos     (23U)
N#define TSC_IOSCR_G6_IO4_Msk     (0x1UL << TSC_IOSCR_G6_IO4_Pos)               /*!< 0x00800000 */
N#define TSC_IOSCR_G6_IO4         TSC_IOSCR_G6_IO4_Msk                          /*!<GROUP6_IO4 sampling mode */
N#define TSC_IOSCR_G7_IO1_Pos     (24U)
N#define TSC_IOSCR_G7_IO1_Msk     (0x1UL << TSC_IOSCR_G7_IO1_Pos)               /*!< 0x01000000 */
N#define TSC_IOSCR_G7_IO1         TSC_IOSCR_G7_IO1_Msk                          /*!<GROUP7_IO1 sampling mode */
N#define TSC_IOSCR_G7_IO2_Pos     (25U)
N#define TSC_IOSCR_G7_IO2_Msk     (0x1UL << TSC_IOSCR_G7_IO2_Pos)               /*!< 0x02000000 */
N#define TSC_IOSCR_G7_IO2         TSC_IOSCR_G7_IO2_Msk                          /*!<GROUP7_IO2 sampling mode */
N#define TSC_IOSCR_G7_IO3_Pos     (26U)
N#define TSC_IOSCR_G7_IO3_Msk     (0x1UL << TSC_IOSCR_G7_IO3_Pos)               /*!< 0x04000000 */
N#define TSC_IOSCR_G7_IO3         TSC_IOSCR_G7_IO3_Msk                          /*!<GROUP7_IO3 sampling mode */
N#define TSC_IOSCR_G7_IO4_Pos     (27U)
N#define TSC_IOSCR_G7_IO4_Msk     (0x1UL << TSC_IOSCR_G7_IO4_Pos)               /*!< 0x08000000 */
N#define TSC_IOSCR_G7_IO4         TSC_IOSCR_G7_IO4_Msk                          /*!<GROUP7_IO4 sampling mode */
N
N/*******************  Bit definition for TSC_IOCCR register  ******************/
N#define TSC_IOCCR_G1_IO1_Pos     (0U)
N#define TSC_IOCCR_G1_IO1_Msk     (0x1UL << TSC_IOCCR_G1_IO1_Pos)               /*!< 0x00000001 */
N#define TSC_IOCCR_G1_IO1         TSC_IOCCR_G1_IO1_Msk                          /*!<GROUP1_IO1 channel mode */
N#define TSC_IOCCR_G1_IO2_Pos     (1U)
N#define TSC_IOCCR_G1_IO2_Msk     (0x1UL << TSC_IOCCR_G1_IO2_Pos)               /*!< 0x00000002 */
N#define TSC_IOCCR_G1_IO2         TSC_IOCCR_G1_IO2_Msk                          /*!<GROUP1_IO2 channel mode */
N#define TSC_IOCCR_G1_IO3_Pos     (2U)
N#define TSC_IOCCR_G1_IO3_Msk     (0x1UL << TSC_IOCCR_G1_IO3_Pos)               /*!< 0x00000004 */
N#define TSC_IOCCR_G1_IO3         TSC_IOCCR_G1_IO3_Msk                          /*!<GROUP1_IO3 channel mode */
N#define TSC_IOCCR_G1_IO4_Pos     (3U)
N#define TSC_IOCCR_G1_IO4_Msk     (0x1UL << TSC_IOCCR_G1_IO4_Pos)               /*!< 0x00000008 */
N#define TSC_IOCCR_G1_IO4         TSC_IOCCR_G1_IO4_Msk                          /*!<GROUP1_IO4 channel mode */
N#define TSC_IOCCR_G2_IO1_Pos     (4U)
N#define TSC_IOCCR_G2_IO1_Msk     (0x1UL << TSC_IOCCR_G2_IO1_Pos)               /*!< 0x00000010 */
N#define TSC_IOCCR_G2_IO1         TSC_IOCCR_G2_IO1_Msk                          /*!<GROUP2_IO1 channel mode */
N#define TSC_IOCCR_G2_IO2_Pos     (5U)
N#define TSC_IOCCR_G2_IO2_Msk     (0x1UL << TSC_IOCCR_G2_IO2_Pos)               /*!< 0x00000020 */
N#define TSC_IOCCR_G2_IO2         TSC_IOCCR_G2_IO2_Msk                          /*!<GROUP2_IO2 channel mode */
N#define TSC_IOCCR_G2_IO3_Pos     (6U)
N#define TSC_IOCCR_G2_IO3_Msk     (0x1UL << TSC_IOCCR_G2_IO3_Pos)               /*!< 0x00000040 */
N#define TSC_IOCCR_G2_IO3         TSC_IOCCR_G2_IO3_Msk                          /*!<GROUP2_IO3 channel mode */
N#define TSC_IOCCR_G2_IO4_Pos     (7U)
N#define TSC_IOCCR_G2_IO4_Msk     (0x1UL << TSC_IOCCR_G2_IO4_Pos)               /*!< 0x00000080 */
N#define TSC_IOCCR_G2_IO4         TSC_IOCCR_G2_IO4_Msk                          /*!<GROUP2_IO4 channel mode */
N#define TSC_IOCCR_G3_IO1_Pos     (8U)
N#define TSC_IOCCR_G3_IO1_Msk     (0x1UL << TSC_IOCCR_G3_IO1_Pos)               /*!< 0x00000100 */
N#define TSC_IOCCR_G3_IO1         TSC_IOCCR_G3_IO1_Msk                          /*!<GROUP3_IO1 channel mode */
N#define TSC_IOCCR_G3_IO2_Pos     (9U)
N#define TSC_IOCCR_G3_IO2_Msk     (0x1UL << TSC_IOCCR_G3_IO2_Pos)               /*!< 0x00000200 */
N#define TSC_IOCCR_G3_IO2         TSC_IOCCR_G3_IO2_Msk                          /*!<GROUP3_IO2 channel mode */
N#define TSC_IOCCR_G3_IO3_Pos     (10U)
N#define TSC_IOCCR_G3_IO3_Msk     (0x1UL << TSC_IOCCR_G3_IO3_Pos)               /*!< 0x00000400 */
N#define TSC_IOCCR_G3_IO3         TSC_IOCCR_G3_IO3_Msk                          /*!<GROUP3_IO3 channel mode */
N#define TSC_IOCCR_G3_IO4_Pos     (11U)
N#define TSC_IOCCR_G3_IO4_Msk     (0x1UL << TSC_IOCCR_G3_IO4_Pos)               /*!< 0x00000800 */
N#define TSC_IOCCR_G3_IO4         TSC_IOCCR_G3_IO4_Msk                          /*!<GROUP3_IO4 channel mode */
N#define TSC_IOCCR_G4_IO1_Pos     (12U)
N#define TSC_IOCCR_G4_IO1_Msk     (0x1UL << TSC_IOCCR_G4_IO1_Pos)               /*!< 0x00001000 */
N#define TSC_IOCCR_G4_IO1         TSC_IOCCR_G4_IO1_Msk                          /*!<GROUP4_IO1 channel mode */
N#define TSC_IOCCR_G4_IO2_Pos     (13U)
N#define TSC_IOCCR_G4_IO2_Msk     (0x1UL << TSC_IOCCR_G4_IO2_Pos)               /*!< 0x00002000 */
N#define TSC_IOCCR_G4_IO2         TSC_IOCCR_G4_IO2_Msk                          /*!<GROUP4_IO2 channel mode */
N#define TSC_IOCCR_G4_IO3_Pos     (14U)
N#define TSC_IOCCR_G4_IO3_Msk     (0x1UL << TSC_IOCCR_G4_IO3_Pos)               /*!< 0x00004000 */
N#define TSC_IOCCR_G4_IO3         TSC_IOCCR_G4_IO3_Msk                          /*!<GROUP4_IO3 channel mode */
N#define TSC_IOCCR_G4_IO4_Pos     (15U)
N#define TSC_IOCCR_G4_IO4_Msk     (0x1UL << TSC_IOCCR_G4_IO4_Pos)               /*!< 0x00008000 */
N#define TSC_IOCCR_G4_IO4         TSC_IOCCR_G4_IO4_Msk                          /*!<GROUP4_IO4 channel mode */
N#define TSC_IOCCR_G5_IO1_Pos     (16U)
N#define TSC_IOCCR_G5_IO1_Msk     (0x1UL << TSC_IOCCR_G5_IO1_Pos)               /*!< 0x00010000 */
N#define TSC_IOCCR_G5_IO1         TSC_IOCCR_G5_IO1_Msk                          /*!<GROUP5_IO1 channel mode */
N#define TSC_IOCCR_G5_IO2_Pos     (17U)
N#define TSC_IOCCR_G5_IO2_Msk     (0x1UL << TSC_IOCCR_G5_IO2_Pos)               /*!< 0x00020000 */
N#define TSC_IOCCR_G5_IO2         TSC_IOCCR_G5_IO2_Msk                          /*!<GROUP5_IO2 channel mode */
N#define TSC_IOCCR_G5_IO3_Pos     (18U)
N#define TSC_IOCCR_G5_IO3_Msk     (0x1UL << TSC_IOCCR_G5_IO3_Pos)               /*!< 0x00040000 */
N#define TSC_IOCCR_G5_IO3         TSC_IOCCR_G5_IO3_Msk                          /*!<GROUP5_IO3 channel mode */
N#define TSC_IOCCR_G5_IO4_Pos     (19U)
N#define TSC_IOCCR_G5_IO4_Msk     (0x1UL << TSC_IOCCR_G5_IO4_Pos)               /*!< 0x00080000 */
N#define TSC_IOCCR_G5_IO4         TSC_IOCCR_G5_IO4_Msk                          /*!<GROUP5_IO4 channel mode */
N#define TSC_IOCCR_G6_IO1_Pos     (20U)
N#define TSC_IOCCR_G6_IO1_Msk     (0x1UL << TSC_IOCCR_G6_IO1_Pos)               /*!< 0x00100000 */
N#define TSC_IOCCR_G6_IO1         TSC_IOCCR_G6_IO1_Msk                          /*!<GROUP6_IO1 channel mode */
N#define TSC_IOCCR_G6_IO2_Pos     (21U)
N#define TSC_IOCCR_G6_IO2_Msk     (0x1UL << TSC_IOCCR_G6_IO2_Pos)               /*!< 0x00200000 */
N#define TSC_IOCCR_G6_IO2         TSC_IOCCR_G6_IO2_Msk                          /*!<GROUP6_IO2 channel mode */
N#define TSC_IOCCR_G6_IO3_Pos     (22U)
N#define TSC_IOCCR_G6_IO3_Msk     (0x1UL << TSC_IOCCR_G6_IO3_Pos)               /*!< 0x00400000 */
N#define TSC_IOCCR_G6_IO3         TSC_IOCCR_G6_IO3_Msk                          /*!<GROUP6_IO3 channel mode */
N#define TSC_IOCCR_G6_IO4_Pos     (23U)
N#define TSC_IOCCR_G6_IO4_Msk     (0x1UL << TSC_IOCCR_G6_IO4_Pos)               /*!< 0x00800000 */
N#define TSC_IOCCR_G6_IO4         TSC_IOCCR_G6_IO4_Msk                          /*!<GROUP6_IO4 channel mode */
N#define TSC_IOCCR_G7_IO1_Pos     (24U)
N#define TSC_IOCCR_G7_IO1_Msk     (0x1UL << TSC_IOCCR_G7_IO1_Pos)               /*!< 0x01000000 */
N#define TSC_IOCCR_G7_IO1         TSC_IOCCR_G7_IO1_Msk                          /*!<GROUP7_IO1 channel mode */
N#define TSC_IOCCR_G7_IO2_Pos     (25U)
N#define TSC_IOCCR_G7_IO2_Msk     (0x1UL << TSC_IOCCR_G7_IO2_Pos)               /*!< 0x02000000 */
N#define TSC_IOCCR_G7_IO2         TSC_IOCCR_G7_IO2_Msk                          /*!<GROUP7_IO2 channel mode */
N#define TSC_IOCCR_G7_IO3_Pos     (26U)
N#define TSC_IOCCR_G7_IO3_Msk     (0x1UL << TSC_IOCCR_G7_IO3_Pos)               /*!< 0x04000000 */
N#define TSC_IOCCR_G7_IO3         TSC_IOCCR_G7_IO3_Msk                          /*!<GROUP7_IO3 channel mode */
N#define TSC_IOCCR_G7_IO4_Pos     (27U)
N#define TSC_IOCCR_G7_IO4_Msk     (0x1UL << TSC_IOCCR_G7_IO4_Pos)               /*!< 0x08000000 */
N#define TSC_IOCCR_G7_IO4         TSC_IOCCR_G7_IO4_Msk                          /*!<GROUP7_IO4 channel mode */
N
N/*******************  Bit definition for TSC_IOGCSR register  *****************/
N#define TSC_IOGCSR_G1E_Pos       (0U)
N#define TSC_IOGCSR_G1E_Msk       (0x1UL << TSC_IOGCSR_G1E_Pos)                 /*!< 0x00000001 */
N#define TSC_IOGCSR_G1E           TSC_IOGCSR_G1E_Msk                            /*!<Analog IO GROUP1 enable */
N#define TSC_IOGCSR_G2E_Pos       (1U)
N#define TSC_IOGCSR_G2E_Msk       (0x1UL << TSC_IOGCSR_G2E_Pos)                 /*!< 0x00000002 */
N#define TSC_IOGCSR_G2E           TSC_IOGCSR_G2E_Msk                            /*!<Analog IO GROUP2 enable */
N#define TSC_IOGCSR_G3E_Pos       (2U)
N#define TSC_IOGCSR_G3E_Msk       (0x1UL << TSC_IOGCSR_G3E_Pos)                 /*!< 0x00000004 */
N#define TSC_IOGCSR_G3E           TSC_IOGCSR_G3E_Msk                            /*!<Analog IO GROUP3 enable */
N#define TSC_IOGCSR_G4E_Pos       (3U)
N#define TSC_IOGCSR_G4E_Msk       (0x1UL << TSC_IOGCSR_G4E_Pos)                 /*!< 0x00000008 */
N#define TSC_IOGCSR_G4E           TSC_IOGCSR_G4E_Msk                            /*!<Analog IO GROUP4 enable */
N#define TSC_IOGCSR_G5E_Pos       (4U)
N#define TSC_IOGCSR_G5E_Msk       (0x1UL << TSC_IOGCSR_G5E_Pos)                 /*!< 0x00000010 */
N#define TSC_IOGCSR_G5E           TSC_IOGCSR_G5E_Msk                            /*!<Analog IO GROUP5 enable */
N#define TSC_IOGCSR_G6E_Pos       (5U)
N#define TSC_IOGCSR_G6E_Msk       (0x1UL << TSC_IOGCSR_G6E_Pos)                 /*!< 0x00000020 */
N#define TSC_IOGCSR_G6E           TSC_IOGCSR_G6E_Msk                            /*!<Analog IO GROUP6 enable */
N#define TSC_IOGCSR_G7E_Pos       (6U)
N#define TSC_IOGCSR_G7E_Msk       (0x1UL << TSC_IOGCSR_G7E_Pos)                 /*!< 0x00000040 */
N#define TSC_IOGCSR_G7E           TSC_IOGCSR_G7E_Msk                            /*!<Analog IO GROUP7 enable */
N#define TSC_IOGCSR_G1S_Pos       (16U)
N#define TSC_IOGCSR_G1S_Msk       (0x1UL << TSC_IOGCSR_G1S_Pos)                 /*!< 0x00010000 */
N#define TSC_IOGCSR_G1S           TSC_IOGCSR_G1S_Msk                            /*!<Analog IO GROUP1 status */
N#define TSC_IOGCSR_G2S_Pos       (17U)
N#define TSC_IOGCSR_G2S_Msk       (0x1UL << TSC_IOGCSR_G2S_Pos)                 /*!< 0x00020000 */
N#define TSC_IOGCSR_G2S           TSC_IOGCSR_G2S_Msk                            /*!<Analog IO GROUP2 status */
N#define TSC_IOGCSR_G3S_Pos       (18U)
N#define TSC_IOGCSR_G3S_Msk       (0x1UL << TSC_IOGCSR_G3S_Pos)                 /*!< 0x00040000 */
N#define TSC_IOGCSR_G3S           TSC_IOGCSR_G3S_Msk                            /*!<Analog IO GROUP3 status */
N#define TSC_IOGCSR_G4S_Pos       (19U)
N#define TSC_IOGCSR_G4S_Msk       (0x1UL << TSC_IOGCSR_G4S_Pos)                 /*!< 0x00080000 */
N#define TSC_IOGCSR_G4S           TSC_IOGCSR_G4S_Msk                            /*!<Analog IO GROUP4 status */
N#define TSC_IOGCSR_G5S_Pos       (20U)
N#define TSC_IOGCSR_G5S_Msk       (0x1UL << TSC_IOGCSR_G5S_Pos)                 /*!< 0x00100000 */
N#define TSC_IOGCSR_G5S           TSC_IOGCSR_G5S_Msk                            /*!<Analog IO GROUP5 status */
N#define TSC_IOGCSR_G6S_Pos       (21U)
N#define TSC_IOGCSR_G6S_Msk       (0x1UL << TSC_IOGCSR_G6S_Pos)                 /*!< 0x00200000 */
N#define TSC_IOGCSR_G6S           TSC_IOGCSR_G6S_Msk                            /*!<Analog IO GROUP6 status */
N#define TSC_IOGCSR_G7S_Pos       (22U)
N#define TSC_IOGCSR_G7S_Msk       (0x1UL << TSC_IOGCSR_G7S_Pos)                 /*!< 0x00400000 */
N#define TSC_IOGCSR_G7S           TSC_IOGCSR_G7S_Msk                            /*!<Analog IO GROUP7 status */
N
N/*******************  Bit definition for TSC_IOGXCR register  *****************/
N#define TSC_IOGXCR_CNT_Pos       (0U)
N#define TSC_IOGXCR_CNT_Msk       (0x3FFFUL << TSC_IOGXCR_CNT_Pos)              /*!< 0x00003FFF */
N#define TSC_IOGXCR_CNT           TSC_IOGXCR_CNT_Msk                            /*!<CNT[13:0] bits (Counter value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N
N/*
N* @brief Specific device feature definitions (not present on all devices in the STM32L4 serie)
N*/
N#define USART_TCBGT_SUPPORT
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define USART_CR1_UE_Pos              (0U)
N#define USART_CR1_UE_Msk              (0x1UL << USART_CR1_UE_Pos)              /*!< 0x00000001 */
N#define USART_CR1_UE                  USART_CR1_UE_Msk                         /*!< USART Enable */
N#define USART_CR1_UESM_Pos            (1U)
N#define USART_CR1_UESM_Msk            (0x1UL << USART_CR1_UESM_Pos)            /*!< 0x00000002 */
N#define USART_CR1_UESM                USART_CR1_UESM_Msk                       /*!< USART Enable in STOP Mode */
N#define USART_CR1_RE_Pos              (2U)
N#define USART_CR1_RE_Msk              (0x1UL << USART_CR1_RE_Pos)              /*!< 0x00000004 */
N#define USART_CR1_RE                  USART_CR1_RE_Msk                         /*!< Receiver Enable */
N#define USART_CR1_TE_Pos              (3U)
N#define USART_CR1_TE_Msk              (0x1UL << USART_CR1_TE_Pos)              /*!< 0x00000008 */
N#define USART_CR1_TE                  USART_CR1_TE_Msk                         /*!< Transmitter Enable */
N#define USART_CR1_IDLEIE_Pos          (4U)
N#define USART_CR1_IDLEIE_Msk          (0x1UL << USART_CR1_IDLEIE_Pos)          /*!< 0x00000010 */
N#define USART_CR1_IDLEIE              USART_CR1_IDLEIE_Msk                     /*!< IDLE Interrupt Enable */
N#define USART_CR1_RXNEIE_Pos          (5U)
N#define USART_CR1_RXNEIE_Msk          (0x1UL << USART_CR1_RXNEIE_Pos)          /*!< 0x00000020 */
N#define USART_CR1_RXNEIE              USART_CR1_RXNEIE_Msk                     /*!< RXNE Interrupt Enable */
N#define USART_CR1_TCIE_Pos            (6U)
N#define USART_CR1_TCIE_Msk            (0x1UL << USART_CR1_TCIE_Pos)            /*!< 0x00000040 */
N#define USART_CR1_TCIE                USART_CR1_TCIE_Msk                       /*!< Transmission Complete Interrupt Enable */
N#define USART_CR1_TXEIE_Pos           (7U)
N#define USART_CR1_TXEIE_Msk           (0x1UL << USART_CR1_TXEIE_Pos)           /*!< 0x00000080 */
N#define USART_CR1_TXEIE               USART_CR1_TXEIE_Msk                      /*!< TXE Interrupt Enable */
N#define USART_CR1_PEIE_Pos            (8U)
N#define USART_CR1_PEIE_Msk            (0x1UL << USART_CR1_PEIE_Pos)            /*!< 0x00000100 */
N#define USART_CR1_PEIE                USART_CR1_PEIE_Msk                       /*!< PE Interrupt Enable */
N#define USART_CR1_PS_Pos              (9U)
N#define USART_CR1_PS_Msk              (0x1UL << USART_CR1_PS_Pos)              /*!< 0x00000200 */
N#define USART_CR1_PS                  USART_CR1_PS_Msk                         /*!< Parity Selection */
N#define USART_CR1_PCE_Pos             (10U)
N#define USART_CR1_PCE_Msk             (0x1UL << USART_CR1_PCE_Pos)             /*!< 0x00000400 */
N#define USART_CR1_PCE                 USART_CR1_PCE_Msk                        /*!< Parity Control Enable */
N#define USART_CR1_WAKE_Pos            (11U)
N#define USART_CR1_WAKE_Msk            (0x1UL << USART_CR1_WAKE_Pos)            /*!< 0x00000800 */
N#define USART_CR1_WAKE                USART_CR1_WAKE_Msk                       /*!< Receiver Wakeup method */
N#define USART_CR1_M_Pos               (12U)
N#define USART_CR1_M_Msk               (0x10001UL << USART_CR1_M_Pos)           /*!< 0x10001000 */
N#define USART_CR1_M                   USART_CR1_M_Msk                          /*!< Word length */
N#define USART_CR1_M0_Pos              (12U)
N#define USART_CR1_M0_Msk              (0x1UL << USART_CR1_M0_Pos)              /*!< 0x00001000 */
N#define USART_CR1_M0                  USART_CR1_M0_Msk                         /*!< Word length - Bit 0 */
N#define USART_CR1_MME_Pos             (13U)
N#define USART_CR1_MME_Msk             (0x1UL << USART_CR1_MME_Pos)             /*!< 0x00002000 */
N#define USART_CR1_MME                 USART_CR1_MME_Msk                        /*!< Mute Mode Enable */
N#define USART_CR1_CMIE_Pos            (14U)
N#define USART_CR1_CMIE_Msk            (0x1UL << USART_CR1_CMIE_Pos)            /*!< 0x00004000 */
N#define USART_CR1_CMIE                USART_CR1_CMIE_Msk                       /*!< Character match interrupt enable */
N#define USART_CR1_OVER8_Pos           (15U)
N#define USART_CR1_OVER8_Msk           (0x1UL << USART_CR1_OVER8_Pos)           /*!< 0x00008000 */
N#define USART_CR1_OVER8               USART_CR1_OVER8_Msk                      /*!< Oversampling by 8-bit or 16-bit mode */
N#define USART_CR1_DEDT_Pos            (16U)
N#define USART_CR1_DEDT_Msk            (0x1FUL << USART_CR1_DEDT_Pos)           /*!< 0x001F0000 */
N#define USART_CR1_DEDT                USART_CR1_DEDT_Msk                       /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define USART_CR1_DEDT_0              (0x01UL << USART_CR1_DEDT_Pos)           /*!< 0x00010000 */
N#define USART_CR1_DEDT_1              (0x02UL << USART_CR1_DEDT_Pos)           /*!< 0x00020000 */
N#define USART_CR1_DEDT_2              (0x04UL << USART_CR1_DEDT_Pos)           /*!< 0x00040000 */
N#define USART_CR1_DEDT_3              (0x08UL << USART_CR1_DEDT_Pos)           /*!< 0x00080000 */
N#define USART_CR1_DEDT_4              (0x10UL << USART_CR1_DEDT_Pos)           /*!< 0x00100000 */
N#define USART_CR1_DEAT_Pos            (21U)
N#define USART_CR1_DEAT_Msk            (0x1FUL << USART_CR1_DEAT_Pos)           /*!< 0x03E00000 */
N#define USART_CR1_DEAT                USART_CR1_DEAT_Msk                       /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
N#define USART_CR1_DEAT_0              (0x01UL << USART_CR1_DEAT_Pos)           /*!< 0x00200000 */
N#define USART_CR1_DEAT_1              (0x02UL << USART_CR1_DEAT_Pos)           /*!< 0x00400000 */
N#define USART_CR1_DEAT_2              (0x04UL << USART_CR1_DEAT_Pos)           /*!< 0x00800000 */
N#define USART_CR1_DEAT_3              (0x08UL << USART_CR1_DEAT_Pos)           /*!< 0x01000000 */
N#define USART_CR1_DEAT_4              (0x10UL << USART_CR1_DEAT_Pos)           /*!< 0x02000000 */
N#define USART_CR1_RTOIE_Pos           (26U)
N#define USART_CR1_RTOIE_Msk           (0x1UL << USART_CR1_RTOIE_Pos)           /*!< 0x04000000 */
N#define USART_CR1_RTOIE               USART_CR1_RTOIE_Msk                      /*!< Receive Time Out interrupt enable */
N#define USART_CR1_EOBIE_Pos           (27U)
N#define USART_CR1_EOBIE_Msk           (0x1UL << USART_CR1_EOBIE_Pos)           /*!< 0x08000000 */
N#define USART_CR1_EOBIE               USART_CR1_EOBIE_Msk                      /*!< End of Block interrupt enable */
N#define USART_CR1_M1_Pos              (28U)
N#define USART_CR1_M1_Msk              (0x1UL << USART_CR1_M1_Pos)              /*!< 0x10000000 */
N#define USART_CR1_M1                  USART_CR1_M1_Msk                         /*!< Word length - Bit 1 */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define USART_CR2_ADDM7_Pos           (4U)
N#define USART_CR2_ADDM7_Msk           (0x1UL << USART_CR2_ADDM7_Pos)           /*!< 0x00000010 */
N#define USART_CR2_ADDM7               USART_CR2_ADDM7_Msk                      /*!< 7-bit or 4-bit Address Detection */
N#define USART_CR2_LBDL_Pos            (5U)
N#define USART_CR2_LBDL_Msk            (0x1UL << USART_CR2_LBDL_Pos)            /*!< 0x00000020 */
N#define USART_CR2_LBDL                USART_CR2_LBDL_Msk                       /*!< LIN Break Detection Length */
N#define USART_CR2_LBDIE_Pos           (6U)
N#define USART_CR2_LBDIE_Msk           (0x1UL << USART_CR2_LBDIE_Pos)           /*!< 0x00000040 */
N#define USART_CR2_LBDIE               USART_CR2_LBDIE_Msk                      /*!< LIN Break Detection Interrupt Enable */
N#define USART_CR2_LBCL_Pos            (8U)
N#define USART_CR2_LBCL_Msk            (0x1UL << USART_CR2_LBCL_Pos)            /*!< 0x00000100 */
N#define USART_CR2_LBCL                USART_CR2_LBCL_Msk                       /*!< Last Bit Clock pulse */
N#define USART_CR2_CPHA_Pos            (9U)
N#define USART_CR2_CPHA_Msk            (0x1UL << USART_CR2_CPHA_Pos)            /*!< 0x00000200 */
N#define USART_CR2_CPHA                USART_CR2_CPHA_Msk                       /*!< Clock Phase */
N#define USART_CR2_CPOL_Pos            (10U)
N#define USART_CR2_CPOL_Msk            (0x1UL << USART_CR2_CPOL_Pos)            /*!< 0x00000400 */
N#define USART_CR2_CPOL                USART_CR2_CPOL_Msk                       /*!< Clock Polarity */
N#define USART_CR2_CLKEN_Pos           (11U)
N#define USART_CR2_CLKEN_Msk           (0x1UL << USART_CR2_CLKEN_Pos)           /*!< 0x00000800 */
N#define USART_CR2_CLKEN               USART_CR2_CLKEN_Msk                      /*!< Clock Enable */
N#define USART_CR2_STOP_Pos            (12U)
N#define USART_CR2_STOP_Msk            (0x3UL << USART_CR2_STOP_Pos)            /*!< 0x00003000 */
N#define USART_CR2_STOP                USART_CR2_STOP_Msk                       /*!< STOP[1:0] bits (STOP bits) */
N#define USART_CR2_STOP_0              (0x1UL << USART_CR2_STOP_Pos)            /*!< 0x00001000 */
N#define USART_CR2_STOP_1              (0x2UL << USART_CR2_STOP_Pos)            /*!< 0x00002000 */
N#define USART_CR2_LINEN_Pos           (14U)
N#define USART_CR2_LINEN_Msk           (0x1UL << USART_CR2_LINEN_Pos)           /*!< 0x00004000 */
N#define USART_CR2_LINEN               USART_CR2_LINEN_Msk                      /*!< LIN mode enable */
N#define USART_CR2_SWAP_Pos            (15U)
N#define USART_CR2_SWAP_Msk            (0x1UL << USART_CR2_SWAP_Pos)            /*!< 0x00008000 */
N#define USART_CR2_SWAP                USART_CR2_SWAP_Msk                       /*!< SWAP TX/RX pins */
N#define USART_CR2_RXINV_Pos           (16U)
N#define USART_CR2_RXINV_Msk           (0x1UL << USART_CR2_RXINV_Pos)           /*!< 0x00010000 */
N#define USART_CR2_RXINV               USART_CR2_RXINV_Msk                      /*!< RX pin active level inversion */
N#define USART_CR2_TXINV_Pos           (17U)
N#define USART_CR2_TXINV_Msk           (0x1UL << USART_CR2_TXINV_Pos)           /*!< 0x00020000 */
N#define USART_CR2_TXINV               USART_CR2_TXINV_Msk                      /*!< TX pin active level inversion */
N#define USART_CR2_DATAINV_Pos         (18U)
N#define USART_CR2_DATAINV_Msk         (0x1UL << USART_CR2_DATAINV_Pos)         /*!< 0x00040000 */
N#define USART_CR2_DATAINV             USART_CR2_DATAINV_Msk                    /*!< Binary data inversion */
N#define USART_CR2_MSBFIRST_Pos        (19U)
N#define USART_CR2_MSBFIRST_Msk        (0x1UL << USART_CR2_MSBFIRST_Pos)        /*!< 0x00080000 */
N#define USART_CR2_MSBFIRST            USART_CR2_MSBFIRST_Msk                   /*!< Most Significant Bit First */
N#define USART_CR2_ABREN_Pos           (20U)
N#define USART_CR2_ABREN_Msk           (0x1UL << USART_CR2_ABREN_Pos)           /*!< 0x00100000 */
N#define USART_CR2_ABREN               USART_CR2_ABREN_Msk                      /*!< Auto Baud-Rate Enable*/
N#define USART_CR2_ABRMODE_Pos         (21U)
N#define USART_CR2_ABRMODE_Msk         (0x3UL << USART_CR2_ABRMODE_Pos)         /*!< 0x00600000 */
N#define USART_CR2_ABRMODE             USART_CR2_ABRMODE_Msk                    /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define USART_CR2_ABRMODE_0           (0x1UL << USART_CR2_ABRMODE_Pos)         /*!< 0x00200000 */
N#define USART_CR2_ABRMODE_1           (0x2UL << USART_CR2_ABRMODE_Pos)         /*!< 0x00400000 */
N#define USART_CR2_RTOEN_Pos           (23U)
N#define USART_CR2_RTOEN_Msk           (0x1UL << USART_CR2_RTOEN_Pos)           /*!< 0x00800000 */
N#define USART_CR2_RTOEN               USART_CR2_RTOEN_Msk                      /*!< Receiver Time-Out enable */
N#define USART_CR2_ADD_Pos             (24U)
N#define USART_CR2_ADD_Msk             (0xFFUL << USART_CR2_ADD_Pos)            /*!< 0xFF000000 */
N#define USART_CR2_ADD                 USART_CR2_ADD_Msk                        /*!< Address of the USART node */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define USART_CR3_EIE_Pos             (0U)
N#define USART_CR3_EIE_Msk             (0x1UL << USART_CR3_EIE_Pos)             /*!< 0x00000001 */
N#define USART_CR3_EIE                 USART_CR3_EIE_Msk                        /*!< Error Interrupt Enable */
N#define USART_CR3_IREN_Pos            (1U)
N#define USART_CR3_IREN_Msk            (0x1UL << USART_CR3_IREN_Pos)            /*!< 0x00000002 */
N#define USART_CR3_IREN                USART_CR3_IREN_Msk                       /*!< IrDA mode Enable */
N#define USART_CR3_IRLP_Pos            (2U)
N#define USART_CR3_IRLP_Msk            (0x1UL << USART_CR3_IRLP_Pos)            /*!< 0x00000004 */
N#define USART_CR3_IRLP                USART_CR3_IRLP_Msk                       /*!< IrDA Low-Power */
N#define USART_CR3_HDSEL_Pos           (3U)
N#define USART_CR3_HDSEL_Msk           (0x1UL << USART_CR3_HDSEL_Pos)           /*!< 0x00000008 */
N#define USART_CR3_HDSEL               USART_CR3_HDSEL_Msk                      /*!< Half-Duplex Selection */
N#define USART_CR3_NACK_Pos            (4U)
N#define USART_CR3_NACK_Msk            (0x1UL << USART_CR3_NACK_Pos)            /*!< 0x00000010 */
N#define USART_CR3_NACK                USART_CR3_NACK_Msk                       /*!< SmartCard NACK enable */
N#define USART_CR3_SCEN_Pos            (5U)
N#define USART_CR3_SCEN_Msk            (0x1UL << USART_CR3_SCEN_Pos)            /*!< 0x00000020 */
N#define USART_CR3_SCEN                USART_CR3_SCEN_Msk                       /*!< SmartCard mode enable */
N#define USART_CR3_DMAR_Pos            (6U)
N#define USART_CR3_DMAR_Msk            (0x1UL << USART_CR3_DMAR_Pos)            /*!< 0x00000040 */
N#define USART_CR3_DMAR                USART_CR3_DMAR_Msk                       /*!< DMA Enable Receiver */
N#define USART_CR3_DMAT_Pos            (7U)
N#define USART_CR3_DMAT_Msk            (0x1UL << USART_CR3_DMAT_Pos)            /*!< 0x00000080 */
N#define USART_CR3_DMAT                USART_CR3_DMAT_Msk                       /*!< DMA Enable Transmitter */
N#define USART_CR3_RTSE_Pos            (8U)
N#define USART_CR3_RTSE_Msk            (0x1UL << USART_CR3_RTSE_Pos)            /*!< 0x00000100 */
N#define USART_CR3_RTSE                USART_CR3_RTSE_Msk                       /*!< RTS Enable */
N#define USART_CR3_CTSE_Pos            (9U)
N#define USART_CR3_CTSE_Msk            (0x1UL << USART_CR3_CTSE_Pos)            /*!< 0x00000200 */
N#define USART_CR3_CTSE                USART_CR3_CTSE_Msk                       /*!< CTS Enable */
N#define USART_CR3_CTSIE_Pos           (10U)
N#define USART_CR3_CTSIE_Msk           (0x1UL << USART_CR3_CTSIE_Pos)           /*!< 0x00000400 */
N#define USART_CR3_CTSIE               USART_CR3_CTSIE_Msk                      /*!< CTS Interrupt Enable */
N#define USART_CR3_ONEBIT_Pos          (11U)
N#define USART_CR3_ONEBIT_Msk          (0x1UL << USART_CR3_ONEBIT_Pos)          /*!< 0x00000800 */
N#define USART_CR3_ONEBIT              USART_CR3_ONEBIT_Msk                     /*!< One sample bit method enable */
N#define USART_CR3_OVRDIS_Pos          (12U)
N#define USART_CR3_OVRDIS_Msk          (0x1UL << USART_CR3_OVRDIS_Pos)          /*!< 0x00001000 */
N#define USART_CR3_OVRDIS              USART_CR3_OVRDIS_Msk                     /*!< Overrun Disable */
N#define USART_CR3_DDRE_Pos            (13U)
N#define USART_CR3_DDRE_Msk            (0x1UL << USART_CR3_DDRE_Pos)            /*!< 0x00002000 */
N#define USART_CR3_DDRE                USART_CR3_DDRE_Msk                       /*!< DMA Disable on Reception Error */
N#define USART_CR3_DEM_Pos             (14U)
N#define USART_CR3_DEM_Msk             (0x1UL << USART_CR3_DEM_Pos)             /*!< 0x00004000 */
N#define USART_CR3_DEM                 USART_CR3_DEM_Msk                        /*!< Driver Enable Mode */
N#define USART_CR3_DEP_Pos             (15U)
N#define USART_CR3_DEP_Msk             (0x1UL << USART_CR3_DEP_Pos)             /*!< 0x00008000 */
N#define USART_CR3_DEP                 USART_CR3_DEP_Msk                        /*!< Driver Enable Polarity Selection */
N#define USART_CR3_SCARCNT_Pos         (17U)
N#define USART_CR3_SCARCNT_Msk         (0x7UL << USART_CR3_SCARCNT_Pos)         /*!< 0x000E0000 */
N#define USART_CR3_SCARCNT             USART_CR3_SCARCNT_Msk                    /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N#define USART_CR3_SCARCNT_0           (0x1UL << USART_CR3_SCARCNT_Pos)         /*!< 0x00020000 */
N#define USART_CR3_SCARCNT_1           (0x2UL << USART_CR3_SCARCNT_Pos)         /*!< 0x00040000 */
N#define USART_CR3_SCARCNT_2           (0x4UL << USART_CR3_SCARCNT_Pos)         /*!< 0x00080000 */
N#define USART_CR3_WUS_Pos             (20U)
N#define USART_CR3_WUS_Msk             (0x3UL << USART_CR3_WUS_Pos)             /*!< 0x00300000 */
N#define USART_CR3_WUS                 USART_CR3_WUS_Msk                        /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
N#define USART_CR3_WUS_0               (0x1UL << USART_CR3_WUS_Pos)             /*!< 0x00100000 */
N#define USART_CR3_WUS_1               (0x2UL << USART_CR3_WUS_Pos)             /*!< 0x00200000 */
N#define USART_CR3_WUFIE_Pos           (22U)
N#define USART_CR3_WUFIE_Msk           (0x1UL << USART_CR3_WUFIE_Pos)           /*!< 0x00400000 */
N#define USART_CR3_WUFIE               USART_CR3_WUFIE_Msk                      /*!< Wake Up Interrupt Enable */
N#define USART_CR3_UCESM_Pos           (23U)
N#define USART_CR3_UCESM_Msk           (0x1UL << USART_CR3_UCESM_Pos)           /*!< 0x02000000 */
N#define USART_CR3_UCESM               USART_CR3_UCESM_Msk                      /*!< USART Clock enable in Stop mode */
N#define USART_CR3_TCBGTIE_Pos         (24U)
N#define USART_CR3_TCBGTIE_Msk         (0x1UL << USART_CR3_TCBGTIE_Pos)         /*!< 0x01000000 */
N#define USART_CR3_TCBGTIE             USART_CR3_TCBGTIE_Msk                    /*!< Transmission Complete Before Guard Time Interrupt Enable */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define USART_BRR_DIV_FRACTION_Pos    (0U)
N#define USART_BRR_DIV_FRACTION_Msk    (0xFUL << USART_BRR_DIV_FRACTION_Pos)    /*!< 0x0000000F */
N#define USART_BRR_DIV_FRACTION        USART_BRR_DIV_FRACTION_Msk               /*!< Fraction of USARTDIV */
N#define USART_BRR_DIV_MANTISSA_Pos    (4U)
N#define USART_BRR_DIV_MANTISSA_Msk    (0xFFFUL << USART_BRR_DIV_MANTISSA_Pos)  /*!< 0x0000FFF0 */
N#define USART_BRR_DIV_MANTISSA        USART_BRR_DIV_MANTISSA_Msk               /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define USART_GTPR_PSC_Pos            (0U)
N#define USART_GTPR_PSC_Msk            (0xFFUL << USART_GTPR_PSC_Pos)           /*!< 0x000000FF */
N#define USART_GTPR_PSC                USART_GTPR_PSC_Msk                       /*!< PSC[7:0] bits (Prescaler value) */
N#define USART_GTPR_GT_Pos             (8U)
N#define USART_GTPR_GT_Msk             (0xFFUL << USART_GTPR_GT_Pos)            /*!< 0x0000FF00 */
N#define USART_GTPR_GT                 USART_GTPR_GT_Msk                        /*!< GT[7:0] bits (Guard time value) */
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define USART_RTOR_RTO_Pos            (0U)
N#define USART_RTOR_RTO_Msk            (0xFFFFFFUL << USART_RTOR_RTO_Pos)       /*!< 0x00FFFFFF */
N#define USART_RTOR_RTO                USART_RTOR_RTO_Msk                       /*!< Receiver Time Out Value */
N#define USART_RTOR_BLEN_Pos           (24U)
N#define USART_RTOR_BLEN_Msk           (0xFFUL << USART_RTOR_BLEN_Pos)          /*!< 0xFF000000 */
N#define USART_RTOR_BLEN               USART_RTOR_BLEN_Msk                      /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define USART_RQR_ABRRQ_Pos           (0U)
N#define USART_RQR_ABRRQ_Msk           (0x1UL << USART_RQR_ABRRQ_Pos)           /*!< 0x00000001 */
N#define USART_RQR_ABRRQ               USART_RQR_ABRRQ_Msk                      /*!< Auto-Baud Rate Request */
N#define USART_RQR_SBKRQ_Pos           (1U)
N#define USART_RQR_SBKRQ_Msk           (0x1UL << USART_RQR_SBKRQ_Pos)           /*!< 0x00000002 */
N#define USART_RQR_SBKRQ               USART_RQR_SBKRQ_Msk                      /*!< Send Break Request */
N#define USART_RQR_MMRQ_Pos            (2U)
N#define USART_RQR_MMRQ_Msk            (0x1UL << USART_RQR_MMRQ_Pos)            /*!< 0x00000004 */
N#define USART_RQR_MMRQ                USART_RQR_MMRQ_Msk                       /*!< Mute Mode Request */
N#define USART_RQR_RXFRQ_Pos           (3U)
N#define USART_RQR_RXFRQ_Msk           (0x1UL << USART_RQR_RXFRQ_Pos)           /*!< 0x00000008 */
N#define USART_RQR_RXFRQ               USART_RQR_RXFRQ_Msk                      /*!< Receive Data flush Request */
N#define USART_RQR_TXFRQ_Pos           (4U)
N#define USART_RQR_TXFRQ_Msk           (0x1UL << USART_RQR_TXFRQ_Pos)           /*!< 0x00000010 */
N#define USART_RQR_TXFRQ               USART_RQR_TXFRQ_Msk                      /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define USART_ISR_PE_Pos              (0U)
N#define USART_ISR_PE_Msk              (0x1UL << USART_ISR_PE_Pos)              /*!< 0x00000001 */
N#define USART_ISR_PE                  USART_ISR_PE_Msk                         /*!< Parity Error */
N#define USART_ISR_FE_Pos              (1U)
N#define USART_ISR_FE_Msk              (0x1UL << USART_ISR_FE_Pos)              /*!< 0x00000002 */
N#define USART_ISR_FE                  USART_ISR_FE_Msk                         /*!< Framing Error */
N#define USART_ISR_NE_Pos              (2U)
N#define USART_ISR_NE_Msk              (0x1UL << USART_ISR_NE_Pos)              /*!< 0x00000004 */
N#define USART_ISR_NE                  USART_ISR_NE_Msk                         /*!< Noise Error detected Flag */
N#define USART_ISR_ORE_Pos             (3U)
N#define USART_ISR_ORE_Msk             (0x1UL << USART_ISR_ORE_Pos)             /*!< 0x00000008 */
N#define USART_ISR_ORE                 USART_ISR_ORE_Msk                        /*!< OverRun Error */
N#define USART_ISR_IDLE_Pos            (4U)
N#define USART_ISR_IDLE_Msk            (0x1UL << USART_ISR_IDLE_Pos)            /*!< 0x00000010 */
N#define USART_ISR_IDLE                USART_ISR_IDLE_Msk                       /*!< IDLE line detected */
N#define USART_ISR_RXNE_Pos            (5U)
N#define USART_ISR_RXNE_Msk            (0x1UL << USART_ISR_RXNE_Pos)            /*!< 0x00000020 */
N#define USART_ISR_RXNE                USART_ISR_RXNE_Msk                       /*!< Read Data Register Not Empty */
N#define USART_ISR_TC_Pos              (6U)
N#define USART_ISR_TC_Msk              (0x1UL << USART_ISR_TC_Pos)              /*!< 0x00000040 */
N#define USART_ISR_TC                  USART_ISR_TC_Msk                         /*!< Transmission Complete */
N#define USART_ISR_TXE_Pos             (7U)
N#define USART_ISR_TXE_Msk             (0x1UL << USART_ISR_TXE_Pos)             /*!< 0x00000080 */
N#define USART_ISR_TXE                 USART_ISR_TXE_Msk                        /*!< Transmit Data Register Empty */
N#define USART_ISR_LBDF_Pos            (8U)
N#define USART_ISR_LBDF_Msk            (0x1UL << USART_ISR_LBDF_Pos)            /*!< 0x00000100 */
N#define USART_ISR_LBDF                USART_ISR_LBDF_Msk                       /*!< LIN Break Detection Flag */
N#define USART_ISR_CTSIF_Pos           (9U)
N#define USART_ISR_CTSIF_Msk           (0x1UL << USART_ISR_CTSIF_Pos)           /*!< 0x00000200 */
N#define USART_ISR_CTSIF               USART_ISR_CTSIF_Msk                      /*!< CTS interrupt flag */
N#define USART_ISR_CTS_Pos             (10U)
N#define USART_ISR_CTS_Msk             (0x1UL << USART_ISR_CTS_Pos)             /*!< 0x00000400 */
N#define USART_ISR_CTS                 USART_ISR_CTS_Msk                        /*!< CTS flag */
N#define USART_ISR_RTOF_Pos            (11U)
N#define USART_ISR_RTOF_Msk            (0x1UL << USART_ISR_RTOF_Pos)            /*!< 0x00000800 */
N#define USART_ISR_RTOF                USART_ISR_RTOF_Msk                       /*!< Receiver Time Out */
N#define USART_ISR_EOBF_Pos            (12U)
N#define USART_ISR_EOBF_Msk            (0x1UL << USART_ISR_EOBF_Pos)            /*!< 0x00001000 */
N#define USART_ISR_EOBF                USART_ISR_EOBF_Msk                       /*!< End Of Block Flag */
N#define USART_ISR_ABRE_Pos            (14U)
N#define USART_ISR_ABRE_Msk            (0x1UL << USART_ISR_ABRE_Pos)            /*!< 0x00004000 */
N#define USART_ISR_ABRE                USART_ISR_ABRE_Msk                       /*!< Auto-Baud Rate Error */
N#define USART_ISR_ABRF_Pos            (15U)
N#define USART_ISR_ABRF_Msk            (0x1UL << USART_ISR_ABRF_Pos)            /*!< 0x00008000 */
N#define USART_ISR_ABRF                USART_ISR_ABRF_Msk                       /*!< Auto-Baud Rate Flag */
N#define USART_ISR_BUSY_Pos            (16U)
N#define USART_ISR_BUSY_Msk            (0x1UL << USART_ISR_BUSY_Pos)            /*!< 0x00010000 */
N#define USART_ISR_BUSY                USART_ISR_BUSY_Msk                       /*!< Busy Flag */
N#define USART_ISR_CMF_Pos             (17U)
N#define USART_ISR_CMF_Msk             (0x1UL << USART_ISR_CMF_Pos)             /*!< 0x00020000 */
N#define USART_ISR_CMF                 USART_ISR_CMF_Msk                        /*!< Character Match Flag */
N#define USART_ISR_SBKF_Pos            (18U)
N#define USART_ISR_SBKF_Msk            (0x1UL << USART_ISR_SBKF_Pos)            /*!< 0x00040000 */
N#define USART_ISR_SBKF                USART_ISR_SBKF_Msk                       /*!< Send Break Flag */
N#define USART_ISR_RWU_Pos             (19U)
N#define USART_ISR_RWU_Msk             (0x1UL << USART_ISR_RWU_Pos)             /*!< 0x00080000 */
N#define USART_ISR_RWU                 USART_ISR_RWU_Msk                        /*!< Receive Wake Up from mute mode Flag */
N#define USART_ISR_WUF_Pos             (20U)
N#define USART_ISR_WUF_Msk             (0x1UL << USART_ISR_WUF_Pos)             /*!< 0x00100000 */
N#define USART_ISR_WUF                 USART_ISR_WUF_Msk                        /*!< Wake Up from stop mode Flag */
N#define USART_ISR_TEACK_Pos           (21U)
N#define USART_ISR_TEACK_Msk           (0x1UL << USART_ISR_TEACK_Pos)           /*!< 0x00200000 */
N#define USART_ISR_TEACK               USART_ISR_TEACK_Msk                      /*!< Transmit Enable Acknowledge Flag */
N#define USART_ISR_REACK_Pos           (22U)
N#define USART_ISR_REACK_Msk           (0x1UL << USART_ISR_REACK_Pos)           /*!< 0x00400000 */
N#define USART_ISR_REACK               USART_ISR_REACK_Msk                      /*!< Receive Enable Acknowledge Flag */
N#define USART_ISR_TCBGT_Pos           (25U)
N#define USART_ISR_TCBGT_Msk           (0x1UL << USART_ISR_TCBGT_Pos)           /*!< 0x02000000 */
N#define USART_ISR_TCBGT               USART_ISR_TCBGT_Msk                      /*!< Transmission Complete Before Guard Time Completion Flag */
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define USART_ICR_PECF_Pos            (0U)
N#define USART_ICR_PECF_Msk            (0x1UL << USART_ICR_PECF_Pos)            /*!< 0x00000001 */
N#define USART_ICR_PECF                USART_ICR_PECF_Msk                       /*!< Parity Error Clear Flag */
N#define USART_ICR_FECF_Pos            (1U)
N#define USART_ICR_FECF_Msk            (0x1UL << USART_ICR_FECF_Pos)            /*!< 0x00000002 */
N#define USART_ICR_FECF                USART_ICR_FECF_Msk                       /*!< Framing Error Clear Flag */
N#define USART_ICR_NECF_Pos            (2U)
N#define USART_ICR_NECF_Msk            (0x1UL << USART_ICR_NECF_Pos)            /*!< 0x00000004 */
N#define USART_ICR_NECF                USART_ICR_NECF_Msk                       /*!< Noise Error detected Clear Flag */
N#define USART_ICR_ORECF_Pos           (3U)
N#define USART_ICR_ORECF_Msk           (0x1UL << USART_ICR_ORECF_Pos)           /*!< 0x00000008 */
N#define USART_ICR_ORECF               USART_ICR_ORECF_Msk                      /*!< OverRun Error Clear Flag */
N#define USART_ICR_IDLECF_Pos          (4U)
N#define USART_ICR_IDLECF_Msk          (0x1UL << USART_ICR_IDLECF_Pos)          /*!< 0x00000010 */
N#define USART_ICR_IDLECF              USART_ICR_IDLECF_Msk                     /*!< IDLE line detected Clear Flag */
N#define USART_ICR_TCCF_Pos            (6U)
N#define USART_ICR_TCCF_Msk            (0x1UL << USART_ICR_TCCF_Pos)            /*!< 0x00000040 */
N#define USART_ICR_TCCF                USART_ICR_TCCF_Msk                       /*!< Transmission Complete Clear Flag */
N#define USART_ICR_TCBGTCF_Pos         (7U)
N#define USART_ICR_TCBGTCF_Msk         (0x1UL << USART_ICR_TCBGTCF_Pos)         /*!< 0x00000080 */
N#define USART_ICR_TCBGTCF             USART_ICR_TCBGTCF_Msk                    /*!< Transmission Complete Before Guard Time Clear Flag */
N#define USART_ICR_LBDCF_Pos           (8U)
N#define USART_ICR_LBDCF_Msk           (0x1UL << USART_ICR_LBDCF_Pos)           /*!< 0x00000100 */
N#define USART_ICR_LBDCF               USART_ICR_LBDCF_Msk                      /*!< LIN Break Detection Clear Flag */
N#define USART_ICR_CTSCF_Pos           (9U)
N#define USART_ICR_CTSCF_Msk           (0x1UL << USART_ICR_CTSCF_Pos)           /*!< 0x00000200 */
N#define USART_ICR_CTSCF               USART_ICR_CTSCF_Msk                      /*!< CTS Interrupt Clear Flag */
N#define USART_ICR_RTOCF_Pos           (11U)
N#define USART_ICR_RTOCF_Msk           (0x1UL << USART_ICR_RTOCF_Pos)           /*!< 0x00000800 */
N#define USART_ICR_RTOCF               USART_ICR_RTOCF_Msk                      /*!< Receiver Time Out Clear Flag */
N#define USART_ICR_EOBCF_Pos           (12U)
N#define USART_ICR_EOBCF_Msk           (0x1UL << USART_ICR_EOBCF_Pos)           /*!< 0x00001000 */
N#define USART_ICR_EOBCF               USART_ICR_EOBCF_Msk                      /*!< End Of Block Clear Flag */
N#define USART_ICR_CMCF_Pos            (17U)
N#define USART_ICR_CMCF_Msk            (0x1UL << USART_ICR_CMCF_Pos)            /*!< 0x00020000 */
N#define USART_ICR_CMCF                USART_ICR_CMCF_Msk                       /*!< Character Match Clear Flag */
N#define USART_ICR_WUCF_Pos            (20U)
N#define USART_ICR_WUCF_Msk            (0x1UL << USART_ICR_WUCF_Pos)            /*!< 0x00100000 */
N#define USART_ICR_WUCF                USART_ICR_WUCF_Msk                       /*!< Wake Up from stop mode Clear Flag */
N
N/* Legacy defines */
N#define USART_ICR_NCF_Pos             USART_ICR_NECF_Pos
N#define USART_ICR_NCF_Msk             USART_ICR_NECF_Msk
N#define USART_ICR_NCF                 USART_ICR_NECF
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define USART_RDR_RDR_Pos             (0U)
N#define USART_RDR_RDR_Msk             (0x1FFUL << USART_RDR_RDR_Pos)           /*!< 0x000001FF */
N#define USART_RDR_RDR                 USART_RDR_RDR_Msk                        /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define USART_TDR_TDR_Pos             (0U)
N#define USART_TDR_TDR_Msk             (0x1FFUL << USART_TDR_TDR_Pos)           /*!< 0x000001FF */
N#define USART_TDR_TDR                 USART_TDR_TDR_Msk                        /*!< TDR[8:0] bits (Transmit Data value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*           Single Wire Protocol Master Interface (SWPMI)                    */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for SWPMI_CR register   ********************/
N#define SWPMI_CR_RXDMA_Pos       (0U)
N#define SWPMI_CR_RXDMA_Msk       (0x1UL << SWPMI_CR_RXDMA_Pos)                 /*!< 0x00000001 */
N#define SWPMI_CR_RXDMA           SWPMI_CR_RXDMA_Msk                            /*!<Reception DMA enable                                 */
N#define SWPMI_CR_TXDMA_Pos       (1U)
N#define SWPMI_CR_TXDMA_Msk       (0x1UL << SWPMI_CR_TXDMA_Pos)                 /*!< 0x00000002 */
N#define SWPMI_CR_TXDMA           SWPMI_CR_TXDMA_Msk                            /*!<Transmission DMA enable                              */
N#define SWPMI_CR_RXMODE_Pos      (2U)
N#define SWPMI_CR_RXMODE_Msk      (0x1UL << SWPMI_CR_RXMODE_Pos)                /*!< 0x00000004 */
N#define SWPMI_CR_RXMODE          SWPMI_CR_RXMODE_Msk                           /*!<Reception buffering mode                             */
N#define SWPMI_CR_TXMODE_Pos      (3U)
N#define SWPMI_CR_TXMODE_Msk      (0x1UL << SWPMI_CR_TXMODE_Pos)                /*!< 0x00000008 */
N#define SWPMI_CR_TXMODE          SWPMI_CR_TXMODE_Msk                           /*!<Transmission buffering mode                          */
N#define SWPMI_CR_LPBK_Pos        (4U)
N#define SWPMI_CR_LPBK_Msk        (0x1UL << SWPMI_CR_LPBK_Pos)                  /*!< 0x00000010 */
N#define SWPMI_CR_LPBK            SWPMI_CR_LPBK_Msk                             /*!<Loopback mode enable                                 */
N#define SWPMI_CR_SWPACT_Pos      (5U)
N#define SWPMI_CR_SWPACT_Msk      (0x1UL << SWPMI_CR_SWPACT_Pos)                /*!< 0x00000020 */
N#define SWPMI_CR_SWPACT          SWPMI_CR_SWPACT_Msk                           /*!<Single wire protocol master interface activate       */
N#define SWPMI_CR_DEACT_Pos       (10U)
N#define SWPMI_CR_DEACT_Msk       (0x1UL << SWPMI_CR_DEACT_Pos)                 /*!< 0x00000400 */
N#define SWPMI_CR_DEACT           SWPMI_CR_DEACT_Msk                            /*!<Single wire protocol master interface deactivate     */
N
N/*******************  Bit definition for SWPMI_BRR register  ********************/
N#define SWPMI_BRR_BR_Pos         (0U)
N#define SWPMI_BRR_BR_Msk         (0x3FUL << SWPMI_BRR_BR_Pos)                  /*!< 0x0000003F */
N#define SWPMI_BRR_BR             SWPMI_BRR_BR_Msk                              /*!<BR[5:0] bits (Bitrate prescaler) */
N
N/*******************  Bit definition for SWPMI_ISR register  ********************/
N#define SWPMI_ISR_RXBFF_Pos      (0U)
N#define SWPMI_ISR_RXBFF_Msk      (0x1UL << SWPMI_ISR_RXBFF_Pos)                /*!< 0x00000001 */
N#define SWPMI_ISR_RXBFF          SWPMI_ISR_RXBFF_Msk                           /*!<Receive buffer full flag        */
N#define SWPMI_ISR_TXBEF_Pos      (1U)
N#define SWPMI_ISR_TXBEF_Msk      (0x1UL << SWPMI_ISR_TXBEF_Pos)                /*!< 0x00000002 */
N#define SWPMI_ISR_TXBEF          SWPMI_ISR_TXBEF_Msk                           /*!<Transmit buffer empty flag      */
N#define SWPMI_ISR_RXBERF_Pos     (2U)
N#define SWPMI_ISR_RXBERF_Msk     (0x1UL << SWPMI_ISR_RXBERF_Pos)               /*!< 0x00000004 */
N#define SWPMI_ISR_RXBERF         SWPMI_ISR_RXBERF_Msk                          /*!<Receive CRC error flag          */
N#define SWPMI_ISR_RXOVRF_Pos     (3U)
N#define SWPMI_ISR_RXOVRF_Msk     (0x1UL << SWPMI_ISR_RXOVRF_Pos)               /*!< 0x00000008 */
N#define SWPMI_ISR_RXOVRF         SWPMI_ISR_RXOVRF_Msk                          /*!<Receive overrun error flag      */
N#define SWPMI_ISR_TXUNRF_Pos     (4U)
N#define SWPMI_ISR_TXUNRF_Msk     (0x1UL << SWPMI_ISR_TXUNRF_Pos)               /*!< 0x00000010 */
N#define SWPMI_ISR_TXUNRF         SWPMI_ISR_TXUNRF_Msk                          /*!<Transmit underrun error flag    */
N#define SWPMI_ISR_RXNE_Pos       (5U)
N#define SWPMI_ISR_RXNE_Msk       (0x1UL << SWPMI_ISR_RXNE_Pos)                 /*!< 0x00000020 */
N#define SWPMI_ISR_RXNE           SWPMI_ISR_RXNE_Msk                            /*!<Receive data register not empty */
N#define SWPMI_ISR_TXE_Pos        (6U)
N#define SWPMI_ISR_TXE_Msk        (0x1UL << SWPMI_ISR_TXE_Pos)                  /*!< 0x00000040 */
N#define SWPMI_ISR_TXE            SWPMI_ISR_TXE_Msk                             /*!<Transmit data register empty    */
N#define SWPMI_ISR_TCF_Pos        (7U)
N#define SWPMI_ISR_TCF_Msk        (0x1UL << SWPMI_ISR_TCF_Pos)                  /*!< 0x00000080 */
N#define SWPMI_ISR_TCF            SWPMI_ISR_TCF_Msk                             /*!<Transfer complete flag          */
N#define SWPMI_ISR_SRF_Pos        (8U)
N#define SWPMI_ISR_SRF_Msk        (0x1UL << SWPMI_ISR_SRF_Pos)                  /*!< 0x00000100 */
N#define SWPMI_ISR_SRF            SWPMI_ISR_SRF_Msk                             /*!<Slave resume flag               */
N#define SWPMI_ISR_SUSP_Pos       (9U)
N#define SWPMI_ISR_SUSP_Msk       (0x1UL << SWPMI_ISR_SUSP_Pos)                 /*!< 0x00000200 */
N#define SWPMI_ISR_SUSP           SWPMI_ISR_SUSP_Msk                            /*!<SUSPEND flag                    */
N#define SWPMI_ISR_DEACTF_Pos     (10U)
N#define SWPMI_ISR_DEACTF_Msk     (0x1UL << SWPMI_ISR_DEACTF_Pos)               /*!< 0x00000400 */
N#define SWPMI_ISR_DEACTF         SWPMI_ISR_DEACTF_Msk                          /*!<DEACTIVATED flag                */
N
N/*******************  Bit definition for SWPMI_ICR register  ********************/
N#define SWPMI_ICR_CRXBFF_Pos     (0U)
N#define SWPMI_ICR_CRXBFF_Msk     (0x1UL << SWPMI_ICR_CRXBFF_Pos)               /*!< 0x00000001 */
N#define SWPMI_ICR_CRXBFF         SWPMI_ICR_CRXBFF_Msk                          /*!<Clear receive buffer full flag       */
N#define SWPMI_ICR_CTXBEF_Pos     (1U)
N#define SWPMI_ICR_CTXBEF_Msk     (0x1UL << SWPMI_ICR_CTXBEF_Pos)               /*!< 0x00000002 */
N#define SWPMI_ICR_CTXBEF         SWPMI_ICR_CTXBEF_Msk                          /*!<Clear transmit buffer empty flag     */
N#define SWPMI_ICR_CRXBERF_Pos    (2U)
N#define SWPMI_ICR_CRXBERF_Msk    (0x1UL << SWPMI_ICR_CRXBERF_Pos)              /*!< 0x00000004 */
N#define SWPMI_ICR_CRXBERF        SWPMI_ICR_CRXBERF_Msk                         /*!<Clear receive CRC error flag         */
N#define SWPMI_ICR_CRXOVRF_Pos    (3U)
N#define SWPMI_ICR_CRXOVRF_Msk    (0x1UL << SWPMI_ICR_CRXOVRF_Pos)              /*!< 0x00000008 */
N#define SWPMI_ICR_CRXOVRF        SWPMI_ICR_CRXOVRF_Msk                         /*!<Clear receive overrun error flag     */
N#define SWPMI_ICR_CTXUNRF_Pos    (4U)
N#define SWPMI_ICR_CTXUNRF_Msk    (0x1UL << SWPMI_ICR_CTXUNRF_Pos)              /*!< 0x00000010 */
N#define SWPMI_ICR_CTXUNRF        SWPMI_ICR_CTXUNRF_Msk                         /*!<Clear transmit underrun error flag   */
N#define SWPMI_ICR_CTCF_Pos       (7U)
N#define SWPMI_ICR_CTCF_Msk       (0x1UL << SWPMI_ICR_CTCF_Pos)                 /*!< 0x00000080 */
N#define SWPMI_ICR_CTCF           SWPMI_ICR_CTCF_Msk                            /*!<Clear transfer complete flag         */
N#define SWPMI_ICR_CSRF_Pos       (8U)
N#define SWPMI_ICR_CSRF_Msk       (0x1UL << SWPMI_ICR_CSRF_Pos)                 /*!< 0x00000100 */
N#define SWPMI_ICR_CSRF           SWPMI_ICR_CSRF_Msk                            /*!<Clear slave resume flag              */
N
N/*******************  Bit definition for SWPMI_IER register  ********************/
N#define SWPMI_IER_SRIE_Pos       (8U)
N#define SWPMI_IER_SRIE_Msk       (0x1UL << SWPMI_IER_SRIE_Pos)                 /*!< 0x00000100 */
N#define SWPMI_IER_SRIE           SWPMI_IER_SRIE_Msk                            /*!<Slave resume interrupt enable               */
N#define SWPMI_IER_TCIE_Pos       (7U)
N#define SWPMI_IER_TCIE_Msk       (0x1UL << SWPMI_IER_TCIE_Pos)                 /*!< 0x00000080 */
N#define SWPMI_IER_TCIE           SWPMI_IER_TCIE_Msk                            /*!<Transmit complete interrupt enable          */
N#define SWPMI_IER_TIE_Pos        (6U)
N#define SWPMI_IER_TIE_Msk        (0x1UL << SWPMI_IER_TIE_Pos)                  /*!< 0x00000040 */
N#define SWPMI_IER_TIE            SWPMI_IER_TIE_Msk                             /*!<Transmit interrupt enable                   */
N#define SWPMI_IER_RIE_Pos        (5U)
N#define SWPMI_IER_RIE_Msk        (0x1UL << SWPMI_IER_RIE_Pos)                  /*!< 0x00000020 */
N#define SWPMI_IER_RIE            SWPMI_IER_RIE_Msk                             /*!<Receive interrupt enable                    */
N#define SWPMI_IER_TXUNRIE_Pos    (4U)
N#define SWPMI_IER_TXUNRIE_Msk    (0x1UL << SWPMI_IER_TXUNRIE_Pos)              /*!< 0x00000010 */
N#define SWPMI_IER_TXUNRIE        SWPMI_IER_TXUNRIE_Msk                         /*!<Transmit underrun error interrupt enable    */
N#define SWPMI_IER_RXOVRIE_Pos    (3U)
N#define SWPMI_IER_RXOVRIE_Msk    (0x1UL << SWPMI_IER_RXOVRIE_Pos)              /*!< 0x00000008 */
N#define SWPMI_IER_RXOVRIE        SWPMI_IER_RXOVRIE_Msk                         /*!<Receive overrun error interrupt enable      */
N#define SWPMI_IER_RXBERIE_Pos    (2U)
N#define SWPMI_IER_RXBERIE_Msk    (0x1UL << SWPMI_IER_RXBERIE_Pos)              /*!< 0x00000004 */
N#define SWPMI_IER_RXBERIE        SWPMI_IER_RXBERIE_Msk                         /*!<Receive CRC error interrupt enable          */
N#define SWPMI_IER_TXBEIE_Pos     (1U)
N#define SWPMI_IER_TXBEIE_Msk     (0x1UL << SWPMI_IER_TXBEIE_Pos)               /*!< 0x00000002 */
N#define SWPMI_IER_TXBEIE         SWPMI_IER_TXBEIE_Msk                          /*!<Transmit buffer empty interrupt enable      */
N#define SWPMI_IER_RXBFIE_Pos     (0U)
N#define SWPMI_IER_RXBFIE_Msk     (0x1UL << SWPMI_IER_RXBFIE_Pos)               /*!< 0x00000001 */
N#define SWPMI_IER_RXBFIE         SWPMI_IER_RXBFIE_Msk                          /*!<Receive buffer full interrupt enable        */
N
N/*******************  Bit definition for SWPMI_RFL register  ********************/
N#define SWPMI_RFL_RFL_Pos        (0U)
N#define SWPMI_RFL_RFL_Msk        (0x1FUL << SWPMI_RFL_RFL_Pos)                 /*!< 0x0000001F */
N#define SWPMI_RFL_RFL            SWPMI_RFL_RFL_Msk                             /*!<RFL[4:0] bits (Receive Frame length) */
N#define SWPMI_RFL_RFL_0_1_Pos    (0U)
N#define SWPMI_RFL_RFL_0_1_Msk    (0x3UL << SWPMI_RFL_RFL_0_1_Pos)              /*!< 0x00000003 */
N#define SWPMI_RFL_RFL_0_1        SWPMI_RFL_RFL_0_1_Msk                         /*!<RFL[1:0] bits (number of relevant bytes for the last SWPMI_RDR register read.) */
N
N/*******************  Bit definition for SWPMI_TDR register  ********************/
N#define SWPMI_TDR_TD_Pos         (0U)
N#define SWPMI_TDR_TD_Msk         (0xFFFFFFFFUL << SWPMI_TDR_TD_Pos)            /*!< 0xFFFFFFFF */
N#define SWPMI_TDR_TD             SWPMI_TDR_TD_Msk                              /*!<Transmit Data Register         */
N
N/*******************  Bit definition for SWPMI_RDR register  ********************/
N#define SWPMI_RDR_RD_Pos         (0U)
N#define SWPMI_RDR_RD_Msk         (0xFFFFFFFFUL << SWPMI_RDR_RD_Pos)            /*!< 0xFFFFFFFF */
N#define SWPMI_RDR_RD             SWPMI_RDR_RD_Msk                              /*!<Receive Data Register          */
N
N/*******************  Bit definition for SWPMI_OR register  ********************/
N#define SWPMI_OR_TBYP_Pos        (0U)
N#define SWPMI_OR_TBYP_Msk        (0x1UL << SWPMI_OR_TBYP_Pos)                  /*!< 0x00000001 */
N#define SWPMI_OR_TBYP            SWPMI_OR_TBYP_Msk                             /*!<SWP Transceiver Bypass */
N#define SWPMI_OR_CLASS_Pos       (1U)
N#define SWPMI_OR_CLASS_Msk       (0x1UL << SWPMI_OR_CLASS_Pos)                 /*!< 0x00000002 */
N#define SWPMI_OR_CLASS           SWPMI_OR_CLASS_Msk                            /*!<SWP Voltage Class selection */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 VREFBUF                                    */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for VREFBUF_CSR register  ****************/
N#define VREFBUF_CSR_ENVR_Pos    (0U)
N#define VREFBUF_CSR_ENVR_Msk    (0x1UL << VREFBUF_CSR_ENVR_Pos)                /*!< 0x00000001 */
N#define VREFBUF_CSR_ENVR        VREFBUF_CSR_ENVR_Msk                           /*!<Voltage reference buffer enable */
N#define VREFBUF_CSR_HIZ_Pos     (1U)
N#define VREFBUF_CSR_HIZ_Msk     (0x1UL << VREFBUF_CSR_HIZ_Pos)                 /*!< 0x00000002 */
N#define VREFBUF_CSR_HIZ         VREFBUF_CSR_HIZ_Msk                            /*!<High impedance mode             */
N#define VREFBUF_CSR_VRS_Pos     (2U)
N#define VREFBUF_CSR_VRS_Msk     (0x1UL << VREFBUF_CSR_VRS_Pos)                 /*!< 0x00000004 */
N#define VREFBUF_CSR_VRS         VREFBUF_CSR_VRS_Msk                            /*!<Voltage reference scale         */
N#define VREFBUF_CSR_VRR_Pos     (3U)
N#define VREFBUF_CSR_VRR_Msk     (0x1UL << VREFBUF_CSR_VRR_Pos)                 /*!< 0x00000008 */
N#define VREFBUF_CSR_VRR         VREFBUF_CSR_VRR_Msk                            /*!<Voltage reference buffer ready  */
N
N/*******************  Bit definition for VREFBUF_CCR register  ******************/
N#define VREFBUF_CCR_TRIM_Pos    (0U)
N#define VREFBUF_CCR_TRIM_Msk    (0x3FUL << VREFBUF_CCR_TRIM_Pos)               /*!< 0x0000003F */
N#define VREFBUF_CCR_TRIM        VREFBUF_CCR_TRIM_Msk                           /*!<TRIM[5:0] bits (Trimming code)  */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define WWDG_CR_T_Pos           (0U)
N#define WWDG_CR_T_Msk           (0x7FUL << WWDG_CR_T_Pos)                      /*!< 0x0000007F */
N#define WWDG_CR_T               WWDG_CR_T_Msk                                  /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define WWDG_CR_T_0             (0x01UL << WWDG_CR_T_Pos)                      /*!< 0x00000001 */
N#define WWDG_CR_T_1             (0x02UL << WWDG_CR_T_Pos)                      /*!< 0x00000002 */
N#define WWDG_CR_T_2             (0x04UL << WWDG_CR_T_Pos)                      /*!< 0x00000004 */
N#define WWDG_CR_T_3             (0x08UL << WWDG_CR_T_Pos)                      /*!< 0x00000008 */
N#define WWDG_CR_T_4             (0x10UL << WWDG_CR_T_Pos)                      /*!< 0x00000010 */
N#define WWDG_CR_T_5             (0x20UL << WWDG_CR_T_Pos)                      /*!< 0x00000020 */
N#define WWDG_CR_T_6             (0x40UL << WWDG_CR_T_Pos)                      /*!< 0x00000040 */
N
N#define WWDG_CR_WDGA_Pos        (7U)
N#define WWDG_CR_WDGA_Msk        (0x1UL << WWDG_CR_WDGA_Pos)                    /*!< 0x00000080 */
N#define WWDG_CR_WDGA            WWDG_CR_WDGA_Msk                               /*!<Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define WWDG_CFR_W_Pos          (0U)
N#define WWDG_CFR_W_Msk          (0x7FUL << WWDG_CFR_W_Pos)                     /*!< 0x0000007F */
N#define WWDG_CFR_W              WWDG_CFR_W_Msk                                 /*!<W[6:0] bits (7-bit window value) */
N#define WWDG_CFR_W_0            (0x01UL << WWDG_CFR_W_Pos)                     /*!< 0x00000001 */
N#define WWDG_CFR_W_1            (0x02UL << WWDG_CFR_W_Pos)                     /*!< 0x00000002 */
N#define WWDG_CFR_W_2            (0x04UL << WWDG_CFR_W_Pos)                     /*!< 0x00000004 */
N#define WWDG_CFR_W_3            (0x08UL << WWDG_CFR_W_Pos)                     /*!< 0x00000008 */
N#define WWDG_CFR_W_4            (0x10UL << WWDG_CFR_W_Pos)                     /*!< 0x00000010 */
N#define WWDG_CFR_W_5            (0x20UL << WWDG_CFR_W_Pos)                     /*!< 0x00000020 */
N#define WWDG_CFR_W_6            (0x40UL << WWDG_CFR_W_Pos)                     /*!< 0x00000040 */
N
N#define WWDG_CFR_WDGTB_Pos      (7U)
N#define WWDG_CFR_WDGTB_Msk      (0x3UL << WWDG_CFR_WDGTB_Pos)                  /*!< 0x00000180 */
N#define WWDG_CFR_WDGTB          WWDG_CFR_WDGTB_Msk                             /*!<WDGTB[1:0] bits (Timer Base) */
N#define WWDG_CFR_WDGTB_0        (0x1UL << WWDG_CFR_WDGTB_Pos)                  /*!< 0x00000080 */
N#define WWDG_CFR_WDGTB_1        (0x2UL << WWDG_CFR_WDGTB_Pos)                  /*!< 0x00000100 */
N
N#define WWDG_CFR_EWI_Pos        (9U)
N#define WWDG_CFR_EWI_Msk        (0x1UL << WWDG_CFR_EWI_Pos)                    /*!< 0x00000200 */
N#define WWDG_CFR_EWI            WWDG_CFR_EWI_Msk                               /*!<Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define WWDG_SR_EWIF_Pos        (0U)
N#define WWDG_SR_EWIF_Msk        (0x1UL << WWDG_SR_EWIF_Pos)                    /*!< 0x00000001 */
N#define WWDG_SR_EWIF            WWDG_SR_EWIF_Msk                               /*!<Early Wakeup Interrupt Flag */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 Debug MCU                                  */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DBGMCU_IDCODE register  *************/
N#define DBGMCU_IDCODE_DEV_ID_Pos               (0U)
N#define DBGMCU_IDCODE_DEV_ID_Msk               (0xFFFUL << DBGMCU_IDCODE_DEV_ID_Pos) /*!< 0x00000FFF */
N#define DBGMCU_IDCODE_DEV_ID                   DBGMCU_IDCODE_DEV_ID_Msk
N#define DBGMCU_IDCODE_REV_ID_Pos               (16U)
N#define DBGMCU_IDCODE_REV_ID_Msk               (0xFFFFUL << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0xFFFF0000 */
N#define DBGMCU_IDCODE_REV_ID                   DBGMCU_IDCODE_REV_ID_Msk
N
N/********************  Bit definition for DBGMCU_CR register  *****************/
N#define DBGMCU_CR_DBG_SLEEP_Pos                (0U)
N#define DBGMCU_CR_DBG_SLEEP_Msk                (0x1UL << DBGMCU_CR_DBG_SLEEP_Pos) /*!< 0x00000001 */
N#define DBGMCU_CR_DBG_SLEEP                    DBGMCU_CR_DBG_SLEEP_Msk
N#define DBGMCU_CR_DBG_STOP_Pos                 (1U)
N#define DBGMCU_CR_DBG_STOP_Msk                 (0x1UL << DBGMCU_CR_DBG_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_CR_DBG_STOP                     DBGMCU_CR_DBG_STOP_Msk
N#define DBGMCU_CR_DBG_STANDBY_Pos              (2U)
N#define DBGMCU_CR_DBG_STANDBY_Msk              (0x1UL << DBGMCU_CR_DBG_STANDBY_Pos) /*!< 0x00000004 */
N#define DBGMCU_CR_DBG_STANDBY                  DBGMCU_CR_DBG_STANDBY_Msk
N#define DBGMCU_CR_TRACE_IOEN_Pos               (5U)
N#define DBGMCU_CR_TRACE_IOEN_Msk               (0x1UL << DBGMCU_CR_TRACE_IOEN_Pos) /*!< 0x00000020 */
N#define DBGMCU_CR_TRACE_IOEN                   DBGMCU_CR_TRACE_IOEN_Msk
N
N#define DBGMCU_CR_TRACE_MODE_Pos               (6U)
N#define DBGMCU_CR_TRACE_MODE_Msk               (0x3UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x000000C0 */
N#define DBGMCU_CR_TRACE_MODE                   DBGMCU_CR_TRACE_MODE_Msk
N#define DBGMCU_CR_TRACE_MODE_0                 (0x1UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000040 */
N#define DBGMCU_CR_TRACE_MODE_1                 (0x2UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000080 */
N
N/********************  Bit definition for DBGMCU_APB1FZR1 register  ***********/
N#define DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos      (0U)
N#define DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos) /*!< 0x00000001 */
N#define DBGMCU_APB1FZR1_DBG_TIM2_STOP          DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_TIM6_STOP_Pos      (4U)
N#define DBGMCU_APB1FZR1_DBG_TIM6_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_TIM6_STOP_Pos) /*!< 0x00000010 */
N#define DBGMCU_APB1FZR1_DBG_TIM6_STOP          DBGMCU_APB1FZR1_DBG_TIM6_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_TIM7_STOP_Pos      (5U)
N#define DBGMCU_APB1FZR1_DBG_TIM7_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_TIM7_STOP_Pos) /*!< 0x00000020 */
N#define DBGMCU_APB1FZR1_DBG_TIM7_STOP          DBGMCU_APB1FZR1_DBG_TIM7_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos       (10U)
N#define DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk       (0x1UL << DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos) /*!< 0x00000400 */
N#define DBGMCU_APB1FZR1_DBG_RTC_STOP           DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos      (11U)
N#define DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos) /*!< 0x00000800 */
N#define DBGMCU_APB1FZR1_DBG_WWDG_STOP          DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos      (12U)
N#define DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos) /*!< 0x00001000 */
N#define DBGMCU_APB1FZR1_DBG_IWDG_STOP          DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos      (21U)
N#define DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos) /*!< 0x00200000 */
N#define DBGMCU_APB1FZR1_DBG_I2C1_STOP          DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_I2C2_STOP_Pos      (22U)
N#define DBGMCU_APB1FZR1_DBG_I2C2_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_I2C2_STOP_Pos) /*!< 0x00400000 */
N#define DBGMCU_APB1FZR1_DBG_I2C2_STOP          DBGMCU_APB1FZR1_DBG_I2C2_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos      (23U)
N#define DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk      (0x1UL << DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos) /*!< 0x00800000 */
N#define DBGMCU_APB1FZR1_DBG_I2C3_STOP          DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_CAN_STOP_Pos       (25U)
N#define DBGMCU_APB1FZR1_DBG_CAN_STOP_Msk       (0x1UL << DBGMCU_APB1FZR1_DBG_CAN_STOP_Pos) /*!< 0x02000000 */
N#define DBGMCU_APB1FZR1_DBG_CAN_STOP           DBGMCU_APB1FZR1_DBG_CAN_STOP_Msk
N#define DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos    (31U)
N#define DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk    (0x1UL << DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos) /*!< 0x80000000 */
N#define DBGMCU_APB1FZR1_DBG_LPTIM1_STOP        DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk
N
N/********************  Bit definition for DBGMCU_APB1FZR2 register  **********/
N#define DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Pos    (5U)
N#define DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Msk    (0x1UL << DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Pos) /*!< 0x00000020 */
N#define DBGMCU_APB1FZR2_DBG_LPTIM2_STOP        DBGMCU_APB1FZR2_DBG_LPTIM2_STOP_Msk
N
N/********************  Bit definition for DBGMCU_APB2FZ register  ************/
N#define DBGMCU_APB2FZ_DBG_TIM1_STOP_Pos        (11U)
N#define DBGMCU_APB2FZ_DBG_TIM1_STOP_Msk        (0x1UL << DBGMCU_APB2FZ_DBG_TIM1_STOP_Pos) /*!< 0x00000800 */
N#define DBGMCU_APB2FZ_DBG_TIM1_STOP            DBGMCU_APB2FZ_DBG_TIM1_STOP_Msk
N#define DBGMCU_APB2FZ_DBG_TIM15_STOP_Pos       (16U)
N#define DBGMCU_APB2FZ_DBG_TIM15_STOP_Msk       (0x1UL << DBGMCU_APB2FZ_DBG_TIM15_STOP_Pos) /*!< 0x00010000 */
N#define DBGMCU_APB2FZ_DBG_TIM15_STOP           DBGMCU_APB2FZ_DBG_TIM15_STOP_Msk
N#define DBGMCU_APB2FZ_DBG_TIM16_STOP_Pos       (17U)
N#define DBGMCU_APB2FZ_DBG_TIM16_STOP_Msk       (0x1UL << DBGMCU_APB2FZ_DBG_TIM16_STOP_Pos) /*!< 0x00020000 */
N#define DBGMCU_APB2FZ_DBG_TIM16_STOP           DBGMCU_APB2FZ_DBG_TIM16_STOP_Msk
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N
N/******************************* ADC Instances ********************************/
N#define IS_ADC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)
N
N#define IS_ADC_COMMON_INSTANCE(INSTANCE) ((INSTANCE) == ADC1_COMMON)
N
N/******************************** CAN Instances ******************************/
N#define IS_CAN_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CAN1)
N
N/******************************** COMP Instances ******************************/
N#define IS_COMP_ALL_INSTANCE(INSTANCE) (((INSTANCE) == COMP1) || \
N                                        ((INSTANCE) == COMP2))
X#define IS_COMP_ALL_INSTANCE(INSTANCE) (((INSTANCE) == COMP1) ||                                         ((INSTANCE) == COMP2))
N
N#define IS_COMP_COMMON_INSTANCE(COMMON_INSTANCE) ((COMMON_INSTANCE) == COMP12_COMMON)
N
N/******************** COMP Instances with window mode capability **************/
N#define IS_COMP_WINDOWMODE_INSTANCE(INSTANCE) ((INSTANCE) == COMP2)
N
N/******************************* CRC Instances ********************************/
N#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)
N
N/******************************* DAC Instances ********************************/
N#define IS_DAC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == DAC1)
N
N/******************************** DMA Instances *******************************/
N#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) || \
N                                       ((INSTANCE) == DMA1_Channel2) || \
N                                       ((INSTANCE) == DMA1_Channel3) || \
N                                       ((INSTANCE) == DMA1_Channel4) || \
N                                       ((INSTANCE) == DMA1_Channel5) || \
N                                       ((INSTANCE) == DMA1_Channel6) || \
N                                       ((INSTANCE) == DMA1_Channel7) || \
N                                       ((INSTANCE) == DMA2_Channel1) || \
N                                       ((INSTANCE) == DMA2_Channel2) || \
N                                       ((INSTANCE) == DMA2_Channel3) || \
N                                       ((INSTANCE) == DMA2_Channel4) || \
N                                       ((INSTANCE) == DMA2_Channel5) || \
N                                       ((INSTANCE) == DMA2_Channel6) || \
N                                       ((INSTANCE) == DMA2_Channel7))
X#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) ||                                        ((INSTANCE) == DMA1_Channel2) ||                                        ((INSTANCE) == DMA1_Channel3) ||                                        ((INSTANCE) == DMA1_Channel4) ||                                        ((INSTANCE) == DMA1_Channel5) ||                                        ((INSTANCE) == DMA1_Channel6) ||                                        ((INSTANCE) == DMA1_Channel7) ||                                        ((INSTANCE) == DMA2_Channel1) ||                                        ((INSTANCE) == DMA2_Channel2) ||                                        ((INSTANCE) == DMA2_Channel3) ||                                        ((INSTANCE) == DMA2_Channel4) ||                                        ((INSTANCE) == DMA2_Channel5) ||                                        ((INSTANCE) == DMA2_Channel6) ||                                        ((INSTANCE) == DMA2_Channel7))
N
N/******************************* GPIO Instances *******************************/
N#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || \
N                                        ((INSTANCE) == GPIOB) || \
N                                        ((INSTANCE) == GPIOC) || \
N                                        ((INSTANCE) == GPIOD) || \
N                                        ((INSTANCE) == GPIOE) || \
N                                        ((INSTANCE) == GPIOH))
X#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) ||                                         ((INSTANCE) == GPIOB) ||                                         ((INSTANCE) == GPIOC) ||                                         ((INSTANCE) == GPIOD) ||                                         ((INSTANCE) == GPIOE) ||                                         ((INSTANCE) == GPIOH))
N
N/******************************* GPIO AF Instances ****************************/
N/* On L4, all GPIO Bank support AF */
N#define IS_GPIO_AF_INSTANCE(INSTANCE)   IS_GPIO_ALL_INSTANCE(INSTANCE)
N
N/**************************** GPIO Lock Instances *****************************/
N/* On L4, all GPIO Bank support the Lock mechanism */
N#define IS_GPIO_LOCK_INSTANCE(INSTANCE) IS_GPIO_ALL_INSTANCE(INSTANCE)
N
N/******************************** I2C Instances *******************************/
N#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || \
N                                       ((INSTANCE) == I2C2) || \
N                                       ((INSTANCE) == I2C3))
X#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) ||                                        ((INSTANCE) == I2C2) ||                                        ((INSTANCE) == I2C3))
N
N/****************** I2C Instances : wakeup capability from stop modes *********/
N#define IS_I2C_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) IS_I2C_ALL_INSTANCE(INSTANCE)
N
N/****************************** OPAMP Instances *******************************/
N#define IS_OPAMP_ALL_INSTANCE(INSTANCE) ((INSTANCE) == OPAMP1)
N
N#define IS_OPAMP_COMMON_INSTANCE(COMMON_INSTANCE) ((COMMON_INSTANCE) == OPAMP1_COMMON)
N
N/******************************* QSPI Instances *******************************/
N#define IS_QSPI_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == QUADSPI)
N
N/******************************* RNG Instances ********************************/
N#define IS_RNG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RNG)
N
N/****************************** RTC Instances *********************************/
N#define IS_RTC_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RTC)
N
N/******************************** SAI Instances *******************************/
N#define IS_SAI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SAI1_Block_A) || \
N                                       ((INSTANCE) == SAI1_Block_B))
X#define IS_SAI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SAI1_Block_A) ||                                        ((INSTANCE) == SAI1_Block_B))
N
N/****************************** SDMMC Instances *******************************/
N#define IS_SDMMC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == SDMMC1)
N
N/****************************** SMBUS Instances *******************************/
N#define IS_SMBUS_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || \
N                                         ((INSTANCE) == I2C2) || \
N                                         ((INSTANCE) == I2C3))
X#define IS_SMBUS_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) ||                                          ((INSTANCE) == I2C2) ||                                          ((INSTANCE) == I2C3))
N
N/******************************** SPI Instances *******************************/
N#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || \
N                                       ((INSTANCE) == SPI2) || \
N                                       ((INSTANCE) == SPI3))
X#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) ||                                        ((INSTANCE) == SPI2) ||                                        ((INSTANCE) == SPI3))
N
N/******************************** SWPMI Instances *****************************/
N#define IS_SWPMI_INSTANCE(INSTANCE)  ((INSTANCE) == SWPMI1)
N
N/****************** LPTIM Instances : All supported instances *****************/
N#define IS_LPTIM_INSTANCE(INSTANCE)     (((INSTANCE) == LPTIM1) || \
N                                         ((INSTANCE) == LPTIM2))
X#define IS_LPTIM_INSTANCE(INSTANCE)     (((INSTANCE) == LPTIM1) ||                                          ((INSTANCE) == LPTIM2))
N
N/****************** TIM Instances : All supported instances *******************/
N#define IS_TIM_INSTANCE(INSTANCE)       (((INSTANCE) == TIM1)   || \
N                                         ((INSTANCE) == TIM2)   || \
N                                         ((INSTANCE) == TIM6)   || \
N                                         ((INSTANCE) == TIM7)   || \
N                                         ((INSTANCE) == TIM15)  || \
N                                         ((INSTANCE) == TIM16))
X#define IS_TIM_INSTANCE(INSTANCE)       (((INSTANCE) == TIM1)   ||                                          ((INSTANCE) == TIM2)   ||                                          ((INSTANCE) == TIM6)   ||                                          ((INSTANCE) == TIM7)   ||                                          ((INSTANCE) == TIM15)  ||                                          ((INSTANCE) == TIM16))
N
N/****************** TIM Instances : supporting 32 bits counter ****************/
N#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE) ((INSTANCE) == TIM2)
N
N/****************** TIM Instances : supporting the break function *************/
N#define IS_TIM_BREAK_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)    || \
N                                            ((INSTANCE) == TIM15)   || \
N                                            ((INSTANCE) == TIM16))
X#define IS_TIM_BREAK_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)    ||                                             ((INSTANCE) == TIM15)   ||                                             ((INSTANCE) == TIM16))
N
N/************** TIM Instances : supporting Break source selection *************/
N#define IS_TIM_BREAKSOURCE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   || \
N                                               ((INSTANCE) == TIM15)  || \
N                                               ((INSTANCE) == TIM16))
X#define IS_TIM_BREAKSOURCE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   ||                                                ((INSTANCE) == TIM15)  ||                                                ((INSTANCE) == TIM16))
N
N/****************** TIM Instances : supporting 2 break inputs *****************/
N#define IS_TIM_BKIN2_INSTANCE(INSTANCE)    ((INSTANCE) == TIM1)
N
N/************* TIM Instances : at least 1 capture/compare channel *************/
N#define IS_TIM_CC1_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   || \
N                                         ((INSTANCE) == TIM2)   || \
N                                         ((INSTANCE) == TIM15)  || \
N                                         ((INSTANCE) == TIM16))
X#define IS_TIM_CC1_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   ||                                          ((INSTANCE) == TIM2)   ||                                          ((INSTANCE) == TIM15)  ||                                          ((INSTANCE) == TIM16))
N
N/************ TIM Instances : at least 2 capture/compare channels *************/
N#define IS_TIM_CC2_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   || \
N                                         ((INSTANCE) == TIM2)   || \
N                                         ((INSTANCE) == TIM15))
X#define IS_TIM_CC2_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   ||                                          ((INSTANCE) == TIM2)   ||                                          ((INSTANCE) == TIM15))
N
N/************ TIM Instances : at least 3 capture/compare channels *************/
N#define IS_TIM_CC3_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   || \
N                                         ((INSTANCE) == TIM2))
X#define IS_TIM_CC3_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   ||                                          ((INSTANCE) == TIM2))
N
N/************ TIM Instances : at least 4 capture/compare channels *************/
N#define IS_TIM_CC4_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   || \
N                                         ((INSTANCE) == TIM2))
X#define IS_TIM_CC4_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   ||                                          ((INSTANCE) == TIM2))
N
N/****************** TIM Instances : at least 5 capture/compare channels *******/
N#define IS_TIM_CC5_INSTANCE(INSTANCE)   ((INSTANCE) == TIM1)
N
N/****************** TIM Instances : at least 6 capture/compare channels *******/
N#define IS_TIM_CC6_INSTANCE(INSTANCE)   ((INSTANCE) == TIM1)
N
N/************ TIM Instances : DMA requests generation (TIMx_DIER.COMDE) *******/
N#define IS_TIM_CCDMA_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)   || \
N                                            ((INSTANCE) == TIM15)  || \
N                                            ((INSTANCE) == TIM16))
X#define IS_TIM_CCDMA_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)   ||                                             ((INSTANCE) == TIM15)  ||                                             ((INSTANCE) == TIM16))
N
N/****************** TIM Instances : DMA requests generation (TIMx_DIER.UDE) ***/
N#define IS_TIM_DMA_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)   || \
N                                            ((INSTANCE) == TIM2)   || \
N                                            ((INSTANCE) == TIM6)   || \
N                                            ((INSTANCE) == TIM7)   || \
N                                            ((INSTANCE) == TIM15)  || \
N                                            ((INSTANCE) == TIM16))
X#define IS_TIM_DMA_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)   ||                                             ((INSTANCE) == TIM2)   ||                                             ((INSTANCE) == TIM6)   ||                                             ((INSTANCE) == TIM7)   ||                                             ((INSTANCE) == TIM15)  ||                                             ((INSTANCE) == TIM16))
N
N/************ TIM Instances : DMA requests generation (TIMx_DIER.CCxDE) *******/
N#define IS_TIM_DMA_CC_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   || \
N                                            ((INSTANCE) == TIM2)   || \
N                                            ((INSTANCE) == TIM15)  || \
N                                            ((INSTANCE) == TIM16))
X#define IS_TIM_DMA_CC_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)   ||                                             ((INSTANCE) == TIM2)   ||                                             ((INSTANCE) == TIM15)  ||                                             ((INSTANCE) == TIM16))
N
N/******************** TIM Instances : DMA burst feature ***********************/
N#define IS_TIM_DMABURST_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   || \
N                                            ((INSTANCE) == TIM2)   || \
N                                            ((INSTANCE) == TIM15)  || \
N                                            ((INSTANCE) == TIM16))
X#define IS_TIM_DMABURST_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   ||                                             ((INSTANCE) == TIM2)   ||                                             ((INSTANCE) == TIM15)  ||                                             ((INSTANCE) == TIM16))
N
N/******************* TIM Instances : output(s) available **********************/
N#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL) \
N    ((((INSTANCE) == TIM1) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4) ||          \
N      ((CHANNEL) == TIM_CHANNEL_5) ||          \
N      ((CHANNEL) == TIM_CHANNEL_6)))           \
N     ||                                        \
N     (((INSTANCE) == TIM2) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N     ||                                        \
N     (((INSTANCE) == TIM15) &&                 \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2)))           \
N     ||                                        \
N     (((INSTANCE) == TIM16) &&                 \
N     (((CHANNEL) == TIM_CHANNEL_1))))
X#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL)     ((((INSTANCE) == TIM1) &&                       (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4) ||                ((CHANNEL) == TIM_CHANNEL_5) ||                ((CHANNEL) == TIM_CHANNEL_6)))                ||                                             (((INSTANCE) == TIM2) &&                       (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))                ||                                             (((INSTANCE) == TIM15) &&                      (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2)))                ||                                             (((INSTANCE) == TIM16) &&                      (((CHANNEL) == TIM_CHANNEL_1))))
N
N/****************** TIM Instances : supporting complementary output(s) ********/
N#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL) \
N   ((((INSTANCE) == TIM1) &&                    \
N     (((CHANNEL) == TIM_CHANNEL_1) ||           \
N      ((CHANNEL) == TIM_CHANNEL_2) ||           \
N      ((CHANNEL) == TIM_CHANNEL_3)))            \
N    ||                                          \
N    (((INSTANCE) == TIM15) &&                   \
N     ((CHANNEL) == TIM_CHANNEL_1))              \
N    ||                                          \
N    (((INSTANCE) == TIM16) &&                   \
N     ((CHANNEL) == TIM_CHANNEL_1)))
X#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL)    ((((INSTANCE) == TIM1) &&                         (((CHANNEL) == TIM_CHANNEL_1) ||                 ((CHANNEL) == TIM_CHANNEL_2) ||                 ((CHANNEL) == TIM_CHANNEL_3)))                ||                                              (((INSTANCE) == TIM15) &&                        ((CHANNEL) == TIM_CHANNEL_1))                  ||                                              (((INSTANCE) == TIM16) &&                        ((CHANNEL) == TIM_CHANNEL_1)))
N
N/****************** TIM Instances : supporting clock division *****************/
N#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)    || \
N                                                    ((INSTANCE) == TIM2)    || \
N                                                    ((INSTANCE) == TIM15)   || \
N                                                    ((INSTANCE) == TIM16))
X#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)    ||                                                     ((INSTANCE) == TIM2)    ||                                                     ((INSTANCE) == TIM15)   ||                                                     ((INSTANCE) == TIM16))
N
N/****** TIM Instances : supporting external clock mode 1 for ETRF input *******/
N#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM15))
X#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM15))
N
N/****** TIM Instances : supporting external clock mode 2 for ETRF input *******/
N#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2))
X#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2))
N
N/****************** TIM Instances : supporting external clock mode 1 for TIX inputs*/
N#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM15))
X#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM15))
N
N/****************** TIM Instances : supporting internal trigger inputs(ITRX) *******/
N#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)     (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM15))
X#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)     (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM15))
N
N/****************** TIM Instances : supporting combined 3-phase PWM mode ******/
N#define IS_TIM_COMBINED3PHASEPWM_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)
N
N/****************** TIM Instances : supporting commutation event generation ***/
N#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   || \
N                                                     ((INSTANCE) == TIM15)  || \
N                                                     ((INSTANCE) == TIM16))
X#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   ||                                                      ((INSTANCE) == TIM15)  ||                                                      ((INSTANCE) == TIM16))
N
N/****************** TIM Instances : supporting counting mode selection ********/
N#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2))
X#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2))
N
N/****************** TIM Instances : supporting encoder interface **************/
N#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)  || \
N                                                      ((INSTANCE) == TIM2))
X#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)  ||                                                       ((INSTANCE) == TIM2))
N
N/****************** TIM Instances : supporting Hall sensor interface **********/
N#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                          ((INSTANCE) == TIM2))
X#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                           ((INSTANCE) == TIM2))
N
N/**************** TIM Instances : external trigger input available ************/
N#define IS_TIM_ETR_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)  || \
N                                            ((INSTANCE) == TIM2))
X#define IS_TIM_ETR_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)  ||                                             ((INSTANCE) == TIM2))
N
N/************* TIM Instances : supporting ETR source selection ***************/
N#define IS_TIM_ETRSEL_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)  || \
N                                             ((INSTANCE) == TIM2))
X#define IS_TIM_ETRSEL_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)  ||                                              ((INSTANCE) == TIM2))
N
N/****** TIM Instances : Master mode available (TIMx_CR2.MMS available )********/
N#define IS_TIM_MASTER_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)  || \
N                                            ((INSTANCE) == TIM2)  || \
N                                            ((INSTANCE) == TIM6)  || \
N                                            ((INSTANCE) == TIM7)  || \
N                                            ((INSTANCE) == TIM15))
X#define IS_TIM_MASTER_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)  ||                                             ((INSTANCE) == TIM2)  ||                                             ((INSTANCE) == TIM6)  ||                                             ((INSTANCE) == TIM7)  ||                                             ((INSTANCE) == TIM15))
N
N/*********** TIM Instances : Slave mode available (TIMx_SMCR available )*******/
N#define IS_TIM_SLAVE_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)  || \
N                                            ((INSTANCE) == TIM2)  || \
N                                            ((INSTANCE) == TIM15))
X#define IS_TIM_SLAVE_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)  ||                                             ((INSTANCE) == TIM2)  ||                                             ((INSTANCE) == TIM15))
N
N/****************** TIM Instances : supporting OCxREF clear *******************/
N#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)        (((INSTANCE) == TIM1) || \
N                                                       ((INSTANCE) == TIM2))
X#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)        (((INSTANCE) == TIM1) ||                                                        ((INSTANCE) == TIM2))
N
N/****************** TIM Instances : remapping capability **********************/
N#define IS_TIM_REMAP_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)  || \
N                                            ((INSTANCE) == TIM2)  || \
N                                            ((INSTANCE) == TIM15) || \
N                                            ((INSTANCE) == TIM16))
X#define IS_TIM_REMAP_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)  ||                                             ((INSTANCE) == TIM2)  ||                                             ((INSTANCE) == TIM15) ||                                             ((INSTANCE) == TIM16))
N
N/****************** TIM Instances : supporting repetition counter *************/
N#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)  || \
N                                                       ((INSTANCE) == TIM15) || \
N                                                       ((INSTANCE) == TIM16))
X#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)  ||                                                        ((INSTANCE) == TIM15) ||                                                        ((INSTANCE) == TIM16))
N
N/****************** TIM Instances : supporting synchronization ****************/
N#define IS_TIM_SYNCHRO_INSTANCE(INSTANCE)  IS_TIM_MASTER_INSTANCE(INSTANCE)
N
N/****************** TIM Instances : supporting ADC triggering through TRGO2 ***/
N#define IS_TIM_TRGO2_INSTANCE(INSTANCE)    ((INSTANCE) == TIM1)
N
N/******************* TIM Instances : Timer input XOR function *****************/
N#define IS_TIM_XOR_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)   || \
N                                            ((INSTANCE) == TIM2)   || \
N                                            ((INSTANCE) == TIM15))
X#define IS_TIM_XOR_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)   ||                                             ((INSTANCE) == TIM2)   ||                                             ((INSTANCE) == TIM15))
N
N/****************** TIM Instances : Advanced timer instances *******************/
N#define IS_TIM_ADVANCED_INSTANCE(INSTANCE)    ((INSTANCE) == TIM1)
N
N/****************************** TSC Instances *********************************/
N#define IS_TSC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == TSC)
N
N/******************** USART Instances : Synchronous mode **********************/
N#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                     ((INSTANCE) == USART2) || \
N                                     ((INSTANCE) == USART3))
X#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                      ((INSTANCE) == USART2) ||                                      ((INSTANCE) == USART3))
N
N/******************** UART Instances : Asynchronous mode **********************/
N#define IS_UART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                    ((INSTANCE) == USART2) || \
N                                    ((INSTANCE) == USART3))
X#define IS_UART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                     ((INSTANCE) == USART2) ||                                     ((INSTANCE) == USART3))
N
N/****************** UART Instances : Auto Baud Rate detection ****************/
N#define IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                                            ((INSTANCE) == USART2) || \
N                                                            ((INSTANCE) == USART3))
X#define IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                                             ((INSTANCE) == USART2) ||                                                             ((INSTANCE) == USART3))
N
N/****************** UART Instances : Driver Enable *****************/
N#define IS_UART_DRIVER_ENABLE_INSTANCE(INSTANCE)     (((INSTANCE) == USART1) || \
N                                                      ((INSTANCE) == USART2) || \
N                                                      ((INSTANCE) == USART3) || \
N                                                      ((INSTANCE) == LPUART1))
X#define IS_UART_DRIVER_ENABLE_INSTANCE(INSTANCE)     (((INSTANCE) == USART1) ||                                                       ((INSTANCE) == USART2) ||                                                       ((INSTANCE) == USART3) ||                                                       ((INSTANCE) == LPUART1))
N
N/******************** UART Instances : Half-Duplex mode **********************/
N#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) || \
N                                                 ((INSTANCE) == USART2) || \
N                                                 ((INSTANCE) == USART3) || \
N                                                 ((INSTANCE) == LPUART1))
X#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) ||                                                  ((INSTANCE) == USART2) ||                                                  ((INSTANCE) == USART3) ||                                                  ((INSTANCE) == LPUART1))
N
N/****************** UART Instances : Hardware Flow control ********************/
N#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                           ((INSTANCE) == USART2) || \
N                                           ((INSTANCE) == USART3) || \
N                                           ((INSTANCE) == LPUART1))
X#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                            ((INSTANCE) == USART2) ||                                            ((INSTANCE) == USART3) ||                                            ((INSTANCE) == LPUART1))
N
N/******************** UART Instances : LIN mode **********************/
N#define IS_UART_LIN_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) || \
N                                          ((INSTANCE) == USART2) || \
N                                          ((INSTANCE) == USART3))
X#define IS_UART_LIN_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) ||                                           ((INSTANCE) == USART2) ||                                           ((INSTANCE) == USART3))
N
N/******************** UART Instances : Wake-up from Stop mode **********************/
N#define IS_UART_WAKEUP_FROMSTOP_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) || \
N                                                      ((INSTANCE) == USART2) || \
N                                                      ((INSTANCE) == USART3) || \
N                                                      ((INSTANCE) == LPUART1))
X#define IS_UART_WAKEUP_FROMSTOP_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) ||                                                       ((INSTANCE) == USART2) ||                                                       ((INSTANCE) == USART3) ||                                                       ((INSTANCE) == LPUART1))
N
N/*********************** UART Instances : IRDA mode ***************************/
N#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                    ((INSTANCE) == USART2) || \
N                                    ((INSTANCE) == USART3))
X#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                     ((INSTANCE) == USART2) ||                                     ((INSTANCE) == USART3))
N
N/********************* USART Instances : Smard card mode ***********************/
N#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                         ((INSTANCE) == USART2) || \
N                                         ((INSTANCE) == USART3))
X#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                          ((INSTANCE) == USART2) ||                                          ((INSTANCE) == USART3))
N
N/******************** LPUART Instance *****************************************/
N#define IS_LPUART_INSTANCE(INSTANCE)    ((INSTANCE) == LPUART1)
N
N/****************************** IWDG Instances ********************************/
N#define IS_IWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == IWDG)
N
N/****************************** WWDG Instances ********************************/
N#define IS_WWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == WWDG)
N
N/**
N  * @}
N  */
N
N
N/******************************************************************************/
N/*  For a painless codes migration between the STM32L4xx device product       */
N/*  lines, the aliases defined below are put in place to overcome the         */
N/*  differences in the interrupt handlers and IRQn definitions.               */
N/*  No need to update developed interrupt code when moving across             */
N/*  product lines within the same STM32L4 Family                              */
N/******************************************************************************/
N
N/* Aliases for __IRQn */
N#define ADC1_2_IRQn                    ADC1_IRQn
N#define TIM1_TRG_COM_TIM17_IRQn        TIM1_TRG_COM_IRQn
N#define HASH_RNG_IRQn                  RNG_IRQn
N#define HASH_CRS_IRQn                  CRS_IRQn
N
N/* Aliases for __IRQHandler */
N#define ADC1_2_IRQHandler              ADC1_IRQHandler
N#define TIM1_TRG_COM_TIM17_IRQHandler  TIM1_TRG_COM_IRQHandler
N#define HASH_RNG_IRQHandler            RNG_IRQHandler
N#define HASH_CRS_IRQHandler            CRS_IRQHandler
N
N#ifdef __cplusplus
N}
N#endif /* __cplusplus */
N
N#endif /* __STM32L431xx_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 129 ".\Source\Core\inc\stm32l4xx.h" 2
N#elif defined(STM32L432xx)
S  #include "stm32l432xx.h"
S#elif defined(STM32L433xx)
S  #include "stm32l433xx.h"
S#elif defined(STM32L442xx)
S  #include "stm32l442xx.h"
S#elif defined(STM32L443xx)
S  #include "stm32l443xx.h"
S#elif defined(STM32L451xx)
S  #include "stm32l451xx.h"
S#elif defined(STM32L452xx)
S  #include "stm32l452xx.h"
S#elif defined(STM32L462xx)
S  #include "stm32l462xx.h"
S#elif defined(STM32L471xx)
S  #include "stm32l471xx.h"
S#elif defined(STM32L475xx)
S  #include "stm32l475xx.h"
S#elif defined(STM32L476xx)
S  #include "stm32l476xx.h"
S#elif defined(STM32L485xx)
S  #include "stm32l485xx.h"
S#elif defined(STM32L486xx)
S  #include "stm32l486xx.h"
S#elif defined(STM32L496xx)
S  #include "stm32l496xx.h"
S#elif defined(STM32L4A6xx)
S  #include "stm32l4a6xx.h"
S#elif defined(STM32L4R5xx)
S  #include "stm32l4r5xx.h"
S#elif defined(STM32L4R7xx)
S  #include "stm32l4r7xx.h"
S#elif defined(STM32L4R9xx)
S  #include "stm32l4r9xx.h"
S#elif defined(STM32L4S5xx)
S  #include "stm32l4s5xx.h"
S#elif defined(STM32L4S7xx)
S  #include "stm32l4s7xx.h"
S#elif defined(STM32L4S9xx)
S  #include "stm32l4s9xx.h"
S#else
S #error "Please select first the target STM32L4xx device used in your application (in stm32l4xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_types
N  * @{
N  */
Ntypedef enum
N{
N  RESET = 0,
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum
N{
N  DISABLE = 0,
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum
N{
N  SUCCESS = 0,
N  ERROR = !SUCCESS
N} ErrorStatus;
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define POSITION_VAL(VAL)     (__CLZ(__RBIT(VAL)))
N
N
N/**
N  * @}
N  */
N
N#if defined (USE_HAL_DRIVER)
X#if 0L
S #include "stm32l4xx_hal.h"
N#endif /* USE_HAL_DRIVER */
N
N#ifdef __cplusplus
N}
N#endif /* __cplusplus */
N
N#endif /* __STM32L4xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_usart.h" 2
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (USART1) || defined (USART2) || defined (USART3) || defined (UART4) || defined (UART5)
X#if 1L || 1L || 1L || 0L || 0L
N
N/** @defgroup USART_LL USART
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S/** @defgroup USART_LL_Private_Variables USART Private Variables
S  * @{
S  */
S/* Array used to get the USART prescaler division decimal values versus @ref USART_LL_EC_PRESCALER values */
Sstatic const uint16_t USART_PRESCALER_TAB[] =
S{
S  (uint16_t)1,
S  (uint16_t)2,
S  (uint16_t)4,
S  (uint16_t)6,
S  (uint16_t)8,
S  (uint16_t)10,
S  (uint16_t)12,
S  (uint16_t)16,
S  (uint16_t)32,
S  (uint16_t)64,
S  (uint16_t)128,
S  (uint16_t)256
S};
S/**
S  * @}
S  */
N#endif
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup USART_LL_Private_Constants USART Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup USART_LL_Private_Macros USART Private Macros
N  * @{
N  */
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup USART_LL_ES_INIT USART Exported Init structures
N  * @{
N  */
N
N/**
N  * @brief LL USART Init Structure definition
N  */
Ntypedef struct
N{
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S  uint32_t PrescalerValue;            /*!< Specifies the Prescaler to compute the communication baud rate.
S                                           This parameter can be a value of @ref USART_LL_EC_PRESCALER.
S
S                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetPrescaler().*/
N#endif
N
N  uint32_t BaudRate;                  /*!< This field defines expected Usart communication baud rate.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetBaudRate().*/
N
N  uint32_t DataWidth;                 /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_LL_EC_DATAWIDTH.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetDataWidth().*/
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_LL_EC_STOPBITS.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetStopBitsLength().*/
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_LL_EC_PARITY.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetParity().*/
N
N  uint32_t TransferDirection;         /*!< Specifies whether the Receive and/or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_LL_EC_DIRECTION.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetTransferDirection().*/
N
N  uint32_t HardwareFlowControl;       /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_LL_EC_HWCONTROL.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetHWFlowCtrl().*/
N
N  uint32_t OverSampling;              /*!< Specifies whether USART oversampling mode is 16 or 8.
N                                           This parameter can be a value of @ref USART_LL_EC_OVERSAMPLING.
N
N                                           This feature can be modified afterwards using unitary function @ref LL_USART_SetOverSampling().*/
N
N} LL_USART_InitTypeDef;
N
N/**
N  * @brief LL USART Clock Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t ClockOutput;               /*!< Specifies whether the USART clock is enabled or disabled.
N                                           This parameter can be a value of @ref USART_LL_EC_CLOCK.
N
N                                           USART HW configuration can be modified afterwards using unitary functions
N                                           @ref LL_USART_EnableSCLKOutput() or @ref LL_USART_DisableSCLKOutput().
N                                           For more details, refer to description of this function. */
N
N  uint32_t ClockPolarity;             /*!< Specifies the steady state of the serial clock.
N                                           This parameter can be a value of @ref USART_LL_EC_POLARITY.
N
N                                           USART HW configuration can be modified afterwards using unitary functions @ref LL_USART_SetClockPolarity().
N                                           For more details, refer to description of this function. */
N
N  uint32_t ClockPhase;                /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref USART_LL_EC_PHASE.
N
N                                           USART HW configuration can be modified afterwards using unitary functions @ref LL_USART_SetClockPhase().
N                                           For more details, refer to description of this function. */
N
N  uint32_t LastBitClockPulse;         /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                                           data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                                           This parameter can be a value of @ref USART_LL_EC_LASTCLKPULSE.
N
N                                           USART HW configuration can be modified afterwards using unitary functions @ref LL_USART_SetLastClkPulseOutput().
N                                           For more details, refer to description of this function. */
N
N} LL_USART_ClockInitTypeDef;
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup USART_LL_Exported_Constants USART Exported Constants
N  * @{
N  */
N
N/** @defgroup USART_LL_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with LL_USART_WriteReg function
N  * @{
N  */
N#define LL_USART_ICR_PECF                       USART_ICR_PECF                /*!< Parity error flag */
N#define LL_USART_ICR_FECF                       USART_ICR_FECF                /*!< Framing error flag */
N#define LL_USART_ICR_NECF                       USART_ICR_NECF                /*!< Noise error detected flag */
N#define LL_USART_ICR_ORECF                      USART_ICR_ORECF               /*!< Overrun error flag */
N#define LL_USART_ICR_IDLECF                     USART_ICR_IDLECF              /*!< Idle line detected flag */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_ICR_TXFECF                     USART_ICR_TXFECF              /*!< TX FIFO Empty Clear flag */
N#endif
N#define LL_USART_ICR_TCCF                       USART_ICR_TCCF                /*!< Transmission complete flag */
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N#define LL_USART_ICR_TCBGTCF                    USART_ICR_TCBGTCF             /*!< Transmission completed before guard time flag */
N#endif
N#define LL_USART_ICR_LBDCF                      USART_ICR_LBDCF               /*!< LIN break detection flag */
N#define LL_USART_ICR_CTSCF                      USART_ICR_CTSCF               /*!< CTS flag */
N#define LL_USART_ICR_RTOCF                      USART_ICR_RTOCF               /*!< Receiver timeout flag */
N#define LL_USART_ICR_EOBCF                      USART_ICR_EOBCF               /*!< End of block flag */
N#if defined(USART_CR2_SLVEN)
X#if 0L
S#define LL_USART_ICR_UDRCF                      USART_ICR_UDRCF               /*!< SPI Slave Underrun Clear flag */
N#endif
N#define LL_USART_ICR_CMCF                       USART_ICR_CMCF                /*!< Character match flag */
N#define LL_USART_ICR_WUCF                       USART_ICR_WUCF                /*!< Wakeup from Stop mode flag */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_USART_ReadReg function
N  * @{
N  */
N#define LL_USART_ISR_PE                         USART_ISR_PE                  /*!< Parity error flag */
N#define LL_USART_ISR_FE                         USART_ISR_FE                  /*!< Framing error flag */
N#define LL_USART_ISR_NE                         USART_ISR_NE                  /*!< Noise detected flag */
N#define LL_USART_ISR_ORE                        USART_ISR_ORE                 /*!< Overrun error flag */
N#define LL_USART_ISR_IDLE                       USART_ISR_IDLE                /*!< Idle line detected flag */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_ISR_RXNE_RXFNE                 USART_ISR_RXNE_RXFNE          /*!< Read data register or RX FIFO not empty flag */
N#else
N#define LL_USART_ISR_RXNE                       USART_ISR_RXNE                /*!< Read data register not empty flag */
N#endif
N#define LL_USART_ISR_TC                         USART_ISR_TC                  /*!< Transmission complete flag */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_ISR_TXE_TXFNF                  USART_ISR_TXE_TXFNF           /*!< Transmit data register empty or TX FIFO Not Full flag*/
N#else
N#define LL_USART_ISR_TXE                        USART_ISR_TXE                 /*!< Transmit data register empty flag */
N#endif
N#define LL_USART_ISR_LBDF                       USART_ISR_LBDF                /*!< LIN break detection flag */
N#define LL_USART_ISR_CTSIF                      USART_ISR_CTSIF               /*!< CTS interrupt flag */
N#define LL_USART_ISR_CTS                        USART_ISR_CTS                 /*!< CTS flag */
N#define LL_USART_ISR_RTOF                       USART_ISR_RTOF                /*!< Receiver timeout flag */
N#define LL_USART_ISR_EOBF                       USART_ISR_EOBF                /*!< End of block flag */
N#if defined(USART_CR2_SLVEN)
X#if 0L
S#define LL_USART_ISR_UDR                        USART_ISR_UDR                 /*!< SPI Slave underrun error flag */
N#endif
N#define LL_USART_ISR_ABRE                       USART_ISR_ABRE                /*!< Auto baud rate error flag */
N#define LL_USART_ISR_ABRF                       USART_ISR_ABRF                /*!< Auto baud rate flag */
N#define LL_USART_ISR_BUSY                       USART_ISR_BUSY                /*!< Busy flag */
N#define LL_USART_ISR_CMF                        USART_ISR_CMF                 /*!< Character match flag */
N#define LL_USART_ISR_SBKF                       USART_ISR_SBKF                /*!< Send break flag */
N#define LL_USART_ISR_RWU                        USART_ISR_RWU                 /*!< Receiver wakeup from Mute mode flag */
N#define LL_USART_ISR_WUF                        USART_ISR_WUF                 /*!< Wakeup from Stop mode flag */
N#define LL_USART_ISR_TEACK                      USART_ISR_TEACK               /*!< Transmit enable acknowledge flag */
N#define LL_USART_ISR_REACK                      USART_ISR_REACK               /*!< Receive enable acknowledge flag */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_ISR_TXFE                       USART_ISR_TXFE                /*!< TX FIFO empty flag */
S#define LL_USART_ISR_RXFF                       USART_ISR_RXFF                /*!< RX FIFO full flag */
N#endif
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N#define LL_USART_ISR_TCBGT                      USART_ISR_TCBGT               /*!< Transmission complete before guard time completion flag */
N#endif
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_ISR_RXFT                       USART_ISR_RXFT                /*!< RX FIFO threshold flag */
S#define LL_USART_ISR_TXFT                       USART_ISR_TXFT                /*!< TX FIFO threshold flag */
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_IT IT Defines
N  * @brief    IT defines which can be used with LL_USART_ReadReg and  LL_USART_WriteReg functions
N  * @{
N  */
N#define LL_USART_CR1_IDLEIE                     USART_CR1_IDLEIE              /*!< IDLE interrupt enable */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_CR1_RXNEIE_RXFNEIE             USART_CR1_RXNEIE_RXFNEIE      /*!< Read data register and RXFIFO not empty interrupt enable */
N#else
N#define LL_USART_CR1_RXNEIE                     USART_CR1_RXNEIE              /*!< Read data register not empty interrupt enable */
N#endif
N#define LL_USART_CR1_TCIE                       USART_CR1_TCIE                /*!< Transmission complete interrupt enable */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_CR1_TXEIE_TXFNFIE              USART_CR1_TXEIE_TXFNFIE       /*!< Transmit data register empty and TX FIFO not full interrupt enable */
N#else
N#define LL_USART_CR1_TXEIE                      USART_CR1_TXEIE               /*!< Transmit data register empty interrupt enable */
N#endif
N#define LL_USART_CR1_PEIE                       USART_CR1_PEIE                /*!< Parity error */
N#define LL_USART_CR1_CMIE                       USART_CR1_CMIE                /*!< Character match interrupt enable */
N#define LL_USART_CR1_RTOIE                      USART_CR1_RTOIE               /*!< Receiver timeout interrupt enable */
N#define LL_USART_CR1_EOBIE                      USART_CR1_EOBIE               /*!< End of Block interrupt enable */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_CR1_TXFEIE                     USART_CR1_TXFEIE              /*!< TX FIFO empty interrupt enable */
S#define LL_USART_CR1_RXFFIE                     USART_CR1_RXFFIE              /*!< RX FIFO full interrupt enable */
N#endif
N#define LL_USART_CR2_LBDIE                      USART_CR2_LBDIE               /*!< LIN break detection interrupt enable */
N#define LL_USART_CR3_EIE                        USART_CR3_EIE                 /*!< Error interrupt enable */
N#define LL_USART_CR3_CTSIE                      USART_CR3_CTSIE               /*!< CTS interrupt enable */
N#define LL_USART_CR3_WUFIE                      USART_CR3_WUFIE               /*!< Wakeup from Stop mode interrupt enable */
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_CR3_TXFTIE                     USART_CR3_TXFTIE              /*!< TX FIFO threshold interrupt enable */
N#endif
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N#define LL_USART_CR3_TCBGTIE                    USART_CR3_TCBGTIE             /*!< Transmission complete before guard time interrupt enable */
N#endif
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S#define LL_USART_CR3_RXFTIE                     USART_CR3_RXFTIE              /*!< RX FIFO threshold interrupt enable */
N#endif
N/**
N  * @}
N  */
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/** @defgroup USART_LL_EC_FIFOTHRESHOLD FIFO Threshold
S  * @{
S  */
S#define LL_USART_FIFOTHRESHOLD_1_8              0x00000000U /*!< FIFO reaches 1/8 of its depth */
S#define LL_USART_FIFOTHRESHOLD_1_4              0x00000001U /*!< FIFO reaches 1/4 of its depth */
S#define LL_USART_FIFOTHRESHOLD_1_2              0x00000002U /*!< FIFO reaches 1/2 of its depth */
S#define LL_USART_FIFOTHRESHOLD_3_4              0x00000003U /*!< FIFO reaches 3/4 of its depth */
S#define LL_USART_FIFOTHRESHOLD_7_8              0x00000004U /*!< FIFO reaches 7/8 of its depth */
S#define LL_USART_FIFOTHRESHOLD_8_8              0x00000005U /*!< FIFO becomes empty for TX and full for RX */
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup USART_LL_EC_DIRECTION Communication Direction
N  * @{
N  */
N#define LL_USART_DIRECTION_NONE                 0x00000000U                        /*!< Transmitter and Receiver are disabled */
N#define LL_USART_DIRECTION_RX                   USART_CR1_RE                       /*!< Transmitter is disabled and Receiver is enabled */
N#define LL_USART_DIRECTION_TX                   USART_CR1_TE                       /*!< Transmitter is enabled and Receiver is disabled */
N#define LL_USART_DIRECTION_TX_RX                (USART_CR1_TE |USART_CR1_RE)       /*!< Transmitter and Receiver are enabled */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_PARITY Parity Control
N  * @{
N  */
N#define LL_USART_PARITY_NONE                    0x00000000U                          /*!< Parity control disabled */
N#define LL_USART_PARITY_EVEN                    USART_CR1_PCE                        /*!< Parity control enabled and Even Parity is selected */
N#define LL_USART_PARITY_ODD                     (USART_CR1_PCE | USART_CR1_PS)       /*!< Parity control enabled and Odd Parity is selected */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_WAKEUP Wakeup
N  * @{
N  */
N#define LL_USART_WAKEUP_IDLELINE                0x00000000U           /*!<  USART wake up from Mute mode on Idle Line */
N#define LL_USART_WAKEUP_ADDRESSMARK             USART_CR1_WAKE        /*!<  USART wake up from Mute mode on Address Mark */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_DATAWIDTH Datawidth
N  * @{
N  */
N#define LL_USART_DATAWIDTH_7B                   USART_CR1_M1            /*!< 7 bits word length : Start bit, 7 data bits, n stop bits */
N#define LL_USART_DATAWIDTH_8B                   0x00000000U             /*!< 8 bits word length : Start bit, 8 data bits, n stop bits */
N#define LL_USART_DATAWIDTH_9B                   USART_CR1_M0            /*!< 9 bits word length : Start bit, 9 data bits, n stop bits */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_OVERSAMPLING Oversampling
N  * @{
N  */
N#define LL_USART_OVERSAMPLING_16                0x00000000U            /*!< Oversampling by 16 */
N#define LL_USART_OVERSAMPLING_8                 USART_CR1_OVER8        /*!< Oversampling by 8 */
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup USART_LL_EC_CLOCK Clock Signal
N  * @{
N  */
N
N#define LL_USART_CLOCK_DISABLE                  0x00000000U            /*!< Clock signal not provided */
N#define LL_USART_CLOCK_ENABLE                   USART_CR2_CLKEN        /*!< Clock signal provided */
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/** @defgroup USART_LL_EC_LASTCLKPULSE Last Clock Pulse
N  * @{
N  */
N#define LL_USART_LASTCLKPULSE_NO_OUTPUT         0x00000000U           /*!< The clock pulse of the last data bit is not output to the SCLK pin */
N#define LL_USART_LASTCLKPULSE_OUTPUT            USART_CR2_LBCL        /*!< The clock pulse of the last data bit is output to the SCLK pin */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_PHASE Clock Phase
N  * @{
N  */
N#define LL_USART_PHASE_1EDGE                    0x00000000U           /*!< The first clock transition is the first data capture edge */
N#define LL_USART_PHASE_2EDGE                    USART_CR2_CPHA        /*!< The second clock transition is the first data capture edge */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_POLARITY Clock Polarity
N  * @{
N  */
N#define LL_USART_POLARITY_LOW                   0x00000000U           /*!< Steady low value on SCLK pin outside transmission window*/
N#define LL_USART_POLARITY_HIGH                  USART_CR2_CPOL        /*!< Steady high value on SCLK pin outside transmission window */
N/**
N  * @}
N  */
N
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S/** @defgroup USART_LL_EC_PRESCALER Clock Source Prescaler
S  * @{
S  */
S#define LL_USART_PRESCALER_DIV1                 0x00000000U                                                                   /*!< Input clock not devided   */
S#define LL_USART_PRESCALER_DIV2                 (USART_PRESC_PRESCALER_0)                                                     /*!< Input clock devided by 2  */
S#define LL_USART_PRESCALER_DIV4                 (USART_PRESC_PRESCALER_1)                                                     /*!< Input clock devided by 4  */
S#define LL_USART_PRESCALER_DIV6                 (USART_PRESC_PRESCALER_1 | USART_PRESC_PRESCALER_0)                           /*!< Input clock devided by 6  */
S#define LL_USART_PRESCALER_DIV8                 (USART_PRESC_PRESCALER_2)                                                     /*!< Input clock devided by 8  */
S#define LL_USART_PRESCALER_DIV10                (USART_PRESC_PRESCALER_2 | USART_PRESC_PRESCALER_0)                           /*!< Input clock devided by 10 */
S#define LL_USART_PRESCALER_DIV12                (USART_PRESC_PRESCALER_2 | USART_PRESC_PRESCALER_1)                           /*!< Input clock devided by 12 */
S#define LL_USART_PRESCALER_DIV16                (USART_PRESC_PRESCALER_2 | USART_PRESC_PRESCALER_1 | USART_PRESC_PRESCALER_0) /*!< Input clock devided by 16 */
S#define LL_USART_PRESCALER_DIV32                (USART_PRESC_PRESCALER_3)                                                     /*!< Input clock devided by 32 */
S#define LL_USART_PRESCALER_DIV64                (USART_PRESC_PRESCALER_3 | USART_PRESC_PRESCALER_0)                           /*!< Input clock devided by 64 */
S#define LL_USART_PRESCALER_DIV128               (USART_PRESC_PRESCALER_3 | USART_PRESC_PRESCALER_1)                           /*!< Input clock devided by 128 */
S#define LL_USART_PRESCALER_DIV256               (USART_PRESC_PRESCALER_3 | USART_PRESC_PRESCALER_1 | USART_PRESC_PRESCALER_0) /*!< Input clock devided by 256 */
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup USART_LL_EC_STOPBITS Stop Bits
N  * @{
N  */
N#define LL_USART_STOPBITS_0_5                   USART_CR2_STOP_0                           /*!< 0.5 stop bit */
N#define LL_USART_STOPBITS_1                     0x00000000U                                /*!< 1 stop bit */
N#define LL_USART_STOPBITS_1_5                   (USART_CR2_STOP_0 | USART_CR2_STOP_1)      /*!< 1.5 stop bits */
N#define LL_USART_STOPBITS_2                     USART_CR2_STOP_1                           /*!< 2 stop bits */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_TXRX TX RX Pins Swap
N  * @{
N  */
N#define LL_USART_TXRX_STANDARD                  0x00000000U           /*!< TX/RX pins are used as defined in standard pinout */
N#define LL_USART_TXRX_SWAPPED                   (USART_CR2_SWAP)      /*!< TX and RX pins functions are swapped.             */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_RXPIN_LEVEL RX Pin Active Level Inversion
N  * @{
N  */
N#define LL_USART_RXPIN_LEVEL_STANDARD           0x00000000U           /*!< RX pin signal works using the standard logic levels */
N#define LL_USART_RXPIN_LEVEL_INVERTED           (USART_CR2_RXINV)     /*!< RX pin signal values are inverted.                  */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_TXPIN_LEVEL TX Pin Active Level Inversion
N  * @{
N  */
N#define LL_USART_TXPIN_LEVEL_STANDARD           0x00000000U           /*!< TX pin signal works using the standard logic levels */
N#define LL_USART_TXPIN_LEVEL_INVERTED           (USART_CR2_TXINV)     /*!< TX pin signal values are inverted.                  */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_BINARY_LOGIC Binary Data Inversion
N  * @{
N  */
N#define LL_USART_BINARY_LOGIC_POSITIVE          0x00000000U           /*!< Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L) */
N#define LL_USART_BINARY_LOGIC_NEGATIVE          USART_CR2_DATAINV     /*!< Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted. */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_BITORDER Bit Order
N  * @{
N  */
N#define LL_USART_BITORDER_LSBFIRST              0x00000000U           /*!< data is transmitted/received with data bit 0 first, following the start bit */
N#define LL_USART_BITORDER_MSBFIRST              USART_CR2_MSBFIRST    /*!< data is transmitted/received with the MSB first, following the start bit */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_AUTOBAUD_DETECT_ON Autobaud Detection
N  * @{
N  */
N#define LL_USART_AUTOBAUD_DETECT_ON_STARTBIT    0x00000000U                                 /*!< Measurement of the start bit is used to detect the baud rate */
N#define LL_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE USART_CR2_ABRMODE_0                         /*!< Falling edge to falling edge measurement. Received frame must start with a single bit = 1 -> Frame = Start10xxxxxx */
N#define LL_USART_AUTOBAUD_DETECT_ON_7F_FRAME    USART_CR2_ABRMODE_1                         /*!< 0x7F frame detection */
N#define LL_USART_AUTOBAUD_DETECT_ON_55_FRAME    (USART_CR2_ABRMODE_1 | USART_CR2_ABRMODE_0) /*!< 0x55 frame detection */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_ADDRESS_DETECT Address Length Detection
N  * @{
N  */
N#define LL_USART_ADDRESS_DETECT_4B              0x00000000U           /*!< 4-bit address detection method selected */
N#define LL_USART_ADDRESS_DETECT_7B              USART_CR2_ADDM7       /*!< 7-bit address detection (in 8-bit data mode) method selected */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_HWCONTROL Hardware Control
N  * @{
N  */
N#define LL_USART_HWCONTROL_NONE                 0x00000000U                          /*!< CTS and RTS hardware flow control disabled */
N#define LL_USART_HWCONTROL_RTS                  USART_CR3_RTSE                       /*!< RTS output enabled, data is only requested when there is space in the receive buffer */
N#define LL_USART_HWCONTROL_CTS                  USART_CR3_CTSE                       /*!< CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0) */
N#define LL_USART_HWCONTROL_RTS_CTS              (USART_CR3_RTSE | USART_CR3_CTSE)    /*!< CTS and RTS hardware flow control enabled */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_WAKEUP_ON Wakeup Activation
N  * @{
N  */
N#define LL_USART_WAKEUP_ON_ADDRESS              0x00000000U                             /*!< Wake up active on address match */
N#define LL_USART_WAKEUP_ON_STARTBIT             USART_CR3_WUS_1                         /*!< Wake up active on Start bit detection */
N#define LL_USART_WAKEUP_ON_RXNE                 (USART_CR3_WUS_0 | USART_CR3_WUS_1)     /*!< Wake up active on RXNE */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_IRDA_POWER IrDA Power
N  * @{
N  */
N#define LL_USART_IRDA_POWER_NORMAL              0x00000000U           /*!< IrDA normal power mode */
N#define LL_USART_IRDA_POWER_LOW                 USART_CR3_IRLP        /*!< IrDA low power mode */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_LINBREAK_DETECT LIN Break Detection Length
N  * @{
N  */
N#define LL_USART_LINBREAK_DETECT_10B            0x00000000U           /*!< 10-bit break detection method selected */
N#define LL_USART_LINBREAK_DETECT_11B            USART_CR2_LBDL        /*!< 11-bit break detection method selected */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_DE_POLARITY Driver Enable Polarity
N  * @{
N  */
N#define LL_USART_DE_POLARITY_HIGH               0x00000000U           /*!< DE signal is active high */
N#define LL_USART_DE_POLARITY_LOW                USART_CR3_DEP         /*!< DE signal is active low */
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EC_DMA_REG_DATA DMA Register Data
N  * @{
N  */
N#define LL_USART_DMA_REG_DATA_TRANSMIT          0x00000000U          /*!< Get address of data register used for transmission */
N#define LL_USART_DMA_REG_DATA_RECEIVE           0x00000001U          /*!< Get address of data register used for reception */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup USART_LL_Exported_Macros USART Exported Macros
N  * @{
N  */
N
N/** @defgroup USART_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in USART register
N  * @param  __INSTANCE__ USART Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_USART_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in USART register
N  * @param  __INSTANCE__ USART Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_USART_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EM_Exported_Macros_Helper Exported_Macros_Helper
N  * @{
N  */
N
N/**
N  * @brief  Compute USARTDIV value according to Peripheral Clock and
N  *         expected Baud Rate in 8 bits sampling mode (32 bits value of USARTDIV is returned)
N  * @param  __PERIPHCLK__ Peripheral Clock frequency used for USART instance
N  @if USART_PRESC_PRESCALER
N  * @param  __PRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PRESCALER_DIV1
N  *         @arg @ref LL_USART_PRESCALER_DIV2
N  *         @arg @ref LL_USART_PRESCALER_DIV4
N  *         @arg @ref LL_USART_PRESCALER_DIV6
N  *         @arg @ref LL_USART_PRESCALER_DIV8
N  *         @arg @ref LL_USART_PRESCALER_DIV10
N  *         @arg @ref LL_USART_PRESCALER_DIV12
N  *         @arg @ref LL_USART_PRESCALER_DIV16
N  *         @arg @ref LL_USART_PRESCALER_DIV32
N  *         @arg @ref LL_USART_PRESCALER_DIV64
N  *         @arg @ref LL_USART_PRESCALER_DIV128
N  *         @arg @ref LL_USART_PRESCALER_DIV256
N  @endif
N  * @param  __BAUDRATE__ Baud rate value to achieve
N  * @retval USARTDIV value to be used for BRR register filling in OverSampling_8 case
N  */
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S#define __LL_USART_DIV_SAMPLING8(__PERIPHCLK__, __PRESCALER__, __BAUDRATE__) (((((__PERIPHCLK__)/(uint32_t)(USART_PRESCALER_TAB[(__PRESCALER__)]))*2U) + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
N#else
N#define __LL_USART_DIV_SAMPLING8(__PERIPHCLK__, __BAUDRATE__) ((((__PERIPHCLK__)*2U) + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
N#endif
N
N/**
N  * @brief  Compute USARTDIV value according to Peripheral Clock and
N  *         expected Baud Rate in 16 bits sampling mode (32 bits value of USARTDIV is returned)
N  * @param  __PERIPHCLK__ Peripheral Clock frequency used for USART instance
N  @if USART_PRESC_PRESCALER
N  * @param  __PRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PRESCALER_DIV1
N  *         @arg @ref LL_USART_PRESCALER_DIV2
N  *         @arg @ref LL_USART_PRESCALER_DIV4
N  *         @arg @ref LL_USART_PRESCALER_DIV6
N  *         @arg @ref LL_USART_PRESCALER_DIV8
N  *         @arg @ref LL_USART_PRESCALER_DIV10
N  *         @arg @ref LL_USART_PRESCALER_DIV12
N  *         @arg @ref LL_USART_PRESCALER_DIV16
N  *         @arg @ref LL_USART_PRESCALER_DIV32
N  *         @arg @ref LL_USART_PRESCALER_DIV64
N  *         @arg @ref LL_USART_PRESCALER_DIV128
N  *         @arg @ref LL_USART_PRESCALER_DIV256
N  @endif
N  * @param  __BAUDRATE__ Baud rate value to achieve
N  * @retval USARTDIV value to be used for BRR register filling in OverSampling_16 case
N  */
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S#define __LL_USART_DIV_SAMPLING16(__PERIPHCLK__, __PRESCALER__, __BAUDRATE__) ((((__PERIPHCLK__)/(uint32_t)(USART_PRESCALER_TAB[(__PRESCALER__)])) + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
N#else
N#define __LL_USART_DIV_SAMPLING16(__PERIPHCLK__, __BAUDRATE__) (((__PERIPHCLK__) + ((__BAUDRATE__)/2U))/(__BAUDRATE__))
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup USART_LL_Exported_Functions USART Exported Functions
N  * @{
N  */
N
N/** @defgroup USART_LL_EF_Configuration Configuration functions
N  * @{
N  */
N
N/**
N  * @brief  USART Enable
N  * @rmtoll CR1          UE            LL_USART_Enable
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_Enable(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_Enable(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_UE);
X  ((USARTx->CR1) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  USART Disable (all USART prescalers and outputs are disabled)
N  * @note   When USART is disabled, USART prescalers and outputs are stopped immediately,
N  *         and current operations are discarded. The configuration of the USART is kept, but all the status
N  *         flags, in the USARTx_ISR are set to their default values.
N  * @rmtoll CR1          UE            LL_USART_Disable
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_Disable(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_Disable(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
X  ((USARTx->CR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicate if USART is enabled
N  * @rmtoll CR1          UE            LL_USART_IsEnabled
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
X  return (((USARTx->CR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  FIFO Mode Enable
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          FIFOEN        LL_USART_EnableFIFO
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableFIFO(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR1, USART_CR1_FIFOEN);
S}
S
S/**
S  * @brief  FIFO Mode Disable
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          FIFOEN        LL_USART_DisableFIFO
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableFIFO(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR1, USART_CR1_FIFOEN);
S}
S
S/**
S  * @brief  Indicate if FIFO Mode is enabled
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          FIFOEN        LL_USART_IsEnabledFIFO
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledFIFO(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR1, USART_CR1_FIFOEN) == (USART_CR1_FIFOEN));
S}
S
S/**
S  * @brief  Configure TX FIFO Threshold
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          TXFTCFG       LL_USART_SetTXFIFOThreshold
S  * @param  USARTx USART Instance
S  * @param  Threshold This parameter can be one of the following values:
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_2
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_3_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_SetTXFIFOThreshold(USART_TypeDef *USARTx, uint32_t Threshold)
S{
S  MODIFY_REG(USARTx->CR3, USART_CR3_TXFTCFG, Threshold << USART_CR3_TXFTCFG_Pos);
S}
S
S/**
S  * @brief  Return TX FIFO Threshold Configuration
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          TXFTCFG       LL_USART_GetTXFIFOThreshold
S  * @param  USARTx USART Instance
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_2
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_3_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
S  */
S__STATIC_INLINE uint32_t LL_USART_GetTXFIFOThreshold(USART_TypeDef *USARTx)
S{
S  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
S}
S
S/**
S  * @brief  Configure RX FIFO Threshold
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          RXFTCFG       LL_USART_SetRXFIFOThreshold
S  * @param  USARTx USART Instance
S  * @param  Threshold This parameter can be one of the following values:
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_2
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_3_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_SetRXFIFOThreshold(USART_TypeDef *USARTx, uint32_t Threshold)
S{
S  MODIFY_REG(USARTx->CR3, USART_CR3_RXFTCFG, Threshold << USART_CR3_RXFTCFG_Pos);
S}
S
S/**
S  * @brief  Return RX FIFO Threshold Configuration
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          RXFTCFG       LL_USART_GetRXFIFOThreshold
S  * @param  USARTx USART Instance
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_2
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_3_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
S  */
S__STATIC_INLINE uint32_t LL_USART_GetRXFIFOThreshold(USART_TypeDef *USARTx)
S{
S  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
S}
S
S/**
S  * @brief  Configure TX and RX FIFOs Threshold
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          TXFTCFG       LL_USART_ConfigFIFOsThreshold\n
S  *         CR3          RXFTCFG       LL_USART_ConfigFIFOsThreshold
S  * @param  USARTx USART Instance
S  * @param  TXThreshold This parameter can be one of the following values:
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_2
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_3_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
S  * @param  RXThreshold This parameter can be one of the following values:
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_1_2
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_3_4
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
S  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_ConfigFIFOsThreshold(USART_TypeDef *USARTx, uint32_t TXThreshold, uint32_t RXThreshold)
S{
S  MODIFY_REG(USARTx->CR3, USART_CR3_TXFTCFG | USART_CR3_RXFTCFG, TXThreshold << USART_CR3_TXFTCFG_Pos | RXThreshold << USART_CR3_RXFTCFG_Pos);
S}
N#endif
N
N/**
N  * @brief  USART enabled in STOP Mode.
N  * @note   When this function is enabled, USART is able to wake up the MCU from Stop mode, provided that
N  *         USART clock selection is HSI or LSE in RCC.
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR1          UESM          LL_USART_EnableInStopMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableInStopMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableInStopMode(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_UESM);
X  ((USARTx->CR1) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  USART disabled in STOP Mode.
N  * @note   When this function is disabled, USART is not able to wake up the MCU from Stop mode
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR1          UESM          LL_USART_DisableInStopMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableInStopMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableInStopMode(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_UESM);
X  ((USARTx->CR1) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicate if USART is enabled in STOP Mode (able to wake up MCU from Stop mode or not)
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR1          UESM          LL_USART_IsEnabledInStopMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledInStopMode(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledInStopMode(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_UESM) == (USART_CR1_UESM));
X  return (((USARTx->CR1) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N#if defined(USART_CR3_UCESM)
X#if 1L
N/**
N  * @brief  USART Clock enabled in STOP Mode
N  * @note   When this function is called, USART Clock is enabled while in STOP mode
N  * @rmtoll CR3          UCESM         LL_USART_EnableClockInStopMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableClockInStopMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableClockInStopMode(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_UCESM);
X  ((USARTx->CR3) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  USART clock disabled in STOP Mode
N  * @note   When this function is called, USART Clock is disabled while in STOP mode
N  * @rmtoll CR3          UCESM         LL_USART_DisableClockInStopMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableClockInStopMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableClockInStopMode(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_UCESM);
X  ((USARTx->CR3) &= ~((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Indicate if USART clock is enabled in STOP Mode
N  * @rmtoll CR3          UCESM         LL_USART_IsClockEnabledInStopMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsClockEnabledInStopMode(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsClockEnabledInStopMode(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_UCESM) == (USART_CR3_UCESM));
X  return (((USARTx->CR3) & ((0x1UL << (23U)))) == ((0x1UL << (23U))));
N}
N
N#endif /* USART_CR3_UCESM */
N/**
N  * @brief  Receiver Enable (Receiver is enabled and begins searching for a start bit)
N  * @rmtoll CR1          RE            LL_USART_EnableDirectionRx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableDirectionRx(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableDirectionRx(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_RE);
X  ((USARTx->CR1) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Receiver Disable
N  * @rmtoll CR1          RE            LL_USART_DisableDirectionRx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableDirectionRx(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableDirectionRx(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_RE);
X  ((USARTx->CR1) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Transmitter Enable
N  * @rmtoll CR1          TE            LL_USART_EnableDirectionTx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableDirectionTx(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableDirectionTx(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_TE);
X  ((USARTx->CR1) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Transmitter Disable
N  * @rmtoll CR1          TE            LL_USART_DisableDirectionTx
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableDirectionTx(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableDirectionTx(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_TE);
X  ((USARTx->CR1) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Configure simultaneously enabled/disabled states
N  *         of Transmitter and Receiver
N  * @rmtoll CR1          RE            LL_USART_SetTransferDirection\n
N  *         CR1          TE            LL_USART_SetTransferDirection
N  * @param  USARTx USART Instance
N  * @param  TransferDirection This parameter can be one of the following values:
N  *         @arg @ref LL_USART_DIRECTION_NONE
N  *         @arg @ref LL_USART_DIRECTION_RX
N  *         @arg @ref LL_USART_DIRECTION_TX
N  *         @arg @ref LL_USART_DIRECTION_TX_RX
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection)
Xstatic __inline void LL_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (2U)) | (0x1UL << (3U))))) | (TransferDirection))));
N}
N
N/**
N  * @brief  Return enabled/disabled states of Transmitter and Receiver
N  * @rmtoll CR1          RE            LL_USART_GetTransferDirection\n
N  *         CR1          TE            LL_USART_GetTransferDirection
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_DIRECTION_NONE
N  *         @arg @ref LL_USART_DIRECTION_RX
N  *         @arg @ref LL_USART_DIRECTION_TX
N  *         @arg @ref LL_USART_DIRECTION_TX_RX
N  */
N__STATIC_INLINE uint32_t LL_USART_GetTransferDirection(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetTransferDirection(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_RE | USART_CR1_TE));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (2U)) | (0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Configure Parity (enabled/disabled and parity mode if enabled).
N  * @note   This function selects if hardware parity control (generation and detection) is enabled or disabled.
N  *         When the parity control is enabled (Odd or Even), computed parity bit is inserted at the MSB position
N  *         (9th or 8th bit depending on data width) and parity is checked on the received data.
N  * @rmtoll CR1          PS            LL_USART_SetParity\n
N  *         CR1          PCE           LL_USART_SetParity
N  * @param  USARTx USART Instance
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PARITY_NONE
N  *         @arg @ref LL_USART_PARITY_EVEN
N  *         @arg @ref LL_USART_PARITY_ODD
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity)
Xstatic __inline void LL_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (9U)) | (0x1UL << (10U))))) | (Parity))));
N}
N
N/**
N  * @brief  Return Parity configuration (enabled/disabled and parity mode if enabled)
N  * @rmtoll CR1          PS            LL_USART_GetParity\n
N  *         CR1          PCE           LL_USART_GetParity
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_PARITY_NONE
N  *         @arg @ref LL_USART_PARITY_EVEN
N  *         @arg @ref LL_USART_PARITY_ODD
N  */
N__STATIC_INLINE uint32_t LL_USART_GetParity(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetParity(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (9U)) | (0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Set Receiver Wake Up method from Mute mode.
N  * @rmtoll CR1          WAKE          LL_USART_SetWakeUpMethod
N  * @param  USARTx USART Instance
N  * @param  Method This parameter can be one of the following values:
N  *         @arg @ref LL_USART_WAKEUP_IDLELINE
N  *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method)
Xstatic __inline void LL_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_WAKE, Method);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (11U))))) | (Method))));
N}
N
N/**
N  * @brief  Return Receiver Wake Up method from Mute mode
N  * @rmtoll CR1          WAKE          LL_USART_GetWakeUpMethod
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_WAKEUP_IDLELINE
N  *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
N  */
N__STATIC_INLINE uint32_t LL_USART_GetWakeUpMethod(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetWakeUpMethod(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_WAKE));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Set Word length (i.e. nb of data bits, excluding start and stop bits)
N  * @rmtoll CR1          M0            LL_USART_SetDataWidth\n
N  *         CR1          M1            LL_USART_SetDataWidth
N  * @param  USARTx USART Instance
N  * @param  DataWidth This parameter can be one of the following values:
N  *         @arg @ref LL_USART_DATAWIDTH_7B
N  *         @arg @ref LL_USART_DATAWIDTH_8B
N  *         @arg @ref LL_USART_DATAWIDTH_9B
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth)
Xstatic __inline void LL_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x10001UL << (12U))))) | (DataWidth))));
N}
N
N/**
N  * @brief  Return Word length (i.e. nb of data bits, excluding start and stop bits)
N  * @rmtoll CR1          M0            LL_USART_GetDataWidth\n
N  *         CR1          M1            LL_USART_GetDataWidth
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_DATAWIDTH_7B
N  *         @arg @ref LL_USART_DATAWIDTH_8B
N  *         @arg @ref LL_USART_DATAWIDTH_9B
N  */
N__STATIC_INLINE uint32_t LL_USART_GetDataWidth(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetDataWidth(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
X  return (uint32_t)(((USARTx->CR1) & ((0x10001UL << (12U)))));
N}
N
N/**
N  * @brief  Allow switch between Mute Mode and Active mode
N  * @rmtoll CR1          MME           LL_USART_EnableMuteMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableMuteMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableMuteMode(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_MME);
X  ((USARTx->CR1) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Prevent Mute Mode use. Set Receiver in active mode permanently.
N  * @rmtoll CR1          MME           LL_USART_DisableMuteMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableMuteMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableMuteMode(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_MME);
X  ((USARTx->CR1) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicate if switch between Mute Mode and Active mode is allowed
N  * @rmtoll CR1          MME           LL_USART_IsEnabledMuteMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledMuteMode(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledMuteMode(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_MME) == (USART_CR1_MME));
X  return (((USARTx->CR1) & ((0x1UL << (13U)))) == ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Set Oversampling to 8-bit or 16-bit mode
N  * @rmtoll CR1          OVER8         LL_USART_SetOverSampling
N  * @param  USARTx USART Instance
N  * @param  OverSampling This parameter can be one of the following values:
N  *         @arg @ref LL_USART_OVERSAMPLING_16
N  *         @arg @ref LL_USART_OVERSAMPLING_8
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling)
Xstatic __inline void LL_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (15U))))) | (OverSampling))));
N}
N
N/**
N  * @brief  Return Oversampling mode
N  * @rmtoll CR1          OVER8         LL_USART_GetOverSampling
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_OVERSAMPLING_16
N  *         @arg @ref LL_USART_OVERSAMPLING_8
N  */
N__STATIC_INLINE uint32_t LL_USART_GetOverSampling(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetOverSampling(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_OVER8));
X  return (uint32_t)(((USARTx->CR1) & ((0x1UL << (15U)))));
N}
N
N/**
N  * @brief  Configure if Clock pulse of the last data bit is output to the SCLK pin or not
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          LBCL          LL_USART_SetLastClkPulseOutput
N  * @param  USARTx USART Instance
N  * @param  LastBitClockPulse This parameter can be one of the following values:
N  *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
N  *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPulse)
Xstatic __inline void LL_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPulse)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_LBCL, LastBitClockPulse);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (8U))))) | (LastBitClockPulse))));
N}
N
N/**
N  * @brief  Retrieve Clock pulse of the last data bit output configuration
N  *         (Last bit Clock pulse output to the SCLK pin or not)
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          LBCL          LL_USART_GetLastClkPulseOutput
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
N  *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
N  */
N__STATIC_INLINE uint32_t LL_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBCL));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (8U)))));
N}
N
N/**
N  * @brief  Select the phase of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPHA          LL_USART_SetClockPhase
N  * @param  USARTx USART Instance
N  * @param  ClockPhase This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PHASE_1EDGE
N  *         @arg @ref LL_USART_PHASE_2EDGE
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase)
Xstatic __inline void LL_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_CPHA, ClockPhase);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (9U))))) | (ClockPhase))));
N}
N
N/**
N  * @brief  Return phase of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPHA          LL_USART_GetClockPhase
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_PHASE_1EDGE
N  *         @arg @ref LL_USART_PHASE_2EDGE
N  */
N__STATIC_INLINE uint32_t LL_USART_GetClockPhase(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetClockPhase(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPHA));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Select the polarity of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPOL          LL_USART_SetClockPolarity
N  * @param  USARTx USART Instance
N  * @param  ClockPolarity This parameter can be one of the following values:
N  *         @arg @ref LL_USART_POLARITY_LOW
N  *         @arg @ref LL_USART_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity)
Xstatic __inline void LL_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_CPOL, ClockPolarity);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (10U))))) | (ClockPolarity))));
N}
N
N/**
N  * @brief  Return polarity of the clock output on the SCLK pin in synchronous mode
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CPOL          LL_USART_GetClockPolarity
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_POLARITY_LOW
N  *         @arg @ref LL_USART_POLARITY_HIGH
N  */
N__STATIC_INLINE uint32_t LL_USART_GetClockPolarity(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetClockPolarity(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPOL));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Configure Clock signal format (Phase Polarity and choice about output of last bit clock pulse)
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clock Phase configuration using @ref LL_USART_SetClockPhase() function
N  *         - Clock Polarity configuration using @ref LL_USART_SetClockPolarity() function
N  *         - Output of Last bit Clock pulse configuration using @ref LL_USART_SetLastClkPulseOutput() function
N  * @rmtoll CR2          CPHA          LL_USART_ConfigClock\n
N  *         CR2          CPOL          LL_USART_ConfigClock\n
N  *         CR2          LBCL          LL_USART_ConfigClock
N  * @param  USARTx USART Instance
N  * @param  Phase This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PHASE_1EDGE
N  *         @arg @ref LL_USART_PHASE_2EDGE
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref LL_USART_POLARITY_LOW
N  *         @arg @ref LL_USART_POLARITY_HIGH
N  * @param  LBCPOutput This parameter can be one of the following values:
N  *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
N  *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity, uint32_t LBCPOutput)
Xstatic __inline void LL_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity, uint32_t LBCPOutput)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL, Phase | Polarity | LBCPOutput);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (9U)) | (0x1UL << (10U)) | (0x1UL << (8U))))) | (Phase | Polarity | LBCPOutput))));
N}
N
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S/**
S  * @brief  Configure Clock source prescaler for baudrate generator and oversampling
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll PRESC        PRESCALER     LL_USART_SetPrescaler
S  * @param  USARTx USART Instance
S  * @param  PrescalerValue This parameter can be one of the following values:
S  *         @arg @ref LL_USART_PRESCALER_DIV1
S  *         @arg @ref LL_USART_PRESCALER_DIV2
S  *         @arg @ref LL_USART_PRESCALER_DIV4
S  *         @arg @ref LL_USART_PRESCALER_DIV6
S  *         @arg @ref LL_USART_PRESCALER_DIV8
S  *         @arg @ref LL_USART_PRESCALER_DIV10
S  *         @arg @ref LL_USART_PRESCALER_DIV12
S  *         @arg @ref LL_USART_PRESCALER_DIV16
S  *         @arg @ref LL_USART_PRESCALER_DIV32
S  *         @arg @ref LL_USART_PRESCALER_DIV64
S  *         @arg @ref LL_USART_PRESCALER_DIV128
S  *         @arg @ref LL_USART_PRESCALER_DIV256
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_SetPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
S{
S  MODIFY_REG(USARTx->PRESC, USART_PRESC_PRESCALER, (uint16_t)PrescalerValue);
S}
S
S/**
S  * @brief  Retrieve the Clock source prescaler for baudrate generator and oversampling
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll PRESC        PRESCALER     LL_USART_GetPrescaler
S  * @param  USARTx USART Instance
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_USART_PRESCALER_DIV1
S  *         @arg @ref LL_USART_PRESCALER_DIV2
S  *         @arg @ref LL_USART_PRESCALER_DIV4
S  *         @arg @ref LL_USART_PRESCALER_DIV6
S  *         @arg @ref LL_USART_PRESCALER_DIV8
S  *         @arg @ref LL_USART_PRESCALER_DIV10
S  *         @arg @ref LL_USART_PRESCALER_DIV12
S  *         @arg @ref LL_USART_PRESCALER_DIV16
S  *         @arg @ref LL_USART_PRESCALER_DIV32
S  *         @arg @ref LL_USART_PRESCALER_DIV64
S  *         @arg @ref LL_USART_PRESCALER_DIV128
S  *         @arg @ref LL_USART_PRESCALER_DIV256
S  */
S__STATIC_INLINE uint32_t LL_USART_GetPrescaler(USART_TypeDef *USARTx)
S{
S  return (uint32_t)(READ_BIT(USARTx->PRESC, USART_PRESC_PRESCALER));
S}
N#endif
N
N/**
N  * @brief  Enable Clock output on SCLK pin
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CLKEN         LL_USART_EnableSCLKOutput
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableSCLKOutput(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableSCLKOutput(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
X  ((USARTx->CR2) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable Clock output on SCLK pin
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CLKEN         LL_USART_DisableSCLKOutput
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableSCLKOutput(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableSCLKOutput(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
X  ((USARTx->CR2) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicate if Clock output on SCLK pin is enabled
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @rmtoll CR2          CLKEN         LL_USART_IsEnabledSCLKOutput
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR2, USART_CR2_CLKEN) == (USART_CR2_CLKEN));
X  return (((USARTx->CR2) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Set the length of the stop bits
N  * @rmtoll CR2          STOP          LL_USART_SetStopBitsLength
N  * @param  USARTx USART Instance
N  * @param  StopBits This parameter can be one of the following values:
N  *         @arg @ref LL_USART_STOPBITS_0_5
N  *         @arg @ref LL_USART_STOPBITS_1
N  *         @arg @ref LL_USART_STOPBITS_1_5
N  *         @arg @ref LL_USART_STOPBITS_2
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
Xstatic __inline void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x3UL << (12U))))) | (StopBits))));
N}
N
N/**
N  * @brief  Retrieve the length of the stop bits
N  * @rmtoll CR2          STOP          LL_USART_GetStopBitsLength
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_STOPBITS_0_5
N  *         @arg @ref LL_USART_STOPBITS_1
N  *         @arg @ref LL_USART_STOPBITS_1_5
N  *         @arg @ref LL_USART_STOPBITS_2
N  */
N__STATIC_INLINE uint32_t LL_USART_GetStopBitsLength(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetStopBitsLength(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
X  return (uint32_t)(((USARTx->CR2) & ((0x3UL << (12U)))));
N}
N
N/**
N  * @brief  Configure Character frame format (Datawidth, Parity control, Stop Bits)
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Data Width configuration using @ref LL_USART_SetDataWidth() function
N  *         - Parity Control and mode configuration using @ref LL_USART_SetParity() function
N  *         - Stop bits configuration using @ref LL_USART_SetStopBitsLength() function
N  * @rmtoll CR1          PS            LL_USART_ConfigCharacter\n
N  *         CR1          PCE           LL_USART_ConfigCharacter\n
N  *         CR1          M0            LL_USART_ConfigCharacter\n
N  *         CR1          M1            LL_USART_ConfigCharacter\n
N  *         CR2          STOP          LL_USART_ConfigCharacter
N  * @param  USARTx USART Instance
N  * @param  DataWidth This parameter can be one of the following values:
N  *         @arg @ref LL_USART_DATAWIDTH_7B
N  *         @arg @ref LL_USART_DATAWIDTH_8B
N  *         @arg @ref LL_USART_DATAWIDTH_9B
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PARITY_NONE
N  *         @arg @ref LL_USART_PARITY_EVEN
N  *         @arg @ref LL_USART_PARITY_ODD
N  * @param  StopBits This parameter can be one of the following values:
N  *         @arg @ref LL_USART_STOPBITS_0_5
N  *         @arg @ref LL_USART_STOPBITS_1
N  *         @arg @ref LL_USART_STOPBITS_1_5
N  *         @arg @ref LL_USART_STOPBITS_2
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
Xstatic __inline void LL_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
N                                              uint32_t StopBits)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1UL << (9U)) | (0x1UL << (10U)) | (0x10001UL << (12U))))) | (Parity | DataWidth))));
N  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x3UL << (12U))))) | (StopBits))));
N}
N
N/**
N  * @brief  Configure TX/RX pins swapping setting.
N  * @rmtoll CR2          SWAP          LL_USART_SetTXRXSwap
N  * @param  USARTx USART Instance
N  * @param  SwapConfig This parameter can be one of the following values:
N  *         @arg @ref LL_USART_TXRX_STANDARD
N  *         @arg @ref LL_USART_TXRX_SWAPPED
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetTXRXSwap(USART_TypeDef *USARTx, uint32_t SwapConfig)
Xstatic __inline void LL_USART_SetTXRXSwap(USART_TypeDef *USARTx, uint32_t SwapConfig)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_SWAP, SwapConfig);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (15U))))) | (SwapConfig))));
N}
N
N/**
N  * @brief  Retrieve TX/RX pins swapping configuration.
N  * @rmtoll CR2          SWAP          LL_USART_GetTXRXSwap
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_TXRX_STANDARD
N  *         @arg @ref LL_USART_TXRX_SWAPPED
N  */
N__STATIC_INLINE uint32_t LL_USART_GetTXRXSwap(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetTXRXSwap(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_SWAP));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (15U)))));
N}
N
N/**
N  * @brief  Configure RX pin active level logic
N  * @rmtoll CR2          RXINV         LL_USART_SetRXPinLevel
N  * @param  USARTx USART Instance
N  * @param  PinInvMethod This parameter can be one of the following values:
N  *         @arg @ref LL_USART_RXPIN_LEVEL_STANDARD
N  *         @arg @ref LL_USART_RXPIN_LEVEL_INVERTED
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetRXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod)
Xstatic __inline void LL_USART_SetRXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_RXINV, PinInvMethod);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (16U))))) | (PinInvMethod))));
N}
N
N/**
N  * @brief  Retrieve RX pin active level logic configuration
N  * @rmtoll CR2          RXINV         LL_USART_GetRXPinLevel
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_RXPIN_LEVEL_STANDARD
N  *         @arg @ref LL_USART_RXPIN_LEVEL_INVERTED
N  */
N__STATIC_INLINE uint32_t LL_USART_GetRXPinLevel(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetRXPinLevel(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_RXINV));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Configure TX pin active level logic
N  * @rmtoll CR2          TXINV         LL_USART_SetTXPinLevel
N  * @param  USARTx USART Instance
N  * @param  PinInvMethod This parameter can be one of the following values:
N  *         @arg @ref LL_USART_TXPIN_LEVEL_STANDARD
N  *         @arg @ref LL_USART_TXPIN_LEVEL_INVERTED
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetTXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod)
Xstatic __inline void LL_USART_SetTXPinLevel(USART_TypeDef *USARTx, uint32_t PinInvMethod)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_TXINV, PinInvMethod);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (17U))))) | (PinInvMethod))));
N}
N
N/**
N  * @brief  Retrieve TX pin active level logic configuration
N  * @rmtoll CR2          TXINV         LL_USART_GetTXPinLevel
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_TXPIN_LEVEL_STANDARD
N  *         @arg @ref LL_USART_TXPIN_LEVEL_INVERTED
N  */
N__STATIC_INLINE uint32_t LL_USART_GetTXPinLevel(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetTXPinLevel(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_TXINV));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (17U)))));
N}
N
N/**
N  * @brief  Configure Binary data logic.
N  * @note   Allow to define how Logical data from the data register are send/received :
N  *         either in positive/direct logic (1=H, 0=L) or in negative/inverse logic (1=L, 0=H)
N  * @rmtoll CR2          DATAINV       LL_USART_SetBinaryDataLogic
N  * @param  USARTx USART Instance
N  * @param  DataLogic This parameter can be one of the following values:
N  *         @arg @ref LL_USART_BINARY_LOGIC_POSITIVE
N  *         @arg @ref LL_USART_BINARY_LOGIC_NEGATIVE
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetBinaryDataLogic(USART_TypeDef *USARTx, uint32_t DataLogic)
Xstatic __inline void LL_USART_SetBinaryDataLogic(USART_TypeDef *USARTx, uint32_t DataLogic)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_DATAINV, DataLogic);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (18U))))) | (DataLogic))));
N}
N
N/**
N  * @brief  Retrieve Binary data configuration
N  * @rmtoll CR2          DATAINV       LL_USART_GetBinaryDataLogic
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_BINARY_LOGIC_POSITIVE
N  *         @arg @ref LL_USART_BINARY_LOGIC_NEGATIVE
N  */
N__STATIC_INLINE uint32_t LL_USART_GetBinaryDataLogic(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetBinaryDataLogic(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_DATAINV));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (18U)))));
N}
N
N/**
N  * @brief  Configure transfer bit order (either Less or Most Significant Bit First)
N  * @note   MSB First means data is transmitted/received with the MSB first, following the start bit.
N  *         LSB First means data is transmitted/received with data bit 0 first, following the start bit.
N  * @rmtoll CR2          MSBFIRST      LL_USART_SetTransferBitOrder
N  * @param  USARTx USART Instance
N  * @param  BitOrder This parameter can be one of the following values:
N  *         @arg @ref LL_USART_BITORDER_LSBFIRST
N  *         @arg @ref LL_USART_BITORDER_MSBFIRST
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetTransferBitOrder(USART_TypeDef *USARTx, uint32_t BitOrder)
Xstatic __inline void LL_USART_SetTransferBitOrder(USART_TypeDef *USARTx, uint32_t BitOrder)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_MSBFIRST, BitOrder);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (19U))))) | (BitOrder))));
N}
N
N/**
N  * @brief  Return transfer bit order (either Less or Most Significant Bit First)
N  * @note   MSB First means data is transmitted/received with the MSB first, following the start bit.
N  *         LSB First means data is transmitted/received with data bit 0 first, following the start bit.
N  * @rmtoll CR2          MSBFIRST      LL_USART_GetTransferBitOrder
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_BITORDER_LSBFIRST
N  *         @arg @ref LL_USART_BITORDER_MSBFIRST
N  */
N__STATIC_INLINE uint32_t LL_USART_GetTransferBitOrder(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetTransferBitOrder(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_MSBFIRST));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (19U)))));
N}
N
N/**
N  * @brief  Enable Auto Baud-Rate Detection
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABREN         LL_USART_EnableAutoBaudRate
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableAutoBaudRate(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableAutoBaudRate(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR2, USART_CR2_ABREN);
X  ((USARTx->CR2) |= ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Disable Auto Baud-Rate Detection
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABREN         LL_USART_DisableAutoBaudRate
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableAutoBaudRate(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableAutoBaudRate(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR2, USART_CR2_ABREN);
X  ((USARTx->CR2) &= ~((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Indicate if Auto Baud-Rate Detection mechanism is enabled
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABREN         LL_USART_IsEnabledAutoBaud
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledAutoBaud(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledAutoBaud(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR2, USART_CR2_ABREN) == (USART_CR2_ABREN));
X  return (((USARTx->CR2) & ((0x1UL << (20U)))) == ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Set Auto Baud-Rate mode bits
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABRMODE       LL_USART_SetAutoBaudRateMode
N  * @param  USARTx USART Instance
N  * @param  AutoBaudRateMode This parameter can be one of the following values:
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_STARTBIT
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_7F_FRAME
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_55_FRAME
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetAutoBaudRateMode(USART_TypeDef *USARTx, uint32_t AutoBaudRateMode)
Xstatic __inline void LL_USART_SetAutoBaudRateMode(USART_TypeDef *USARTx, uint32_t AutoBaudRateMode)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_ABRMODE, AutoBaudRateMode);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x3UL << (21U))))) | (AutoBaudRateMode))));
N}
N
N/**
N  * @brief  Return Auto Baud-Rate mode
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll CR2          ABRMODE       LL_USART_GetAutoBaudRateMode
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_STARTBIT
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_FALLINGEDGE
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_7F_FRAME
N  *         @arg @ref LL_USART_AUTOBAUD_DETECT_ON_55_FRAME
N  */
N__STATIC_INLINE uint32_t LL_USART_GetAutoBaudRateMode(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetAutoBaudRateMode(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ABRMODE));
X  return (uint32_t)(((USARTx->CR2) & ((0x3UL << (21U)))));
N}
N
N/**
N  * @brief  Enable Receiver Timeout
N  * @rmtoll CR2          RTOEN         LL_USART_EnableRxTimeout
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableRxTimeout(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableRxTimeout(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR2, USART_CR2_RTOEN);
X  ((USARTx->CR2) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Disable Receiver Timeout
N  * @rmtoll CR2          RTOEN         LL_USART_DisableRxTimeout
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableRxTimeout(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableRxTimeout(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR2, USART_CR2_RTOEN);
X  ((USARTx->CR2) &= ~((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Indicate if Receiver Timeout feature is enabled
N  * @rmtoll CR2          RTOEN         LL_USART_IsEnabledRxTimeout
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledRxTimeout(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledRxTimeout(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR2, USART_CR2_RTOEN) == (USART_CR2_RTOEN));
X  return (((USARTx->CR2) & ((0x1UL << (23U)))) == ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Set Address of the USART node.
N  * @note   This is used in multiprocessor communication during Mute mode or Stop mode,
N  *         for wake up with address mark detection.
N  * @note   4bits address node is used when 4-bit Address Detection is selected in ADDM7.
N  *         (b7-b4 should be set to 0)
N  *         8bits address node is used when 7-bit Address Detection is selected in ADDM7.
N  *         (This is used in multiprocessor communication during Mute mode or Stop mode,
N  *         for wake up with 7-bit address mark detection.
N  *         The MSB of the character sent by the transmitter should be equal to 1.
N  *         It may also be used for character detection during normal reception,
N  *         Mute mode inactive (for example, end of block detection in ModBus protocol).
N  *         In this case, the whole received character (8-bit) is compared to the ADD[7:0]
N  *         value and CMF flag is set on match)
N  * @rmtoll CR2          ADD           LL_USART_ConfigNodeAddress\n
N  *         CR2          ADDM7         LL_USART_ConfigNodeAddress
N  * @param  USARTx USART Instance
N  * @param  AddressLen This parameter can be one of the following values:
N  *         @arg @ref LL_USART_ADDRESS_DETECT_4B
N  *         @arg @ref LL_USART_ADDRESS_DETECT_7B
N  * @param  NodeAddress 4 or 7 bit Address of the USART node.
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigNodeAddress(USART_TypeDef *USARTx, uint32_t AddressLen, uint32_t NodeAddress)
Xstatic __inline void LL_USART_ConfigNodeAddress(USART_TypeDef *USARTx, uint32_t AddressLen, uint32_t NodeAddress)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_ADD | USART_CR2_ADDM7,
N             (uint32_t)(AddressLen | (NodeAddress << USART_CR2_ADD_Pos)));
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0xFFUL << (24U)) | (0x1UL << (4U))))) | ((uint32_t)(AddressLen | (NodeAddress << (24U)))))));
N}
N
N/**
N  * @brief  Return 8 bit Address of the USART node as set in ADD field of CR2.
N  * @note   If 4-bit Address Detection is selected in ADDM7,
N  *         only 4bits (b3-b0) of returned value are relevant (b31-b4 are not relevant)
N  *         If 7-bit Address Detection is selected in ADDM7,
N  *         only 8bits (b7-b0) of returned value are relevant (b31-b8 are not relevant)
N  * @rmtoll CR2          ADD           LL_USART_GetNodeAddress
N  * @param  USARTx USART Instance
N  * @retval Address of the USART node (Value between Min_Data=0 and Max_Data=255)
N  */
N__STATIC_INLINE uint32_t LL_USART_GetNodeAddress(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetNodeAddress(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADD) >> USART_CR2_ADD_Pos);
X  return (uint32_t)(((USARTx->CR2) & ((0xFFUL << (24U)))) >> (24U));
N}
N
N/**
N  * @brief  Return Length of Node Address used in Address Detection mode (7-bit or 4-bit)
N  * @rmtoll CR2          ADDM7         LL_USART_GetNodeAddressLen
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_ADDRESS_DETECT_4B
N  *         @arg @ref LL_USART_ADDRESS_DETECT_7B
N  */
N__STATIC_INLINE uint32_t LL_USART_GetNodeAddressLen(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetNodeAddressLen(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADDM7));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Enable RTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          LL_USART_EnableRTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_RTSE);
X  ((USARTx->CR3) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable RTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          LL_USART_DisableRTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_RTSE);
X  ((USARTx->CR3) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable CTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSE          LL_USART_EnableCTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_CTSE);
X  ((USARTx->CR3) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable CTS HW Flow Control
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSE          LL_USART_DisableCTSHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_CTSE);
X  ((USARTx->CR3) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Configure HW Flow Control mode (both CTS and RTS)
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          LL_USART_SetHWFlowCtrl\n
N  *         CR3          CTSE          LL_USART_SetHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @param  HardwareFlowControl This parameter can be one of the following values:
N  *         @arg @ref LL_USART_HWCONTROL_NONE
N  *         @arg @ref LL_USART_HWCONTROL_RTS
N  *         @arg @ref LL_USART_HWCONTROL_CTS
N  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
Xstatic __inline void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
N{
N  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x1UL << (8U)) | (0x1UL << (9U))))) | (HardwareFlowControl))));
N}
N
N/**
N  * @brief  Return HW Flow Control configuration (both CTS and RTS)
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          RTSE          LL_USART_GetHWFlowCtrl\n
N  *         CR3          CTSE          LL_USART_GetHWFlowCtrl
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_HWCONTROL_NONE
N  *         @arg @ref LL_USART_HWCONTROL_RTS
N  *         @arg @ref LL_USART_HWCONTROL_CTS
N  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
N  */
N__STATIC_INLINE uint32_t LL_USART_GetHWFlowCtrl(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetHWFlowCtrl(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
X  return (uint32_t)(((USARTx->CR3) & ((0x1UL << (8U)) | (0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Enable One bit sampling method
N  * @rmtoll CR3          ONEBIT        LL_USART_EnableOneBitSamp
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableOneBitSamp(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableOneBitSamp(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_ONEBIT);
X  ((USARTx->CR3) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable One bit sampling method
N  * @rmtoll CR3          ONEBIT        LL_USART_DisableOneBitSamp
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableOneBitSamp(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableOneBitSamp(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_ONEBIT);
X  ((USARTx->CR3) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicate if One bit sampling method is enabled
N  * @rmtoll CR3          ONEBIT        LL_USART_IsEnabledOneBitSamp
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_ONEBIT) == (USART_CR3_ONEBIT));
X  return (((USARTx->CR3) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Enable Overrun detection
N  * @rmtoll CR3          OVRDIS        LL_USART_EnableOverrunDetect
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableOverrunDetect(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableOverrunDetect(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_OVRDIS);
X  ((USARTx->CR3) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable Overrun detection
N  * @rmtoll CR3          OVRDIS        LL_USART_DisableOverrunDetect
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableOverrunDetect(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableOverrunDetect(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_OVRDIS);
X  ((USARTx->CR3) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Indicate if Overrun detection is enabled
N  * @rmtoll CR3          OVRDIS        LL_USART_IsEnabledOverrunDetect
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledOverrunDetect(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledOverrunDetect(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_OVRDIS) != USART_CR3_OVRDIS);
X  return (((USARTx->CR3) & ((0x1UL << (12U)))) != (0x1UL << (12U)));
N}
N
N/**
N  * @brief  Select event type for Wake UP Interrupt Flag (WUS[1:0] bits)
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUS           LL_USART_SetWKUPType
N  * @param  USARTx USART Instance
N  * @param  Type This parameter can be one of the following values:
N  *         @arg @ref LL_USART_WAKEUP_ON_ADDRESS
N  *         @arg @ref LL_USART_WAKEUP_ON_STARTBIT
N  *         @arg @ref LL_USART_WAKEUP_ON_RXNE
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetWKUPType(USART_TypeDef *USARTx, uint32_t Type)
Xstatic __inline void LL_USART_SetWKUPType(USART_TypeDef *USARTx, uint32_t Type)
N{
N  MODIFY_REG(USARTx->CR3, USART_CR3_WUS, Type);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x3UL << (20U))))) | (Type))));
N}
N
N/**
N  * @brief  Return event type for Wake UP Interrupt Flag (WUS[1:0] bits)
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUS           LL_USART_GetWKUPType
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_WAKEUP_ON_ADDRESS
N  *         @arg @ref LL_USART_WAKEUP_ON_STARTBIT
N  *         @arg @ref LL_USART_WAKEUP_ON_RXNE
N  */
N__STATIC_INLINE uint32_t LL_USART_GetWKUPType(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetWKUPType(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_WUS));
X  return (uint32_t)(((USARTx->CR3) & ((0x3UL << (20U)))));
N}
N
N/**
N  * @brief  Configure USART BRR register for achieving expected Baud Rate value.
N  * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
N  *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
N  * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
N  *         (Baud rate value != 0)
N  * @note   In case of oversampling by 16 and 8, BRR content must be greater than or equal to 16d.
N  * @rmtoll BRR          BRR           LL_USART_SetBaudRate
N  * @param  USARTx USART Instance
N  * @param  PeriphClk Peripheral Clock
N  @if USART_PRESC_PRESCALER
N  * @param  PrescalerValue This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PRESCALER_DIV1
N  *         @arg @ref LL_USART_PRESCALER_DIV2
N  *         @arg @ref LL_USART_PRESCALER_DIV4
N  *         @arg @ref LL_USART_PRESCALER_DIV6
N  *         @arg @ref LL_USART_PRESCALER_DIV8
N  *         @arg @ref LL_USART_PRESCALER_DIV10
N  *         @arg @ref LL_USART_PRESCALER_DIV12
N  *         @arg @ref LL_USART_PRESCALER_DIV16
N  *         @arg @ref LL_USART_PRESCALER_DIV32
N  *         @arg @ref LL_USART_PRESCALER_DIV64
N  *         @arg @ref LL_USART_PRESCALER_DIV128
N  *         @arg @ref LL_USART_PRESCALER_DIV256
N  @endif
N  * @param  OverSampling This parameter can be one of the following values:
N  *         @arg @ref LL_USART_OVERSAMPLING_16
N  *         @arg @ref LL_USART_OVERSAMPLING_8
N  * @param  BaudRate Baud Rate
N  * @retval None
N  */
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S__STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t PrescalerValue, uint32_t OverSampling,
S                                          uint32_t BaudRate)
N#else
N__STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
Xstatic __inline void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
N                                          uint32_t BaudRate)
N#endif
N{
N  register uint32_t usartdiv = 0x0U;
N  register uint32_t brrtemp = 0x0U;
N
N  if (OverSampling == LL_USART_OVERSAMPLING_8)
X  if (OverSampling == (0x1UL << (15U)))
N  {
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint16_t)PrescalerValue, BaudRate));
N#else
N    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
X    usartdiv = (uint16_t)(((((PeriphClk)*2U) + ((BaudRate)/2U))/(BaudRate)));
N#endif
N    brrtemp = usartdiv & 0xFFF0U;
N    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
N    USARTx->BRR = brrtemp;
N  }
N  else
N  {
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint16_t)PrescalerValue, BaudRate));
N#else
N    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
X    USARTx->BRR = (uint16_t)((((PeriphClk) + ((BaudRate)/2U))/(BaudRate)));
N#endif
N  }
N}
N
N/**
N  * @brief  Return current Baud Rate value, according to USARTDIV present in BRR register
N  *         (full BRR content), and to used Peripheral Clock and Oversampling mode values
N  * @note   In case of non-initialized or invalid value stored in BRR register, value 0 will be returned.
N  * @note   In case of oversampling by 16 and 8, BRR content must be greater than or equal to 16d.
N  * @rmtoll BRR          BRR           LL_USART_GetBaudRate
N  * @param  USARTx USART Instance
N  * @param  PeriphClk Peripheral Clock
N  @if USART_PRESC_PRESCALER
N  * @param  PrescalerValue This parameter can be one of the following values:
N  *         @arg @ref LL_USART_PRESCALER_DIV1
N  *         @arg @ref LL_USART_PRESCALER_DIV2
N  *         @arg @ref LL_USART_PRESCALER_DIV4
N  *         @arg @ref LL_USART_PRESCALER_DIV6
N  *         @arg @ref LL_USART_PRESCALER_DIV8
N  *         @arg @ref LL_USART_PRESCALER_DIV10
N  *         @arg @ref LL_USART_PRESCALER_DIV12
N  *         @arg @ref LL_USART_PRESCALER_DIV16
N  *         @arg @ref LL_USART_PRESCALER_DIV32
N  *         @arg @ref LL_USART_PRESCALER_DIV64
N  *         @arg @ref LL_USART_PRESCALER_DIV128
N  *         @arg @ref LL_USART_PRESCALER_DIV256
N  @endif
N  * @param  OverSampling This parameter can be one of the following values:
N  *         @arg @ref LL_USART_OVERSAMPLING_16
N  *         @arg @ref LL_USART_OVERSAMPLING_8
N  * @retval Baud Rate
N  */
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S__STATIC_INLINE uint32_t LL_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t PrescalerValue, uint32_t OverSampling)
N#else
N__STATIC_INLINE uint32_t LL_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling)
Xstatic __inline uint32_t LL_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling)
N#endif
N{
N  register uint32_t usartdiv = 0x0U;
N  register uint32_t brrresult = 0x0U;
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S  register uint32_t periphclkpresc = (uint32_t)(PeriphClk / (uint32_t)(USART_PRESCALER_TAB[(uint16_t)PrescalerValue]));
N#endif
N
N  usartdiv = USARTx->BRR;
N
N  if (OverSampling == LL_USART_OVERSAMPLING_8)
X  if (OverSampling == (0x1UL << (15U)))
N  {
N    if ((usartdiv & 0xFFF7U) != 0U)
N    {
N      usartdiv = (uint16_t)((usartdiv & 0xFFF0U) | ((usartdiv & 0x0007U) << 1U)) ;
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S      brrresult = (periphclkpresc * 2U) / usartdiv;
N#else
N      brrresult = (PeriphClk * 2U) / usartdiv;
N#endif
N    }
N  }
N  else
N  {
N    if ((usartdiv & 0xFFFFU) != 0U)
N    {
N#if defined(USART_PRESC_PRESCALER)
X#if 0L
S      brrresult = periphclkpresc / usartdiv;
N#else
N      brrresult = PeriphClk / usartdiv;
N#endif
N    }
N  }
N  return (brrresult);
N}
N
N/**
N  * @brief  Set Receiver Time Out Value (expressed in nb of bits duration)
N  * @rmtoll RTOR         RTO           LL_USART_SetRxTimeout
N  * @param  USARTx USART Instance
N  * @param  Timeout Value between Min_Data=0x00 and Max_Data=0x00FFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetRxTimeout(USART_TypeDef *USARTx, uint32_t Timeout)
Xstatic __inline void LL_USART_SetRxTimeout(USART_TypeDef *USARTx, uint32_t Timeout)
N{
N  MODIFY_REG(USARTx->RTOR, USART_RTOR_RTO, Timeout);
X  (((USARTx->RTOR)) = ((((((USARTx->RTOR))) & (~((0xFFFFFFUL << (0U))))) | (Timeout))));
N}
N
N/**
N  * @brief  Get Receiver Time Out Value (expressed in nb of bits duration)
N  * @rmtoll RTOR         RTO           LL_USART_GetRxTimeout
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x00FFFFFF
N  */
N__STATIC_INLINE uint32_t LL_USART_GetRxTimeout(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetRxTimeout(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->RTOR, USART_RTOR_RTO));
X  return (uint32_t)(((USARTx->RTOR) & ((0xFFFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set Block Length value in reception
N  * @rmtoll RTOR         BLEN          LL_USART_SetBlockLength
N  * @param  USARTx USART Instance
N  * @param  BlockLength Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetBlockLength(USART_TypeDef *USARTx, uint32_t BlockLength)
Xstatic __inline void LL_USART_SetBlockLength(USART_TypeDef *USARTx, uint32_t BlockLength)
N{
N  MODIFY_REG(USARTx->RTOR, USART_RTOR_BLEN, BlockLength << USART_RTOR_BLEN_Pos);
X  (((USARTx->RTOR)) = ((((((USARTx->RTOR))) & (~((0xFFUL << (24U))))) | (BlockLength << (24U)))));
N}
N
N/**
N  * @brief  Get Block Length value in reception
N  * @rmtoll RTOR         BLEN          LL_USART_GetBlockLength
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t LL_USART_GetBlockLength(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetBlockLength(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->RTOR, USART_RTOR_BLEN) >> USART_RTOR_BLEN_Pos);
X  return (uint32_t)(((USARTx->RTOR) & ((0xFFUL << (24U)))) >> (24U));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_Configuration_IRDA Configuration functions related to Irda feature
N  * @{
N  */
N
N/**
N  * @brief  Enable IrDA mode
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IREN          LL_USART_EnableIrda
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIrda(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIrda(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_IREN);
X  ((USARTx->CR3) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable IrDA mode
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IREN          LL_USART_DisableIrda
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIrda(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIrda(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_IREN);
X  ((USARTx->CR3) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicate if IrDA mode is enabled
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IREN          LL_USART_IsEnabledIrda
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIrda(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIrda(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_IREN) == (USART_CR3_IREN));
X  return (((USARTx->CR3) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Configure IrDA Power Mode (Normal or Low Power)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IRLP          LL_USART_SetIrdaPowerMode
N  * @param  USARTx USART Instance
N  * @param  PowerMode This parameter can be one of the following values:
N  *         @arg @ref LL_USART_IRDA_POWER_NORMAL
N  *         @arg @ref LL_USART_IRDA_POWER_LOW
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetIrdaPowerMode(USART_TypeDef *USARTx, uint32_t PowerMode)
Xstatic __inline void LL_USART_SetIrdaPowerMode(USART_TypeDef *USARTx, uint32_t PowerMode)
N{
N  MODIFY_REG(USARTx->CR3, USART_CR3_IRLP, PowerMode);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x1UL << (2U))))) | (PowerMode))));
N}
N
N/**
N  * @brief  Retrieve IrDA Power Mode configuration (Normal or Low Power)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll CR3          IRLP          LL_USART_GetIrdaPowerMode
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_IRDA_POWER_NORMAL
N  *         @arg @ref LL_USART_PHASE_2EDGE
N  */
N__STATIC_INLINE uint32_t LL_USART_GetIrdaPowerMode(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetIrdaPowerMode(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_IRLP));
X  return (uint32_t)(((USARTx->CR3) & ((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Set Irda prescaler value, used for dividing the USART clock source
N  *         to achieve the Irda Low Power frequency (8 bits value)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           LL_USART_SetIrdaPrescaler
N  * @param  USARTx USART Instance
N  * @param  PrescalerValue Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetIrdaPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
Xstatic __inline void LL_USART_SetIrdaPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
N{
N  MODIFY_REG(USARTx->GTPR, USART_GTPR_PSC, (uint16_t)PrescalerValue);
X  (((USARTx->GTPR)) = ((((((USARTx->GTPR))) & (~((0xFFUL << (0U))))) | ((uint16_t)PrescalerValue))));
N}
N
N/**
N  * @brief  Return Irda prescaler value, used for dividing the USART clock source
N  *         to achieve the Irda Low Power frequency (8 bits value)
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           LL_USART_GetIrdaPrescaler
N  * @param  USARTx USART Instance
N  * @retval Irda prescaler value (Value between Min_Data=0x00 and Max_Data=0xFF)
N  */
N__STATIC_INLINE uint32_t LL_USART_GetIrdaPrescaler(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetIrdaPrescaler(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_PSC));
X  return (uint32_t)(((USARTx->GTPR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_Configuration_Smartcard Configuration functions related to Smartcard feature
N  * @{
N  */
N
N/**
N  * @brief  Enable Smartcard NACK transmission
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          NACK          LL_USART_EnableSmartcardNACK
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableSmartcardNACK(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableSmartcardNACK(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_NACK);
X  ((USARTx->CR3) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable Smartcard NACK transmission
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          NACK          LL_USART_DisableSmartcardNACK
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableSmartcardNACK(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableSmartcardNACK(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_NACK);
X  ((USARTx->CR3) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Indicate if Smartcard NACK transmission is enabled
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          NACK          LL_USART_IsEnabledSmartcardNACK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledSmartcardNACK(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledSmartcardNACK(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_NACK) == (USART_CR3_NACK));
X  return (((USARTx->CR3) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable Smartcard mode
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCEN          LL_USART_EnableSmartcard
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableSmartcard(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableSmartcard(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_SCEN);
X  ((USARTx->CR3) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Smartcard mode
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCEN          LL_USART_DisableSmartcard
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableSmartcard(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableSmartcard(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_SCEN);
X  ((USARTx->CR3) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Indicate if Smartcard mode is enabled
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCEN          LL_USART_IsEnabledSmartcard
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledSmartcard(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledSmartcard(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_SCEN) == (USART_CR3_SCEN));
X  return (((USARTx->CR3) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Set Smartcard Auto-Retry Count value (SCARCNT[2:0] bits)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @note   This bit-field specifies the number of retries in transmit and receive, in Smartcard mode.
N  *         In transmission mode, it specifies the number of automatic retransmission retries, before
N  *         generating a transmission error (FE bit set).
N  *         In reception mode, it specifies the number or erroneous reception trials, before generating a
N  *         reception error (RXNE and PE bits set)
N  * @rmtoll CR3          SCARCNT       LL_USART_SetSmartcardAutoRetryCount
N  * @param  USARTx USART Instance
N  * @param  AutoRetryCount Value between Min_Data=0 and Max_Data=7
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetSmartcardAutoRetryCount(USART_TypeDef *USARTx, uint32_t AutoRetryCount)
Xstatic __inline void LL_USART_SetSmartcardAutoRetryCount(USART_TypeDef *USARTx, uint32_t AutoRetryCount)
N{
N  MODIFY_REG(USARTx->CR3, USART_CR3_SCARCNT, AutoRetryCount << USART_CR3_SCARCNT_Pos);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x7UL << (17U))))) | (AutoRetryCount << (17U)))));
N}
N
N/**
N  * @brief  Return Smartcard Auto-Retry Count value (SCARCNT[2:0] bits)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          SCARCNT       LL_USART_GetSmartcardAutoRetryCount
N  * @param  USARTx USART Instance
N  * @retval Smartcard Auto-Retry Count value (Value between Min_Data=0 and Max_Data=7)
N  */
N__STATIC_INLINE uint32_t LL_USART_GetSmartcardAutoRetryCount(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetSmartcardAutoRetryCount(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_SCARCNT) >> USART_CR3_SCARCNT_Pos);
X  return (uint32_t)(((USARTx->CR3) & ((0x7UL << (17U)))) >> (17U));
N}
N
N/**
N  * @brief  Set Smartcard prescaler value, used for dividing the USART clock
N  *         source to provide the SMARTCARD Clock (5 bits value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           LL_USART_SetSmartcardPrescaler
N  * @param  USARTx USART Instance
N  * @param  PrescalerValue Value between Min_Data=0 and Max_Data=31
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetSmartcardPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
Xstatic __inline void LL_USART_SetSmartcardPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
N{
N  MODIFY_REG(USARTx->GTPR, USART_GTPR_PSC, (uint16_t)PrescalerValue);
X  (((USARTx->GTPR)) = ((((((USARTx->GTPR))) & (~((0xFFUL << (0U))))) | ((uint16_t)PrescalerValue))));
N}
N
N/**
N  * @brief  Return Smartcard prescaler value, used for dividing the USART clock
N  *         source to provide the SMARTCARD Clock (5 bits value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         PSC           LL_USART_GetSmartcardPrescaler
N  * @param  USARTx USART Instance
N  * @retval Smartcard prescaler value (Value between Min_Data=0 and Max_Data=31)
N  */
N__STATIC_INLINE uint32_t LL_USART_GetSmartcardPrescaler(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetSmartcardPrescaler(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_PSC));
X  return (uint32_t)(((USARTx->GTPR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set Smartcard Guard time value, expressed in nb of baud clocks periods
N  *         (GT[7:0] bits : Guard time value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         GT            LL_USART_SetSmartcardGuardTime
N  * @param  USARTx USART Instance
N  * @param  GuardTime Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetSmartcardGuardTime(USART_TypeDef *USARTx, uint32_t GuardTime)
Xstatic __inline void LL_USART_SetSmartcardGuardTime(USART_TypeDef *USARTx, uint32_t GuardTime)
N{
N  MODIFY_REG(USARTx->GTPR, USART_GTPR_GT, GuardTime << USART_GTPR_GT_Pos);
X  (((USARTx->GTPR)) = ((((((USARTx->GTPR))) & (~((0xFFUL << (8U))))) | (GuardTime << (8U)))));
N}
N
N/**
N  * @brief  Return Smartcard Guard time value, expressed in nb of baud clocks periods
N  *         (GT[7:0] bits : Guard time value)
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll GTPR         GT            LL_USART_GetSmartcardGuardTime
N  * @param  USARTx USART Instance
N  * @retval Smartcard Guard time value (Value between Min_Data=0x00 and Max_Data=0xFF)
N  */
N__STATIC_INLINE uint32_t LL_USART_GetSmartcardGuardTime(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetSmartcardGuardTime(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_GT) >> USART_GTPR_GT_Pos);
X  return (uint32_t)(((USARTx->GTPR) & ((0xFFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_Configuration_HalfDuplex Configuration functions related to Half Duplex feature
N  * @{
N  */
N
N/**
N  * @brief  Enable Single Wire Half-Duplex mode
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @rmtoll CR3          HDSEL         LL_USART_EnableHalfDuplex
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableHalfDuplex(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableHalfDuplex(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
X  ((USARTx->CR3) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable Single Wire Half-Duplex mode
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @rmtoll CR3          HDSEL         LL_USART_DisableHalfDuplex
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableHalfDuplex(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableHalfDuplex(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
X  ((USARTx->CR3) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Indicate if Single Wire Half-Duplex mode is enabled
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @rmtoll CR3          HDSEL         LL_USART_IsEnabledHalfDuplex
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledHalfDuplex(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledHalfDuplex(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_HDSEL) == (USART_CR3_HDSEL));
X  return (((USARTx->CR3) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USART_CR2_SLVEN)
X#if 0L
S/** @defgroup USART_LL_EF_Configuration_SPI_SLAVE Configuration functions related to SPI Slave feature
S  * @{
S  */
S/**
S  * @brief  Enable SPI Synchronous Slave mode
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @rmtoll CR2          SLVEN         LL_USART_EnableSPISlave
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableSPISlave(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR2, USART_CR2_SLVEN);
S}
S
S/**
S  * @brief  Disable SPI Synchronous Slave mode
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @rmtoll CR2          SLVEN         LL_USART_DisableSPISlave
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableSPISlave(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR2, USART_CR2_SLVEN);
S}
S
S/**
S  * @brief  Indicate if  SPI Synchronous Slave mode is enabled
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @rmtoll CR2          SLVEN         LL_USART_IsEnabledSPISlave
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledSPISlave(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR2, USART_CR2_SLVEN) == (USART_CR2_SLVEN));
S}
S
S/**
S  * @brief  Enable SPI Slave Selection using NSS input pin
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @note   SPI Slave Selection depends on NSS input pin
S  *         (The slave is selected when NSS is low and deselected when NSS is high).
S  * @rmtoll CR2          DIS_NSS       LL_USART_EnableSPISlaveSelect
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableSPISlaveSelect(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR2, USART_CR2_DIS_NSS);
S}
S
S/**
S  * @brief  Disable SPI Slave Selection using NSS input pin
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @note   SPI Slave will be always selected and NSS input pin will be ignored.
S  * @rmtoll CR2          DIS_NSS       LL_USART_DisableSPISlaveSelect
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableSPISlaveSelect(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR2, USART_CR2_DIS_NSS);
S}
S
S/**
S  * @brief  Indicate if  SPI Slave Selection depends on NSS input pin
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @rmtoll CR2          DIS_NSS       LL_USART_IsEnabledSPISlaveSelect
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledSPISlaveSelect(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR2, USART_CR2_DIS_NSS) != (USART_CR2_DIS_NSS));
S}
S
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup USART_LL_EF_Configuration_LIN Configuration functions related to LIN feature
N  * @{
N  */
N
N/**
N  * @brief  Set LIN Break Detection Length
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDL          LL_USART_SetLINBrkDetectionLen
N  * @param  USARTx USART Instance
N  * @param  LINBDLength This parameter can be one of the following values:
N  *         @arg @ref LL_USART_LINBREAK_DETECT_10B
N  *         @arg @ref LL_USART_LINBREAK_DETECT_11B
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetLINBrkDetectionLen(USART_TypeDef *USARTx, uint32_t LINBDLength)
Xstatic __inline void LL_USART_SetLINBrkDetectionLen(USART_TypeDef *USARTx, uint32_t LINBDLength)
N{
N  MODIFY_REG(USARTx->CR2, USART_CR2_LBDL, LINBDLength);
X  (((USARTx->CR2)) = ((((((USARTx->CR2))) & (~((0x1UL << (5U))))) | (LINBDLength))));
N}
N
N/**
N  * @brief  Return LIN Break Detection Length
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDL          LL_USART_GetLINBrkDetectionLen
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_LINBREAK_DETECT_10B
N  *         @arg @ref LL_USART_LINBREAK_DETECT_11B
N  */
N__STATIC_INLINE uint32_t LL_USART_GetLINBrkDetectionLen(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetLINBrkDetectionLen(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBDL));
X  return (uint32_t)(((USARTx->CR2) & ((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Enable LIN mode
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LINEN         LL_USART_EnableLIN
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableLIN(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableLIN(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR2, USART_CR2_LINEN);
X  ((USARTx->CR2) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable LIN mode
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LINEN         LL_USART_DisableLIN
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableLIN(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableLIN(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR2, USART_CR2_LINEN);
X  ((USARTx->CR2) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate if LIN mode is enabled
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LINEN         LL_USART_IsEnabledLIN
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledLIN(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledLIN(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR2, USART_CR2_LINEN) == (USART_CR2_LINEN));
X  return (((USARTx->CR2) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_Configuration_DE Configuration functions related to Driver Enable feature
N  * @{
N  */
N
N/**
N  * @brief  Set DEDT (Driver Enable De-Assertion Time), Time value expressed on 5 bits ([4:0] bits).
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEDT          LL_USART_SetDEDeassertionTime
N  * @param  USARTx USART Instance
N  * @param  Time Value between Min_Data=0 and Max_Data=31
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetDEDeassertionTime(USART_TypeDef *USARTx, uint32_t Time)
Xstatic __inline void LL_USART_SetDEDeassertionTime(USART_TypeDef *USARTx, uint32_t Time)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_DEDT, Time << USART_CR1_DEDT_Pos);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1FUL << (16U))))) | (Time << (16U)))));
N}
N
N/**
N  * @brief  Return DEDT (Driver Enable De-Assertion Time)
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEDT          LL_USART_GetDEDeassertionTime
N  * @param  USARTx USART Instance
N  * @retval Time value expressed on 5 bits ([4:0] bits) : Value between Min_Data=0 and Max_Data=31
N  */
N__STATIC_INLINE uint32_t LL_USART_GetDEDeassertionTime(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetDEDeassertionTime(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_DEDT) >> USART_CR1_DEDT_Pos);
X  return (uint32_t)(((USARTx->CR1) & ((0x1FUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Set DEAT (Driver Enable Assertion Time), Time value expressed on 5 bits ([4:0] bits).
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEAT          LL_USART_SetDEAssertionTime
N  * @param  USARTx USART Instance
N  * @param  Time Value between Min_Data=0 and Max_Data=31
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetDEAssertionTime(USART_TypeDef *USARTx, uint32_t Time)
Xstatic __inline void LL_USART_SetDEAssertionTime(USART_TypeDef *USARTx, uint32_t Time)
N{
N  MODIFY_REG(USARTx->CR1, USART_CR1_DEAT, Time << USART_CR1_DEAT_Pos);
X  (((USARTx->CR1)) = ((((((USARTx->CR1))) & (~((0x1FUL << (21U))))) | (Time << (21U)))));
N}
N
N/**
N  * @brief  Return DEAT (Driver Enable Assertion Time)
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR1          DEAT          LL_USART_GetDEAssertionTime
N  * @param  USARTx USART Instance
N  * @retval Time value expressed on 5 bits ([4:0] bits) : Value between Min_Data=0 and Max_Data=31
N  */
N__STATIC_INLINE uint32_t LL_USART_GetDEAssertionTime(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetDEAssertionTime(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_DEAT) >> USART_CR1_DEAT_Pos);
X  return (uint32_t)(((USARTx->CR1) & ((0x1FUL << (21U)))) >> (21U));
N}
N
N/**
N  * @brief  Enable Driver Enable (DE) Mode
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEM           LL_USART_EnableDEMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableDEMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableDEMode(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_DEM);
X  ((USARTx->CR3) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable Driver Enable (DE) Mode
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEM           LL_USART_DisableDEMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableDEMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableDEMode(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DEM);
X  ((USARTx->CR3) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate if Driver Enable (DE) Mode is enabled
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEM           LL_USART_IsEnabledDEMode
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledDEMode(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledDEMode(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_DEM) == (USART_CR3_DEM));
X  return (((USARTx->CR3) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Select Driver Enable Polarity
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEP           LL_USART_SetDESignalPolarity
N  * @param  USARTx USART Instance
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref LL_USART_DE_POLARITY_HIGH
N  *         @arg @ref LL_USART_DE_POLARITY_LOW
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_SetDESignalPolarity(USART_TypeDef *USARTx, uint32_t Polarity)
Xstatic __inline void LL_USART_SetDESignalPolarity(USART_TypeDef *USARTx, uint32_t Polarity)
N{
N  MODIFY_REG(USARTx->CR3, USART_CR3_DEP, Polarity);
X  (((USARTx->CR3)) = ((((((USARTx->CR3))) & (~((0x1UL << (15U))))) | (Polarity))));
N}
N
N/**
N  * @brief  Return Driver Enable Polarity
N  * @note   Macro @ref IS_UART_DRIVER_ENABLE_INSTANCE(USARTx) can be used to check whether or not
N  *         Driver Enable feature is supported by the USARTx instance.
N  * @rmtoll CR3          DEP           LL_USART_GetDESignalPolarity
N  * @param  USARTx USART Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_USART_DE_POLARITY_HIGH
N  *         @arg @ref LL_USART_DE_POLARITY_LOW
N  */
N__STATIC_INLINE uint32_t LL_USART_GetDESignalPolarity(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_GetDESignalPolarity(USART_TypeDef *USARTx)
N{
N  return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_DEP));
X  return (uint32_t)(((USARTx->CR3) & ((0x1UL << (15U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_AdvancedConfiguration Advanced Configurations services
N  * @{
N  */
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Asynchronous Mode (UART)
N  * @note   In UART mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register,
N  *           - CLKEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register,
N  *           - IREN bit in the USART_CR3 register,
N  *           - HDSEL bit in the USART_CR3 register.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
N  *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
N  *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
N  *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
N  * @note   Other remaining configurations items related to Asynchronous Mode
N  *         (as Baud Rate, Word length, Parity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         LL_USART_ConfigAsyncMode\n
N  *         CR2          CLKEN         LL_USART_ConfigAsyncMode\n
N  *         CR3          SCEN          LL_USART_ConfigAsyncMode\n
N  *         CR3          IREN          LL_USART_ConfigAsyncMode\n
N  *         CR3          HDSEL         LL_USART_ConfigAsyncMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigAsyncMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigAsyncMode(USART_TypeDef *USARTx)
N{
N  /* In Asynchronous mode, the following bits must be kept cleared:
N  - LINEN, CLKEN bits in the USART_CR2 register,
N  - SCEN, IREN and HDSEL bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (1U)) | (0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Synchronous Mode
N  * @note   In Synchronous mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register,
N  *           - IREN bit in the USART_CR3 register,
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also sets the USART in Synchronous mode.
N  * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
N  *         Synchronous mode is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
N  *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
N  *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
N  *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
N  *         - Set CLKEN in CR2 using @ref LL_USART_EnableSCLKOutput() function
N  * @note   Other remaining configurations items related to Synchronous Mode
N  *         (as Baud Rate, Word length, Parity, Clock Polarity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         LL_USART_ConfigSyncMode\n
N  *         CR2          CLKEN         LL_USART_ConfigSyncMode\n
N  *         CR3          SCEN          LL_USART_ConfigSyncMode\n
N  *         CR3          IREN          LL_USART_ConfigSyncMode\n
N  *         CR3          HDSEL         LL_USART_ConfigSyncMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigSyncMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigSyncMode(USART_TypeDef *USARTx)
N{
N  /* In Synchronous mode, the following bits must be kept cleared:
N  - LINEN bit in the USART_CR2 register,
N  - SCEN, IREN and HDSEL bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (1U)) | (0x1UL << (3U)))));
N  /* set the UART/USART in Synchronous mode */
N  SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
X  ((USARTx->CR2) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in LIN Mode
N  * @note   In LIN mode, the following bits must be kept cleared:
N  *           - STOP and CLKEN bits in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register,
N  *           - IREN bit in the USART_CR3 register,
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also set the UART/USART in LIN mode.
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
N  *         - Clear STOP in CR2 using @ref LL_USART_SetStopBitsLength() function
N  *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
N  *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
N  *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
N  *         - Set LINEN in CR2 using @ref LL_USART_EnableLIN() function
N  * @note   Other remaining configurations items related to LIN Mode
N  *         (as Baud Rate, Word length, LIN Break Detection Length, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          CLKEN         LL_USART_ConfigLINMode\n
N  *         CR2          STOP          LL_USART_ConfigLINMode\n
N  *         CR2          LINEN         LL_USART_ConfigLINMode\n
N  *         CR3          IREN          LL_USART_ConfigLINMode\n
N  *         CR3          SCEN          LL_USART_ConfigLINMode\n
N  *         CR3          HDSEL         LL_USART_ConfigLINMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigLINMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigLINMode(USART_TypeDef *USARTx)
N{
N  /* In LIN mode, the following bits must be kept cleared:
N  - STOP and CLKEN bits in the USART_CR2 register,
N  - IREN, SCEN and HDSEL bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_CLKEN | USART_CR2_STOP));
X  ((USARTx->CR2) &= ~(((0x1UL << (11U)) | (0x3UL << (12U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (1U)) | (0x1UL << (5U)) | (0x1UL << (3U)))));
N  /* Set the UART/USART in LIN mode */
N  SET_BIT(USARTx->CR2, USART_CR2_LINEN);
X  ((USARTx->CR2) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Half Duplex Mode
N  * @note   In Half Duplex mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register,
N  *           - CLKEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register,
N  *           - IREN bit in the USART_CR3 register,
N  *         This function also sets the UART/USART in Half Duplex mode.
N  * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
N  *         Half-Duplex mode is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
N  *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
N  *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
N  *         - Set HDSEL in CR3 using @ref LL_USART_EnableHalfDuplex() function
N  * @note   Other remaining configurations items related to Half Duplex Mode
N  *         (as Baud Rate, Word length, Parity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         LL_USART_ConfigHalfDuplexMode\n
N  *         CR2          CLKEN         LL_USART_ConfigHalfDuplexMode\n
N  *         CR3          HDSEL         LL_USART_ConfigHalfDuplexMode\n
N  *         CR3          SCEN          LL_USART_ConfigHalfDuplexMode\n
N  *         CR3          IREN          LL_USART_ConfigHalfDuplexMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigHalfDuplexMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigHalfDuplexMode(USART_TypeDef *USARTx)
N{
N  /* In Half Duplex mode, the following bits must be kept cleared:
N  - LINEN and CLKEN bits in the USART_CR2 register,
N  - SCEN and IREN bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (1U)))));
N  /* set the UART/USART in Half Duplex mode */
N  SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
X  ((USARTx->CR3) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Smartcard Mode
N  * @note   In Smartcard mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register,
N  *           - IREN bit in the USART_CR3 register,
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also configures Stop bits to 1.5 bits and
N  *         sets the USART in Smartcard mode (SCEN bit).
N  *         Clock Output is also enabled (CLKEN).
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
N  *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
N  *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
N  *         - Configure STOP in CR2 using @ref LL_USART_SetStopBitsLength() function
N  *         - Set CLKEN in CR2 using @ref LL_USART_EnableSCLKOutput() function
N  *         - Set SCEN in CR3 using @ref LL_USART_EnableSmartcard() function
N  * @note   Other remaining configurations items related to Smartcard Mode
N  *         (as Baud Rate, Word length, Parity, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         LL_USART_ConfigSmartcardMode\n
N  *         CR2          STOP          LL_USART_ConfigSmartcardMode\n
N  *         CR2          CLKEN         LL_USART_ConfigSmartcardMode\n
N  *         CR3          HDSEL         LL_USART_ConfigSmartcardMode\n
N  *         CR3          SCEN          LL_USART_ConfigSmartcardMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigSmartcardMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigSmartcardMode(USART_TypeDef *USARTx)
N{
N  /* In Smartcard mode, the following bits must be kept cleared:
N  - LINEN bit in the USART_CR2 register,
N  - IREN and HDSEL bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_IREN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (1U)) | (0x1UL << (3U)))));
N  /* Configure Stop bits to 1.5 bits */
N  /* Synchronous mode is activated by default */
N  SET_BIT(USARTx->CR2, (USART_CR2_STOP_0 | USART_CR2_STOP_1 | USART_CR2_CLKEN));
X  ((USARTx->CR2) |= (((0x1UL << (12U)) | (0x2UL << (12U)) | (0x1UL << (11U)))));
N  /* set the UART/USART in Smartcard mode */
N  SET_BIT(USARTx->CR3, USART_CR3_SCEN);
X  ((USARTx->CR3) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Irda Mode
N  * @note   In IRDA mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register,
N  *           - STOP and CLKEN bits in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register,
N  *           - HDSEL bit in the USART_CR3 register.
N  *         This function also sets the UART/USART in IRDA mode (IREN bit).
N  * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
N  *         IrDA feature is supported by the USARTx instance.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
N  *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
N  *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
N  *         - Configure STOP in CR2 using @ref LL_USART_SetStopBitsLength() function
N  *         - Set IREN in CR3 using @ref LL_USART_EnableIrda() function
N  * @note   Other remaining configurations items related to Irda Mode
N  *         (as Baud Rate, Word length, Power mode, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         LL_USART_ConfigIrdaMode\n
N  *         CR2          CLKEN         LL_USART_ConfigIrdaMode\n
N  *         CR2          STOP          LL_USART_ConfigIrdaMode\n
N  *         CR3          SCEN          LL_USART_ConfigIrdaMode\n
N  *         CR3          HDSEL         LL_USART_ConfigIrdaMode\n
N  *         CR3          IREN          LL_USART_ConfigIrdaMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigIrdaMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigIrdaMode(USART_TypeDef *USARTx)
N{
N  /* In IRDA mode, the following bits must be kept cleared:
N  - LINEN, STOP and CLKEN bits in the USART_CR2 register,
N  - SCEN and HDSEL bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN | USART_CR2_STOP));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)) | (0x3UL << (12U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (3U)))));
N  /* set the UART/USART in IRDA mode */
N  SET_BIT(USARTx->CR3, USART_CR3_IREN);
X  ((USARTx->CR3) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Perform basic configuration of USART for enabling use in Multi processor Mode
N  *         (several USARTs connected in a network, one of the USARTs can be the master,
N  *         its TX output connected to the RX inputs of the other slaves USARTs).
N  * @note   In MultiProcessor mode, the following bits must be kept cleared:
N  *           - LINEN bit in the USART_CR2 register,
N  *           - CLKEN bit in the USART_CR2 register,
N  *           - SCEN bit in the USART_CR3 register,
N  *           - IREN bit in the USART_CR3 register,
N  *           - HDSEL bit in the USART_CR3 register.
N  * @note   Call of this function is equivalent to following function call sequence :
N  *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
N  *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
N  *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
N  *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
N  *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
N  * @note   Other remaining configurations items related to Multi processor Mode
N  *         (as Baud Rate, Wake Up Method, Node address, ...) should be set using
N  *         dedicated functions
N  * @rmtoll CR2          LINEN         LL_USART_ConfigMultiProcessMode\n
N  *         CR2          CLKEN         LL_USART_ConfigMultiProcessMode\n
N  *         CR3          SCEN          LL_USART_ConfigMultiProcessMode\n
N  *         CR3          HDSEL         LL_USART_ConfigMultiProcessMode\n
N  *         CR3          IREN          LL_USART_ConfigMultiProcessMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ConfigMultiProcessMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ConfigMultiProcessMode(USART_TypeDef *USARTx)
N{
N  /* In Multi Processor mode, the following bits must be kept cleared:
N  - LINEN and CLKEN bits in the USART_CR2 register,
N  - IREN, SCEN and HDSEL bits in the USART_CR3 register.*/
N  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
X  ((USARTx->CR2) &= ~(((0x1UL << (14U)) | (0x1UL << (11U)))));
N  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
X  ((USARTx->CR3) &= ~(((0x1UL << (5U)) | (0x1UL << (3U)) | (0x1UL << (1U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Check if the USART Parity Error Flag is set or not
N  * @rmtoll ISR          PE            LL_USART_IsActiveFlag_PE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_PE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_PE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_PE) == (USART_ISR_PE));
X  return (((USARTx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if the USART Framing Error Flag is set or not
N  * @rmtoll ISR          FE            LL_USART_IsActiveFlag_FE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_FE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_FE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE));
X  return (((USARTx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if the USART Noise error detected Flag is set or not
N  * @rmtoll ISR          NF            LL_USART_IsActiveFlag_NE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_NE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_NE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE));
X  return (((USARTx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if the USART OverRun Error Flag is set or not
N  * @rmtoll ISR          ORE           LL_USART_IsActiveFlag_ORE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_ORE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_ORE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE));
X  return (((USARTx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if the USART IDLE line detected Flag is set or not
N  * @rmtoll ISR          IDLE          LL_USART_IsActiveFlag_IDLE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_IDLE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_IDLE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE));
X  return (((USARTx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_IsActiveFlag_RXNE  LL_USART_IsActiveFlag_RXNE_RXFNE
S
S/**
S  * @brief  Check if the USART Read Data Register or USART RX FIFO Not Empty Flag is set or not
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          RXNE_RXFNE    LL_USART_IsActiveFlag_RXNE_RXFNE
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RXNE_RXFNE(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_RXNE_RXFNE) == (USART_ISR_RXNE_RXFNE));
S}
N#else
N
N/**
N  * @brief  Check if the USART Read Data Register Not Empty Flag is set or not
N  * @rmtoll ISR          RXNE          LL_USART_IsActiveFlag_RXNE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_RXNE) == (USART_ISR_RXNE));
X  return (((USARTx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N#endif
N
N/**
N  * @brief  Check if the USART Transmission Complete Flag is set or not
N  * @rmtoll ISR          TC            LL_USART_IsActiveFlag_TC
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC));
X  return (((USARTx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_IsActiveFlag_TXE  LL_USART_IsActiveFlag_TXE_TXFNF
S
S/**
S  * @brief  Check if the USART Transmit Data Register Empty or USART TX FIFO Not Full Flag is set or not
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          TXE_TXFNF     LL_USART_IsActiveFlag_TXE_TXFNF
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE_TXFNF(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_TXE_TXFNF) == (USART_ISR_TXE_TXFNF));
S}
N#else
N
N/**
N  * @brief  Check if the USART Transmit Data Register Empty Flag is set or not
N  * @rmtoll ISR          TXE           LL_USART_IsActiveFlag_TXE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_TXE) == (USART_ISR_TXE));
X  return (((USARTx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N#endif
N
N/**
N  * @brief  Check if the USART LIN Break Detection Flag is set or not
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll ISR          LBDF          LL_USART_IsActiveFlag_LBD
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_LBDF) == (USART_ISR_LBDF));
X  return (((USARTx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if the USART CTS interrupt Flag is set or not
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll ISR          CTSIF         LL_USART_IsActiveFlag_nCTS
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_CTSIF) == (USART_ISR_CTSIF));
X  return (((USARTx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Check if the USART CTS Flag is set or not
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll ISR          CTS           LL_USART_IsActiveFlag_CTS
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_CTS(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_CTS(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_CTS) == (USART_ISR_CTS));
X  return (((USARTx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Check if the USART Receiver Time Out Flag is set or not
N  * @rmtoll ISR          RTOF          LL_USART_IsActiveFlag_RTO
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RTO(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_RTO(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_RTOF) == (USART_ISR_RTOF));
X  return (((USARTx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Check if the USART End Of Block Flag is set or not
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll ISR          EOBF          LL_USART_IsActiveFlag_EOB
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_EOB(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_EOB(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_EOBF) == (USART_ISR_EOBF));
X  return (((USARTx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N#if defined(USART_CR2_SLVEN)
X#if 0L
S/**
S  * @brief  Check if the SPI Slave Underrun error flag is set or not
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          UDR           LL_USART_IsActiveFlag_UDR
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_UDR(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_UDR) == (USART_ISR_UDR));
S}
S
N#endif
N/**
N  * @brief  Check if the USART Auto-Baud Rate Error Flag is set or not
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll ISR          ABRE          LL_USART_IsActiveFlag_ABRE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_ABRE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_ABRE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_ABRE) == (USART_ISR_ABRE));
X  return (((USARTx->ISR) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Check if the USART Auto-Baud Rate Flag is set or not
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll ISR          ABRF          LL_USART_IsActiveFlag_ABR
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_ABR(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_ABR(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_ABRF) == (USART_ISR_ABRF));
X  return (((USARTx->ISR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if the USART Busy Flag is set or not
N  * @rmtoll ISR          BUSY          LL_USART_IsActiveFlag_BUSY
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_BUSY(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_BUSY(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_BUSY) == (USART_ISR_BUSY));
X  return (((USARTx->ISR) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Check if the USART Character Match Flag is set or not
N  * @rmtoll ISR          CMF           LL_USART_IsActiveFlag_CM
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_CM(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_CM(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_CMF) == (USART_ISR_CMF));
X  return (((USARTx->ISR) & ((0x1UL << (17U)))) == ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Check if the USART Send Break Flag is set or not
N  * @rmtoll ISR          SBKF          LL_USART_IsActiveFlag_SBK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_SBKF) == (USART_ISR_SBKF));
X  return (((USARTx->ISR) & ((0x1UL << (18U)))) == ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Check if the USART Receive Wake Up from mute mode Flag is set or not
N  * @rmtoll ISR          RWU           LL_USART_IsActiveFlag_RWU
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_RWU) == (USART_ISR_RWU));
X  return (((USARTx->ISR) & ((0x1UL << (19U)))) == ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Check if the USART Wake Up from stop mode Flag is set or not
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll ISR          WUF           LL_USART_IsActiveFlag_WKUP
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_WKUP(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_WKUP(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_WUF) == (USART_ISR_WUF));
X  return (((USARTx->ISR) & ((0x1UL << (20U)))) == ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Check if the USART Transmit Enable Acknowledge Flag is set or not
N  * @rmtoll ISR          TEACK         LL_USART_IsActiveFlag_TEACK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TEACK(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_TEACK(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK));
X  return (((USARTx->ISR) & ((0x1UL << (21U)))) == ((0x1UL << (21U))));
N}
N
N/**
N  * @brief  Check if the USART Receive Enable Acknowledge Flag is set or not
N  * @rmtoll ISR          REACK         LL_USART_IsActiveFlag_REACK
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_REACK(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_REACK(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_REACK) == (USART_ISR_REACK));
X  return (((USARTx->ISR) & ((0x1UL << (22U)))) == ((0x1UL << (22U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Check if the USART TX FIFO Empty Flag is set or not
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          TXFE          LL_USART_IsActiveFlag_TXFE
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXFE(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_TXFE) == (USART_ISR_TXFE));
S}
S
S/**
S  * @brief  Check if the USART RX FIFO Full Flag is set or not
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          RXFF          LL_USART_IsActiveFlag_RXFF
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RXFF(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_RXFF) == (USART_ISR_RXFF));
S}
N#endif
N
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N/* Function available only on devices supporting Transmit Complete before Guard Time feature */
N/**
N  * @brief  Check if the Smartcard Transmission Complete Before Guard Time Flag is set or not
N  * @rmtoll ISR          TCBGT         LL_USART_IsActiveFlag_TCBGT
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TCBGT(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsActiveFlag_TCBGT(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->ISR, USART_ISR_TCBGT) == (USART_ISR_TCBGT));
X  return (((USARTx->ISR) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N#endif
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Check if the USART TX FIFO Threshold Flag is set or not
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          TXFT          LL_USART_IsActiveFlag_TXFT
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXFT(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_TXFT) == (USART_ISR_TXFT));
S}
S
S/**
S  * @brief  Check if the USART RX FIFO Threshold Flag is set or not
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ISR          RXFT          LL_USART_IsActiveFlag_RXFT
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RXFT(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->ISR, USART_ISR_RXFT) == (USART_ISR_RXFT));
S}
N#endif
N
N/**
N  * @brief  Clear Parity Error Flag
N  * @rmtoll ICR          PECF          LL_USART_ClearFlag_PE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_PE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_PE(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_PECF);
X  ((USARTx->ICR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Framing Error Flag
N  * @rmtoll ICR          FECF          LL_USART_ClearFlag_FE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_FE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_FE(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_FECF);
X  ((USARTx->ICR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear Noise Error detected Flag
N  * @rmtoll ICR          NECF           LL_USART_ClearFlag_NE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_NE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_NE(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_NECF);
X  ((USARTx->ICR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear OverRun Error Flag
N  * @rmtoll ICR          ORECF         LL_USART_ClearFlag_ORE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_ORECF);
X  ((USARTx->ICR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear IDLE line detected Flag
N  * @rmtoll ICR          IDLECF        LL_USART_ClearFlag_IDLE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_IDLE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_IDLE(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
X  ((USARTx->ICR) = ((0x1UL << (4U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Clear TX FIFO Empty Flag
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll ICR          TXFECF        LL_USART_ClearFlag_TXFE
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_ClearFlag_TXFE(USART_TypeDef *USARTx)
S{
S  WRITE_REG(USARTx->ICR, USART_ICR_TXFECF);
S}
N#endif
N
N/**
N  * @brief  Clear Transmission Complete Flag
N  * @rmtoll ICR          TCCF          LL_USART_ClearFlag_TC
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
X  ((USARTx->ICR) = ((0x1UL << (6U))));
N}
N
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N/* Function available only on devices supporting Transmit Complete before Guard Time feature */
N/**
N  * @brief  Clear Smartcard Transmission Complete Before Guard Time Flag
N  * @rmtoll ICR          TCBGTCF       LL_USART_ClearFlag_TCBGT
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_TCBGT(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_TCBGT(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_TCBGTCF);
X  ((USARTx->ICR) = ((0x1UL << (7U))));
N}
N#endif
N
N/**
N  * @brief  Clear LIN Break Detection Flag
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll ICR          LBDCF         LL_USART_ClearFlag_LBD
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_LBD(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_LBD(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_LBDCF);
X  ((USARTx->ICR) = ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear CTS Interrupt Flag
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll ICR          CTSCF         LL_USART_ClearFlag_nCTS
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_nCTS(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_nCTS(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_CTSCF);
X  ((USARTx->ICR) = ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear Receiver Time Out Flag
N  * @rmtoll ICR          RTOCF         LL_USART_ClearFlag_RTO
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_RTO(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_RTO(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_RTOCF);
X  ((USARTx->ICR) = ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Clear End Of Block Flag
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll ICR          EOBCF         LL_USART_ClearFlag_EOB
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_EOB(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_EOB(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_EOBCF);
X  ((USARTx->ICR) = ((0x1UL << (12U))));
N}
N
N#if defined(USART_CR2_SLVEN)
X#if 0L
S/**
S  * @brief  Clear SPI Slave Underrun Flag
S  * @note   Macro @ref IS_UART_SPI_SLAVE_INSTANCE(USARTx) can be used to check whether or not
S  *         SPI Slave mode feature is supported by the USARTx instance.
S  * @rmtoll ICR          UDRCF         LL_USART_ClearFlag_UDR
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_ClearFlag_UDR(USART_TypeDef *USARTx)
S{
S  WRITE_REG(USARTx->ICR, USART_ICR_UDRCF);
S}
S
N#endif
N/**
N  * @brief  Clear Character Match Flag
N  * @rmtoll ICR          CMCF          LL_USART_ClearFlag_CM
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_CM(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_CM(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_CMCF);
X  ((USARTx->ICR) = ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Clear Wake Up from stop mode Flag
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll ICR          WUCF          LL_USART_ClearFlag_WKUP
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_ClearFlag_WKUP(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_ClearFlag_WKUP(USART_TypeDef *USARTx)
N{
N  WRITE_REG(USARTx->ICR, USART_ICR_WUCF);
X  ((USARTx->ICR) = ((0x1UL << (20U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable IDLE Interrupt
N  * @rmtoll CR1          IDLEIE        LL_USART_EnableIT_IDLE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_IDLE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_IDLE(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
X  ((USARTx->CR1) |= ((0x1UL << (4U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_EnableIT_RXNE  LL_USART_EnableIT_RXNE_RXFNE
S
S/**
S  * @brief  Enable RX Not Empty and RX FIFO Not Empty Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1        RXNEIE_RXFNEIE  LL_USART_EnableIT_RXNE_RXFNE
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableIT_RXNE_RXFNE(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
S}
N#else
N
N/**
N  * @brief  Enable RX Not Empty Interrupt
N  * @rmtoll CR1          RXNEIE        LL_USART_EnableIT_RXNE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
X  ((USARTx->CR1) |= ((0x1UL << (5U))));
N}
N#endif
N
N/**
N  * @brief  Enable Transmission Complete Interrupt
N  * @rmtoll CR1          TCIE          LL_USART_EnableIT_TC
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_TC(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_TC(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_TCIE);
X  ((USARTx->CR1) |= ((0x1UL << (6U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_EnableIT_TXE  LL_USART_EnableIT_TXE_TXFNF
S
S/**
S  * @brief  Enable TX Empty and TX FIFO Not Full Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1         TXEIE_TXFNFIE  LL_USART_EnableIT_TXE_TXFNF
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableIT_TXE_TXFNF(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE);
S}
N#else
N
N/**
N  * @brief  Enable TX Empty Interrupt
N  * @rmtoll CR1          TXEIE         LL_USART_EnableIT_TXE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_TXE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_TXE(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
X  ((USARTx->CR1) |= ((0x1UL << (7U))));
N}
N#endif
N
N/**
N  * @brief  Enable Parity Error Interrupt
N  * @rmtoll CR1          PEIE          LL_USART_EnableIT_PE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_PE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_PE(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_PEIE);
X  ((USARTx->CR1) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable Character Match Interrupt
N  * @rmtoll CR1          CMIE          LL_USART_EnableIT_CM
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_CM(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_CM(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_CMIE);
X  ((USARTx->CR1) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Enable Receiver Timeout Interrupt
N  * @rmtoll CR1          RTOIE         LL_USART_EnableIT_RTO
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_RTO(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_RTO(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_RTOIE);
X  ((USARTx->CR1) |= ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Enable End Of Block Interrupt
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR1          EOBIE         LL_USART_EnableIT_EOB
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_EOB(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_EOB(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR1, USART_CR1_EOBIE);
X  ((USARTx->CR1) |= ((0x1UL << (27U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Enable TX FIFO Empty Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          TXFEIE        LL_USART_EnableIT_TXFE
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableIT_TXFE(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR1, USART_CR1_TXFEIE);
S}
S
S/**
S  * @brief  Enable RX FIFO Full Interrupt
S  * @rmtoll CR1          RXFFIE        LL_USART_EnableIT_RXFF
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableIT_RXFF(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR1, USART_CR1_RXFFIE);
S}
N#endif
N
N/**
N  * @brief  Enable LIN Break Detection Interrupt
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDIE         LL_USART_EnableIT_LBD
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_LBD(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_LBD(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
X  ((USARTx->CR2) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable Error Interrupt
N  * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
N  *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_ISR register).
N  *           0: Interrupt is inhibited
N  *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_ISR register.
N  * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_EIE);
X  ((USARTx->CR3) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable CTS Interrupt
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSIE         LL_USART_EnableIT_CTS
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_CTS(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_CTS(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_CTSIE);
X  ((USARTx->CR3) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Enable Wake Up from Stop Mode Interrupt
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUFIE         LL_USART_EnableIT_WKUP
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_WKUP(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_WKUP(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_WUFIE);
X  ((USARTx->CR3) |= ((0x1UL << (22U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Enable TX FIFO Threshold Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          TXFTIE        LL_USART_EnableIT_TXFT
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableIT_TXFT(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR3, USART_CR3_TXFTIE);
S}
N#endif
N
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N/* Function available only on devices supporting Transmit Complete before Guard Time feature */
N/**
N  * @brief  Enable Smartcard Transmission Complete Before Guard Time Interrupt
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          TCBGTIE       LL_USART_EnableIT_TCBGT
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableIT_TCBGT(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableIT_TCBGT(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_TCBGTIE);
X  ((USARTx->CR3) |= ((0x1UL << (24U))));
N}
N#endif
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Enable RX FIFO Threshold Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          RXFTIE        LL_USART_EnableIT_RXFT
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_EnableIT_RXFT(USART_TypeDef *USARTx)
S{
S  SET_BIT(USARTx->CR3, USART_CR3_RXFTIE);
S}
N#endif
N
N/**
N  * @brief  Disable IDLE Interrupt
N  * @rmtoll CR1          IDLEIE        LL_USART_DisableIT_IDLE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_IDLE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_IDLE(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (4U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_DisableIT_RXNE  LL_USART_DisableIT_RXNE_RXFNE
S
S/**
S  * @brief  Disable RX Not Empty and RX FIFO Not Empty Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1        RXNEIE_RXFNEIE  LL_USART_DisableIT_RXNE_RXFNE
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableIT_RXNE_RXFNE(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
S}
N#else
N
N/**
N  * @brief  Disable RX Not Empty Interrupt
N  * @rmtoll CR1          RXNEIE        LL_USART_DisableIT_RXNE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_RXNE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_RXNE(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (5U))));
N}
N#endif
N
N/**
N  * @brief  Disable Transmission Complete Interrupt
N  * @rmtoll CR1          TCIE          LL_USART_DisableIT_TC
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_TC(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_TC(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
X  ((USARTx->CR1) &= ~((0x1UL << (6U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_DisableIT_TXE  LL_USART_DisableIT_TXE_TXFNF
S
S/**
S  * @brief  Disable TX Empty and TX FIFO Not Full Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1        TXEIE_TXFNFIE  LL_USART_DisableIT_TXE_TXFNF
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableIT_TXE_TXFNF(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE);
S}
N#else
N
N/**
N  * @brief  Disable TX Empty Interrupt
N  * @rmtoll CR1          TXEIE         LL_USART_DisableIT_TXE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_TXE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_TXE(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (7U))));
N}
N#endif
N
N/**
N  * @brief  Disable Parity Error Interrupt
N  * @rmtoll CR1          PEIE          LL_USART_DisableIT_PE
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_PE(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_PE(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
X  ((USARTx->CR1) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable Character Match Interrupt
N  * @rmtoll CR1          CMIE          LL_USART_DisableIT_CM
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_CM(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_CM(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_CMIE);
X  ((USARTx->CR1) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable Receiver Timeout Interrupt
N  * @rmtoll CR1          RTOIE         LL_USART_DisableIT_RTO
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_RTO(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_RTO(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_RTOIE);
X  ((USARTx->CR1) &= ~((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Disable End Of Block Interrupt
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR1          EOBIE         LL_USART_DisableIT_EOB
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_EOB(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_EOB(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR1, USART_CR1_EOBIE);
X  ((USARTx->CR1) &= ~((0x1UL << (27U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Disable TX FIFO Empty Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          TXFEIE        LL_USART_DisableIT_TXFE
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableIT_TXFE(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR1, USART_CR1_TXFEIE);
S}
S
S/**
S  * @brief  Disable RX FIFO Full Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          RXFFIE        LL_USART_DisableIT_RXFF
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableIT_RXFF(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR1, USART_CR1_RXFFIE);
S}
N#endif
N
N/**
N  * @brief  Disable LIN Break Detection Interrupt
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDIE         LL_USART_DisableIT_LBD
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_LBD(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_LBD(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
X  ((USARTx->CR2) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable Error Interrupt
N  * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
N  *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_ISR register).
N  *           0: Interrupt is inhibited
N  *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_ISR register.
N  * @rmtoll CR3          EIE           LL_USART_DisableIT_ERROR
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_ERROR(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_ERROR(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
X  ((USARTx->CR3) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable CTS Interrupt
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSIE         LL_USART_DisableIT_CTS
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_CTS(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_CTS(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_CTSIE);
X  ((USARTx->CR3) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable Wake Up from Stop Mode Interrupt
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUFIE         LL_USART_DisableIT_WKUP
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_WKUP(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_WKUP(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_WUFIE);
X  ((USARTx->CR3) &= ~((0x1UL << (22U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Disable TX FIFO Threshold Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          TXFTIE        LL_USART_DisableIT_TXFT
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableIT_TXFT(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR3, USART_CR3_TXFTIE);
S}
N#endif
N
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N/* Function available only on devices supporting Transmit Complete before Guard Time feature */
N/**
N  * @brief  Disable Smartcard Transmission Complete Before Guard Time Interrupt
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          TCBGTIE       LL_USART_DisableIT_TCBGT
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableIT_TCBGT(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableIT_TCBGT(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_TCBGTIE);
X  ((USARTx->CR3) &= ~((0x1UL << (24U))));
N}
N#endif
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Disable RX FIFO Threshold Interrupt
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          RXFTIE        LL_USART_DisableIT_RXFT
S  * @param  USARTx USART Instance
S  * @retval None
S  */
S__STATIC_INLINE void LL_USART_DisableIT_RXFT(USART_TypeDef *USARTx)
S{
S  CLEAR_BIT(USARTx->CR3, USART_CR3_RXFTIE);
S}
N#endif
N
N/**
N  * @brief  Check if the USART IDLE Interrupt  source is enabled or disabled.
N  * @rmtoll CR1          IDLEIE        LL_USART_IsEnabledIT_IDLE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_IDLE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_IDLE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
X  return (((USARTx->CR1) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_IsEnabledIT_RXNE  LL_USART_IsEnabledIT_RXNE_RXFNE
S
S/**
S  * @brief  Check if the USART RX Not Empty and USART RX FIFO Not Empty Interrupt is enabled or disabled.
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1        RXNEIE_RXFNEIE  LL_USART_IsEnabledIT_RXNE_RXFNE
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXNE_RXFNE(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE) == (USART_CR1_RXNEIE_RXFNEIE));
S}
N#else
N
N/**
N  * @brief  Check if the USART RX Not Empty Interrupt is enabled or disabled.
N  * @rmtoll CR1          RXNEIE        LL_USART_IsEnabledIT_RXNE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
X  return (((USARTx->CR1) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N#endif
N
N/**
N  * @brief  Check if the USART Transmission Complete Interrupt is enabled or disabled.
N  * @rmtoll CR1          TCIE          LL_USART_IsEnabledIT_TC
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_TC(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_TC(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE));
X  return (((USARTx->CR1) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/* Legacy define */
S#define LL_USART_IsEnabledIT_TXE  LL_USART_IsEnabledIT_TXE_TXFNF
S
S/**
S  * @brief  Check if the USART TX Empty and USART TX FIFO Not Full Interrupt is enabled or disabled
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1         TXEIE_TXFNFIE  LL_USART_IsEnabledIT_TXE_TXFNF
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_TXE_TXFNF(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE) == (USART_CR1_TXEIE_TXFNFIE));
S}
N#else
N
N/**
N  * @brief  Check if the USART TX Empty Interrupt is enabled or disabled.
N  * @rmtoll CR1          TXEIE         LL_USART_IsEnabledIT_TXE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_TXE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_TXE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_TXEIE) == (USART_CR1_TXEIE));
X  return (((USARTx->CR1) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N#endif
N
N/**
N  * @brief  Check if the USART Parity Error Interrupt is enabled or disabled.
N  * @rmtoll CR1          PEIE          LL_USART_IsEnabledIT_PE
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_PE(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_PE(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_PEIE) == (USART_CR1_PEIE));
X  return (((USARTx->CR1) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if the USART Character Match Interrupt is enabled or disabled.
N  * @rmtoll CR1          CMIE          LL_USART_IsEnabledIT_CM
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_CM(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_CM(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_CMIE) == (USART_CR1_CMIE));
X  return (((USARTx->CR1) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Check if the USART Receiver Timeout Interrupt is enabled or disabled.
N  * @rmtoll CR1          RTOIE         LL_USART_IsEnabledIT_RTO
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RTO(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_RTO(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_RTOIE) == (USART_CR1_RTOIE));
X  return (((USARTx->CR1) & ((0x1UL << (26U)))) == ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Check if the USART End Of Block Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR1          EOBIE         LL_USART_IsEnabledIT_EOB
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_EOB(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_EOB(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR1, USART_CR1_EOBIE) == (USART_CR1_EOBIE));
X  return (((USARTx->CR1) & ((0x1UL << (27U)))) == ((0x1UL << (27U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Check if the USART TX FIFO Empty Interrupt is enabled or disabled
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          TXFEIE        LL_USART_IsEnabledIT_TXFE
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_TXFE(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR1, USART_CR1_TXFEIE) == (USART_CR1_TXFEIE));
S}
S
S/**
S  * @brief  Check if the USART RX FIFO Full Interrupt is enabled or disabled
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR1          RXFFIE        LL_USART_IsEnabledIT_RXFF
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXFF(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR1, USART_CR1_RXFFIE) == (USART_CR1_RXFFIE));
S}
N#endif
N
N/**
N  * @brief  Check if the USART LIN Break Detection Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
N  *         LIN feature is supported by the USARTx instance.
N  * @rmtoll CR2          LBDIE         LL_USART_IsEnabledIT_LBD
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_LBD(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_LBD(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR2, USART_CR2_LBDIE) == (USART_CR2_LBDIE));
X  return (((USARTx->CR2) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if the USART Error Interrupt is enabled or disabled.
N  * @rmtoll CR3          EIE           LL_USART_IsEnabledIT_ERROR
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_ERROR(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_ERROR(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_EIE) == (USART_CR3_EIE));
X  return (((USARTx->CR3) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if the USART CTS Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
N  *         Hardware Flow control feature is supported by the USARTx instance.
N  * @rmtoll CR3          CTSIE         LL_USART_IsEnabledIT_CTS
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_CTS(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_CTS(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_CTSIE) == (USART_CR3_CTSIE));
X  return (((USARTx->CR3) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Check if the USART Wake Up from Stop Mode Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_UART_WAKEUP_FROMSTOP_INSTANCE(USARTx) can be used to check whether or not
N  *         Wake-up from Stop mode feature is supported by the USARTx instance.
N  * @rmtoll CR3          WUFIE         LL_USART_IsEnabledIT_WKUP
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_WKUP(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_WKUP(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_WUFIE) == (USART_CR3_WUFIE));
X  return (((USARTx->CR3) & ((0x1UL << (22U)))) == ((0x1UL << (22U))));
N}
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Check if USART TX FIFO Threshold Interrupt is enabled or disabled
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          TXFTIE        LL_USART_IsEnabledIT_TXFT
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_TXFT(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR3, USART_CR3_TXFTIE) == (USART_CR3_TXFTIE));
S}
N#endif
N
N#if defined(USART_TCBGT_SUPPORT)
X#if 1L
N/* Function available only on devices supporting Transmit Complete before Guard Time feature */
N/**
N  * @brief  Check if the Smartcard Transmission Complete Before Guard Time Interrupt is enabled or disabled.
N  * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
N  *         Smartcard feature is supported by the USARTx instance.
N  * @rmtoll CR3          TCBGTIE       LL_USART_IsEnabledIT_TCBGT
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_TCBGT(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledIT_TCBGT(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_TCBGTIE) == (USART_CR3_TCBGTIE));
X  return (((USARTx->CR3) & ((0x1UL << (24U)))) == ((0x1UL << (24U))));
N}
N#endif
N
N#if defined(USART_CR1_FIFOEN)
X#if 0L
S/**
S  * @brief  Check if USART RX FIFO Threshold Interrupt is enabled or disabled
S  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
S  *         FIFO mode feature is supported by the USARTx instance.
S  * @rmtoll CR3          RXFTIE        LL_USART_IsEnabledIT_RXFT
S  * @param  USARTx USART Instance
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXFT(USART_TypeDef *USARTx)
S{
S  return (READ_BIT(USARTx->CR3, USART_CR3_RXFTIE) == (USART_CR3_RXFTIE));
S}
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_DMA_Management DMA_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable DMA Mode for reception
N  * @rmtoll CR3          DMAR          LL_USART_EnableDMAReq_RX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableDMAReq_RX(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableDMAReq_RX(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_DMAR);
X  ((USARTx->CR3) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable DMA Mode for reception
N  * @rmtoll CR3          DMAR          LL_USART_DisableDMAReq_RX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DMAR);
X  ((USARTx->CR3) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if DMA Mode is enabled for reception
N  * @rmtoll CR3          DMAR          LL_USART_IsEnabledDMAReq_RX
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledDMAReq_RX(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledDMAReq_RX(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_DMAR) == (USART_CR3_DMAR));
X  return (((USARTx->CR3) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable DMA Mode for transmission
N  * @rmtoll CR3          DMAT          LL_USART_EnableDMAReq_TX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableDMAReq_TX(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableDMAReq_TX(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_DMAT);
X  ((USARTx->CR3) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable DMA Mode for transmission
N  * @rmtoll CR3          DMAT          LL_USART_DisableDMAReq_TX
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableDMAReq_TX(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableDMAReq_TX(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
X  ((USARTx->CR3) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if DMA Mode is enabled for transmission
N  * @rmtoll CR3          DMAT          LL_USART_IsEnabledDMAReq_TX
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledDMAReq_TX(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledDMAReq_TX(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_DMAT) == (USART_CR3_DMAT));
X  return (((USARTx->CR3) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Enable DMA Disabling on Reception Error
N  * @rmtoll CR3          DDRE          LL_USART_EnableDMADeactOnRxErr
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_EnableDMADeactOnRxErr(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_EnableDMADeactOnRxErr(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->CR3, USART_CR3_DDRE);
X  ((USARTx->CR3) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable DMA Disabling on Reception Error
N  * @rmtoll CR3          DDRE          LL_USART_DisableDMADeactOnRxErr
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_DisableDMADeactOnRxErr(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_DisableDMADeactOnRxErr(USART_TypeDef *USARTx)
N{
N  CLEAR_BIT(USARTx->CR3, USART_CR3_DDRE);
X  ((USARTx->CR3) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicate if DMA Disabling on Reception Error is disabled
N  * @rmtoll CR3          DDRE          LL_USART_IsEnabledDMADeactOnRxErr
N  * @param  USARTx USART Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_USART_IsEnabledDMADeactOnRxErr(USART_TypeDef *USARTx)
Xstatic __inline uint32_t LL_USART_IsEnabledDMADeactOnRxErr(USART_TypeDef *USARTx)
N{
N  return (READ_BIT(USARTx->CR3, USART_CR3_DDRE) == (USART_CR3_DDRE));
X  return (((USARTx->CR3) & ((0x1UL << (13U)))) == ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Get the data register address used for DMA transfer
N  * @rmtoll RDR          RDR           LL_USART_DMA_GetRegAddr\n
N  * @rmtoll TDR          TDR           LL_USART_DMA_GetRegAddr
N  * @param  USARTx USART Instance
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref LL_USART_DMA_REG_DATA_TRANSMIT
N  *         @arg @ref LL_USART_DMA_REG_DATA_RECEIVE
N  * @retval Address of data register
N  */
N__STATIC_INLINE uint32_t LL_USART_DMA_GetRegAddr(USART_TypeDef *USARTx, uint32_t Direction)
Xstatic __inline uint32_t LL_USART_DMA_GetRegAddr(USART_TypeDef *USARTx, uint32_t Direction)
N{
N  register uint32_t data_reg_addr = 0U;
N
N  if (Direction == LL_USART_DMA_REG_DATA_TRANSMIT)
X  if (Direction == 0x00000000U)
N  {
N    /* return address of TDR register */
N    data_reg_addr = (uint32_t) & (USARTx->TDR);
N  }
N  else
N  {
N    /* return address of RDR register */
N    data_reg_addr = (uint32_t) & (USARTx->RDR);
N  }
N
N  return data_reg_addr;
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_Data_Management Data_Management
N  * @{
N  */
N
N/**
N  * @brief  Read Receiver Data register (Receive Data value, 8 bits)
N  * @rmtoll RDR          RDR           LL_USART_ReceiveData8
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
Xstatic __inline uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
N{
N  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
X  return (uint8_t)(((USARTx->RDR) & ((0x1FFUL << (0U)))));
N}
N
N/**
N  * @brief  Read Receiver Data register (Receive Data value, 9 bits)
N  * @rmtoll RDR          RDR           LL_USART_ReceiveData9
N  * @param  USARTx USART Instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x1FF
N  */
N__STATIC_INLINE uint16_t LL_USART_ReceiveData9(USART_TypeDef *USARTx)
Xstatic __inline uint16_t LL_USART_ReceiveData9(USART_TypeDef *USARTx)
N{
N  return (uint16_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
X  return (uint16_t)(((USARTx->RDR) & ((0x1FFUL << (0U)))));
N}
N
N/**
N  * @brief  Write in Transmitter Data Register (Transmit Data value, 8 bits)
N  * @rmtoll TDR          TDR           LL_USART_TransmitData8
N  * @param  USARTx USART Instance
N  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
Xstatic __inline void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
N{
N  USARTx->TDR = Value;
N}
N
N/**
N  * @brief  Write in Transmitter Data Register (Transmit Data value, 9 bits)
N  * @rmtoll TDR          TDR           LL_USART_TransmitData9
N  * @param  USARTx USART Instance
N  * @param  Value between Min_Data=0x00 and Max_Data=0x1FF
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_TransmitData9(USART_TypeDef *USARTx, uint16_t Value)
Xstatic __inline void LL_USART_TransmitData9(USART_TypeDef *USARTx, uint16_t Value)
N{
N  USARTx->TDR = Value & 0x1FFU;
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_LL_EF_Execution Execution
N  * @{
N  */
N
N/**
N  * @brief  Request an Automatic Baud Rate measurement on next received data frame
N  * @note   Macro @ref IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(USARTx) can be used to check whether or not
N  *         Auto Baud Rate detection feature is supported by the USARTx instance.
N  * @rmtoll RQR          ABRRQ         LL_USART_RequestAutoBaudRate
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_RequestAutoBaudRate(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_RequestAutoBaudRate(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->RQR, USART_RQR_ABRRQ);
X  ((USARTx->RQR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Request Break sending
N  * @rmtoll RQR          SBKRQ         LL_USART_RequestBreakSending
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_RequestBreakSending(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_RequestBreakSending(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->RQR, USART_RQR_SBKRQ);
X  ((USARTx->RQR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Put USART in mute mode and set the RWU flag
N  * @rmtoll RQR          MMRQ          LL_USART_RequestEnterMuteMode
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_RequestEnterMuteMode(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_RequestEnterMuteMode(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->RQR, USART_RQR_MMRQ);
X  ((USARTx->RQR) |= ((0x1UL << (2U))));
N}
N
N/**
N  @if USART_CR1_FIFOEN
N  * @brief  Request a Receive Data and FIFO flush
N  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
N  *         FIFO mode feature is supported by the USARTx instance.
N  * @note   Allows to discard the received data without reading them, and avoid an overrun
N  *         condition.
N  @else
N  * @brief  Request a Receive Data flush
N  @endif
N  * @rmtoll RQR          RXFRQ         LL_USART_RequestRxDataFlush
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_RequestRxDataFlush(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_RequestRxDataFlush(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->RQR, USART_RQR_RXFRQ);
X  ((USARTx->RQR) |= ((0x1UL << (3U))));
N}
N
N/**
N  @if USART_CR1_FIFOEN
N  * @brief  Request a Transmit data and FIFO flush
N  * @note   Macro @ref IS_UART_FIFO_INSTANCE(USARTx) can be used to check whether or not
N  *         FIFO mode feature is supported by the USARTx instance.
N  @else
N  * @brief  Request a Transmit data flush
N  @endif
N  * @rmtoll RQR          TXFRQ         LL_USART_RequestTxDataFlush
N  * @param  USARTx USART Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_USART_RequestTxDataFlush(USART_TypeDef *USARTx)
Xstatic __inline void LL_USART_RequestTxDataFlush(USART_TypeDef *USARTx)
N{
N  SET_BIT(USARTx->RQR, USART_RQR_TXFRQ);
X  ((USARTx->RQR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup USART_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
NErrorStatus LL_USART_DeInit(USART_TypeDef *USARTx);
NErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct);
Nvoid        LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct);
NErrorStatus LL_USART_ClockInit(USART_TypeDef *USARTx, LL_USART_ClockInitTypeDef *USART_ClockInitStruct);
Nvoid        LL_USART_ClockStructInit(LL_USART_ClockInitTypeDef *USART_ClockInitStruct);
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* USART1 || USART2 || USART3 || UART4 || UART5 */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_USART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 7 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_rcc.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_rcc.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_RCC_H
N#define __STM32L4xx_LL_RCC_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined(RCC)
X#if 1L
N
N/** @defgroup RCC_LL RCC
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup RCC_LL_Private_Variables RCC Private Variables
N  * @{
N  */
N
N#if defined(RCC_CCIPR2_PLLSAI2DIVR)
X#if 0L
Sstatic const uint8_t aRCC_PLLSAI2DIVRPrescTable[4] = {2, 4, 8, 16};
N#endif /* RCC_CCIPR2_PLLSAI2DIVR */
N
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCC_LL_Private_Constants RCC Private Constants
N  * @{
N  */
N/* Defines used to perform offsets*/
N/* Offset used to access to RCC_CCIPR and RCC_CCIPR2 registers */
N#define RCC_OFFSET_CCIPR        0U
N#define RCC_OFFSET_CCIPR2       0x14U
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup RCC_LL_Private_Macros RCC Private Macros
N  * @{
N  */
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup RCC_LL_Exported_Types RCC Exported Types
N  * @{
N  */
N
N/** @defgroup LL_ES_CLOCK_FREQ Clocks Frequency Structure
N  * @{
N  */
N
N/**
N  * @brief  RCC Clocks Frequency Structure
N  */
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency;        /*!< SYSCLK clock frequency */
N  uint32_t HCLK_Frequency;          /*!< HCLK clock frequency */
N  uint32_t PCLK1_Frequency;         /*!< PCLK1 clock frequency */
N  uint32_t PCLK2_Frequency;         /*!< PCLK2 clock frequency */
N} LL_RCC_ClocksTypeDef;
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCC_LL_Exported_Constants RCC Exported Constants
N  * @{
N  */
N
N/** @defgroup RCC_LL_EC_OSC_VALUES Oscillator Values adaptation
N  * @brief    Defines used to adapt values of different oscillators
N  * @note     These values could be modified in the user environment according to
N  *           HW set-up.
N  * @{
N  */
N#if !defined  (HSE_VALUE)
X#if !1L
S#define HSE_VALUE    8000000U   /*!< Value of the HSE oscillator in Hz */
N#endif /* HSE_VALUE */
N
N#if !defined  (HSI_VALUE)
X#if !0L
N#define HSI_VALUE    16000000U  /*!< Value of the HSI oscillator in Hz */
N#endif /* HSI_VALUE */
N
N#if !defined  (LSE_VALUE)
X#if !0L
N#define LSE_VALUE    32768U     /*!< Value of the LSE oscillator in Hz */
N#endif /* LSE_VALUE */
N
N#if !defined  (LSI_VALUE)
X#if !0L
N#define LSI_VALUE    32000U     /*!< Value of the LSI oscillator in Hz */
N#endif /* LSI_VALUE */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N
N#if !defined  (HSI48_VALUE)
X#if !0L
N#define HSI48_VALUE  48000000U  /*!< Value of the HSI48 oscillator in Hz */
N#endif /* HSI48_VALUE */
N#endif /* RCC_HSI48_SUPPORT */
N
N#if !defined  (EXTERNAL_SAI1_CLOCK_VALUE)
X#if !0L
N#define EXTERNAL_SAI1_CLOCK_VALUE    48000U /*!< Value of the SAI1_EXTCLK external oscillator in Hz */
N#endif /* EXTERNAL_SAI1_CLOCK_VALUE */
N
N#if !defined  (EXTERNAL_SAI2_CLOCK_VALUE)
X#if !0L
N#define EXTERNAL_SAI2_CLOCK_VALUE    48000U /*!< Value of the SAI2_EXTCLK external oscillator in Hz */
N#endif /* EXTERNAL_SAI2_CLOCK_VALUE */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with LL_RCC_WriteReg function
N  * @{
N  */
N#define LL_RCC_CICR_LSIRDYC                RCC_CICR_LSIRDYC     /*!< LSI Ready Interrupt Clear */
N#define LL_RCC_CICR_LSERDYC                RCC_CICR_LSERDYC     /*!< LSE Ready Interrupt Clear */
N#define LL_RCC_CICR_MSIRDYC                RCC_CICR_MSIRDYC     /*!< MSI Ready Interrupt Clear */
N#define LL_RCC_CICR_HSIRDYC                RCC_CICR_HSIRDYC     /*!< HSI Ready Interrupt Clear */
N#define LL_RCC_CICR_HSERDYC                RCC_CICR_HSERDYC     /*!< HSE Ready Interrupt Clear */
N#define LL_RCC_CICR_PLLRDYC                RCC_CICR_PLLRDYC     /*!< PLL Ready Interrupt Clear */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define LL_RCC_CICR_HSI48RDYC              RCC_CICR_HSI48RDYC   /*!< HSI48 Ready Interrupt Clear */
N#endif /* RCC_HSI48_SUPPORT */
N#define LL_RCC_CICR_PLLSAI1RDYC            RCC_CICR_PLLSAI1RDYC /*!< PLLSAI1 Ready Interrupt Clear */
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S#define LL_RCC_CICR_PLLSAI2RDYC            RCC_CICR_PLLSAI2RDYC /*!< PLLSAI2 Ready Interrupt Clear */
N#endif /* RCC_PLLSAI2_SUPPORT */
N#define LL_RCC_CICR_LSECSSC                RCC_CICR_LSECSSC     /*!< LSE Clock Security System Interrupt Clear */
N#define LL_RCC_CICR_CSSC                   RCC_CICR_CSSC        /*!< Clock Security System Interrupt Clear */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_RCC_ReadReg function
N  * @{
N  */
N#define LL_RCC_CIFR_LSIRDYF                RCC_CIFR_LSIRDYF     /*!< LSI Ready Interrupt flag */
N#define LL_RCC_CIFR_LSERDYF                RCC_CIFR_LSERDYF     /*!< LSE Ready Interrupt flag */
N#define LL_RCC_CIFR_MSIRDYF                RCC_CIFR_MSIRDYF     /*!< MSI Ready Interrupt flag */
N#define LL_RCC_CIFR_HSIRDYF                RCC_CIFR_HSIRDYF     /*!< HSI Ready Interrupt flag */
N#define LL_RCC_CIFR_HSERDYF                RCC_CIFR_HSERDYF     /*!< HSE Ready Interrupt flag */
N#define LL_RCC_CIFR_PLLRDYF                RCC_CIFR_PLLRDYF     /*!< PLL Ready Interrupt flag */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define LL_RCC_CIFR_HSI48RDYF              RCC_CIFR_HSI48RDYF   /*!< HSI48 Ready Interrupt flag */
N#endif /* RCC_HSI48_SUPPORT */
N#define LL_RCC_CIFR_PLLSAI1RDYF            RCC_CIFR_PLLSAI1RDYF /*!< PLLSAI1 Ready Interrupt flag */
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S#define LL_RCC_CIFR_PLLSAI2RDYF            RCC_CIFR_PLLSAI2RDYF /*!< PLLSAI2 Ready Interrupt flag */
N#endif /* RCC_PLLSAI2_SUPPORT */
N#define LL_RCC_CIFR_LSECSSF                RCC_CIFR_LSECSSF     /*!< LSE Clock Security System Interrupt flag */
N#define LL_RCC_CIFR_CSSF                   RCC_CIFR_CSSF        /*!< Clock Security System Interrupt flag */
N#define LL_RCC_CSR_FWRSTF                  RCC_CSR_FWRSTF     /*!< Firewall reset flag */
N#define LL_RCC_CSR_LPWRRSTF                RCC_CSR_LPWRRSTF   /*!< Low-Power reset flag */
N#define LL_RCC_CSR_OBLRSTF                 RCC_CSR_OBLRSTF    /*!< OBL reset flag */
N#define LL_RCC_CSR_PINRSTF                 RCC_CSR_PINRSTF    /*!< PIN reset flag */
N#define LL_RCC_CSR_SFTRSTF                 RCC_CSR_SFTRSTF    /*!< Software Reset flag */
N#define LL_RCC_CSR_IWDGRSTF                RCC_CSR_IWDGRSTF   /*!< Independent Watchdog reset flag */
N#define LL_RCC_CSR_WWDGRSTF                RCC_CSR_WWDGRSTF   /*!< Window watchdog reset flag */
N#define LL_RCC_CSR_BORRSTF                 RCC_CSR_BORRSTF    /*!< BOR reset flag */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_IT IT Defines
N  * @brief    IT defines which can be used with LL_RCC_ReadReg and  LL_RCC_WriteReg functions
N  * @{
N  */
N#define LL_RCC_CIER_LSIRDYIE               RCC_CIER_LSIRDYIE      /*!< LSI Ready Interrupt Enable */
N#define LL_RCC_CIER_LSERDYIE               RCC_CIER_LSERDYIE      /*!< LSE Ready Interrupt Enable */
N#define LL_RCC_CIER_MSIRDYIE               RCC_CIER_MSIRDYIE      /*!< MSI Ready Interrupt Enable */
N#define LL_RCC_CIER_HSIRDYIE               RCC_CIER_HSIRDYIE      /*!< HSI Ready Interrupt Enable */
N#define LL_RCC_CIER_HSERDYIE               RCC_CIER_HSERDYIE      /*!< HSE Ready Interrupt Enable */
N#define LL_RCC_CIER_PLLRDYIE               RCC_CIER_PLLRDYIE      /*!< PLL Ready Interrupt Enable */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define LL_RCC_CIER_HSI48RDYIE             RCC_CIER_HSI48RDYIE    /*!< HSI48 Ready Interrupt Enable */
N#endif /* RCC_HSI48_SUPPORT */
N#define LL_RCC_CIER_PLLSAI1RDYIE           RCC_CIER_PLLSAI1RDYIE  /*!< PLLSAI1 Ready Interrupt Enable */
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S#define LL_RCC_CIER_PLLSAI2RDYIE           RCC_CIER_PLLSAI2RDYIE  /*!< PLLSAI2 Ready Interrupt Enable */
N#endif /* RCC_PLLSAI2_SUPPORT */
N#define LL_RCC_CIER_LSECSSIE               RCC_CIER_LSECSSIE      /*!< LSE CSS Interrupt Enable */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_LSEDRIVE  LSE oscillator drive capability
N  * @{
N  */
N#define LL_RCC_LSEDRIVE_LOW                0x00000000U             /*!< Xtal mode lower driving capability */
N#define LL_RCC_LSEDRIVE_MEDIUMLOW          RCC_BDCR_LSEDRV_0       /*!< Xtal mode medium low driving capability */
N#define LL_RCC_LSEDRIVE_MEDIUMHIGH         RCC_BDCR_LSEDRV_1       /*!< Xtal mode medium high driving capability */
N#define LL_RCC_LSEDRIVE_HIGH               RCC_BDCR_LSEDRV         /*!< Xtal mode higher driving capability */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_MSIRANGE  MSI clock ranges
N  * @{
N  */
N#define LL_RCC_MSIRANGE_0                  RCC_CR_MSIRANGE_0  /*!< MSI = 100 KHz  */
N#define LL_RCC_MSIRANGE_1                  RCC_CR_MSIRANGE_1  /*!< MSI = 200 KHz  */
N#define LL_RCC_MSIRANGE_2                  RCC_CR_MSIRANGE_2  /*!< MSI = 400 KHz  */
N#define LL_RCC_MSIRANGE_3                  RCC_CR_MSIRANGE_3  /*!< MSI = 800 KHz  */
N#define LL_RCC_MSIRANGE_4                  RCC_CR_MSIRANGE_4  /*!< MSI = 1 MHz    */
N#define LL_RCC_MSIRANGE_5                  RCC_CR_MSIRANGE_5  /*!< MSI = 2 MHz    */
N#define LL_RCC_MSIRANGE_6                  RCC_CR_MSIRANGE_6  /*!< MSI = 4 MHz    */
N#define LL_RCC_MSIRANGE_7                  RCC_CR_MSIRANGE_7  /*!< MSI = 8 MHz    */
N#define LL_RCC_MSIRANGE_8                  RCC_CR_MSIRANGE_8  /*!< MSI = 16 MHz   */
N#define LL_RCC_MSIRANGE_9                  RCC_CR_MSIRANGE_9  /*!< MSI = 24 MHz   */
N#define LL_RCC_MSIRANGE_10                 RCC_CR_MSIRANGE_10 /*!< MSI = 32 MHz   */
N#define LL_RCC_MSIRANGE_11                 RCC_CR_MSIRANGE_11 /*!< MSI = 48 MHz   */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_MSISRANGE  MSI range after Standby mode
N  * @{
N  */
N#define LL_RCC_MSISRANGE_4                 RCC_CSR_MSISRANGE_1  /*!< MSI = 1 MHz    */
N#define LL_RCC_MSISRANGE_5                 RCC_CSR_MSISRANGE_2  /*!< MSI = 2 MHz    */
N#define LL_RCC_MSISRANGE_6                 RCC_CSR_MSISRANGE_4  /*!< MSI = 4 MHz    */
N#define LL_RCC_MSISRANGE_7                 RCC_CSR_MSISRANGE_8  /*!< MSI = 8 MHz    */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_LSCO_CLKSOURCE  LSCO Selection
N  * @{
N  */
N#define LL_RCC_LSCO_CLKSOURCE_LSI          0x00000000U                 /*!< LSI selection for low speed clock  */
N#define LL_RCC_LSCO_CLKSOURCE_LSE          RCC_BDCR_LSCOSEL      /*!< LSE selection for low speed clock  */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_SYS_CLKSOURCE  System clock switch
N  * @{
N  */
N#define LL_RCC_SYS_CLKSOURCE_MSI           RCC_CFGR_SW_MSI    /*!< MSI selection as system clock */
N#define LL_RCC_SYS_CLKSOURCE_HSI           RCC_CFGR_SW_HSI    /*!< HSI selection as system clock */
N#define LL_RCC_SYS_CLKSOURCE_HSE           RCC_CFGR_SW_HSE    /*!< HSE selection as system clock */
N#define LL_RCC_SYS_CLKSOURCE_PLL           RCC_CFGR_SW_PLL    /*!< PLL selection as system clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_SYS_CLKSOURCE_STATUS  System clock switch status
N  * @{
N  */
N#define LL_RCC_SYS_CLKSOURCE_STATUS_MSI    RCC_CFGR_SWS_MSI   /*!< MSI used as system clock */
N#define LL_RCC_SYS_CLKSOURCE_STATUS_HSI    RCC_CFGR_SWS_HSI   /*!< HSI used as system clock */
N#define LL_RCC_SYS_CLKSOURCE_STATUS_HSE    RCC_CFGR_SWS_HSE   /*!< HSE used as system clock */
N#define LL_RCC_SYS_CLKSOURCE_STATUS_PLL    RCC_CFGR_SWS_PLL   /*!< PLL used as system clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_SYSCLK_DIV  AHB prescaler
N  * @{
N  */
N#define LL_RCC_SYSCLK_DIV_1                RCC_CFGR_HPRE_DIV1   /*!< SYSCLK not divided */
N#define LL_RCC_SYSCLK_DIV_2                RCC_CFGR_HPRE_DIV2   /*!< SYSCLK divided by 2 */
N#define LL_RCC_SYSCLK_DIV_4                RCC_CFGR_HPRE_DIV4   /*!< SYSCLK divided by 4 */
N#define LL_RCC_SYSCLK_DIV_8                RCC_CFGR_HPRE_DIV8   /*!< SYSCLK divided by 8 */
N#define LL_RCC_SYSCLK_DIV_16               RCC_CFGR_HPRE_DIV16  /*!< SYSCLK divided by 16 */
N#define LL_RCC_SYSCLK_DIV_64               RCC_CFGR_HPRE_DIV64  /*!< SYSCLK divided by 64 */
N#define LL_RCC_SYSCLK_DIV_128              RCC_CFGR_HPRE_DIV128 /*!< SYSCLK divided by 128 */
N#define LL_RCC_SYSCLK_DIV_256              RCC_CFGR_HPRE_DIV256 /*!< SYSCLK divided by 256 */
N#define LL_RCC_SYSCLK_DIV_512              RCC_CFGR_HPRE_DIV512 /*!< SYSCLK divided by 512 */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_APB1_DIV  APB low-speed prescaler (APB1)
N  * @{
N  */
N#define LL_RCC_APB1_DIV_1                  RCC_CFGR_PPRE1_DIV1  /*!< HCLK not divided */
N#define LL_RCC_APB1_DIV_2                  RCC_CFGR_PPRE1_DIV2  /*!< HCLK divided by 2 */
N#define LL_RCC_APB1_DIV_4                  RCC_CFGR_PPRE1_DIV4  /*!< HCLK divided by 4 */
N#define LL_RCC_APB1_DIV_8                  RCC_CFGR_PPRE1_DIV8  /*!< HCLK divided by 8 */
N#define LL_RCC_APB1_DIV_16                 RCC_CFGR_PPRE1_DIV16 /*!< HCLK divided by 16 */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_APB2_DIV  APB high-speed prescaler (APB2)
N  * @{
N  */
N#define LL_RCC_APB2_DIV_1                  RCC_CFGR_PPRE2_DIV1  /*!< HCLK not divided */
N#define LL_RCC_APB2_DIV_2                  RCC_CFGR_PPRE2_DIV2  /*!< HCLK divided by 2 */
N#define LL_RCC_APB2_DIV_4                  RCC_CFGR_PPRE2_DIV4  /*!< HCLK divided by 4 */
N#define LL_RCC_APB2_DIV_8                  RCC_CFGR_PPRE2_DIV8  /*!< HCLK divided by 8 */
N#define LL_RCC_APB2_DIV_16                 RCC_CFGR_PPRE2_DIV16 /*!< HCLK divided by 16 */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_STOP_WAKEUPCLOCK  Wakeup from Stop and CSS backup clock selection
N  * @{
N  */
N#define LL_RCC_STOP_WAKEUPCLOCK_MSI        0x00000000U             /*!< MSI selection after wake-up from STOP */
N#define LL_RCC_STOP_WAKEUPCLOCK_HSI        RCC_CFGR_STOPWUCK       /*!< HSI selection after wake-up from STOP */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_MCO1SOURCE  MCO1 SOURCE selection
N  * @{
N  */
N#define LL_RCC_MCO1SOURCE_NOCLOCK          0x00000000U                            /*!< MCO output disabled, no clock on MCO */
N#define LL_RCC_MCO1SOURCE_SYSCLK           RCC_CFGR_MCOSEL_0                      /*!< SYSCLK selection as MCO1 source */
N#define LL_RCC_MCO1SOURCE_MSI              RCC_CFGR_MCOSEL_1                      /*!< MSI selection as MCO1 source */
N#define LL_RCC_MCO1SOURCE_HSI              (RCC_CFGR_MCOSEL_0| RCC_CFGR_MCOSEL_1) /*!< HSI16 selection as MCO1 source */
N#define LL_RCC_MCO1SOURCE_HSE              RCC_CFGR_MCOSEL_2                      /*!< HSE selection as MCO1 source */
N#define LL_RCC_MCO1SOURCE_PLLCLK           (RCC_CFGR_MCOSEL_0|RCC_CFGR_MCOSEL_2)  /*!< Main PLL selection as MCO1 source */
N#define LL_RCC_MCO1SOURCE_LSI              (RCC_CFGR_MCOSEL_1|RCC_CFGR_MCOSEL_2)  /*!< LSI selection as MCO1 source */
N#define LL_RCC_MCO1SOURCE_LSE              (RCC_CFGR_MCOSEL_0|RCC_CFGR_MCOSEL_1|RCC_CFGR_MCOSEL_2) /*!< LSE selection as MCO1 source */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define LL_RCC_MCO1SOURCE_HSI48            RCC_CFGR_MCOSEL_3                      /*!< HSI48 selection as MCO1 source */
N#endif /* RCC_HSI48_SUPPORT */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_MCO1_DIV  MCO1 prescaler
N  * @{
N  */
N#define LL_RCC_MCO1_DIV_1                  RCC_CFGR_MCOPRE_DIV1       /*!< MCO not divided */
N#define LL_RCC_MCO1_DIV_2                  RCC_CFGR_MCOPRE_DIV2       /*!< MCO divided by 2 */
N#define LL_RCC_MCO1_DIV_4                  RCC_CFGR_MCOPRE_DIV4       /*!< MCO divided by 4 */
N#define LL_RCC_MCO1_DIV_8                  RCC_CFGR_MCOPRE_DIV8       /*!< MCO divided by 8 */
N#define LL_RCC_MCO1_DIV_16                 RCC_CFGR_MCOPRE_DIV16      /*!< MCO divided by 16 */
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup RCC_LL_EC_PERIPH_FREQUENCY Peripheral clock frequency
N  * @{
N  */
N#define LL_RCC_PERIPH_FREQUENCY_NO         0x00000000U                 /*!< No clock enabled for the peripheral            */
N#define LL_RCC_PERIPH_FREQUENCY_NA         0xFFFFFFFFU                 /*!< Frequency cannot be provided as external clock */
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/** @defgroup RCC_LL_EC_USART1_CLKSOURCE  Peripheral USART clock source selection
N  * @{
N  */
N#define LL_RCC_USART1_CLKSOURCE_PCLK2      (RCC_CCIPR_USART1SEL << 16U)                           /*!< PCLK2 clock used as USART1 clock source */
N#define LL_RCC_USART1_CLKSOURCE_SYSCLK     ((RCC_CCIPR_USART1SEL << 16U) | RCC_CCIPR_USART1SEL_0) /*!< SYSCLK clock used as USART1 clock source */
N#define LL_RCC_USART1_CLKSOURCE_HSI        ((RCC_CCIPR_USART1SEL << 16U) | RCC_CCIPR_USART1SEL_1) /*!< HSI clock used as USART1 clock source */
N#define LL_RCC_USART1_CLKSOURCE_LSE        ((RCC_CCIPR_USART1SEL << 16U) | RCC_CCIPR_USART1SEL)   /*!< LSE clock used as USART1 clock source */
N#define LL_RCC_USART2_CLKSOURCE_PCLK1      (RCC_CCIPR_USART2SEL << 16U)                           /*!< PCLK1 clock used as USART2 clock source */
N#define LL_RCC_USART2_CLKSOURCE_SYSCLK     ((RCC_CCIPR_USART2SEL << 16U) | RCC_CCIPR_USART2SEL_0) /*!< SYSCLK clock used as USART2 clock source */
N#define LL_RCC_USART2_CLKSOURCE_HSI        ((RCC_CCIPR_USART2SEL << 16U) | RCC_CCIPR_USART2SEL_1) /*!< HSI clock used as USART2 clock source */
N#define LL_RCC_USART2_CLKSOURCE_LSE        ((RCC_CCIPR_USART2SEL << 16U) | RCC_CCIPR_USART2SEL)   /*!< LSE clock used as USART2 clock source */
N#if defined(RCC_CCIPR_USART3SEL)
X#if 1L
N#define LL_RCC_USART3_CLKSOURCE_PCLK1      (RCC_CCIPR_USART3SEL << 16U)                           /*!< PCLK1 clock used as USART3 clock source */
N#define LL_RCC_USART3_CLKSOURCE_SYSCLK     ((RCC_CCIPR_USART3SEL << 16U) | RCC_CCIPR_USART3SEL_0) /*!< SYSCLK clock used as USART3 clock source */
N#define LL_RCC_USART3_CLKSOURCE_HSI        ((RCC_CCIPR_USART3SEL << 16U) | RCC_CCIPR_USART3SEL_1) /*!< HSI clock used as USART3 clock source */
N#define LL_RCC_USART3_CLKSOURCE_LSE        ((RCC_CCIPR_USART3SEL << 16U) | RCC_CCIPR_USART3SEL)   /*!< LSE clock used as USART3 clock source */
N#endif /* RCC_CCIPR_USART3SEL */
N/**
N  * @}
N  */
N
N#if defined(RCC_CCIPR_UART4SEL) || defined(RCC_CCIPR_UART5SEL)
X#if 0L || 0L
S/** @defgroup RCC_LL_EC_UART4_CLKSOURCE  Peripheral UART clock source selection
S  * @{
S  */
S#if defined(RCC_CCIPR_UART4SEL)
S#define LL_RCC_UART4_CLKSOURCE_PCLK1       (RCC_CCIPR_UART4SEL << 16U)                           /*!< PCLK1 clock used as UART4 clock source */
S#define LL_RCC_UART4_CLKSOURCE_SYSCLK      ((RCC_CCIPR_UART4SEL << 16U) | RCC_CCIPR_UART4SEL_0)  /*!< SYSCLK clock used as UART4 clock source */
S#define LL_RCC_UART4_CLKSOURCE_HSI         ((RCC_CCIPR_UART4SEL << 16U) | RCC_CCIPR_UART4SEL_1)  /*!< HSI clock used as UART4 clock source */
S#define LL_RCC_UART4_CLKSOURCE_LSE         ((RCC_CCIPR_UART4SEL << 16U) | RCC_CCIPR_UART4SEL)    /*!< LSE clock used as UART4 clock source */
S#endif /* RCC_CCIPR_UART4SEL */
S#if defined(RCC_CCIPR_UART5SEL)
S#define LL_RCC_UART5_CLKSOURCE_PCLK1       (RCC_CCIPR_UART5SEL << 16U)                           /*!< PCLK1 clock used as UART5 clock source */
S#define LL_RCC_UART5_CLKSOURCE_SYSCLK      ((RCC_CCIPR_UART5SEL << 16U) | RCC_CCIPR_UART5SEL_0)  /*!< SYSCLK clock used as UART5 clock source */
S#define LL_RCC_UART5_CLKSOURCE_HSI         ((RCC_CCIPR_UART5SEL << 16U) | RCC_CCIPR_UART5SEL_1)  /*!< HSI clock used as UART5 clock source */
S#define LL_RCC_UART5_CLKSOURCE_LSE         ((RCC_CCIPR_UART5SEL << 16U) | RCC_CCIPR_UART5SEL)    /*!< LSE clock used as UART5 clock source */
S#endif /* RCC_CCIPR_UART5SEL */
S/**
S  * @}
S  */
N#endif /* RCC_CCIPR_UART4SEL || RCC_CCIPR_UART5SEL */
N
N/** @defgroup RCC_LL_EC_LPUART1_CLKSOURCE  Peripheral LPUART clock source selection
N  * @{
N  */
N#define LL_RCC_LPUART1_CLKSOURCE_PCLK1     0x00000000U                     /*!< PCLK1 clock used as LPUART1 clock source */
N#define LL_RCC_LPUART1_CLKSOURCE_SYSCLK    RCC_CCIPR_LPUART1SEL_0          /*!< SYSCLK clock used as LPUART1 clock source */
N#define LL_RCC_LPUART1_CLKSOURCE_HSI       RCC_CCIPR_LPUART1SEL_1          /*!< HSI clock used as LPUART1 clock source */
N#define LL_RCC_LPUART1_CLKSOURCE_LSE       RCC_CCIPR_LPUART1SEL            /*!< LSE clock used as LPUART1 clock source */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_I2C1_CLKSOURCE  Peripheral I2C clock source selection
N  * @{
N  */
N#define LL_RCC_I2C1_CLKSOURCE_PCLK1        ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C1SEL_Pos << 16U))                                                  /*!< PCLK1 clock used as I2C1 clock source */
N#define LL_RCC_I2C1_CLKSOURCE_SYSCLK       ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C1SEL_Pos << 16U) | (RCC_CCIPR_I2C1SEL_0 >> RCC_CCIPR_I2C1SEL_Pos)) /*!< SYSCLK clock used as I2C1 clock source */
N#define LL_RCC_I2C1_CLKSOURCE_HSI          ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C1SEL_Pos << 16U) | (RCC_CCIPR_I2C1SEL_1 >> RCC_CCIPR_I2C1SEL_Pos)) /*!< HSI clock used as I2C1 clock source */
N#if defined(RCC_CCIPR_I2C2SEL)
X#if 1L
N#define LL_RCC_I2C2_CLKSOURCE_PCLK1        ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C2SEL_Pos << 16U))                                                  /*!< PCLK1 clock used as I2C2 clock source */
N#define LL_RCC_I2C2_CLKSOURCE_SYSCLK       ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C2SEL_Pos << 16U) | (RCC_CCIPR_I2C2SEL_0 >> RCC_CCIPR_I2C2SEL_Pos)) /*!< SYSCLK clock used as I2C2 clock source */
N#define LL_RCC_I2C2_CLKSOURCE_HSI          ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C2SEL_Pos << 16U) | (RCC_CCIPR_I2C2SEL_1 >> RCC_CCIPR_I2C2SEL_Pos)) /*!< HSI clock used as I2C2 clock source */
N#endif /* RCC_CCIPR_I2C2SEL */
N#define LL_RCC_I2C3_CLKSOURCE_PCLK1        ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C3SEL_Pos << 16U))                                                  /*!< PCLK1 clock used as I2C3 clock source */
N#define LL_RCC_I2C3_CLKSOURCE_SYSCLK       ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C3SEL_Pos << 16U) | (RCC_CCIPR_I2C3SEL_0 >> RCC_CCIPR_I2C3SEL_Pos)) /*!< SYSCLK clock used as I2C3 clock source */
N#define LL_RCC_I2C3_CLKSOURCE_HSI          ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C3SEL_Pos << 16U) | (RCC_CCIPR_I2C3SEL_1 >> RCC_CCIPR_I2C3SEL_Pos)) /*!< HSI clock used as I2C3 clock source */
N#if defined(RCC_CCIPR2_I2C4SEL)
X#if 0L
S#define LL_RCC_I2C4_CLKSOURCE_PCLK1        ((RCC_OFFSET_CCIPR2 << 24U) | (RCC_CCIPR2_I2C4SEL_Pos << 16U))                                                    /*!< PCLK1 clock used as I2C4 clock source */
S#define LL_RCC_I2C4_CLKSOURCE_SYSCLK       ((RCC_OFFSET_CCIPR2 << 24U) | (RCC_CCIPR2_I2C4SEL_Pos << 16U) | (RCC_CCIPR2_I2C4SEL_0 >> RCC_CCIPR2_I2C4SEL_Pos)) /*!< SYSCLK clock used as I2C4 clock source */
S#define LL_RCC_I2C4_CLKSOURCE_HSI          ((RCC_OFFSET_CCIPR2 << 24U) | (RCC_CCIPR2_I2C4SEL_Pos << 16U) | (RCC_CCIPR2_I2C4SEL_1 >> RCC_CCIPR2_I2C4SEL_Pos)) /*!< HSI clock used as I2C4 clock source */
N#endif /* RCC_CCIPR2_I2C4SEL */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_LPTIM1_CLKSOURCE  Peripheral LPTIM clock source selection
N  * @{
N  */
N#define LL_RCC_LPTIM1_CLKSOURCE_PCLK1      RCC_CCIPR_LPTIM1SEL                                    /*!< PCLK1 clock used as LPTIM1 clock source */
N#define LL_RCC_LPTIM1_CLKSOURCE_LSI        (RCC_CCIPR_LPTIM1SEL | (RCC_CCIPR_LPTIM1SEL_0 >> 16U)) /*!< LSI clock used as LPTIM1 clock source */
N#define LL_RCC_LPTIM1_CLKSOURCE_HSI        (RCC_CCIPR_LPTIM1SEL | (RCC_CCIPR_LPTIM1SEL_1 >> 16U)) /*!< HSI clock used as LPTIM1 clock source */
N#define LL_RCC_LPTIM1_CLKSOURCE_LSE        (RCC_CCIPR_LPTIM1SEL | (RCC_CCIPR_LPTIM1SEL >> 16U))   /*!< LSE clock used as LPTIM1 clock source */
N#define LL_RCC_LPTIM2_CLKSOURCE_PCLK1      RCC_CCIPR_LPTIM2SEL                                    /*!< PCLK1 clock used as LPTIM2 clock source */
N#define LL_RCC_LPTIM2_CLKSOURCE_LSI        (RCC_CCIPR_LPTIM2SEL | (RCC_CCIPR_LPTIM2SEL_0 >> 16U)) /*!< LSI clock used as LPTIM2 clock source */
N#define LL_RCC_LPTIM2_CLKSOURCE_HSI        (RCC_CCIPR_LPTIM2SEL | (RCC_CCIPR_LPTIM2SEL_1 >> 16U)) /*!< HSI clock used as LPTIM2 clock source */
N#define LL_RCC_LPTIM2_CLKSOURCE_LSE        (RCC_CCIPR_LPTIM2SEL | (RCC_CCIPR_LPTIM2SEL >> 16U))   /*!< LSE clock used as LPTIM2 clock source */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_SAI1_CLKSOURCE  Peripheral SAI clock source selection
N  * @{
N  */
N#if defined(RCC_CCIPR2_SAI1SEL)
X#if 0L
S#define LL_RCC_SAI1_CLKSOURCE_PLL          (RCC_CCIPR2_SAI1SEL << 16U)                          /*!< PLL clock used as SAI1 clock source */
S#define LL_RCC_SAI1_CLKSOURCE_PLLSAI1      ((RCC_CCIPR2_SAI1SEL << 16U) | RCC_CCIPR2_SAI1SEL_0) /*!< PLLSAI1 clock used as SAI1 clock source */
S#define LL_RCC_SAI1_CLKSOURCE_PLLSAI2      ((RCC_CCIPR2_SAI1SEL << 16U) | RCC_CCIPR2_SAI1SEL_1) /*!< PLLSAI2 clock used as SAI1 clock source */
S#define LL_RCC_SAI1_CLKSOURCE_HSI          ((RCC_CCIPR2_SAI1SEL << 16U) | RCC_CCIPR2_SAI1SEL_2) /*!< HSI clock used as SAI1 clock source */
S#define LL_RCC_SAI1_CLKSOURCE_PIN          ((RCC_CCIPR2_SAI1SEL << 16U) | (RCC_CCIPR2_SAI1SEL_1 | RCC_CCIPR2_SAI1SEL_0))  /*!< External input clock used as SAI1 clock source */
N#else
N#define LL_RCC_SAI1_CLKSOURCE_PLLSAI1      RCC_CCIPR_SAI1SEL                                    /*!< PLLSAI1 clock used as SAI1 clock source */
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S#define LL_RCC_SAI1_CLKSOURCE_PLLSAI2      (RCC_CCIPR_SAI1SEL | (RCC_CCIPR_SAI1SEL_0 >> 16U))   /*!< PLLSAI2 clock used as SAI1 clock source */
N#endif /* RCC_PLLSAI2_SUPPORT */
N#define LL_RCC_SAI1_CLKSOURCE_PLL          (RCC_CCIPR_SAI1SEL | (RCC_CCIPR_SAI1SEL_1 >> 16U))   /*!< PLL clock used as SAI1 clock source */
N#define LL_RCC_SAI1_CLKSOURCE_PIN          (RCC_CCIPR_SAI1SEL | (RCC_CCIPR_SAI1SEL >> 16U))     /*!< External input clock used as SAI1 clock source */
N#endif /* RCC_CCIPR2_SAI1SEL */
N
N#if defined(RCC_CCIPR2_SAI2SEL)
X#if 0L
S#define LL_RCC_SAI2_CLKSOURCE_PLL          (RCC_CCIPR2_SAI2SEL << 16U)                          /*!< PLL clock used as SAI2 clock source */
S#define LL_RCC_SAI2_CLKSOURCE_PLLSAI1      ((RCC_CCIPR2_SAI2SEL << 16U) | RCC_CCIPR2_SAI2SEL_0) /*!< PLLSAI1 clock used as SAI2 clock source */
S#define LL_RCC_SAI2_CLKSOURCE_PLLSAI2      ((RCC_CCIPR2_SAI2SEL << 16U) | RCC_CCIPR2_SAI2SEL_1) /*!< PLLSAI2 clock used as SAI2 clock source */
S#define LL_RCC_SAI2_CLKSOURCE_HSI          ((RCC_CCIPR2_SAI2SEL << 16U) | RCC_CCIPR2_SAI2SEL_2) /*!< HSI clock used as SAI2 clock source */
S#define LL_RCC_SAI2_CLKSOURCE_PIN          ((RCC_CCIPR2_SAI2SEL << 16U) | (RCC_CCIPR2_SAI2SEL_1 | RCC_CCIPR2_SAI2SEL_0))  /*!< External input clock used as SAI2 clock source */
S#elif defined(RCC_CCIPR_SAI2SEL)
X#elif 0L
S#define LL_RCC_SAI2_CLKSOURCE_PLLSAI1      RCC_CCIPR_SAI2SEL                                    /*!< PLLSAI1 clock used as SAI2 clock source */
S#if defined(RCC_PLLSAI2_SUPPORT)
S#define LL_RCC_SAI2_CLKSOURCE_PLLSAI2      (RCC_CCIPR_SAI2SEL | (RCC_CCIPR_SAI2SEL_0 >> 16U))   /*!< PLLSAI2 clock used as SAI2 clock source */
S#endif /* RCC_PLLSAI2_SUPPORT */
S#define LL_RCC_SAI2_CLKSOURCE_PLL          (RCC_CCIPR_SAI2SEL | (RCC_CCIPR_SAI2SEL_1 >> 16U))   /*!< PLL clock used as SAI2 clock source */
S#define LL_RCC_SAI2_CLKSOURCE_PIN          (RCC_CCIPR_SAI2SEL | (RCC_CCIPR_SAI2SEL >> 16U))     /*!< External input clock used as SAI2 clock source */
N#endif /* RCC_CCIPR2_SAI2SEL */
N/**
N  * @}
N  */
N
N#if defined(RCC_CCIPR2_SDMMCSEL)
X#if 0L
S/** @defgroup RCC_LL_EC_SDMMC1_KERNELCLKSOURCE  Peripheral SDMMC kernel clock source selection
S  * @{
S  */
S#define LL_RCC_SDMMC1_KERNELCLKSOURCE_48CLK  0x00000000U          /*!< 48MHz clock from internal multiplexor used as SDMMC1 clock source */
S#define LL_RCC_SDMMC1_KERNELCLKSOURCE_PLLP   RCC_CCIPR2_SDMMCSEL  /*!< PLLSAI3CLK clock used as SDMMC1 clock source */
S/**
S  * @}
S  */
N#endif /* RCC_CCIPR2_SDMMCSEL */
N
N/** @defgroup RCC_LL_EC_SDMMC1_CLKSOURCE  Peripheral SDMMC clock source selection
N  * @{
N  */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define LL_RCC_SDMMC1_CLKSOURCE_HSI48      0x00000000U          /*!< HSI48 clock used as SDMMC1 clock source */
N#else
S#define LL_RCC_SDMMC1_CLKSOURCE_NONE       0x00000000U          /*!< No clock used as SDMMC1 clock source */
N#endif
N#define LL_RCC_SDMMC1_CLKSOURCE_PLLSAI1    RCC_CCIPR_CLK48SEL_0 /*!< PLLSAI1 clock used as SDMMC1 clock source */
N#define LL_RCC_SDMMC1_CLKSOURCE_PLL        RCC_CCIPR_CLK48SEL_1 /*!< PLL clock used as SDMMC1 clock source */
N#define LL_RCC_SDMMC1_CLKSOURCE_MSI        RCC_CCIPR_CLK48SEL   /*!< MSI clock used as SDMMC1 clock source */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_RNG_CLKSOURCE  Peripheral RNG clock source selection
N  * @{
N  */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define LL_RCC_RNG_CLKSOURCE_HSI48         0x00000000U          /*!< HSI48 clock used as RNG clock source */
N#else
S#define LL_RCC_RNG_CLKSOURCE_NONE          0x00000000U          /*!< No clock used as RNG clock source */
N#endif
N#define LL_RCC_RNG_CLKSOURCE_PLLSAI1       RCC_CCIPR_CLK48SEL_0 /*!< PLLSAI1 clock used as RNG clock source */
N#define LL_RCC_RNG_CLKSOURCE_PLL           RCC_CCIPR_CLK48SEL_1 /*!< PLL clock used as RNG clock source */
N#define LL_RCC_RNG_CLKSOURCE_MSI           RCC_CCIPR_CLK48SEL   /*!< MSI clock used as RNG clock source */
N/**
N  * @}
N  */
N
N#if defined(USB_OTG_FS) || defined(USB)
X#if 0L || 0L
S/** @defgroup RCC_LL_EC_USB_CLKSOURCE  Peripheral USB clock source selection
S  * @{
S  */
S#if defined(RCC_HSI48_SUPPORT)
S#define LL_RCC_USB_CLKSOURCE_HSI48         0x00000000U          /*!< HSI48 clock used as USB clock source */
S#else
S#define LL_RCC_USB_CLKSOURCE_NONE          0x00000000U          /*!< No clock used as USB clock source */
S#endif
S#define LL_RCC_USB_CLKSOURCE_PLLSAI1       RCC_CCIPR_CLK48SEL_0 /*!< PLLSAI1 clock used as USB clock source */
S#define LL_RCC_USB_CLKSOURCE_PLL           RCC_CCIPR_CLK48SEL_1 /*!< PLL clock used as USB clock source */
S#define LL_RCC_USB_CLKSOURCE_MSI           RCC_CCIPR_CLK48SEL   /*!< MSI clock used as USB clock source */
S/**
S  * @}
S  */
S
N#endif /* USB_OTG_FS || USB */
N
N/** @defgroup RCC_LL_EC_ADC_CLKSOURCE  Peripheral ADC clock source selection
N  * @{
N  */
N#define LL_RCC_ADC_CLKSOURCE_NONE          0x00000000U          /*!< No clock used as ADC clock source */
N#define LL_RCC_ADC_CLKSOURCE_PLLSAI1       RCC_CCIPR_ADCSEL_0   /*!< PLLSAI1 clock used as ADC clock source */
N#if defined(RCC_PLLSAI2_SUPPORT) && !defined(LTDC)
X#if 0L && !0L
S#define LL_RCC_ADC_CLKSOURCE_PLLSAI2       RCC_CCIPR_ADCSEL_1   /*!< PLLSAI2 clock used as ADC clock source */
N#endif /* RCC_PLLSAI2_SUPPORT */
N#define LL_RCC_ADC_CLKSOURCE_SYSCLK        RCC_CCIPR_ADCSEL     /*!< SYSCLK clock used as ADC clock source */
N/**
N  * @}
N  */
N
N#if defined(SWPMI1)
X#if 1L
N/** @defgroup RCC_LL_EC_SWPMI1_CLKSOURCE  Peripheral SWPMI1 clock source selection
N  * @{
N  */
N#define LL_RCC_SWPMI1_CLKSOURCE_PCLK1      0x00000000U          /*!< PCLK1 used as SWPMI1 clock source */
N#define LL_RCC_SWPMI1_CLKSOURCE_HSI        RCC_CCIPR_SWPMI1SEL  /*!< HSI used as SWPMI1 clock source */
N/**
N  * @}
N  */
N#endif /* SWPMI1 */
N
N#if defined(DFSDM1_Channel0)
X#if 0L
S#if defined(RCC_CCIPR2_ADFSDM1SEL)
S/** @defgroup RCC_LL_EC_DFSDM1_AUDIO_CLKSOURCE  Peripheral DFSDM1 Audio clock source selection
S  * @{
S  */
S#define LL_RCC_DFSDM1_AUDIO_CLKSOURCE_SAI1 0x00000000U             /*!< SAI1 clock used as DFSDM1 Audio clock */
S#define LL_RCC_DFSDM1_AUDIO_CLKSOURCE_HSI  RCC_CCIPR2_ADFSDM1SEL_0 /*!< HSI clock used as DFSDM1 Audio clock */
S#define LL_RCC_DFSDM1_AUDIO_CLKSOURCE_MSI  RCC_CCIPR2_ADFSDM1SEL_1 /*!< MSI clock used as DFSDM1 Audio clock */
S/**
S  * @}
S  */
S#endif /* RCC_CCIPR2_ADFSDM1SEL */
S
S/** @defgroup RCC_LL_EC_DFSDM1_CLKSOURCE  Peripheral DFSDM1 clock source selection
S  * @{
S  */
S#if defined(RCC_CCIPR2_DFSDM1SEL)
S#define LL_RCC_DFSDM1_CLKSOURCE_PCLK2      0x00000000U          /*!< PCLK2 used as DFSDM1 clock source */
S#define LL_RCC_DFSDM1_CLKSOURCE_SYSCLK     RCC_CCIPR2_DFSDM1SEL /*!< SYSCLK used as DFSDM1 clock source */
S#else
S#define LL_RCC_DFSDM1_CLKSOURCE_PCLK2      0x00000000U          /*!< PCLK2 used as DFSDM1 clock source */
S#define LL_RCC_DFSDM1_CLKSOURCE_SYSCLK     RCC_CCIPR_DFSDM1SEL  /*!< SYSCLK used as DFSDM1 clock source */
S#endif /* RCC_CCIPR2_DFSDM1SEL */
S/**
S  * @}
S  */
N#endif /* DFSDM1_Channel0 */
N
N#if defined(DSI)
X#if 0L
S/** @defgroup RCC_LL_EC_DSI_CLKSOURCE  Peripheral DSI clock source selection
S  * @{
S  */
S#define LL_RCC_DSI_CLKSOURCE_PHY          0x00000000U           /*!< DSI-PHY clock used as DSI byte lane clock source */
S#define LL_RCC_DSI_CLKSOURCE_PLL          RCC_CCIPR2_DSISEL     /*!< PLL clock used as DSI byte lane clock source */
S/**
S  * @}
S  */
N#endif /* DSI */
N
N#if defined(LTDC)
X#if 0L
S/** @defgroup RCC_LL_EC_LTDC_CLKSOURCE  Peripheral LTDC clock source selection
S  * @{
S  */
S#define LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV2  0x00000000U              /*!< PLLSAI2DIVR divided by 2 used as LTDC clock source */
S#define LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV4  RCC_CCIPR2_PLLSAI2DIVR_0 /*!< PLLSAI2DIVR divided by 4 used as LTDC clock source */
S#define LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV8  RCC_CCIPR2_PLLSAI2DIVR_1 /*!< PLLSAI2DIVR divided by 8 used as LTDC clock source */
S#define LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV16 RCC_CCIPR2_PLLSAI2DIVR   /*!< PLLSAI2DIVR divided by 16 used as LTDC clock source */
S/**
S  * @}
S  */
N#endif /* LTDC */
N
N#if defined(OCTOSPI1)
X#if 0L
S/** @defgroup RCC_LL_EC_OCTOSPI  Peripheral OCTOSPI get clock source
S  * @{
S  */
S#define LL_RCC_OCTOSPI_CLKSOURCE_SYSCLK    0x00000000U           /*!< SYSCLK used as OctoSPI clock source */
S#define LL_RCC_OCTOSPI_CLKSOURCE_MSI       RCC_CCIPR2_OSPISEL_0  /*!< MSI used as OctoSPI clock source */
S#define LL_RCC_OCTOSPI_CLKSOURCE_PLL       RCC_CCIPR2_OSPISEL_1  /*!< PLL used as OctoSPI clock source */
S/**
S  * @}
S  */
N#endif /* OCTOSPI1 */
N
N/** @defgroup RCC_LL_EC_USART1 Peripheral USART get clock source
N  * @{
N  */
N#define LL_RCC_USART1_CLKSOURCE            RCC_CCIPR_USART1SEL /*!< USART1 Clock source selection */
N#define LL_RCC_USART2_CLKSOURCE            RCC_CCIPR_USART2SEL /*!< USART2 Clock source selection */
N#if defined(RCC_CCIPR_USART3SEL)
X#if 1L
N#define LL_RCC_USART3_CLKSOURCE            RCC_CCIPR_USART3SEL /*!< USART3 Clock source selection */
N#endif /* RCC_CCIPR_USART3SEL */
N/**
N  * @}
N  */
N
N#if defined(RCC_CCIPR_UART4SEL) || defined(RCC_CCIPR_UART5SEL)
X#if 0L || 0L
S/** @defgroup RCC_LL_EC_UART4 Peripheral UART get clock source
S  * @{
S  */
S#if defined(RCC_CCIPR_UART4SEL)
S#define LL_RCC_UART4_CLKSOURCE             RCC_CCIPR_UART4SEL /*!< UART4 Clock source selection */
S#endif /* RCC_CCIPR_UART4SEL */
S#if defined(RCC_CCIPR_UART5SEL)
S#define LL_RCC_UART5_CLKSOURCE             RCC_CCIPR_UART5SEL /*!< UART5 Clock source selection */
S#endif /* RCC_CCIPR_UART5SEL */
S/**
S  * @}
S  */
N#endif /* RCC_CCIPR_UART4SEL || RCC_CCIPR_UART5SEL */
N
N/** @defgroup RCC_LL_EC_LPUART1 Peripheral LPUART get clock source
N  * @{
N  */
N#define LL_RCC_LPUART1_CLKSOURCE           RCC_CCIPR_LPUART1SEL /*!< LPUART1 Clock source selection */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_I2C1 Peripheral I2C get clock source
N  * @{
N  */
N#define LL_RCC_I2C1_CLKSOURCE              ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C1SEL_Pos << 16U) | (RCC_CCIPR_I2C1SEL >> RCC_CCIPR_I2C1SEL_Pos)) /*!< I2C1 Clock source selection */
N#if defined(RCC_CCIPR_I2C2SEL)
X#if 1L
N#define LL_RCC_I2C2_CLKSOURCE              ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C2SEL_Pos << 16U) | (RCC_CCIPR_I2C2SEL >> RCC_CCIPR_I2C2SEL_Pos)) /*!< I2C2 Clock source selection */
N#endif /* RCC_CCIPR_I2C2SEL */
N#define LL_RCC_I2C3_CLKSOURCE              ((RCC_OFFSET_CCIPR << 24U) | (RCC_CCIPR_I2C3SEL_Pos << 16U) | (RCC_CCIPR_I2C3SEL >> RCC_CCIPR_I2C3SEL_Pos)) /*!< I2C3 Clock source selection */
N#if defined(RCC_CCIPR2_I2C4SEL)
X#if 0L
S#define LL_RCC_I2C4_CLKSOURCE              ((RCC_OFFSET_CCIPR2 << 24U) | (RCC_CCIPR2_I2C4SEL_Pos << 16U) | (RCC_CCIPR2_I2C4SEL >> RCC_CCIPR2_I2C4SEL_Pos)) /*!< I2C4 Clock source selection */
N#endif /* RCC_CCIPR2_I2C4SEL */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_LPTIM1 Peripheral LPTIM get clock source
N  * @{
N  */
N#define LL_RCC_LPTIM1_CLKSOURCE            RCC_CCIPR_LPTIM1SEL /*!< LPTIM1 Clock source selection */
N#define LL_RCC_LPTIM2_CLKSOURCE            RCC_CCIPR_LPTIM2SEL /*!< LPTIM2 Clock source selection */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_SAI1  Peripheral SAI get clock source
N  * @{
N  */
N#if defined(RCC_CCIPR2_SAI1SEL)
X#if 0L
S#define LL_RCC_SAI1_CLKSOURCE              RCC_CCIPR2_SAI1SEL /*!< SAI1 Clock source selection */
N#else
N#define LL_RCC_SAI1_CLKSOURCE              RCC_CCIPR_SAI1SEL /*!< SAI1 Clock source selection */
N#endif /* RCC_CCIPR2_SAI1SEL */
N#if defined(RCC_CCIPR2_SAI2SEL)
X#if 0L
S#define LL_RCC_SAI2_CLKSOURCE              RCC_CCIPR2_SAI2SEL /*!< SAI2 Clock source selection */
S#elif defined(RCC_CCIPR_SAI2SEL)
X#elif 0L
S#define LL_RCC_SAI2_CLKSOURCE              RCC_CCIPR_SAI2SEL /*!< SAI2 Clock source selection */
N#endif /* RCC_CCIPR2_SAI2SEL */
N/**
N  * @}
N  */
N
N#if defined(RCC_CCIPR2_SDMMCSEL)
X#if 0L
S/** @defgroup RCC_LL_EC_SDMMC1_KERNEL  Peripheral SDMMC get kernel clock source
S  * @{
S  */
S#define LL_RCC_SDMMC1_KERNELCLKSOURCE      RCC_CCIPR2_SDMMCSEL /*!< SDMMC1 Kernel Clock source selection */
S/**
S  * @}
S  */
N#endif /* RCC_CCIPR2_SDMMCSEL */
N
N/** @defgroup RCC_LL_EC_SDMMC1  Peripheral SDMMC get clock source
N  * @{
N  */
N#define LL_RCC_SDMMC1_CLKSOURCE            RCC_CCIPR_CLK48SEL /*!< SDMMC1 Clock source selection */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_RNG  Peripheral RNG get clock source
N  * @{
N  */
N#define LL_RCC_RNG_CLKSOURCE               RCC_CCIPR_CLK48SEL /*!< RNG Clock source selection */
N/**
N  * @}
N  */
N
N#if defined(USB_OTG_FS) || defined(USB)
X#if 0L || 0L
S/** @defgroup RCC_LL_EC_USB  Peripheral USB get clock source
S  * @{
S  */
S#define LL_RCC_USB_CLKSOURCE               RCC_CCIPR_CLK48SEL /*!< USB Clock source selection */
S/**
S  * @}
S  */
N#endif /* USB_OTG_FS || USB */
N
N/** @defgroup RCC_LL_EC_ADC  Peripheral ADC get clock source
N  * @{
N  */
N#define LL_RCC_ADC_CLKSOURCE               RCC_CCIPR_ADCSEL /*!< ADC Clock source selection */
N/**
N  * @}
N  */
N
N#if defined(SWPMI1)
X#if 1L
N/** @defgroup RCC_LL_EC_SWPMI1  Peripheral SWPMI1 get clock source
N  * @{
N  */
N#define LL_RCC_SWPMI1_CLKSOURCE            RCC_CCIPR_SWPMI1SEL /*!< SWPMI1 Clock source selection */
N/**
N  * @}
N  */
N#endif /* SWPMI1 */
N
N#if defined(DFSDM1_Channel0)
X#if 0L
S#if defined(RCC_CCIPR2_ADFSDM1SEL)
S/** @defgroup RCC_LL_EC_DFSDM1_AUDIO  Peripheral DFSDM1 Audio get clock source
S  * @{
S  */
S#define LL_RCC_DFSDM1_AUDIO_CLKSOURCE      RCC_CCIPR2_ADFSDM1SEL /* DFSDM1 Audio Clock source selection */
S/**
S  * @}
S  */
S
S#endif /* RCC_CCIPR2_ADFSDM1SEL */
S/** @defgroup RCC_LL_EC_DFSDM1  Peripheral DFSDM1 get clock source
S  * @{
S  */
S#if defined(RCC_CCIPR2_DFSDM1SEL)
S#define LL_RCC_DFSDM1_CLKSOURCE            RCC_CCIPR2_DFSDM1SEL /*!< DFSDM1 Clock source selection */
S#else
S#define LL_RCC_DFSDM1_CLKSOURCE            RCC_CCIPR_DFSDM1SEL /*!< DFSDM1 Clock source selection */
S#endif /* RCC_CCIPR2_DFSDM1SEL */
S/**
S  * @}
S  */
N#endif /* DFSDM1_Channel0 */
N
N#if defined(DSI)
X#if 0L
S/** @defgroup RCC_LL_EC_DSI  Peripheral DSI get clock source
S  * @{
S  */
S#define LL_RCC_DSI_CLKSOURCE               RCC_CCIPR2_DSISEL      /*!< DSI Clock source selection */
S/**
S  * @}
S  */
N#endif /* DSI */
N
N#if defined(LTDC)
X#if 0L
S/** @defgroup RCC_LL_EC_LTDC  Peripheral LTDC get clock source
S  * @{
S  */
S#define LL_RCC_LTDC_CLKSOURCE              RCC_CCIPR2_PLLSAI2DIVR /*!< LTDC Clock source selection */
S/**
S  * @}
S  */
N#endif /* LTDC */
N
N#if defined(OCTOSPI1)
X#if 0L
S/** @defgroup RCC_LL_EC_OCTOSPI  Peripheral OCTOSPI get clock source
S  * @{
S  */
S#define LL_RCC_OCTOSPI_CLKSOURCE           RCC_CCIPR2_OSPISEL    /*!< OctoSPI Clock source selection */
S/**
S  * @}
S  */
N#endif /* OCTOSPI1 */
N
N
N/** @defgroup RCC_LL_EC_RTC_CLKSOURCE  RTC clock source selection
N  * @{
N  */
N#define LL_RCC_RTC_CLKSOURCE_NONE          0x00000000U                   /*!< No clock used as RTC clock */
N#define LL_RCC_RTC_CLKSOURCE_LSE           RCC_BDCR_RTCSEL_0       /*!< LSE oscillator clock used as RTC clock */
N#define LL_RCC_RTC_CLKSOURCE_LSI           RCC_BDCR_RTCSEL_1       /*!< LSI oscillator clock used as RTC clock */
N#define LL_RCC_RTC_CLKSOURCE_HSE_DIV32     RCC_BDCR_RTCSEL         /*!< HSE oscillator clock divided by 32 used as RTC clock */
N/**
N  * @}
N  */
N
N
N/** @defgroup RCC_LL_EC_PLLSOURCE  PLL, PLLSAI1 and PLLSAI2 entry clock source
N  * @{
N  */
N#define LL_RCC_PLLSOURCE_NONE              0x00000000U             /*!< No clock */
N#define LL_RCC_PLLSOURCE_MSI               RCC_PLLCFGR_PLLSRC_MSI  /*!< MSI clock selected as PLL entry clock source */
N#define LL_RCC_PLLSOURCE_HSI               RCC_PLLCFGR_PLLSRC_HSI  /*!< HSI16 clock selected as PLL entry clock source */
N#define LL_RCC_PLLSOURCE_HSE               RCC_PLLCFGR_PLLSRC_HSE  /*!< HSE clock selected as PLL entry clock source */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_PLLM_DIV  PLL division factor
N  * @{
N  */
N#define LL_RCC_PLLM_DIV_1                  0x00000000U                                                    /*!< Main PLL division factor for PLLM input by 1 */
N#define LL_RCC_PLLM_DIV_2                  (RCC_PLLCFGR_PLLM_0)                                           /*!< Main PLL division factor for PLLM input by 2 */
N#define LL_RCC_PLLM_DIV_3                  (RCC_PLLCFGR_PLLM_1)                                           /*!< Main PLL division factor for PLLM input by 3 */
N#define LL_RCC_PLLM_DIV_4                  (RCC_PLLCFGR_PLLM_1 | RCC_PLLCFGR_PLLM_0)                      /*!< Main PLL division factor for PLLM input by 4 */
N#define LL_RCC_PLLM_DIV_5                  (RCC_PLLCFGR_PLLM_2)                                           /*!< Main PLL division factor for PLLM input by 5 */
N#define LL_RCC_PLLM_DIV_6                  (RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_0)                      /*!< Main PLL division factor for PLLM input by 6 */
N#define LL_RCC_PLLM_DIV_7                  (RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_1)                      /*!< Main PLL division factor for PLLM input by 7 */
N#define LL_RCC_PLLM_DIV_8                  (RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_1 | RCC_PLLCFGR_PLLM_0) /*!< Main PLL division factor for PLLM input by 8 */
N#if defined(RCC_PLLM_DIV_1_16_SUPPORT)
X#if 0L
S#define LL_RCC_PLLM_DIV_9                  (RCC_PLLCFGR_PLLM_3)                                           /*!< Main PLL division factor for PLLM input by 9 */
S#define LL_RCC_PLLM_DIV_10                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_0)                      /*!< Main PLL division factor for PLLM input by 10 */
S#define LL_RCC_PLLM_DIV_11                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_1)                      /*!< Main PLL division factor for PLLM input by 11 */
S#define LL_RCC_PLLM_DIV_12                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_1 | RCC_PLLCFGR_PLLM_0) /*!< Main PLL division factor for PLLM input by 12 */
S#define LL_RCC_PLLM_DIV_13                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_2)                      /*!< Main PLL division factor for PLLM input by 13 */
S#define LL_RCC_PLLM_DIV_14                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_0) /*!< Main PLL division factor for PLLM input by 14 */
S#define LL_RCC_PLLM_DIV_15                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_1) /*!< Main PLL division factor for PLLM input by 15 */
S#define LL_RCC_PLLM_DIV_16                 (RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_1 | RCC_PLLCFGR_PLLM_0) /*!< Main PLL division factor for PLLM input by 16 */
N#endif /* RCC_PLLM_DIV_1_16_SUPPORT */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_PLLR_DIV  PLL division factor (PLLR)
N  * @{
N  */
N#define LL_RCC_PLLR_DIV_2                  0x00000000U            /*!< Main PLL division factor for PLLCLK (system clock) by 2 */
N#define LL_RCC_PLLR_DIV_4                  (RCC_PLLCFGR_PLLR_0)   /*!< Main PLL division factor for PLLCLK (system clock) by 4 */
N#define LL_RCC_PLLR_DIV_6                  (RCC_PLLCFGR_PLLR_1)   /*!< Main PLL division factor for PLLCLK (system clock) by 6 */
N#define LL_RCC_PLLR_DIV_8                  (RCC_PLLCFGR_PLLR)     /*!< Main PLL division factor for PLLCLK (system clock) by 8 */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_PLLP_DIV  PLL division factor (PLLP)
N  * @{
N  */
N#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
X#if 1L
N#define LL_RCC_PLLP_DIV_2                  (RCC_PLLCFGR_PLLPDIV_1)                                              /*!< Main PLL division factor for PLLP output by 2 */
N#define LL_RCC_PLLP_DIV_3                  (RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0)                        /*!< Main PLL division factor for PLLP output by 3 */
N#define LL_RCC_PLLP_DIV_4                  (RCC_PLLCFGR_PLLPDIV_2)                                              /*!< Main PLL division factor for PLLP output by 4 */
N#define LL_RCC_PLLP_DIV_5                  (RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_0)                        /*!< Main PLL division factor for PLLP output by 5 */
N#define LL_RCC_PLLP_DIV_6                  (RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1)                        /*!< Main PLL division factor for PLLP output by 6 */
N#define LL_RCC_PLLP_DIV_7                  (RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0)  /*!< Main PLL division factor for PLLP output by 7 */
N#define LL_RCC_PLLP_DIV_8                  (RCC_PLLCFGR_PLLPDIV_3)                                              /*!< Main PLL division factor for PLLP output by 8 */
N#define LL_RCC_PLLP_DIV_9                  (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_0)                        /*!< Main PLL division factor for PLLP output by 9 */
N#define LL_RCC_PLLP_DIV_10                 (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_1)                        /*!< Main PLL division factor for PLLP output by 10 */
N#define LL_RCC_PLLP_DIV_11                 (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0)  /*!< Main PLL division factor for PLLP output by 11 */
N#define LL_RCC_PLLP_DIV_12                 (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2)                        /*!< Main PLL division factor for PLLP output by 12 */
N#define LL_RCC_PLLP_DIV_13                 (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_0)  /*!< Main PLL division factor for PLLP output by 13 */
N#define LL_RCC_PLLP_DIV_14                 (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1)  /*!< Main PLL division factor for PLLP output by 14 */
N#define LL_RCC_PLLP_DIV_15                 (RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0) /*!< Main PLL division factor for PLLP output by 15 */
N#define LL_RCC_PLLP_DIV_16                 (RCC_PLLCFGR_PLLPDIV_4)                                              /*!< Main PLL division factor for PLLP output by 16 */
N#define LL_RCC_PLLP_DIV_17                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_0)                        /*!< Main PLL division factor for PLLP output by 17 */
N#define LL_RCC_PLLP_DIV_18                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_1)                        /*!< Main PLL division factor for PLLP output by 18 */
N#define LL_RCC_PLLP_DIV_19                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0)  /*!< Main PLL division factor for PLLP output by 19 */
N#define LL_RCC_PLLP_DIV_20                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_2)                        /*!< Main PLL division factor for PLLP output by 20 */
N#define LL_RCC_PLLP_DIV_21                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_0)  /*!< Main PLL division factor for PLLP output by 21 */
N#define LL_RCC_PLLP_DIV_22                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1)  /*!< Main PLL division factor for PLLP output by 22 */
N#define LL_RCC_PLLP_DIV_23                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0) /*!< Main PLL division factor for PLLP output by 23 */
N#define LL_RCC_PLLP_DIV_24                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3)                        /*!< Main PLL division factor for PLLP output by 24 */
N#define LL_RCC_PLLP_DIV_25                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_0)  /*!< Main PLL division factor for PLLP output by 25 */
N#define LL_RCC_PLLP_DIV_26                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_1)  /*!< Main PLL division factor for PLLP output by 26 */
N#define LL_RCC_PLLP_DIV_27                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0) /*!< Main PLL division factor for PLLP output by 27 */
N#define LL_RCC_PLLP_DIV_28                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2)  /*!< Main PLL division factor for PLLP output by 28 */
N#define LL_RCC_PLLP_DIV_29                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_0) /*!< Main PLL division factor for PLLP output by 29 */
N#define LL_RCC_PLLP_DIV_30                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1) /*!< Main PLL division factor for PLLP output by 30 */
N#define LL_RCC_PLLP_DIV_31                 (RCC_PLLCFGR_PLLPDIV_4|RCC_PLLCFGR_PLLPDIV_3|RCC_PLLCFGR_PLLPDIV_2|RCC_PLLCFGR_PLLPDIV_1|RCC_PLLCFGR_PLLPDIV_0) /*!< Main PLL division factor for PLLP output by 31 */
N#else
S#define LL_RCC_PLLP_DIV_7                  0x00000000U            /*!< Main PLL division factor for PLLP output by 7 */
S#define LL_RCC_PLLP_DIV_17                 (RCC_PLLCFGR_PLLP)     /*!< Main PLL division factor for PLLP output by 17 */
N#endif /* RCC_PLLP_DIV_2_31_SUPPORT */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_PLLQ_DIV  PLL division factor (PLLQ)
N  * @{
N  */
N#define LL_RCC_PLLQ_DIV_2                  0x00000000U             /*!< Main PLL division factor for PLLQ output by 2 */
N#define LL_RCC_PLLQ_DIV_4                  (RCC_PLLCFGR_PLLQ_0)    /*!< Main PLL division factor for PLLQ output by 4 */
N#define LL_RCC_PLLQ_DIV_6                  (RCC_PLLCFGR_PLLQ_1)    /*!< Main PLL division factor for PLLQ output by 6 */
N#define LL_RCC_PLLQ_DIV_8                  (RCC_PLLCFGR_PLLQ)      /*!< Main PLL division factor for PLLQ output by 8 */
N/**
N  * @}
N  */
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
X#if 0L
S/** @defgroup RCC_LL_EC_PLLSAI1M  PLLSAI1 division factor (PLLSAI1M)
S  * @{
S  */
S#define LL_RCC_PLLSAI1M_DIV_1              0x00000000U                                             /*!< PLLSAI1 division factor for PLLSAI1M input by 1 */
S#define LL_RCC_PLLSAI1M_DIV_2              (RCC_PLLSAI1CFGR_PLLSAI1M_0)                            /*!< PLLSAI1 division factor for PLLSAI1M input by 2 */
S#define LL_RCC_PLLSAI1M_DIV_3              (RCC_PLLSAI1CFGR_PLLSAI1M_1)                            /*!< PLLSAI1 division factor for PLLSAI1M input by 3 */
S#define LL_RCC_PLLSAI1M_DIV_4              (RCC_PLLSAI1CFGR_PLLSAI1M_1|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 4 */
S#define LL_RCC_PLLSAI1M_DIV_5              (RCC_PLLSAI1CFGR_PLLSAI1M_2)                            /*!< PLLSAI1 division factor for PLLSAI1M input by 5 */
S#define LL_RCC_PLLSAI1M_DIV_6              (RCC_PLLSAI1CFGR_PLLSAI1M_2|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 6 */
S#define LL_RCC_PLLSAI1M_DIV_7              (RCC_PLLSAI1CFGR_PLLSAI1M_2|RCC_PLLSAI1CFGR_PLLSAI1M_1) /*!< PLLSAI1 division factor for PLLSAI1M input by 7 */
S#define LL_RCC_PLLSAI1M_DIV_8              (RCC_PLLSAI1CFGR_PLLSAI1M_2|RCC_PLLSAI1CFGR_PLLSAI1M_1|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 8 */
S#define LL_RCC_PLLSAI1M_DIV_9              (RCC_PLLSAI1CFGR_PLLSAI1M_3)                            /*!< PLLSAI1 division factor for PLLSAI1M input by 9 */
S#define LL_RCC_PLLSAI1M_DIV_10             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 10 */
S#define LL_RCC_PLLSAI1M_DIV_11             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_1) /*!< PLLSAI1 division factor for PLLSAI1M input by 11 */
S#define LL_RCC_PLLSAI1M_DIV_12             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_1|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 12 */
S#define LL_RCC_PLLSAI1M_DIV_13             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_2) /*!< PLLSAI1 division factor for PLLSAI1M input by 13 */
S#define LL_RCC_PLLSAI1M_DIV_14             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_2|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 14 */
S#define LL_RCC_PLLSAI1M_DIV_15             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_2|RCC_PLLSAI1CFGR_PLLSAI1M_1) /*!< PLLSAI1 division factor for PLLSAI1M input by 15 */
S#define LL_RCC_PLLSAI1M_DIV_16             (RCC_PLLSAI1CFGR_PLLSAI1M_3|RCC_PLLSAI1CFGR_PLLSAI1M_2|RCC_PLLSAI1CFGR_PLLSAI1M_1|RCC_PLLSAI1CFGR_PLLSAI1M_0) /*!< PLLSAI1 division factor for PLLSAI1M input by 16 */
S/**
S  * @}
S  */
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
N
N/** @defgroup RCC_LL_EC_PLLSAI1Q  PLLSAI1 division factor (PLLSAI1Q)
N  * @{
N  */
N#define LL_RCC_PLLSAI1Q_DIV_2              0x00000000U                  /*!< PLLSAI1 division factor for PLLSAI1Q output by 2 */
N#define LL_RCC_PLLSAI1Q_DIV_4              (RCC_PLLSAI1CFGR_PLLSAI1Q_0) /*!< PLLSAI1 division factor for PLLSAI1Q output by 4 */
N#define LL_RCC_PLLSAI1Q_DIV_6              (RCC_PLLSAI1CFGR_PLLSAI1Q_1) /*!< PLLSAI1 division factor for PLLSAI1Q output by 6 */
N#define LL_RCC_PLLSAI1Q_DIV_8              (RCC_PLLSAI1CFGR_PLLSAI1Q)   /*!< PLLSAI1 division factor for PLLSAI1Q output by 8 */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_PLLSAI1P  PLLSAI1 division factor (PLLSAI1P)
N  * @{
N  */
N#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
X#if 1L
N#define LL_RCC_PLLSAI1P_DIV_2              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_1)                               /*!< PLLSAI1 division factor for PLLSAI1P output by 2 */
N#define LL_RCC_PLLSAI1P_DIV_3              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 3 */
N#define LL_RCC_PLLSAI1P_DIV_4              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_2)                               /*!< PLLSAI1 division factor for PLLSAI1P output by 4 */
N#define LL_RCC_PLLSAI1P_DIV_5              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 5 */
N#define LL_RCC_PLLSAI1P_DIV_6              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 6 */
N#define LL_RCC_PLLSAI1P_DIV_7              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 7 */
N#define LL_RCC_PLLSAI1P_DIV_8              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3)                               /*!< PLLSAI1 division factor for PLLSAI1P output by 8 */
N#define LL_RCC_PLLSAI1P_DIV_9              (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 9 */
N#define LL_RCC_PLLSAI1P_DIV_10             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 10 */
N#define LL_RCC_PLLSAI1P_DIV_11             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 1 */
N#define LL_RCC_PLLSAI1P_DIV_12             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2) /*!< PLLSAI1 division factor for PLLSAI1P output by 12 */
N#define LL_RCC_PLLSAI1P_DIV_13             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 13 */
N#define LL_RCC_PLLSAI1P_DIV_14             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 14 */
N#define LL_RCC_PLLSAI1P_DIV_15             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 15 */
N#define LL_RCC_PLLSAI1P_DIV_16             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4)                               /*!< PLLSAI1 division factor for PLLSAI1P output by 16 */
N#define LL_RCC_PLLSAI1P_DIV_17             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 17 */
N#define LL_RCC_PLLSAI1P_DIV_18             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 18 */
N#define LL_RCC_PLLSAI1P_DIV_19             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 19 */
N#define LL_RCC_PLLSAI1P_DIV_20             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2) /*!< PLLSAI1 division factor for PLLSAI1P output by 20 */
N#define LL_RCC_PLLSAI1P_DIV_21             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division fctor for PLLSAI1P output by 21 */
N#define LL_RCC_PLLSAI1P_DIV_22             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 22 */
N#define LL_RCC_PLLSAI1P_DIV_23             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 23 */
N#define LL_RCC_PLLSAI1P_DIV_24             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3) /*!< PLLSAI1 division factor for PLLSAI1P output by 24 */
N#define LL_RCC_PLLSAI1P_DIV_25             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 25 */
N#define LL_RCC_PLLSAI1P_DIV_26             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 26 */
N#define LL_RCC_PLLSAI1P_DIV_27             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 27 */
N#define LL_RCC_PLLSAI1P_DIV_28             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2) /*!< PLLSAI1 division factor for PLLSAI1P output by 28 */
N#define LL_RCC_PLLSAI1P_DIV_29             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 29 */
N#define LL_RCC_PLLSAI1P_DIV_30             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1) /*!< PLLSAI1 division factor for PLLSAI1P output by 30 */
N#define LL_RCC_PLLSAI1P_DIV_31             (RCC_PLLSAI1CFGR_PLLSAI1PDIV_4|RCC_PLLSAI1CFGR_PLLSAI1PDIV_3|RCC_PLLSAI1CFGR_PLLSAI1PDIV_2|RCC_PLLSAI1CFGR_PLLSAI1PDIV_1|RCC_PLLSAI1CFGR_PLLSAI1PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 31 */
N#else
S#define LL_RCC_PLLSAI1P_DIV_7              0x00000000U                /*!< PLLSAI1 division factor for PLLSAI1P output by 7 */
S#define LL_RCC_PLLSAI1P_DIV_17             (RCC_PLLSAI1CFGR_PLLSAI1P) /*!< PLLSAI1 division factor for PLLSAI1P output by 17 */
N#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EC_PLLSAI1R  PLLSAI1 division factor (PLLSAI1R)
N  * @{
N  */
N#define LL_RCC_PLLSAI1R_DIV_2              0x00000000U                  /*!< PLLSAI1 division factor for PLLSAI1R output by 2 */
N#define LL_RCC_PLLSAI1R_DIV_4              (RCC_PLLSAI1CFGR_PLLSAI1R_0) /*!< PLLSAI1 division factor for PLLSAI1R output by 4 */
N#define LL_RCC_PLLSAI1R_DIV_6              (RCC_PLLSAI1CFGR_PLLSAI1R_1) /*!< PLLSAI1 division factor for PLLSAI1R output by 6 */
N#define LL_RCC_PLLSAI1R_DIV_8              (RCC_PLLSAI1CFGR_PLLSAI1R)   /*!< PLLSAI1 division factor for PLLSAI1R output by 8 */
N/**
N  * @}
N  */
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S/** @defgroup RCC_LL_EC_PLLSAI2M  PLLSAI1 division factor (PLLSAI2M)
S  * @{
S  */
S#define LL_RCC_PLLSAI2M_DIV_1              0x00000000U                                             /*!< PLLSAI2 division factor for PLLSAI2M input by 1 */
S#define LL_RCC_PLLSAI2M_DIV_2              (RCC_PLLSAI2CFGR_PLLSAI2M_0)                            /*!< PLLSAI2 division factor for PLLSAI2M input by 2 */
S#define LL_RCC_PLLSAI2M_DIV_3              (RCC_PLLSAI2CFGR_PLLSAI2M_1)                            /*!< PLLSAI2 division factor for PLLSAI2M input by 3 */
S#define LL_RCC_PLLSAI2M_DIV_4              (RCC_PLLSAI2CFGR_PLLSAI2M_1|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 4 */
S#define LL_RCC_PLLSAI2M_DIV_5              (RCC_PLLSAI2CFGR_PLLSAI2M_2)                            /*!< PLLSAI2 division factor for PLLSAI2M input by 5 */
S#define LL_RCC_PLLSAI2M_DIV_6              (RCC_PLLSAI2CFGR_PLLSAI2M_2|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 6 */
S#define LL_RCC_PLLSAI2M_DIV_7              (RCC_PLLSAI2CFGR_PLLSAI2M_2|RCC_PLLSAI2CFGR_PLLSAI2M_1) /*!< PLLSAI2 division factor for PLLSAI2M input by 7 */
S#define LL_RCC_PLLSAI2M_DIV_8              (RCC_PLLSAI2CFGR_PLLSAI2M_2|RCC_PLLSAI2CFGR_PLLSAI2M_1|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 8 */
S#define LL_RCC_PLLSAI2M_DIV_9              (RCC_PLLSAI2CFGR_PLLSAI2M_3)                            /*!< PLLSAI2 division factor for PLLSAI2M input by 9 */
S#define LL_RCC_PLLSAI2M_DIV_10             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 10 */
S#define LL_RCC_PLLSAI2M_DIV_11             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_1) /*!< PLLSAI2 division factor for PLLSAI2M input by 11 */
S#define LL_RCC_PLLSAI2M_DIV_12             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_1|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 12 */
S#define LL_RCC_PLLSAI2M_DIV_13             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_2) /*!< PLLSAI2 division factor for PLLSAI2M input by 13 */
S#define LL_RCC_PLLSAI2M_DIV_14             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_2|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 14 */
S#define LL_RCC_PLLSAI2M_DIV_15             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_2|RCC_PLLSAI2CFGR_PLLSAI2M_1) /*!< PLLSAI2 division factor for PLLSAI2M input by 15 */
S#define LL_RCC_PLLSAI2M_DIV_16             (RCC_PLLSAI2CFGR_PLLSAI2M_3|RCC_PLLSAI2CFGR_PLLSAI2M_2|RCC_PLLSAI2CFGR_PLLSAI2M_1|RCC_PLLSAI2CFGR_PLLSAI2M_0) /*!< PLLSAI2 division factor for PLLSAI2M input by 16 */
S/**
S  * @}
S  */
S#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
S
S#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
S/** @defgroup RCC_LL_EC_PLLSAI2Q  PLLSAI2 division factor (PLLSAI2Q)
S  * @{
S  */
S#define LL_RCC_PLLSAI2Q_DIV_2              0x00000000U                  /*!< PLLSAI2 division factor for PLLSAI2Q output by 2 */
S#define LL_RCC_PLLSAI2Q_DIV_4              (RCC_PLLSAI2CFGR_PLLSAI2Q_0) /*!< PLLSAI2 division factor for PLLSAI2Q output by 4 */
S#define LL_RCC_PLLSAI2Q_DIV_6              (RCC_PLLSAI2CFGR_PLLSAI2Q_1) /*!< PLLSAI2 division factor for PLLSAI2Q output by 6 */
S#define LL_RCC_PLLSAI2Q_DIV_8              (RCC_PLLSAI2CFGR_PLLSAI2Q)   /*!< PLLSAI2 division factor for PLLSAI2Q output by 8 */
S/**
S  * @}
S  */
S#endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
S
S/** @defgroup RCC_LL_EC_PLLSAI2P  PLLSAI2 division factor (PLLSAI2P)
S  * @{
S  */
S#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
S#define LL_RCC_PLLSAI2P_DIV_2              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_1)                               /*!< PLLSAI2 division factor for PLLSAI2P output by 2 */
S#define LL_RCC_PLLSAI2P_DIV_3              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 3 */
S#define LL_RCC_PLLSAI2P_DIV_4              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_2)                               /*!< PLLSAI2 division factor for PLLSAI2P output by 4 */
S#define LL_RCC_PLLSAI2P_DIV_5              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 5 */
S#define LL_RCC_PLLSAI2P_DIV_6              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 6 */
S#define LL_RCC_PLLSAI2P_DIV_7              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 7 */
S#define LL_RCC_PLLSAI2P_DIV_8              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3)                               /*!< PLLSAI2 division factor for PLLSAI2P output by 8 */
S#define LL_RCC_PLLSAI2P_DIV_9              (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 9 */
S#define LL_RCC_PLLSAI2P_DIV_10             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 10 */
S#define LL_RCC_PLLSAI2P_DIV_11             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 1 */
S#define LL_RCC_PLLSAI2P_DIV_12             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2) /*!< PLLSAI2 division factor for PLLSAI2P output by 12 */
S#define LL_RCC_PLLSAI2P_DIV_13             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 13 */
S#define LL_RCC_PLLSAI2P_DIV_14             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 14 */
S#define LL_RCC_PLLSAI2P_DIV_15             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 15 */
S#define LL_RCC_PLLSAI2P_DIV_16             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4)                               /*!< PLLSAI2 division factor for PLLSAI2P output by 16 */
S#define LL_RCC_PLLSAI2P_DIV_17             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 17 */
S#define LL_RCC_PLLSAI2P_DIV_18             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 18 */
S#define LL_RCC_PLLSAI2P_DIV_19             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 19 */
S#define LL_RCC_PLLSAI2P_DIV_20             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2) /*!< PLLSAI2 division factor for PLLSAI2P output by 20 */
S#define LL_RCC_PLLSAI2P_DIV_21             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division fctor for PLLSAI2P output by 21 */
S#define LL_RCC_PLLSAI2P_DIV_22             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 22 */
S#define LL_RCC_PLLSAI2P_DIV_23             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 23 */
S#define LL_RCC_PLLSAI2P_DIV_24             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3) /*!< PLLSAI2 division factor for PLLSAI2P output by 24 */
S#define LL_RCC_PLLSAI2P_DIV_25             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 25 */
S#define LL_RCC_PLLSAI2P_DIV_26             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 26 */
S#define LL_RCC_PLLSAI2P_DIV_27             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 27 */
S#define LL_RCC_PLLSAI2P_DIV_28             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2) /*!< PLLSAI2 division factor for PLLSAI2P output by 28 */
S#define LL_RCC_PLLSAI2P_DIV_29             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI2 division factor for PLLSAI2P output by 29 */
S#define LL_RCC_PLLSAI2P_DIV_30             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1) /*!< PLLSAI2 division factor for PLLSAI2P output by 30 */
S#define LL_RCC_PLLSAI2P_DIV_31             (RCC_PLLSAI2CFGR_PLLSAI2PDIV_4|RCC_PLLSAI2CFGR_PLLSAI2PDIV_3|RCC_PLLSAI2CFGR_PLLSAI2PDIV_2|RCC_PLLSAI2CFGR_PLLSAI2PDIV_1|RCC_PLLSAI2CFGR_PLLSAI2PDIV_0) /*!< PLLSAI1 division factor for PLLSAI1P output by 31 */
S#else
S#define LL_RCC_PLLSAI2P_DIV_7              0x00000000U                /*!< PLLSAI2 division factor for PLLSAI2P output by 7 */
S#define LL_RCC_PLLSAI2P_DIV_17             (RCC_PLLSAI2CFGR_PLLSAI2P) /*!< PLLSAI2 division factor for PLLSAI2P output by 17 */
S#endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
S/**
S  * @}
S  */
S
S/** @defgroup RCC_LL_EC_PLLSAI2R  PLLSAI2 division factor (PLLSAI2R)
S  * @{
S  */
S#define LL_RCC_PLLSAI2R_DIV_2              0x00000000U                  /*!< PLLSAI2 division factor for PLLSAI2R output by 2 */
S#define LL_RCC_PLLSAI2R_DIV_4              (RCC_PLLSAI2CFGR_PLLSAI2R_0) /*!< PLLSAI2 division factor for PLLSAI2R output by 4 */
S#define LL_RCC_PLLSAI2R_DIV_6              (RCC_PLLSAI2CFGR_PLLSAI2R_1) /*!< PLLSAI2 division factor for PLLSAI2R output by 6 */
S#define LL_RCC_PLLSAI2R_DIV_8              (RCC_PLLSAI2CFGR_PLLSAI2R)   /*!< PLLSAI2 division factor for PLLSAI2R output by 8 */
S/**
S  * @}
S  */
S
S#if defined(RCC_CCIPR2_PLLSAI2DIVR)
S/** @defgroup RCC_LL_EC_PLLSAI2DIVR  PLLSAI2DIVR division factor (PLLSAI2DIVR)
S  * @{
S  */
S#define LL_RCC_PLLSAI2DIVR_DIV_2           0x00000000U                     /*!< PLLSAI2 division factor for PLLSAI2DIVR output by 2 */
S#define LL_RCC_PLLSAI2DIVR_DIV_4           RCC_CCIPR2_PLLSAI2DIVR_0        /*!< PLLSAI2 division factor for PLLSAI2DIVR output by 4 */
S#define LL_RCC_PLLSAI2DIVR_DIV_8           RCC_CCIPR2_PLLSAI2DIVR_1        /*!< PLLSAI2 division factor for PLLSAI2DIVR output by 8 */
S#define LL_RCC_PLLSAI2DIVR_DIV_16          (RCC_CCIPR2_PLLSAI2DIVR_1 | RCC_CCIPR2_PLLSAI2DIVR_0) /*!< PLLSAI2 division factor for PLLSAI2DIVR output by 16 */
S/**
S  * @}
S  */
S#endif /* RCC_CCIPR2_PLLSAI2DIVR */
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N/** @defgroup RCC_LL_EC_MSIRANGESEL  MSI clock range selection
N  * @{
N  */
N#define LL_RCC_MSIRANGESEL_STANDBY         0U                  /*!< MSI Range is provided by MSISRANGE */
N#define LL_RCC_MSIRANGESEL_RUN             1U                  /*!< MSI Range is provided by MSIRANGE */
N/**
N  * @}
N  */
N
N/** Legacy definitions for compatibility purpose
N@cond 0
N*/
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define LL_RCC_DFSDM1_CLKSOURCE_PCLK       LL_RCC_DFSDM1_CLKSOURCE_PCLK2
S#define LL_RCC_DFSDM_CLKSOURCE_PCLK        LL_RCC_DFSDM1_CLKSOURCE_PCLK2
S#define LL_RCC_DFSDM_CLKSOURCE_SYSCLK      LL_RCC_DFSDM1_CLKSOURCE_SYSCLK
S#define LL_RCC_DFSDM_CLKSOURCE             LL_RCC_DFSDM1_CLKSOURCE
N#endif /* DFSDM1_Channel0 */
N#if defined(SWPMI1)
X#if 1L
N#define LL_RCC_SWPMI1_CLKSOURCE_PCLK       LL_RCC_SWPMI1_CLKSOURCE_PCLK1
N#endif /* SWPMI1 */
N/**
N@endcond
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCC_LL_Exported_Macros RCC Exported Macros
N  * @{
N  */
N
N/** @defgroup RCC_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in RCC register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_RCC_WriteReg(__REG__, __VALUE__) WRITE_REG(RCC->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in RCC register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_RCC_ReadReg(__REG__) READ_REG(RCC->__REG__)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EM_CALC_FREQ Calculate frequencies
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to calculate the PLLCLK frequency on system domain
N  * @note ex: @ref __LL_RCC_CALC_PLLCLK_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLL_GetN (), @ref LL_RCC_PLL_GetR ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @param  __PLLN__ Between 8 and 86
N  * @param  __PLLR__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLR_DIV_2
N  *         @arg @ref LL_RCC_PLLR_DIV_4
N  *         @arg @ref LL_RCC_PLLR_DIV_6
N  *         @arg @ref LL_RCC_PLLR_DIV_8
N  * @retval PLL clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLCLK_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLR__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) / \
N                   ((((__PLLR__) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U))
X#define __LL_RCC_CALC_PLLCLK_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLR__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) /                    ((((__PLLR__) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U))
N
N#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
X#if 1L
N/**
N  * @brief  Helper macro to calculate the PLLCLK frequency used on SAI domain
N  * @note ex: @ref __LL_RCC_CALC_PLLCLK_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLL_GetN (), @ref LL_RCC_PLL_GetP ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @param  __PLLN__ Between 8 and 86
N  * @param  __PLLP__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLP_DIV_2
N  *         @arg @ref LL_RCC_PLLP_DIV_3
N  *         @arg @ref LL_RCC_PLLP_DIV_4
N  *         @arg @ref LL_RCC_PLLP_DIV_5
N  *         @arg @ref LL_RCC_PLLP_DIV_6
N  *         @arg @ref LL_RCC_PLLP_DIV_7
N  *         @arg @ref LL_RCC_PLLP_DIV_8
N  *         @arg @ref LL_RCC_PLLP_DIV_9
N  *         @arg @ref LL_RCC_PLLP_DIV_10
N  *         @arg @ref LL_RCC_PLLP_DIV_11
N  *         @arg @ref LL_RCC_PLLP_DIV_12
N  *         @arg @ref LL_RCC_PLLP_DIV_13
N  *         @arg @ref LL_RCC_PLLP_DIV_14
N  *         @arg @ref LL_RCC_PLLP_DIV_15
N  *         @arg @ref LL_RCC_PLLP_DIV_16
N  *         @arg @ref LL_RCC_PLLP_DIV_17
N  *         @arg @ref LL_RCC_PLLP_DIV_18
N  *         @arg @ref LL_RCC_PLLP_DIV_19
N  *         @arg @ref LL_RCC_PLLP_DIV_20
N  *         @arg @ref LL_RCC_PLLP_DIV_21
N  *         @arg @ref LL_RCC_PLLP_DIV_22
N  *         @arg @ref LL_RCC_PLLP_DIV_23
N  *         @arg @ref LL_RCC_PLLP_DIV_24
N  *         @arg @ref LL_RCC_PLLP_DIV_25
N  *         @arg @ref LL_RCC_PLLP_DIV_26
N  *         @arg @ref LL_RCC_PLLP_DIV_27
N  *         @arg @ref LL_RCC_PLLP_DIV_28
N  *         @arg @ref LL_RCC_PLLP_DIV_29
N  *         @arg @ref LL_RCC_PLLP_DIV_30
N  *         @arg @ref LL_RCC_PLLP_DIV_31
N  * @retval PLL clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLCLK_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLP__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) / \
N                   ((__PLLP__) >> RCC_PLLCFGR_PLLPDIV_Pos))
X#define __LL_RCC_CALC_PLLCLK_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLP__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) /                    ((__PLLP__) >> RCC_PLLCFGR_PLLPDIV_Pos))
N
N#else
S/**
S  * @brief  Helper macro to calculate the PLLCLK frequency used on SAI domain
S  * @note ex: @ref __LL_RCC_CALC_PLLCLK_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
S  *             @ref LL_RCC_PLL_GetN (), @ref LL_RCC_PLL_GetP ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLM__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  __PLLN__ Between 8 and 86
S  * @param  __PLLP__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLP_DIV_7
S  *         @arg @ref LL_RCC_PLLP_DIV_17
S  * @retval PLL clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLCLK_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLP__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) / \
S                   (((__PLLP__) == LL_RCC_PLLP_DIV_7) ? 7U : 17U))
X#define __LL_RCC_CALC_PLLCLK_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLP__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) /                    (((__PLLP__) == LL_RCC_PLLP_DIV_7) ? 7U : 17U))
S
N#endif /* RCC_PLLP_DIV_2_31_SUPPORT */
N
N/**
N  * @brief  Helper macro to calculate the PLLCLK frequency used on 48M domain
N  * @note ex: @ref __LL_RCC_CALC_PLLCLK_48M_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLL_GetN (), @ref LL_RCC_PLL_GetQ ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @param  __PLLN__ Between 8 and 86
N  * @param  __PLLQ__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLQ_DIV_2
N  *         @arg @ref LL_RCC_PLLQ_DIV_4
N  *         @arg @ref LL_RCC_PLLQ_DIV_6
N  *         @arg @ref LL_RCC_PLLQ_DIV_8
N  * @retval PLL clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLCLK_48M_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLQ__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) / \
N                   ((((__PLLQ__) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLCLK_48M_FREQ(__INPUTFREQ__, __PLLM__, __PLLN__, __PLLQ__) ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLN__) /                    ((((__PLLQ__) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U))
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
X#if 0L && 1L
S/**
S  * @brief  Helper macro to calculate the PLLSAI1 frequency used for SAI domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLLSAI1_GetDivider (),
S  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetP ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLSAI1M__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  * @param  __PLLSAI1N__ Between 8 and 86
S  * @param  __PLLSAI1P__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_31
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI1_SAI_FREQ(__INPUTFREQ__, __PLLSAI1M__, __PLLSAI1N__, __PLLSAI1P__) \
S                   ((__INPUTFREQ__) / ((((__PLLSAI1M__) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U)) * (__PLLSAI1N__) / \
S                    ((__PLLSAI1P__) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos))
X#define __LL_RCC_CALC_PLLSAI1_SAI_FREQ(__INPUTFREQ__, __PLLSAI1M__, __PLLSAI1N__, __PLLSAI1P__)                    ((__INPUTFREQ__) / ((((__PLLSAI1M__) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U)) * (__PLLSAI1N__) /                     ((__PLLSAI1P__) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos))
S
N#elif defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
X#elif 1L
N/**
N  * @brief  Helper macro to calculate the PLLSAI1 frequency used for SAI domain
N  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetP ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  __PLLSAI1N__ Between 8 and 86
N  * @param  __PLLSAI1P__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_3
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_5
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_8
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_9
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_10
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_11
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_12
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_13
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_14
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_15
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_16
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_18
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_19
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_20
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_21
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_22
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_23
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_24
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_25
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_26
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_27
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_28
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_29
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_30
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_31
N  * @retval PLLSAI1 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLSAI1_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1P__) \
N                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) / \
N                    ((__PLLSAI1P__) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos))
X#define __LL_RCC_CALC_PLLSAI1_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1P__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) /                     ((__PLLSAI1P__) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos))
N
N#else
S/**
S  * @brief  Helper macro to calculate the PLLSAI1 frequency used for SAI domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
S  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetP ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLM__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  __PLLSAI1N__ Between 8 and 86
S  * @param  __PLLSAI1P__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI1_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1P__) \
S                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) / \
S                    (((__PLLSAI1P__) == LL_RCC_PLLSAI1P_DIV_7) ? 7U : 17U))
X#define __LL_RCC_CALC_PLLSAI1_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1P__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) /                     (((__PLLSAI1P__) == LL_RCC_PLLSAI1P_DIV_7) ? 7U : 17U))
S
N#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
X#if 0L
S/**
S  * @brief  Helper macro to calculate the PLLSAI1 frequency used on 48M domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_48M_FREQ (HSE_VALUE,@ref LL_RCC_PLLSAI1_GetDivider (),
S  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetQ ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLSAI1M__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  * @param  __PLLSAI1N__ Between 8 and 86
S  * @param  __PLLSAI1Q__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_8
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI1_48M_FREQ(__INPUTFREQ__, __PLLSAI1M__, __PLLSAI1N__, __PLLSAI1Q__) \
S                   ((__INPUTFREQ__) / ((((__PLLSAI1M__) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U)) * (__PLLSAI1N__) / \
S                    ((((__PLLSAI1Q__) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLSAI1_48M_FREQ(__INPUTFREQ__, __PLLSAI1M__, __PLLSAI1N__, __PLLSAI1Q__)                    ((__INPUTFREQ__) / ((((__PLLSAI1M__) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U)) * (__PLLSAI1N__) /                     ((((__PLLSAI1Q__) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U))
S
N#else
N/**
N  * @brief  Helper macro to calculate the PLLSAI1 frequency used on 48M domain
N  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_48M_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetQ ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  __PLLSAI1N__ Between 8 and 86
N  * @param  __PLLSAI1Q__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_8
N  * @retval PLLSAI1 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLSAI1_48M_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1Q__) \
N                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) / \
N                    ((((__PLLSAI1Q__) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLSAI1_48M_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1Q__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) /                     ((((__PLLSAI1Q__) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U))
N
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
X#if 0L
S/**
S  * @brief  Helper macro to calculate the PLLSAI1 frequency used on ADC domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_ADC_FREQ (HSE_VALUE,@ref LL_RCC_PLLSAI1_GetDivider (),
S  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetR ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLSAI1M__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  * @param  __PLLSAI1N__ Between 8 and 86
S  * @param  __PLLSAI1R__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_8
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI1_ADC_FREQ(__INPUTFREQ__, __PLLSAI1M__, __PLLSAI1N__, __PLLSAI1R__) \
S                   ((__INPUTFREQ__) / ((((__PLLSAI1M__) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U)) * (__PLLSAI1N__) / \
S                    ((((__PLLSAI1R__) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLSAI1_ADC_FREQ(__INPUTFREQ__, __PLLSAI1M__, __PLLSAI1N__, __PLLSAI1R__)                    ((__INPUTFREQ__) / ((((__PLLSAI1M__) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U)) * (__PLLSAI1N__) /                     ((((__PLLSAI1R__) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U))
S
N#else
N/**
N  * @brief  Helper macro to calculate the PLLSAI1 frequency used on ADC domain
N  * @note ex: @ref __LL_RCC_CALC_PLLSAI1_ADC_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLLSAI1_GetN (), @ref LL_RCC_PLLSAI1_GetR ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  __PLLSAI1N__ Between 8 and 86
N  * @param  __PLLSAI1R__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_8
N  * @retval PLLSAI1 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLSAI1_ADC_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1R__) \
N                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) / \
N                    ((((__PLLSAI1R__) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLSAI1_ADC_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI1N__, __PLLSAI1R__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI1N__) /                     ((((__PLLSAI1R__) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U))
N
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
N
N#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
X#if 0L && 0L
S/**
S  * @brief  Helper macro to calculate the PLLSAI2 frequency used for SAI domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI2_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLLSAI2_GetDivider (),
S  *             @ref LL_RCC_PLLSAI2_GetN (), @ref LL_RCC_PLLSAI2_GetP ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLSAI2M__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  * @param  __PLLSAI2N__ Between 8 and 86
S  * @param  __PLLSAI2P__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_31
S  * @retval PLLSAI2 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI2_SAI_FREQ(__INPUTFREQ__, __PLLSAI2M__, __PLLSAI2N__, __PLLSAI2P__) \
S                   ((__INPUTFREQ__) / ((((__PLLSAI2M__) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U)) * (__PLLSAI2N__) / \
S                    ((__PLLSAI2P__) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos))
X#define __LL_RCC_CALC_PLLSAI2_SAI_FREQ(__INPUTFREQ__, __PLLSAI2M__, __PLLSAI2N__, __PLLSAI2P__)                    ((__INPUTFREQ__) / ((((__PLLSAI2M__) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U)) * (__PLLSAI2N__) /                     ((__PLLSAI2P__) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos))
S
S#elif defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
X#elif 0L
S/**
S  * @brief  Helper macro to calculate the PLLSAI2 frequency used for SAI domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI2_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
S  *             @ref LL_RCC_PLLSAI2_GetN (), @ref LL_RCC_PLLSAI2_GetP ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
S  * @param  __PLLM__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  __PLLSAI2N__ Between 8 and 86
S  * @param  __PLLSAI2P__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_31
S  * @retval PLLSAI2 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI2_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI2N__, __PLLSAI2P__) \
S                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI2N__) / \
S                    ((__PLLSAI2P__) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos))
X#define __LL_RCC_CALC_PLLSAI2_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI2N__, __PLLSAI2P__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI2N__) /                     ((__PLLSAI2P__) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos))
S
N#else
N/**
N  * @brief  Helper macro to calculate the PLLSAI2 frequency used for SAI domain
N  * @note ex: @ref __LL_RCC_CALC_PLLSAI2_SAI_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLLSAI2_GetN (), @ref LL_RCC_PLLSAI2_GetP ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  __PLLSAI2N__ Between 8 and 86
N  * @param  __PLLSAI2P__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
N  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
N  * @retval PLLSAI2 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLSAI2_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI2N__, __PLLSAI2P__) \
N                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1)) * (__PLLSAI2N__) / \
N                    (((__PLLSAI2P__) == LL_RCC_PLLSAI2P_DIV_7) ? 7U : 17U))
X#define __LL_RCC_CALC_PLLSAI2_SAI_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI2N__, __PLLSAI2P__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1)) * (__PLLSAI2N__) /                     (((__PLLSAI2P__) == LL_RCC_PLLSAI2P_DIV_7) ? 7U : 17U))
N
N#endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
N
N#if defined(LTDC)
X#if 0L
S/**
S  * @brief  Helper macro to calculate the PLLSAI2 frequency used for LTDC domain
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI2_LTDC_FREQ (HSE_VALUE,@ref LL_RCC_PLLSAI2_GetDivider (),
S  *             @ref LL_RCC_PLLSAI2_GetN (), @ref LL_RCC_PLLSAI2_GetR (), @ref LL_RCC_PLLSAI2_GetDIVR ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on HSE/HSI/MSI)
S  * @param  __PLLSAI2M__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  * @param  __PLLSAI2N__ Between 8 and 86
S  * @param  __PLLSAI2R__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_8
S  * @param  __PLLSAI2DIVR__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_16
S  * @retval PLLSAI2 clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI2_LTDC_FREQ(__INPUTFREQ__, __PLLSAI2M__, __PLLSAI2N__, __PLLSAI2R__, __PLLSAI2DIVR__) \
S                   (((__INPUTFREQ__) / (((__PLLSAI2M__)>> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U)) * (__PLLSAI2N__) / \
S                    (((((__PLLSAI2R__) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos ) + 1U) << 1U) * (aRCC_PLLSAI2DIVRPrescTable[(__PLLSAI2DIVR__) >> RCC_CCIPR2_PLLSAI2DIVR_Pos])))
X#define __LL_RCC_CALC_PLLSAI2_LTDC_FREQ(__INPUTFREQ__, __PLLSAI2M__, __PLLSAI2N__, __PLLSAI2R__, __PLLSAI2DIVR__)                    (((__INPUTFREQ__) / (((__PLLSAI2M__)>> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U)) * (__PLLSAI2N__) /                     (((((__PLLSAI2R__) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos ) + 1U) << 1U) * (aRCC_PLLSAI2DIVRPrescTable[(__PLLSAI2DIVR__) >> RCC_CCIPR2_PLLSAI2DIVR_Pos])))
N#else
N/**
N  * @brief  Helper macro to calculate the PLLSAI2 frequency used on ADC domain
N  * @note ex: @ref __LL_RCC_CALC_PLLSAI2_ADC_FREQ (HSE_VALUE,@ref LL_RCC_PLL_GetDivider (),
N  *             @ref LL_RCC_PLLSAI2_GetN (), @ref LL_RCC_PLLSAI2_GetR ());
N  * @param  __INPUTFREQ__ PLL Input frequency (based on MSI/HSE/HSI)
N  * @param  __PLLM__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  __PLLSAI2N__ Between 8 and 86
N  * @param  __PLLSAI2R__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI2R_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI2R_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI2R_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI2R_DIV_8
N  * @retval PLLSAI2 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PLLSAI2_ADC_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI2N__, __PLLSAI2R__) \
N                   ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI2N__) / \
N                    ((((__PLLSAI2R__) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos ) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLSAI2_ADC_FREQ(__INPUTFREQ__, __PLLM__, __PLLSAI2N__, __PLLSAI2R__)                    ((__INPUTFREQ__) / ((((__PLLM__)>> RCC_PLLCFGR_PLLM_Pos) + 1U)) * (__PLLSAI2N__) /                     ((((__PLLSAI2R__) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos ) + 1U) << 1U))
N
N#endif /* LTDC */
N
N#if defined(DSI)
X#if 0L
S/**
S  * @brief  Helper macro to calculate the PLLDSICLK frequency used on DSI
S  * @note ex: @ref __LL_RCC_CALC_PLLSAI2_DSI_FREQ (HSE_VALUE,@ref LL_RCC_PLLSAI2_GetDivider (),
S  *             @ref LL_RCC_PLLSAI2_GetN (), @ref LL_RCC_PLLSAI2_GetQ ());
S  * @param  __INPUTFREQ__ PLL Input frequency (based on HSE/HSI/MSI)
S  * @param  __PLLSAI2M__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  * @param  __PLLSAI2N__ Between 8 and 86
S  * @param  __PLLSAI2Q__ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_8
S  * @retval PLL clock frequency (in Hz)
S  */
S#define __LL_RCC_CALC_PLLSAI2_DSI_FREQ(__INPUTFREQ__, __PLLSAI2M__, __PLLSAI2N__, __PLLSAI2Q__) \
S                   ((__INPUTFREQ__) / ((((__PLLSAI2M__) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U)) * (__PLLSAI2N__) / \
S                    ((((__PLLSAI2Q__) >> RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) + 1U) << 1U))
X#define __LL_RCC_CALC_PLLSAI2_DSI_FREQ(__INPUTFREQ__, __PLLSAI2M__, __PLLSAI2N__, __PLLSAI2Q__)                    ((__INPUTFREQ__) / ((((__PLLSAI2M__) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U)) * (__PLLSAI2N__) /                     ((((__PLLSAI2Q__) >> RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) + 1U) << 1U))
N#endif /* DSI */
N
N
N
N/**
N  * @brief  Helper macro to calculate the HCLK frequency
N  * @param  __SYSCLKFREQ__ SYSCLK frequency (based on MSI/HSE/HSI/PLLCLK)
N  * @param  __AHBPRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SYSCLK_DIV_1
N  *         @arg @ref LL_RCC_SYSCLK_DIV_2
N  *         @arg @ref LL_RCC_SYSCLK_DIV_4
N  *         @arg @ref LL_RCC_SYSCLK_DIV_8
N  *         @arg @ref LL_RCC_SYSCLK_DIV_16
N  *         @arg @ref LL_RCC_SYSCLK_DIV_64
N  *         @arg @ref LL_RCC_SYSCLK_DIV_128
N  *         @arg @ref LL_RCC_SYSCLK_DIV_256
N  *         @arg @ref LL_RCC_SYSCLK_DIV_512
N  * @retval HCLK clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_HCLK_FREQ(__SYSCLKFREQ__, __AHBPRESCALER__) ((__SYSCLKFREQ__) >> AHBPrescTable[((__AHBPRESCALER__) & RCC_CFGR_HPRE) >>  RCC_CFGR_HPRE_Pos])
N
N/**
N  * @brief  Helper macro to calculate the PCLK1 frequency (ABP1)
N  * @param  __HCLKFREQ__ HCLK frequency
N  * @param  __APB1PRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_APB1_DIV_1
N  *         @arg @ref LL_RCC_APB1_DIV_2
N  *         @arg @ref LL_RCC_APB1_DIV_4
N  *         @arg @ref LL_RCC_APB1_DIV_8
N  *         @arg @ref LL_RCC_APB1_DIV_16
N  * @retval PCLK1 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PCLK1_FREQ(__HCLKFREQ__, __APB1PRESCALER__) ((__HCLKFREQ__) >> APBPrescTable[(__APB1PRESCALER__) >>  RCC_CFGR_PPRE1_Pos])
N
N/**
N  * @brief  Helper macro to calculate the PCLK2 frequency (ABP2)
N  * @param  __HCLKFREQ__ HCLK frequency
N  * @param  __APB2PRESCALER__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_APB2_DIV_1
N  *         @arg @ref LL_RCC_APB2_DIV_2
N  *         @arg @ref LL_RCC_APB2_DIV_4
N  *         @arg @ref LL_RCC_APB2_DIV_8
N  *         @arg @ref LL_RCC_APB2_DIV_16
N  * @retval PCLK2 clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_PCLK2_FREQ(__HCLKFREQ__, __APB2PRESCALER__) ((__HCLKFREQ__) >> APBPrescTable[(__APB2PRESCALER__) >>  RCC_CFGR_PPRE2_Pos])
N
N/**
N  * @brief  Helper macro to calculate the MSI frequency (in Hz)
N  * @note __MSISEL__ can be retrieved thanks to function LL_RCC_MSI_IsEnabledRangeSelect()
N  * @note if __MSISEL__ is equal to LL_RCC_MSIRANGESEL_STANDBY,
N  *        __MSIRANGE__can be retrieved by LL_RCC_MSI_GetRangeAfterStandby()
N  *        else by LL_RCC_MSI_GetRange()
N  *        ex: __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
N  *              (LL_RCC_MSI_IsEnabledRangeSelect()?
N  *               LL_RCC_MSI_GetRange():
N  *               LL_RCC_MSI_GetRangeAfterStandby()))
N  * @param  __MSISEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_MSIRANGESEL_STANDBY
N  *         @arg @ref LL_RCC_MSIRANGESEL_RUN
N  * @param  __MSIRANGE__ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_MSIRANGE_0
N  *         @arg @ref LL_RCC_MSIRANGE_1
N  *         @arg @ref LL_RCC_MSIRANGE_2
N  *         @arg @ref LL_RCC_MSIRANGE_3
N  *         @arg @ref LL_RCC_MSIRANGE_4
N  *         @arg @ref LL_RCC_MSIRANGE_5
N  *         @arg @ref LL_RCC_MSIRANGE_6
N  *         @arg @ref LL_RCC_MSIRANGE_7
N  *         @arg @ref LL_RCC_MSIRANGE_8
N  *         @arg @ref LL_RCC_MSIRANGE_9
N  *         @arg @ref LL_RCC_MSIRANGE_10
N  *         @arg @ref LL_RCC_MSIRANGE_11
N  *         @arg @ref LL_RCC_MSISRANGE_4
N  *         @arg @ref LL_RCC_MSISRANGE_5
N  *         @arg @ref LL_RCC_MSISRANGE_6
N  *         @arg @ref LL_RCC_MSISRANGE_7
N  * @retval MSI clock frequency (in Hz)
N  */
N#define __LL_RCC_CALC_MSI_FREQ(__MSISEL__, __MSIRANGE__)   (((__MSISEL__) == LL_RCC_MSIRANGESEL_STANDBY) ? \
N                           (MSIRangeTable[(__MSIRANGE__) >> 8U]) : \
N                           (MSIRangeTable[(__MSIRANGE__) >> 4U]))
X#define __LL_RCC_CALC_MSI_FREQ(__MSISEL__, __MSIRANGE__)   (((__MSISEL__) == LL_RCC_MSIRANGESEL_STANDBY) ?                            (MSIRangeTable[(__MSIRANGE__) >> 8U]) :                            (MSIRangeTable[(__MSIRANGE__) >> 4U]))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RCC_LL_Exported_Functions RCC Exported Functions
N  * @{
N  */
N
N/** @defgroup RCC_LL_EF_HSE HSE
N  * @{
N  */
N
N/**
N  * @brief  Enable the Clock Security System.
N  * @rmtoll CR           CSSON         LL_RCC_HSE_EnableCSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSE_EnableCSS(void)
Xstatic __inline void LL_RCC_HSE_EnableCSS(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_CSSON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Enable HSE external oscillator (HSE Bypass)
N  * @rmtoll CR           HSEBYP        LL_RCC_HSE_EnableBypass
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSE_EnableBypass(void)
Xstatic __inline void LL_RCC_HSE_EnableBypass(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_HSEBYP);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Disable HSE external oscillator (HSE Bypass)
N  * @rmtoll CR           HSEBYP        LL_RCC_HSE_DisableBypass
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSE_DisableBypass(void)
Xstatic __inline void LL_RCC_HSE_DisableBypass(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Enable HSE crystal oscillator (HSE ON)
N  * @rmtoll CR           HSEON         LL_RCC_HSE_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSE_Enable(void)
Xstatic __inline void LL_RCC_HSE_Enable(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_HSEON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable HSE crystal oscillator (HSE ON)
N  * @rmtoll CR           HSEON         LL_RCC_HSE_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSE_Disable(void)
Xstatic __inline void LL_RCC_HSE_Disable(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Check if HSE oscillator Ready
N  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
Xstatic __inline uint32_t LL_RCC_HSE_IsReady(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (17U)))) == ((0x1UL << (17U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_HSI HSI
N  * @{
N  */
N
N/**
N  * @brief  Enable HSI even in stop mode
N  * @note HSI oscillator is forced ON even in Stop mode
N  * @rmtoll CR           HSIKERON      LL_RCC_HSI_EnableInStopMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_EnableInStopMode(void)
Xstatic __inline void LL_RCC_HSI_EnableInStopMode(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_HSIKERON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable HSI in stop mode
N  * @rmtoll CR           HSIKERON      LL_RCC_HSI_DisableInStopMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_DisableInStopMode(void)
Xstatic __inline void LL_RCC_HSI_DisableInStopMode(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_HSIKERON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Check if HSI is enabled in stop mode
N  * @rmtoll CR           HSIKERON        LL_RCC_HSI_IsEnabledInStopMode
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSI_IsEnabledInStopMode(void)
Xstatic __inline uint32_t LL_RCC_HSI_IsEnabledInStopMode(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_HSIKERON) == (RCC_CR_HSIKERON));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Enable HSI oscillator
N  * @rmtoll CR           HSION         LL_RCC_HSI_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_Enable(void)
Xstatic __inline void LL_RCC_HSI_Enable(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_HSION);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable HSI oscillator
N  * @rmtoll CR           HSION         LL_RCC_HSI_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_Disable(void)
Xstatic __inline void LL_RCC_HSI_Disable(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if HSI clock is ready
N  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
Xstatic __inline uint32_t LL_RCC_HSI_IsReady(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Enable HSI Automatic from stop mode
N  * @rmtoll CR           HSIASFS       LL_RCC_HSI_EnableAutoFromStop
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_EnableAutoFromStop(void)
Xstatic __inline void LL_RCC_HSI_EnableAutoFromStop(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_HSIASFS);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable HSI Automatic from stop mode
N  * @rmtoll CR           HSIASFS       LL_RCC_HSI_DisableAutoFromStop
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_DisableAutoFromStop(void)
Xstatic __inline void LL_RCC_HSI_DisableAutoFromStop(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_HSIASFS);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (11U))));
N}
N/**
N  * @brief  Get HSI Calibration value
N  * @note When HSITRIM is written, HSICAL is updated with the sum of
N  *       HSITRIM and the factory trim value
N  * @rmtoll ICSCR        HSICAL        LL_RCC_HSI_GetCalibration
N  * @retval Between Min_Data = 0x00 and Max_Data = 0xFF
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSI_GetCalibration(void)
Xstatic __inline uint32_t LL_RCC_HSI_GetCalibration(void)
N{
N  return (uint32_t)(READ_BIT(RCC->ICSCR, RCC_ICSCR_HSICAL) >> RCC_ICSCR_HSICAL_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR) & ((0xFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Set HSI Calibration trimming
N  * @note user-programmable trimming value that is added to the HSICAL
N  * @note Default value is 16, which, when added to the HSICAL value,
N  *       should trim the HSI to 16 MHz +/- 1 %
N  * @rmtoll ICSCR        HSITRIM       LL_RCC_HSI_SetCalibTrimming
N  * @param  Value Between Min_Data = 0 and Max_Data = 31
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
Xstatic __inline void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
N{
N  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR))) & (~((0x1FUL << (24U))))) | (Value << (24U)))));
N}
N
N/**
N  * @brief  Get HSI Calibration trimming
N  * @rmtoll ICSCR        HSITRIM       LL_RCC_HSI_GetCalibTrimming
N  * @retval Between Min_Data = 0 and Max_Data = 31
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSI_GetCalibTrimming(void)
Xstatic __inline uint32_t LL_RCC_HSI_GetCalibTrimming(void)
N{
N  return (uint32_t)(READ_BIT(RCC->ICSCR, RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR) & ((0x1FUL << (24U)))) >> (24U));
N}
N
N/**
N  * @}
N  */
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/** @defgroup RCC_LL_EF_HSI48 HSI48
N  * @{
N  */
N
N/**
N  * @brief  Enable HSI48
N  * @rmtoll CRRCR          HSI48ON       LL_RCC_HSI48_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
Xstatic __inline void LL_RCC_HSI48_Enable(void)
N{
N  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CRRCR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable HSI48
N  * @rmtoll CRRCR          HSI48ON       LL_RCC_HSI48_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_HSI48_Disable(void)
Xstatic __inline void LL_RCC_HSI48_Disable(void)
N{
N  CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CRRCR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if HSI48 oscillator Ready
N  * @rmtoll CRRCR          HSI48RDY      LL_RCC_HSI48_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
Xstatic __inline uint32_t LL_RCC_HSI48_IsReady(void)
N{
N  return (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CRRCR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get HSI48 Calibration value
N  * @rmtoll CRRCR          HSI48CAL      LL_RCC_HSI48_GetCalibration
N  * @retval Between Min_Data = 0x00 and Max_Data = 0x1FF
N  */
N__STATIC_INLINE uint32_t LL_RCC_HSI48_GetCalibration(void)
Xstatic __inline uint32_t LL_RCC_HSI48_GetCalibration(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48CAL) >> RCC_CRRCR_HSI48CAL_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CRRCR) & ((0x1FFUL << (7U)))) >> (7U));
N}
N
N/**
N  * @}
N  */
N#endif /* RCC_HSI48_SUPPORT */
N
N/** @defgroup RCC_LL_EF_LSE LSE
N  * @{
N  */
N
N/**
N  * @brief  Enable  Low Speed External (LSE) crystal.
N  * @rmtoll BDCR         LSEON         LL_RCC_LSE_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_Enable(void)
Xstatic __inline void LL_RCC_LSE_Enable(void)
N{
N  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable  Low Speed External (LSE) crystal.
N  * @rmtoll BDCR         LSEON         LL_RCC_LSE_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_Disable(void)
Xstatic __inline void LL_RCC_LSE_Disable(void)
N{
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable external clock source (LSE bypass).
N  * @rmtoll BDCR         LSEBYP        LL_RCC_LSE_EnableBypass
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_EnableBypass(void)
Xstatic __inline void LL_RCC_LSE_EnableBypass(void)
N{
N  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable external clock source (LSE bypass).
N  * @rmtoll BDCR         LSEBYP        LL_RCC_LSE_DisableBypass
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_DisableBypass(void)
Xstatic __inline void LL_RCC_LSE_DisableBypass(void)
N{
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Set LSE oscillator drive capability
N  * @note The oscillator is in Xtal mode when it is not in bypass mode.
N  * @rmtoll BDCR         LSEDRV        LL_RCC_LSE_SetDriveCapability
N  * @param  LSEDrive This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_LSEDRIVE_LOW
N  *         @arg @ref LL_RCC_LSEDRIVE_MEDIUMLOW
N  *         @arg @ref LL_RCC_LSEDRIVE_MEDIUMHIGH
N  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
Xstatic __inline void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
N{
N  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR))) & (~((0x3UL << (3U))))) | (LSEDrive))));
N}
N
N/**
N  * @brief  Get LSE oscillator drive capability
N  * @rmtoll BDCR         LSEDRV        LL_RCC_LSE_GetDriveCapability
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_LSEDRIVE_LOW
N  *         @arg @ref LL_RCC_LSEDRIVE_MEDIUMLOW
N  *         @arg @ref LL_RCC_LSEDRIVE_MEDIUMHIGH
N  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
N  */
N__STATIC_INLINE uint32_t LL_RCC_LSE_GetDriveCapability(void)
Xstatic __inline uint32_t LL_RCC_LSE_GetDriveCapability(void)
N{
N  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_LSEDRV));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) & ((0x3UL << (3U)))));
N}
N
N/**
N  * @brief  Enable Clock security system on LSE.
N  * @rmtoll BDCR         LSECSSON      LL_RCC_LSE_EnableCSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_EnableCSS(void)
Xstatic __inline void LL_RCC_LSE_EnableCSS(void)
N{
N  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Clock security system on LSE.
N  * @note Clock security system can be disabled only after a LSE
N  *       failure detection. In that case it MUST be disabled by software.
N  * @rmtoll BDCR         LSECSSON      LL_RCC_LSE_DisableCSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSE_DisableCSS(void)
Xstatic __inline void LL_RCC_LSE_DisableCSS(void)
N{
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Check if LSE oscillator Ready
N  * @rmtoll BDCR         LSERDY        LL_RCC_LSE_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
Xstatic __inline uint32_t LL_RCC_LSE_IsReady(void)
N{
N  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if CSS on LSE failure Detection
N  * @rmtoll BDCR         LSECSSD       LL_RCC_LSE_IsCSSDetected
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_LSE_IsCSSDetected(void)
Xstatic __inline uint32_t LL_RCC_LSE_IsCSSDetected(void)
N{
N  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSECSSD) == (RCC_BDCR_LSECSSD));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_LSI LSI
N  * @{
N  */
N
N/**
N  * @brief  Enable LSI Oscillator
N  * @rmtoll CSR          LSION         LL_RCC_LSI_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSI_Enable(void)
Xstatic __inline void LL_RCC_LSI_Enable(void)
N{
N  SET_BIT(RCC->CSR, RCC_CSR_LSION);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable LSI Oscillator
N  * @rmtoll CSR          LSION         LL_RCC_LSI_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSI_Disable(void)
Xstatic __inline void LL_RCC_LSI_Disable(void)
N{
N  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if LSI is Ready
N  * @rmtoll CSR          LSIRDY        LL_RCC_LSI_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
Xstatic __inline uint32_t LL_RCC_LSI_IsReady(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_MSI MSI
N  * @{
N  */
N
N/**
N  * @brief  Enable MSI oscillator
N  * @rmtoll CR           MSION         LL_RCC_MSI_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_Enable(void)
Xstatic __inline void LL_RCC_MSI_Enable(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_MSION);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable MSI oscillator
N  * @rmtoll CR           MSION         LL_RCC_MSI_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_Disable(void)
Xstatic __inline void LL_RCC_MSI_Disable(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if MSI oscillator Ready
N  * @rmtoll CR           MSIRDY        LL_RCC_MSI_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
Xstatic __inline uint32_t LL_RCC_MSI_IsReady(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable MSI PLL-mode (Hardware auto calibration with LSE)
N  * @note MSIPLLEN must be enabled after LSE is enabled (LSEON enabled)
N  *       and ready (LSERDY set by hardware)
N  * @note hardware protection to avoid enabling MSIPLLEN if LSE is not
N  *       ready
N  * @rmtoll CR           MSIPLLEN      LL_RCC_MSI_EnablePLLMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_EnablePLLMode(void)
Xstatic __inline void LL_RCC_MSI_EnablePLLMode(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable MSI-PLL mode
N  * @note cleared by hardware when LSE is disabled (LSEON = 0) or when
N  *       the Clock Security System on LSE detects a LSE failure
N  * @rmtoll CR           MSIPLLEN      LL_RCC_MSI_DisablePLLMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_DisablePLLMode(void)
Xstatic __inline void LL_RCC_MSI_DisablePLLMode(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable MSI clock range selection with MSIRANGE register
N  * @note Write 0 has no effect. After a standby or a reset
N  *       MSIRGSEL is at 0 and the MSI range value is provided by
N  *       MSISRANGE
N  * @rmtoll CR           MSIRGSEL      LL_RCC_MSI_EnableRangeSelection
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_EnableRangeSelection(void)
Xstatic __inline void LL_RCC_MSI_EnableRangeSelection(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_MSIRGSEL);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if MSI clock range is selected with MSIRANGE register
N  * @rmtoll CR           MSIRGSEL      LL_RCC_MSI_IsEnabledRangeSelect
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_MSI_IsEnabledRangeSelect(void)
Xstatic __inline uint32_t LL_RCC_MSI_IsEnabledRangeSelect(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Configure the Internal Multi Speed oscillator (MSI) clock range in run mode.
N  * @rmtoll CR           MSIRANGE      LL_RCC_MSI_SetRange
N  * @param  Range This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_MSIRANGE_0
N  *         @arg @ref LL_RCC_MSIRANGE_1
N  *         @arg @ref LL_RCC_MSIRANGE_2
N  *         @arg @ref LL_RCC_MSIRANGE_3
N  *         @arg @ref LL_RCC_MSIRANGE_4
N  *         @arg @ref LL_RCC_MSIRANGE_5
N  *         @arg @ref LL_RCC_MSIRANGE_6
N  *         @arg @ref LL_RCC_MSIRANGE_7
N  *         @arg @ref LL_RCC_MSIRANGE_8
N  *         @arg @ref LL_RCC_MSIRANGE_9
N  *         @arg @ref LL_RCC_MSIRANGE_10
N  *         @arg @ref LL_RCC_MSIRANGE_11
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_SetRange(uint32_t Range)
Xstatic __inline void LL_RCC_MSI_SetRange(uint32_t Range)
N{
N  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR))) & (~((0xFUL << (4U))))) | (Range))));
N}
N
N/**
N  * @brief  Get the Internal Multi Speed oscillator (MSI) clock range in run mode.
N  * @rmtoll CR           MSIRANGE      LL_RCC_MSI_GetRange
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_MSIRANGE_0
N  *         @arg @ref LL_RCC_MSIRANGE_1
N  *         @arg @ref LL_RCC_MSIRANGE_2
N  *         @arg @ref LL_RCC_MSIRANGE_3
N  *         @arg @ref LL_RCC_MSIRANGE_4
N  *         @arg @ref LL_RCC_MSIRANGE_5
N  *         @arg @ref LL_RCC_MSIRANGE_6
N  *         @arg @ref LL_RCC_MSIRANGE_7
N  *         @arg @ref LL_RCC_MSIRANGE_8
N  *         @arg @ref LL_RCC_MSIRANGE_9
N  *         @arg @ref LL_RCC_MSIRANGE_10
N  *         @arg @ref LL_RCC_MSIRANGE_11
N  */
N__STATIC_INLINE uint32_t LL_RCC_MSI_GetRange(void)
Xstatic __inline uint32_t LL_RCC_MSI_GetRange(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0xFUL << (4U)))));
N}
N
N/**
N  * @brief  Configure MSI range used after standby
N  * @rmtoll CSR          MSISRANGE     LL_RCC_MSI_SetRangeAfterStandby
N  * @param  Range This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_MSISRANGE_4
N  *         @arg @ref LL_RCC_MSISRANGE_5
N  *         @arg @ref LL_RCC_MSISRANGE_6
N  *         @arg @ref LL_RCC_MSISRANGE_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_SetRangeAfterStandby(uint32_t Range)
Xstatic __inline void LL_RCC_MSI_SetRangeAfterStandby(uint32_t Range)
N{
N  MODIFY_REG(RCC->CSR, RCC_CSR_MSISRANGE, Range);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR))) & (~((0xFUL << (8U))))) | (Range))));
N}
N
N/**
N  * @brief  Get MSI range used after standby
N  * @rmtoll CSR          MSISRANGE     LL_RCC_MSI_GetRangeAfterStandby
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_MSISRANGE_4
N  *         @arg @ref LL_RCC_MSISRANGE_5
N  *         @arg @ref LL_RCC_MSISRANGE_6
N  *         @arg @ref LL_RCC_MSISRANGE_7
N  */
N__STATIC_INLINE uint32_t LL_RCC_MSI_GetRangeAfterStandby(void)
Xstatic __inline uint32_t LL_RCC_MSI_GetRangeAfterStandby(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0xFUL << (8U)))));
N}
N
N/**
N  * @brief  Get MSI Calibration value
N  * @note When MSITRIM is written, MSICAL is updated with the sum of
N  *       MSITRIM and the factory trim value
N  * @rmtoll ICSCR        MSICAL        LL_RCC_MSI_GetCalibration
N  * @retval Between Min_Data = 0 and Max_Data = 255
N  */
N__STATIC_INLINE uint32_t LL_RCC_MSI_GetCalibration(void)
Xstatic __inline uint32_t LL_RCC_MSI_GetCalibration(void)
N{
N  return (uint32_t)(READ_BIT(RCC->ICSCR, RCC_ICSCR_MSICAL) >> RCC_ICSCR_MSICAL_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR) & ((0xFFUL << (0U)))) >> (0U));
N}
N
N/**
N  * @brief  Set MSI Calibration trimming
N  * @note user-programmable trimming value that is added to the MSICAL
N  * @rmtoll ICSCR        MSITRIM       LL_RCC_MSI_SetCalibTrimming
N  * @param  Value Between Min_Data = 0 and Max_Data = 255
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
Xstatic __inline void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
N{
N  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR))) & (~((0xFFUL << (8U))))) | (Value << (8U)))));
N}
N
N/**
N  * @brief  Get MSI Calibration trimming
N  * @rmtoll ICSCR        MSITRIM       LL_RCC_MSI_GetCalibTrimming
N  * @retval Between 0 and 255
N  */
N__STATIC_INLINE uint32_t LL_RCC_MSI_GetCalibTrimming(void)
Xstatic __inline uint32_t LL_RCC_MSI_GetCalibTrimming(void)
N{
N  return (uint32_t)(READ_BIT(RCC->ICSCR, RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->ICSCR) & ((0xFFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_LSCO LSCO
N  * @{
N  */
N
N/**
N  * @brief  Enable Low speed clock
N  * @rmtoll BDCR         LSCOEN        LL_RCC_LSCO_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSCO_Enable(void)
Xstatic __inline void LL_RCC_LSCO_Enable(void)
N{
N  SET_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable Low speed clock
N  * @rmtoll BDCR         LSCOEN        LL_RCC_LSCO_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSCO_Disable(void)
Xstatic __inline void LL_RCC_LSCO_Disable(void)
N{
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Configure Low speed clock selection
N  * @rmtoll BDCR         LSCOSEL       LL_RCC_LSCO_SetSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_LSE
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_LSCO_SetSource(uint32_t Source)
Xstatic __inline void LL_RCC_LSCO_SetSource(uint32_t Source)
N{
N  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL, Source);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR))) & (~((0x1UL << (25U))))) | (Source))));
N}
N
N/**
N  * @brief  Get Low speed clock selection
N  * @rmtoll BDCR         LSCOSEL       LL_RCC_LSCO_GetSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_LSE
N  */
N__STATIC_INLINE uint32_t LL_RCC_LSCO_GetSource(void)
Xstatic __inline uint32_t LL_RCC_LSCO_GetSource(void)
N{
N  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_LSCOSEL));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) & ((0x1UL << (25U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_System System
N  * @{
N  */
N
N/**
N  * @brief  Configure the system clock source
N  * @rmtoll CFGR         SW            LL_RCC_SetSysClkSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_MSI
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_HSE
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_PLL
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
Xstatic __inline void LL_RCC_SetSysClkSource(uint32_t Source)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR))) & (~((0x3UL << (0U))))) | (Source))));
N}
N
N/**
N  * @brief  Get the system clock source
N  * @rmtoll CFGR         SWS           LL_RCC_GetSysClkSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
N  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
Xstatic __inline uint32_t LL_RCC_GetSysClkSource(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR) & ((0x3UL << (2U)))));
N}
N
N/**
N  * @brief  Set AHB prescaler
N  * @rmtoll CFGR         HPRE          LL_RCC_SetAHBPrescaler
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SYSCLK_DIV_1
N  *         @arg @ref LL_RCC_SYSCLK_DIV_2
N  *         @arg @ref LL_RCC_SYSCLK_DIV_4
N  *         @arg @ref LL_RCC_SYSCLK_DIV_8
N  *         @arg @ref LL_RCC_SYSCLK_DIV_16
N  *         @arg @ref LL_RCC_SYSCLK_DIV_64
N  *         @arg @ref LL_RCC_SYSCLK_DIV_128
N  *         @arg @ref LL_RCC_SYSCLK_DIV_256
N  *         @arg @ref LL_RCC_SYSCLK_DIV_512
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
Xstatic __inline void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR))) & (~((0xFUL << (4U))))) | (Prescaler))));
N}
N
N/**
N  * @brief  Set APB1 prescaler
N  * @rmtoll CFGR         PPRE1         LL_RCC_SetAPB1Prescaler
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_APB1_DIV_1
N  *         @arg @ref LL_RCC_APB1_DIV_2
N  *         @arg @ref LL_RCC_APB1_DIV_4
N  *         @arg @ref LL_RCC_APB1_DIV_8
N  *         @arg @ref LL_RCC_APB1_DIV_16
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
Xstatic __inline void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR))) & (~((0x7UL << (8U))))) | (Prescaler))));
N}
N
N/**
N  * @brief  Set APB2 prescaler
N  * @rmtoll CFGR         PPRE2         LL_RCC_SetAPB2Prescaler
N  * @param  Prescaler This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_APB2_DIV_1
N  *         @arg @ref LL_RCC_APB2_DIV_2
N  *         @arg @ref LL_RCC_APB2_DIV_4
N  *         @arg @ref LL_RCC_APB2_DIV_8
N  *         @arg @ref LL_RCC_APB2_DIV_16
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
Xstatic __inline void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR))) & (~((0x7UL << (11U))))) | (Prescaler))));
N}
N
N/**
N  * @brief  Get AHB prescaler
N  * @rmtoll CFGR         HPRE          LL_RCC_GetAHBPrescaler
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_SYSCLK_DIV_1
N  *         @arg @ref LL_RCC_SYSCLK_DIV_2
N  *         @arg @ref LL_RCC_SYSCLK_DIV_4
N  *         @arg @ref LL_RCC_SYSCLK_DIV_8
N  *         @arg @ref LL_RCC_SYSCLK_DIV_16
N  *         @arg @ref LL_RCC_SYSCLK_DIV_64
N  *         @arg @ref LL_RCC_SYSCLK_DIV_128
N  *         @arg @ref LL_RCC_SYSCLK_DIV_256
N  *         @arg @ref LL_RCC_SYSCLK_DIV_512
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
Xstatic __inline uint32_t LL_RCC_GetAHBPrescaler(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR) & ((0xFUL << (4U)))));
N}
N
N/**
N  * @brief  Get APB1 prescaler
N  * @rmtoll CFGR         PPRE1         LL_RCC_GetAPB1Prescaler
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_APB1_DIV_1
N  *         @arg @ref LL_RCC_APB1_DIV_2
N  *         @arg @ref LL_RCC_APB1_DIV_4
N  *         @arg @ref LL_RCC_APB1_DIV_8
N  *         @arg @ref LL_RCC_APB1_DIV_16
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
Xstatic __inline uint32_t LL_RCC_GetAPB1Prescaler(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR) & ((0x7UL << (8U)))));
N}
N
N/**
N  * @brief  Get APB2 prescaler
N  * @rmtoll CFGR         PPRE2         LL_RCC_GetAPB2Prescaler
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_APB2_DIV_1
N  *         @arg @ref LL_RCC_APB2_DIV_2
N  *         @arg @ref LL_RCC_APB2_DIV_4
N  *         @arg @ref LL_RCC_APB2_DIV_8
N  *         @arg @ref LL_RCC_APB2_DIV_16
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
Xstatic __inline uint32_t LL_RCC_GetAPB2Prescaler(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR) & ((0x7UL << (11U)))));
N}
N
N/**
N  * @brief  Set Clock After Wake-Up From Stop mode
N  * @rmtoll CFGR         STOPWUCK      LL_RCC_SetClkAfterWakeFromStop
N  * @param  Clock This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_MSI
N  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
Xstatic __inline void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR))) & (~((0x1UL << (15U))))) | (Clock))));
N}
N
N/**
N  * @brief  Get Clock After Wake-Up From Stop mode
N  * @rmtoll CFGR         STOPWUCK      LL_RCC_GetClkAfterWakeFromStop
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_MSI
N  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetClkAfterWakeFromStop(void)
Xstatic __inline uint32_t LL_RCC_GetClkAfterWakeFromStop(void)
N{
N  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_STOPWUCK));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR) & ((0x1UL << (15U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_MCO MCO
N  * @{
N  */
N
N/**
N  * @brief  Configure MCOx
N  * @rmtoll CFGR         MCOSEL        LL_RCC_ConfigMCO\n
N  *         CFGR         MCOPRE        LL_RCC_ConfigMCO
N  * @param  MCOxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_MCO1SOURCE_NOCLOCK
N  *         @arg @ref LL_RCC_MCO1SOURCE_SYSCLK
N  *         @arg @ref LL_RCC_MCO1SOURCE_MSI
N  *         @arg @ref LL_RCC_MCO1SOURCE_HSI
N  *         @arg @ref LL_RCC_MCO1SOURCE_HSE
N  *         @arg @ref LL_RCC_MCO1SOURCE_HSI48 (*)
N  *         @arg @ref LL_RCC_MCO1SOURCE_PLLCLK
N  *         @arg @ref LL_RCC_MCO1SOURCE_LSI
N  *         @arg @ref LL_RCC_MCO1SOURCE_LSE
N  *
N  *         (*) value not defined in all devices.
N  * @param  MCOxPrescaler This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_MCO1_DIV_1
N  *         @arg @ref LL_RCC_MCO1_DIV_2
N  *         @arg @ref LL_RCC_MCO1_DIV_4
N  *         @arg @ref LL_RCC_MCO1_DIV_8
N  *         @arg @ref LL_RCC_MCO1_DIV_16
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ConfigMCO(uint32_t MCOxSource, uint32_t MCOxPrescaler)
Xstatic __inline void LL_RCC_ConfigMCO(uint32_t MCOxSource, uint32_t MCOxPrescaler)
N{
N  MODIFY_REG(RCC->CFGR, RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE, MCOxSource | MCOxPrescaler);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CFGR))) & (~((0xFUL << (24U)) | (0x7UL << (28U))))) | (MCOxSource | MCOxPrescaler))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_Peripheral_Clock_Source Peripheral Clock Source
N  * @{
N  */
N
N/**
N  * @brief  Configure USARTx clock source
N  * @rmtoll CCIPR        USARTxSEL     LL_RCC_SetUSARTClockSource
N  * @param  USARTxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_PCLK2
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_PCLK1 (*)
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_SYSCLK (*)
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_HSI (*)
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_LSE (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetUSARTClockSource(uint32_t USARTxSource)
Xstatic __inline void LL_RCC_SetUSARTClockSource(uint32_t USARTxSource)
N{
N  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFF));
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((USARTxSource >> 16)))) | ((USARTxSource & 0x0000FFFF)))));
N}
N
N#if defined(UART4) || defined(UART5)
X#if 0L || 0L
S/**
S  * @brief  Configure UARTx clock source
S  * @rmtoll CCIPR        UARTxSEL      LL_RCC_SetUARTClockSource
S  * @param  UARTxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_PCLK1
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_SYSCLK
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_HSI
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_LSE
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_PCLK1
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_SYSCLK
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_HSI
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_LSE
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetUARTClockSource(uint32_t UARTxSource)
S{
S  MODIFY_REG(RCC->CCIPR, (UARTxSource >> 16), (UARTxSource & 0x0000FFFF));
S}
N#endif /* UART4 || UART5 */
N
N/**
N  * @brief  Configure LPUART1x clock source
N  * @rmtoll CCIPR        LPUART1SEL    LL_RCC_SetLPUARTClockSource
N  * @param  LPUARTxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_LSE
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetLPUARTClockSource(uint32_t LPUARTxSource)
Xstatic __inline void LL_RCC_SetLPUARTClockSource(uint32_t LPUARTxSource)
N{
N  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((0x3UL << (10U))))) | (LPUARTxSource))));
N}
N
N/**
N  * @brief  Configure I2Cx clock source
N  * @rmtoll CCIPR        I2CxSEL       LL_RCC_SetI2CClockSource
N  * @param  I2CxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE_PCLK1 (*)
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE_SYSCLK (*)
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE_HSI (*)
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_PCLK1 (*)
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_SYSCLK (*)
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_HSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetI2CClockSource(uint32_t I2CxSource)
Xstatic __inline void LL_RCC_SetI2CClockSource(uint32_t I2CxSource)
N{
N  __IO uint32_t *reg = (__IO uint32_t *)(uint32_t)(RCC_BASE + 0x88U + (I2CxSource >> 24U));
X  volatile uint32_t *reg = (volatile uint32_t *)(uint32_t)((((0x40000000UL) + 0x00020000UL) + 0x1000UL) + 0x88U + (I2CxSource >> 24U));
N  MODIFY_REG(*reg, 3U << ((I2CxSource & 0x00FF0000U) >> 16U), ((I2CxSource & 0x000000FFU) << ((I2CxSource & 0x00FF0000U) >> 16U)));
X  (((*reg)) = ((((((*reg))) & (~(3U << ((I2CxSource & 0x00FF0000U) >> 16U)))) | (((I2CxSource & 0x000000FFU) << ((I2CxSource & 0x00FF0000U) >> 16U))))));
N}
N
N/**
N  * @brief  Configure LPTIMx clock source
N  * @rmtoll CCIPR        LPTIMxSEL     LL_RCC_SetLPTIMClockSource
N  * @param  LPTIMxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_LSE
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetLPTIMClockSource(uint32_t LPTIMxSource)
Xstatic __inline void LL_RCC_SetLPTIMClockSource(uint32_t LPTIMxSource)
N{
N  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16U));
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((LPTIMxSource & 0xFFFF0000U)))) | ((LPTIMxSource << 16U)))));
N}
N
N/**
N  * @brief  Configure SAIx clock source
N  @if STM32L4S9xx
N  * @rmtoll CCIPR2       SAIxSEL       LL_RCC_SetSAIClockSource
N  @else
N  * @rmtoll CCIPR        SAIxSEL       LL_RCC_SetSAIClockSource
N  @endif
N  * @param  SAIxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PLLSAI1
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PLLSAI2 (*)
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PLL
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PIN
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PLLSAI1 (*)
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PLLSAI2 (*)
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PLL (*)
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PIN (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetSAIClockSource(uint32_t SAIxSource)
Xstatic __inline void LL_RCC_SetSAIClockSource(uint32_t SAIxSource)
N{
N#if defined(RCC_CCIPR2_SAI1SEL)
X#if 0L
S  MODIFY_REG(RCC->CCIPR2, (SAIxSource >> 16U), (SAIxSource & 0x0000FFFFU));
N#else
N  MODIFY_REG(RCC->CCIPR, (SAIxSource & 0xFFFF0000U), (SAIxSource << 16U));
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((SAIxSource & 0xFFFF0000U)))) | ((SAIxSource << 16U)))));
N#endif /* RCC_CCIPR2_SAI1SEL */
N}
N
N#if defined(RCC_CCIPR2_SDMMCSEL)
X#if 0L
S/**
S  * @brief  Configure SDMMC1 kernel clock source
S  * @rmtoll CCIPR2       SDMMCSEL      LL_RCC_SetSDMMCKernelClockSource
S  * @param  SDMMCxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_SDMMC1_KERNELCLKSOURCE_48CLK (*)
S  *         @arg @ref LL_RCC_SDMMC1_KERNELCLKSOURCE_PLLP (*)
S  *
S  *         (*) value not defined in all devices.
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetSDMMCKernelClockSource(uint32_t SDMMCxSource)
S{
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_SDMMCSEL, SDMMCxSource);
S}
N#endif /* RCC_CCIPR2_SDMMCSEL */
N
N/**
N  * @brief  Configure SDMMC1 clock source
N  * @rmtoll CCIPR        CLK48SEL      LL_RCC_SetSDMMCClockSource
N  * @param  SDMMCxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_NONE (*)
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_HSI48 (*)
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_PLLSAI1 (*)
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_PLL
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_MSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetSDMMCClockSource(uint32_t SDMMCxSource)
Xstatic __inline void LL_RCC_SetSDMMCClockSource(uint32_t SDMMCxSource)
N{
N  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, SDMMCxSource);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((0x3UL << (26U))))) | (SDMMCxSource))));
N}
N
N/**
N  * @brief  Configure RNG clock source
N  * @rmtoll CCIPR        CLK48SEL      LL_RCC_SetRNGClockSource
N  * @param  RNGxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_NONE (*)
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_HSI48 (*)
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_PLLSAI1
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_PLL
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_MSI
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetRNGClockSource(uint32_t RNGxSource)
Xstatic __inline void LL_RCC_SetRNGClockSource(uint32_t RNGxSource)
N{
N  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, RNGxSource);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((0x3UL << (26U))))) | (RNGxSource))));
N}
N
N#if defined(USB_OTG_FS) || defined(USB)
X#if 0L || 0L
S/**
S  * @brief  Configure USB clock source
S  * @rmtoll CCIPR        CLK48SEL      LL_RCC_SetUSBClockSource
S  * @param  USBxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_NONE (*)
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_HSI48 (*)
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_PLLSAI1
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_PLL
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_MSI
S  *
S  *         (*) value not defined in all devices.
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetUSBClockSource(uint32_t USBxSource)
S{
S  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, USBxSource);
S}
N#endif /* USB_OTG_FS || USB */
N
N/**
N  * @brief  Configure ADC clock source
N  * @rmtoll CCIPR        ADCSEL        LL_RCC_SetADCClockSource
N  * @param  ADCxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_NONE
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_PLLSAI1
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_PLLSAI2 (*)
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_SYSCLK
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetADCClockSource(uint32_t ADCxSource)
Xstatic __inline void LL_RCC_SetADCClockSource(uint32_t ADCxSource)
N{
N  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((0x3UL << (28U))))) | (ADCxSource))));
N}
N
N#if defined(SWPMI1)
X#if 1L
N/**
N  * @brief  Configure SWPMI clock source
N  * @rmtoll CCIPR        SWPMI1SEL     LL_RCC_SetSWPMIClockSource
N  * @param  SWPMIxSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SWPMI1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_SWPMI1_CLKSOURCE_HSI
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetSWPMIClockSource(uint32_t SWPMIxSource)
Xstatic __inline void LL_RCC_SetSWPMIClockSource(uint32_t SWPMIxSource)
N{
N  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SWPMI1SEL, SWPMIxSource);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR))) & (~((0x1UL << (30U))))) | (SWPMIxSource))));
N}
N#endif /* SWPMI1 */
N
N#if defined(DFSDM1_Channel0)
X#if 0L
S#if defined(RCC_CCIPR2_ADFSDM1SEL)
S/**
S  * @brief  Configure DFSDM Audio clock source
S  * @rmtoll CCIPR2        ADFSDM1SEL        LL_RCC_SetDFSDMAudioClockSource
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE_SAI1
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE_HSI
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE_MSI
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetDFSDMAudioClockSource(uint32_t Source)
S{
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ADFSDM1SEL, Source);
S}
S#endif /* RCC_CCIPR2_ADFSDM1SEL */
S
S/**
S  * @brief  Configure DFSDM Kernel clock source
S  @if STM32L4S9xx
S  * @rmtoll CCIPR2       DFSDM1SEL     LL_RCC_SetDFSDMClockSource
S  @else
S  * @rmtoll CCIPR        DFSDM1SEL     LL_RCC_SetDFSDMClockSource
S  @endif
S  * @param  DFSDMxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE_PCLK2
S  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE_SYSCLK
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetDFSDMClockSource(uint32_t DFSDMxSource)
S{
S#if defined(RCC_CCIPR2_DFSDM1SEL)
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_DFSDM1SEL, DFSDMxSource);
S#else
S  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_DFSDM1SEL, DFSDMxSource);
S#endif /* RCC_CCIPR2_DFSDM1SEL */
S}
N#endif /* DFSDM1_Channel0 */
N
N#if defined(DSI)
X#if 0L
S/**
S  * @brief  Configure DSI clock source
S  * @rmtoll CCIPR2         DSISEL        LL_RCC_SetDSIClockSource
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DSI_CLKSOURCE_PHY
S  *         @arg @ref LL_RCC_DSI_CLKSOURCE_PLL
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetDSIClockSource(uint32_t Source)
S{
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_DSISEL, Source);
S}
N#endif /* DSI */
N
N#if defined(LTDC)
X#if 0L
S/**
S  * @brief  Configure LTDC Clock Source
S  * @rmtoll CCIPR2         PLLSAI2DIVR        LL_RCC_SetLTDCClockSource
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV2
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV4
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV8
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV16
S  * @retval None
S */
S__STATIC_INLINE void LL_RCC_SetLTDCClockSource(uint32_t Source)
S{
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_PLLSAI2DIVR, Source);
S}
N#endif /* LTDC */
N
N#if defined(OCTOSPI1)
X#if 0L
S/**
S  * @brief  Configure OCTOSPI clock source
S  * @rmtoll CCIPR2         OSPISEL        LL_RCC_SetOCTOSPIClockSource
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE_SYSCLK
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE_MSI
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE_PLL
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_SetOCTOSPIClockSource(uint32_t Source)
S{
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_OSPISEL, Source);
S}
N#endif /* OCTOSPI1 */
N
N/**
N  * @brief  Get USARTx clock source
N  * @rmtoll CCIPR        USARTxSEL     LL_RCC_GetUSARTClockSource
N  * @param  USARTx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_PCLK2
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_USART1_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_USART2_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_PCLK1 (*)
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_SYSCLK (*)
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_HSI (*)
N  *         @arg @ref LL_RCC_USART3_CLKSOURCE_LSE (*)
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetUSARTClockSource(uint32_t USARTx)
Xstatic __inline uint32_t LL_RCC_GetUSARTClockSource(uint32_t USARTx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16U));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (USARTx)) | (USARTx << 16U));
N}
N
N#if defined(UART4) || defined(UART5)
X#if 0L || 0L
S/**
S  * @brief  Get UARTx clock source
S  * @rmtoll CCIPR        UARTxSEL      LL_RCC_GetUARTClockSource
S  * @param  UARTx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_PCLK1
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_SYSCLK
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_HSI
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE_LSE
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_PCLK1
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_SYSCLK
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_HSI
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE_LSE
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetUARTClockSource(uint32_t UARTx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR, UARTx) | (UARTx << 16U));
S}
N#endif /* UART4 || UART5 */
N
N/**
N  * @brief  Get LPUARTx clock source
N  * @rmtoll CCIPR        LPUART1SEL    LL_RCC_GetLPUARTClockSource
N  * @param  LPUARTx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_LSE
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetLPUARTClockSource(uint32_t LPUARTx)
Xstatic __inline uint32_t LL_RCC_GetLPUARTClockSource(uint32_t LPUARTx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (LPUARTx)));
N}
N
N/**
N  * @brief  Get I2Cx clock source
N  * @rmtoll CCIPR        I2CxSEL       LL_RCC_GetI2CClockSource
N  * @param  I2Cx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE (*)
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_I2C1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE_PCLK1 (*)
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE_SYSCLK (*)
N  *         @arg @ref LL_RCC_I2C2_CLKSOURCE_HSI (*)
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE_SYSCLK
N  *         @arg @ref LL_RCC_I2C3_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_PCLK1 (*)
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_SYSCLK (*)
N  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_HSI (*)
N  *
N  *         (*) value not defined in all devices.
N */
N__STATIC_INLINE uint32_t LL_RCC_GetI2CClockSource(uint32_t I2Cx)
Xstatic __inline uint32_t LL_RCC_GetI2CClockSource(uint32_t I2Cx)
N{
N  __IO uint32_t *reg = (__IO uint32_t *)(uint32_t)(RCC_BASE + 0x88U + (I2Cx >> 24U));
X  volatile uint32_t *reg = (volatile uint32_t *)(uint32_t)((((0x40000000UL) + 0x00020000UL) + 0x1000UL) + 0x88U + (I2Cx >> 24U));
N  return (uint32_t)((READ_BIT(*reg, 3U << ((I2Cx & 0x00FF0000U) >> 16U)) >> ((I2Cx & 0x00FF0000U) >> 16U)) | (I2Cx & 0xFFFF0000U));
X  return (uint32_t)((((*reg) & (3U << ((I2Cx & 0x00FF0000U) >> 16U))) >> ((I2Cx & 0x00FF0000U) >> 16U)) | (I2Cx & 0xFFFF0000U));
N}
N
N/**
N  * @brief  Get LPTIMx clock source
N  * @rmtoll CCIPR        LPTIMxSEL     LL_RCC_GetLPTIMClockSource
N  * @param  LPTIMx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_HSI
N  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE_LSE
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetLPTIMClockSource(uint32_t LPTIMx)
Xstatic __inline uint32_t LL_RCC_GetLPTIMClockSource(uint32_t LPTIMx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, LPTIMx) >> 16U | LPTIMx);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (LPTIMx)) >> 16U | LPTIMx);
N}
N
N/**
N  * @brief  Get SAIx clock source
N  @if STM32L4S9xx
N  * @rmtoll CCIPR2       SAIxSEL       LL_RCC_GetSAIClockSource
N  @else
N  * @rmtoll CCIPR        SAIxSEL       LL_RCC_GetSAIClockSource
N  @endif
N  * @param  SAIx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PLLSAI1
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PLLSAI2 (*)
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PLL
N  *         @arg @ref LL_RCC_SAI1_CLKSOURCE_PIN
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PLLSAI1 (*)
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PLLSAI2 (*)
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PLL (*)
N  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_PIN (*)
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetSAIClockSource(uint32_t SAIx)
Xstatic __inline uint32_t LL_RCC_GetSAIClockSource(uint32_t SAIx)
N{
N#if defined(RCC_CCIPR2_SAI1SEL)
X#if 0L
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, SAIx) | (SAIx << 16U));
N#else
N  return (uint32_t)(READ_BIT(RCC->CCIPR, SAIx) >> 16U | SAIx);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (SAIx)) >> 16U | SAIx);
N#endif /* RCC_CCIPR2_SAI1SEL */
N}
N
N#if defined(RCC_CCIPR2_SDMMCSEL)
X#if 0L
S/**
S  * @brief  Get SDMMCx kernel clock source
S  * @rmtoll CCIPR2       SDMMCSEL      LL_RCC_GetSDMMCKernelClockSource
S  * @param  SDMMCx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_SDMMC1_KERNELCLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_SDMMC1_KERNELCLKSOURCE_48CLK (*)
S  *         @arg @ref LL_RCC_SDMMC1_KERNELCLKSOURCE_PLL (*)
S  *
S  *         (*) value not defined in all devices.
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetSDMMCKernelClockSource(uint32_t SDMMCx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, SDMMCx));
S}
N#endif /* RCC_CCIPR2_SDMMCSEL */
N
N/**
N  * @brief  Get SDMMCx clock source
N  * @rmtoll CCIPR        CLK48SEL      LL_RCC_GetSDMMCClockSource
N  * @param  SDMMCx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_NONE (*)
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_HSI48 (*)
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_PLLSAI1 (*)
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_PLL
N  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE_MSI (*)
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetSDMMCClockSource(uint32_t SDMMCx)
Xstatic __inline uint32_t LL_RCC_GetSDMMCClockSource(uint32_t SDMMCx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, SDMMCx));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (SDMMCx)));
N}
N
N/**
N  * @brief  Get RNGx clock source
N  * @rmtoll CCIPR        CLK48SEL      LL_RCC_GetRNGClockSource
N  * @param  RNGx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_NONE (*)
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_HSI48 (*)
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_PLLSAI1
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_PLL
N  *         @arg @ref LL_RCC_RNG_CLKSOURCE_MSI
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetRNGClockSource(uint32_t RNGx)
Xstatic __inline uint32_t LL_RCC_GetRNGClockSource(uint32_t RNGx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, RNGx));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (RNGx)));
N}
N
N#if defined(USB_OTG_FS) || defined(USB)
X#if 0L || 0L
S/**
S  * @brief  Get USBx clock source
S  * @rmtoll CCIPR        CLK48SEL      LL_RCC_GetUSBClockSource
S  * @param  USBx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_USB_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_NONE (*)
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_HSI48 (*)
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_PLLSAI1
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_PLL
S  *         @arg @ref LL_RCC_USB_CLKSOURCE_MSI
S  *
S  *         (*) value not defined in all devices.
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetUSBClockSource(uint32_t USBx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR, USBx));
S}
N#endif /* USB_OTG_FS || USB */
N
N/**
N  * @brief  Get ADCx clock source
N  * @rmtoll CCIPR        ADCSEL        LL_RCC_GetADCClockSource
N  * @param  ADCx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_NONE
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_PLLSAI1
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_PLLSAI2 (*)
N  *         @arg @ref LL_RCC_ADC_CLKSOURCE_SYSCLK
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetADCClockSource(uint32_t ADCx)
Xstatic __inline uint32_t LL_RCC_GetADCClockSource(uint32_t ADCx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, ADCx));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (ADCx)));
N}
N
N#if defined(SWPMI1)
X#if 1L
N/**
N  * @brief  Get SWPMIx clock source
N  * @rmtoll CCIPR        SWPMI1SEL     LL_RCC_GetSWPMIClockSource
N  * @param  SPWMIx This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_SWPMI1_CLKSOURCE
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_SWPMI1_CLKSOURCE_PCLK1
N  *         @arg @ref LL_RCC_SWPMI1_CLKSOURCE_HSI
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetSWPMIClockSource(uint32_t SPWMIx)
Xstatic __inline uint32_t LL_RCC_GetSWPMIClockSource(uint32_t SPWMIx)
N{
N  return (uint32_t)(READ_BIT(RCC->CCIPR, SPWMIx));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CCIPR) & (SPWMIx)));
N}
N#endif /* SWPMI1 */
N
N#if defined(DFSDM1_Channel0)
X#if 0L
S#if defined(RCC_CCIPR2_ADFSDM1SEL)
S/**
S  * @brief  Get DFSDM Audio Clock Source
S  * @rmtoll CCIPR2         ADFSDM1SEL        LL_RCC_GetDFSDMAudioClockSource
S  * @param  DFSDMx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE_SAI1
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE_HSI
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE_MSI
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetDFSDMAudioClockSource(uint32_t DFSDMx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, DFSDMx));
S}
S#endif /* RCC_CCIPR2_ADFSDM1SEL */
S
S/**
S  * @brief  Get DFSDMx Kernel clock source
S  @if STM32L4S9xx
S  * @rmtoll CCIPR2       DFSDM1SEL     LL_RCC_GetDFSDMClockSource
S  @else
S  * @rmtoll CCIPR        DFSDM1SEL     LL_RCC_GetDFSDMClockSource
S  @endif
S  * @param  DFSDMx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE_PCLK2
S  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE_SYSCLK
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetDFSDMClockSource(uint32_t DFSDMx)
S{
S#if defined(RCC_CCIPR2_DFSDM1SEL)
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, DFSDMx));
S#else
S  return (uint32_t)(READ_BIT(RCC->CCIPR, DFSDMx));
S#endif /* RCC_CCIPR2_DFSDM1SEL */
S}
N#endif /* DFSDM1_Channel0 */
N
N#if defined(DSI)
X#if 0L
S/**
S  * @brief  Get DSI Clock Source
S  * @rmtoll CCIPR2         DSISEL        LL_RCC_GetDSIClockSource
S  * @param  DSIx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DSI_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_DSI_CLKSOURCE_PHY
S  *         @arg @ref LL_RCC_DSI_CLKSOURCE_PLL
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetDSIClockSource(uint32_t DSIx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, DSIx));
S}
N#endif /* DSI */
N
N#if defined(LTDC)
X#if 0L
S/**
S  * @brief  Get LTDC Clock Source
S  * @rmtoll CCIPR2         PLLSAI2DIVR        LL_RCC_GetLTDCClockSource
S  * @param  LTDCx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV2
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV4
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV8
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_PLLSAI2R_DIV16
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetLTDCClockSource(uint32_t LTDCx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, LTDCx));
S}
N#endif /* LTDC */
N
N#if defined(OCTOSPI1)
X#if 0L
S/**
S  * @brief  Get OCTOSPI clock source
S  * @rmtoll CCIPR2         OSPISEL        LL_RCC_GetOCTOSPIClockSource
S  * @param  OCTOSPIx This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE_SYSCLK
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE_MSI
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE_PLL
S  */
S__STATIC_INLINE uint32_t LL_RCC_GetOCTOSPIClockSource(uint32_t OCTOSPIx)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, OCTOSPIx));
S}
N#endif /* OCTOSPI1 */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_RTC RTC
N  * @{
N  */
N
N/**
N  * @brief  Set RTC Clock Source
N  * @note Once the RTC clock source has been selected, it cannot be changed anymore unless
N  *       the Backup domain is reset, or unless a failure is detected on LSE (LSECSSD is
N  *       set). The BDRST bit can be used to reset them.
N  * @rmtoll BDCR         RTCSEL        LL_RCC_SetRTCClockSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_NONE
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_HSE_DIV32
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_SetRTCClockSource(uint32_t Source)
Xstatic __inline void LL_RCC_SetRTCClockSource(uint32_t Source)
N{
N  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR))) & (~((0x3UL << (8U))))) | (Source))));
N}
N
N/**
N  * @brief  Get RTC Clock Source
N  * @rmtoll BDCR         RTCSEL        LL_RCC_GetRTCClockSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_NONE
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSE
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSI
N  *         @arg @ref LL_RCC_RTC_CLKSOURCE_HSE_DIV32
N  */
N__STATIC_INLINE uint32_t LL_RCC_GetRTCClockSource(void)
Xstatic __inline uint32_t LL_RCC_GetRTCClockSource(void)
N{
N  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Enable RTC
N  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableRTC(void)
Xstatic __inline void LL_RCC_EnableRTC(void)
N{
N  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable RTC
N  * @rmtoll BDCR         RTCEN         LL_RCC_DisableRTC
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableRTC(void)
Xstatic __inline void LL_RCC_DisableRTC(void)
N{
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if RTC has been enabled or not
N  * @rmtoll BDCR         RTCEN         LL_RCC_IsEnabledRTC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledRTC(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledRTC(void)
N{
N  return (READ_BIT(RCC->BDCR, RCC_BDCR_RTCEN) == (RCC_BDCR_RTCEN));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Force the Backup domain reset
N  * @rmtoll BDCR         BDRST         LL_RCC_ForceBackupDomainReset
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ForceBackupDomainReset(void)
Xstatic __inline void LL_RCC_ForceBackupDomainReset(void)
N{
N  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Release the Backup domain reset
N  * @rmtoll BDCR         BDRST         LL_RCC_ReleaseBackupDomainReset
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ReleaseBackupDomainReset(void)
Xstatic __inline void LL_RCC_ReleaseBackupDomainReset(void)
N{
N  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->BDCR) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @}
N  */
N
N
N/** @defgroup RCC_LL_EF_PLL PLL
N  * @{
N  */
N
N/**
N  * @brief  Enable PLL
N  * @rmtoll CR           PLLON         LL_RCC_PLL_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_Enable(void)
Xstatic __inline void LL_RCC_PLL_Enable(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_PLLON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable PLL
N  * @note Cannot be disabled if the PLL clock is used as the system clock
N  * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_Disable(void)
Xstatic __inline void LL_RCC_PLL_Disable(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Check if PLL Ready
N  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
Xstatic __inline uint32_t LL_RCC_PLL_IsReady(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Configure PLL used for SYSCLK Domain
N  * @note PLL Source and PLLM Divider can be written only when PLL,
N  *       PLLSAI1 and PLLSAI2 (*) are disabled.
N  * @note PLLN/PLLR can be written only when PLL is disabled.
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLL_ConfigDomain_SYS\n
N  *         PLLCFGR      PLLM          LL_RCC_PLL_ConfigDomain_SYS\n
N  *         PLLCFGR      PLLN          LL_RCC_PLL_ConfigDomain_SYS\n
N  *         PLLCFGR      PLLR          LL_RCC_PLL_ConfigDomain_SYS
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @param  PLLM This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @param  PLLN Between 8 and 86
N  * @param  PLLR This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLR_DIV_2
N  *         @arg @ref LL_RCC_PLLR_DIV_4
N  *         @arg @ref LL_RCC_PLLR_DIV_6
N  *         @arg @ref LL_RCC_PLLR_DIV_8
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
Xstatic __inline void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
N{
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLR,
N             Source | PLLM | PLLN << RCC_PLLCFGR_PLLN_Pos | PLLR);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U)) | (0x7UL << (4U)) | (0x7FUL << (8U)) | (0x3UL << (25U))))) | (Source | PLLM | PLLN << (8U) | PLLR))));
N}
N
N#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
X#if 1L
N/**
N  * @brief  Configure PLL used for SAI domain clock
N  * @note PLL Source and PLLM Divider can be written only when PLL,
N  *       PLLSAI1 and PLLSAI2 (*) are disabled.
N  * @note PLLN/PLLP can be written only when PLL is disabled.
N  * @note This  can be selected for SAI1 or SAI2 (*)
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLL_ConfigDomain_SAI\n
N  *         PLLCFGR      PLLM          LL_RCC_PLL_ConfigDomain_SAI\n
N  *         PLLCFGR      PLLN          LL_RCC_PLL_ConfigDomain_SAI\n
N  *         PLLCFGR      PLLPDIV       LL_RCC_PLL_ConfigDomain_SAI
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @param  PLLM This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @param  PLLN Between 8 and 86
N  * @param  PLLP This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLP_DIV_2
N  *         @arg @ref LL_RCC_PLLP_DIV_3
N  *         @arg @ref LL_RCC_PLLP_DIV_4
N  *         @arg @ref LL_RCC_PLLP_DIV_5
N  *         @arg @ref LL_RCC_PLLP_DIV_6
N  *         @arg @ref LL_RCC_PLLP_DIV_7
N  *         @arg @ref LL_RCC_PLLP_DIV_8
N  *         @arg @ref LL_RCC_PLLP_DIV_9
N  *         @arg @ref LL_RCC_PLLP_DIV_10
N  *         @arg @ref LL_RCC_PLLP_DIV_11
N  *         @arg @ref LL_RCC_PLLP_DIV_12
N  *         @arg @ref LL_RCC_PLLP_DIV_13
N  *         @arg @ref LL_RCC_PLLP_DIV_14
N  *         @arg @ref LL_RCC_PLLP_DIV_15
N  *         @arg @ref LL_RCC_PLLP_DIV_16
N  *         @arg @ref LL_RCC_PLLP_DIV_17
N  *         @arg @ref LL_RCC_PLLP_DIV_18
N  *         @arg @ref LL_RCC_PLLP_DIV_19
N  *         @arg @ref LL_RCC_PLLP_DIV_20
N  *         @arg @ref LL_RCC_PLLP_DIV_21
N  *         @arg @ref LL_RCC_PLLP_DIV_22
N  *         @arg @ref LL_RCC_PLLP_DIV_23
N  *         @arg @ref LL_RCC_PLLP_DIV_24
N  *         @arg @ref LL_RCC_PLLP_DIV_25
N  *         @arg @ref LL_RCC_PLLP_DIV_26
N  *         @arg @ref LL_RCC_PLLP_DIV_27
N  *         @arg @ref LL_RCC_PLLP_DIV_28
N  *         @arg @ref LL_RCC_PLLP_DIV_29
N  *         @arg @ref LL_RCC_PLLP_DIV_30
N  *         @arg @ref LL_RCC_PLLP_DIV_31
N  * @retval None
N  */
N#else
S/**
S  * @brief  Configure PLL used for SAI domain clock
S  * @note   PLL Source and PLLM Divider can be written only when PLL,
S  *         PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note   PLLN/PLLP can be written only when PLL is disabled.
S  * @note   This  can be selected for SAI1 or SAI2 (*)
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLL_ConfigDomain_SAI\n
S  *         PLLCFGR      PLLM          LL_RCC_PLL_ConfigDomain_SAI\n
S  *         PLLCFGR      PLLN          LL_RCC_PLL_ConfigDomain_SAI\n
S  *         PLLCFGR      PLLP          LL_RCC_PLL_ConfigDomain_SAI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  PLLN Between 8 and 86
S  * @param  PLLP This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLP_DIV_7
S  *         @arg @ref LL_RCC_PLLP_DIV_17
S  * @retval None
S  */
N#endif /* RCC_PLLP_DIV_2_31_SUPPORT */
N__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
Xstatic __inline void LL_RCC_PLL_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
N{
N#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
X#if 1L
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLPDIV,
N             Source | PLLM | PLLN << RCC_PLLCFGR_PLLN_Pos | PLLP);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U)) | (0x7UL << (4U)) | (0x7FUL << (8U)) | (0x1FUL << (27U))))) | (Source | PLLM | PLLN << (8U) | PLLP))));
N#else
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLP,
S             Source | PLLM | PLLN << RCC_PLLCFGR_PLLN_Pos | PLLP);
N#endif /* RCC_PLLP_DIV_2_31_SUPPORT */
N}
N
N/**
N  * @brief  Configure PLL used for 48Mhz domain clock
N  * @note PLL Source and PLLM Divider can be written only when PLL,
N  *       PLLSAI1 and PLLSAI2 (*) are disabled.
N  * @note PLLN/PLLQ can be written only when PLL is disabled.
N  * @note This  can be selected for USB, RNG, SDMMC
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLL_ConfigDomain_48M\n
N  *         PLLCFGR      PLLM          LL_RCC_PLL_ConfigDomain_48M\n
N  *         PLLCFGR      PLLN          LL_RCC_PLL_ConfigDomain_48M\n
N  *         PLLCFGR      PLLQ          LL_RCC_PLL_ConfigDomain_48M
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @param  PLLM This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @param  PLLN Between 8 and 86
N  * @param  PLLQ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLQ_DIV_2
N  *         @arg @ref LL_RCC_PLLQ_DIV_4
N  *         @arg @ref LL_RCC_PLLQ_DIV_6
N  *         @arg @ref LL_RCC_PLLQ_DIV_8
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_48M(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLQ)
Xstatic __inline void LL_RCC_PLL_ConfigDomain_48M(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLQ)
N{
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLQ,
N             Source | PLLM | PLLN << RCC_PLLCFGR_PLLN_Pos | PLLQ);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U)) | (0x7UL << (4U)) | (0x7FUL << (8U)) | (0x3UL << (21U))))) | (Source | PLLM | PLLN << (8U) | PLLQ))));
N}
N
N/**
N  * @brief  Configure PLL clock source
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLL_SetMainSource
N  * @param  PLLSource This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_SetMainSource(uint32_t PLLSource)
Xstatic __inline void LL_RCC_PLL_SetMainSource(uint32_t PLLSource)
N{
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSource);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U))))) | (PLLSource))));
N}
N
N/**
N  * @brief  Get the oscillator used as PLL clock source.
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLL_GetMainSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
Xstatic __inline uint32_t LL_RCC_PLL_GetMainSource(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) & ((0x3UL << (0U)))));
N}
N
N/**
N  * @brief  Get Main PLL multiplication factor for VCO
N  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
N  * @retval Between 8 and 86
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
Xstatic __inline uint32_t LL_RCC_PLL_GetN(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) & ((0x7FUL << (8U)))) >>  (8U));
N}
N
N#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
X#if 1L
N/**
N  * @brief  Get Main PLL division factor for PLLP
N  * @note Used for PLLSAI3CLK (SAI1 and SAI2 clock)
N  * @rmtoll PLLCFGR      PLLPDIV       LL_RCC_PLL_GetP
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLP_DIV_2
N  *         @arg @ref LL_RCC_PLLP_DIV_3
N  *         @arg @ref LL_RCC_PLLP_DIV_4
N  *         @arg @ref LL_RCC_PLLP_DIV_5
N  *         @arg @ref LL_RCC_PLLP_DIV_6
N  *         @arg @ref LL_RCC_PLLP_DIV_7
N  *         @arg @ref LL_RCC_PLLP_DIV_8
N  *         @arg @ref LL_RCC_PLLP_DIV_9
N  *         @arg @ref LL_RCC_PLLP_DIV_10
N  *         @arg @ref LL_RCC_PLLP_DIV_11
N  *         @arg @ref LL_RCC_PLLP_DIV_12
N  *         @arg @ref LL_RCC_PLLP_DIV_13
N  *         @arg @ref LL_RCC_PLLP_DIV_14
N  *         @arg @ref LL_RCC_PLLP_DIV_15
N  *         @arg @ref LL_RCC_PLLP_DIV_16
N  *         @arg @ref LL_RCC_PLLP_DIV_17
N  *         @arg @ref LL_RCC_PLLP_DIV_18
N  *         @arg @ref LL_RCC_PLLP_DIV_19
N  *         @arg @ref LL_RCC_PLLP_DIV_20
N  *         @arg @ref LL_RCC_PLLP_DIV_21
N  *         @arg @ref LL_RCC_PLLP_DIV_22
N  *         @arg @ref LL_RCC_PLLP_DIV_23
N  *         @arg @ref LL_RCC_PLLP_DIV_24
N  *         @arg @ref LL_RCC_PLLP_DIV_25
N  *         @arg @ref LL_RCC_PLLP_DIV_26
N  *         @arg @ref LL_RCC_PLLP_DIV_27
N  *         @arg @ref LL_RCC_PLLP_DIV_28
N  *         @arg @ref LL_RCC_PLLP_DIV_29
N  *         @arg @ref LL_RCC_PLLP_DIV_30
N  *         @arg @ref LL_RCC_PLLP_DIV_31
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_GetP(void)
Xstatic __inline uint32_t LL_RCC_PLL_GetP(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) & ((0x1FUL << (27U)))));
N}
N#else
S/**
S  * @brief  Get Main PLL division factor for PLLP
S  * @note Used for PLLSAI3CLK (SAI1 and SAI2 clock)
S  * @rmtoll PLLCFGR      PLLP          LL_RCC_PLL_GetP
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLP_DIV_7
S  *         @arg @ref LL_RCC_PLLP_DIV_17
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLL_GetP(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP));
S}
N#endif /* RCC_PLLP_DIV_2_31_SUPPORT */
N
N/**
N  * @brief  Get Main PLL division factor for PLLQ
N  * @note Used for PLL48M1CLK selected for USB, RNG, SDMMC (48 MHz clock)
N  * @rmtoll PLLCFGR      PLLQ          LL_RCC_PLL_GetQ
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLQ_DIV_2
N  *         @arg @ref LL_RCC_PLLQ_DIV_4
N  *         @arg @ref LL_RCC_PLLQ_DIV_6
N  *         @arg @ref LL_RCC_PLLQ_DIV_8
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_GetQ(void)
Xstatic __inline uint32_t LL_RCC_PLL_GetQ(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) & ((0x3UL << (21U)))));
N}
N
N/**
N  * @brief  Get Main PLL division factor for PLLR
N  * @note Used for PLLCLK (system clock)
N  * @rmtoll PLLCFGR      PLLR          LL_RCC_PLL_GetR
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLR_DIV_2
N  *         @arg @ref LL_RCC_PLLR_DIV_4
N  *         @arg @ref LL_RCC_PLLR_DIV_6
N  *         @arg @ref LL_RCC_PLLR_DIV_8
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
Xstatic __inline uint32_t LL_RCC_PLL_GetR(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) & ((0x3UL << (25U)))));
N}
N
N/**
N  * @brief  Get Division factor for the main PLL and other PLL
N  * @rmtoll PLLCFGR      PLLM          LL_RCC_PLL_GetDivider
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  *         @arg @ref LL_RCC_PLLM_DIV_9 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_10 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_11 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_12 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_13 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_14 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_15 (*)
N  *         @arg @ref LL_RCC_PLLM_DIV_16 (*)
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
Xstatic __inline uint32_t LL_RCC_PLL_GetDivider(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) & ((0x7UL << (4U)))));
N}
N
N/**
N  * @brief  Enable PLL output mapped on SAI domain clock
N  * @rmtoll PLLCFGR      PLLPEN        LL_RCC_PLL_EnableDomain_SAI
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_EnableDomain_SAI(void)
Xstatic __inline void LL_RCC_PLL_EnableDomain_SAI(void)
N{
N  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable PLL output mapped on SAI domain clock
N  * @note Cannot be disabled if the PLL clock is used as the system
N  *       clock
N  * @note In order to save power, when the PLLCLK  of the PLL is
N  *       not used,  should be 0
N  * @rmtoll PLLCFGR      PLLPEN        LL_RCC_PLL_DisableDomain_SAI
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_DisableDomain_SAI(void)
Xstatic __inline void LL_RCC_PLL_DisableDomain_SAI(void)
N{
N  CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Enable PLL output mapped on 48MHz domain clock
N  * @rmtoll PLLCFGR      PLLQEN        LL_RCC_PLL_EnableDomain_48M
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_EnableDomain_48M(void)
Xstatic __inline void LL_RCC_PLL_EnableDomain_48M(void)
N{
N  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) |= ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Disable PLL output mapped on 48MHz domain clock
N  * @note Cannot be disabled if the PLL clock is used as the system
N  *       clock
N  * @note In order to save power, when the PLLCLK  of the PLL is
N  *       not used,  should be 0
N  * @rmtoll PLLCFGR      PLLQEN        LL_RCC_PLL_DisableDomain_48M
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_DisableDomain_48M(void)
Xstatic __inline void LL_RCC_PLL_DisableDomain_48M(void)
N{
N  CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) &= ~((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Enable PLL output mapped on SYSCLK domain
N  * @rmtoll PLLCFGR      PLLREN        LL_RCC_PLL_EnableDomain_SYS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_EnableDomain_SYS(void)
Xstatic __inline void LL_RCC_PLL_EnableDomain_SYS(void)
N{
N  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLREN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable PLL output mapped on SYSCLK domain
N  * @note Cannot be disabled if the PLL clock is used as the system
N  *       clock
N  * @note In order to save power, when the PLLCLK  of the PLL is
N  *       not used, Main PLL  should be 0
N  * @rmtoll PLLCFGR      PLLREN        LL_RCC_PLL_DisableDomain_SYS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLL_DisableDomain_SYS(void)
Xstatic __inline void LL_RCC_PLL_DisableDomain_SYS(void)
N{
N  CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLREN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_PLLSAI1 PLLSAI1
N  * @{
N  */
N
N/**
N  * @brief  Enable PLLSAI1
N  * @rmtoll CR           PLLSAI1ON     LL_RCC_PLLSAI1_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_Enable(void)
Xstatic __inline void LL_RCC_PLLSAI1_Enable(void)
N{
N  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) |= ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Disable PLLSAI1
N  * @rmtoll CR           PLLSAI1ON     LL_RCC_PLLSAI1_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_Disable(void)
Xstatic __inline void LL_RCC_PLLSAI1_Disable(void)
N{
N  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) &= ~((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Check if PLLSAI1 Ready
N  * @rmtoll CR           PLLSAI1RDY    LL_RCC_PLLSAI1_IsReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_IsReady(void)
Xstatic __inline uint32_t LL_RCC_PLLSAI1_IsReady(void)
N{
N  return (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CR) & ((0x1UL << (27U)))) == ((0x1UL << (27U))));
N}
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
X#if 0L
S/**
S  * @brief  Configure PLLSAI1 used for 48Mhz domain clock
S  * @note PLL Source can be written only when PLL, PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI1M/PLLSAI1N/PLLSAI1Q can be written only when PLLSAI1 is disabled.
S  * @note This  can be selected for USB, RNG, SDMMC
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_48M\n
S  *         PLLSAI1CFGR  PLLSAI1M      LL_RCC_PLLSAI1_ConfigDomain_48M\n
S  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_48M\n
S  *         PLLSAI1CFGR  PLLSAI1Q      LL_RCC_PLLSAI1_ConfigDomain_48M
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  * @param  PLLN Between 8 and 86
S  * @param  PLLQ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_48M(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLQ)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, Source);
S  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M | RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1Q,
S             PLLM | PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLQ);
S}
N#else
N/**
N  * @brief  Configure PLLSAI1 used for 48Mhz domain clock
N  * @note PLL Source and PLLM Divider can be written only when PLL,
N  *       PLLSAI1 and PLLSAI2 (*) are disabled.
N  * @note PLLSAI1N/PLLSAI1Q can be written only when PLLSAI1 is disabled.
N  * @note This  can be selected for USB, RNG, SDMMC
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_48M\n
N  *         PLLCFGR      PLLM          LL_RCC_PLLSAI1_ConfigDomain_48M\n
N  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_48M\n
N  *         PLLSAI1CFGR  PLLSAI1Q      LL_RCC_PLLSAI1_ConfigDomain_48M
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @param  PLLM This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  PLLN Between 8 and 86
N  * @param  PLLQ This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_8
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_48M(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLQ)
Xstatic __inline void LL_RCC_PLLSAI1_ConfigDomain_48M(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLQ)
N{
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U)) | (0x7UL << (4U))))) | (Source | PLLM))));
N  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1Q, PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLQ);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR))) & (~((0x7FUL << (8U)) | (0x3UL << (21U))))) | (PLLN << (8U) | PLLQ))));
N}
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
X#if 0L && 1L
S/**
S  * @brief  Configure PLLSAI1 used for SAI domain clock
S  * @note PLL Source can be written only when PLL, PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI1M/PLLSAI1N/PLLSAI1PDIV can be written only when PLLSAI1 is disabled.
S  * @note This  can be selected for SAI1 or SAI2
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_SAI\n
S  *         PLLSAI1CFGR  PLLSAI1M      LL_RCC_PLLSAI1_ConfigDomain_SAI\n
S  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_SAI\n
S  *         PLLSAI1CFGR  PLLSAI1PDIV   LL_RCC_PLLSAI1_ConfigDomain_SAI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  * @param  PLLN Between 8 and 86
S  * @param  PLLP This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_31
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, Source);
S  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M | RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV,
S             PLLM | PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLP);
S}
N#elif defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
X#elif 1L
N/**
N  * @brief  Configure PLLSAI1 used for SAI domain clock
N  * @note PLL Source and PLLM Divider can be written only when PLL,
N  *       PLLSAI1 and PLLSAI2 (*) are disabled.
N  * @note PLLSAI1N/PLLSAI1PDIV can be written only when PLLSAI1 is disabled.
N  * @note This  can be selected for SAI1 or SAI2 (*)
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_SAI\n
N  *         PLLCFGR      PLLM          LL_RCC_PLLSAI1_ConfigDomain_SAI\n
N  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_SAI\n
N  *         PLLSAI1CFGR  PLLSAI1PDIV   LL_RCC_PLLSAI1_ConfigDomain_SAI
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @param  PLLM This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  PLLN Between 8 and 86
N  * @param  PLLP This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_3
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_5
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_8
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_9
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_10
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_11
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_12
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_13
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_14
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_15
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_16
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_18
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_19
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_20
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_21
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_22
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_23
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_24
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_25
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_26
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_27
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_28
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_29
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_30
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_31
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
Xstatic __inline void LL_RCC_PLLSAI1_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
N{
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U)) | (0x7UL << (4U))))) | (Source | PLLM))));
N  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV,
N             PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLP);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR))) & (~((0x7FUL << (8U)) | (0x1FUL << (27U))))) | (PLLN << (8U) | PLLP))));
N}
N#else
S/**
S  * @brief  Configure PLLSAI1 used for SAI domain clock
S  * @note PLL Source and PLLM Divider can be written only when PLL,
S  *       PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI1N/PLLSAI1P can be written only when PLLSAI1 is disabled.
S  * @note This  can be selected for SAI1 or SAI2 (*)
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_SAI\n
S  *         PLLCFGR      PLLM          LL_RCC_PLLSAI1_ConfigDomain_SAI\n
S  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_SAI\n
S  *         PLLSAI1CFGR  PLLSAI1P      LL_RCC_PLLSAI1_ConfigDomain_SAI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  PLLN Between 8 and 86
S  * @param  PLLP This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
S  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P, PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLP);
S}
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT && RCC_PLLSAI1P_DIV_2_31_SUPPORT */
N
N#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
X#if 0L
S/**
S  * @brief  Configure PLLSAI1 used for ADC domain clock
S  * @note PLL Source can be written only when PLL, PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI1M/PLLSAI1N/PLLSAI1R can be written only when PLLSAI1 is disabled.
S  * @note This  can be selected for ADC
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_ADC\n
S  *         PLLSAI1CFGR  PLLSAI1M      LL_RCC_PLLSAI1_ConfigDomain_ADC\n
S  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_ADC\n
S  *         PLLSAI1CFGR  PLLSAI1R      LL_RCC_PLLSAI1_ConfigDomain_ADC
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  * @param  PLLN Between 8 and 86
S  * @param  PLLR This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1R_DIV_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_ADC(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, Source);
S  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M | RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1R,
S             PLLM | PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLR);
S}
N#else
N/**
N  * @brief  Configure PLLSAI1 used for ADC domain clock
N  * @note PLL Source and PLLM Divider can be written only when PLL,
N  *       PLLSAI1 and PLLSAI2 (*) are disabled.
N  * @note PLLN/PLLR can be written only when PLLSAI1 is disabled.
N  * @note This  can be selected for ADC
N  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI1_ConfigDomain_ADC\n
N  *         PLLCFGR      PLLM          LL_RCC_PLLSAI1_ConfigDomain_ADC\n
N  *         PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_ConfigDomain_ADC\n
N  *         PLLSAI1CFGR  PLLSAI1R      LL_RCC_PLLSAI1_ConfigDomain_ADC
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSOURCE_NONE
N  *         @arg @ref LL_RCC_PLLSOURCE_MSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSI
N  *         @arg @ref LL_RCC_PLLSOURCE_HSE
N  * @param  PLLM This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLM_DIV_1
N  *         @arg @ref LL_RCC_PLLM_DIV_2
N  *         @arg @ref LL_RCC_PLLM_DIV_3
N  *         @arg @ref LL_RCC_PLLM_DIV_4
N  *         @arg @ref LL_RCC_PLLM_DIV_5
N  *         @arg @ref LL_RCC_PLLM_DIV_6
N  *         @arg @ref LL_RCC_PLLM_DIV_7
N  *         @arg @ref LL_RCC_PLLM_DIV_8
N  * @param  PLLN Between 8 and 86
N  * @param  PLLR This parameter can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_8
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_ConfigDomain_ADC(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
Xstatic __inline void LL_RCC_PLLSAI1_ConfigDomain_ADC(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
N{
N  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLCFGR))) & (~((0x3UL << (0U)) | (0x7UL << (4U))))) | (Source | PLLM))));
N  MODIFY_REG(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1R, PLLN << RCC_PLLSAI1CFGR_PLLSAI1N_Pos | PLLR);
X  (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR)) = ((((((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR))) & (~((0x7FUL << (8U)) | (0x3UL << (25U))))) | (PLLN << (8U) | PLLR))));
N}
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
N
N/**
N  * @brief  Get SAI1PLL multiplication factor for VCO
N  * @rmtoll PLLSAI1CFGR  PLLSAI1N      LL_RCC_PLLSAI1_GetN
N  * @retval Between 8 and 86
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_GetN(void)
Xstatic __inline uint32_t LL_RCC_PLLSAI1_GetN(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos);
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) & ((0x7FUL << (8U)))) >> (8U));
N}
N
N#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
X#if 1L
N/**
N  * @brief  Get SAI1PLL division factor for PLLSAI1P
N  * @note Used for PLLSAI1CLK (SAI1 or SAI2 (*) clock).
N  * @rmtoll PLLSAI1CFGR  PLLSAI1PDIV      LL_RCC_PLLSAI1_GetP
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_3
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_5
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_8
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_9
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_10
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_11
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_12
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_13
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_14
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_15
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_16
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_18
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_19
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_20
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_21
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_22
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_23
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_24
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_25
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_26
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_27
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_28
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_29
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_30
N  *         @arg @ref LL_RCC_PLLSAI1P_DIV_31
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_GetP(void)
Xstatic __inline uint32_t LL_RCC_PLLSAI1_GetP(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) & ((0x1FUL << (27U)))));
N}
N#else
S/**
S  * @brief  Get SAI1PLL division factor for PLLSAI1P
S  * @note Used for PLLSAI1CLK (SAI1 or SAI2 (*) clock).
S  * @rmtoll PLLSAI1CFGR  PLLSAI1P      LL_RCC_PLLSAI1_GetP
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1P_DIV_17
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_GetP(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P));
S}
N#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
N
N/**
N  * @brief  Get SAI1PLL division factor for PLLSAI1Q
N  * @note Used PLL48M2CLK selected for USB, RNG, SDMMC (48 MHz clock)
N  * @rmtoll PLLSAI1CFGR  PLLSAI1Q      LL_RCC_PLLSAI1_GetQ
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1Q_DIV_8
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_GetQ(void)
Xstatic __inline uint32_t LL_RCC_PLLSAI1_GetQ(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) & ((0x3UL << (21U)))));
N}
N
N/**
N  * @brief  Get PLLSAI1 division factor for PLLSAIR
N  * @note Used for PLLADC1CLK (ADC clock)
N  * @rmtoll PLLSAI1CFGR  PLLSAI1R      LL_RCC_PLLSAI1_GetR
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_2
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_4
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_6
N  *         @arg @ref LL_RCC_PLLSAI1R_DIV_8
N  */
N__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_GetR(void)
Xstatic __inline uint32_t LL_RCC_PLLSAI1_GetR(void)
N{
N  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R));
X  return (uint32_t)(((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) & ((0x3UL << (25U)))));
N}
N
N#if  defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
X#if  0L
S/**
S  * @brief  Get Division factor for the PLLSAI1
S  * @rmtoll PLLSAI1CFGR  PLLSAI1M      LL_RCC_PLLSAI1_GetDivider
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI1M_DIV_16
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI1_GetDivider(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M));
S}
N#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
N
N/**
N  * @brief  Enable PLLSAI1 output mapped on SAI domain clock
N  * @rmtoll PLLSAI1CFGR  PLLSAI1PEN    LL_RCC_PLLSAI1_EnableDomain_SAI
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_EnableDomain_SAI(void)
Xstatic __inline void LL_RCC_PLLSAI1_EnableDomain_SAI(void)
N{
N  SET_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable PLLSAI1 output mapped on SAI domain clock
N  * @note In order to save power, when  of the PLLSAI1 is
N  *       not used,  should be 0
N  * @rmtoll PLLSAI1CFGR  PLLSAI1PEN    LL_RCC_PLLSAI1_DisableDomain_SAI
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_DisableDomain_SAI(void)
Xstatic __inline void LL_RCC_PLLSAI1_DisableDomain_SAI(void)
N{
N  CLEAR_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Enable PLLSAI1 output mapped on 48MHz domain clock
N  * @rmtoll PLLSAI1CFGR  PLLSAI1QEN    LL_RCC_PLLSAI1_EnableDomain_48M
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_EnableDomain_48M(void)
Xstatic __inline void LL_RCC_PLLSAI1_EnableDomain_48M(void)
N{
N  SET_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) |= ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Disable PLLSAI1 output mapped on 48MHz domain clock
N  * @note In order to save power, when  of the PLLSAI1 is
N  *       not used,  should be 0
N  * @rmtoll PLLSAI1CFGR  PLLSAI1QEN    LL_RCC_PLLSAI1_DisableDomain_48M
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_DisableDomain_48M(void)
Xstatic __inline void LL_RCC_PLLSAI1_DisableDomain_48M(void)
N{
N  CLEAR_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) &= ~((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Enable PLLSAI1 output mapped on ADC domain clock
N  * @rmtoll PLLSAI1CFGR  PLLSAI1REN    LL_RCC_PLLSAI1_EnableDomain_ADC
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_EnableDomain_ADC(void)
Xstatic __inline void LL_RCC_PLLSAI1_EnableDomain_ADC(void)
N{
N  SET_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1REN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable PLLSAI1 output mapped on ADC domain clock
N  * @note In order to save power, when  of the PLLSAI1 is
N  *       not used, Main PLLSAI1  should be 0
N  * @rmtoll PLLSAI1CFGR  PLLSAI1REN    LL_RCC_PLLSAI1_DisableDomain_ADC
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_PLLSAI1_DisableDomain_ADC(void)
Xstatic __inline void LL_RCC_PLLSAI1_DisableDomain_ADC(void)
N{
N  CLEAR_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1REN);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->PLLSAI1CFGR) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S/** @defgroup RCC_LL_EF_PLLSAI2 PLLSAI2
S  * @{
S  */
S
S/**
S  * @brief  Enable PLLSAI2
S  * @rmtoll CR           PLLSAI2ON     LL_RCC_PLLSAI2_Enable
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_Enable(void)
S{
S  SET_BIT(RCC->CR, RCC_CR_PLLSAI2ON);
S}
S
S/**
S  * @brief  Disable PLLSAI2
S  * @rmtoll CR           PLLSAI2ON     LL_RCC_PLLSAI2_Disable
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_Disable(void)
S{
S  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI2ON);
S}
S
S/**
S  * @brief  Check if PLLSAI2 Ready
S  * @rmtoll CR           PLLSAI2RDY    LL_RCC_PLLSAI2_IsReady
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_IsReady(void)
S{
S  return (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == (RCC_CR_PLLSAI2RDY));
S}
S
S#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
S/**
S  * @brief  Configure PLLSAI2 used for SAI domain clock
S  * @note PLL Source can be written only when PLL, PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI2M/PLLSAI2N/PLLSAI2PDIV can be written only when PLLSAI2 is disabled.
S  * @note This  can be selected for SAI1 or SAI2
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2M      LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2PDIV   LL_RCC_PLLSAI2_ConfigDomain_SAI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  * @param  PLLN Between 8 and 86
S  * @param  PLLP This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_31
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, Source);
S  MODIFY_REG(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M | RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV,
S             PLLM | PLLN << RCC_PLLSAI2CFGR_PLLSAI2N_Pos | PLLP);
S}
S#elif defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
S/**
S  * @brief  Configure PLLSAI2 used for SAI domain clock
S  * @note PLL Source and PLLM Divider can be written only when PLL,
S  *       PLLSAI1 and PLLSAI2 are disabled.
S  * @note PLLSAI2N/PLLSAI2PDIV can be written only when PLLSAI2 is disabled.
S  * @note This  can be selected for SAI1 or SAI2
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLCFGR      PLLM          LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2PDIV   LL_RCC_PLLSAI2_ConfigDomain_SAI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  PLLN Between 8 and 86
S  * @param  PLLP This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_31
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
S  MODIFY_REG(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV, PLLN << RCC_PLLSAI2CFGR_PLLSAI2N_Pos | PLLP);
S}
S#else
S/**
S  * @brief  Configure PLLSAI2 used for SAI domain clock
S  * @note PLL Source and PLLM Divider can be written only when PLL,
S  *       PLLSAI2 and PLLSAI2 are disabled.
S  * @note PLLSAI2N/PLLSAI2P can be written only when PLLSAI2 is disabled.
S  * @note This  can be selected for SAI1 or SAI2
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLCFGR      PLLM          LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_ConfigDomain_SAI\n
S  *         PLLSAI2CFGR  PLLSAI2P      LL_RCC_PLLSAI2_ConfigDomain_SAI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  PLLN Between 8 and 86
S  * @param  PLLP This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_ConfigDomain_SAI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
S  MODIFY_REG(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2P, PLLN << RCC_PLLSAI2CFGR_PLLSAI2N_Pos | PLLP);
S}
S#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2P_DIV_2_31_SUPPORT */
S
S#if defined(DSI)
S/**
S  * @brief  Configure PLLSAI2 used for DSI domain clock
S  * @note PLL Source can be written only when PLL, PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI2M/PLLSAI2N/PLLSAI2Q can be written only when PLLSAI2 is disabled.
S  * @note This  can be selected for DSI
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI2_ConfigDomain_DSI\n
S  *         PLLSAI2CFGR  PLLSAI2M      LL_RCC_PLLSAI2_ConfigDomain_DSI\n
S  *         PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_ConfigDomain_DSI\n
S  *         PLLSAI2CFGR  PLLSAI2Q      LL_RCC_PLLSAI2_ConfigDomain_DSI
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  * @param  PLLN Between 8 and 86
S  * @param  PLLQ This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_ConfigDomain_DSI(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLQ)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, Source);
S  MODIFY_REG(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M | RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2Q, PLLN << RCC_PLLSAI2CFGR_PLLSAI2N_Pos | PLLQ | PLLM);
S}
S#endif /* DSI */
S
S#if defined(LTDC)
S/**
S  * @brief  Configure PLLSAI2 used for LTDC domain clock
S  * @note PLL Source can be written only when PLL, PLLSAI1 and PLLSAI2 (*) are disabled.
S  * @note PLLSAI2M/PLLSAI2N/PLLSAI2R can be written only when PLLSAI2 is disabled.
S  * @note This  can be selected for LTDC
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI2_ConfigDomain_LTDC\n
S  *         PLLSAI2CFGR  PLLSAI2M      LL_RCC_PLLSAI2_ConfigDomain_LTDC\n
S  *         PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_ConfigDomain_LTDC\n
S  *         PLLSAI2CFGR  PLLSAI2R      LL_RCC_PLLSAI2_ConfigDomain_LTDC\n
S  *         CCIPR2       PLLSAI2DIVR   LL_RCC_PLLSAI2_ConfigDomain_LTDC
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  * @param  PLLN Between 8 and 86
S  * @param  PLLR This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_8
S  * @param  PLLDIVR This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_16
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_ConfigDomain_LTDC(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR, uint32_t PLLDIVR)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, Source);
S  MODIFY_REG(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M | RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2R, PLLN << RCC_PLLSAI2CFGR_PLLSAI2N_Pos | PLLR | PLLM);
S  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_PLLSAI2DIVR, PLLDIVR);
S}
S#else
S/**
S  * @brief  Configure PLLSAI2 used for ADC domain clock
S  * @note PLL Source and PLLM Divider can be written only when PLL,
S  *       PLLSAI2 and PLLSAI2 are disabled.
S  * @note PLLSAI2N/PLLSAI2R can be written only when PLLSAI2 is disabled.
S  * @note This  can be selected for ADC
S  * @rmtoll PLLCFGR      PLLSRC        LL_RCC_PLLSAI2_ConfigDomain_ADC\n
S  *         PLLCFGR      PLLM          LL_RCC_PLLSAI2_ConfigDomain_ADC\n
S  *         PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_ConfigDomain_ADC\n
S  *         PLLSAI2CFGR  PLLSAI2R      LL_RCC_PLLSAI2_ConfigDomain_ADC
S  * @param  Source This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSOURCE_NONE
S  *         @arg @ref LL_RCC_PLLSOURCE_MSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSI
S  *         @arg @ref LL_RCC_PLLSOURCE_HSE
S  * @param  PLLM This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLM_DIV_1
S  *         @arg @ref LL_RCC_PLLM_DIV_2
S  *         @arg @ref LL_RCC_PLLM_DIV_3
S  *         @arg @ref LL_RCC_PLLM_DIV_4
S  *         @arg @ref LL_RCC_PLLM_DIV_5
S  *         @arg @ref LL_RCC_PLLM_DIV_6
S  *         @arg @ref LL_RCC_PLLM_DIV_7
S  *         @arg @ref LL_RCC_PLLM_DIV_8
S  * @param  PLLN Between 8 and 86
S  * @param  PLLR This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_8
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_ConfigDomain_ADC(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
S{
S  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, Source | PLLM);
S  MODIFY_REG(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2R, PLLN << RCC_PLLSAI2CFGR_PLLSAI2N_Pos | PLLR);
S}
S#endif /* LTDC */
S
S/**
S  * @brief  Get SAI2PLL multiplication factor for VCO
S  * @rmtoll PLLSAI2CFGR  PLLSAI2N      LL_RCC_PLLSAI2_GetN
S  * @retval Between 8 and 86
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetN(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos);
S}
S
S#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
S/**
S  * @brief  Get SAI2PLL division factor for PLLSAI2P
S  * @note Used for PLLSAI2CLK (SAI1 or SAI2 clock).
S  * @rmtoll PLLSAI2CFGR  PLLSAI2PDIV    LL_RCC_PLLSAI2_GetP
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_16
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_18
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_19
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_20
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_21
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_22
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_23
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_24
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_25
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_26
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_27
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_28
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_29
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_30
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_31
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetP(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV));
S}
S#else
S/**
S  * @brief  Get SAI2PLL division factor for PLLSAI2P
S  * @note Used for PLLSAI2CLK (SAI1 or SAI2 clock).
S  * @rmtoll PLLSAI2CFGR  PLLSAI2P      LL_RCC_PLLSAI2_GetP
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2P_DIV_17
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetP(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P));
S}
S#endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
S
S#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
S/**
S  * @brief  Get division factor for PLLSAI2Q
S  * @note Used for PLLDSICLK (DSI clock)
S  * @rmtoll PLLSAI2CFGR  PLLSAI2Q      LL_RCC_PLLSAI2_GetQ
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2Q_DIV_8
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetQ(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2Q));
S}
S#endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
S
S/**
S  * @brief  Get SAI2PLL division factor for PLLSAI2R
S  * @note Used for PLLADC2CLK (ADC clock) or PLLLCDCLK (LTDC clock) depending on devices
S  * @rmtoll PLLSAI2CFGR  PLLSAI2R      LL_RCC_PLLSAI2_GetR
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2R_DIV_8
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetR(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R));
S}
S
S#if  defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S/**
S  * @brief  Get Division factor for the PLLSAI2
S  * @rmtoll PLLSAI2CFGR  PLLSAI2M      LL_RCC_PLLSAI2_GetDivider
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_1
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_3
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_5
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_6
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_7
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_9
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_10
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_11
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_12
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_13
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_14
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_15
S  *         @arg @ref LL_RCC_PLLSAI2M_DIV_16
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetDivider(void)
S{
S  return (uint32_t)(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M));
S}
S#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
S
S#if defined(RCC_CCIPR2_PLLSAI2DIVR)
S/**
S  * @brief  Get PLLSAI2 division factor for PLLSAI2DIVR
S  * @note Used for LTDC domain clock
S  * @rmtoll CCIPR2  PLLSAI2DIVR      LL_RCC_PLLSAI2_GetDIVR
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_2
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_4
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_8
S  *         @arg @ref LL_RCC_PLLSAI2DIVR_DIV_16
S  */
S__STATIC_INLINE uint32_t LL_RCC_PLLSAI2_GetDIVR(void)
S{
S  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_PLLSAI2DIVR));
S}
S#endif /* RCC_CCIPR2_PLLSAI2DIVR */
S
S/**
S  * @brief  Enable PLLSAI2 output mapped on SAI domain clock
S  * @rmtoll PLLSAI2CFGR  PLLSAI2PEN    LL_RCC_PLLSAI2_EnableDomain_SAI
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_EnableDomain_SAI(void)
S{
S  SET_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PEN);
S}
S
S/**
S  * @brief  Disable PLLSAI2 output mapped on SAI domain clock
S  * @note In order to save power, when  of the PLLSAI2 is
S  *       not used,  should be 0
S  * @rmtoll PLLSAI2CFGR  PLLSAI2PEN    LL_RCC_PLLSAI2_DisableDomain_SAI
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_DisableDomain_SAI(void)
S{
S  CLEAR_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PEN);
S}
S
S#if defined(DSI)
S/**
S  * @brief  Enable PLLSAI2 output mapped on DSI domain clock
S  * @rmtoll PLLSAI2CFGR  PLLSAI2QEN    LL_RCC_PLLSAI2_EnableDomain_DSI
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_EnableDomain_DSI(void)
S{
S  SET_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2QEN);
S}
S
S/**
S  * @brief  Disable PLLSAI2 output mapped on DSI domain clock
S  * @note In order to save power, when  of the PLLSAI2 is
S  *       not used, Main PLLSAI2  should be 0
S  * @rmtoll PLLSAI2CFGR  PLLSAI2QEN    LL_RCC_PLLSAI2_DisableDomain_DSI
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_DisableDomain_DSI(void)
S{
S  CLEAR_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2QEN);
S}
S#endif /* DSI */
S
S#if defined(LTDC)
S/**
S  * @brief  Enable PLLSAI2 output mapped on LTDC domain clock
S  * @rmtoll PLLSAI2CFGR  PLLSAI2REN    LL_RCC_PLLSAI2_EnableDomain_LTDC
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_EnableDomain_LTDC(void)
S{
S  SET_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2REN);
S}
S
S/**
S  * @brief  Disable PLLSAI2 output mapped on LTDC domain clock
S  * @note In order to save power, when  of the PLLSAI2 is
S  *       not used, Main PLLSAI2  should be 0
S  * @rmtoll PLLSAI2CFGR  PLLSAI2REN    LL_RCC_PLLSAI2_DisableDomain_LTDC
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_DisableDomain_LTDC(void)
S{
S  CLEAR_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2REN);
S}
S#else
S/**
S  * @brief  Enable PLLSAI2 output mapped on ADC domain clock
S  * @rmtoll PLLSAI2CFGR  PLLSAI2REN    LL_RCC_PLLSAI2_EnableDomain_ADC
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_EnableDomain_ADC(void)
S{
S  SET_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2REN);
S}
S
S/**
S  * @brief  Disable PLLSAI2 output mapped on ADC domain clock
S  * @note In order to save power, when  of the PLLSAI2 is
S  *       not used, Main PLLSAI2  should be 0
S  * @rmtoll PLLSAI2CFGR  PLLSAI2REN    LL_RCC_PLLSAI2_DisableDomain_ADC
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_PLLSAI2_DisableDomain_ADC(void)
S{
S  CLEAR_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2REN);
S}
S#endif /* LTDC */
S
S/**
S  * @}
S  */
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N
N
N/** @defgroup RCC_LL_EF_FLAG_Management FLAG Management
N  * @{
N  */
N
N/**
N  * @brief  Clear LSI ready interrupt flag
N  * @rmtoll CICR         LSIRDYC       LL_RCC_ClearFlag_LSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_LSIRDY(void)
Xstatic __inline void LL_RCC_ClearFlag_LSIRDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_LSIRDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear LSE ready interrupt flag
N  * @rmtoll CICR         LSERDYC       LL_RCC_ClearFlag_LSERDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_LSERDY(void)
Xstatic __inline void LL_RCC_ClearFlag_LSERDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_LSERDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear MSI ready interrupt flag
N  * @rmtoll CICR         MSIRDYC       LL_RCC_ClearFlag_MSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_MSIRDY(void)
Xstatic __inline void LL_RCC_ClearFlag_MSIRDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_MSIRDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear HSI ready interrupt flag
N  * @rmtoll CICR         HSIRDYC       LL_RCC_ClearFlag_HSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_HSIRDY(void)
Xstatic __inline void LL_RCC_ClearFlag_HSIRDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_HSIRDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear HSE ready interrupt flag
N  * @rmtoll CICR         HSERDYC       LL_RCC_ClearFlag_HSERDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_HSERDY(void)
Xstatic __inline void LL_RCC_ClearFlag_HSERDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_HSERDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear PLL ready interrupt flag
N  * @rmtoll CICR         PLLRDYC       LL_RCC_ClearFlag_PLLRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_PLLRDY(void)
Xstatic __inline void LL_RCC_ClearFlag_PLLRDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_PLLRDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (5U))));
N}
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/**
N  * @brief  Clear HSI48 ready interrupt flag
N  * @rmtoll CICR          HSI48RDYC     LL_RCC_ClearFlag_HSI48RDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_HSI48RDY(void)
Xstatic __inline void LL_RCC_ClearFlag_HSI48RDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_HSI48RDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (10U))));
N}
N#endif /* RCC_HSI48_SUPPORT */
N
N/**
N  * @brief  Clear PLLSAI1 ready interrupt flag
N  * @rmtoll CICR         PLLSAI1RDYC   LL_RCC_ClearFlag_PLLSAI1RDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_PLLSAI1RDY(void)
Xstatic __inline void LL_RCC_ClearFlag_PLLSAI1RDY(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_PLLSAI1RDYC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (6U))));
N}
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S/**
S  * @brief  Clear PLLSAI1 ready interrupt flag
S  * @rmtoll CICR         PLLSAI2RDYC   LL_RCC_ClearFlag_PLLSAI2RDY
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_ClearFlag_PLLSAI2RDY(void)
S{
S  SET_BIT(RCC->CICR, RCC_CICR_PLLSAI2RDYC);
S}
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N/**
N  * @brief  Clear Clock security system interrupt flag
N  * @rmtoll CICR         CSSC          LL_RCC_ClearFlag_HSECSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_HSECSS(void)
Xstatic __inline void LL_RCC_ClearFlag_HSECSS(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_CSSC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear LSE Clock security system interrupt flag
N  * @rmtoll CICR         LSECSSC       LL_RCC_ClearFlag_LSECSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearFlag_LSECSS(void)
Xstatic __inline void LL_RCC_ClearFlag_LSECSS(void)
N{
N  SET_BIT(RCC->CICR, RCC_CICR_LSECSSC);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CICR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Check if LSI ready interrupt occurred or not
N  * @rmtoll CIFR         LSIRDYF       LL_RCC_IsActiveFlag_LSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_LSIRDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_LSIRDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_LSIRDYF) == (RCC_CIFR_LSIRDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if LSE ready interrupt occurred or not
N  * @rmtoll CIFR         LSERDYF       LL_RCC_IsActiveFlag_LSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_LSERDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_LSERDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_LSERDYF) == (RCC_CIFR_LSERDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if MSI ready interrupt occurred or not
N  * @rmtoll CIFR         MSIRDYF       LL_RCC_IsActiveFlag_MSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_MSIRDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_MSIRDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_MSIRDYF) == (RCC_CIFR_MSIRDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if HSI ready interrupt occurred or not
N  * @rmtoll CIFR         HSIRDYF       LL_RCC_IsActiveFlag_HSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HSIRDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_HSIRDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_HSIRDYF) == (RCC_CIFR_HSIRDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if HSE ready interrupt occurred or not
N  * @rmtoll CIFR         HSERDYF       LL_RCC_IsActiveFlag_HSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HSERDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_HSERDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_HSERDYF) == (RCC_CIFR_HSERDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Check if PLL ready interrupt occurred or not
N  * @rmtoll CIFR         PLLRDYF       LL_RCC_IsActiveFlag_PLLRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PLLRDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_PLLRDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_PLLRDYF) == (RCC_CIFR_PLLRDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/**
N  * @brief  Check if HSI48 ready interrupt occurred or not
N  * @rmtoll CIR          HSI48RDYF     LL_RCC_IsActiveFlag_HSI48RDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HSI48RDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_HSI48RDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_HSI48RDYF) == (RCC_CIFR_HSI48RDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N#endif /* RCC_HSI48_SUPPORT */
N
N/**
N  * @brief  Check if PLLSAI1 ready interrupt occurred or not
N  * @rmtoll CIFR         PLLSAI1RDYF   LL_RCC_IsActiveFlag_PLLSAI1RDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PLLSAI1RDY(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_PLLSAI1RDY(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_PLLSAI1RDYF) == (RCC_CIFR_PLLSAI1RDYF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S/**
S  * @brief  Check if PLLSAI1 ready interrupt occurred or not
S  * @rmtoll CIFR         PLLSAI2RDYF   LL_RCC_IsActiveFlag_PLLSAI2RDY
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PLLSAI2RDY(void)
S{
S  return (READ_BIT(RCC->CIFR, RCC_CIFR_PLLSAI2RDYF) == (RCC_CIFR_PLLSAI2RDYF));
S}
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N/**
N  * @brief  Check if Clock security system interrupt occurred or not
N  * @rmtoll CIFR         CSSF          LL_RCC_IsActiveFlag_HSECSS
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HSECSS(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_HSECSS(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_CSSF) == (RCC_CIFR_CSSF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if LSE Clock security system interrupt occurred or not
N  * @rmtoll CIFR         LSECSSF       LL_RCC_IsActiveFlag_LSECSS
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_LSECSS(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_LSECSS(void)
N{
N  return (READ_BIT(RCC->CIFR, RCC_CIFR_LSECSSF) == (RCC_CIFR_LSECSSF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIFR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Check if RCC flag FW reset is set or not.
N  * @rmtoll CSR          FWRSTF        LL_RCC_IsActiveFlag_FWRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_FWRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_FWRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_FWRSTF) == (RCC_CSR_FWRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (24U)))) == ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Check if RCC flag Independent Watchdog reset is set or not.
N  * @rmtoll CSR          IWDGRSTF      LL_RCC_IsActiveFlag_IWDGRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_IWDGRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_IWDGRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_IWDGRSTF) == (RCC_CSR_IWDGRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (29U)))) == ((0x1UL << (29U))));
N}
N
N/**
N  * @brief  Check if RCC flag Low Power reset is set or not.
N  * @rmtoll CSR          LPWRRSTF      LL_RCC_IsActiveFlag_LPWRRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_LPWRRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_LPWRRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_LPWRRSTF) == (RCC_CSR_LPWRRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (31U)))) == ((0x1UL << (31U))));
N}
N
N/**
N  * @brief  Check if RCC flag is set or not.
N  * @rmtoll CSR          OBLRSTF       LL_RCC_IsActiveFlag_OBLRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_OBLRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_OBLRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_OBLRSTF) == (RCC_CSR_OBLRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Check if RCC flag Pin reset is set or not.
N  * @rmtoll CSR          PINRSTF       LL_RCC_IsActiveFlag_PINRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PINRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_PINRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_PINRSTF) == (RCC_CSR_PINRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (26U)))) == ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Check if RCC flag Software reset is set or not.
N  * @rmtoll CSR          SFTRSTF       LL_RCC_IsActiveFlag_SFTRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SFTRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_SFTRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_SFTRSTF) == (RCC_CSR_SFTRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (28U)))) == ((0x1UL << (28U))));
N}
N
N/**
N  * @brief  Check if RCC flag Window Watchdog reset is set or not.
N  * @rmtoll CSR          WWDGRSTF      LL_RCC_IsActiveFlag_WWDGRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_WWDGRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_WWDGRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_WWDGRSTF) == (RCC_CSR_WWDGRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (30U)))) == ((0x1UL << (30U))));
N}
N
N/**
N  * @brief  Check if RCC flag BOR reset is set or not.
N  * @rmtoll CSR          BORRSTF       LL_RCC_IsActiveFlag_BORRST
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_BORRST(void)
Xstatic __inline uint32_t LL_RCC_IsActiveFlag_BORRST(void)
N{
N  return (READ_BIT(RCC->CSR, RCC_CSR_BORRSTF) == (RCC_CSR_BORRSTF));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) & ((0x1UL << (27U)))) == ((0x1UL << (27U))));
N}
N
N/**
N  * @brief  Set RMVF bit to clear the reset flags.
N  * @rmtoll CSR          RMVF          LL_RCC_ClearResetFlags
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_ClearResetFlags(void)
Xstatic __inline void LL_RCC_ClearResetFlags(void)
N{
N  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CSR) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_IT_Management IT Management
N  * @{
N  */
N
N/**
N  * @brief  Enable LSI ready interrupt
N  * @rmtoll CIER         LSIRDYIE      LL_RCC_EnableIT_LSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_LSIRDY(void)
Xstatic __inline void LL_RCC_EnableIT_LSIRDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_LSIRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable LSE ready interrupt
N  * @rmtoll CIER         LSERDYIE      LL_RCC_EnableIT_LSERDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_LSERDY(void)
Xstatic __inline void LL_RCC_EnableIT_LSERDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_LSERDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable MSI ready interrupt
N  * @rmtoll CIER         MSIRDYIE      LL_RCC_EnableIT_MSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_MSIRDY(void)
Xstatic __inline void LL_RCC_EnableIT_MSIRDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_MSIRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable HSI ready interrupt
N  * @rmtoll CIER         HSIRDYIE      LL_RCC_EnableIT_HSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_HSIRDY(void)
Xstatic __inline void LL_RCC_EnableIT_HSIRDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_HSIRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Enable HSE ready interrupt
N  * @rmtoll CIER         HSERDYIE      LL_RCC_EnableIT_HSERDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_HSERDY(void)
Xstatic __inline void LL_RCC_EnableIT_HSERDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_HSERDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable PLL ready interrupt
N  * @rmtoll CIER         PLLRDYIE      LL_RCC_EnableIT_PLLRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_PLLRDY(void)
Xstatic __inline void LL_RCC_EnableIT_PLLRDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_PLLRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (5U))));
N}
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/**
N  * @brief  Enable HSI48 ready interrupt
N  * @rmtoll CIER          HSI48RDYIE    LL_RCC_EnableIT_HSI48RDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_HSI48RDY(void)
Xstatic __inline void LL_RCC_EnableIT_HSI48RDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_HSI48RDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (10U))));
N}
N#endif /* RCC_HSI48_SUPPORT */
N
N/**
N  * @brief  Enable PLLSAI1 ready interrupt
N  * @rmtoll CIER         PLLSAI1RDYIE  LL_RCC_EnableIT_PLLSAI1RDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_PLLSAI1RDY(void)
Xstatic __inline void LL_RCC_EnableIT_PLLSAI1RDY(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_PLLSAI1RDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (6U))));
N}
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S/**
S  * @brief  Enable PLLSAI2 ready interrupt
S  * @rmtoll CIER         PLLSAI2RDYIE  LL_RCC_EnableIT_PLLSAI2RDY
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_EnableIT_PLLSAI2RDY(void)
S{
S  SET_BIT(RCC->CIER, RCC_CIER_PLLSAI2RDYIE);
S}
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N/**
N  * @brief  Enable LSE clock security system interrupt
N  * @rmtoll CIER         LSECSSIE      LL_RCC_EnableIT_LSECSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_EnableIT_LSECSS(void)
Xstatic __inline void LL_RCC_EnableIT_LSECSS(void)
N{
N  SET_BIT(RCC->CIER, RCC_CIER_LSECSSIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable LSI ready interrupt
N  * @rmtoll CIER         LSIRDYIE      LL_RCC_DisableIT_LSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_LSIRDY(void)
Xstatic __inline void LL_RCC_DisableIT_LSIRDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_LSIRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable LSE ready interrupt
N  * @rmtoll CIER         LSERDYIE      LL_RCC_DisableIT_LSERDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_LSERDY(void)
Xstatic __inline void LL_RCC_DisableIT_LSERDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_LSERDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable MSI ready interrupt
N  * @rmtoll CIER         MSIRDYIE      LL_RCC_DisableIT_MSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_MSIRDY(void)
Xstatic __inline void LL_RCC_DisableIT_MSIRDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_MSIRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable HSI ready interrupt
N  * @rmtoll CIER         HSIRDYIE      LL_RCC_DisableIT_HSIRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_HSIRDY(void)
Xstatic __inline void LL_RCC_DisableIT_HSIRDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_HSIRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable HSE ready interrupt
N  * @rmtoll CIER         HSERDYIE      LL_RCC_DisableIT_HSERDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_HSERDY(void)
Xstatic __inline void LL_RCC_DisableIT_HSERDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_HSERDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable PLL ready interrupt
N  * @rmtoll CIER         PLLRDYIE      LL_RCC_DisableIT_PLLRDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_PLLRDY(void)
Xstatic __inline void LL_RCC_DisableIT_PLLRDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_PLLRDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (5U))));
N}
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/**
N  * @brief  Disable HSI48 ready interrupt
N  * @rmtoll CIER          HSI48RDYIE    LL_RCC_DisableIT_HSI48RDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_HSI48RDY(void)
Xstatic __inline void LL_RCC_DisableIT_HSI48RDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_HSI48RDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (10U))));
N}
N#endif /* RCC_HSI48_SUPPORT */
N
N/**
N  * @brief  Disable PLLSAI1 ready interrupt
N  * @rmtoll CIER         PLLSAI1RDYIE  LL_RCC_DisableIT_PLLSAI1RDY
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_PLLSAI1RDY(void)
Xstatic __inline void LL_RCC_DisableIT_PLLSAI1RDY(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_PLLSAI1RDYIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (6U))));
N}
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S/**
S  * @brief  Disable PLLSAI2 ready interrupt
S  * @rmtoll CIER         PLLSAI2RDYIE  LL_RCC_DisableIT_PLLSAI2RDY
S  * @retval None
S  */
S__STATIC_INLINE void LL_RCC_DisableIT_PLLSAI2RDY(void)
S{
S  CLEAR_BIT(RCC->CIER, RCC_CIER_PLLSAI2RDYIE);
S}
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N/**
N  * @brief  Disable LSE clock security system interrupt
N  * @rmtoll CIER         LSECSSIE      LL_RCC_DisableIT_LSECSS
N  * @retval None
N  */
N__STATIC_INLINE void LL_RCC_DisableIT_LSECSS(void)
Xstatic __inline void LL_RCC_DisableIT_LSECSS(void)
N{
N  CLEAR_BIT(RCC->CIER, RCC_CIER_LSECSSIE);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Checks if LSI ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         LSIRDYIE      LL_RCC_IsEnabledIT_LSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_LSIRDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_LSIRDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_LSIRDYIE) == (RCC_CIER_LSIRDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Checks if LSE ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         LSERDYIE      LL_RCC_IsEnabledIT_LSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_LSERDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_LSERDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_LSERDYIE) == (RCC_CIER_LSERDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Checks if MSI ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         MSIRDYIE      LL_RCC_IsEnabledIT_MSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_MSIRDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_MSIRDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_MSIRDYIE) == (RCC_CIER_MSIRDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Checks if HSI ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         HSIRDYIE      LL_RCC_IsEnabledIT_HSIRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_HSIRDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_HSIRDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_HSIRDYIE) == (RCC_CIER_HSIRDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Checks if HSE ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         HSERDYIE      LL_RCC_IsEnabledIT_HSERDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_HSERDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_HSERDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_HSERDYIE) == (RCC_CIER_HSERDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Checks if PLL ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         PLLRDYIE      LL_RCC_IsEnabledIT_PLLRDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_PLLRDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_PLLRDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_PLLRDYIE) == (RCC_CIER_PLLRDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/**
N  * @brief  Checks if HSI48 ready interrupt source is enabled or disabled.
N  * @rmtoll CIER          HSI48RDYIE    LL_RCC_IsEnabledIT_HSI48RDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_HSI48RDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_HSI48RDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_HSI48RDYIE) == (RCC_CIER_HSI48RDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N#endif /* RCC_HSI48_SUPPORT */
N
N/**
N  * @brief  Checks if PLLSAI1 ready interrupt source is enabled or disabled.
N  * @rmtoll CIER         PLLSAI1RDYIE  LL_RCC_IsEnabledIT_PLLSAI1RDY
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_PLLSAI1RDY(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_PLLSAI1RDY(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_PLLSAI1RDYIE) == (RCC_CIER_PLLSAI1RDYIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N#if defined(RCC_PLLSAI2_SUPPORT)
X#if 0L
S/**
S  * @brief  Checks if PLLSAI2 ready interrupt source is enabled or disabled.
S  * @rmtoll CIER         PLLSAI2RDYIE  LL_RCC_IsEnabledIT_PLLSAI2RDY
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_PLLSAI2RDY(void)
S{
S  return (READ_BIT(RCC->CIER, RCC_CIER_PLLSAI2RDYIE) == (RCC_CIER_PLLSAI2RDYIE));
S}
N#endif /* RCC_PLLSAI2_SUPPORT */
N
N/**
N  * @brief  Checks if LSECSS interrupt source is enabled or disabled.
N  * @rmtoll CIER         LSECSSIE      LL_RCC_IsEnabledIT_LSECSS
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_RCC_IsEnabledIT_LSECSS(void)
Xstatic __inline uint32_t LL_RCC_IsEnabledIT_LSECSS(void)
N{
N  return (READ_BIT(RCC->CIER, RCC_CIER_LSECSSIE) == (RCC_CIER_LSECSSIE));
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->CIER) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup RCC_LL_EF_Init De-initialization function
N  * @{
N  */
NErrorStatus LL_RCC_DeInit(void);
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LL_EF_Get_Freq Get system and peripherals clocks frequency functions
N  * @{
N  */
Nvoid        LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks);
Nuint32_t    LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource);
N#if defined(UART4) || defined(UART5)
X#if 0L || 0L
Suint32_t    LL_RCC_GetUARTClockFreq(uint32_t UARTxSource);
N#endif /* UART4 || UART5 */
Nuint32_t    LL_RCC_GetI2CClockFreq(uint32_t I2CxSource);
Nuint32_t    LL_RCC_GetLPUARTClockFreq(uint32_t LPUARTxSource);
Nuint32_t    LL_RCC_GetLPTIMClockFreq(uint32_t LPTIMxSource);
Nuint32_t    LL_RCC_GetSAIClockFreq(uint32_t SAIxSource);
N#if defined(RCC_CCIPR2_SDMMCSEL)
X#if 0L
Suint32_t    LL_RCC_GetSDMMCKernelClockFreq(uint32_t SDMMCxSource);
N#endif
Nuint32_t    LL_RCC_GetSDMMCClockFreq(uint32_t SDMMCxSource);
Nuint32_t    LL_RCC_GetRNGClockFreq(uint32_t RNGxSource);
N#if defined(USB_OTG_FS) || defined(USB)
X#if 0L || 0L
Suint32_t    LL_RCC_GetUSBClockFreq(uint32_t USBxSource);
N#endif /* USB_OTG_FS || USB */
Nuint32_t    LL_RCC_GetADCClockFreq(uint32_t ADCxSource);
N#if defined(SWPMI1)
X#if 1L
Nuint32_t    LL_RCC_GetSWPMIClockFreq(uint32_t SWPMIxSource);
N#endif /* SWPMI1 */
N#if defined(DFSDM1_Channel0)
X#if 0L
Suint32_t    LL_RCC_GetDFSDMClockFreq(uint32_t DFSDMxSource);
S#if defined(RCC_CCIPR2_DFSDM1SEL)
Suint32_t    LL_RCC_GetDFSDMAudioClockFreq(uint32_t DFSDMxSource);
S#endif /* RCC_CCIPR2_DFSDM1SEL */
N#endif /* DFSDM1_Channel0 */
N#if defined(LTDC)
X#if 0L
Suint32_t    LL_RCC_GetLTDCClockFreq(uint32_t LTDCxSource);
N#endif /* LTDC */
N#if defined(DSI)
X#if 0L
Suint32_t    LL_RCC_GetDSIClockFreq(uint32_t DSIxSource);
N#endif /* DSI */
N#if defined(OCTOSPI1)
X#if 0L
Suint32_t    LL_RCC_GetOCTOSPIClockFreq(uint32_t OCTOSPIxSource);
N#endif /* OCTOSPI1 */
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* defined(RCC) */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_RCC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 8 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_bus.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_bus.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_bus.h
N  * @author  MCD Application Team
N  * @brief   Header file of BUS LL module.
N
N  @verbatim
N                      ##### RCC Limitations #####
N  ==============================================================================
N    [..]
N      A delay between an RCC peripheral clock enable and the effective peripheral
N      enabling should be taken into account in order to manage the peripheral read/write
N      from/to registers.
N      (+) This delay depends on the peripheral mapping.
N        (++) AHB & APB peripherals, 1 dummy read is necessary
N
N    [..]
N      Workarounds:
N      (#) For AHB & APB peripherals, a dummy read to the peripheral register has been
N          inserted in each LL_{BUS}_GRP{x}_EnableClock() function.
N
N  @endverbatim
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_BUS_H
N#define __STM32L4xx_LL_BUS_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined(RCC)
X#if 1L
N
N/** @defgroup BUS_LL BUS
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup BUS_LL_Exported_Constants BUS Exported Constants
N  * @{
N  */
N
N/** @defgroup BUS_LL_EC_AHB1_GRP1_PERIPH  AHB1 GRP1 PERIPH
N  * @{
N  */
N#define LL_AHB1_GRP1_PERIPH_ALL            0xFFFFFFFFU
N#define LL_AHB1_GRP1_PERIPH_DMA1           RCC_AHB1ENR_DMA1EN
N#define LL_AHB1_GRP1_PERIPH_DMA2           RCC_AHB1ENR_DMA2EN
N#if defined(DMAMUX1)
X#if 0L
S#define LL_AHB1_GRP1_PERIPH_DMAMUX1        RCC_AHB1ENR_DMAMUX1EN
N#endif /* DMAMUX1 */
N#define LL_AHB1_GRP1_PERIPH_FLASH          RCC_AHB1ENR_FLASHEN
N#define LL_AHB1_GRP1_PERIPH_CRC            RCC_AHB1ENR_CRCEN
N#define LL_AHB1_GRP1_PERIPH_TSC            RCC_AHB1ENR_TSCEN
N#if defined(DMA2D)
X#if 0L
S#define LL_AHB1_GRP1_PERIPH_DMA2D          RCC_AHB1ENR_DMA2DEN
N#endif /* DMA2D */
N#if defined(GFXMMU)
X#if 0L
S#define LL_AHB1_GRP1_PERIPH_GFXMMU         RCC_AHB1ENR_GFXMMUEN
N#endif /* GFXMMU */
N#define LL_AHB1_GRP1_PERIPH_SRAM1          RCC_AHB1SMENR_SRAM1SMEN
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EC_AHB2_GRP1_PERIPH  AHB2 GRP1 PERIPH
N  * @{
N  */
N#define LL_AHB2_GRP1_PERIPH_ALL            0xFFFFFFFFU
N#define LL_AHB2_GRP1_PERIPH_GPIOA          RCC_AHB2ENR_GPIOAEN
N#define LL_AHB2_GRP1_PERIPH_GPIOB          RCC_AHB2ENR_GPIOBEN
N#define LL_AHB2_GRP1_PERIPH_GPIOC          RCC_AHB2ENR_GPIOCEN
N#if defined(GPIOD)
X#if 1L
N#define LL_AHB2_GRP1_PERIPH_GPIOD          RCC_AHB2ENR_GPIODEN
N#endif /*GPIOD*/
N#if defined(GPIOE)
X#if 1L
N#define LL_AHB2_GRP1_PERIPH_GPIOE          RCC_AHB2ENR_GPIOEEN
N#endif /*GPIOE*/
N#if defined(GPIOF)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_GPIOF          RCC_AHB2ENR_GPIOFEN
N#endif /* GPIOF */
N#if defined(GPIOG)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_GPIOG          RCC_AHB2ENR_GPIOGEN
N#endif /* GPIOG */
N#define LL_AHB2_GRP1_PERIPH_GPIOH          RCC_AHB2ENR_GPIOHEN
N#if defined(GPIOI)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_GPIOI          RCC_AHB2ENR_GPIOIEN
N#endif /* GPIOI */
N#if defined(USB_OTG_FS)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_OTGFS          RCC_AHB2ENR_OTGFSEN
N#endif /* USB_OTG_FS */
N#define LL_AHB2_GRP1_PERIPH_ADC            RCC_AHB2ENR_ADCEN
N#if defined(DCMI)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_DCMI           RCC_AHB2ENR_DCMIEN
N#endif /* DCMI */
N#if defined(AES)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_AES            RCC_AHB2ENR_AESEN
N#endif /* AES */
N#if defined(HASH)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_HASH           RCC_AHB2ENR_HASHEN
N#endif /* HASH */
N#define LL_AHB2_GRP1_PERIPH_RNG            RCC_AHB2ENR_RNGEN
N#if defined(OCTOSPIM)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_OSPIM          RCC_AHB2ENR_OSPIMEN
N#endif /* OCTOSPIM */
N#if defined(SDMMC1) && defined(RCC_AHB2ENR_SDMMC1EN)
X#if 1L && 0L
S#define LL_AHB2_GRP1_PERIPH_SDMMC1         RCC_AHB2ENR_SDMMC1EN
N#endif /* SDMMC1 && RCC_AHB2ENR_SDMMC1EN */
N#define LL_AHB2_GRP1_PERIPH_SRAM2          RCC_AHB2SMENR_SRAM2SMEN
N#if defined(SRAM3_BASE)
X#if 0L
S#define LL_AHB2_GRP1_PERIPH_SRAM3          RCC_AHB2SMENR_SRAM3SMEN
N#endif /* SRAM3_BASE */
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EC_AHB3_GRP1_PERIPH  AHB3 GRP1 PERIPH
N  * @{
N  */
N#define LL_AHB3_GRP1_PERIPH_ALL            0xFFFFFFFFU
N#if defined(FMC_Bank1_R)
X#if 0L
S#define LL_AHB3_GRP1_PERIPH_FMC            RCC_AHB3ENR_FMCEN
N#endif /* FMC_Bank1_R */
N#if defined(QUADSPI)
X#if 1L
N#define LL_AHB3_GRP1_PERIPH_QSPI           RCC_AHB3ENR_QSPIEN
N#endif /* QUADSPI */
N#if defined(OCTOSPI1)
X#if 0L
S#define LL_AHB3_GRP1_PERIPH_OSPI1          RCC_AHB3ENR_OSPI1EN
N#endif /* OCTOSPI1 */
N#if defined(OCTOSPI2)
X#if 0L
S#define LL_AHB3_GRP1_PERIPH_OSPI2          RCC_AHB3ENR_OSPI2EN
N#endif /* OCTOSPI2 */
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EC_APB1_GRP1_PERIPH  APB1 GRP1 PERIPH
N  * @{
N  */
N#define LL_APB1_GRP1_PERIPH_ALL            0xFFFFFFFFU
N#define LL_APB1_GRP1_PERIPH_TIM2           RCC_APB1ENR1_TIM2EN
N#if defined(TIM3)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_TIM3           RCC_APB1ENR1_TIM3EN
N#endif /* TIM3 */
N#if defined(TIM4)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_TIM4           RCC_APB1ENR1_TIM4EN
N#endif /* TIM4 */
N#if defined(TIM5)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_TIM5           RCC_APB1ENR1_TIM5EN
N#endif /* TIM5 */
N#define LL_APB1_GRP1_PERIPH_TIM6           RCC_APB1ENR1_TIM6EN
N#define LL_APB1_GRP1_PERIPH_TIM7           RCC_APB1ENR1_TIM7EN
N#if defined(LCD)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_LCD            RCC_APB1ENR1_LCDEN
N#endif /* LCD */
N#if defined(RCC_APB1ENR1_RTCAPBEN)
X#if 1L
N#define LL_APB1_GRP1_PERIPH_RTCAPB         RCC_APB1ENR1_RTCAPBEN
N#endif /* RCC_APB1ENR1_RTCAPBEN */
N#define LL_APB1_GRP1_PERIPH_WWDG           RCC_APB1ENR1_WWDGEN
N#if defined(SPI2)
X#if 1L
N#define LL_APB1_GRP1_PERIPH_SPI2           RCC_APB1ENR1_SPI2EN
N#endif /* SPI2 */
N#define LL_APB1_GRP1_PERIPH_SPI3           RCC_APB1ENR1_SPI3EN
N#define LL_APB1_GRP1_PERIPH_USART2         RCC_APB1ENR1_USART2EN
N#if defined(USART3)
X#if 1L
N#define LL_APB1_GRP1_PERIPH_USART3         RCC_APB1ENR1_USART3EN
N#endif /* USART3 */
N#if defined(UART4)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_UART4          RCC_APB1ENR1_UART4EN
N#endif /* UART4 */
N#if defined(UART5)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_UART5          RCC_APB1ENR1_UART5EN
N#endif /* UART5 */
N#define LL_APB1_GRP1_PERIPH_I2C1           RCC_APB1ENR1_I2C1EN
N#if defined(I2C2)
X#if 1L
N#define LL_APB1_GRP1_PERIPH_I2C2           RCC_APB1ENR1_I2C2EN
N#endif /* I2C2 */
N#define LL_APB1_GRP1_PERIPH_I2C3           RCC_APB1ENR1_I2C3EN
N#if defined(CRS)
X#if 1L
N#define LL_APB1_GRP1_PERIPH_CRS            RCC_APB1ENR1_CRSEN
N#endif /* CRS */
N#define LL_APB1_GRP1_PERIPH_CAN1           RCC_APB1ENR1_CAN1EN
N#if defined(CAN2)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_CAN2           RCC_APB1ENR1_CAN2EN
N#endif /* CAN2 */
N#if defined(USB)
X#if 0L
S#define LL_APB1_GRP1_PERIPH_USB            RCC_APB1ENR1_USBFSEN
N#endif /* USB */
N#define LL_APB1_GRP1_PERIPH_PWR            RCC_APB1ENR1_PWREN
N#define LL_APB1_GRP1_PERIPH_DAC1           RCC_APB1ENR1_DAC1EN
N#define LL_APB1_GRP1_PERIPH_OPAMP          RCC_APB1ENR1_OPAMPEN
N#define LL_APB1_GRP1_PERIPH_LPTIM1         RCC_APB1ENR1_LPTIM1EN
N/**
N  * @}
N  */
N
N
N/** @defgroup BUS_LL_EC_APB1_GRP2_PERIPH  APB1 GRP2 PERIPH
N  * @{
N  */
N#define LL_APB1_GRP2_PERIPH_ALL            0xFFFFFFFFU
N#define LL_APB1_GRP2_PERIPH_LPUART1        RCC_APB1ENR2_LPUART1EN
N#if defined(I2C4)
X#if 0L
S#define LL_APB1_GRP2_PERIPH_I2C4           RCC_APB1ENR2_I2C4EN
N#endif /* I2C4 */
N#if defined(SWPMI1)
X#if 1L
N#define LL_APB1_GRP2_PERIPH_SWPMI1         RCC_APB1ENR2_SWPMI1EN
N#endif /* SWPMI1 */
N#define LL_APB1_GRP2_PERIPH_LPTIM2         RCC_APB1ENR2_LPTIM2EN
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EC_APB2_GRP1_PERIPH  APB2 GRP1 PERIPH
N  * @{
N  */
N#define LL_APB2_GRP1_PERIPH_ALL            0xFFFFFFFFU
N#define LL_APB2_GRP1_PERIPH_SYSCFG         RCC_APB2ENR_SYSCFGEN
N#define LL_APB2_GRP1_PERIPH_FW             RCC_APB2ENR_FWEN
N#if defined(SDMMC1) && defined(RCC_APB2ENR_SDMMC1EN)
X#if 1L && 1L
N#define LL_APB2_GRP1_PERIPH_SDMMC1         RCC_APB2ENR_SDMMC1EN
N#endif /* SDMMC1 && RCC_APB2ENR_SDMMC1EN */
N#define LL_APB2_GRP1_PERIPH_TIM1           RCC_APB2ENR_TIM1EN
N#define LL_APB2_GRP1_PERIPH_SPI1           RCC_APB2ENR_SPI1EN
N#if defined(TIM8)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_TIM8           RCC_APB2ENR_TIM8EN
N#endif /* TIM8 */
N#define LL_APB2_GRP1_PERIPH_USART1         RCC_APB2ENR_USART1EN
N#define LL_APB2_GRP1_PERIPH_TIM15          RCC_APB2ENR_TIM15EN
N#define LL_APB2_GRP1_PERIPH_TIM16          RCC_APB2ENR_TIM16EN
N#if defined(TIM17)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_TIM17          RCC_APB2ENR_TIM17EN
N#endif /* TIM17 */
N#define LL_APB2_GRP1_PERIPH_SAI1           RCC_APB2ENR_SAI1EN
N#if defined(SAI2)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_SAI2           RCC_APB2ENR_SAI2EN
N#endif /* SAI2 */
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_DFSDM1         RCC_APB2ENR_DFSDM1EN
N#endif /* DFSDM1_Channel0 */
N#if defined(LTDC)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_LTDC           RCC_APB2ENR_LTDCEN
N#endif /* LTDC */
N#if defined(DSI)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_DSI            RCC_APB2ENR_DSIEN
N#endif /* DSI */
N/**
N  * @}
N  */
N
N/** Legacy definitions for compatibility purpose
N@cond 0
N*/
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define LL_APB2_GRP1_PERIPH_DFSDM          LL_APB2_GRP1_PERIPH_DFSDM1
N#endif /* DFSDM1_Channel0 */
N/**
N@endcond
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup BUS_LL_Exported_Functions BUS Exported Functions
N  * @{
N  */
N
N/** @defgroup BUS_LL_EF_AHB1 AHB1
N  * @{
N  */
N
N/**
N  * @brief  Enable AHB1 peripherals clock.
N  * @rmtoll AHB1ENR      DMA1EN        LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      DMA2EN        LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      DMAMUX1EN     LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      FLASHEN       LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      CRCEN         LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      TSCEN         LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      DMA2DEN       LL_AHB1_GRP1_EnableClock\n
N  *         AHB1ENR      GFXMMUEN      LL_AHB1_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
Xstatic __inline void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHB1ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1ENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1ENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if AHB1 peripheral clock is enabled or not
N  * @rmtoll AHB1ENR      DMA1EN        LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      DMA2EN        LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      DMAMUX1EN     LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      FLASHEN       LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      CRCEN         LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      TSCEN         LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      DMA2DEN       LL_AHB1_GRP1_IsEnabledClock\n
N  *         AHB1ENR      GFXMMUEN      LL_AHB1_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t LL_AHB1_GRP1_IsEnabledClock(uint32_t Periphs)
Xstatic __inline uint32_t LL_AHB1_GRP1_IsEnabledClock(uint32_t Periphs)
N{
N  return (READ_BIT(RCC->AHB1ENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1ENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable AHB1 peripherals clock.
N  * @rmtoll AHB1ENR      DMA1EN        LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      DMA2EN        LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      DMAMUX1EN     LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      FLASHEN       LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      CRCEN         LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      TSCEN         LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      DMA2DEN       LL_AHB1_GRP1_DisableClock\n
N  *         AHB1ENR      GFXMMUEN      LL_AHB1_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB1_GRP1_DisableClock(uint32_t Periphs)
Xstatic __inline void LL_AHB1_GRP1_DisableClock(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB1ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1ENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force AHB1 peripherals reset.
N  * @rmtoll AHB1RSTR     DMA1RST       LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     DMA2RST       LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     DMAMUX1RST     LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     FLASHRST      LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     CRCRST        LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     TSCRST        LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     DMA2DRST      LL_AHB1_GRP1_ForceReset\n
N  *         AHB1RSTR     GFXMMURST     LL_AHB1_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_ALL
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB1_GRP1_ForceReset(uint32_t Periphs)
Xstatic __inline void LL_AHB1_GRP1_ForceReset(uint32_t Periphs)
N{
N  SET_BIT(RCC->AHB1RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1RSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release AHB1 peripherals reset.
N  * @rmtoll AHB1RSTR     DMA1RST       LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     DMA2RST       LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     DMAMUX1RST     LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     FLASHRST      LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     CRCRST        LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     TSCRST        LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     DMA2DRST      LL_AHB1_GRP1_ReleaseReset\n
N  *         AHB1RSTR     GFXMMURST     LL_AHB1_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_ALL
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB1_GRP1_ReleaseReset(uint32_t Periphs)
Xstatic __inline void LL_AHB1_GRP1_ReleaseReset(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB1RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1RSTR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Enable AHB1 peripheral clocks in Sleep and Stop modes
N  * @rmtoll AHB1SMENR    DMA1SMEN      LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    DMA2SMEN      LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    DMAMUX1SMEN   LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    FLASHSMEN     LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    SRAM1SMEN     LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    CRCSMEN       LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    TSCSMEN       LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    DMA2DSMEN     LL_AHB1_GRP1_EnableClockStopSleep\n
N  *         AHB1SMENR    GFXMMUSMEN    LL_AHB1_GRP1_EnableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_SRAM1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB1_GRP1_EnableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_AHB1_GRP1_EnableClockStopSleep(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHB1SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1SMENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHB1SMENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1SMENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Disable AHB1 peripheral clocks in Sleep and Stop modes
N  * @rmtoll AHB1SMENR    DMA1SMEN      LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    DMA2SMEN      LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    DMAMUX1SMEN   LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    FLASHSMEN     LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    SRAM1SMEN     LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    CRCSMEN       LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    TSCSMEN       LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    DMA2DSMEN     LL_AHB1_GRP1_DisableClockStopSleep\n
N  *         AHB1SMENR    GFXMMUSMEN    LL_AHB1_GRP1_DisableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMAMUX1 (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_FLASH
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_SRAM1
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_CRC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA2D (*)
N  *         @arg @ref LL_AHB1_GRP1_PERIPH_GFXMMU (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB1_GRP1_DisableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_AHB1_GRP1_DisableClockStopSleep(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB1SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB1SMENR) &= ~(Periphs));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EF_AHB2 AHB2
N  * @{
N  */
N
N/**
N  * @brief  Enable AHB2 peripherals clock.
N  * @rmtoll AHB2ENR      GPIOAEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOBEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOCEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIODEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOEEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOFEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOGEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOHEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      GPIOIEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      OTGFSEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      ADCEN         LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      DCMIEN        LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      AESEN         LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      HASHEN        LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      RNGEN         LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      OSPIMEN       LL_AHB2_GRP1_EnableClock\n
N  *         AHB2ENR      SDMMC1EN      LL_AHB2_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
Xstatic __inline void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHB2ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2ENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2ENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if AHB2 peripheral clock is enabled or not
N  * @rmtoll AHB2ENR      GPIOAEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOBEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOCEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIODEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOEEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOFEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOGEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOHEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      GPIOIEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      OTGFSEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      ADCEN         LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      DCMIEN        LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      AESEN         LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      HASHEN        LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      RNGEN         LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      OSPIMEN       LL_AHB2_GRP1_IsEnabledClock\n
N  *         AHB2ENR      SDMMC1EN      LL_AHB2_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t LL_AHB2_GRP1_IsEnabledClock(uint32_t Periphs)
Xstatic __inline uint32_t LL_AHB2_GRP1_IsEnabledClock(uint32_t Periphs)
N{
N  return (READ_BIT(RCC->AHB2ENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2ENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable AHB2 peripherals clock.
N  * @rmtoll AHB2ENR      GPIOAEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOBEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOCEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIODEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOEEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOFEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOGEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOHEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      GPIOIEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      OTGFSEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      ADCEN         LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      DCMIEN        LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      AESEN         LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      HASHEN        LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      RNGEN         LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      OSPIMEN       LL_AHB2_GRP1_DisableClock\n
N  *         AHB2ENR      SDMMC1EN      LL_AHB2_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB2_GRP1_DisableClock(uint32_t Periphs)
Xstatic __inline void LL_AHB2_GRP1_DisableClock(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB2ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2ENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force AHB2 peripherals reset.
N  * @rmtoll AHB2RSTR     GPIOARST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOBRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOCRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIODRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOERST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOFRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOGRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOHRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     GPIOIRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     OTGFSRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     ADCRST        LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     DCMIRST       LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     AESRST        LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     HASHRST       LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     RNGRST        LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     OSPIMRST      LL_AHB2_GRP1_ForceReset\n
N  *         AHB2RSTR     SDMMC1RST     LL_AHB2_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ALL
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB2_GRP1_ForceReset(uint32_t Periphs)
Xstatic __inline void LL_AHB2_GRP1_ForceReset(uint32_t Periphs)
N{
N  SET_BIT(RCC->AHB2RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2RSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release AHB2 peripherals reset.
N  * @rmtoll AHB2RSTR     GPIOARST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOBRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOCRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIODRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOERST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOFRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOGRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOHRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     GPIOIRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     OTGFSRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     ADCRST        LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     DCMIRST       LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     AESRST        LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     HASHRST       LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     RNGRST        LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     OSPIMRST      LL_AHB2_GRP1_ReleaseReset\n
N  *         AHB2RSTR     SDMMC1RST     LL_AHB2_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ALL
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB2_GRP1_ReleaseReset(uint32_t Periphs)
Xstatic __inline void LL_AHB2_GRP1_ReleaseReset(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB2RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2RSTR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Enable AHB2 peripheral clocks in Sleep and Stop modes
N  * @rmtoll AHB2SMENR    GPIOASMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOBSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOCSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIODSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOESMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOFSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOGSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOHSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    GPIOISMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    SRAM2SMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    SRAM3SMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    OTGFSSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    ADCSMEN       LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    DCMISMEN      LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    AESSMEN       LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    HASHSMEN      LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    RNGSMEN       LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    OSPIMSMEN     LL_AHB2_GRP1_EnableClockStopSleep\n
N  *         AHB2SMENR    SDMMC1SMEN    LL_AHB2_GRP1_EnableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SRAM2
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SRAM3 (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB2_GRP1_EnableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_AHB2_GRP1_EnableClockStopSleep(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHB2SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2SMENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHB2SMENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2SMENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Disable AHB2 peripheral clocks in Sleep and Stop modes
N  * @rmtoll AHB2SMENR    GPIOASMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOBSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOCSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIODSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOESMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOFSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOGSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOHSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    GPIOISMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    SRAM2SMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    SRAM3SMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    OTGFSSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    ADCSMEN       LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    DCMISMEN      LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    AESSMEN       LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    HASHSMEN      LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    RNGSMEN       LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    OSPIMSMEN     LL_AHB2_GRP1_DisableClockStopSleep\n
N  *         AHB2SMENR    SDMMC1SMEN    LL_AHB2_GRP1_DisableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOB
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOD (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOE (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOF (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOG (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SRAM2
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SRAM3 (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OTGFS (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADC
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_DCMI (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_HASH (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_RNG
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_OSPIM (*)
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_SDMMC1 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB2_GRP1_DisableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_AHB2_GRP1_DisableClockStopSleep(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB2SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB2SMENR) &= ~(Periphs));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EF_AHB3 AHB3
N  * @{
N  */
N
N/**
N  * @brief  Enable AHB3 peripherals clock.
N  * @rmtoll AHB3ENR      FMCEN         LL_AHB3_GRP1_EnableClock\n
N  *         AHB3ENR      QSPIEN        LL_AHB3_GRP1_EnableClock\n
N  *         AHB3ENR      OSPI1EN       LL_AHB3_GRP1_EnableClock\n
N  *         AHB3ENR      OSPI2EN       LL_AHB3_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
Xstatic __inline void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHB3ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3ENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3ENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if AHB3 peripheral clock is enabled or not
N  * @rmtoll AHB3ENR      FMCEN         LL_AHB3_GRP1_IsEnabledClock\n
N  *         AHB3ENR      QSPIEN        LL_AHB3_GRP1_IsEnabledClock\n
N  *         AHB3ENR      OSPI1EN       LL_AHB3_GRP1_IsEnabledClock\n
N  *         AHB3ENR      OSPI2EN       LL_AHB3_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t LL_AHB3_GRP1_IsEnabledClock(uint32_t Periphs)
Xstatic __inline uint32_t LL_AHB3_GRP1_IsEnabledClock(uint32_t Periphs)
N{
N  return (READ_BIT(RCC->AHB3ENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3ENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable AHB3 peripherals clock.
N  * @rmtoll AHB3ENR      FMCEN         LL_AHB3_GRP1_DisableClock\n
N  *         AHB3ENR      QSPIEN        LL_AHB3_GRP1_DisableClock\n
N  *         AHB3ENR      OSPI1EN       LL_AHB3_GRP1_DisableClock\n
N  *         AHB3ENR      OSPI2EN       LL_AHB3_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB3_GRP1_DisableClock(uint32_t Periphs)
Xstatic __inline void LL_AHB3_GRP1_DisableClock(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB3ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3ENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force AHB3 peripherals reset.
N  * @rmtoll AHB3RSTR     FMCRST        LL_AHB3_GRP1_ForceReset\n
N  *         AHB3RSTR     QSPIRST       LL_AHB3_GRP1_ForceReset\n
N  *         AHB3RSTR     OSPI1RST      LL_AHB3_GRP1_ForceReset\n
N  *         AHB3RSTR     OSPI2RST      LL_AHB3_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_ALL
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB3_GRP1_ForceReset(uint32_t Periphs)
Xstatic __inline void LL_AHB3_GRP1_ForceReset(uint32_t Periphs)
N{
N  SET_BIT(RCC->AHB3RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3RSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release AHB3 peripherals reset.
N  * @rmtoll AHB3RSTR     FMCRST        LL_AHB3_GRP1_ReleaseReset\n
N  *         AHB3RSTR     QSPIRST       LL_AHB3_GRP1_ReleaseReset\n
N  *         AHB3RSTR     OSPI1RST      LL_AHB3_GRP1_ReleaseReset\n
N  *         AHB3RSTR     OSPI2RST      LL_AHB3_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB2_GRP1_PERIPH_ALL
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
Xstatic __inline void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB3RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3RSTR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Enable AHB3 peripheral clocks in Sleep and Stop modes
N  * @rmtoll AHB3SMENR    FMCSMEN       LL_AHB3_GRP1_EnableClockStopSleep\n
N  *         AHB3SMENR    QSPISMEN      LL_AHB3_GRP1_EnableClockStopSleep\n
N  *         AHB3SMENR    OSPI1SMEN     LL_AHB3_GRP1_EnableClockStopSleep\n
N  *         AHB3SMENR    OSPI2SMEN     LL_AHB3_GRP1_EnableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB3_GRP1_EnableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_AHB3_GRP1_EnableClockStopSleep(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->AHB3SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3SMENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->AHB3SMENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3SMENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Disable AHB3 peripheral clocks in Sleep and Stop modes
N  * @rmtoll AHB3SMENR    FMCSMEN       LL_AHB3_GRP1_DisableClockStopSleep\n
N  *         AHB3SMENR    QSPISMEN      LL_AHB3_GRP1_DisableClockStopSleep\n
N  *         AHB3SMENR    OSPI1SMEN     LL_AHB3_GRP1_DisableClockStopSleep\n
N  *         AHB3SMENR    OSPI2SMEN     LL_AHB3_GRP1_DisableClockStopSleep\n
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_QSPI (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI1 (*)
N  *         @arg @ref LL_AHB3_GRP1_PERIPH_OSPI2 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_AHB3_GRP1_DisableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_AHB3_GRP1_DisableClockStopSleep(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->AHB3SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->AHB3SMENR) &= ~(Periphs));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EF_APB1 APB1
N  * @{
N  */
N
N/**
N  * @brief  Enable APB1 peripherals clock.
N  * @rmtoll APB1ENR1     TIM2EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     TIM3EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     TIM4EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     TIM5EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     TIM6EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     TIM7EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     LCDEN         LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     RTCAPBEN      LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     WWDGEN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     SPI2EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     SPI3EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     USART2EN      LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     USART3EN      LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     UART4EN       LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     UART5EN       LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     I2C1EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     I2C2EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     I2C3EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     CRSEN         LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     CAN1EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     USBFSEN       LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     CAN2EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     PWREN         LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     DAC1EN        LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     OPAMPEN       LL_APB1_GRP1_EnableClock\n
N  *         APB1ENR1     LPTIM1EN      LL_APB1_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_RTCAPB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB1ENR1, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR1) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR1) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Enable APB1 peripherals clock.
N  * @rmtoll APB1ENR2     LPUART1EN     LL_APB1_GRP2_EnableClock\n
N  *         APB1ENR2     I2C4EN        LL_APB1_GRP2_EnableClock\n
N  *         APB1ENR2     SWPMI1EN      LL_APB1_GRP2_EnableClock\n
N  *         APB1ENR2     LPTIM2EN      LL_APB1_GRP2_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB1ENR2, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR2) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB1ENR2, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR2) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if APB1 peripheral clock is enabled or not
N  * @rmtoll APB1ENR1     TIM2EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     TIM3EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     TIM4EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     TIM5EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     TIM6EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     TIM7EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     LCDEN         LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     RTCAPBEN      LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     WWDGEN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     SPI2EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     SPI3EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     USART2EN      LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     USART3EN      LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     UART4EN       LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     UART5EN       LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     I2C1EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     I2C2EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     I2C3EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     CRSEN         LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     CAN1EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     USBFSEN       LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     CAN2EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     PWREN         LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     DAC1EN        LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     OPAMPEN       LL_APB1_GRP1_IsEnabledClock\n
N  *         APB1ENR1     LPTIM1EN      LL_APB1_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_RTCAPB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
Xstatic __inline uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
N{
N  return (READ_BIT(RCC->APB1ENR1, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR1) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Check if APB1 peripheral clock is enabled or not
N  * @rmtoll APB1ENR2     LPUART1EN     LL_APB1_GRP2_IsEnabledClock\n
N  *         APB1ENR2     I2C4EN        LL_APB1_GRP2_IsEnabledClock\n
N  *         APB1ENR2     SWPMI1EN      LL_APB1_GRP2_IsEnabledClock\n
N  *         APB1ENR2     LPTIM2EN      LL_APB1_GRP2_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t LL_APB1_GRP2_IsEnabledClock(uint32_t Periphs)
Xstatic __inline uint32_t LL_APB1_GRP2_IsEnabledClock(uint32_t Periphs)
N{
N  return (READ_BIT(RCC->APB1ENR2, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR2) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable APB1 peripherals clock.
N  * @rmtoll APB1ENR1     TIM2EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     TIM3EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     TIM4EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     TIM5EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     TIM6EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     TIM7EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     LCDEN         LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     RTCAPBEN      LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     WWDGEN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     SPI2EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     SPI3EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     USART2EN      LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     USART3EN      LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     UART4EN       LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     UART5EN       LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     I2C1EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     I2C2EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     I2C3EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     CRSEN         LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     CAN1EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     USBFSEN       LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     CAN2EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     PWREN         LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     DAC1EN        LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     OPAMPEN       LL_APB1_GRP1_DisableClock\n
N  *         APB1ENR1     LPTIM1EN      LL_APB1_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_RTCAPB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB1ENR1, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR1) &= ~(Periphs));
N}
N
N/**
N  * @brief  Disable APB1 peripherals clock.
N  * @rmtoll APB1ENR2     LPUART1EN     LL_APB1_GRP2_DisableClock\n
N  *         APB1ENR2     I2C4EN        LL_APB1_GRP2_DisableClock\n
N  *         APB1ENR2     SWPMI1EN      LL_APB1_GRP2_DisableClock\n
N  *         APB1ENR2     LPTIM2EN      LL_APB1_GRP2_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP2_DisableClock(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP2_DisableClock(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB1ENR2, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1ENR2) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force APB1 peripherals reset.
N  * @rmtoll APB1RSTR1    TIM2RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    TIM3RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    TIM4RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    TIM5RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    TIM6RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    TIM7RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    LCDRST        LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    SPI2RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    SPI3RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    USART2RST     LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    USART3RST     LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    UART4RST      LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    UART5RST      LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    I2C1RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    I2C2RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    I2C3RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    CRSRST        LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    CAN1RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    USBFSRST      LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    CAN2RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    PWRRST        LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    DAC1RST       LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    OPAMPRST      LL_APB1_GRP1_ForceReset\n
N  *         APB1RSTR1    LPTIM1RST     LL_APB1_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
N{
N  SET_BIT(RCC->APB1RSTR1, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1RSTR1) |= (Periphs));
N}
N
N/**
N  * @brief  Force APB1 peripherals reset.
N  * @rmtoll APB1RSTR2    LPUART1RST    LL_APB1_GRP2_ForceReset\n
N  *         APB1RSTR2    I2C4RST       LL_APB1_GRP2_ForceReset\n
N  *         APB1RSTR2    SWPMI1RST     LL_APB1_GRP2_ForceReset\n
N  *         APB1RSTR2    LPTIM2RST     LL_APB1_GRP2_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_ALL
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP2_ForceReset(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP2_ForceReset(uint32_t Periphs)
N{
N  SET_BIT(RCC->APB1RSTR2, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1RSTR2) |= (Periphs));
N}
N
N/**
N  * @brief  Release APB1 peripherals reset.
N  * @rmtoll APB1RSTR1    TIM2RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    TIM3RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    TIM4RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    TIM5RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    TIM6RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    TIM7RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    LCDRST        LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    SPI2RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    SPI3RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    USART2RST     LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    USART3RST     LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    UART4RST      LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    UART5RST      LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    I2C1RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    I2C2RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    I2C3RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    CRSRST        LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    CAN1RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    USBFSRST      LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    CAN2RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    PWRRST        LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    DAC1RST       LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    OPAMPRST      LL_APB1_GRP1_ReleaseReset\n
N  *         APB1RSTR1    LPTIM1RST     LL_APB1_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1RSTR1) &= ~(Periphs));
N}
N
N/**
N  * @brief  Release APB1 peripherals reset.
N  * @rmtoll APB1RSTR2    LPUART1RST    LL_APB1_GRP2_ReleaseReset\n
N  *         APB1RSTR2    I2C4RST       LL_APB1_GRP2_ReleaseReset\n
N  *         APB1RSTR2    SWPMI1RST     LL_APB1_GRP2_ReleaseReset\n
N  *         APB1RSTR2    LPTIM2RST     LL_APB1_GRP2_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_ALL
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP2_ReleaseReset(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP2_ReleaseReset(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB1RSTR2, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1RSTR2) &= ~(Periphs));
N}
N
N/**
N  * @brief  Enable APB1 peripheral clocks in Sleep and Stop modes
N  * @rmtoll APB1SMENR1   TIM2SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   TIM3SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   TIM4SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   TIM5SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   TIM6SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   TIM7SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   LCDSMEN       LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   RTCAPBSMEN    LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   WWDGSMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   SPI2SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   SPI3SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   USART2SMEN    LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   USART3SMEN    LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   UART4SMEN     LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   UART5SMEN     LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   I2C1SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   I2C2SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   I2C3SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   CRSSMEN       LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   CAN1SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   USBFSSMEN     LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   CAN2SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   PWRSMEN       LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   DAC1SMEN      LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   OPAMPSMEN     LL_APB1_GRP1_EnableClockStopSleep\n
N  *         APB1SMENR1   LPTIM1SMEN    LL_APB1_GRP1_EnableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_RTCAPB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP1_EnableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP1_EnableClockStopSleep(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB1SMENR1, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1SMENR1) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB1SMENR1, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1SMENR1) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Enable APB1 peripheral clocks in Sleep and Stop modes
N  * @rmtoll APB1SMENR2   LPUART1SMEN   LL_APB1_GRP2_EnableClockStopSleep\n
N  *         APB1SMENR2   I2C4SMEN      LL_APB1_GRP2_EnableClockStopSleep\n
N  *         APB1SMENR2   SWPMI1SMEN    LL_APB1_GRP2_EnableClockStopSleep\n
N  *         APB1SMENR2   LPTIM2SMEN    LL_APB1_GRP2_EnableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP2_EnableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP2_EnableClockStopSleep(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB1SMENR2, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1SMENR2) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB1SMENR2, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1SMENR2) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Disable APB1 peripheral clocks in Sleep and Stop modes
N  * @rmtoll APB1SMENR1   TIM2SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   TIM3SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   TIM4SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   TIM5SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   TIM6SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   TIM7SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   LCDSMEN       LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   RTCAPBSMEN    LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   WWDGSMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   SPI2SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   SPI3SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   USART2SMEN    LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   USART3SMEN    LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   UART4SMEN     LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   UART5SMEN     LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   I2C1SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   I2C2SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   I2C3SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   CRSSMEN       LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   CAN1SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   USBFSSMEN     LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   CAN2SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   PWRSMEN       LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   DAC1SMEN      LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   OPAMPSMEN     LL_APB1_GRP1_DisableClockStopSleep\n
N  *         APB1SMENR1   LPTIM1SMEN    LL_APB1_GRP1_DisableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6
N  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LCD (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_RTCAPB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_I2C3
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CRS (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
N  *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
N  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1
N  *         @arg @ref LL_APB1_GRP1_PERIPH_OPAMP
N  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP1_DisableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP1_DisableClockStopSleep(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB1SMENR1, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1SMENR1) &= ~(Periphs));
N}
N
N/**
N  * @brief  Disable APB1 peripheral clocks in Sleep and Stop modes
N  * @rmtoll APB1SMENR2   LPUART1SMEN   LL_APB1_GRP2_DisableClockStopSleep\n
N  *         APB1SMENR2   I2C4SMEN      LL_APB1_GRP2_DisableClockStopSleep\n
N  *         APB1SMENR2   SWPMI1SMEN    LL_APB1_GRP2_DisableClockStopSleep\n
N  *         APB1SMENR2   LPTIM2SMEN    LL_APB1_GRP2_DisableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
N  *         @arg @ref LL_APB1_GRP2_PERIPH_I2C4 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_SWPMI1 (*)
N  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB1_GRP2_DisableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_APB1_GRP2_DisableClockStopSleep(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB1SMENR2, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB1SMENR2) &= ~(Periphs));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup BUS_LL_EF_APB2 APB2
N  * @{
N  */
N
N/**
N  * @brief  Enable APB2 peripherals clock.
N  * @rmtoll APB2ENR      SYSCFGEN      LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      FWEN          LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      SDMMC1EN      LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      TIM1EN        LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      SPI1EN        LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      TIM8EN        LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      USART1EN      LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      TIM15EN       LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      TIM16EN       LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      TIM17EN       LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      SAI1EN        LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      SAI2EN        LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      DFSDM1EN      LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      LTDCEN        LL_APB2_GRP1_EnableClock\n
N  *         APB2ENR      DSIEN         LL_APB2_GRP1_EnableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_FW
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
Xstatic __inline void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB2ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2ENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2ENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Check if APB2 peripheral clock is enabled or not
N  * @rmtoll APB2ENR      SYSCFGEN      LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      FWEN          LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      SDMMC1EN      LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      TIM1EN        LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      SPI1EN        LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      TIM8EN        LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      USART1EN      LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      TIM15EN       LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      TIM16EN       LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      TIM17EN       LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      SAI1EN        LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      SAI2EN        LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      DFSDM1EN      LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      LTDCEN        LL_APB2_GRP1_IsEnabledClock\n
N  *         APB2ENR      DSIEN         LL_APB2_GRP1_IsEnabledClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_FW
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval State of Periphs (1 or 0).
N*/
N__STATIC_INLINE uint32_t LL_APB2_GRP1_IsEnabledClock(uint32_t Periphs)
Xstatic __inline uint32_t LL_APB2_GRP1_IsEnabledClock(uint32_t Periphs)
N{
N  return (READ_BIT(RCC->APB2ENR, Periphs) == Periphs);
X  return (((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2ENR) & (Periphs)) == Periphs);
N}
N
N/**
N  * @brief  Disable APB2 peripherals clock.
N  * @rmtoll APB2ENR      SYSCFGEN      LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      SDMMC1EN      LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      TIM1EN        LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      SPI1EN        LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      TIM8EN        LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      USART1EN      LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      TIM15EN       LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      TIM16EN       LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      TIM17EN       LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      SAI1EN        LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      SAI2EN        LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      DFSDM1EN      LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      LTDCEN        LL_APB2_GRP1_DisableClock\n
N  *         APB2ENR      DSIEN         LL_APB2_GRP1_DisableClock
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
Xstatic __inline void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB2ENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2ENR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Force APB2 peripherals reset.
N  * @rmtoll APB2RSTR     SYSCFGRST     LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     SDMMC1RST     LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     TIM1RST       LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     SPI1RST       LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     TIM8RST       LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     USART1RST     LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     TIM15RST      LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     TIM16RST      LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     TIM17RST      LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     SAI1RST       LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     SAI2RST       LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     DFSDM1RST     LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     LTDCRST       LL_APB2_GRP1_ForceReset\n
N  *         APB2RSTR     DSIRST        LL_APB2_GRP1_ForceReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_ALL
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
Xstatic __inline void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
N{
N  SET_BIT(RCC->APB2RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2RSTR) |= (Periphs));
N}
N
N/**
N  * @brief  Release APB2 peripherals reset.
N  * @rmtoll APB2RSTR     SYSCFGRST     LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     SDMMC1RST     LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     TIM1RST       LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     SPI1RST       LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     TIM8RST       LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     USART1RST     LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     TIM15RST      LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     TIM16RST      LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     TIM17RST      LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     SAI1RST       LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     SAI2RST       LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     DFSDM1RST     LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     LTDCRST       LL_APB2_GRP1_ReleaseReset\n
N  *         APB2RSTR     DSIRST        LL_APB2_GRP1_ReleaseReset
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_ALL
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
Xstatic __inline void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB2RSTR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2RSTR) &= ~(Periphs));
N}
N
N/**
N  * @brief  Enable APB2 peripheral clocks in Sleep and Stop modes
N  * @rmtoll APB2SMENR    SYSCFGSMEN    LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    SDMMC1SMEN    LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    TIM1SMEN      LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    SPI1SMEN      LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    TIM8SMEN      LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    USART1SMEN    LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    TIM15SMEN     LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    TIM16SMEN     LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    TIM17SMEN     LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    SAI1SMEN      LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    SAI2SMEN      LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    DFSDM1SMEN    LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    LTDCSMEN      LL_APB2_GRP1_EnableClockStopSleep\n
N  *         APB2SMENR    DSISMEN       LL_APB2_GRP1_EnableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB2_GRP1_EnableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_APB2_GRP1_EnableClockStopSleep(uint32_t Periphs)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  SET_BIT(RCC->APB2SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2SMENR) |= (Periphs));
N  /* Delay after an RCC peripheral clock enabling */
N  tmpreg = READ_BIT(RCC->APB2SMENR, Periphs);
X  tmpreg = ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2SMENR) & (Periphs));
N  (void)tmpreg;
N}
N
N/**
N  * @brief  Disable APB2 peripheral clocks in Sleep and Stop modes
N  * @rmtoll APB2SMENR    SYSCFGSMEN    LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    SDMMC1SMEN    LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    TIM1SMEN      LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    SPI1SMEN      LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    TIM8SMEN      LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    USART1SMEN    LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    TIM15SMEN     LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    TIM16SMEN     LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    TIM17SMEN     LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    SAI1SMEN      LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    SAI2SMEN      LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    DFSDM1SMEN    LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    LTDCSMEN      LL_APB2_GRP1_DisableClockStopSleep\n
N  *         APB2SMENR    DSISMEN       LL_APB2_GRP1_DisableClockStopSleep
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SDMMC1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16
N  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1
N  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI2 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DFSDM1 (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_LTDC (*)
N  *         @arg @ref LL_APB2_GRP1_PERIPH_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N*/
N__STATIC_INLINE void LL_APB2_GRP1_DisableClockStopSleep(uint32_t Periphs)
Xstatic __inline void LL_APB2_GRP1_DisableClockStopSleep(uint32_t Periphs)
N{
N  CLEAR_BIT(RCC->APB2SMENR, Periphs);
X  ((((RCC_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x1000UL))->APB2SMENR) &= ~(Periphs));
N}
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* defined(RCC) */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_BUS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 9 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_system.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_system.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_system.h
N  * @author  MCD Application Team
N  * @brief   Header file of SYSTEM LL module.
N  @verbatim
N  ==============================================================================
N                     ##### How to use this driver #####
N  ==============================================================================
N    [..]
N    The LL SYSTEM driver contains a set of generic APIs that can be
N    used by user:
N      (+) Some of the FLASH features need to be handled in the SYSTEM file.
N      (+) Access to DBGCMU registers
N      (+) Access to SYSCFG registers
N      (+) Access to VREFBUF registers
N
N  @endverbatim
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_SYSTEM_H
N#define __STM32L4xx_LL_SYSTEM_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (FLASH) || defined (SYSCFG) || defined (DBGMCU) || defined (VREFBUF)
X#if 1L || 1L || 1L || 1L
N
N/** @defgroup SYSTEM_LL SYSTEM
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup SYSTEM_LL_Private_Constants SYSTEM Private Constants
N  * @{
N  */
N
N/**
N * @brief Power-down in Run mode Flash key
N */
N#define FLASH_PDKEY1                  0x04152637U /*!< Flash power down key1 */
N#define FLASH_PDKEY2                  0xFAFBFCFDU /*!< Flash power down key2: used with FLASH_PDKEY1 
N                                                       to unlock the RUN_PD bit in FLASH_ACR */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SYSTEM_LL_Exported_Constants SYSTEM Exported Constants
N  * @{
N  */
N
N/** @defgroup SYSTEM_LL_EC_REMAP SYSCFG REMAP
N* @{
N*/
N#define LL_SYSCFG_REMAP_FLASH              0x00000000U                                           /*!< Main Flash memory mapped at 0x00000000              */
N#define LL_SYSCFG_REMAP_SYSTEMFLASH        SYSCFG_MEMRMP_MEM_MODE_0                              /*!< System Flash memory mapped at 0x00000000            */
N#define LL_SYSCFG_REMAP_SRAM               (SYSCFG_MEMRMP_MEM_MODE_1 | SYSCFG_MEMRMP_MEM_MODE_0) /*!< SRAM1 mapped at 0x00000000                          */
N#if defined(FMC_Bank1_R)
X#if 0L
S#define LL_SYSCFG_REMAP_FMC                SYSCFG_MEMRMP_MEM_MODE_1                              /*!< FMC bank 1 (NOR/PSRAM 1 and 2) mapped at 0x00000000 */
N#endif /* FMC_Bank1_R */
N#define LL_SYSCFG_REMAP_QUADSPI            (SYSCFG_MEMRMP_MEM_MODE_2 | SYSCFG_MEMRMP_MEM_MODE_1) /*!< QUADSPI memory mapped at 0x00000000                 */
N/**
N  * @}
N  */
N
N#if defined(SYSCFG_MEMRMP_FB_MODE)
X#if 0L
S/** @defgroup SYSTEM_LL_EC_BANKMODE SYSCFG BANK MODE
S  * @{
S  */
S#define LL_SYSCFG_BANKMODE_BANK1           0x00000000U               /*!< Flash Bank1 mapped at 0x08000000 (and aliased @0x00000000) 
S                                                                      and Flash Bank2 mapped at 0x08080000 (and aliased at 0x00080000) */
S#define LL_SYSCFG_BANKMODE_BANK2           SYSCFG_MEMRMP_FB_MODE     /*!< Flash Bank2 mapped at 0x08000000 (and aliased @0x00000000) 
S                                                                      and Flash Bank1 mapped at 0x08080000 (and aliased at 0x00080000) */
S/**
S  * @}
S  */
S
N#endif /* SYSCFG_MEMRMP_FB_MODE */
N/** @defgroup SYSTEM_LL_EC_I2C_FASTMODEPLUS SYSCFG I2C FASTMODEPLUS
N  * @{
N  */
N#define LL_SYSCFG_I2C_FASTMODEPLUS_PB6     SYSCFG_CFGR1_I2C_PB6_FMP  /*!< Enable Fast Mode Plus on PB6       */
N#define LL_SYSCFG_I2C_FASTMODEPLUS_PB7     SYSCFG_CFGR1_I2C_PB7_FMP  /*!< Enable Fast Mode Plus on PB7       */
N#if defined(SYSCFG_CFGR1_I2C_PB8_FMP)
X#if 1L
N#define LL_SYSCFG_I2C_FASTMODEPLUS_PB8     SYSCFG_CFGR1_I2C_PB8_FMP  /*!< Enable Fast Mode Plus on PB8       */
N#endif /* SYSCFG_CFGR1_I2C_PB8_FMP */
N#if defined(SYSCFG_CFGR1_I2C_PB9_FMP)
X#if 1L
N#define LL_SYSCFG_I2C_FASTMODEPLUS_PB9     SYSCFG_CFGR1_I2C_PB9_FMP  /*!< Enable Fast Mode Plus on PB9       */
N#endif /* SYSCFG_CFGR1_I2C_PB9_FMP */
N#define LL_SYSCFG_I2C_FASTMODEPLUS_I2C1    SYSCFG_CFGR1_I2C1_FMP     /*!< Enable Fast Mode Plus on I2C1 pins */
N#if defined(I2C2)
X#if 1L
N#define LL_SYSCFG_I2C_FASTMODEPLUS_I2C2    SYSCFG_CFGR1_I2C2_FMP     /*!< Enable Fast Mode Plus on I2C2 pins */
N#endif /* I2C2 */
N#define LL_SYSCFG_I2C_FASTMODEPLUS_I2C3    SYSCFG_CFGR1_I2C3_FMP     /*!< Enable Fast Mode Plus on I2C3 pins */
N#if defined(I2C4)
X#if 0L
S#define LL_SYSCFG_I2C_FASTMODEPLUS_I2C4    SYSCFG_CFGR1_I2C4_FMP     /*!< Enable Fast Mode Plus on I2C4 pins */
N#endif /* I2C4 */
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_EXTI_PORT SYSCFG EXTI PORT
N  * @{
N  */
N#define LL_SYSCFG_EXTI_PORTA               0U                        /*!< EXTI PORT A                        */
N#define LL_SYSCFG_EXTI_PORTB               1U                        /*!< EXTI PORT B                        */
N#define LL_SYSCFG_EXTI_PORTC               2U                        /*!< EXTI PORT C                        */
N#define LL_SYSCFG_EXTI_PORTD               3U                        /*!< EXTI PORT D                        */
N#define LL_SYSCFG_EXTI_PORTE               4U                        /*!< EXTI PORT E                        */
N#if defined(GPIOF)
X#if 0L
S#define LL_SYSCFG_EXTI_PORTF               5U                        /*!< EXTI PORT F                        */
N#endif /* GPIOF */
N#if defined(GPIOG)
X#if 0L
S#define LL_SYSCFG_EXTI_PORTG               6U                        /*!< EXTI PORT G                        */
N#endif /* GPIOG */
N#define LL_SYSCFG_EXTI_PORTH               7U                        /*!< EXTI PORT H                        */
N#if defined(GPIOI)
X#if 0L
S#define LL_SYSCFG_EXTI_PORTI               8U                        /*!< EXTI PORT I                        */
N#endif /* GPIOI */
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_EXTI_LINE SYSCFG EXTI LINE
N  * @{
N  */
N#define LL_SYSCFG_EXTI_LINE0               (uint32_t)(0x000FU << 16U | 0U)  /* !< EXTI_POSITION_0  | EXTICR[0] */
N#define LL_SYSCFG_EXTI_LINE1               (uint32_t)(0x00F0U << 16U | 0U)  /* !< EXTI_POSITION_4  | EXTICR[0] */
N#define LL_SYSCFG_EXTI_LINE2               (uint32_t)(0x0F00U << 16U | 0U)  /* !< EXTI_POSITION_8  | EXTICR[0] */
N#define LL_SYSCFG_EXTI_LINE3               (uint32_t)(0xF000U << 16U | 0U)  /* !< EXTI_POSITION_12 | EXTICR[0] */
N#define LL_SYSCFG_EXTI_LINE4               (uint32_t)(0x000FU << 16U | 1U)  /* !< EXTI_POSITION_0  | EXTICR[1] */
N#define LL_SYSCFG_EXTI_LINE5               (uint32_t)(0x00F0U << 16U | 1U)  /* !< EXTI_POSITION_4  | EXTICR[1] */
N#define LL_SYSCFG_EXTI_LINE6               (uint32_t)(0x0F00U << 16U | 1U)  /* !< EXTI_POSITION_8  | EXTICR[1] */
N#define LL_SYSCFG_EXTI_LINE7               (uint32_t)(0xF000U << 16U | 1U)  /* !< EXTI_POSITION_12 | EXTICR[1] */
N#define LL_SYSCFG_EXTI_LINE8               (uint32_t)(0x000FU << 16U | 2U)  /* !< EXTI_POSITION_0  | EXTICR[2] */
N#define LL_SYSCFG_EXTI_LINE9               (uint32_t)(0x00F0U << 16U | 2U)  /* !< EXTI_POSITION_4  | EXTICR[2] */
N#define LL_SYSCFG_EXTI_LINE10              (uint32_t)(0x0F00U << 16U | 2U)  /* !< EXTI_POSITION_8  | EXTICR[2] */
N#define LL_SYSCFG_EXTI_LINE11              (uint32_t)(0xF000U << 16U | 2U)  /* !< EXTI_POSITION_12 | EXTICR[2] */
N#define LL_SYSCFG_EXTI_LINE12              (uint32_t)(0x000FU << 16U | 3U)  /* !< EXTI_POSITION_0  | EXTICR[3] */
N#define LL_SYSCFG_EXTI_LINE13              (uint32_t)(0x00F0U << 16U | 3U)  /* !< EXTI_POSITION_4  | EXTICR[3] */
N#define LL_SYSCFG_EXTI_LINE14              (uint32_t)(0x0F00U << 16U | 3U)  /* !< EXTI_POSITION_8  | EXTICR[3] */
N#define LL_SYSCFG_EXTI_LINE15              (uint32_t)(0xF000U << 16U | 3U)  /* !< EXTI_POSITION_12 | EXTICR[3] */
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_TIMBREAK SYSCFG TIMER BREAK
N  * @{
N  */
N#define LL_SYSCFG_TIMBREAK_ECC             SYSCFG_CFGR2_ECCL  /*!< Enables and locks the ECC error signal 
N                                                                   with Break Input of TIM1/8/15/16/17                           */
N#define LL_SYSCFG_TIMBREAK_PVD             SYSCFG_CFGR2_PVDL  /*!< Enables and locks the PVD connection 
N                                                                   with TIM1/8/15/16/17 Break Input 
N                                                                   and also the PVDE and PLS bits of the Power Control Interface */
N#define LL_SYSCFG_TIMBREAK_SRAM2_PARITY    SYSCFG_CFGR2_SPL   /*!< Enables and locks the SRAM2_PARITY error signal 
N                                                                   with Break Input of TIM1/8/15/16/17                           */
N#define LL_SYSCFG_TIMBREAK_LOCKUP          SYSCFG_CFGR2_CLL   /*!< Enables and locks the LOCKUP output of CortexM4 
N                                                                   with Break Input of TIM1/15/16/17                             */
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_SRAM2WRP SYSCFG SRAM2 WRP
N  * @{
N  */
N#define LL_SYSCFG_SRAM2WRP_PAGE0           SYSCFG_SWPR_PAGE0  /*!< SRAM2 Write protection page 0  */
N#define LL_SYSCFG_SRAM2WRP_PAGE1           SYSCFG_SWPR_PAGE1  /*!< SRAM2 Write protection page 1  */
N#define LL_SYSCFG_SRAM2WRP_PAGE2           SYSCFG_SWPR_PAGE2  /*!< SRAM2 Write protection page 2  */
N#define LL_SYSCFG_SRAM2WRP_PAGE3           SYSCFG_SWPR_PAGE3  /*!< SRAM2 Write protection page 3  */
N#define LL_SYSCFG_SRAM2WRP_PAGE4           SYSCFG_SWPR_PAGE4  /*!< SRAM2 Write protection page 4  */
N#define LL_SYSCFG_SRAM2WRP_PAGE5           SYSCFG_SWPR_PAGE5  /*!< SRAM2 Write protection page 5  */
N#define LL_SYSCFG_SRAM2WRP_PAGE6           SYSCFG_SWPR_PAGE6  /*!< SRAM2 Write protection page 6  */
N#define LL_SYSCFG_SRAM2WRP_PAGE7           SYSCFG_SWPR_PAGE7  /*!< SRAM2 Write protection page 7  */
N#define LL_SYSCFG_SRAM2WRP_PAGE8           SYSCFG_SWPR_PAGE8  /*!< SRAM2 Write protection page 8  */
N#define LL_SYSCFG_SRAM2WRP_PAGE9           SYSCFG_SWPR_PAGE9  /*!< SRAM2 Write protection page 9  */
N#define LL_SYSCFG_SRAM2WRP_PAGE10          SYSCFG_SWPR_PAGE10 /*!< SRAM2 Write protection page 10 */
N#define LL_SYSCFG_SRAM2WRP_PAGE11          SYSCFG_SWPR_PAGE11 /*!< SRAM2 Write protection page 11 */
N#define LL_SYSCFG_SRAM2WRP_PAGE12          SYSCFG_SWPR_PAGE12 /*!< SRAM2 Write protection page 12 */
N#define LL_SYSCFG_SRAM2WRP_PAGE13          SYSCFG_SWPR_PAGE13 /*!< SRAM2 Write protection page 13 */
N#define LL_SYSCFG_SRAM2WRP_PAGE14          SYSCFG_SWPR_PAGE14 /*!< SRAM2 Write protection page 14 */
N#define LL_SYSCFG_SRAM2WRP_PAGE15          SYSCFG_SWPR_PAGE15 /*!< SRAM2 Write protection page 15 */
N#if defined(SYSCFG_SWPR_PAGE31)
X#if 0L
S#define LL_SYSCFG_SRAM2WRP_PAGE16          SYSCFG_SWPR_PAGE16 /*!< SRAM2 Write protection page 16 */
S#define LL_SYSCFG_SRAM2WRP_PAGE17          SYSCFG_SWPR_PAGE17 /*!< SRAM2 Write protection page 17 */
S#define LL_SYSCFG_SRAM2WRP_PAGE18          SYSCFG_SWPR_PAGE18 /*!< SRAM2 Write protection page 18 */
S#define LL_SYSCFG_SRAM2WRP_PAGE19          SYSCFG_SWPR_PAGE19 /*!< SRAM2 Write protection page 19 */
S#define LL_SYSCFG_SRAM2WRP_PAGE20          SYSCFG_SWPR_PAGE20 /*!< SRAM2 Write protection page 20 */
S#define LL_SYSCFG_SRAM2WRP_PAGE21          SYSCFG_SWPR_PAGE21 /*!< SRAM2 Write protection page 21 */
S#define LL_SYSCFG_SRAM2WRP_PAGE22          SYSCFG_SWPR_PAGE22 /*!< SRAM2 Write protection page 22 */
S#define LL_SYSCFG_SRAM2WRP_PAGE23          SYSCFG_SWPR_PAGE23 /*!< SRAM2 Write protection page 23 */
S#define LL_SYSCFG_SRAM2WRP_PAGE24          SYSCFG_SWPR_PAGE24 /*!< SRAM2 Write protection page 24 */
S#define LL_SYSCFG_SRAM2WRP_PAGE25          SYSCFG_SWPR_PAGE25 /*!< SRAM2 Write protection page 25 */
S#define LL_SYSCFG_SRAM2WRP_PAGE26          SYSCFG_SWPR_PAGE26 /*!< SRAM2 Write protection page 26 */
S#define LL_SYSCFG_SRAM2WRP_PAGE27          SYSCFG_SWPR_PAGE27 /*!< SRAM2 Write protection page 27 */
S#define LL_SYSCFG_SRAM2WRP_PAGE28          SYSCFG_SWPR_PAGE28 /*!< SRAM2 Write protection page 28 */
S#define LL_SYSCFG_SRAM2WRP_PAGE29          SYSCFG_SWPR_PAGE29 /*!< SRAM2 Write protection page 29 */
S#define LL_SYSCFG_SRAM2WRP_PAGE30          SYSCFG_SWPR_PAGE30 /*!< SRAM2 Write protection page 30 */
S#define LL_SYSCFG_SRAM2WRP_PAGE31          SYSCFG_SWPR_PAGE31 /*!< SRAM2 Write protection page 31 */
N#endif /* SYSCFG_SWPR_PAGE31 */
N#if defined(SYSCFG_SWPR2_PAGE63)
X#if 0L
S#define LL_SYSCFG_SRAM2WRP_PAGE32          SYSCFG_SWPR2_PAGE32 /*!< SRAM2 Write protection page 32 */
S#define LL_SYSCFG_SRAM2WRP_PAGE33          SYSCFG_SWPR2_PAGE33 /*!< SRAM2 Write protection page 33 */
S#define LL_SYSCFG_SRAM2WRP_PAGE34          SYSCFG_SWPR2_PAGE34 /*!< SRAM2 Write protection page 34 */
S#define LL_SYSCFG_SRAM2WRP_PAGE35          SYSCFG_SWPR2_PAGE35 /*!< SRAM2 Write protection page 35 */
S#define LL_SYSCFG_SRAM2WRP_PAGE36          SYSCFG_SWPR2_PAGE36 /*!< SRAM2 Write protection page 36 */
S#define LL_SYSCFG_SRAM2WRP_PAGE37          SYSCFG_SWPR2_PAGE37 /*!< SRAM2 Write protection page 37 */
S#define LL_SYSCFG_SRAM2WRP_PAGE38          SYSCFG_SWPR2_PAGE38 /*!< SRAM2 Write protection page 38 */
S#define LL_SYSCFG_SRAM2WRP_PAGE39          SYSCFG_SWPR2_PAGE39 /*!< SRAM2 Write protection page 39 */
S#define LL_SYSCFG_SRAM2WRP_PAGE40          SYSCFG_SWPR2_PAGE40 /*!< SRAM2 Write protection page 40 */
S#define LL_SYSCFG_SRAM2WRP_PAGE41          SYSCFG_SWPR2_PAGE41 /*!< SRAM2 Write protection page 41 */
S#define LL_SYSCFG_SRAM2WRP_PAGE42          SYSCFG_SWPR2_PAGE42 /*!< SRAM2 Write protection page 42 */
S#define LL_SYSCFG_SRAM2WRP_PAGE43          SYSCFG_SWPR2_PAGE43 /*!< SRAM2 Write protection page 43 */
S#define LL_SYSCFG_SRAM2WRP_PAGE44          SYSCFG_SWPR2_PAGE44 /*!< SRAM2 Write protection page 44 */
S#define LL_SYSCFG_SRAM2WRP_PAGE45          SYSCFG_SWPR2_PAGE45 /*!< SRAM2 Write protection page 45 */
S#define LL_SYSCFG_SRAM2WRP_PAGE46          SYSCFG_SWPR2_PAGE46 /*!< SRAM2 Write protection page 46 */
S#define LL_SYSCFG_SRAM2WRP_PAGE47          SYSCFG_SWPR2_PAGE47 /*!< SRAM2 Write protection page 47 */
S#define LL_SYSCFG_SRAM2WRP_PAGE48          SYSCFG_SWPR2_PAGE48 /*!< SRAM2 Write protection page 48 */
S#define LL_SYSCFG_SRAM2WRP_PAGE49          SYSCFG_SWPR2_PAGE49 /*!< SRAM2 Write protection page 49 */
S#define LL_SYSCFG_SRAM2WRP_PAGE50          SYSCFG_SWPR2_PAGE50 /*!< SRAM2 Write protection page 50 */
S#define LL_SYSCFG_SRAM2WRP_PAGE51          SYSCFG_SWPR2_PAGE51 /*!< SRAM2 Write protection page 51 */
S#define LL_SYSCFG_SRAM2WRP_PAGE52          SYSCFG_SWPR2_PAGE52 /*!< SRAM2 Write protection page 52 */
S#define LL_SYSCFG_SRAM2WRP_PAGE53          SYSCFG_SWPR2_PAGE53 /*!< SRAM2 Write protection page 53 */
S#define LL_SYSCFG_SRAM2WRP_PAGE54          SYSCFG_SWPR2_PAGE54 /*!< SRAM2 Write protection page 54 */
S#define LL_SYSCFG_SRAM2WRP_PAGE55          SYSCFG_SWPR2_PAGE55 /*!< SRAM2 Write protection page 55 */
S#define LL_SYSCFG_SRAM2WRP_PAGE56          SYSCFG_SWPR2_PAGE56 /*!< SRAM2 Write protection page 56 */
S#define LL_SYSCFG_SRAM2WRP_PAGE57          SYSCFG_SWPR2_PAGE57 /*!< SRAM2 Write protection page 57 */
S#define LL_SYSCFG_SRAM2WRP_PAGE58          SYSCFG_SWPR2_PAGE58 /*!< SRAM2 Write protection page 58 */
S#define LL_SYSCFG_SRAM2WRP_PAGE59          SYSCFG_SWPR2_PAGE59 /*!< SRAM2 Write protection page 59 */
S#define LL_SYSCFG_SRAM2WRP_PAGE60          SYSCFG_SWPR2_PAGE60 /*!< SRAM2 Write protection page 60 */
S#define LL_SYSCFG_SRAM2WRP_PAGE61          SYSCFG_SWPR2_PAGE61 /*!< SRAM2 Write protection page 61 */
S#define LL_SYSCFG_SRAM2WRP_PAGE62          SYSCFG_SWPR2_PAGE62 /*!< SRAM2 Write protection page 62 */
S#define LL_SYSCFG_SRAM2WRP_PAGE63          SYSCFG_SWPR2_PAGE63 /*!< SRAM2 Write protection page 63 */
N#endif /* SYSCFG_SWPR2_PAGE63 */
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_TRACE DBGMCU TRACE Pin Assignment
N  * @{
N  */
N#define LL_DBGMCU_TRACE_NONE               0x00000000U                                     /*!< TRACE pins not assigned (default state) */
N#define LL_DBGMCU_TRACE_ASYNCH             DBGMCU_CR_TRACE_IOEN                            /*!< TRACE pin assignment for Asynchronous Mode */
N#define LL_DBGMCU_TRACE_SYNCH_SIZE1        (DBGMCU_CR_TRACE_IOEN | DBGMCU_CR_TRACE_MODE_0) /*!< TRACE pin assignment for Synchronous Mode with a TRACEDATA size of 1 */
N#define LL_DBGMCU_TRACE_SYNCH_SIZE2        (DBGMCU_CR_TRACE_IOEN | DBGMCU_CR_TRACE_MODE_1) /*!< TRACE pin assignment for Synchronous Mode with a TRACEDATA size of 2 */
N#define LL_DBGMCU_TRACE_SYNCH_SIZE4        (DBGMCU_CR_TRACE_IOEN | DBGMCU_CR_TRACE_MODE)   /*!< TRACE pin assignment for Synchronous Mode with a TRACEDATA size of 4 */
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_APB1_GRP1_STOP_IP DBGMCU APB1 GRP1 STOP IP
N  * @{
N  */
N#define LL_DBGMCU_APB1_GRP1_TIM2_STOP      DBGMCU_APB1FZR1_DBG_TIM2_STOP   /*!< The counter clock of TIM2 is stopped when the core is halted*/
N#if defined(TIM3)
X#if 0L
S#define LL_DBGMCU_APB1_GRP1_TIM3_STOP      DBGMCU_APB1FZR1_DBG_TIM3_STOP   /*!< The counter clock of TIM3 is stopped when the core is halted*/
N#endif /* TIM3 */
N#if defined(TIM4)
X#if 0L
S#define LL_DBGMCU_APB1_GRP1_TIM4_STOP      DBGMCU_APB1FZR1_DBG_TIM4_STOP   /*!< The counter clock of TIM4 is stopped when the core is halted*/
N#endif /* TIM4 */
N#if defined(TIM5)
X#if 0L
S#define LL_DBGMCU_APB1_GRP1_TIM5_STOP      DBGMCU_APB1FZR1_DBG_TIM5_STOP   /*!< The counter clock of TIM5 is stopped when the core is halted*/
N#endif /* TIM5 */
N#define LL_DBGMCU_APB1_GRP1_TIM6_STOP      DBGMCU_APB1FZR1_DBG_TIM6_STOP   /*!< The counter clock of TIM6 is stopped when the core is halted*/
N#if defined(TIM7)
X#if 1L
N#define LL_DBGMCU_APB1_GRP1_TIM7_STOP      DBGMCU_APB1FZR1_DBG_TIM7_STOP   /*!< The counter clock of TIM7 is stopped when the core is halted*/
N#endif /* TIM7 */
N#define LL_DBGMCU_APB1_GRP1_RTC_STOP       DBGMCU_APB1FZR1_DBG_RTC_STOP    /*!< The clock of the RTC counter is stopped when the core is halted*/
N#define LL_DBGMCU_APB1_GRP1_WWDG_STOP      DBGMCU_APB1FZR1_DBG_WWDG_STOP   /*!< The window watchdog counter clock is stopped when the core is halted*/
N#define LL_DBGMCU_APB1_GRP1_IWDG_STOP      DBGMCU_APB1FZR1_DBG_IWDG_STOP   /*!< The independent watchdog counter clock is stopped when the core is halted*/
N#define LL_DBGMCU_APB1_GRP1_I2C1_STOP      DBGMCU_APB1FZR1_DBG_I2C1_STOP   /*!< The I2C1 SMBus timeout is frozen*/
N#if defined(I2C2)
X#if 1L
N#define LL_DBGMCU_APB1_GRP1_I2C2_STOP      DBGMCU_APB1FZR1_DBG_I2C2_STOP   /*!< The I2C2 SMBus timeout is frozen*/
N#endif /* I2C2 */
N#define LL_DBGMCU_APB1_GRP1_I2C3_STOP      DBGMCU_APB1FZR1_DBG_I2C3_STOP   /*!< The I2C3 SMBus timeout is frozen*/
N#define LL_DBGMCU_APB1_GRP1_CAN_STOP       DBGMCU_APB1FZR1_DBG_CAN_STOP    /*!< The bxCAN receive registers are frozen*/
N#if defined(CAN2)
X#if 0L
S#define LL_DBGMCU_APB1_GRP1_CAN2_STOP      DBGMCU_APB1FZR1_DBG_CAN2_STOP   /*!< The bxCAN2 receive registers are frozen*/
N#endif /* CAN2 */
N#define LL_DBGMCU_APB1_GRP1_LPTIM1_STOP    DBGMCU_APB1FZR1_DBG_LPTIM1_STOP /*!< The counter clock of LPTIM1 is stopped when the core is halted*/
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_APB1_GRP2_STOP_IP DBGMCU APB1 GRP2 STOP IP
N  * @{
N  */
N#if defined(I2C4)
X#if 0L
S#define LL_DBGMCU_APB1_GRP2_I2C4_STOP      DBGMCU_APB1FZR2_DBG_I2C4_STOP   /*!< The I2C4 SMBus timeout is frozen*/
N#endif /* I2C4 */
N#define LL_DBGMCU_APB1_GRP2_LPTIM2_STOP    DBGMCU_APB1FZR2_DBG_LPTIM2_STOP /*!< The counter clock of LPTIM2 is stopped when the core is halted*/
N/**
N  * @}
N  */
N
N/** @defgroup SYSTEM_LL_EC_APB2_GRP1_STOP_IP DBGMCU APB2 GRP1 STOP IP
N  * @{
N  */
N#define LL_DBGMCU_APB2_GRP1_TIM1_STOP      DBGMCU_APB2FZ_DBG_TIM1_STOP     /*!< The counter clock of TIM1 is stopped when the core is halted*/
N#if defined(TIM8)
X#if 0L
S#define LL_DBGMCU_APB2_GRP1_TIM8_STOP      DBGMCU_APB2FZ_DBG_TIM8_STOP     /*!< The counter clock of TIM8 is stopped when the core is halted*/
N#endif /* TIM8 */
N#define LL_DBGMCU_APB2_GRP1_TIM15_STOP     DBGMCU_APB2FZ_DBG_TIM15_STOP    /*!< The counter clock of TIM15 is stopped when the core is halted*/
N#define LL_DBGMCU_APB2_GRP1_TIM16_STOP     DBGMCU_APB2FZ_DBG_TIM16_STOP    /*!< The counter clock of TIM16 is stopped when the core is halted*/
N#if defined(TIM17)
X#if 0L
S#define LL_DBGMCU_APB2_GRP1_TIM17_STOP     DBGMCU_APB2FZ_DBG_TIM17_STOP    /*!< The counter clock of TIM17 is stopped when the core is halted*/
N#endif /* TIM17 */
N/**
N  * @}
N  */
N
N#if defined(VREFBUF)
X#if 1L
N/** @defgroup SYSTEM_LL_EC_VOLTAGE VREFBUF VOLTAGE
N  * @{
N  */
N#define LL_VREFBUF_VOLTAGE_SCALE0          ((uint32_t)0x00000000) /*!< Voltage reference scale 0 (VREF_OUT1) */
N#define LL_VREFBUF_VOLTAGE_SCALE1          VREFBUF_CSR_VRS        /*!< Voltage reference scale 1 (VREF_OUT2) */
N/**
N  * @}
N  */
N#endif /* VREFBUF */
N
N/** @defgroup SYSTEM_LL_EC_LATENCY FLASH LATENCY
N  * @{
N  */
N#define LL_FLASH_LATENCY_0                 FLASH_ACR_LATENCY_0WS   /*!< FLASH Zero wait state */
N#define LL_FLASH_LATENCY_1                 FLASH_ACR_LATENCY_1WS   /*!< FLASH One wait state */
N#define LL_FLASH_LATENCY_2                 FLASH_ACR_LATENCY_2WS   /*!< FLASH Two wait states */
N#define LL_FLASH_LATENCY_3                 FLASH_ACR_LATENCY_3WS   /*!< FLASH Three wait states */
N#define LL_FLASH_LATENCY_4                 FLASH_ACR_LATENCY_4WS   /*!< FLASH Four wait states */
N#if defined(FLASH_ACR_LATENCY_5WS)
X#if 0L
S#define LL_FLASH_LATENCY_5                 FLASH_ACR_LATENCY_5WS   /*!< FLASH five wait state */
S#define LL_FLASH_LATENCY_6                 FLASH_ACR_LATENCY_6WS   /*!< FLASH six wait state */
S#define LL_FLASH_LATENCY_7                 FLASH_ACR_LATENCY_7WS   /*!< FLASH seven wait states */
S#define LL_FLASH_LATENCY_8                 FLASH_ACR_LATENCY_8WS   /*!< FLASH eight wait states */
S#define LL_FLASH_LATENCY_9                 FLASH_ACR_LATENCY_9WS   /*!< FLASH nine wait states */
S#define LL_FLASH_LATENCY_10                FLASH_ACR_LATENCY_10WS  /*!< FLASH ten wait states */
S#define LL_FLASH_LATENCY_11                FLASH_ACR_LATENCY_11WS  /*!< FLASH eleven wait states */
S#define LL_FLASH_LATENCY_12                FLASH_ACR_LATENCY_12WS  /*!< FLASH twelve wait states */
S#define LL_FLASH_LATENCY_13                FLASH_ACR_LATENCY_13WS  /*!< FLASH thirteen wait states */
S#define LL_FLASH_LATENCY_14                FLASH_ACR_LATENCY_14WS  /*!< FLASH fourteen wait states */
S#define LL_FLASH_LATENCY_15                FLASH_ACR_LATENCY_15WS  /*!< FLASH fifteen wait states */
N#endif
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup SYSTEM_LL_Exported_Functions SYSTEM Exported Functions
N  * @{
N  */
N
N/** @defgroup SYSTEM_LL_EF_SYSCFG SYSCFG
N  * @{
N  */
N
N/**
N  * @brief  Set memory mapping at address 0x00000000
N  * @rmtoll SYSCFG_MEMRMP MEM_MODE      LL_SYSCFG_SetRemapMemory
N  * @param  Memory This parameter can be one of the following values:
N  *         @arg @ref LL_SYSCFG_REMAP_FLASH
N  *         @arg @ref LL_SYSCFG_REMAP_SYSTEMFLASH
N  *         @arg @ref LL_SYSCFG_REMAP_SRAM
N  *         @arg @ref LL_SYSCFG_REMAP_FMC (*)
N  *         @arg @ref LL_SYSCFG_REMAP_QUADSPI
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_SetRemapMemory(uint32_t Memory)
Xstatic __inline void LL_SYSCFG_SetRemapMemory(uint32_t Memory)
N{
N  MODIFY_REG(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE, Memory);
X  (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->MEMRMP)) = ((((((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->MEMRMP))) & (~((0x7UL << (0U))))) | (Memory))));
N}
N
N/**
N  * @brief  Get memory mapping at address 0x00000000
N  * @rmtoll SYSCFG_MEMRMP MEM_MODE      LL_SYSCFG_GetRemapMemory
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SYSCFG_REMAP_FLASH
N  *         @arg @ref LL_SYSCFG_REMAP_SYSTEMFLASH
N  *         @arg @ref LL_SYSCFG_REMAP_SRAM
N  *         @arg @ref LL_SYSCFG_REMAP_FMC (*)
N  *         @arg @ref LL_SYSCFG_REMAP_QUADSPI
N  *
N  *         (*) value not defined in all devices
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_GetRemapMemory(void)
Xstatic __inline uint32_t LL_SYSCFG_GetRemapMemory(void)
N{
N  return (uint32_t)(READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE));
X  return (uint32_t)(((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->MEMRMP) & ((0x7UL << (0U)))));
N}
N
N#if defined(SYSCFG_MEMRMP_FB_MODE)
X#if 0L
S/**
S  * @brief  Select Flash bank mode (Bank flashed at 0x08000000)
S  * @rmtoll SYSCFG_MEMRMP FB_MODE       LL_SYSCFG_SetFlashBankMode
S  * @param  Bank This parameter can be one of the following values:
S  *         @arg @ref LL_SYSCFG_BANKMODE_BANK1
S  *         @arg @ref LL_SYSCFG_BANKMODE_BANK2
S  * @retval None
S  */
S__STATIC_INLINE void LL_SYSCFG_SetFlashBankMode(uint32_t Bank)
S{
S  MODIFY_REG(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE, Bank);
S}
S
S/**
S  * @brief  Get Flash bank mode (Bank flashed at 0x08000000)
S  * @rmtoll SYSCFG_MEMRMP FB_MODE       LL_SYSCFG_GetFlashBankMode
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_SYSCFG_BANKMODE_BANK1
S  *         @arg @ref LL_SYSCFG_BANKMODE_BANK2
S  */
S__STATIC_INLINE uint32_t LL_SYSCFG_GetFlashBankMode(void)
S{
S  return (uint32_t)(READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE));
S}
N#endif /* SYSCFG_MEMRMP_FB_MODE */
N
N/**
N  * @brief  Firewall protection enabled
N  * @rmtoll SYSCFG_CFGR1 FWDIS         LL_SYSCFG_EnableFirewall
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableFirewall(void)
Xstatic __inline void LL_SYSCFG_EnableFirewall(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FWDIS);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if Firewall protection is enabled or not
N  * @rmtoll SYSCFG_CFGR1 FWDIS         LL_SYSCFG_IsEnabledFirewall
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledFirewall(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledFirewall(void)
N{
N  return !(READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FWDIS) == SYSCFG_CFGR1_FWDIS);
X  return !(((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x1UL << (0U)))) == (0x1UL << (0U)));
N}
N
N/**
N  * @brief  Enable I/O analog switch voltage booster.
N  * @note   When voltage booster is enabled, I/O analog switches are supplied
N  *         by a dedicated voltage booster, from VDD power domain. This is
N  *         the recommended configuration with low VDDA voltage operation.
N  * @note   The I/O analog switch voltage booster is relevant for peripherals
N  *         using I/O in analog input: ADC, COMP, OPAMP.
N  *         However, COMP and OPAMP inputs have a high impedance and
N  *         voltage booster do not impact performance significantly.
N  *         Therefore, the voltage booster is mainly intended for
N  *         usage with ADC.
N  * @rmtoll SYSCFG_CFGR1 BOOSTEN       LL_SYSCFG_EnableAnalogBooster
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableAnalogBooster(void)
Xstatic __inline void LL_SYSCFG_EnableAnalogBooster(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable I/O analog switch voltage booster.
N  * @note   When voltage booster is enabled, I/O analog switches are supplied
N  *         by a dedicated voltage booster, from VDD power domain. This is
N  *         the recommended configuration with low VDDA voltage operation.
N  * @note   The I/O analog switch voltage booster is relevant for peripherals
N  *         using I/O in analog input: ADC, COMP, OPAMP.
N  *         However, COMP and OPAMP inputs have a high impedance and
N  *         voltage booster do not impact performance significantly.
N  *         Therefore, the voltage booster is mainly intended for
N  *         usage with ADC.
N  * @rmtoll SYSCFG_CFGR1 BOOSTEN       LL_SYSCFG_DisableAnalogBooster
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableAnalogBooster(void)
Xstatic __inline void LL_SYSCFG_DisableAnalogBooster(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable the I2C fast mode plus driving capability.
N  * @rmtoll SYSCFG_CFGR1 I2C_PBx_FMP   LL_SYSCFG_EnableFastModePlus\n
N  *         SYSCFG_CFGR1 I2Cx_FMP      LL_SYSCFG_EnableFastModePlus
N  * @param  ConfigFastModePlus This parameter can be a combination of the following values:
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB6
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB7
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB8 (*)
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB9 (*)
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C1
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C2 (*)
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C3
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C4 (*)
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableFastModePlus(uint32_t ConfigFastModePlus)
Xstatic __inline void LL_SYSCFG_EnableFastModePlus(uint32_t ConfigFastModePlus)
N{
N  SET_BIT(SYSCFG->CFGR1, ConfigFastModePlus);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= (ConfigFastModePlus));
N}
N
N/**
N  * @brief  Disable the I2C fast mode plus driving capability.
N  * @rmtoll SYSCFG_CFGR1 I2C_PBx_FMP   LL_SYSCFG_DisableFastModePlus\n
N  *         SYSCFG_CFGR1 I2Cx_FMP      LL_SYSCFG_DisableFastModePlus
N  * @param  ConfigFastModePlus This parameter can be a combination of the following values:
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB6
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB7
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB8 (*)
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_PB9 (*)
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C1
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C2 (*)
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C3
N  *         @arg @ref LL_SYSCFG_I2C_FASTMODEPLUS_I2C4 (*)
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableFastModePlus(uint32_t ConfigFastModePlus)
Xstatic __inline void LL_SYSCFG_DisableFastModePlus(uint32_t ConfigFastModePlus)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, ConfigFastModePlus);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~(ConfigFastModePlus));
N}
N
N/**
N  * @brief  Enable Floating Point Unit Invalid operation Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_0      LL_SYSCFG_EnableIT_FPU_IOC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableIT_FPU_IOC(void)
Xstatic __inline void LL_SYSCFG_EnableIT_FPU_IOC(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_0);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x04000000UL)));
N}
N
N/**
N  * @brief  Enable Floating Point Unit Divide-by-zero Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_1      LL_SYSCFG_EnableIT_FPU_DZC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableIT_FPU_DZC(void)
Xstatic __inline void LL_SYSCFG_EnableIT_FPU_DZC(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_1);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x08000000UL)));
N}
N
N/**
N  * @brief  Enable Floating Point Unit Underflow Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_2      LL_SYSCFG_EnableIT_FPU_UFC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableIT_FPU_UFC(void)
Xstatic __inline void LL_SYSCFG_EnableIT_FPU_UFC(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_2);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x10000000UL)));
N}
N
N/**
N  * @brief  Enable Floating Point Unit Overflow Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_3      LL_SYSCFG_EnableIT_FPU_OFC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableIT_FPU_OFC(void)
Xstatic __inline void LL_SYSCFG_EnableIT_FPU_OFC(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_3);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x20000000UL)));
N}
N
N/**
N  * @brief  Enable Floating Point Unit Input denormal Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_4      LL_SYSCFG_EnableIT_FPU_IDC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableIT_FPU_IDC(void)
Xstatic __inline void LL_SYSCFG_EnableIT_FPU_IDC(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_4);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x40000000UL)));
N}
N
N/**
N  * @brief  Enable Floating Point Unit Inexact Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_5      LL_SYSCFG_EnableIT_FPU_IXC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableIT_FPU_IXC(void)
Xstatic __inline void LL_SYSCFG_EnableIT_FPU_IXC(void)
N{
N  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_5);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) |= ((0x80000000UL)));
N}
N
N/**
N  * @brief  Disable Floating Point Unit Invalid operation Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_0      LL_SYSCFG_DisableIT_FPU_IOC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableIT_FPU_IOC(void)
Xstatic __inline void LL_SYSCFG_DisableIT_FPU_IOC(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_0);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x04000000UL)));
N}
N
N/**
N  * @brief  Disable Floating Point Unit Divide-by-zero Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_1      LL_SYSCFG_DisableIT_FPU_DZC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableIT_FPU_DZC(void)
Xstatic __inline void LL_SYSCFG_DisableIT_FPU_DZC(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_1);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x08000000UL)));
N}
N
N/**
N  * @brief  Disable Floating Point Unit Underflow Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_2      LL_SYSCFG_DisableIT_FPU_UFC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableIT_FPU_UFC(void)
Xstatic __inline void LL_SYSCFG_DisableIT_FPU_UFC(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_2);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x10000000UL)));
N}
N
N/**
N  * @brief  Disable Floating Point Unit Overflow Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_3      LL_SYSCFG_DisableIT_FPU_OFC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableIT_FPU_OFC(void)
Xstatic __inline void LL_SYSCFG_DisableIT_FPU_OFC(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_3);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x20000000UL)));
N}
N
N/**
N  * @brief  Disable Floating Point Unit Input denormal Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_4      LL_SYSCFG_DisableIT_FPU_IDC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableIT_FPU_IDC(void)
Xstatic __inline void LL_SYSCFG_DisableIT_FPU_IDC(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_4);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x40000000UL)));
N}
N
N/**
N  * @brief  Disable Floating Point Unit Inexact Interrupt
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_5      LL_SYSCFG_DisableIT_FPU_IXC
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_DisableIT_FPU_IXC(void)
Xstatic __inline void LL_SYSCFG_DisableIT_FPU_IXC(void)
N{
N  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_5);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) &= ~((0x80000000UL)));
N}
N
N/**
N  * @brief  Check if Floating Point Unit Invalid operation Interrupt source is enabled or disabled.
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_0      LL_SYSCFG_IsEnabledIT_FPU_IOC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledIT_FPU_IOC(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledIT_FPU_IOC(void)
N{
N  return (READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_0) == (SYSCFG_CFGR1_FPU_IE_0));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x04000000UL))) == ((0x04000000UL)));
N}
N
N/**
N  * @brief  Check if Floating Point Unit Divide-by-zero Interrupt source is enabled or disabled.
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_1      LL_SYSCFG_IsEnabledIT_FPU_DZC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledIT_FPU_DZC(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledIT_FPU_DZC(void)
N{
N  return (READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_1) == (SYSCFG_CFGR1_FPU_IE_1));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x08000000UL))) == ((0x08000000UL)));
N}
N
N/**
N  * @brief  Check if Floating Point Unit Underflow Interrupt source is enabled or disabled.
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_2      LL_SYSCFG_IsEnabledIT_FPU_UFC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledIT_FPU_UFC(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledIT_FPU_UFC(void)
N{
N  return (READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_2) == (SYSCFG_CFGR1_FPU_IE_2));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x10000000UL))) == ((0x10000000UL)));
N}
N
N/**
N  * @brief  Check if Floating Point Unit Overflow Interrupt source is enabled or disabled.
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_3      LL_SYSCFG_IsEnabledIT_FPU_OFC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledIT_FPU_OFC(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledIT_FPU_OFC(void)
N{
N  return (READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_3) == (SYSCFG_CFGR1_FPU_IE_3));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x20000000UL))) == ((0x20000000UL)));
N}
N
N/**
N  * @brief  Check if Floating Point Unit Input denormal Interrupt source is enabled or disabled.
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_4      LL_SYSCFG_IsEnabledIT_FPU_IDC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledIT_FPU_IDC(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledIT_FPU_IDC(void)
N{
N  return (READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_4) == (SYSCFG_CFGR1_FPU_IE_4));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x40000000UL))) == ((0x40000000UL)));
N}
N
N/**
N  * @brief  Check if Floating Point Unit Inexact Interrupt source is enabled or disabled.
N  * @rmtoll SYSCFG_CFGR1 FPU_IE_5      LL_SYSCFG_IsEnabledIT_FPU_IXC
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsEnabledIT_FPU_IXC(void)
Xstatic __inline uint32_t LL_SYSCFG_IsEnabledIT_FPU_IXC(void)
N{
N  return (READ_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FPU_IE_5) == (SYSCFG_CFGR1_FPU_IE_5));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR1) & ((0x80000000UL))) == ((0x80000000UL)));
N}
N
N/**
N  * @brief  Configure source input for the EXTI external interrupt.
N  * @rmtoll SYSCFG_EXTICR1 EXTIx         LL_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTIx         LL_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTIx         LL_SYSCFG_SetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTIx         LL_SYSCFG_SetEXTISource
N  * @param  Port This parameter can be one of the following values:
N  *         @arg @ref LL_SYSCFG_EXTI_PORTA
N  *         @arg @ref LL_SYSCFG_EXTI_PORTB
N  *         @arg @ref LL_SYSCFG_EXTI_PORTC
N  *         @arg @ref LL_SYSCFG_EXTI_PORTD
N  *         @arg @ref LL_SYSCFG_EXTI_PORTE
N  *         @arg @ref LL_SYSCFG_EXTI_PORTF (*)
N  *         @arg @ref LL_SYSCFG_EXTI_PORTG (*)
N  *         @arg @ref LL_SYSCFG_EXTI_PORTH
N  *         @arg @ref LL_SYSCFG_EXTI_PORTI (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  Line This parameter can be one of the following values:
N  *         @arg @ref LL_SYSCFG_EXTI_LINE0
N  *         @arg @ref LL_SYSCFG_EXTI_LINE1
N  *         @arg @ref LL_SYSCFG_EXTI_LINE2
N  *         @arg @ref LL_SYSCFG_EXTI_LINE3
N  *         @arg @ref LL_SYSCFG_EXTI_LINE4
N  *         @arg @ref LL_SYSCFG_EXTI_LINE5
N  *         @arg @ref LL_SYSCFG_EXTI_LINE6
N  *         @arg @ref LL_SYSCFG_EXTI_LINE7
N  *         @arg @ref LL_SYSCFG_EXTI_LINE8
N  *         @arg @ref LL_SYSCFG_EXTI_LINE9
N  *         @arg @ref LL_SYSCFG_EXTI_LINE10
N  *         @arg @ref LL_SYSCFG_EXTI_LINE11
N  *         @arg @ref LL_SYSCFG_EXTI_LINE12
N  *         @arg @ref LL_SYSCFG_EXTI_LINE13
N  *         @arg @ref LL_SYSCFG_EXTI_LINE14
N  *         @arg @ref LL_SYSCFG_EXTI_LINE15
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_SetEXTISource(uint32_t Port, uint32_t Line)
Xstatic __inline void LL_SYSCFG_SetEXTISource(uint32_t Port, uint32_t Line)
N{
N  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFFU], (Line >> 16U), Port << POSITION_VAL((Line >> 16U)));
X  (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->EXTICR[Line & 0xFFU])) = ((((((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->EXTICR[Line & 0xFFU]))) & (~((Line >> 16U)))) | (Port << (__clz(__rbit((Line >> 16U))))))));
N}
N
N/**
N  * @brief  Get the configured defined for specific EXTI Line
N  * @rmtoll SYSCFG_EXTICR1 EXTIx         LL_SYSCFG_GetEXTISource\n
N  *         SYSCFG_EXTICR2 EXTIx         LL_SYSCFG_GetEXTISource\n
N  *         SYSCFG_EXTICR3 EXTIx         LL_SYSCFG_GetEXTISource\n
N  *         SYSCFG_EXTICR4 EXTIx         LL_SYSCFG_GetEXTISource
N  * @param  Line This parameter can be one of the following values:
N  *         @arg @ref LL_SYSCFG_EXTI_LINE0
N  *         @arg @ref LL_SYSCFG_EXTI_LINE1
N  *         @arg @ref LL_SYSCFG_EXTI_LINE2
N  *         @arg @ref LL_SYSCFG_EXTI_LINE3
N  *         @arg @ref LL_SYSCFG_EXTI_LINE4
N  *         @arg @ref LL_SYSCFG_EXTI_LINE5
N  *         @arg @ref LL_SYSCFG_EXTI_LINE6
N  *         @arg @ref LL_SYSCFG_EXTI_LINE7
N  *         @arg @ref LL_SYSCFG_EXTI_LINE8
N  *         @arg @ref LL_SYSCFG_EXTI_LINE9
N  *         @arg @ref LL_SYSCFG_EXTI_LINE10
N  *         @arg @ref LL_SYSCFG_EXTI_LINE11
N  *         @arg @ref LL_SYSCFG_EXTI_LINE12
N  *         @arg @ref LL_SYSCFG_EXTI_LINE13
N  *         @arg @ref LL_SYSCFG_EXTI_LINE14
N  *         @arg @ref LL_SYSCFG_EXTI_LINE15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SYSCFG_EXTI_PORTA
N  *         @arg @ref LL_SYSCFG_EXTI_PORTB
N  *         @arg @ref LL_SYSCFG_EXTI_PORTC
N  *         @arg @ref LL_SYSCFG_EXTI_PORTD
N  *         @arg @ref LL_SYSCFG_EXTI_PORTE
N  *         @arg @ref LL_SYSCFG_EXTI_PORTF (*)
N  *         @arg @ref LL_SYSCFG_EXTI_PORTG (*)
N  *         @arg @ref LL_SYSCFG_EXTI_PORTH
N  *         @arg @ref LL_SYSCFG_EXTI_PORTI (*)
N  *
N  *         (*) value not defined in all devices
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_GetEXTISource(uint32_t Line)
Xstatic __inline uint32_t LL_SYSCFG_GetEXTISource(uint32_t Line)
N{
N  return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFFU], (Line >> 16U)) >> POSITION_VAL(Line >> 16U));
X  return (uint32_t)(((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->EXTICR[Line & 0xFFU]) & ((Line >> 16U))) >> (__clz(__rbit(Line >> 16U))));
N}
N
N/**
N  * @brief  Enable SRAM2 Erase (starts a hardware SRAM2 erase operation. This bit is
N  * automatically cleared at the end of the SRAM2 erase operation.)
N  * @note This bit is write-protected: setting this bit is possible only after the
N  *       correct key sequence is written in the SYSCFG_SKR register as described in 
N  *       the Reference Manual.
N  * @rmtoll SYSCFG_SCSR  SRAM2ER       LL_SYSCFG_EnableSRAM2Erase
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_EnableSRAM2Erase(void)
Xstatic __inline void LL_SYSCFG_EnableSRAM2Erase(void)
N{
N  /* Starts a hardware SRAM2 erase operation*/
N  SET_BIT(SYSCFG->SCSR, SYSCFG_SCSR_SRAM2ER);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->SCSR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if SRAM2 erase operation is on going
N  * @rmtoll SYSCFG_SCSR  SRAM2BSY      LL_SYSCFG_IsSRAM2EraseOngoing
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsSRAM2EraseOngoing(void)
Xstatic __inline uint32_t LL_SYSCFG_IsSRAM2EraseOngoing(void)
N{
N  return (READ_BIT(SYSCFG->SCSR, SYSCFG_SCSR_SRAM2BSY) == (SYSCFG_SCSR_SRAM2BSY));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->SCSR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Set connections to TIM1/8/15/16/17 Break inputs
N  * @rmtoll SYSCFG_CFGR2 CLL           LL_SYSCFG_SetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 SPL           LL_SYSCFG_SetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 PVDL          LL_SYSCFG_SetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 ECCL          LL_SYSCFG_SetTIMBreakInputs
N  * @param  Break This parameter can be a combination of the following values:
N  *         @arg @ref LL_SYSCFG_TIMBREAK_ECC
N  *         @arg @ref LL_SYSCFG_TIMBREAK_PVD
N  *         @arg @ref LL_SYSCFG_TIMBREAK_SRAM2_PARITY
N  *         @arg @ref LL_SYSCFG_TIMBREAK_LOCKUP
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_SetTIMBreakInputs(uint32_t Break)
Xstatic __inline void LL_SYSCFG_SetTIMBreakInputs(uint32_t Break)
N{
N  MODIFY_REG(SYSCFG->CFGR2, SYSCFG_CFGR2_CLL | SYSCFG_CFGR2_SPL | SYSCFG_CFGR2_PVDL | SYSCFG_CFGR2_ECCL, Break);
X  (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR2)) = ((((((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR2))) & (~((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (2U)) | (0x1UL << (3U))))) | (Break))));
N}
N
N/**
N  * @brief  Get connections to TIM1/8/15/16/17 Break inputs
N  * @rmtoll SYSCFG_CFGR2 CLL           LL_SYSCFG_GetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 SPL           LL_SYSCFG_GetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 PVDL          LL_SYSCFG_GetTIMBreakInputs\n
N  *         SYSCFG_CFGR2 ECCL          LL_SYSCFG_GetTIMBreakInputs
N  * @retval Returned value can be can be a combination of the following values:
N  *         @arg @ref LL_SYSCFG_TIMBREAK_ECC
N  *         @arg @ref LL_SYSCFG_TIMBREAK_PVD
N  *         @arg @ref LL_SYSCFG_TIMBREAK_SRAM2_PARITY
N  *         @arg @ref LL_SYSCFG_TIMBREAK_LOCKUP
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_GetTIMBreakInputs(void)
Xstatic __inline uint32_t LL_SYSCFG_GetTIMBreakInputs(void)
N{
N  return (uint32_t)(READ_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_CLL | SYSCFG_CFGR2_SPL | SYSCFG_CFGR2_PVDL | SYSCFG_CFGR2_ECCL));
X  return (uint32_t)(((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR2) & ((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (2U)) | (0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Check if SRAM2 parity error detected
N  * @rmtoll SYSCFG_CFGR2 SPF           LL_SYSCFG_IsActiveFlag_SP
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSCFG_IsActiveFlag_SP(void)
Xstatic __inline uint32_t LL_SYSCFG_IsActiveFlag_SP(void)
N{
N  return (READ_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SPF) == (SYSCFG_CFGR2_SPF));
X  return (((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR2) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear SRAM2 parity error flag
N  * @rmtoll SYSCFG_CFGR2 SPF           LL_SYSCFG_ClearFlag_SP
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_ClearFlag_SP(void)
Xstatic __inline void LL_SYSCFG_ClearFlag_SP(void)
N{
N  SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SPF);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->CFGR2) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable SRAM2 page write protection for Pages in range 0 to 31
N  * @note Write protection is cleared only by a system reset
N  * @rmtoll SYSCFG_SWPR  PxWP         LL_SYSCFG_EnableSRAM2PageWRP_0_31
N  * @param  SRAM2WRP This parameter can be a combination of the following values:
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE0
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE1
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE2
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE3
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE4
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE5
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE6
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE7
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE8
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE9
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE10
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE11
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE12
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE13
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE14
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE15
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE16 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE17 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE18 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE19 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE20 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE21 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE22 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE23 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE24 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE25 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE26 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE27 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE28 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE29 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE30 (*)
N  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE31 (*)
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N/* Legacy define */
N#define LL_SYSCFG_EnableSRAM2PageWRP    LL_SYSCFG_EnableSRAM2PageWRP_0_31
N__STATIC_INLINE void LL_SYSCFG_EnableSRAM2PageWRP_0_31(uint32_t SRAM2WRP)
Xstatic __inline void LL_SYSCFG_EnableSRAM2PageWRP_0_31(uint32_t SRAM2WRP)
N{
N  SET_BIT(SYSCFG->SWPR, SRAM2WRP);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->SWPR) |= (SRAM2WRP));
N}
N
N#if defined(SYSCFG_SWPR2_PAGE63)
X#if 0L
S/**
S  * @brief  Enable SRAM2 page write protection for Pages in range 32 to 63
S  * @note Write protection is cleared only by a system reset
S  * @rmtoll SYSCFG_SWPR2 PxWP          LL_SYSCFG_EnableSRAM2PageWRP_32_63
S  * @param  SRAM2WRP This parameter can be a combination of the following values:
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE32 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE33 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE34 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE35 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE36 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE37 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE38 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE39 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE40 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE41 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE42 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE43 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE44 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE45 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE46 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE47 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE48 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE49 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE50 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE51 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE52 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE53 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE54 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE55 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE56 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE57 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE58 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE59 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE60 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE61 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE62 (*)
S  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE63 (*)
S  *
S  *         (*) value not defined in all devices
S  * @retval None
S  */
S__STATIC_INLINE void LL_SYSCFG_EnableSRAM2PageWRP_32_63(uint32_t SRAM2WRP)
S{
S  SET_BIT(SYSCFG->SWPR2, SRAM2WRP);
S}
N#endif /* SYSCFG_SWPR2_PAGE63 */
N
N/**
N  * @brief  SRAM2 page write protection lock prior to erase
N  * @rmtoll SYSCFG_SKR   KEY           LL_SYSCFG_LockSRAM2WRP
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_LockSRAM2WRP(void)
Xstatic __inline void LL_SYSCFG_LockSRAM2WRP(void)
N{
N  /* Writing a wrong key reactivates the write protection */
N  WRITE_REG(SYSCFG->SKR, 0x00);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->SKR) = (0x00));
N}
N
N/**
N  * @brief  SRAM2 page write protection unlock prior to erase
N  * @rmtoll SYSCFG_SKR   KEY           LL_SYSCFG_UnlockSRAM2WRP
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSCFG_UnlockSRAM2WRP(void)
Xstatic __inline void LL_SYSCFG_UnlockSRAM2WRP(void)
N{
N  /* unlock the write protection of the SRAM2ER bit */
N  WRITE_REG(SYSCFG->SKR, 0xCA);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->SKR) = (0xCA));
N  WRITE_REG(SYSCFG->SKR, 0x53);
X  ((((SYSCFG_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0000UL))->SKR) = (0x53));
N}
N
N/**
N  * @}
N  */
N
N
N/** @defgroup SYSTEM_LL_EF_DBGMCU DBGMCU
N  * @{
N  */
N
N/**
N  * @brief  Return the device identifier
N  * @rmtoll DBGMCU_IDCODE DEV_ID        LL_DBGMCU_GetDeviceID
N  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF (ex: device ID is 0x6415)
N  */
N__STATIC_INLINE uint32_t LL_DBGMCU_GetDeviceID(void)
Xstatic __inline uint32_t LL_DBGMCU_GetDeviceID(void)
N{
N  return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_DEV_ID));
X  return (uint32_t)(((((DBGMCU_TypeDef *) (0xE0042000UL))->IDCODE) & ((0xFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Return the device revision identifier
N  * @note This field indicates the revision of the device.
N  * @rmtoll DBGMCU_IDCODE REV_ID        LL_DBGMCU_GetRevisionID
N  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
N  */
N__STATIC_INLINE uint32_t LL_DBGMCU_GetRevisionID(void)
Xstatic __inline uint32_t LL_DBGMCU_GetRevisionID(void)
N{
N  return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_REV_ID) >> DBGMCU_IDCODE_REV_ID_Pos);
X  return (uint32_t)(((((DBGMCU_TypeDef *) (0xE0042000UL))->IDCODE) & ((0xFFFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Enable the Debug Module during SLEEP mode
N  * @rmtoll DBGMCU_CR    DBG_SLEEP     LL_DBGMCU_EnableDBGSleepMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_EnableDBGSleepMode(void)
Xstatic __inline void LL_DBGMCU_EnableDBGSleepMode(void)
N{
N  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable the Debug Module during SLEEP mode
N  * @rmtoll DBGMCU_CR    DBG_SLEEP     LL_DBGMCU_DisableDBGSleepMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_DisableDBGSleepMode(void)
Xstatic __inline void LL_DBGMCU_DisableDBGSleepMode(void)
N{
N  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable the Debug Module during STOP mode
N  * @rmtoll DBGMCU_CR    DBG_STOP      LL_DBGMCU_EnableDBGStopMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_EnableDBGStopMode(void)
Xstatic __inline void LL_DBGMCU_EnableDBGStopMode(void)
N{
N  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable the Debug Module during STOP mode
N  * @rmtoll DBGMCU_CR    DBG_STOP      LL_DBGMCU_DisableDBGStopMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_DisableDBGStopMode(void)
Xstatic __inline void LL_DBGMCU_DisableDBGStopMode(void)
N{
N  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable the Debug Module during STANDBY mode
N  * @rmtoll DBGMCU_CR    DBG_STANDBY   LL_DBGMCU_EnableDBGStandbyMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_EnableDBGStandbyMode(void)
Xstatic __inline void LL_DBGMCU_EnableDBGStandbyMode(void)
N{
N  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable the Debug Module during STANDBY mode
N  * @rmtoll DBGMCU_CR    DBG_STANDBY   LL_DBGMCU_DisableDBGStandbyMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_DisableDBGStandbyMode(void)
Xstatic __inline void LL_DBGMCU_DisableDBGStandbyMode(void)
N{
N  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Set Trace pin assignment control
N  * @rmtoll DBGMCU_CR    TRACE_IOEN    LL_DBGMCU_SetTracePinAssignment\n
N  *         DBGMCU_CR    TRACE_MODE    LL_DBGMCU_SetTracePinAssignment
N  * @param  PinAssignment This parameter can be one of the following values:
N  *         @arg @ref LL_DBGMCU_TRACE_NONE
N  *         @arg @ref LL_DBGMCU_TRACE_ASYNCH
N  *         @arg @ref LL_DBGMCU_TRACE_SYNCH_SIZE1
N  *         @arg @ref LL_DBGMCU_TRACE_SYNCH_SIZE2
N  *         @arg @ref LL_DBGMCU_TRACE_SYNCH_SIZE4
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_SetTracePinAssignment(uint32_t PinAssignment)
Xstatic __inline void LL_DBGMCU_SetTracePinAssignment(uint32_t PinAssignment)
N{
N  MODIFY_REG(DBGMCU->CR, DBGMCU_CR_TRACE_IOEN | DBGMCU_CR_TRACE_MODE, PinAssignment);
X  (((((DBGMCU_TypeDef *) (0xE0042000UL))->CR)) = ((((((((DBGMCU_TypeDef *) (0xE0042000UL))->CR))) & (~((0x1UL << (5U)) | (0x3UL << (6U))))) | (PinAssignment))));
N}
N
N/**
N  * @brief  Get Trace pin assignment control
N  * @rmtoll DBGMCU_CR    TRACE_IOEN    LL_DBGMCU_GetTracePinAssignment\n
N  *         DBGMCU_CR    TRACE_MODE    LL_DBGMCU_GetTracePinAssignment
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DBGMCU_TRACE_NONE
N  *         @arg @ref LL_DBGMCU_TRACE_ASYNCH
N  *         @arg @ref LL_DBGMCU_TRACE_SYNCH_SIZE1
N  *         @arg @ref LL_DBGMCU_TRACE_SYNCH_SIZE2
N  *         @arg @ref LL_DBGMCU_TRACE_SYNCH_SIZE4
N  */
N__STATIC_INLINE uint32_t LL_DBGMCU_GetTracePinAssignment(void)
Xstatic __inline uint32_t LL_DBGMCU_GetTracePinAssignment(void)
N{
N  return (uint32_t)(READ_BIT(DBGMCU->CR, DBGMCU_CR_TRACE_IOEN | DBGMCU_CR_TRACE_MODE));
X  return (uint32_t)(((((DBGMCU_TypeDef *) (0xE0042000UL))->CR) & ((0x1UL << (5U)) | (0x3UL << (6U)))));
N}
N
N/**
N  * @brief  Freeze APB1 peripherals (group1 peripherals)
N  * @rmtoll DBGMCU_APB1FZR1 DBG_xxxx_STOP  LL_DBGMCU_APB1_GRP1_FreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM2_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM3_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM4_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM5_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM6_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM7_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_RTC_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_WWDG_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_IWDG_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_I2C1_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_I2C2_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_I2C3_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_CAN_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_CAN2_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_LPTIM1_STOP
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_APB1_GRP1_FreezePeriph(uint32_t Periphs)
Xstatic __inline void LL_DBGMCU_APB1_GRP1_FreezePeriph(uint32_t Periphs)
N{
N  SET_BIT(DBGMCU->APB1FZR1, Periphs);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->APB1FZR1) |= (Periphs));
N}
N
N/**
N  * @brief  Freeze APB1 peripherals (group2 peripherals)
N  * @rmtoll DBGMCU_APB1FZR2 DBG_xxxx_STOP  LL_DBGMCU_APB1_GRP2_FreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_DBGMCU_APB1_GRP2_I2C4_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP2_LPTIM2_STOP
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_APB1_GRP2_FreezePeriph(uint32_t Periphs)
Xstatic __inline void LL_DBGMCU_APB1_GRP2_FreezePeriph(uint32_t Periphs)
N{
N  SET_BIT(DBGMCU->APB1FZR2, Periphs);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->APB1FZR2) |= (Periphs));
N}
N
N/**
N  * @brief  Unfreeze APB1 peripherals (group1 peripherals)
N  * @rmtoll DBGMCU_APB1FZR1 DBG_xxxx_STOP  LL_DBGMCU_APB1_GRP1_UnFreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM2_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM3_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM4_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM5_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM6_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_TIM7_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_RTC_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_WWDG_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_IWDG_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_I2C1_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_I2C2_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_I2C3_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_CAN_STOP
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_CAN2_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP1_LPTIM1_STOP
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_APB1_GRP1_UnFreezePeriph(uint32_t Periphs)
Xstatic __inline void LL_DBGMCU_APB1_GRP1_UnFreezePeriph(uint32_t Periphs)
N{
N  CLEAR_BIT(DBGMCU->APB1FZR1, Periphs);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->APB1FZR1) &= ~(Periphs));
N}
N
N/**
N  * @brief  Unfreeze APB1 peripherals (group2 peripherals)
N  * @rmtoll DBGMCU_APB1FZR2 DBG_xxxx_STOP  LL_DBGMCU_APB1_GRP2_UnFreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_DBGMCU_APB1_GRP2_I2C4_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB1_GRP2_LPTIM2_STOP
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_APB1_GRP2_UnFreezePeriph(uint32_t Periphs)
Xstatic __inline void LL_DBGMCU_APB1_GRP2_UnFreezePeriph(uint32_t Periphs)
N{
N  CLEAR_BIT(DBGMCU->APB1FZR2, Periphs);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->APB1FZR2) &= ~(Periphs));
N}
N
N/**
N  * @brief  Freeze APB2 peripherals
N  * @rmtoll DBGMCU_APB2FZ DBG_TIMx_STOP  LL_DBGMCU_APB2_GRP1_FreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM1_STOP
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM8_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM15_STOP
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM16_STOP
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM17_STOP (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_APB2_GRP1_FreezePeriph(uint32_t Periphs)
Xstatic __inline void LL_DBGMCU_APB2_GRP1_FreezePeriph(uint32_t Periphs)
N{
N  SET_BIT(DBGMCU->APB2FZ, Periphs);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->APB2FZ) |= (Periphs));
N}
N
N/**
N  * @brief  Unfreeze APB2 peripherals
N  * @rmtoll DBGMCU_APB2FZ DBG_TIMx_STOP  LL_DBGMCU_APB2_GRP1_UnFreezePeriph
N  * @param  Periphs This parameter can be a combination of the following values:
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM1_STOP
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM8_STOP (*)
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM15_STOP
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM16_STOP
N  *         @arg @ref LL_DBGMCU_APB2_GRP1_TIM17_STOP (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_DBGMCU_APB2_GRP1_UnFreezePeriph(uint32_t Periphs)
Xstatic __inline void LL_DBGMCU_APB2_GRP1_UnFreezePeriph(uint32_t Periphs)
N{
N  CLEAR_BIT(DBGMCU->APB2FZ, Periphs);
X  ((((DBGMCU_TypeDef *) (0xE0042000UL))->APB2FZ) &= ~(Periphs));
N}
N
N/**
N  * @}
N  */
N
N#if defined(VREFBUF)
X#if 1L
N/** @defgroup SYSTEM_LL_EF_VREFBUF VREFBUF
N  * @{
N  */
N
N/**
N  * @brief  Enable Internal voltage reference
N  * @rmtoll VREFBUF_CSR  ENVR          LL_VREFBUF_Enable
N  * @retval None
N  */
N__STATIC_INLINE void LL_VREFBUF_Enable(void)
Xstatic __inline void LL_VREFBUF_Enable(void)
N{
N  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
X  ((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable Internal voltage reference
N  * @rmtoll VREFBUF_CSR  ENVR          LL_VREFBUF_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_VREFBUF_Disable(void)
Xstatic __inline void LL_VREFBUF_Disable(void)
N{
N  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
X  ((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable high impedance (VREF+pin is high impedance)
N  * @rmtoll VREFBUF_CSR  HIZ           LL_VREFBUF_EnableHIZ
N  * @retval None
N  */
N__STATIC_INLINE void LL_VREFBUF_EnableHIZ(void)
Xstatic __inline void LL_VREFBUF_EnableHIZ(void)
N{
N  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_HIZ);
X  ((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable high impedance (VREF+pin is internally connected to the voltage reference buffer output)
N  * @rmtoll VREFBUF_CSR  HIZ           LL_VREFBUF_DisableHIZ
N  * @retval None
N  */
N__STATIC_INLINE void LL_VREFBUF_DisableHIZ(void)
Xstatic __inline void LL_VREFBUF_DisableHIZ(void)
N{
N  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_HIZ);
X  ((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Set the Voltage reference scale
N  * @rmtoll VREFBUF_CSR  VRS           LL_VREFBUF_SetVoltageScaling
N  * @param  Scale This parameter can be one of the following values:
N  *         @arg @ref LL_VREFBUF_VOLTAGE_SCALE0
N  *         @arg @ref LL_VREFBUF_VOLTAGE_SCALE1
N  * @retval None
N  */
N__STATIC_INLINE void LL_VREFBUF_SetVoltageScaling(uint32_t Scale)
Xstatic __inline void LL_VREFBUF_SetVoltageScaling(uint32_t Scale)
N{
N  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, Scale);
X  (((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR)) = ((((((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR))) & (~((0x1UL << (2U))))) | (Scale))));
N}
N
N/**
N  * @brief  Get the Voltage reference scale
N  * @rmtoll VREFBUF_CSR  VRS           LL_VREFBUF_GetVoltageScaling
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_VREFBUF_VOLTAGE_SCALE0
N  *         @arg @ref LL_VREFBUF_VOLTAGE_SCALE1
N  */
N__STATIC_INLINE uint32_t LL_VREFBUF_GetVoltageScaling(void)
Xstatic __inline uint32_t LL_VREFBUF_GetVoltageScaling(void)
N{
N  return (uint32_t)(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRS));
X  return (uint32_t)(((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR) & ((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Check if Voltage reference buffer is ready
N  * @rmtoll VREFBUF_CSR  VRR           LL_VREFBUF_IsVREFReady
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_VREFBUF_IsVREFReady(void)
Xstatic __inline uint32_t LL_VREFBUF_IsVREFReady(void)
N{
N  return (READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == (VREFBUF_CSR_VRR));
X  return (((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CSR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get the trimming code for VREFBUF calibration
N  * @rmtoll VREFBUF_CCR  TRIM          LL_VREFBUF_GetTrimming
N  * @retval Between 0 and 0x3F
N  */
N__STATIC_INLINE uint32_t LL_VREFBUF_GetTrimming(void)
Xstatic __inline uint32_t LL_VREFBUF_GetTrimming(void)
N{
N  return (uint32_t)(READ_BIT(VREFBUF->CCR, VREFBUF_CCR_TRIM));
X  return (uint32_t)(((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CCR) & ((0x3FUL << (0U)))));
N}
N
N/**
N  * @brief  Set the trimming code for VREFBUF calibration (Tune the internal reference buffer voltage)
N  * @rmtoll VREFBUF_CCR  TRIM          LL_VREFBUF_SetTrimming
N  * @param  Value Between 0 and 0x3F
N  * @retval None
N  */
N__STATIC_INLINE void LL_VREFBUF_SetTrimming(uint32_t Value)
Xstatic __inline void LL_VREFBUF_SetTrimming(uint32_t Value)
N{
N  WRITE_REG(VREFBUF->CCR, Value);
X  ((((VREFBUF_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0030UL))->CCR) = (Value));
N}
N
N/**
N  * @}
N  */
N#endif /* VREFBUF */
N
N/** @defgroup SYSTEM_LL_EF_FLASH FLASH
N  * @{
N  */
N
N/**
N  * @brief  Set FLASH Latency
N  * @rmtoll FLASH_ACR    LATENCY       LL_FLASH_SetLatency
N  * @param  Latency This parameter can be one of the following values:
N  *         @arg @ref LL_FLASH_LATENCY_0
N  *         @arg @ref LL_FLASH_LATENCY_1
N  *         @arg @ref LL_FLASH_LATENCY_2
N  *         @arg @ref LL_FLASH_LATENCY_3
N  *         @arg @ref LL_FLASH_LATENCY_4
N  *         @arg @ref LL_FLASH_LATENCY_5 (*)
N  *         @arg @ref LL_FLASH_LATENCY_6 (*)
N  *         @arg @ref LL_FLASH_LATENCY_7 (*)
N  *         @arg @ref LL_FLASH_LATENCY_8 (*)
N  *         @arg @ref LL_FLASH_LATENCY_9 (*)
N  *         @arg @ref LL_FLASH_LATENCY_10 (*)
N  *         @arg @ref LL_FLASH_LATENCY_11 (*)
N  *         @arg @ref LL_FLASH_LATENCY_12 (*)
N  *         @arg @ref LL_FLASH_LATENCY_13 (*)
N  *         @arg @ref LL_FLASH_LATENCY_14 (*)
N  *         @arg @ref LL_FLASH_LATENCY_15 (*)
N  *
N  *         (*) value not defined in all devices.
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
Xstatic __inline void LL_FLASH_SetLatency(uint32_t Latency)
N{
N  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
X  (((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR)) = ((((((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR))) & (~((0x7UL << (0U))))) | (Latency))));
N}
N
N/**
N  * @brief  Get FLASH Latency
N  * @rmtoll FLASH_ACR    LATENCY       LL_FLASH_GetLatency
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_FLASH_LATENCY_0
N  *         @arg @ref LL_FLASH_LATENCY_1
N  *         @arg @ref LL_FLASH_LATENCY_2
N  *         @arg @ref LL_FLASH_LATENCY_3
N  *         @arg @ref LL_FLASH_LATENCY_4
N  *         @arg @ref LL_FLASH_LATENCY_5 (*)
N  *         @arg @ref LL_FLASH_LATENCY_6 (*)
N  *         @arg @ref LL_FLASH_LATENCY_7 (*)
N  *         @arg @ref LL_FLASH_LATENCY_8 (*)
N  *         @arg @ref LL_FLASH_LATENCY_9 (*)
N  *         @arg @ref LL_FLASH_LATENCY_10 (*)
N  *         @arg @ref LL_FLASH_LATENCY_11 (*)
N  *         @arg @ref LL_FLASH_LATENCY_12 (*)
N  *         @arg @ref LL_FLASH_LATENCY_13 (*)
N  *         @arg @ref LL_FLASH_LATENCY_14 (*)
N  *         @arg @ref LL_FLASH_LATENCY_15 (*)
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
Xstatic __inline uint32_t LL_FLASH_GetLatency(void)
N{
N  return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
X  return (uint32_t)(((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) & ((0x7UL << (0U)))));
N}
N
N/**
N  * @brief  Enable Prefetch
N  * @rmtoll FLASH_ACR    PRFTEN        LL_FLASH_EnablePrefetch
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnablePrefetch(void)
Xstatic __inline void LL_FLASH_EnablePrefetch(void)
N{
N  SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable Prefetch
N  * @rmtoll FLASH_ACR    PRFTEN        LL_FLASH_DisablePrefetch
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisablePrefetch(void)
Xstatic __inline void LL_FLASH_DisablePrefetch(void)
N{
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if Prefetch buffer is enabled
N  * @rmtoll FLASH_ACR    PRFTEN        LL_FLASH_IsPrefetchEnabled
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_FLASH_IsPrefetchEnabled(void)
Xstatic __inline uint32_t LL_FLASH_IsPrefetchEnabled(void)
N{
N  return (READ_BIT(FLASH->ACR, FLASH_ACR_PRFTEN) == (FLASH_ACR_PRFTEN));
X  return (((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable Instruction cache
N  * @rmtoll FLASH_ACR    ICEN          LL_FLASH_EnableInstCache
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnableInstCache(void)
Xstatic __inline void LL_FLASH_EnableInstCache(void)
N{
N  SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable Instruction cache
N  * @rmtoll FLASH_ACR    ICEN          LL_FLASH_DisableInstCache
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisableInstCache(void)
Xstatic __inline void LL_FLASH_DisableInstCache(void)
N{
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_ICEN);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Enable Data cache
N  * @rmtoll FLASH_ACR    DCEN          LL_FLASH_EnableDataCache
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnableDataCache(void)
Xstatic __inline void LL_FLASH_EnableDataCache(void)
N{
N  SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable Data cache
N  * @rmtoll FLASH_ACR    DCEN          LL_FLASH_DisableDataCache
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisableDataCache(void)
Xstatic __inline void LL_FLASH_DisableDataCache(void)
N{
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_DCEN);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Enable Instruction cache reset
N  * @note  bit can be written only when the instruction cache is disabled
N  * @rmtoll FLASH_ACR    ICRST         LL_FLASH_EnableInstCacheReset
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnableInstCacheReset(void)
Xstatic __inline void LL_FLASH_EnableInstCacheReset(void)
N{
N  SET_BIT(FLASH->ACR, FLASH_ACR_ICRST);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable Instruction cache reset
N  * @rmtoll FLASH_ACR    ICRST         LL_FLASH_DisableInstCacheReset
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisableInstCacheReset(void)
Xstatic __inline void LL_FLASH_DisableInstCacheReset(void)
N{
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_ICRST);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Enable Data cache reset
N  * @note bit can be written only when the data cache is disabled
N  * @rmtoll FLASH_ACR    DCRST         LL_FLASH_EnableDataCacheReset
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnableDataCacheReset(void)
Xstatic __inline void LL_FLASH_EnableDataCacheReset(void)
N{
N  SET_BIT(FLASH->ACR, FLASH_ACR_DCRST);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable Data cache reset
N  * @rmtoll FLASH_ACR    DCRST         LL_FLASH_DisableDataCacheReset
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisableDataCacheReset(void)
Xstatic __inline void LL_FLASH_DisableDataCacheReset(void)
N{
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_DCRST);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Enable Flash Power-down mode during run mode or Low-power run mode
N  * @note Flash memory can be put in power-down mode only when the code is executed
N  *       from RAM
N  * @note Flash must not be accessed when power down is enabled
N  * @note Flash must not be put in power-down while a program or an erase operation
N  *       is on-going
N  * @rmtoll FLASH_ACR    RUN_PD        LL_FLASH_EnableRunPowerDown\n
N  *         FLASH_PDKEYR PDKEY1        LL_FLASH_EnableRunPowerDown\n
N  *         FLASH_PDKEYR PDKEY2        LL_FLASH_EnableRunPowerDown
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnableRunPowerDown(void)
Xstatic __inline void LL_FLASH_EnableRunPowerDown(void)
N{
N  /* Following values must be written consecutively to unlock the RUN_PD bit in
N     FLASH_ACR */
N  WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY1);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->PDKEYR) = (0x04152637U));
N  WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY2);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->PDKEYR) = (0xFAFBFCFDU));
N  SET_BIT(FLASH->ACR, FLASH_ACR_RUN_PD);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable Flash Power-down mode during run mode or Low-power run mode
N  * @rmtoll FLASH_ACR    RUN_PD        LL_FLASH_DisableRunPowerDown\n
N  *         FLASH_PDKEYR PDKEY1        LL_FLASH_DisableRunPowerDown\n
N  *         FLASH_PDKEYR PDKEY2        LL_FLASH_DisableRunPowerDown
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisableRunPowerDown(void)
Xstatic __inline void LL_FLASH_DisableRunPowerDown(void)
N{
N  /* Following values must be written consecutively to unlock the RUN_PD bit in
N     FLASH_ACR */
N  WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY1);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->PDKEYR) = (0x04152637U));
N  WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY2);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->PDKEYR) = (0xFAFBFCFDU));
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_RUN_PD);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Enable Flash Power-down mode during Sleep or Low-power sleep mode
N  * @note Flash must not be put in power-down while a program or an erase operation
N  *       is on-going
N  * @rmtoll FLASH_ACR    SLEEP_PD      LL_FLASH_EnableSleepPowerDown
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_EnableSleepPowerDown(void)
Xstatic __inline void LL_FLASH_EnableSleepPowerDown(void)
N{
N  SET_BIT(FLASH->ACR, FLASH_ACR_SLEEP_PD);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable Flash Power-down mode during Sleep or Low-power sleep mode
N  * @rmtoll FLASH_ACR    SLEEP_PD      LL_FLASH_DisableSleepPowerDown
N  * @retval None
N  */
N__STATIC_INLINE void LL_FLASH_DisableSleepPowerDown(void)
Xstatic __inline void LL_FLASH_DisableSleepPowerDown(void)
N{
N  CLEAR_BIT(FLASH->ACR, FLASH_ACR_SLEEP_PD);
X  ((((FLASH_TypeDef *) (((0x40000000UL) + 0x00020000UL) + 0x2000UL))->ACR) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* defined (FLASH) || defined (SYSCFG) || defined (DBGMCU) || defined (VREFBUF) */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_SYSTEM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 10 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_exti.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_exti.h
N  * @author  MCD Application Team
N  * @brief   Header file of EXTI LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_EXTI_H
N#define __STM32L4xx_LL_EXTI_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (EXTI)
X#if 1L
N
N/** @defgroup EXTI_LL EXTI
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private Macros ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup EXTI_LL_Private_Macros EXTI Private Macros
N  * @{
N  */
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup EXTI_LL_ES_INIT EXTI Exported Init structure
N  * @{
N  */
Ntypedef struct
N{
N
N  uint32_t Line_0_31;           /*!< Specifies the EXTI lines to be enabled or disabled for Lines in range 0 to 31
N                                     This parameter can be any combination of @ref EXTI_LL_EC_LINE */
N
N  uint32_t Line_32_63;          /*!< Specifies the EXTI lines to be enabled or disabled for Lines in range 32 to 63
N                                     This parameter can be any combination of @ref EXTI_LL_EC_LINE */
N
N  FunctionalState LineCommand;  /*!< Specifies the new state of the selected EXTI lines.
N                                     This parameter can be set either to ENABLE or DISABLE */
N
N  uint8_t Mode;                 /*!< Specifies the mode for the EXTI lines.
N                                     This parameter can be a value of @ref EXTI_LL_EC_MODE. */
N
N  uint8_t Trigger;              /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                     This parameter can be a value of @ref EXTI_LL_EC_TRIGGER. */
N} LL_EXTI_InitTypeDef;
N
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup EXTI_LL_Exported_Constants EXTI Exported Constants
N  * @{
N  */
N
N/** @defgroup EXTI_LL_EC_LINE LINE
N  * @{
N  */
N#define LL_EXTI_LINE_0                 EXTI_IMR1_IM0           /*!< Extended line 0 */
N#define LL_EXTI_LINE_1                 EXTI_IMR1_IM1           /*!< Extended line 1 */
N#define LL_EXTI_LINE_2                 EXTI_IMR1_IM2           /*!< Extended line 2 */
N#define LL_EXTI_LINE_3                 EXTI_IMR1_IM3           /*!< Extended line 3 */
N#define LL_EXTI_LINE_4                 EXTI_IMR1_IM4           /*!< Extended line 4 */
N#define LL_EXTI_LINE_5                 EXTI_IMR1_IM5           /*!< Extended line 5 */
N#define LL_EXTI_LINE_6                 EXTI_IMR1_IM6           /*!< Extended line 6 */
N#define LL_EXTI_LINE_7                 EXTI_IMR1_IM7           /*!< Extended line 7 */
N#define LL_EXTI_LINE_8                 EXTI_IMR1_IM8           /*!< Extended line 8 */
N#define LL_EXTI_LINE_9                 EXTI_IMR1_IM9           /*!< Extended line 9 */
N#define LL_EXTI_LINE_10                EXTI_IMR1_IM10          /*!< Extended line 10 */
N#define LL_EXTI_LINE_11                EXTI_IMR1_IM11          /*!< Extended line 11 */
N#define LL_EXTI_LINE_12                EXTI_IMR1_IM12          /*!< Extended line 12 */
N#define LL_EXTI_LINE_13                EXTI_IMR1_IM13          /*!< Extended line 13 */
N#define LL_EXTI_LINE_14                EXTI_IMR1_IM14          /*!< Extended line 14 */
N#define LL_EXTI_LINE_15                EXTI_IMR1_IM15          /*!< Extended line 15 */
N#if defined(EXTI_IMR1_IM16)
X#if 1L
N#define LL_EXTI_LINE_16                EXTI_IMR1_IM16          /*!< Extended line 16 */
N#endif
N#define LL_EXTI_LINE_17                EXTI_IMR1_IM17          /*!< Extended line 17 */
N#if defined(EXTI_IMR1_IM18)
X#if 1L
N#define LL_EXTI_LINE_18                EXTI_IMR1_IM18          /*!< Extended line 18 */
N#endif
N#define LL_EXTI_LINE_19                EXTI_IMR1_IM19          /*!< Extended line 19 */
N#if defined(EXTI_IMR1_IM20)
X#if 1L
N#define LL_EXTI_LINE_20                EXTI_IMR1_IM20          /*!< Extended line 20 */
N#endif
N#if defined(EXTI_IMR1_IM21)
X#if 1L
N#define LL_EXTI_LINE_21                EXTI_IMR1_IM21          /*!< Extended line 21 */
N#endif
N#if defined(EXTI_IMR1_IM22)
X#if 1L
N#define LL_EXTI_LINE_22                EXTI_IMR1_IM22          /*!< Extended line 22 */
N#endif
N#define LL_EXTI_LINE_23                EXTI_IMR1_IM23          /*!< Extended line 23 */
N#if defined(EXTI_IMR1_IM24)
X#if 1L
N#define LL_EXTI_LINE_24                EXTI_IMR1_IM24          /*!< Extended line 24 */
N#endif
N#if defined(EXTI_IMR1_IM25)
X#if 1L
N#define LL_EXTI_LINE_25                EXTI_IMR1_IM25          /*!< Extended line 25 */
N#endif
N#if defined(EXTI_IMR1_IM26)
X#if 1L
N#define LL_EXTI_LINE_26                EXTI_IMR1_IM26          /*!< Extended line 26 */
N#endif
N#if defined(EXTI_IMR1_IM27)
X#if 1L
N#define LL_EXTI_LINE_27                EXTI_IMR1_IM27          /*!< Extended line 27 */
N#endif
N#if defined(EXTI_IMR1_IM28)
X#if 1L
N#define LL_EXTI_LINE_28                EXTI_IMR1_IM28          /*!< Extended line 28 */
N#endif
N#if defined(EXTI_IMR1_IM29)
X#if 0L
S#define LL_EXTI_LINE_29                EXTI_IMR1_IM29          /*!< Extended line 29 */
N#endif
N#if defined(EXTI_IMR1_IM30)
X#if 0L
S#define LL_EXTI_LINE_30                EXTI_IMR1_IM30          /*!< Extended line 30 */
N#endif
N#if defined(EXTI_IMR1_IM31)
X#if 1L
N#define LL_EXTI_LINE_31                EXTI_IMR1_IM31          /*!< Extended line 31 */
N#endif
N#define LL_EXTI_LINE_ALL_0_31          EXTI_IMR1_IM            /*!< All Extended line not reserved*/
N
N#define LL_EXTI_LINE_32                EXTI_IMR2_IM32          /*!< Extended line 32 */
N#if defined(EXTI_IMR2_IM33)
X#if 1L
N#define LL_EXTI_LINE_33                EXTI_IMR2_IM33          /*!< Extended line 33 */
N#endif
N#if defined(EXTI_IMR2_IM34)
X#if 1L
N#define LL_EXTI_LINE_34                EXTI_IMR2_IM34          /*!< Extended line 34 */
N#endif
N#if defined(EXTI_IMR2_IM35)
X#if 0L
S#define LL_EXTI_LINE_35                EXTI_IMR2_IM35          /*!< Extended line 35 */
N#endif
N#if defined(EXTI_IMR2_IM36)
X#if 0L
S#define LL_EXTI_LINE_36                EXTI_IMR2_IM36          /*!< Extended line 36 */
N#endif
N#if defined(EXTI_IMR2_IM37)
X#if 1L
N#define LL_EXTI_LINE_37                EXTI_IMR2_IM37          /*!< Extended line 37 */
N#endif
N#if defined(EXTI_IMR2_IM38)
X#if 1L
N#define LL_EXTI_LINE_38                EXTI_IMR2_IM38          /*!< Extended line 38 */
N#endif
N#if defined(EXTI_IMR2_IM39)
X#if 0L
S#define LL_EXTI_LINE_39                EXTI_IMR2_IM39          /*!< Extended line 39 */
N#endif
N#if defined(EXTI_IMR2_IM40)
X#if 0L
S#define LL_EXTI_LINE_40                EXTI_IMR2_IM40          /*!< Extended line 40 */
N#endif
N#define LL_EXTI_LINE_ALL_32_63         EXTI_IMR2_IM            /*!< All Extended line not reserved*/
N
N
N#define LL_EXTI_LINE_ALL               (0xFFFFFFFFU)  /*!< All Extended line */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N#define LL_EXTI_LINE_NONE              (0x00000000U)  /*!< None Extended line */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/**
N  * @}
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N
N/** @defgroup EXTI_LL_EC_MODE Mode
N  * @{
N  */
N#define LL_EXTI_MODE_IT                 ((uint8_t)0x00U) /*!< Interrupt Mode */
N#define LL_EXTI_MODE_EVENT              ((uint8_t)0x01U) /*!< Event Mode */
N#define LL_EXTI_MODE_IT_EVENT           ((uint8_t)0x02U) /*!< Interrupt & Event Mode */
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_LL_EC_TRIGGER Edge Trigger
N  * @{
N  */
N#define LL_EXTI_TRIGGER_NONE            ((uint8_t)0x00U) /*!< No Trigger Mode */
N#define LL_EXTI_TRIGGER_RISING          ((uint8_t)0x01U) /*!< Trigger Rising Mode */
N#define LL_EXTI_TRIGGER_FALLING         ((uint8_t)0x02U) /*!< Trigger Falling Mode */
N#define LL_EXTI_TRIGGER_RISING_FALLING  ((uint8_t)0x03U) /*!< Trigger Rising & Falling Mode */
N
N/**
N  * @}
N  */
N
N
N#endif /*USE_FULL_LL_DRIVER*/
N
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup EXTI_LL_Exported_Macros EXTI Exported Macros
N  * @{
N  */
N
N/** @defgroup EXTI_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in EXTI register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_EXTI_WriteReg(__REG__, __VALUE__) WRITE_REG(EXTI->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in EXTI register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_EXTI_ReadReg(__REG__) READ_REG(EXTI->__REG__)
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup EXTI_LL_Exported_Functions EXTI Exported Functions
N * @{
N */
N/** @defgroup EXTI_LL_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Interrupt request for Lines in range 0 to 31
N  * @note The reset value for the direct or internal lines (see RM)
N  *       is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR1         IMx           LL_EXTI_EnableIT_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_17
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_23
N  *         @arg @ref LL_EXTI_LINE_24
N  *         @arg @ref LL_EXTI_LINE_25
N  *         @arg @ref LL_EXTI_LINE_26
N  *         @arg @ref LL_EXTI_LINE_27
N  *         @arg @ref LL_EXTI_LINE_28
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  *         @arg @ref LL_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableIT_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableIT_0_31(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->IMR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->IMR1) |= (ExtiLine));
N}
N/**
N  * @brief  Enable ExtiLine Interrupt request for Lines in range 32 to 63
N  * @note The reset value for the direct lines (lines from 32 to 34, line
N  *       39) is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR2         IMx           LL_EXTI_EnableIT_32_63
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_32
N  *         @arg @ref LL_EXTI_LINE_33
N  *         @arg @ref LL_EXTI_LINE_34(*)
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  *         @arg @ref LL_EXTI_LINE_39(*)
N  *         @arg @ref LL_EXTI_LINE_40(*)
N  *         @arg @ref LL_EXTI_LINE_ALL_32_63
N  * @note   (*): Available in some devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->IMR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->IMR2) |= (ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Interrupt request for Lines in range 0 to 31
N  * @note The reset value for the direct or internal lines (see RM)
N  *       is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR1         IMx           LL_EXTI_DisableIT_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_17
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_23
N  *         @arg @ref LL_EXTI_LINE_24
N  *         @arg @ref LL_EXTI_LINE_25
N  *         @arg @ref LL_EXTI_LINE_26
N  *         @arg @ref LL_EXTI_LINE_27
N  *         @arg @ref LL_EXTI_LINE_28
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  *         @arg @ref LL_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableIT_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableIT_0_31(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->IMR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->IMR1) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Interrupt request for Lines in range 32 to 63
N  * @note The reset value for the direct lines (lines from 32 to 34, line
N  *       39) is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR2         IMx           LL_EXTI_DisableIT_32_63
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_32
N  *         @arg @ref LL_EXTI_LINE_33
N  *         @arg @ref LL_EXTI_LINE_34(*)
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  *         @arg @ref LL_EXTI_LINE_39(*)
N  *         @arg @ref LL_EXTI_LINE_40(*)
N  *         @arg @ref LL_EXTI_LINE_ALL_32_63
N  * @note   (*): Available in some devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableIT_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableIT_32_63(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->IMR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->IMR2) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Indicate if ExtiLine Interrupt request is enabled for Lines in range 0 to 31
N  * @note The reset value for the direct or internal lines (see RM)
N  *       is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR1         IMx           LL_EXTI_IsEnabledIT_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_17
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_23
N  *         @arg @ref LL_EXTI_LINE_24
N  *         @arg @ref LL_EXTI_LINE_25
N  *         @arg @ref LL_EXTI_LINE_26
N  *         @arg @ref LL_EXTI_LINE_27
N  *         @arg @ref LL_EXTI_LINE_28
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  *         @arg @ref LL_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledIT_0_31(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledIT_0_31(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->IMR1, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->IMR1) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @brief  Indicate if ExtiLine Interrupt request is enabled for Lines in range 32 to 63
N  * @note The reset value for the direct lines (lines from 32 to 34, line
N  *       39) is set to 1 in order to enable the interrupt by default.
N  *       Bits are set automatically at Power on.
N  * @rmtoll IMR2         IMx           LL_EXTI_IsEnabledIT_32_63
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_32
N  *         @arg @ref LL_EXTI_LINE_33
N  *         @arg @ref LL_EXTI_LINE_34(*)
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  *         @arg @ref LL_EXTI_LINE_39(*)
N  *         @arg @ref LL_EXTI_LINE_40(*)
N  *         @arg @ref LL_EXTI_LINE_ALL_32_63
N  * @note   (*): Available in some devices
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledIT_32_63(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledIT_32_63(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->IMR2, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->IMR2) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_LL_EF_Event_Management Event_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Event request for Lines in range 0 to 31
N  * @rmtoll EMR1         EMx           LL_EXTI_EnableEvent_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_17
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_23
N  *         @arg @ref LL_EXTI_LINE_24
N  *         @arg @ref LL_EXTI_LINE_25
N  *         @arg @ref LL_EXTI_LINE_26
N  *         @arg @ref LL_EXTI_LINE_27
N  *         @arg @ref LL_EXTI_LINE_28
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  *         @arg @ref LL_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableEvent_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableEvent_0_31(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->EMR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->EMR1) |= (ExtiLine));
N
N}
N
N/**
N  * @brief  Enable ExtiLine Event request for Lines in range 32 to 63
N  * @rmtoll EMR2         EMx           LL_EXTI_EnableEvent_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_32
N  *         @arg @ref LL_EXTI_LINE_33
N  *         @arg @ref LL_EXTI_LINE_34(*)
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  *         @arg @ref LL_EXTI_LINE_39(*)
N  *         @arg @ref LL_EXTI_LINE_40(*)
N  *         @arg @ref LL_EXTI_LINE_ALL_32_63
N  * @note   (*): Available in some devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableEvent_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableEvent_32_63(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->EMR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->EMR2) |= (ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Event request for Lines in range 0 to 31
N  * @rmtoll EMR1         EMx           LL_EXTI_DisableEvent_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_17
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_23
N  *         @arg @ref LL_EXTI_LINE_24
N  *         @arg @ref LL_EXTI_LINE_25
N  *         @arg @ref LL_EXTI_LINE_26
N  *         @arg @ref LL_EXTI_LINE_27
N  *         @arg @ref LL_EXTI_LINE_28
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  *         @arg @ref LL_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->EMR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->EMR1) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Event request for Lines in range 32 to 63
N  * @rmtoll EMR2         EMx           LL_EXTI_DisableEvent_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_32
N  *         @arg @ref LL_EXTI_LINE_33
N  *         @arg @ref LL_EXTI_LINE_34(*)
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  *         @arg @ref LL_EXTI_LINE_39(*)
N  *         @arg @ref LL_EXTI_LINE_40(*)
N  *         @arg @ref LL_EXTI_LINE_ALL_32_63
N  * @note   (*): Available in some devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableEvent_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableEvent_32_63(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->EMR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->EMR2) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Indicate if ExtiLine Event request is enabled for Lines in range 0 to 31
N  * @rmtoll EMR1         EMx           LL_EXTI_IsEnabledEvent_0_31
N  * @param  ExtiLine This parameter can be one of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_17
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_23
N  *         @arg @ref LL_EXTI_LINE_24
N  *         @arg @ref LL_EXTI_LINE_25
N  *         @arg @ref LL_EXTI_LINE_26
N  *         @arg @ref LL_EXTI_LINE_27
N  *         @arg @ref LL_EXTI_LINE_28
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  *         @arg @ref LL_EXTI_LINE_ALL_0_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledEvent_0_31(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledEvent_0_31(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->EMR1, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->EMR1) & (ExtiLine)) == (ExtiLine));
N
N}
N
N/**
N  * @brief  Indicate if ExtiLine Event request is enabled for Lines in range 32 to 63
N  * @rmtoll EMR2         EMx           LL_EXTI_IsEnabledEvent_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_32
N  *         @arg @ref LL_EXTI_LINE_33
N  *         @arg @ref LL_EXTI_LINE_34(*)
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  *         @arg @ref LL_EXTI_LINE_39(*)
N  *         @arg @ref LL_EXTI_LINE_40(*)
N  *         @arg @ref LL_EXTI_LINE_ALL_32_63
N  * @note   (*): Available in some devices
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledEvent_32_63(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledEvent_32_63(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->EMR2, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->EMR2) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_LL_EF_Rising_Trigger_Management Rising_Trigger_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Rising Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a rising edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_RTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll RTSR1        RTx           LL_EXTI_EnableRisingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->RTSR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->RTSR1) |= (ExtiLine));
N
N}
N
N/**
N  * @brief  Enable ExtiLine Rising Edge Trigger for Lines in range 32 to 63
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a rising edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_RTSR register, the
N  *       pending bit is not set.Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll RTSR2        RTx           LL_EXTI_EnableRisingTrig_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->RTSR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->RTSR2) |= (ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Rising Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a rising edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_RTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll RTSR1        RTx           LL_EXTI_DisableRisingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->RTSR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->RTSR1) &= ~(ExtiLine));
N
N}
N
N/**
N  * @brief  Disable ExtiLine Rising Edge Trigger for Lines in range 32 to 63
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a rising edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_RTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll RTSR2        RTx           LL_EXTI_DisableRisingTrig_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableRisingTrig_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableRisingTrig_32_63(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->RTSR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->RTSR2) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Check if rising edge trigger is enabled for Lines in range 0 to 31
N  * @rmtoll RTSR1        RTx           LL_EXTI_IsEnabledRisingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledRisingTrig_0_31(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledRisingTrig_0_31(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->RTSR1, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->RTSR1) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @brief  Check if rising edge trigger is enabled for Lines in range 32 to 63
N  * @rmtoll RTSR2        RTx           LL_EXTI_IsEnabledRisingTrig_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledRisingTrig_32_63(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledRisingTrig_32_63(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->RTSR2, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->RTSR2) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_LL_EF_Falling_Trigger_Management Falling_Trigger_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable ExtiLine Falling Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a falling edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_FTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll FTSR1        FTx           LL_EXTI_EnableFallingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->FTSR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->FTSR1) |= (ExtiLine));
N}
N
N/**
N  * @brief  Enable ExtiLine Falling Edge Trigger for Lines in range 32 to 63
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a Falling edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_FTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for
N  *       the same interrupt line. In this case, both generate a trigger
N  *       condition.
N  * @rmtoll FTSR2        FTx           LL_EXTI_EnableFallingTrig_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_EnableFallingTrig_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_EnableFallingTrig_32_63(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->FTSR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->FTSR2) |= (ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Falling Edge Trigger for Lines in range 0 to 31
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a Falling edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_FTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for the same interrupt line.
N  *       In this case, both generate a trigger condition.
N  * @rmtoll FTSR1        FTx           LL_EXTI_DisableFallingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->FTSR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->FTSR1) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Disable ExtiLine Falling Edge Trigger for Lines in range 32 to 63
N  * @note The configurable wakeup lines are edge-triggered. No glitch must be
N  *       generated on these lines. If a Falling edge on a configurable interrupt
N  *       line occurs during a write operation in the EXTI_FTSR register, the
N  *       pending bit is not set.
N  *       Rising and falling edge triggers can be set for the same interrupt line.
N  *       In this case, both generate a trigger condition.
N  * @rmtoll FTSR2        FTx           LL_EXTI_DisableFallingTrig_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_DisableFallingTrig_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_DisableFallingTrig_32_63(uint32_t ExtiLine)
N{
N  CLEAR_BIT(EXTI->FTSR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->FTSR2) &= ~(ExtiLine));
N}
N
N/**
N  * @brief  Check if falling edge trigger is enabled for Lines in range 0 to 31
N  * @rmtoll FTSR1        FTx           LL_EXTI_IsEnabledFallingTrig_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledFallingTrig_0_31(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledFallingTrig_0_31(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->FTSR1, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->FTSR1) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @brief  Check if falling edge trigger is enabled for Lines in range 32 to 63
N  * @rmtoll FTSR2        FTx           LL_EXTI_IsEnabledFallingTrig_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsEnabledFallingTrig_32_63(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsEnabledFallingTrig_32_63(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->FTSR2, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->FTSR2) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_LL_EF_Software_Interrupt_Management Software_Interrupt_Management
N  * @{
N  */
N
N/**
N  * @brief  Generate a software Interrupt Event for Lines in range 0 to 31
N  * @note If the interrupt is enabled on this line in the EXTI_IMR1, writing a 1 to
N  *       this bit when it is at '0' sets the corresponding pending bit in EXTI_PR1
N  *       resulting in an interrupt request generation.
N  *       This bit is cleared by clearing the corresponding bit in the EXTI_PR1
N  *       register (by writing a 1 into the bit)
N  * @rmtoll SWIER1       SWIx          LL_EXTI_GenerateSWI_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_GenerateSWI_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_GenerateSWI_0_31(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->SWIER1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->SWIER1) |= (ExtiLine));
N}
N
N/**
N  * @brief  Generate a software Interrupt Event for Lines in range 32 to 63
N  * @note If the interrupt is enabled on this line inthe EXTI_IMR2, writing a 1 to
N  *       this bit when it is at '0' sets the corresponding pending bit in EXTI_PR2
N  *       resulting in an interrupt request generation.
N  *       This bit is cleared by clearing the corresponding bit in the EXTI_PR2
N  *       register (by writing a 1 into the bit)
N  * @rmtoll SWIER2       SWIx          LL_EXTI_GenerateSWI_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_GenerateSWI_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_GenerateSWI_32_63(uint32_t ExtiLine)
N{
N  SET_BIT(EXTI->SWIER2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->SWIER2) |= (ExtiLine));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_LL_EF_Flag_Management Flag_Management
N  * @{
N  */
N
N/**
N  * @brief  Check if the ExtLine Flag is set or not for Lines in range 0 to 31
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR1          PIFx           LL_EXTI_IsActiveFlag_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->PR1, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->PR1) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @brief  Check if the ExtLine Flag is set or not for  Lines in range 32 to 63
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR2          PIFx           LL_EXTI_IsActiveFlag_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_EXTI_IsActiveFlag_32_63(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_IsActiveFlag_32_63(uint32_t ExtiLine)
N{
N  return (READ_BIT(EXTI->PR2, ExtiLine) == (ExtiLine));
X  return (((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->PR2) & (ExtiLine)) == (ExtiLine));
N}
N
N/**
N  * @brief  Read ExtLine Combination Flag for Lines in range 0 to 31
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR1          PIFx           LL_EXTI_ReadFlag_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval @note This bit is set when the selected edge event arrives on the interrupt
N  */
N__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
N{
N  return (uint32_t)(READ_BIT(EXTI->PR1, ExtiLine));
X  return (uint32_t)(((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->PR1) & (ExtiLine)));
N}
N
N
N/**
N  * @brief  Read ExtLine Combination Flag for  Lines in range 32 to 63
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR2          PIFx           LL_EXTI_ReadFlag_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval @note This bit is set when the selected edge event arrives on the interrupt
N  */
N__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_32_63(uint32_t ExtiLine)
Xstatic __inline uint32_t LL_EXTI_ReadFlag_32_63(uint32_t ExtiLine)
N{
N  return (uint32_t)(READ_BIT(EXTI->PR2, ExtiLine));
X  return (uint32_t)(((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->PR2) & (ExtiLine)));
N}
N
N/**
N  * @brief  Clear ExtLine Flags  for Lines in range 0 to 31
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR1          PIFx           LL_EXTI_ClearFlag_0_31
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_0
N  *         @arg @ref LL_EXTI_LINE_1
N  *         @arg @ref LL_EXTI_LINE_2
N  *         @arg @ref LL_EXTI_LINE_3
N  *         @arg @ref LL_EXTI_LINE_4
N  *         @arg @ref LL_EXTI_LINE_5
N  *         @arg @ref LL_EXTI_LINE_6
N  *         @arg @ref LL_EXTI_LINE_7
N  *         @arg @ref LL_EXTI_LINE_8
N  *         @arg @ref LL_EXTI_LINE_9
N  *         @arg @ref LL_EXTI_LINE_10
N  *         @arg @ref LL_EXTI_LINE_11
N  *         @arg @ref LL_EXTI_LINE_12
N  *         @arg @ref LL_EXTI_LINE_13
N  *         @arg @ref LL_EXTI_LINE_14
N  *         @arg @ref LL_EXTI_LINE_15
N  *         @arg @ref LL_EXTI_LINE_16
N  *         @arg @ref LL_EXTI_LINE_18
N  *         @arg @ref LL_EXTI_LINE_19
N  *         @arg @ref LL_EXTI_LINE_20
N  *         @arg @ref LL_EXTI_LINE_21
N  *         @arg @ref LL_EXTI_LINE_22
N  *         @arg @ref LL_EXTI_LINE_29
N  *         @arg @ref LL_EXTI_LINE_30
N  *         @arg @ref LL_EXTI_LINE_31
N  * @note   Please check each device line mapping for EXTI Line availability
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
N{
N  WRITE_REG(EXTI->PR1, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->PR1) = (ExtiLine));
N}
N
N/**
N  * @brief  Clear ExtLine Flags for  Lines in range 32 to 63
N  * @note This bit is set when the selected edge event arrives on the interrupt
N  *       line. This bit is cleared by writing a 1 to the bit.
N  * @rmtoll PR2          PIFx           LL_EXTI_ClearFlag_32_63
N  * @param  ExtiLine This parameter can be a combination of the following values:
N  *         @arg @ref LL_EXTI_LINE_35
N  *         @arg @ref LL_EXTI_LINE_36
N  *         @arg @ref LL_EXTI_LINE_37
N  *         @arg @ref LL_EXTI_LINE_38
N  * @retval None
N  */
N__STATIC_INLINE void LL_EXTI_ClearFlag_32_63(uint32_t ExtiLine)
Xstatic __inline void LL_EXTI_ClearFlag_32_63(uint32_t ExtiLine)
N{
N  WRITE_REG(EXTI->PR2, ExtiLine);
X  ((((EXTI_TypeDef *) (((0x40000000UL) + 0x00010000UL) + 0x0400UL))->PR2) = (ExtiLine));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup EXTI_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
Nuint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct);
Nuint32_t LL_EXTI_DeInit(void);
Nvoid LL_EXTI_StructInit(LL_EXTI_InitTypeDef *EXTI_InitStruct);
N
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* EXTI */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_EXTI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 11 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_cortex.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_cortex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_cortex.h
N  * @author  MCD Application Team
N  * @brief   Header file of CORTEX LL module.
N  @verbatim
N  ==============================================================================
N                     ##### How to use this driver #####
N  ==============================================================================
N    [..]
N    The LL CORTEX driver contains a set of generic APIs that can be
N    used by user:
N      (+) SYSTICK configuration used by @ref LL_mDelay and @ref LL_Init1msTick
N          functions
N      (+) Low power mode configuration (SCB register of Cortex-MCU)
N      (+) MPU API to configure and enable regions
N      (+) API to access to MCU info (CPUID register)
N      (+) API to enable fault handler (SHCSR accesses)
N
N  @endverbatim
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_CORTEX_H
N#define __STM32L4xx_LL_CORTEX_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N/** @defgroup CORTEX_LL CORTEX
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CORTEX_LL_Exported_Constants CORTEX Exported Constants
N  * @{
N  */
N
N/** @defgroup CORTEX_LL_EC_CLKSOURCE_HCLK SYSTICK Clock Source
N  * @{
N  */
N#define LL_SYSTICK_CLKSOURCE_HCLK_DIV8     0x00000000U                 /*!< AHB clock divided by 8 selected as SysTick clock source.*/
N#define LL_SYSTICK_CLKSOURCE_HCLK          SysTick_CTRL_CLKSOURCE_Msk  /*!< AHB clock selected as SysTick clock source. */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_FAULT Handler Fault type
N  * @{
N  */
N#define LL_HANDLER_FAULT_USG               SCB_SHCSR_USGFAULTENA_Msk              /*!< Usage fault */
N#define LL_HANDLER_FAULT_BUS               SCB_SHCSR_BUSFAULTENA_Msk              /*!< Bus fault */
N#define LL_HANDLER_FAULT_MEM               SCB_SHCSR_MEMFAULTENA_Msk              /*!< Memory management fault */
N/**
N  * @}
N  */
N
N#if __MPU_PRESENT
X#if 1
N
N/** @defgroup CORTEX_LL_EC_CTRL_HFNMI_PRIVDEF MPU Control
N  * @{
N  */
N#define LL_MPU_CTRL_HFNMI_PRIVDEF_NONE     0x00000000U                                       /*!< Disable NMI and privileged SW access */
N#define LL_MPU_CTRL_HARDFAULT_NMI          MPU_CTRL_HFNMIENA_Msk                             /*!< Enables the operation of MPU during hard fault, NMI, and FAULTMASK handlers */
N#define LL_MPU_CTRL_PRIVILEGED_DEFAULT     MPU_CTRL_PRIVDEFENA_Msk                           /*!< Enable privileged software access to default memory map */
N#define LL_MPU_CTRL_HFNMI_PRIVDEF          (MPU_CTRL_HFNMIENA_Msk | MPU_CTRL_PRIVDEFENA_Msk) /*!< Enable NMI and privileged SW access */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_REGION MPU Region Number
N  * @{
N  */
N#define LL_MPU_REGION_NUMBER0              0x00U /*!< REGION Number 0 */
N#define LL_MPU_REGION_NUMBER1              0x01U /*!< REGION Number 1 */
N#define LL_MPU_REGION_NUMBER2              0x02U /*!< REGION Number 2 */
N#define LL_MPU_REGION_NUMBER3              0x03U /*!< REGION Number 3 */
N#define LL_MPU_REGION_NUMBER4              0x04U /*!< REGION Number 4 */
N#define LL_MPU_REGION_NUMBER5              0x05U /*!< REGION Number 5 */
N#define LL_MPU_REGION_NUMBER6              0x06U /*!< REGION Number 6 */
N#define LL_MPU_REGION_NUMBER7              0x07U /*!< REGION Number 7 */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_REGION_SIZE MPU Region Size
N  * @{
N  */
N#define LL_MPU_REGION_SIZE_32B             (0x04U << MPU_RASR_SIZE_Pos) /*!< 32B Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_64B             (0x05U << MPU_RASR_SIZE_Pos) /*!< 64B Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_128B            (0x06U << MPU_RASR_SIZE_Pos) /*!< 128B Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_256B            (0x07U << MPU_RASR_SIZE_Pos) /*!< 256B Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_512B            (0x08U << MPU_RASR_SIZE_Pos) /*!< 512B Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_1KB             (0x09U << MPU_RASR_SIZE_Pos) /*!< 1KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_2KB             (0x0AU << MPU_RASR_SIZE_Pos) /*!< 2KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_4KB             (0x0BU << MPU_RASR_SIZE_Pos) /*!< 4KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_8KB             (0x0CU << MPU_RASR_SIZE_Pos) /*!< 8KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_16KB            (0x0DU << MPU_RASR_SIZE_Pos) /*!< 16KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_32KB            (0x0EU << MPU_RASR_SIZE_Pos) /*!< 32KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_64KB            (0x0FU << MPU_RASR_SIZE_Pos) /*!< 64KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_128KB           (0x10U << MPU_RASR_SIZE_Pos) /*!< 128KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_256KB           (0x11U << MPU_RASR_SIZE_Pos) /*!< 256KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_512KB           (0x12U << MPU_RASR_SIZE_Pos) /*!< 512KB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_1MB             (0x13U << MPU_RASR_SIZE_Pos) /*!< 1MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_2MB             (0x14U << MPU_RASR_SIZE_Pos) /*!< 2MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_4MB             (0x15U << MPU_RASR_SIZE_Pos) /*!< 4MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_8MB             (0x16U << MPU_RASR_SIZE_Pos) /*!< 8MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_16MB            (0x17U << MPU_RASR_SIZE_Pos) /*!< 16MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_32MB            (0x18U << MPU_RASR_SIZE_Pos) /*!< 32MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_64MB            (0x19U << MPU_RASR_SIZE_Pos) /*!< 64MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_128MB           (0x1AU << MPU_RASR_SIZE_Pos) /*!< 128MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_256MB           (0x1BU << MPU_RASR_SIZE_Pos) /*!< 256MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_512MB           (0x1CU << MPU_RASR_SIZE_Pos) /*!< 512MB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_1GB             (0x1DU << MPU_RASR_SIZE_Pos) /*!< 1GB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_2GB             (0x1EU << MPU_RASR_SIZE_Pos) /*!< 2GB Size of the MPU protection region */
N#define LL_MPU_REGION_SIZE_4GB             (0x1FU << MPU_RASR_SIZE_Pos) /*!< 4GB Size of the MPU protection region */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_REGION_PRIVILEDGES MPU Region Privileges
N  * @{
N  */
N#define LL_MPU_REGION_NO_ACCESS            (0x00U << MPU_RASR_AP_Pos) /*!< No access*/
N#define LL_MPU_REGION_PRIV_RW              (0x01U << MPU_RASR_AP_Pos) /*!< RW privileged (privileged access only)*/
N#define LL_MPU_REGION_PRIV_RW_URO          (0x02U << MPU_RASR_AP_Pos) /*!< RW privileged - RO user (Write in a user program generates a fault) */
N#define LL_MPU_REGION_FULL_ACCESS          (0x03U << MPU_RASR_AP_Pos) /*!< RW privileged & user (Full access) */
N#define LL_MPU_REGION_PRIV_RO              (0x05U << MPU_RASR_AP_Pos) /*!< RO privileged (privileged read only)*/
N#define LL_MPU_REGION_PRIV_RO_URO          (0x06U << MPU_RASR_AP_Pos) /*!< RO privileged & user (read only) */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_TEX MPU TEX Level
N  * @{
N  */
N#define LL_MPU_TEX_LEVEL0                  (0x00U << MPU_RASR_TEX_Pos) /*!< b000 for TEX bits */
N#define LL_MPU_TEX_LEVEL1                  (0x01U << MPU_RASR_TEX_Pos) /*!< b001 for TEX bits */
N#define LL_MPU_TEX_LEVEL2                  (0x02U << MPU_RASR_TEX_Pos) /*!< b010 for TEX bits */
N#define LL_MPU_TEX_LEVEL4                  (0x04U << MPU_RASR_TEX_Pos) /*!< b100 for TEX bits */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_INSTRUCTION_ACCESS MPU Instruction Access
N  * @{
N  */
N#define LL_MPU_INSTRUCTION_ACCESS_ENABLE   0x00U            /*!< Instruction fetches enabled */
N#define LL_MPU_INSTRUCTION_ACCESS_DISABLE  MPU_RASR_XN_Msk  /*!< Instruction fetches disabled*/
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_SHAREABLE_ACCESS MPU Shareable Access
N  * @{
N  */
N#define LL_MPU_ACCESS_SHAREABLE            MPU_RASR_S_Msk   /*!< Shareable memory attribute */
N#define LL_MPU_ACCESS_NOT_SHAREABLE        0x00U            /*!< Not Shareable memory attribute */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_CACHEABLE_ACCESS MPU Cacheable Access
N  * @{
N  */
N#define LL_MPU_ACCESS_CACHEABLE            MPU_RASR_C_Msk   /*!< Cacheable memory attribute */
N#define LL_MPU_ACCESS_NOT_CACHEABLE        0x00U            /*!< Not Cacheable memory attribute */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EC_BUFFERABLE_ACCESS MPU Bufferable Access
N  * @{
N  */
N#define LL_MPU_ACCESS_BUFFERABLE           MPU_RASR_B_Msk   /*!< Bufferable memory attribute */
N#define LL_MPU_ACCESS_NOT_BUFFERABLE       0x00U            /*!< Not Bufferable memory attribute */
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup CORTEX_LL_Exported_Functions CORTEX Exported Functions
N  * @{
N  */
N
N/** @defgroup CORTEX_LL_EF_SYSTICK SYSTICK
N  * @{
N  */
N
N/**
N  * @brief  This function checks if the Systick counter flag is active or not.
N  * @note   It can be used in timeout function on application side.
N  * @rmtoll STK_CTRL     COUNTFLAG     LL_SYSTICK_IsActiveCounterFlag
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSTICK_IsActiveCounterFlag(void)
Xstatic __inline uint32_t LL_SYSTICK_IsActiveCounterFlag(void)
N{
N  return ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == (SysTick_CTRL_COUNTFLAG_Msk));
X  return ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16U)) == ((1UL << 16U)));
N}
N
N/**
N  * @brief  Configures the SysTick clock source
N  * @rmtoll STK_CTRL     CLKSOURCE     LL_SYSTICK_SetClkSource
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_SYSTICK_CLKSOURCE_HCLK_DIV8
N  *         @arg @ref LL_SYSTICK_CLKSOURCE_HCLK
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSTICK_SetClkSource(uint32_t Source)
Xstatic __inline void LL_SYSTICK_SetClkSource(uint32_t Source)
N{
N  if (Source == LL_SYSTICK_CLKSOURCE_HCLK)
X  if (Source == (1UL << 2U))
N  {
N    SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
X    ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) |= ((1UL << 2U)));
N  }
N  else
N  {
N    CLEAR_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
X    ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) &= ~((1UL << 2U)));
N  }
N}
N
N/**
N  * @brief  Get the SysTick clock source
N  * @rmtoll STK_CTRL     CLKSOURCE     LL_SYSTICK_GetClkSource
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SYSTICK_CLKSOURCE_HCLK_DIV8
N  *         @arg @ref LL_SYSTICK_CLKSOURCE_HCLK
N  */
N__STATIC_INLINE uint32_t LL_SYSTICK_GetClkSource(void)
Xstatic __inline uint32_t LL_SYSTICK_GetClkSource(void)
N{
N  return READ_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
X  return ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) & ((1UL << 2U)));
N}
N
N/**
N  * @brief  Enable SysTick exception request
N  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_EnableIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSTICK_EnableIT(void)
Xstatic __inline void LL_SYSTICK_EnableIT(void)
N{
N  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
X  ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) |= ((1UL << 1U)));
N}
N
N/**
N  * @brief  Disable SysTick exception request
N  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_DisableIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_SYSTICK_DisableIT(void)
Xstatic __inline void LL_SYSTICK_DisableIT(void)
N{
N  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
X  ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) &= ~((1UL << 1U)));
N}
N
N/**
N  * @brief  Checks if the SYSTICK interrupt is enabled or disabled.
N  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_IsEnabledIT
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SYSTICK_IsEnabledIT(void)
Xstatic __inline uint32_t LL_SYSTICK_IsEnabledIT(void)
N{
N  return (READ_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk) == (SysTick_CTRL_TICKINT_Msk));
X  return (((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL) & ((1UL << 1U))) == ((1UL << 1U)));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EF_LOW_POWER_MODE LOW POWER MODE
N  * @{
N  */
N
N/**
N  * @brief  Processor uses sleep as its low power mode
N  * @rmtoll SCB_SCR      SLEEPDEEP     LL_LPM_EnableSleep
N  * @retval None
N  */
N__STATIC_INLINE void LL_LPM_EnableSleep(void)
Xstatic __inline void LL_LPM_EnableSleep(void)
N{
N  /* Clear SLEEPDEEP bit of Cortex System Control Register */
N  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) &= ~(((uint32_t)(1UL << 2U))));
N}
N
N/**
N  * @brief  Processor uses deep sleep as its low power mode
N  * @rmtoll SCB_SCR      SLEEPDEEP     LL_LPM_EnableDeepSleep
N  * @retval None
N  */
N__STATIC_INLINE void LL_LPM_EnableDeepSleep(void)
Xstatic __inline void LL_LPM_EnableDeepSleep(void)
N{
N  /* Set SLEEPDEEP bit of Cortex System Control Register */
N  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) |= (((uint32_t)(1UL << 2U))));
N}
N
N/**
N  * @brief  Configures sleep-on-exit when returning from Handler mode to Thread mode.
N  * @note   Setting this bit to 1 enables an interrupt-driven application to avoid returning to an
N  *         empty main application.
N  * @rmtoll SCB_SCR      SLEEPONEXIT   LL_LPM_EnableSleepOnExit
N  * @retval None
N  */
N__STATIC_INLINE void LL_LPM_EnableSleepOnExit(void)
Xstatic __inline void LL_LPM_EnableSleepOnExit(void)
N{
N  /* Set SLEEPONEXIT bit of Cortex System Control Register */
N  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) |= (((uint32_t)(1UL << 1U))));
N}
N
N/**
N  * @brief  Do not sleep when returning to Thread mode.
N  * @rmtoll SCB_SCR      SLEEPONEXIT   LL_LPM_DisableSleepOnExit
N  * @retval None
N  */
N__STATIC_INLINE void LL_LPM_DisableSleepOnExit(void)
Xstatic __inline void LL_LPM_DisableSleepOnExit(void)
N{
N  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
N  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) &= ~(((uint32_t)(1UL << 1U))));
N}
N
N/**
N  * @brief  Enabled events and all interrupts, including disabled interrupts, can wakeup the
N  *         processor.
N  * @rmtoll SCB_SCR      SEVEONPEND    LL_LPM_EnableEventOnPend
N  * @retval None
N  */
N__STATIC_INLINE void LL_LPM_EnableEventOnPend(void)
Xstatic __inline void LL_LPM_EnableEventOnPend(void)
N{
N  /* Set SEVEONPEND bit of Cortex System Control Register */
N  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) |= (((uint32_t)(1UL << 4U))));
N}
N
N/**
N  * @brief  Only enabled interrupts or events can wakeup the processor, disabled interrupts are
N  *         excluded
N  * @rmtoll SCB_SCR      SEVEONPEND    LL_LPM_DisableEventOnPend
N  * @retval None
N  */
N__STATIC_INLINE void LL_LPM_DisableEventOnPend(void)
Xstatic __inline void LL_LPM_DisableEventOnPend(void)
N{
N  /* Clear SEVEONPEND bit of Cortex System Control Register */
N  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR) &= ~(((uint32_t)(1UL << 4U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EF_HANDLER HANDLER
N  * @{
N  */
N
N/**
N  * @brief  Enable a fault in System handler control register (SHCSR)
N  * @rmtoll SCB_SHCSR    MEMFAULTENA   LL_HANDLER_EnableFault
N  * @param  Fault This parameter can be a combination of the following values:
N  *         @arg @ref LL_HANDLER_FAULT_USG
N  *         @arg @ref LL_HANDLER_FAULT_BUS
N  *         @arg @ref LL_HANDLER_FAULT_MEM
N  * @retval None
N  */
N__STATIC_INLINE void LL_HANDLER_EnableFault(uint32_t Fault)
Xstatic __inline void LL_HANDLER_EnableFault(uint32_t Fault)
N{
N  /* Enable the system handler fault */
N  SET_BIT(SCB->SHCSR, Fault);
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR) |= (Fault));
N}
N
N/**
N  * @brief  Disable a fault in System handler control register (SHCSR)
N  * @rmtoll SCB_SHCSR    MEMFAULTENA   LL_HANDLER_DisableFault
N  * @param  Fault This parameter can be a combination of the following values:
N  *         @arg @ref LL_HANDLER_FAULT_USG
N  *         @arg @ref LL_HANDLER_FAULT_BUS
N  *         @arg @ref LL_HANDLER_FAULT_MEM
N  * @retval None
N  */
N__STATIC_INLINE void LL_HANDLER_DisableFault(uint32_t Fault)
Xstatic __inline void LL_HANDLER_DisableFault(uint32_t Fault)
N{
N  /* Disable the system handler fault */
N  CLEAR_BIT(SCB->SHCSR, Fault);
X  ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR) &= ~(Fault));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_LL_EF_MCU_INFO MCU INFO
N  * @{
N  */
N
N/**
N  * @brief  Get Implementer code
N  * @rmtoll SCB_CPUID    IMPLEMENTER   LL_CPUID_GetImplementer
N  * @retval Value should be equal to 0x41 for ARM
N  */
N__STATIC_INLINE uint32_t LL_CPUID_GetImplementer(void)
Xstatic __inline uint32_t LL_CPUID_GetImplementer(void)
N{
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_IMPLEMENTER_Msk) >> SCB_CPUID_IMPLEMENTER_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFFUL << 24U))) >> 24U);
N}
N
N/**
N  * @brief  Get Variant number (The r value in the rnpn product revision identifier)
N  * @rmtoll SCB_CPUID    VARIANT       LL_CPUID_GetVariant
N  * @retval Value between 0 and 255 (0x0: revision 0)
N  */
N__STATIC_INLINE uint32_t LL_CPUID_GetVariant(void)
Xstatic __inline uint32_t LL_CPUID_GetVariant(void)
N{
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_VARIANT_Msk) >> SCB_CPUID_VARIANT_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFUL << 20U))) >> 20U);
N}
N
N/**
N  * @brief  Get Constant number
N  * @rmtoll SCB_CPUID    ARCHITECTURE  LL_CPUID_GetConstant
N  * @retval Value should be equal to 0xF for Cortex-M4 devices
N  */
N__STATIC_INLINE uint32_t LL_CPUID_GetConstant(void)
Xstatic __inline uint32_t LL_CPUID_GetConstant(void)
N{
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_ARCHITECTURE_Msk) >> SCB_CPUID_ARCHITECTURE_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFUL << 16U))) >> 16U);
N}
N
N/**
N  * @brief  Get Part number
N  * @rmtoll SCB_CPUID    PARTNO        LL_CPUID_GetParNo
N  * @retval Value should be equal to 0xC24 for Cortex-M4
N  */
N__STATIC_INLINE uint32_t LL_CPUID_GetParNo(void)
Xstatic __inline uint32_t LL_CPUID_GetParNo(void)
N{
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_PARTNO_Msk) >> SCB_CPUID_PARTNO_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFFFUL << 4U))) >> 4U);
N}
N
N/**
N  * @brief  Get Revision number (The p value in the rnpn product revision identifier, indicates patch release)
N  * @rmtoll SCB_CPUID    REVISION      LL_CPUID_GetRevision
N  * @retval Value between 0 and 255 (0x1: patch 1)
N  */
N__STATIC_INLINE uint32_t LL_CPUID_GetRevision(void)
Xstatic __inline uint32_t LL_CPUID_GetRevision(void)
N{
N  return (uint32_t)(READ_BIT(SCB->CPUID, SCB_CPUID_REVISION_Msk) >> SCB_CPUID_REVISION_Pos);
X  return (uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID) & ((0xFUL ))) >> 0U);
N}
N
N/**
N  * @}
N  */
N
N#if __MPU_PRESENT
X#if 1
N/** @defgroup CORTEX_LL_EF_MPU MPU
N  * @{
N  */
N
N/**
N  * @brief  Enable MPU with input options
N  * @rmtoll MPU_CTRL     ENABLE        LL_MPU_Enable
N  * @param  Options This parameter can be one of the following values:
N  *         @arg @ref LL_MPU_CTRL_HFNMI_PRIVDEF_NONE
N  *         @arg @ref LL_MPU_CTRL_HARDFAULT_NMI
N  *         @arg @ref LL_MPU_CTRL_PRIVILEGED_DEFAULT
N  *         @arg @ref LL_MPU_CTRL_HFNMI_PRIVDEF
N  * @retval None
N  */
N__STATIC_INLINE void LL_MPU_Enable(uint32_t Options)
Xstatic __inline void LL_MPU_Enable(uint32_t Options)
N{
N  /* Enable the MPU*/
N  WRITE_REG(MPU->CTRL, (MPU_CTRL_ENABLE_Msk | Options));
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL) = (((1UL ) | Options)));
N  /* Ensure MPU settings take effects */
N  __DSB();
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N  /* Sequence instruction fetches using update settings */
N  __ISB();
X  do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N}
N
N/**
N  * @brief  Disable MPU
N  * @rmtoll MPU_CTRL     ENABLE        LL_MPU_Disable
N  * @retval None
N  */
N__STATIC_INLINE void LL_MPU_Disable(void)
Xstatic __inline void LL_MPU_Disable(void)
N{
N  /* Make sure outstanding transfers are done */
N  __DMB();
X  do { __schedule_barrier(); __dmb(0xF); __schedule_barrier(); } while (0U);
N  /* Disable MPU*/
N  WRITE_REG(MPU->CTRL, 0U);
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL) = (0U));
N}
N
N/**
N  * @brief  Check if MPU is enabled or not
N  * @rmtoll MPU_CTRL     ENABLE        LL_MPU_IsEnabled
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_MPU_IsEnabled(void)
Xstatic __inline uint32_t LL_MPU_IsEnabled(void)
N{
N  return (READ_BIT(MPU->CTRL, MPU_CTRL_ENABLE_Msk) == (MPU_CTRL_ENABLE_Msk));
X  return (((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL) & ((1UL ))) == ((1UL )));
N}
N
N/**
N  * @brief  Enable a MPU region
N  * @rmtoll MPU_RASR     ENABLE        LL_MPU_EnableRegion
N  * @param  Region This parameter can be one of the following values:
N  *         @arg @ref LL_MPU_REGION_NUMBER0
N  *         @arg @ref LL_MPU_REGION_NUMBER1
N  *         @arg @ref LL_MPU_REGION_NUMBER2
N  *         @arg @ref LL_MPU_REGION_NUMBER3
N  *         @arg @ref LL_MPU_REGION_NUMBER4
N  *         @arg @ref LL_MPU_REGION_NUMBER5
N  *         @arg @ref LL_MPU_REGION_NUMBER6
N  *         @arg @ref LL_MPU_REGION_NUMBER7
N  * @retval None
N  */
N__STATIC_INLINE void LL_MPU_EnableRegion(uint32_t Region)
Xstatic __inline void LL_MPU_EnableRegion(uint32_t Region)
N{
N  /* Set Region number */
N  WRITE_REG(MPU->RNR, Region);
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR) = (Region));
N  /* Enable the MPU region */
N  SET_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR) |= ((1UL )));
N}
N
N/**
N  * @brief  Configure and enable a region
N  * @rmtoll MPU_RNR      REGION        LL_MPU_ConfigRegion\n
N  *         MPU_RBAR     REGION        LL_MPU_ConfigRegion\n
N  *         MPU_RBAR     ADDR          LL_MPU_ConfigRegion\n
N  *         MPU_RASR     XN            LL_MPU_ConfigRegion\n
N  *         MPU_RASR     AP            LL_MPU_ConfigRegion\n
N  *         MPU_RASR     S             LL_MPU_ConfigRegion\n
N  *         MPU_RASR     C             LL_MPU_ConfigRegion\n
N  *         MPU_RASR     B             LL_MPU_ConfigRegion\n
N  *         MPU_RASR     SIZE          LL_MPU_ConfigRegion
N  * @param  Region This parameter can be one of the following values:
N  *         @arg @ref LL_MPU_REGION_NUMBER0
N  *         @arg @ref LL_MPU_REGION_NUMBER1
N  *         @arg @ref LL_MPU_REGION_NUMBER2
N  *         @arg @ref LL_MPU_REGION_NUMBER3
N  *         @arg @ref LL_MPU_REGION_NUMBER4
N  *         @arg @ref LL_MPU_REGION_NUMBER5
N  *         @arg @ref LL_MPU_REGION_NUMBER6
N  *         @arg @ref LL_MPU_REGION_NUMBER7
N  * @param  Address Value of region base address
N  * @param  SubRegionDisable Sub-region disable value between Min_Data = 0x00 and Max_Data = 0xFF
N  * @param  Attributes This parameter can be a combination of the following values:
N  *         @arg @ref LL_MPU_REGION_SIZE_32B or @ref LL_MPU_REGION_SIZE_64B or @ref LL_MPU_REGION_SIZE_128B or @ref LL_MPU_REGION_SIZE_256B or @ref LL_MPU_REGION_SIZE_512B
N  *           or @ref LL_MPU_REGION_SIZE_1KB or @ref LL_MPU_REGION_SIZE_2KB or @ref LL_MPU_REGION_SIZE_4KB or @ref LL_MPU_REGION_SIZE_8KB or @ref LL_MPU_REGION_SIZE_16KB
N  *           or @ref LL_MPU_REGION_SIZE_32KB or @ref LL_MPU_REGION_SIZE_64KB or @ref LL_MPU_REGION_SIZE_128KB or @ref LL_MPU_REGION_SIZE_256KB or @ref LL_MPU_REGION_SIZE_512KB
N  *           or @ref LL_MPU_REGION_SIZE_1MB or @ref LL_MPU_REGION_SIZE_2MB or @ref LL_MPU_REGION_SIZE_4MB or @ref LL_MPU_REGION_SIZE_8MB or @ref LL_MPU_REGION_SIZE_16MB
N  *           or @ref LL_MPU_REGION_SIZE_32MB or @ref LL_MPU_REGION_SIZE_64MB or @ref LL_MPU_REGION_SIZE_128MB or @ref LL_MPU_REGION_SIZE_256MB or @ref LL_MPU_REGION_SIZE_512MB
N  *           or @ref LL_MPU_REGION_SIZE_1GB or @ref LL_MPU_REGION_SIZE_2GB or @ref LL_MPU_REGION_SIZE_4GB
N  *         @arg @ref LL_MPU_REGION_NO_ACCESS or @ref LL_MPU_REGION_PRIV_RW or @ref LL_MPU_REGION_PRIV_RW_URO or @ref LL_MPU_REGION_FULL_ACCESS
N  *           or @ref LL_MPU_REGION_PRIV_RO or @ref LL_MPU_REGION_PRIV_RO_URO
N  *         @arg @ref LL_MPU_TEX_LEVEL0 or @ref LL_MPU_TEX_LEVEL1 or @ref LL_MPU_TEX_LEVEL2 or @ref LL_MPU_TEX_LEVEL4
N  *         @arg @ref LL_MPU_INSTRUCTION_ACCESS_ENABLE or  @ref LL_MPU_INSTRUCTION_ACCESS_DISABLE
N  *         @arg @ref LL_MPU_ACCESS_SHAREABLE or @ref LL_MPU_ACCESS_NOT_SHAREABLE
N  *         @arg @ref LL_MPU_ACCESS_CACHEABLE or @ref LL_MPU_ACCESS_NOT_CACHEABLE
N  *         @arg @ref LL_MPU_ACCESS_BUFFERABLE or @ref LL_MPU_ACCESS_NOT_BUFFERABLE
N  * @retval None
N  */
N__STATIC_INLINE void LL_MPU_ConfigRegion(uint32_t Region, uint32_t SubRegionDisable, uint32_t Address, uint32_t Attributes)
Xstatic __inline void LL_MPU_ConfigRegion(uint32_t Region, uint32_t SubRegionDisable, uint32_t Address, uint32_t Attributes)
N{
N  /* Set Region number */
N  WRITE_REG(MPU->RNR, Region);
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR) = (Region));
N  /* Set base address */
N  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR) = ((Address & 0xFFFFFFE0U)));
N  /* Configure MPU */
N  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | SubRegionDisable << MPU_RASR_SRD_Pos));
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR) = (((1UL ) | Attributes | SubRegionDisable << 8U)));
N}
N
N/**
N  * @brief  Disable a region
N  * @rmtoll MPU_RNR      REGION        LL_MPU_DisableRegion\n
N  *         MPU_RASR     ENABLE        LL_MPU_DisableRegion
N  * @param  Region This parameter can be one of the following values:
N  *         @arg @ref LL_MPU_REGION_NUMBER0
N  *         @arg @ref LL_MPU_REGION_NUMBER1
N  *         @arg @ref LL_MPU_REGION_NUMBER2
N  *         @arg @ref LL_MPU_REGION_NUMBER3
N  *         @arg @ref LL_MPU_REGION_NUMBER4
N  *         @arg @ref LL_MPU_REGION_NUMBER5
N  *         @arg @ref LL_MPU_REGION_NUMBER6
N  *         @arg @ref LL_MPU_REGION_NUMBER7
N  * @retval None
N  */
N__STATIC_INLINE void LL_MPU_DisableRegion(uint32_t Region)
Xstatic __inline void LL_MPU_DisableRegion(uint32_t Region)
N{
N  /* Set Region number */
N  WRITE_REG(MPU->RNR, Region);
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR) = (Region));
N  /* Disable the MPU region */
N  CLEAR_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
X  ((((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR) &= ~((1UL )));
N}
N
N/**
N  * @}
N  */
N
N#endif /* __MPU_PRESENT */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_CORTEX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 12 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_utils.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_utils.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_utils.h
N  * @author  MCD Application Team
N  * @brief   Header file of UTILS LL module.
N  @verbatim
N  ==============================================================================
N                     ##### How to use this driver #####
N  ==============================================================================
N    [..]
N    The LL UTILS driver contains a set of generic APIs that can be
N    used by user:
N      (+) Device electronic signature
N      (+) Timing functions
N      (+) PLL configuration functions
N
N  @endverbatim
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_UTILS_H
N#define __STM32L4xx_LL_UTILS_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N/** @defgroup UTILS_LL UTILS
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup UTILS_LL_Private_Constants UTILS Private Constants
N  * @{
N  */
N
N/* Max delay can be used in LL_mDelay */
N#define LL_MAX_DELAY                  0xFFFFFFFFU
N
N/**
N * @brief Unique device ID register base address
N */
N#define UID_BASE_ADDRESS              UID_BASE
N
N/**
N * @brief Flash size data register base address
N */
N#define FLASHSIZE_BASE_ADDRESS        FLASHSIZE_BASE
N
N/**
N * @brief Package data register base address
N */
N#define PACKAGE_BASE_ADDRESS          PACKAGE_BASE
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup UTILS_LL_Private_Macros UTILS Private Macros
N  * @{
N  */
N/**
N  * @}
N  */
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup UTILS_LL_ES_INIT UTILS Exported structures
N  * @{
N  */
N/**
N  * @brief  UTILS PLL structure definition
N  */
Ntypedef struct
N{
N  uint32_t PLLM;   /*!< Division factor for PLL VCO input clock.
N                        This parameter can be a value of @ref RCC_LL_EC_PLLM_DIV
N
N                        This feature can be modified afterwards using unitary function
N                        @ref LL_RCC_PLL_ConfigDomain_SYS(). */
N
N  uint32_t PLLN;   /*!< Multiplication factor for PLL VCO output clock.
N                        This parameter must be a number between Min_Data = 8 and Max_Data = 86
N
N                        This feature can be modified afterwards using unitary function
N                        @ref LL_RCC_PLL_ConfigDomain_SYS(). */
N
N  uint32_t PLLR;   /*!< Division for the main system clock.
N                        This parameter can be a value of @ref RCC_LL_EC_PLLR_DIV
N
N                        This feature can be modified afterwards using unitary function
N                        @ref LL_RCC_PLL_ConfigDomain_SYS(). */
N} LL_UTILS_PLLInitTypeDef;
N
N/**
N  * @brief  UTILS System, AHB and APB buses clock configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref RCC_LL_EC_SYSCLK_DIV
N
N                                       This feature can be modified afterwards using unitary function
N                                       @ref LL_RCC_SetAHBPrescaler(). */
N
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_LL_EC_APB1_DIV
N
N                                       This feature can be modified afterwards using unitary function
N                                       @ref LL_RCC_SetAPB1Prescaler(). */
N
N  uint32_t APB2CLKDivider;        /*!< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_LL_EC_APB2_DIV
N
N                                       This feature can be modified afterwards using unitary function
N                                       @ref LL_RCC_SetAPB2Prescaler(). */
N
N} LL_UTILS_ClkInitTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UTILS_LL_Exported_Constants UTILS Exported Constants
N  * @{
N  */
N
N/** @defgroup UTILS_EC_HSE_BYPASS HSE Bypass activation
N  * @{
N  */
N#define LL_UTILS_HSEBYPASS_OFF        0x00000000U       /*!< HSE Bypass is not enabled                */
N#define LL_UTILS_HSEBYPASS_ON         0x00000001U       /*!< HSE Bypass is enabled                    */
N/**
N  * @}
N  */
N
N/** @defgroup UTILS_EC_PACKAGETYPE PACKAGE TYPE
N  * @{
N  */
N#define LL_UTILS_PACKAGETYPE_LQFP64         0x00000000U /*!< LQFP64 package type                      */
N#define LL_UTILS_PACKAGETYPE_WLCSP64        0x00000001U /*!< WLCSP64 package type                     */
N#define LL_UTILS_PACKAGETYPE_LQFP100        0x00000002U /*!< LQFP100 package type                     */
N#define LL_UTILS_PACKAGETYPE_BGA132         0x00000003U /*!< BGA132 package type                      */
N#define LL_UTILS_PACKAGETYPE_LQFP144_CSP72  0x00000004U /*!< LQFP144, WLCSP81 or WLCSP72 package type */
N#define LL_UTILS_PACKAGETYPE_UFQFPN32       0x00000008U /*!< UFQFPN32 package type                    */
N#define LL_UTILS_PACKAGETYPE_UFQFPN48       0x0000000AU /*!< UFQFPN48 package type                    */
N#define LL_UTILS_PACKAGETYPE_LQFP48         0x0000000BU /*!< LQFP48 package type                      */
N#define LL_UTILS_PACKAGETYPE_WLCSP49        0x0000000CU /*!< WLCSP49 package type                     */
N#define LL_UTILS_PACKAGETYPE_UFBGA64        0x0000000DU /*!< UFBGA64 package type                     */
N#define LL_UTILS_PACKAGETYPE_UFBGA100       0x0000000EU /*!< UFBGA100 package type                    */
N#define LL_UTILS_PACKAGETYPE_UFBGA169       0x00000010U /*!< UFBGA169 package type                    */
N#define LL_UTILS_PACKAGETYPE_LQFP100_DSI    0x00000012U /*!< LQFP100 with DSI package type            */
N#define LL_UTILS_PACKAGETYPE_WLCSP144_DSI   0x00000013U /*!< WLCSP144 with DSI package type           */
N#define LL_UTILS_PACKAGETYPE_UFBGA144_DSI   0x00000013U /*!< UFBGA144 with DSI package type           */
N#define LL_UTILS_PACKAGETYPE_UFBGA169_DSI   0x00000014U /*!< UFBGA169 with DSI package type           */
N#define LL_UTILS_PACKAGETYPE_LQFP144_DSI    0x00000015U /*!< LQFP144 with DSI package type            */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup UTILS_LL_Exported_Functions UTILS Exported Functions
N  * @{
N  */
N
N/** @defgroup UTILS_EF_DEVICE_ELECTRONIC_SIGNATURE DEVICE ELECTRONIC SIGNATURE
N  * @{
N  */
N
N/**
N  * @brief  Get Word0 of the unique device identifier (UID based on 96 bits)
N  * @retval UID[31:0]: X and Y coordinates on the wafer expressed in BCD format
N  */
N__STATIC_INLINE uint32_t LL_GetUID_Word0(void)
Xstatic __inline uint32_t LL_GetUID_Word0(void)
N{
N  return (uint32_t)(READ_REG(*((uint32_t *)UID_BASE_ADDRESS)));
X  return (uint32_t)(((*((uint32_t *)(0x1FFF7590UL)))));
N}
N
N/**
N  * @brief  Get Word1 of the unique device identifier (UID based on 96 bits)
N  * @retval UID[63:32]: Wafer number (UID[39:32]) & LOT_NUM[23:0] (UID[63:40])
N  */
N__STATIC_INLINE uint32_t LL_GetUID_Word1(void)
Xstatic __inline uint32_t LL_GetUID_Word1(void)
N{
N  return (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE_ADDRESS + 4U))));
X  return (uint32_t)(((*((uint32_t *)((0x1FFF7590UL) + 4U)))));
N}
N
N/**
N  * @brief  Get Word2 of the unique device identifier (UID based on 96 bits)
N  * @retval UID[95:64]: Lot number (ASCII encoded) - LOT_NUM[55:24]
N  */
N__STATIC_INLINE uint32_t LL_GetUID_Word2(void)
Xstatic __inline uint32_t LL_GetUID_Word2(void)
N{
N  return (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE_ADDRESS + 8U))));
X  return (uint32_t)(((*((uint32_t *)((0x1FFF7590UL) + 8U)))));
N}
N
N/**
N  * @brief  Get Flash memory size
N  * @note   This bitfield indicates the size of the device Flash memory expressed in
N  *         Kbytes. As an example, 0x040 corresponds to 64 Kbytes.
N  * @retval FLASH_SIZE[15:0]: Flash memory size
N  */
N__STATIC_INLINE uint32_t LL_GetFlashSize(void)
Xstatic __inline uint32_t LL_GetFlashSize(void)
N{
N  return (uint32_t)(READ_REG(*((uint32_t *)FLASHSIZE_BASE_ADDRESS)) & 0xFFFFU);
X  return (uint32_t)(((*((uint32_t *)(0x1FFF75E0UL)))) & 0xFFFFU);
N}
N
N/**
N  * @brief  Get Package type
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_UTILS_PACKAGETYPE_LQFP64 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_LQFP100 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_BGA132 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_LQFP144_CSP72 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFQFPN32 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFQFPN48 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_LQFP48 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_WLCSP49 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFBGA64 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFBGA100 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFBGA169 (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_LQFP100_DSI (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_WLCSP144_DSI (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFBGA144_DSI (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_UFBGA169_DSI (*)
N  *         @arg @ref LL_UTILS_PACKAGETYPE_LQFP144_DSI (*)
N  *
N  *         (*) value not defined in all devices.
N  */
N__STATIC_INLINE uint32_t LL_GetPackageType(void)
Xstatic __inline uint32_t LL_GetPackageType(void)
N{
N  return (uint32_t)(READ_REG(*((uint32_t *)PACKAGE_BASE_ADDRESS)) & 0x1FU);
X  return (uint32_t)(((*((uint32_t *)(0x1FFF7500UL)))) & 0x1FU);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup UTILS_LL_EF_DELAY DELAY
N  * @{
N  */
N
N/**
N  * @brief  This function configures the Cortex-M SysTick source of the time base.
N  * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)
N  * @note   When a RTOS is used, it is recommended to avoid changing the SysTick
N  *         configuration by calling this function, for a delay use rather osDelay RTOS service.
N  * @param  Ticks Number of ticks
N  * @retval None
N  */
N__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
Xstatic __inline void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
N{
N  /* Configure the SysTick to have interrupt in 1ms time base */
N  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);   
N  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                        
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_ENABLE_Msk;                   /* Enable the Systick Timer */
X                   (1UL );                    
N}
N
Nvoid        LL_Init1msTick(uint32_t HCLKFrequency);
Nvoid        LL_mDelay(uint32_t Delay);
N
N/**
N  * @}
N  */
N
N/** @defgroup UTILS_EF_SYSTEM SYSTEM
N  * @{
N  */
N
Nvoid        LL_SetSystemCoreClock(uint32_t HCLKFrequency);
NErrorStatus LL_PLL_ConfigSystemClock_MSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
N                                         LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);
NErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
N                                         LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);
NErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
N                                         LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_UTILS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 13 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_pwr.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_pwr.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_PWR_H
N#define __STM32L4xx_LL_PWR_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined(PWR)
X#if 1L
N
N/** @defgroup PWR_LL PWR
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWR_LL_Exported_Constants PWR Exported Constants
N  * @{
N  */
N
N/** @defgroup PWR_LL_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with LL_PWR_WriteReg function
N  * @{
N  */
N#define LL_PWR_SCR_CSBF                    PWR_SCR_CSBF
N#define LL_PWR_SCR_CWUF                    PWR_SCR_CWUF
N#define LL_PWR_SCR_CWUF5                   PWR_SCR_CWUF5
N#define LL_PWR_SCR_CWUF4                   PWR_SCR_CWUF4
N#define LL_PWR_SCR_CWUF3                   PWR_SCR_CWUF3
N#define LL_PWR_SCR_CWUF2                   PWR_SCR_CWUF2
N#define LL_PWR_SCR_CWUF1                   PWR_SCR_CWUF1
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_PWR_ReadReg function
N  * @{
N  */
N#define LL_PWR_SR1_WUFI                    PWR_SR1_WUFI
N#define LL_PWR_SR1_SBF                     PWR_SR1_SBF
N#define LL_PWR_SR1_WUF5                    PWR_SR1_WUF5
N#define LL_PWR_SR1_WUF4                    PWR_SR1_WUF4
N#define LL_PWR_SR1_WUF3                    PWR_SR1_WUF3
N#define LL_PWR_SR1_WUF2                    PWR_SR1_WUF2
N#define LL_PWR_SR1_WUF1                    PWR_SR1_WUF1
N#if defined(PWR_SR2_PVMO4)
X#if 1L
N#define LL_PWR_SR2_PVMO4                   PWR_SR2_PVMO4
N#endif /* PWR_SR2_PVMO4 */
N#if defined(PWR_SR2_PVMO3)
X#if 1L
N#define LL_PWR_SR2_PVMO3                   PWR_SR2_PVMO3
N#endif /* PWR_SR2_PVMO3 */
N#if defined(PWR_SR2_PVMO2)
X#if 0L
S#define LL_PWR_SR2_PVMO2                   PWR_SR2_PVMO2
N#endif /* PWR_SR2_PVMO2 */
N#if defined(PWR_SR2_PVMO1)
X#if 0L
S#define LL_PWR_SR2_PVMO1                   PWR_SR2_PVMO1
N#endif /* PWR_SR2_PVMO1 */
N#define LL_PWR_SR2_PVDO                    PWR_SR2_PVDO
N#define LL_PWR_SR2_VOSF                    PWR_SR2_VOSF
N#define LL_PWR_SR2_REGLPF                  PWR_SR2_REGLPF
N#define LL_PWR_SR2_REGLPS                  PWR_SR2_REGLPS
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_REGU_VOLTAGE REGU VOLTAGE
N  * @{
N  */
N#define LL_PWR_REGU_VOLTAGE_SCALE1         (PWR_CR1_VOS_0)
N#define LL_PWR_REGU_VOLTAGE_SCALE2         (PWR_CR1_VOS_1)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_MODE_PWR MODE PWR
N  * @{
N  */
N#define LL_PWR_MODE_STOP0                  (PWR_CR1_LPMS_STOP0)
N#define LL_PWR_MODE_STOP1                  (PWR_CR1_LPMS_STOP1)
N#define LL_PWR_MODE_STOP2                  (PWR_CR1_LPMS_STOP2)
N#define LL_PWR_MODE_STANDBY                (PWR_CR1_LPMS_STANDBY)
N#define LL_PWR_MODE_SHUTDOWN               (PWR_CR1_LPMS_SHUTDOWN)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_PVM_VDDUSB_1 Peripheral voltage monitoring
N  * @{
N  */
N#if defined(PWR_CR2_PVME1)
X#if 0L
S#define LL_PWR_PVM_VDDUSB_1_2V             (PWR_CR2_PVME1)     /* Monitoring VDDUSB vs. 1.2V */
N#endif
N#if defined(PWR_CR2_PVME2)
X#if 0L
S#define LL_PWR_PVM_VDDIO2_0_9V             (PWR_CR2_PVME2)     /* Monitoring VDDIO2 vs. 0.9V */
N#endif
N#if defined(PWR_CR2_PVME3)
X#if 1L
N#define LL_PWR_PVM_VDDA_1_62V              (PWR_CR2_PVME3)     /* Monitoring VDDA vs. 1.62V  */
N#endif
N#if defined(PWR_CR2_PVME4)
X#if 1L
N#define LL_PWR_PVM_VDDA_2_2V               (PWR_CR2_PVME4)     /* Monitoring VDDA vs. 2.2V   */
N#endif
N/**
N  * @}
N  */
N  
N/** @defgroup PWR_LL_EC_PVDLEVEL PVDLEVEL
N  * @{
N  */
N#define LL_PWR_PVDLEVEL_0                  (PWR_CR2_PLS_LEV0)  /* VPVD0 around 2.0 V */
N#define LL_PWR_PVDLEVEL_1                  (PWR_CR2_PLS_LEV1)  /* VPVD1 around 2.2 V */
N#define LL_PWR_PVDLEVEL_2                  (PWR_CR2_PLS_LEV2)  /* VPVD2 around 2.4 V */
N#define LL_PWR_PVDLEVEL_3                  (PWR_CR2_PLS_LEV3)  /* VPVD3 around 2.5 V */
N#define LL_PWR_PVDLEVEL_4                  (PWR_CR2_PLS_LEV4)  /* VPVD4 around 2.6 V */
N#define LL_PWR_PVDLEVEL_5                  (PWR_CR2_PLS_LEV5)  /* VPVD5 around 2.8 V */
N#define LL_PWR_PVDLEVEL_6                  (PWR_CR2_PLS_LEV6)  /* VPVD6 around 2.9 V */
N#define LL_PWR_PVDLEVEL_7                  (PWR_CR2_PLS_LEV7)  /* External input analog voltage   (Compare internally to VREFINT) */
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_WAKEUP WAKEUP
N  * @{
N  */
N#define LL_PWR_WAKEUP_PIN1                 (PWR_CR3_EWUP1)
N#define LL_PWR_WAKEUP_PIN2                 (PWR_CR3_EWUP2)
N#define LL_PWR_WAKEUP_PIN3                 (PWR_CR3_EWUP3)
N#define LL_PWR_WAKEUP_PIN4                 (PWR_CR3_EWUP4)
N#define LL_PWR_WAKEUP_PIN5                 (PWR_CR3_EWUP5)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_BATT_CHARG_RESISTOR BATT CHARG RESISTOR
N  * @{
N  */
N#define LL_PWR_BATT_CHARG_RESISTOR_5K      (0x00000000U)
N#define LL_PWR_BATT_CHARGRESISTOR_1_5K     (PWR_CR4_VBRS)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_GPIO GPIO
N  * @{
N  */
N#define LL_PWR_GPIO_A                      ((uint32_t)(&(PWR->PUCRA)))
N#define LL_PWR_GPIO_B                      ((uint32_t)(&(PWR->PUCRB)))
N#define LL_PWR_GPIO_C                      ((uint32_t)(&(PWR->PUCRC)))
N#define LL_PWR_GPIO_D                      ((uint32_t)(&(PWR->PUCRD)))
N#define LL_PWR_GPIO_E                      ((uint32_t)(&(PWR->PUCRE)))
N#if defined(GPIOF)
X#if 0L
S#define LL_PWR_GPIO_F                      ((uint32_t)(&(PWR->PUCRF)))
N#endif
N#if defined(GPIOG)
X#if 0L
S#define LL_PWR_GPIO_G                      ((uint32_t)(&(PWR->PUCRG)))
N#endif
N#if defined(GPIOH)
X#if 1L
N#define LL_PWR_GPIO_H                      ((uint32_t)(&(PWR->PUCRH)))
N#endif
N#if defined(GPIOI)
X#if 0L
S#define LL_PWR_GPIO_I                      ((uint32_t)(&(PWR->PUCRI)))
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EC_GPIO_BIT GPIO BIT
N  * @{
N  */
N#define LL_PWR_GPIO_BIT_0                  (0x00000001U)
N#define LL_PWR_GPIO_BIT_1                  (0x00000002U)
N#define LL_PWR_GPIO_BIT_2                  (0x00000004U)
N#define LL_PWR_GPIO_BIT_3                  (0x00000008U)
N#define LL_PWR_GPIO_BIT_4                  (0x00000010U)
N#define LL_PWR_GPIO_BIT_5                  (0x00000020U)
N#define LL_PWR_GPIO_BIT_6                  (0x00000040U)
N#define LL_PWR_GPIO_BIT_7                  (0x00000080U)
N#define LL_PWR_GPIO_BIT_8                  (0x00000100U)
N#define LL_PWR_GPIO_BIT_9                  (0x00000200U)
N#define LL_PWR_GPIO_BIT_10                 (0x00000400U)
N#define LL_PWR_GPIO_BIT_11                 (0x00000800U)
N#define LL_PWR_GPIO_BIT_12                 (0x00001000U)
N#define LL_PWR_GPIO_BIT_13                 (0x00002000U)
N#define LL_PWR_GPIO_BIT_14                 (0x00004000U)
N#define LL_PWR_GPIO_BIT_15                 (0x00008000U)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWR_LL_Exported_Macros PWR Exported Macros
N  * @{
N  */
N
N/** @defgroup PWR_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in PWR register
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_PWR_WriteReg(__REG__, __VALUE__) WRITE_REG(PWR->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in PWR register
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_PWR_ReadReg(__REG__) READ_REG(PWR->__REG__)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup PWR_LL_Exported_Functions PWR Exported Functions
N  * @{
N  */
N
N/** @defgroup PWR_LL_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Switch the regulator from main mode to low-power mode
N  * @rmtoll CR1          LPR           LL_PWR_EnableLowPowerRunMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableLowPowerRunMode(void)
Xstatic __inline void LL_PWR_EnableLowPowerRunMode(void)
N{
N  SET_BIT(PWR->CR1, PWR_CR1_LPR);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Switch the regulator from low-power mode to main mode
N  * @rmtoll CR1          LPR           LL_PWR_DisableLowPowerRunMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableLowPowerRunMode(void)
Xstatic __inline void LL_PWR_DisableLowPowerRunMode(void)
N{
N  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Switch from run main mode to run low-power mode.
N  * @rmtoll CR1          LPR           LL_PWR_EnterLowPowerRunMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnterLowPowerRunMode(void)
Xstatic __inline void LL_PWR_EnterLowPowerRunMode(void)
N{
N  LL_PWR_EnableLowPowerRunMode();
N}
N
N/**
N  * @brief  Switch from run main mode to low-power mode.
N  * @rmtoll CR1          LPR           LL_PWR_ExitLowPowerRunMode
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ExitLowPowerRunMode(void)
Xstatic __inline void LL_PWR_ExitLowPowerRunMode(void)
N{
N  LL_PWR_DisableLowPowerRunMode();
N}
N
N/**
N  * @brief  Check if the regulator is in low-power mode
N  * @rmtoll CR1          LPR           LL_PWR_IsEnabledLowPowerRunMode
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledLowPowerRunMode(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledLowPowerRunMode(void)
N{
N  return (READ_BIT(PWR->CR1, PWR_CR1_LPR) == (PWR_CR1_LPR));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Set the main internal regulator output voltage
N  * @note   This configuration may be completed with LL_PWR_EnableRange1BoostMode() on STM32L4Rx/STM32L4Sx devices.
N  * @rmtoll CR1          VOS           LL_PWR_SetRegulVoltageScaling
N  * @param  VoltageScaling This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE1
N  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE2
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_SetRegulVoltageScaling(uint32_t VoltageScaling)
Xstatic __inline void LL_PWR_SetRegulVoltageScaling(uint32_t VoltageScaling)
N{
N  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
X  (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1)) = ((((((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1))) & (~((0x3UL << (9U))))) | (VoltageScaling))));
N}
N
N/**
N  * @brief  Get the main internal regulator output voltage
N  * @rmtoll CR1          VOS           LL_PWR_GetRegulVoltageScaling
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE1
N  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE2
N  */
N__STATIC_INLINE uint32_t LL_PWR_GetRegulVoltageScaling(void)
Xstatic __inline uint32_t LL_PWR_GetRegulVoltageScaling(void)
N{
N  return (uint32_t)(READ_BIT(PWR->CR1, PWR_CR1_VOS));
X  return (uint32_t)(((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) & ((0x3UL << (9U)))));
N}
N
N#if defined(PWR_CR5_R1MODE)
X#if 0L
S/**
S  * @brief  Enable main regulator voltage range 1 boost mode 
S  * @rmtoll CR5          R1MODE        LL_PWR_EnableRange1BoostMode
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_EnableRange1BoostMode(void)
S{
S  CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
S}
S
S/**
S  * @brief  Disable main regulator voltage range 1 boost mode 
S  * @rmtoll CR5          R1MODE        LL_PWR_DisableRange1BoostMode
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_DisableRange1BoostMode(void)
S{
S  SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
S}
S
S/**
S  * @brief  Check if the main regulator voltage range 1 boost mode is enabled
S  * @rmtoll CR5          R1MODE        LL_PWR_IsEnabledRange1BoostMode
S  * @retval Inverted state of bit (0 or 1).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsEnabledRange1BoostMode(void)
S{
S  return (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == RESET);
S}
N#endif /* PWR_CR5_R1MODE */
N
N/**
N  * @brief  Enable access to the backup domain
N  * @rmtoll CR1          DBP           LL_PWR_EnableBkUpAccess
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableBkUpAccess(void)
Xstatic __inline void LL_PWR_EnableBkUpAccess(void)
N{
N  SET_BIT(PWR->CR1, PWR_CR1_DBP);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable access to the backup domain
N  * @rmtoll CR1          DBP           LL_PWR_DisableBkUpAccess
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableBkUpAccess(void)
Xstatic __inline void LL_PWR_DisableBkUpAccess(void)
N{
N  CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if the backup domain is enabled
N  * @rmtoll CR1          DBP           LL_PWR_IsEnabledBkUpAccess
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledBkUpAccess(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledBkUpAccess(void)
N{
N  return (READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Set Low-Power mode
N  * @rmtoll CR1          LPMS          LL_PWR_SetPowerMode
N  * @param  LowPowerMode This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_MODE_STOP0
N  *         @arg @ref LL_PWR_MODE_STOP1
N  *         @arg @ref LL_PWR_MODE_STOP2
N  *         @arg @ref LL_PWR_MODE_STANDBY
N  *         @arg @ref LL_PWR_MODE_SHUTDOWN
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_SetPowerMode(uint32_t LowPowerMode)
Xstatic __inline void LL_PWR_SetPowerMode(uint32_t LowPowerMode)
N{
N  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, LowPowerMode);
X  (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1)) = ((((((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1))) & (~((0x7UL << (0U))))) | (LowPowerMode))));
N}
N
N/**
N  * @brief  Get Low-Power mode
N  * @rmtoll CR1          LPMS          LL_PWR_GetPowerMode
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_PWR_MODE_STOP0
N  *         @arg @ref LL_PWR_MODE_STOP1
N  *         @arg @ref LL_PWR_MODE_STOP2
N  *         @arg @ref LL_PWR_MODE_STANDBY
N  *         @arg @ref LL_PWR_MODE_SHUTDOWN
N  */
N__STATIC_INLINE uint32_t LL_PWR_GetPowerMode(void)
Xstatic __inline uint32_t LL_PWR_GetPowerMode(void)
N{
N  return (uint32_t)(READ_BIT(PWR->CR1, PWR_CR1_LPMS));
X  return (uint32_t)(((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR1) & ((0x7UL << (0U)))));
N}
N
N#if defined(PWR_CR1_RRSTP)
X#if 0L
S/**
S  * @brief  Enable SRAM3 content retention in Stop mode
S  * @rmtoll CR1          RRSTP           LL_PWR_EnableSRAM3Retention
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_EnableSRAM3Retention(void)
S{
S  SET_BIT(PWR->CR1, PWR_CR1_RRSTP);
S}
S
S/**
S  * @brief  Disable SRAM3 content retention in Stop mode
S  * @rmtoll CR1          RRSTP           LL_PWR_DisableSRAM3Retention
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_DisableSRAM3Retention(void)
S{
S  CLEAR_BIT(PWR->CR1, PWR_CR1_RRSTP);
S}
S
S/**
S  * @brief  Check if SRAM3 content retention in Stop mode is enabled
S  * @rmtoll CR1          RRSTP           LL_PWR_IsEnabledSRAM3Retention
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsEnabledSRAM3Retention(void)
S{
S  return (READ_BIT(PWR->CR1, PWR_CR1_RRSTP) == (PWR_CR1_RRSTP));
S}
N#endif /* PWR_CR1_RRSTP */
N
N#if defined(PWR_CR3_DSIPDEN)
X#if 0L
S/**
S  * @brief  Enable pull-down activation on DSI pins
S  * @rmtoll CR3          DSIPDEN           LL_PWR_EnableDSIPinsPDActivation
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_EnableDSIPinsPDActivation(void)
S{
S  SET_BIT(PWR->CR3, PWR_CR3_DSIPDEN);
S}
S
S/**
S  * @brief  Disable pull-down activation on DSI pins
S  * @rmtoll CR3          DSIPDEN           LL_PWR_DisableDSIPinsPDActivation
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_DisableDSIPinsPDActivation(void)
S{
S  CLEAR_BIT(PWR->CR3, PWR_CR3_DSIPDEN);
S}
S
S/**
S  * @brief  Check if pull-down activation on DSI pins is enabled
S  * @rmtoll CR3          DSIPDEN           LL_PWR_IsEnabledDSIPinsPDActivation
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsEnabledDSIPinsPDActivation(void)
S{
S  return (READ_BIT(PWR->CR3, PWR_CR3_DSIPDEN) == (PWR_CR3_DSIPDEN));
S}
N#endif /* PWR_CR3_DSIPDEN */
N
N#if defined(PWR_CR2_PVME1)
X#if 0L
S/**
S  * @brief  Enable VDDUSB supply
S  * @rmtoll CR2          USV           LL_PWR_EnableVddUSB
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_EnableVddUSB(void)
S{
S  SET_BIT(PWR->CR2, PWR_CR2_USV);
S}
S
S/**
S  * @brief  Disable VDDUSB supply
S  * @rmtoll CR2          USV           LL_PWR_DisableVddUSB
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_DisableVddUSB(void)
S{
S  CLEAR_BIT(PWR->CR2, PWR_CR2_USV);
S}
S
S/**
S  * @brief  Check if VDDUSB supply is enabled
S  * @rmtoll CR2          USV           LL_PWR_IsEnabledVddUSB
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsEnabledVddUSB(void)
S{
S  return (READ_BIT(PWR->CR2, PWR_CR2_USV) == (PWR_CR2_USV));
S}
N#endif
N
N#if defined(PWR_CR2_IOSV)
X#if 0L
S/**
S  * @brief  Enable VDDIO2 supply
S  * @rmtoll CR2          IOSV          LL_PWR_EnableVddIO2
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_EnableVddIO2(void)
S{
S  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
S}
S
S/**
S  * @brief  Disable VDDIO2 supply
S  * @rmtoll CR2          IOSV          LL_PWR_DisableVddIO2
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_DisableVddIO2(void)
S{
S  CLEAR_BIT(PWR->CR2, PWR_CR2_IOSV);
S}
S
S/**
S  * @brief  Check if VDDIO2 supply is enabled
S  * @rmtoll CR2          IOSV          LL_PWR_IsEnabledVddIO2
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsEnabledVddIO2(void)
S{
S  return (READ_BIT(PWR->CR2, PWR_CR2_IOSV) == (PWR_CR2_IOSV));
S}
N#endif
N
N/**
N  * @brief  Enable the Power Voltage Monitoring on a peripheral
N  * @rmtoll CR2          PVME1         LL_PWR_EnablePVM\n
N  *         CR2          PVME2         LL_PWR_EnablePVM\n
N  *         CR2          PVME3         LL_PWR_EnablePVM\n
N  *         CR2          PVME4         LL_PWR_EnablePVM
N  * @param  PeriphVoltage This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_PVM_VDDUSB_1_2V (*)
N  *         @arg @ref LL_PWR_PVM_VDDIO2_0_9V (*)
N  *         @arg @ref LL_PWR_PVM_VDDA_1_62V
N  *         @arg @ref LL_PWR_PVM_VDDA_2_2V
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnablePVM(uint32_t PeriphVoltage)
Xstatic __inline void LL_PWR_EnablePVM(uint32_t PeriphVoltage)
N{
N  SET_BIT(PWR->CR2, PeriphVoltage);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) |= (PeriphVoltage));
N}
N
N/**
N  * @brief  Disable the Power Voltage Monitoring on a peripheral
N  * @rmtoll CR2          PVME1         LL_PWR_DisablePVM\n
N  *         CR2          PVME2         LL_PWR_DisablePVM\n
N  *         CR2          PVME3         LL_PWR_DisablePVM\n
N  *         CR2          PVME4         LL_PWR_DisablePVM
N  * @param  PeriphVoltage This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_PVM_VDDUSB_1_2V (*)
N  *         @arg @ref LL_PWR_PVM_VDDIO2_0_9V (*)
N  *         @arg @ref LL_PWR_PVM_VDDA_1_62V
N  *         @arg @ref LL_PWR_PVM_VDDA_2_2V
N  *
N  *         (*) value not defined in all devices
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisablePVM(uint32_t PeriphVoltage)
Xstatic __inline void LL_PWR_DisablePVM(uint32_t PeriphVoltage)
N{
N  CLEAR_BIT(PWR->CR2, PeriphVoltage);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) &= ~(PeriphVoltage));
N}
N
N/**
N  * @brief  Check if Power Voltage Monitoring is enabled on a peripheral
N  * @rmtoll CR2          PVME1         LL_PWR_IsEnabledPVM\n
N  *         CR2          PVME2         LL_PWR_IsEnabledPVM\n
N  *         CR2          PVME3         LL_PWR_IsEnabledPVM\n
N  *         CR2          PVME4         LL_PWR_IsEnabledPVM
N  * @param  PeriphVoltage This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_PVM_VDDUSB_1_2V (*)
N  *         @arg @ref LL_PWR_PVM_VDDIO2_0_9V (*)
N  *         @arg @ref LL_PWR_PVM_VDDA_1_62V
N  *         @arg @ref LL_PWR_PVM_VDDA_2_2V
N  *
N  *         (*) value not defined in all devices
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledPVM(uint32_t PeriphVoltage)
Xstatic __inline uint32_t LL_PWR_IsEnabledPVM(uint32_t PeriphVoltage)
N{
N  return (READ_BIT(PWR->CR2, PeriphVoltage) == (PeriphVoltage));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) & (PeriphVoltage)) == (PeriphVoltage));
N}
N
N/**
N  * @brief  Configure the voltage threshold detected by the Power Voltage Detector
N  * @rmtoll CR2          PLS           LL_PWR_SetPVDLevel
N  * @param  PVDLevel This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_PVDLEVEL_0
N  *         @arg @ref LL_PWR_PVDLEVEL_1
N  *         @arg @ref LL_PWR_PVDLEVEL_2
N  *         @arg @ref LL_PWR_PVDLEVEL_3
N  *         @arg @ref LL_PWR_PVDLEVEL_4
N  *         @arg @ref LL_PWR_PVDLEVEL_5
N  *         @arg @ref LL_PWR_PVDLEVEL_6
N  *         @arg @ref LL_PWR_PVDLEVEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_SetPVDLevel(uint32_t PVDLevel)
Xstatic __inline void LL_PWR_SetPVDLevel(uint32_t PVDLevel)
N{
N  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, PVDLevel);
X  (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2)) = ((((((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2))) & (~((0x7UL << (1U))))) | (PVDLevel))));
N}
N
N/**
N  * @brief  Get the voltage threshold detection
N  * @rmtoll CR2          PLS           LL_PWR_GetPVDLevel
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_PWR_PVDLEVEL_0
N  *         @arg @ref LL_PWR_PVDLEVEL_1
N  *         @arg @ref LL_PWR_PVDLEVEL_2
N  *         @arg @ref LL_PWR_PVDLEVEL_3
N  *         @arg @ref LL_PWR_PVDLEVEL_4
N  *         @arg @ref LL_PWR_PVDLEVEL_5
N  *         @arg @ref LL_PWR_PVDLEVEL_6
N  *         @arg @ref LL_PWR_PVDLEVEL_7
N  */
N__STATIC_INLINE uint32_t LL_PWR_GetPVDLevel(void)
Xstatic __inline uint32_t LL_PWR_GetPVDLevel(void)
N{
N  return (uint32_t)(READ_BIT(PWR->CR2, PWR_CR2_PLS));
X  return (uint32_t)(((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) & ((0x7UL << (1U)))));
N}
N
N/**
N  * @brief  Enable Power Voltage Detector
N  * @rmtoll CR2          PVDE          LL_PWR_EnablePVD
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnablePVD(void)
Xstatic __inline void LL_PWR_EnablePVD(void)
N{
N  SET_BIT(PWR->CR2, PWR_CR2_PVDE);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable Power Voltage Detector
N  * @rmtoll CR2          PVDE          LL_PWR_DisablePVD
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisablePVD(void)
Xstatic __inline void LL_PWR_DisablePVD(void)
N{
N  CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if Power Voltage Detector is enabled
N  * @rmtoll CR2          PVDE          LL_PWR_IsEnabledPVD
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledPVD(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledPVD(void)
N{
N  return (READ_BIT(PWR->CR2, PWR_CR2_PVDE) == (PWR_CR2_PVDE));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR2) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable Internal Wake-up line
N  * @rmtoll CR3          EIWF          LL_PWR_EnableInternWU
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableInternWU(void)
Xstatic __inline void LL_PWR_EnableInternWU(void)
N{
N  SET_BIT(PWR->CR3, PWR_CR3_EIWF);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable Internal Wake-up line
N  * @rmtoll CR3          EIWF          LL_PWR_DisableInternWU
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableInternWU(void)
Xstatic __inline void LL_PWR_DisableInternWU(void)
N{
N  CLEAR_BIT(PWR->CR3, PWR_CR3_EIWF);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if Internal Wake-up line is enabled
N  * @rmtoll CR3          EIWF          LL_PWR_IsEnabledInternWU
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledInternWU(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledInternWU(void)
N{
N  return (READ_BIT(PWR->CR3, PWR_CR3_EIWF) == (PWR_CR3_EIWF));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Enable pull-up and pull-down configuration
N  * @rmtoll CR3          APC           LL_PWR_EnablePUPDCfg
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnablePUPDCfg(void)
Xstatic __inline void LL_PWR_EnablePUPDCfg(void)
N{
N  SET_BIT(PWR->CR3, PWR_CR3_APC);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable pull-up and pull-down configuration
N  * @rmtoll CR3          APC           LL_PWR_DisablePUPDCfg
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisablePUPDCfg(void)
Xstatic __inline void LL_PWR_DisablePUPDCfg(void)
N{
N  CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Check if pull-up and pull-down configuration is enabled
N  * @rmtoll CR3          APC           LL_PWR_IsEnabledPUPDCfg
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledPUPDCfg(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledPUPDCfg(void)
N{
N  return (READ_BIT(PWR->CR3, PWR_CR3_APC) == (PWR_CR3_APC));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N#if defined(PWR_CR3_DSIPDEN)
X#if 0L
S/**
S  * @brief  Enable pull-down activation on DSI pins
S  * @rmtoll CR3          DSIPDEN       LL_PWR_EnableDSIPullDown
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_EnableDSIPullDown(void)
S{
S  SET_BIT(PWR->CR3, PWR_CR3_DSIPDEN);
S}
S
S/**
S  * @brief  Disable pull-down activation on DSI pins
S  * @rmtoll CR3          DSIPDEN       LL_PWR_DisableDSIPullDown
S  * @retval None
S  */
S__STATIC_INLINE void LL_PWR_DisableDSIPullDown(void)
S{
S  CLEAR_BIT(PWR->CR3, PWR_CR3_DSIPDEN);
S}
S
S/**
S  * @brief  Check if pull-down activation on DSI pins is enabled
S  * @rmtoll CR3          DSIPDEN       LL_PWR_IsEnabledDSIPullDown
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsEnabledDSIPullDown(void)
S{
S  return (READ_BIT(PWR->CR3, PWR_CR3_DSIPDEN) == (PWR_CR3_DSIPDEN));
S}
N#endif /* PWR_CR3_DSIPDEN */
N
N/**
N  * @brief  Enable SRAM2 content retention in Standby mode
N  * @rmtoll CR3          RRS           LL_PWR_EnableSRAM2Retention
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableSRAM2Retention(void)
Xstatic __inline void LL_PWR_EnableSRAM2Retention(void)
N{
N  SET_BIT(PWR->CR3, PWR_CR3_RRS);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable SRAM2 content retention in Standby mode
N  * @rmtoll CR3          RRS           LL_PWR_DisableSRAM2Retention
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableSRAM2Retention(void)
Xstatic __inline void LL_PWR_DisableSRAM2Retention(void)
N{
N  CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if SRAM2 content retention in Standby mode is enabled
N  * @rmtoll CR3          RRS           LL_PWR_IsEnabledSRAM2Retention
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledSRAM2Retention(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledSRAM2Retention(void)
N{
N  return (READ_BIT(PWR->CR3, PWR_CR3_RRS) == (PWR_CR3_RRS));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable the WakeUp PINx functionality
N  * @rmtoll CR3          EWUP1         LL_PWR_EnableWakeUpPin\n
N  *         CR3          EWUP2         LL_PWR_EnableWakeUpPin\n
N  *         CR3          EWUP3         LL_PWR_EnableWakeUpPin\n
N  *         CR3          EWUP4         LL_PWR_EnableWakeUpPin\n
N  *         CR3          EWUP5         LL_PWR_EnableWakeUpPin\n
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_WAKEUP_PIN1
N  *         @arg @ref LL_PWR_WAKEUP_PIN2
N  *         @arg @ref LL_PWR_WAKEUP_PIN3
N  *         @arg @ref LL_PWR_WAKEUP_PIN4
N  *         @arg @ref LL_PWR_WAKEUP_PIN5
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableWakeUpPin(uint32_t WakeUpPin)
Xstatic __inline void LL_PWR_EnableWakeUpPin(uint32_t WakeUpPin)
N{
N  SET_BIT(PWR->CR3, WakeUpPin);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) |= (WakeUpPin));
N}
N
N/**
N  * @brief  Disable the WakeUp PINx functionality
N  * @rmtoll CR3          EWUP1         LL_PWR_DisableWakeUpPin\n
N  *         CR3          EWUP2         LL_PWR_DisableWakeUpPin\n
N  *         CR3          EWUP3         LL_PWR_DisableWakeUpPin\n
N  *         CR3          EWUP4         LL_PWR_DisableWakeUpPin\n
N  *         CR3          EWUP5         LL_PWR_DisableWakeUpPin\n
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_WAKEUP_PIN1
N  *         @arg @ref LL_PWR_WAKEUP_PIN2
N  *         @arg @ref LL_PWR_WAKEUP_PIN3
N  *         @arg @ref LL_PWR_WAKEUP_PIN4
N  *         @arg @ref LL_PWR_WAKEUP_PIN5
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableWakeUpPin(uint32_t WakeUpPin)
Xstatic __inline void LL_PWR_DisableWakeUpPin(uint32_t WakeUpPin)
N{
N  CLEAR_BIT(PWR->CR3, WakeUpPin);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) &= ~(WakeUpPin));
N}
N
N/**
N  * @brief  Check if the WakeUp PINx functionality is enabled
N  * @rmtoll CR3          EWUP1         LL_PWR_IsEnabledWakeUpPin\n
N  *         CR3          EWUP2         LL_PWR_IsEnabledWakeUpPin\n
N  *         CR3          EWUP3         LL_PWR_IsEnabledWakeUpPin\n
N  *         CR3          EWUP4         LL_PWR_IsEnabledWakeUpPin\n
N  *         CR3          EWUP5         LL_PWR_IsEnabledWakeUpPin\n
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_WAKEUP_PIN1
N  *         @arg @ref LL_PWR_WAKEUP_PIN2
N  *         @arg @ref LL_PWR_WAKEUP_PIN3
N  *         @arg @ref LL_PWR_WAKEUP_PIN4
N  *         @arg @ref LL_PWR_WAKEUP_PIN5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledWakeUpPin(uint32_t WakeUpPin)
Xstatic __inline uint32_t LL_PWR_IsEnabledWakeUpPin(uint32_t WakeUpPin)
N{
N  return (READ_BIT(PWR->CR3, WakeUpPin) == (WakeUpPin));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR3) & (WakeUpPin)) == (WakeUpPin));
N}
N
N/**
N  * @brief  Set the resistor impedance
N  * @rmtoll CR4          VBRS          LL_PWR_SetBattChargResistor
N  * @param  Resistor This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_BATT_CHARG_RESISTOR_5K
N  *         @arg @ref LL_PWR_BATT_CHARGRESISTOR_1_5K
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_SetBattChargResistor(uint32_t Resistor)
Xstatic __inline void LL_PWR_SetBattChargResistor(uint32_t Resistor)
N{
N  MODIFY_REG(PWR->CR4, PWR_CR4_VBRS, Resistor);
X  (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4)) = ((((((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4))) & (~((0x1UL << (9U))))) | (Resistor))));
N}
N
N/**
N  * @brief  Get the resistor impedance
N  * @rmtoll CR4          VBRS          LL_PWR_GetBattChargResistor
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_PWR_BATT_CHARG_RESISTOR_5K
N  *         @arg @ref LL_PWR_BATT_CHARGRESISTOR_1_5K
N  */
N__STATIC_INLINE uint32_t LL_PWR_GetBattChargResistor(void)
Xstatic __inline uint32_t LL_PWR_GetBattChargResistor(void)
N{
N  return (uint32_t)(READ_BIT(PWR->CR4, PWR_CR4_VBRS));
X  return (uint32_t)(((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) & ((0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Enable battery charging
N  * @rmtoll CR4          VBE           LL_PWR_EnableBatteryCharging
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableBatteryCharging(void)
Xstatic __inline void LL_PWR_EnableBatteryCharging(void)
N{
N  SET_BIT(PWR->CR4, PWR_CR4_VBE);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable battery charging
N  * @rmtoll CR4          VBE           LL_PWR_DisableBatteryCharging
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableBatteryCharging(void)
Xstatic __inline void LL_PWR_DisableBatteryCharging(void)
N{
N  CLEAR_BIT(PWR->CR4, PWR_CR4_VBE);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Check if battery charging is enabled
N  * @rmtoll CR4          VBE           LL_PWR_IsEnabledBatteryCharging
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledBatteryCharging(void)
Xstatic __inline uint32_t LL_PWR_IsEnabledBatteryCharging(void)
N{
N  return (READ_BIT(PWR->CR4, PWR_CR4_VBE) == (PWR_CR4_VBE));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Set the Wake-Up pin polarity low for the event detection
N  * @rmtoll CR4          WP1           LL_PWR_SetWakeUpPinPolarityLow\n
N  *         CR4          WP2           LL_PWR_SetWakeUpPinPolarityLow\n
N  *         CR4          WP3           LL_PWR_SetWakeUpPinPolarityLow\n
N  *         CR4          WP4           LL_PWR_SetWakeUpPinPolarityLow\n
N  *         CR4          WP5           LL_PWR_SetWakeUpPinPolarityLow
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_WAKEUP_PIN1
N  *         @arg @ref LL_PWR_WAKEUP_PIN2
N  *         @arg @ref LL_PWR_WAKEUP_PIN3
N  *         @arg @ref LL_PWR_WAKEUP_PIN4
N  *         @arg @ref LL_PWR_WAKEUP_PIN5
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_SetWakeUpPinPolarityLow(uint32_t WakeUpPin)
Xstatic __inline void LL_PWR_SetWakeUpPinPolarityLow(uint32_t WakeUpPin)
N{
N  SET_BIT(PWR->CR4, WakeUpPin);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) |= (WakeUpPin));
N}
N
N/**
N  * @brief  Set the Wake-Up pin polarity high for the event detection
N  * @rmtoll CR4          WP1           LL_PWR_SetWakeUpPinPolarityHigh\n
N  *         CR4          WP2           LL_PWR_SetWakeUpPinPolarityHigh\n
N  *         CR4          WP3           LL_PWR_SetWakeUpPinPolarityHigh\n
N  *         CR4          WP4           LL_PWR_SetWakeUpPinPolarityHigh\n
N  *         CR4          WP5           LL_PWR_SetWakeUpPinPolarityHigh
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_WAKEUP_PIN1
N  *         @arg @ref LL_PWR_WAKEUP_PIN2
N  *         @arg @ref LL_PWR_WAKEUP_PIN3
N  *         @arg @ref LL_PWR_WAKEUP_PIN4
N  *         @arg @ref LL_PWR_WAKEUP_PIN5
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_SetWakeUpPinPolarityHigh(uint32_t WakeUpPin)
Xstatic __inline void LL_PWR_SetWakeUpPinPolarityHigh(uint32_t WakeUpPin)
N{
N  CLEAR_BIT(PWR->CR4, WakeUpPin);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) &= ~(WakeUpPin));
N}
N
N/**
N  * @brief  Get the Wake-Up pin polarity for the event detection
N  * @rmtoll CR4          WP1           LL_PWR_IsWakeUpPinPolarityLow\n
N  *         CR4          WP2           LL_PWR_IsWakeUpPinPolarityLow\n
N  *         CR4          WP3           LL_PWR_IsWakeUpPinPolarityLow\n
N  *         CR4          WP4           LL_PWR_IsWakeUpPinPolarityLow\n
N  *         CR4          WP5           LL_PWR_IsWakeUpPinPolarityLow
N  * @param  WakeUpPin This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_WAKEUP_PIN1
N  *         @arg @ref LL_PWR_WAKEUP_PIN2
N  *         @arg @ref LL_PWR_WAKEUP_PIN3
N  *         @arg @ref LL_PWR_WAKEUP_PIN4
N  *         @arg @ref LL_PWR_WAKEUP_PIN5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsWakeUpPinPolarityLow(uint32_t WakeUpPin)
Xstatic __inline uint32_t LL_PWR_IsWakeUpPinPolarityLow(uint32_t WakeUpPin)
N{
N  return (READ_BIT(PWR->CR4, WakeUpPin) == (WakeUpPin));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->CR4) & (WakeUpPin)) == (WakeUpPin));
N}
N
N/**
N  * @brief  Enable GPIO pull-up state in Standby and Shutdown modes
N  * @rmtoll PUCRA        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRB        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRC        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRD        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRE        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRF        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRG        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRH        PU0-15        LL_PWR_EnableGPIOPullUp\n
N  *         PUCRI        PU0-11        LL_PWR_EnableGPIOPullUp
N  * @param  GPIO This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_A
N  *         @arg @ref LL_PWR_GPIO_B
N  *         @arg @ref LL_PWR_GPIO_C
N  *         @arg @ref LL_PWR_GPIO_D
N  *         @arg @ref LL_PWR_GPIO_E
N  *         @arg @ref LL_PWR_GPIO_F (*)
N  *         @arg @ref LL_PWR_GPIO_G (*)
N  *         @arg @ref LL_PWR_GPIO_H
N  *         @arg @ref LL_PWR_GPIO_I (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  GPIONumber This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_BIT_0
N  *         @arg @ref LL_PWR_GPIO_BIT_1
N  *         @arg @ref LL_PWR_GPIO_BIT_2
N  *         @arg @ref LL_PWR_GPIO_BIT_3
N  *         @arg @ref LL_PWR_GPIO_BIT_4
N  *         @arg @ref LL_PWR_GPIO_BIT_5
N  *         @arg @ref LL_PWR_GPIO_BIT_6
N  *         @arg @ref LL_PWR_GPIO_BIT_7
N  *         @arg @ref LL_PWR_GPIO_BIT_8
N  *         @arg @ref LL_PWR_GPIO_BIT_9
N  *         @arg @ref LL_PWR_GPIO_BIT_10
N  *         @arg @ref LL_PWR_GPIO_BIT_11
N  *         @arg @ref LL_PWR_GPIO_BIT_12
N  *         @arg @ref LL_PWR_GPIO_BIT_13
N  *         @arg @ref LL_PWR_GPIO_BIT_14
N  *         @arg @ref LL_PWR_GPIO_BIT_15
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
Xstatic __inline void LL_PWR_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
N{
N  SET_BIT(*((uint32_t *)GPIO), GPIONumber);
X  ((*((uint32_t *)GPIO)) |= (GPIONumber));
N}
N
N/**
N  * @brief  Disable GPIO pull-up state in Standby and Shutdown modes
N  * @rmtoll PUCRA        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRB        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRC        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRD        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRE        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRF        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRG        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRH        PU0-15        LL_PWR_DisableGPIOPullUp\n
N  *         PUCRI        PU0-11        LL_PWR_DisableGPIOPullUp
N  * @param  GPIO This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_A
N  *         @arg @ref LL_PWR_GPIO_B
N  *         @arg @ref LL_PWR_GPIO_C
N  *         @arg @ref LL_PWR_GPIO_D
N  *         @arg @ref LL_PWR_GPIO_E
N  *         @arg @ref LL_PWR_GPIO_F (*)
N  *         @arg @ref LL_PWR_GPIO_G (*)
N  *         @arg @ref LL_PWR_GPIO_H
N  *         @arg @ref LL_PWR_GPIO_I (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  GPIONumber This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_BIT_0
N  *         @arg @ref LL_PWR_GPIO_BIT_1
N  *         @arg @ref LL_PWR_GPIO_BIT_2
N  *         @arg @ref LL_PWR_GPIO_BIT_3
N  *         @arg @ref LL_PWR_GPIO_BIT_4
N  *         @arg @ref LL_PWR_GPIO_BIT_5
N  *         @arg @ref LL_PWR_GPIO_BIT_6
N  *         @arg @ref LL_PWR_GPIO_BIT_7
N  *         @arg @ref LL_PWR_GPIO_BIT_8
N  *         @arg @ref LL_PWR_GPIO_BIT_9
N  *         @arg @ref LL_PWR_GPIO_BIT_10
N  *         @arg @ref LL_PWR_GPIO_BIT_11
N  *         @arg @ref LL_PWR_GPIO_BIT_12
N  *         @arg @ref LL_PWR_GPIO_BIT_13
N  *         @arg @ref LL_PWR_GPIO_BIT_14
N  *         @arg @ref LL_PWR_GPIO_BIT_15
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
Xstatic __inline void LL_PWR_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
N{
N  CLEAR_BIT(*((uint32_t *)GPIO), GPIONumber);
X  ((*((uint32_t *)GPIO)) &= ~(GPIONumber));
N}
N
N/**
N  * @brief  Check if GPIO pull-up state is enabled
N  * @rmtoll PUCRA        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRB        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRC        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRD        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRE        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRF        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRG        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRH        PU0-15        LL_PWR_IsEnabledGPIOPullUp\n
N  *         PUCRI        PU0-11        LL_PWR_IsEnabledGPIOPullUp
N  * @param  GPIO This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_A
N  *         @arg @ref LL_PWR_GPIO_B
N  *         @arg @ref LL_PWR_GPIO_C
N  *         @arg @ref LL_PWR_GPIO_D
N  *         @arg @ref LL_PWR_GPIO_E
N  *         @arg @ref LL_PWR_GPIO_F (*)
N  *         @arg @ref LL_PWR_GPIO_G (*)
N  *         @arg @ref LL_PWR_GPIO_H
N  *         @arg @ref LL_PWR_GPIO_I (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  GPIONumber This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_BIT_0
N  *         @arg @ref LL_PWR_GPIO_BIT_1
N  *         @arg @ref LL_PWR_GPIO_BIT_2
N  *         @arg @ref LL_PWR_GPIO_BIT_3
N  *         @arg @ref LL_PWR_GPIO_BIT_4
N  *         @arg @ref LL_PWR_GPIO_BIT_5
N  *         @arg @ref LL_PWR_GPIO_BIT_6
N  *         @arg @ref LL_PWR_GPIO_BIT_7
N  *         @arg @ref LL_PWR_GPIO_BIT_8
N  *         @arg @ref LL_PWR_GPIO_BIT_9
N  *         @arg @ref LL_PWR_GPIO_BIT_10
N  *         @arg @ref LL_PWR_GPIO_BIT_11
N  *         @arg @ref LL_PWR_GPIO_BIT_12
N  *         @arg @ref LL_PWR_GPIO_BIT_13
N  *         @arg @ref LL_PWR_GPIO_BIT_14
N  *         @arg @ref LL_PWR_GPIO_BIT_15
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
Xstatic __inline uint32_t LL_PWR_IsEnabledGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
N{
N  return (READ_BIT(*((uint32_t *)(GPIO)), GPIONumber) == (GPIONumber));
X  return (((*((uint32_t *)(GPIO))) & (GPIONumber)) == (GPIONumber));
N}
N
N/**
N  * @brief  Enable GPIO pull-down state in Standby and Shutdown modes
N  * @rmtoll PDCRA        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRB        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRC        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRD        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRE        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRF        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRG        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRH        PD0-15        LL_PWR_EnableGPIOPullDown\n
N  *         PDCRI        PD0-11        LL_PWR_EnableGPIOPullDown
N  * @param  GPIO This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_A
N  *         @arg @ref LL_PWR_GPIO_B
N  *         @arg @ref LL_PWR_GPIO_C
N  *         @arg @ref LL_PWR_GPIO_D
N  *         @arg @ref LL_PWR_GPIO_E
N  *         @arg @ref LL_PWR_GPIO_F (*)
N  *         @arg @ref LL_PWR_GPIO_G (*)
N  *         @arg @ref LL_PWR_GPIO_H
N  *         @arg @ref LL_PWR_GPIO_I (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  GPIONumber This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_BIT_0
N  *         @arg @ref LL_PWR_GPIO_BIT_1
N  *         @arg @ref LL_PWR_GPIO_BIT_2
N  *         @arg @ref LL_PWR_GPIO_BIT_3
N  *         @arg @ref LL_PWR_GPIO_BIT_4
N  *         @arg @ref LL_PWR_GPIO_BIT_5
N  *         @arg @ref LL_PWR_GPIO_BIT_6
N  *         @arg @ref LL_PWR_GPIO_BIT_7
N  *         @arg @ref LL_PWR_GPIO_BIT_8
N  *         @arg @ref LL_PWR_GPIO_BIT_9
N  *         @arg @ref LL_PWR_GPIO_BIT_10
N  *         @arg @ref LL_PWR_GPIO_BIT_11
N  *         @arg @ref LL_PWR_GPIO_BIT_12
N  *         @arg @ref LL_PWR_GPIO_BIT_13
N  *         @arg @ref LL_PWR_GPIO_BIT_14
N  *         @arg @ref LL_PWR_GPIO_BIT_15
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
Xstatic __inline void LL_PWR_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
N{
N  register uint32_t temp = (uint32_t)(GPIO) + 4;
N  SET_BIT(*((uint32_t *)(temp)), GPIONumber);
X  ((*((uint32_t *)(temp))) |= (GPIONumber));
N}
N
N/**
N  * @brief  Disable GPIO pull-down state in Standby and Shutdown modes
N  * @rmtoll PDCRA        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRB        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRC        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRD        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRE        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRF        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRG        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRH        PD0-15        LL_PWR_DisableGPIOPullDown\n
N  *         PDCRI        PD0-11        LL_PWR_DisableGPIOPullDown
N  * @param  GPIO This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_A
N  *         @arg @ref LL_PWR_GPIO_B
N  *         @arg @ref LL_PWR_GPIO_C
N  *         @arg @ref LL_PWR_GPIO_D
N  *         @arg @ref LL_PWR_GPIO_E
N  *         @arg @ref LL_PWR_GPIO_F (*)
N  *         @arg @ref LL_PWR_GPIO_G (*)
N  *         @arg @ref LL_PWR_GPIO_H
N  *         @arg @ref LL_PWR_GPIO_I (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  GPIONumber This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_BIT_0
N  *         @arg @ref LL_PWR_GPIO_BIT_1
N  *         @arg @ref LL_PWR_GPIO_BIT_2
N  *         @arg @ref LL_PWR_GPIO_BIT_3
N  *         @arg @ref LL_PWR_GPIO_BIT_4
N  *         @arg @ref LL_PWR_GPIO_BIT_5
N  *         @arg @ref LL_PWR_GPIO_BIT_6
N  *         @arg @ref LL_PWR_GPIO_BIT_7
N  *         @arg @ref LL_PWR_GPIO_BIT_8
N  *         @arg @ref LL_PWR_GPIO_BIT_9
N  *         @arg @ref LL_PWR_GPIO_BIT_10
N  *         @arg @ref LL_PWR_GPIO_BIT_11
N  *         @arg @ref LL_PWR_GPIO_BIT_12
N  *         @arg @ref LL_PWR_GPIO_BIT_13
N  *         @arg @ref LL_PWR_GPIO_BIT_14
N  *         @arg @ref LL_PWR_GPIO_BIT_15
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
Xstatic __inline void LL_PWR_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
N{
N  register uint32_t temp = (uint32_t)(GPIO) + 4;
N  CLEAR_BIT(*((uint32_t *)(temp)), GPIONumber);
X  ((*((uint32_t *)(temp))) &= ~(GPIONumber));
N}
N
N/**
N  * @brief  Check if GPIO pull-down state is enabled
N  * @rmtoll PDCRA        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRB        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRC        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRD        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRE        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRF        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRG        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRH        PD0-15        LL_PWR_IsEnabledGPIOPullDown\n
N  *         PDCRI        PD0-11        LL_PWR_IsEnabledGPIOPullDown
N  * @param  GPIO This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_A
N  *         @arg @ref LL_PWR_GPIO_B
N  *         @arg @ref LL_PWR_GPIO_C
N  *         @arg @ref LL_PWR_GPIO_D
N  *         @arg @ref LL_PWR_GPIO_E
N  *         @arg @ref LL_PWR_GPIO_F (*)
N  *         @arg @ref LL_PWR_GPIO_G (*)
N  *         @arg @ref LL_PWR_GPIO_H
N  *         @arg @ref LL_PWR_GPIO_I (*)
N  *
N  *         (*) value not defined in all devices
N  * @param  GPIONumber This parameter can be one of the following values:
N  *         @arg @ref LL_PWR_GPIO_BIT_0
N  *         @arg @ref LL_PWR_GPIO_BIT_1
N  *         @arg @ref LL_PWR_GPIO_BIT_2
N  *         @arg @ref LL_PWR_GPIO_BIT_3
N  *         @arg @ref LL_PWR_GPIO_BIT_4
N  *         @arg @ref LL_PWR_GPIO_BIT_5
N  *         @arg @ref LL_PWR_GPIO_BIT_6
N  *         @arg @ref LL_PWR_GPIO_BIT_7
N  *         @arg @ref LL_PWR_GPIO_BIT_8
N  *         @arg @ref LL_PWR_GPIO_BIT_9
N  *         @arg @ref LL_PWR_GPIO_BIT_10
N  *         @arg @ref LL_PWR_GPIO_BIT_11
N  *         @arg @ref LL_PWR_GPIO_BIT_12
N  *         @arg @ref LL_PWR_GPIO_BIT_13
N  *         @arg @ref LL_PWR_GPIO_BIT_14
N  *         @arg @ref LL_PWR_GPIO_BIT_15
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsEnabledGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
Xstatic __inline uint32_t LL_PWR_IsEnabledGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
N{
N  register uint32_t temp = (uint32_t)(GPIO) + 4;
N  return (READ_BIT(*((uint32_t *)(temp)), GPIONumber) == (GPIONumber));
X  return (((*((uint32_t *)(temp))) & (GPIONumber)) == (GPIONumber));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup PWR_LL_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Get Internal Wake-up line Flag
N  * @rmtoll SR1          WUFI          LL_PWR_IsActiveFlag_InternWU
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_InternWU(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_InternWU(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_WUFI) == (PWR_SR1_WUFI));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Get Stand-By Flag
N  * @rmtoll SR1          SBF           LL_PWR_IsActiveFlag_SB
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_SB(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_SB(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_SBF) == (PWR_SR1_SBF));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Get Wake-up Flag 5
N  * @rmtoll SR1          WUF5          LL_PWR_IsActiveFlag_WU5
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_WU5(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_WU5(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_WUF5) == (PWR_SR1_WUF5));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get Wake-up Flag 4
N  * @rmtoll SR1          WUF4          LL_PWR_IsActiveFlag_WU4
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_WU4(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_WU4(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_WUF4) == (PWR_SR1_WUF4));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get Wake-up Flag 3
N  * @rmtoll SR1          WUF3          LL_PWR_IsActiveFlag_WU3
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_WU3(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_WU3(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_WUF3) == (PWR_SR1_WUF3));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get Wake-up Flag 2
N  * @rmtoll SR1          WUF2          LL_PWR_IsActiveFlag_WU2
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_WU2(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_WU2(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_WUF2) == (PWR_SR1_WUF2));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get Wake-up Flag 1
N  * @rmtoll SR1          WUF1          LL_PWR_IsActiveFlag_WU1
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_WU1(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_WU1(void)
N{
N  return (READ_BIT(PWR->SR1, PWR_SR1_WUF1) == (PWR_SR1_WUF1));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Stand-By Flag
N  * @rmtoll SCR          CSBF          LL_PWR_ClearFlag_SB
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_SB(void)
Xstatic __inline void LL_PWR_ClearFlag_SB(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CSBF);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flags
N  * @rmtoll SCR          CWUF          LL_PWR_ClearFlag_WU
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_WU(void)
Xstatic __inline void LL_PWR_ClearFlag_WU(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CWUF);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1FUL << (0U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flag 5
N  * @rmtoll SCR          CWUF5         LL_PWR_ClearFlag_WU5
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_WU5(void)
Xstatic __inline void LL_PWR_ClearFlag_WU5(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CWUF5);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flag 4
N  * @rmtoll SCR          CWUF4         LL_PWR_ClearFlag_WU4
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_WU4(void)
Xstatic __inline void LL_PWR_ClearFlag_WU4(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CWUF4);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flag 3
N  * @rmtoll SCR          CWUF3         LL_PWR_ClearFlag_WU3
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_WU3(void)
Xstatic __inline void LL_PWR_ClearFlag_WU3(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CWUF3);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flag 2
N  * @rmtoll SCR          CWUF2         LL_PWR_ClearFlag_WU2
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_WU2(void)
Xstatic __inline void LL_PWR_ClearFlag_WU2(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CWUF2);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear Wake-up Flag 1
N  * @rmtoll SCR          CWUF1         LL_PWR_ClearFlag_WU1
N  * @retval None
N  */
N__STATIC_INLINE void LL_PWR_ClearFlag_WU1(void)
Xstatic __inline void LL_PWR_ClearFlag_WU1(void)
N{
N  WRITE_REG(PWR->SCR, PWR_SCR_CWUF1);
X  ((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SCR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicate whether VDDA voltage is below or above PVM4 threshold
N  * @rmtoll SR2          PVMO4         LL_PWR_IsActiveFlag_PVMO4
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_PVMO4(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_PVMO4(void)
N{
N  return (READ_BIT(PWR->SR2, PWR_SR2_PVMO4) == (PWR_SR2_PVMO4));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR2) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Indicate whether VDDA voltage is below or above PVM3 threshold
N  * @rmtoll SR2          PVMO3         LL_PWR_IsActiveFlag_PVMO3
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_PVMO3(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_PVMO3(void)
N{
N  return (READ_BIT(PWR->SR2, PWR_SR2_PVMO3) == (PWR_SR2_PVMO3));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR2) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N#if defined(PWR_SR2_PVMO2)
X#if 0L
S/**
S  * @brief  Indicate whether VDDIO2 voltage is below or above PVM2 threshold
S  * @rmtoll SR2          PVMO2         LL_PWR_IsActiveFlag_PVMO2
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_PVMO2(void)
S{
S  return (READ_BIT(PWR->SR2, PWR_SR2_PVMO2) == (PWR_SR2_PVMO2));
S}
N#endif /* PWR_SR2_PVMO2 */
N
N#if defined(PWR_SR2_PVMO1)
X#if 0L
S/**
S  * @brief  Indicate whether VDDUSB voltage is below or above PVM1 threshold
S  * @rmtoll SR2          PVMO1         LL_PWR_IsActiveFlag_PVMO1
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_PVMO1(void)
S{
S  return (READ_BIT(PWR->SR2, PWR_SR2_PVMO1) == (PWR_SR2_PVMO1));
S}
N#endif /* PWR_SR2_PVMO1 */
N
N/**
N  * @brief  Indicate whether VDD voltage is below or above the selected PVD threshold
N  * @rmtoll SR2          PVDO          LL_PWR_IsActiveFlag_PVDO
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_PVDO(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_PVDO(void)
N{
N  return (READ_BIT(PWR->SR2, PWR_SR2_PVDO) == (PWR_SR2_PVDO));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR2) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicate whether the regulator is ready in the selected voltage range or if its output voltage is still changing to the required voltage level
N  * @rmtoll SR2          VOSF          LL_PWR_IsActiveFlag_VOS
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_VOS(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_VOS(void)
N{
N  return (READ_BIT(PWR->SR2, PWR_SR2_VOSF) == (PWR_SR2_VOSF));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR2) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Indicate whether the regulator is ready in main mode or is in low-power mode
N  * @note   Take care, return value "0" means the regulator is ready. Return value "1" means the output voltage range is still changing.
N  * @rmtoll SR2          REGLPF        LL_PWR_IsActiveFlag_REGLPF
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_REGLPF(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_REGLPF(void)
N{
N  return (READ_BIT(PWR->SR2, PWR_SR2_REGLPF) == (PWR_SR2_REGLPF));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR2) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Indicate whether or not the low-power regulator is ready
N  * @rmtoll SR2          REGLPS        LL_PWR_IsActiveFlag_REGLPS
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_REGLPS(void)
Xstatic __inline uint32_t LL_PWR_IsActiveFlag_REGLPS(void)
N{
N  return (READ_BIT(PWR->SR2, PWR_SR2_REGLPS) == (PWR_SR2_REGLPS));
X  return (((((PWR_TypeDef *) ((0x40000000UL) + 0x7000UL))->SR2) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup PWR_LL_EF_Init De-initialization function
N  * @{
N  */
NErrorStatus LL_PWR_DeInit(void);
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/** @defgroup PWR_LL_EF_Legacy_Functions Legacy functions name
N  * @{
N  */
N/* Old functions name kept for legacy purpose, to be replaced by the          */
N/* current functions name.                                                    */
N#define LL_PWR_IsActiveFlag_VOSF  LL_PWR_IsActiveFlag_VOS
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* defined(PWR) */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_PWR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 14 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_dma.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_dma.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_DMA_H
N#define __STM32L4xx_LL_DMA_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N#if defined(DMAMUX1)
X#if 0L
S#include "stm32l4xx_ll_dmamux.h"
N#endif /* DMAMUX1 */
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (DMA1) || defined (DMA2)
X#if 1L || 1L
N
N/** @defgroup DMA_LL DMA
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup DMA_LL_Private_Variables DMA Private Variables
N  * @{
N  */
N/* Array used to get the DMA channel register offset versus channel index LL_DMA_CHANNEL_x */
Nstatic const uint8_t CHANNEL_OFFSET_TAB[] =
N{
N  (uint8_t)(DMA1_Channel1_BASE - DMA1_BASE),
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x0008UL) - (((0x40000000UL) + 0x00020000UL))),
N  (uint8_t)(DMA1_Channel2_BASE - DMA1_BASE),
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x001CUL) - (((0x40000000UL) + 0x00020000UL))),
N  (uint8_t)(DMA1_Channel3_BASE - DMA1_BASE),
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x0030UL) - (((0x40000000UL) + 0x00020000UL))),
N  (uint8_t)(DMA1_Channel4_BASE - DMA1_BASE),
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x0044UL) - (((0x40000000UL) + 0x00020000UL))),
N  (uint8_t)(DMA1_Channel5_BASE - DMA1_BASE),
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x0058UL) - (((0x40000000UL) + 0x00020000UL))),
N  (uint8_t)(DMA1_Channel6_BASE - DMA1_BASE),
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x006CUL) - (((0x40000000UL) + 0x00020000UL))),
N  (uint8_t)(DMA1_Channel7_BASE - DMA1_BASE)
X  (uint8_t)(((((0x40000000UL) + 0x00020000UL)) + 0x0080UL) - (((0x40000000UL) + 0x00020000UL)))
N};
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N#if defined(DMAMUX1)
X#if 0L
N#else
N/** @defgroup DMA_LL_Private_Constants DMA Private Constants
N  * @{
N  */
N/* Define used to get CSELR register offset */
N#define DMA_CSELR_OFFSET                  (uint32_t)(DMA1_CSELR_BASE - DMA1_BASE)
N
N/* Defines used for the bit position in the register and perform offsets */
N#define DMA_POSITION_CSELR_CXS            POSITION_VAL(DMA_CSELR_C1S << ((Channel-1U)*4U))
N/**
N  * @}
N  */
N#endif /* DMAMUX1 */
N
N/* Private macros ------------------------------------------------------------*/
N#if defined(DMAMUX1)
X#if 0L
S/** @defgroup DMA_LL_Private_Macros DMA Private Macros
S  * @{
S  */
S/**
S  * @brief  Helper macro to convert DMA Instance DMAx into DMAMUX channel
S  * @note   DMAMUX channel 0 to 6 are mapped to DMA1 channel 1 to 7.
S  *         DMAMUX channel 7 to 13 are mapped to DMA2 channel 1 to 7.
S  * @param  __DMA_INSTANCE__ DMAx
S  * @retval Channel_Offset (LL_DMA_CHANNEL_7 or 0).
S  */
S#define __LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(__DMA_INSTANCE__)   \
S(((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) ? 0 : LL_DMA_CHANNEL_7)
X#define __LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(__DMA_INSTANCE__)   (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) ? 0 : LL_DMA_CHANNEL_7)
S
S/**
S  * @}
S  */
N#else
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup DMA_LL_Private_Macros DMA Private Macros
N  * @{
N  */
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N#endif /* DMAMUX1 */
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup DMA_LL_ES_INIT DMA Exported Init structure
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t PeriphOrM2MSrcAddress;  /*!< Specifies the peripheral base address for DMA transfer
N                                        or as Source base address in case of memory to memory transfer direction.
N
N                                        This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF. */
N
N  uint32_t MemoryOrM2MDstAddress;  /*!< Specifies the memory base address for DMA transfer
N                                        or as Destination base address in case of memory to memory transfer direction.
N
N                                        This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF. */
N
N  uint32_t Direction;              /*!< Specifies if the data will be transferred from memory to peripheral,
N                                        from memory to memory or from peripheral to memory.
N                                        This parameter can be a value of @ref DMA_LL_EC_DIRECTION
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataTransferDirection(). */
N
N  uint32_t Mode;                   /*!< Specifies the normal or circular operation mode.
N                                        This parameter can be a value of @ref DMA_LL_EC_MODE
N                                        @note: The circular buffer mode cannot be used if the memory to memory
N                                               data transfer direction is configured on the selected Channel
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetMode(). */
N
N  uint32_t PeriphOrM2MSrcIncMode;  /*!< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction
N                                        is incremented or not.
N                                        This parameter can be a value of @ref DMA_LL_EC_PERIPH
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphIncMode(). */
N
N  uint32_t MemoryOrM2MDstIncMode;  /*!< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction
N                                        is incremented or not.
N                                        This parameter can be a value of @ref DMA_LL_EC_MEMORY
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemoryIncMode(). */
N
N  uint32_t PeriphOrM2MSrcDataSize; /*!< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)
N                                        in case of memory to memory transfer direction.
N                                        This parameter can be a value of @ref DMA_LL_EC_PDATAALIGN
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphSize(). */
N
N  uint32_t MemoryOrM2MDstDataSize; /*!< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)
N                                        in case of memory to memory transfer direction.
N                                        This parameter can be a value of @ref DMA_LL_EC_MDATAALIGN
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemorySize(). */
N
N  uint32_t NbData;                 /*!< Specifies the number of data to transfer, in data unit.
N                                        The data unit is equal to the source buffer configuration set in PeripheralSize
N                                        or MemorySize parameters depending in the transfer direction.
N                                        This parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataLength(). */
N#if defined(DMAMUX1)
X#if 0L
S
S  uint32_t PeriphRequest;          /*!< Specifies the peripheral request.
S                                        This parameter can be a value of @ref DMAMUX_LL_EC_REQUEST
S
S                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphRequest(). */
N#else
N
N  uint32_t PeriphRequest;          /*!< Specifies the peripheral request.
N                                        This parameter can be a value of @ref DMA_LL_EC_REQUEST
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphRequest(). */
N#endif /* DMAMUX1 */
N
N  uint32_t Priority;               /*!< Specifies the channel priority level.
N                                        This parameter can be a value of @ref DMA_LL_EC_PRIORITY
N
N                                        This feature can be modified afterwards using unitary function @ref LL_DMA_SetChannelPriorityLevel(). */
N
N} LL_DMA_InitTypeDef;
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup DMA_LL_Exported_Constants DMA Exported Constants
N  * @{
N  */
N/** @defgroup DMA_LL_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with LL_DMA_WriteReg function
N  * @{
N  */
N#define LL_DMA_IFCR_CGIF1                 DMA_IFCR_CGIF1        /*!< Channel 1 global flag            */
N#define LL_DMA_IFCR_CTCIF1                DMA_IFCR_CTCIF1       /*!< Channel 1 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF1                DMA_IFCR_CHTIF1       /*!< Channel 1 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF1                DMA_IFCR_CTEIF1       /*!< Channel 1 transfer error flag    */
N#define LL_DMA_IFCR_CGIF2                 DMA_IFCR_CGIF2        /*!< Channel 2 global flag            */
N#define LL_DMA_IFCR_CTCIF2                DMA_IFCR_CTCIF2       /*!< Channel 2 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF2                DMA_IFCR_CHTIF2       /*!< Channel 2 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF2                DMA_IFCR_CTEIF2       /*!< Channel 2 transfer error flag    */
N#define LL_DMA_IFCR_CGIF3                 DMA_IFCR_CGIF3        /*!< Channel 3 global flag            */
N#define LL_DMA_IFCR_CTCIF3                DMA_IFCR_CTCIF3       /*!< Channel 3 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF3                DMA_IFCR_CHTIF3       /*!< Channel 3 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF3                DMA_IFCR_CTEIF3       /*!< Channel 3 transfer error flag    */
N#define LL_DMA_IFCR_CGIF4                 DMA_IFCR_CGIF4        /*!< Channel 4 global flag            */
N#define LL_DMA_IFCR_CTCIF4                DMA_IFCR_CTCIF4       /*!< Channel 4 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF4                DMA_IFCR_CHTIF4       /*!< Channel 4 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF4                DMA_IFCR_CTEIF4       /*!< Channel 4 transfer error flag    */
N#define LL_DMA_IFCR_CGIF5                 DMA_IFCR_CGIF5        /*!< Channel 5 global flag            */
N#define LL_DMA_IFCR_CTCIF5                DMA_IFCR_CTCIF5       /*!< Channel 5 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF5                DMA_IFCR_CHTIF5       /*!< Channel 5 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF5                DMA_IFCR_CTEIF5       /*!< Channel 5 transfer error flag    */
N#define LL_DMA_IFCR_CGIF6                 DMA_IFCR_CGIF6        /*!< Channel 6 global flag            */
N#define LL_DMA_IFCR_CTCIF6                DMA_IFCR_CTCIF6       /*!< Channel 6 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF6                DMA_IFCR_CHTIF6       /*!< Channel 6 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF6                DMA_IFCR_CTEIF6       /*!< Channel 6 transfer error flag    */
N#define LL_DMA_IFCR_CGIF7                 DMA_IFCR_CGIF7        /*!< Channel 7 global flag            */
N#define LL_DMA_IFCR_CTCIF7                DMA_IFCR_CTCIF7       /*!< Channel 7 transfer complete flag */
N#define LL_DMA_IFCR_CHTIF7                DMA_IFCR_CHTIF7       /*!< Channel 7 half transfer flag     */
N#define LL_DMA_IFCR_CTEIF7                DMA_IFCR_CTEIF7       /*!< Channel 7 transfer error flag    */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_DMA_ReadReg function
N  * @{
N  */
N#define LL_DMA_ISR_GIF1                   DMA_ISR_GIF1          /*!< Channel 1 global flag            */
N#define LL_DMA_ISR_TCIF1                  DMA_ISR_TCIF1         /*!< Channel 1 transfer complete flag */
N#define LL_DMA_ISR_HTIF1                  DMA_ISR_HTIF1         /*!< Channel 1 half transfer flag     */
N#define LL_DMA_ISR_TEIF1                  DMA_ISR_TEIF1         /*!< Channel 1 transfer error flag    */
N#define LL_DMA_ISR_GIF2                   DMA_ISR_GIF2          /*!< Channel 2 global flag            */
N#define LL_DMA_ISR_TCIF2                  DMA_ISR_TCIF2         /*!< Channel 2 transfer complete flag */
N#define LL_DMA_ISR_HTIF2                  DMA_ISR_HTIF2         /*!< Channel 2 half transfer flag     */
N#define LL_DMA_ISR_TEIF2                  DMA_ISR_TEIF2         /*!< Channel 2 transfer error flag    */
N#define LL_DMA_ISR_GIF3                   DMA_ISR_GIF3          /*!< Channel 3 global flag            */
N#define LL_DMA_ISR_TCIF3                  DMA_ISR_TCIF3         /*!< Channel 3 transfer complete flag */
N#define LL_DMA_ISR_HTIF3                  DMA_ISR_HTIF3         /*!< Channel 3 half transfer flag     */
N#define LL_DMA_ISR_TEIF3                  DMA_ISR_TEIF3         /*!< Channel 3 transfer error flag    */
N#define LL_DMA_ISR_GIF4                   DMA_ISR_GIF4          /*!< Channel 4 global flag            */
N#define LL_DMA_ISR_TCIF4                  DMA_ISR_TCIF4         /*!< Channel 4 transfer complete flag */
N#define LL_DMA_ISR_HTIF4                  DMA_ISR_HTIF4         /*!< Channel 4 half transfer flag     */
N#define LL_DMA_ISR_TEIF4                  DMA_ISR_TEIF4         /*!< Channel 4 transfer error flag    */
N#define LL_DMA_ISR_GIF5                   DMA_ISR_GIF5          /*!< Channel 5 global flag            */
N#define LL_DMA_ISR_TCIF5                  DMA_ISR_TCIF5         /*!< Channel 5 transfer complete flag */
N#define LL_DMA_ISR_HTIF5                  DMA_ISR_HTIF5         /*!< Channel 5 half transfer flag     */
N#define LL_DMA_ISR_TEIF5                  DMA_ISR_TEIF5         /*!< Channel 5 transfer error flag    */
N#define LL_DMA_ISR_GIF6                   DMA_ISR_GIF6          /*!< Channel 6 global flag            */
N#define LL_DMA_ISR_TCIF6                  DMA_ISR_TCIF6         /*!< Channel 6 transfer complete flag */
N#define LL_DMA_ISR_HTIF6                  DMA_ISR_HTIF6         /*!< Channel 6 half transfer flag     */
N#define LL_DMA_ISR_TEIF6                  DMA_ISR_TEIF6         /*!< Channel 6 transfer error flag    */
N#define LL_DMA_ISR_GIF7                   DMA_ISR_GIF7          /*!< Channel 7 global flag            */
N#define LL_DMA_ISR_TCIF7                  DMA_ISR_TCIF7         /*!< Channel 7 transfer complete flag */
N#define LL_DMA_ISR_HTIF7                  DMA_ISR_HTIF7         /*!< Channel 7 half transfer flag     */
N#define LL_DMA_ISR_TEIF7                  DMA_ISR_TEIF7         /*!< Channel 7 transfer error flag    */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_IT IT Defines
N  * @brief    IT defines which can be used with LL_DMA_ReadReg and  LL_DMA_WriteReg functions
N  * @{
N  */
N#define LL_DMA_CCR_TCIE                   DMA_CCR_TCIE          /*!< Transfer complete interrupt */
N#define LL_DMA_CCR_HTIE                   DMA_CCR_HTIE          /*!< Half Transfer interrupt     */
N#define LL_DMA_CCR_TEIE                   DMA_CCR_TEIE          /*!< Transfer error interrupt    */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_CHANNEL CHANNEL
N  * @{
N  */
N#define LL_DMA_CHANNEL_1                  0x00000001U /*!< DMA Channel 1 */
N#define LL_DMA_CHANNEL_2                  0x00000002U /*!< DMA Channel 2 */
N#define LL_DMA_CHANNEL_3                  0x00000003U /*!< DMA Channel 3 */
N#define LL_DMA_CHANNEL_4                  0x00000004U /*!< DMA Channel 4 */
N#define LL_DMA_CHANNEL_5                  0x00000005U /*!< DMA Channel 5 */
N#define LL_DMA_CHANNEL_6                  0x00000006U /*!< DMA Channel 6 */
N#define LL_DMA_CHANNEL_7                  0x00000007U /*!< DMA Channel 7 */
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N#define LL_DMA_CHANNEL_ALL                0xFFFF0000U /*!< DMA Channel all (used only for function @ref LL_DMA_DeInit(). */
N#endif /*USE_FULL_LL_DRIVER*/
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_DIRECTION Transfer Direction
N  * @{
N  */
N#define LL_DMA_DIRECTION_PERIPH_TO_MEMORY 0x00000000U             /*!< Peripheral to memory direction */
N#define LL_DMA_DIRECTION_MEMORY_TO_PERIPH DMA_CCR_DIR             /*!< Memory to peripheral direction */
N#define LL_DMA_DIRECTION_MEMORY_TO_MEMORY DMA_CCR_MEM2MEM         /*!< Memory to memory direction     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_MODE Transfer mode
N  * @{
N  */
N#define LL_DMA_MODE_NORMAL                0x00000000U             /*!< Normal Mode                  */
N#define LL_DMA_MODE_CIRCULAR              DMA_CCR_CIRC            /*!< Circular Mode                */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_PERIPH Peripheral increment mode
N  * @{
N  */
N#define LL_DMA_PERIPH_INCREMENT           DMA_CCR_PINC            /*!< Peripheral increment mode Enable */
N#define LL_DMA_PERIPH_NOINCREMENT         0x00000000U             /*!< Peripheral increment mode Disable */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_MEMORY Memory increment mode
N  * @{
N  */
N#define LL_DMA_MEMORY_INCREMENT           DMA_CCR_MINC            /*!< Memory increment mode Enable  */
N#define LL_DMA_MEMORY_NOINCREMENT         0x00000000U             /*!< Memory increment mode Disable */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_PDATAALIGN Peripheral data alignment
N  * @{
N  */
N#define LL_DMA_PDATAALIGN_BYTE            0x00000000U             /*!< Peripheral data alignment : Byte     */
N#define LL_DMA_PDATAALIGN_HALFWORD        DMA_CCR_PSIZE_0         /*!< Peripheral data alignment : HalfWord */
N#define LL_DMA_PDATAALIGN_WORD            DMA_CCR_PSIZE_1         /*!< Peripheral data alignment : Word     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_MDATAALIGN Memory data alignment
N  * @{
N  */
N#define LL_DMA_MDATAALIGN_BYTE            0x00000000U             /*!< Memory data alignment : Byte     */
N#define LL_DMA_MDATAALIGN_HALFWORD        DMA_CCR_MSIZE_0         /*!< Memory data alignment : HalfWord */
N#define LL_DMA_MDATAALIGN_WORD            DMA_CCR_MSIZE_1         /*!< Memory data alignment : Word     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EC_PRIORITY Transfer Priority level
N  * @{
N  */
N#define LL_DMA_PRIORITY_LOW               0x00000000U             /*!< Priority level : Low       */
N#define LL_DMA_PRIORITY_MEDIUM            DMA_CCR_PL_0            /*!< Priority level : Medium    */
N#define LL_DMA_PRIORITY_HIGH              DMA_CCR_PL_1            /*!< Priority level : High      */
N#define LL_DMA_PRIORITY_VERYHIGH          DMA_CCR_PL              /*!< Priority level : Very_High */
N/**
N  * @}
N  */
N
N#if defined(DMAMUX1)
X#if 0L
S/** @defgroup DMAMUX_LL_EC_REQUEST Transfer request
S  * @{
S  */
S#define LL_DMAMUX_REQUEST_MEM2MEM          0U   /*!< Memory to memory transfer  */
S#define LL_DMAMUX_REQUEST_GENERATOR0       1U   /*!< DMAMUX request generator 0 */
S#define LL_DMAMUX_REQUEST_GENERATOR1       2U   /*!< DMAMUX request generator 1 */
S#define LL_DMAMUX_REQUEST_GENERATOR2       3U   /*!< DMAMUX request generator 2 */
S#define LL_DMAMUX_REQUEST_GENERATOR3       4U   /*!< DMAMUX request generator 3 */
S#define LL_DMAMUX_REQUEST_ADC1             5U   /*!< DMAMUX ADC1 request        */
S#define LL_DMAMUX_REQUEST_DAC1_CH1         6U   /*!< DMAMUX DAC1 CH1 request    */
S#define LL_DMAMUX_REQUEST_DAC1_CH2         7U   /*!< DMAMUX DAC1 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM6_UP          8U   /*!< DMAMUX TIM6 UP request     */
S#define LL_DMAMUX_REQUEST_TIM7_UP          9U   /*!< DMAMUX TIM7 UP request     */
S#define LL_DMAMUX_REQUEST_SPI1_RX         10U   /*!< DMAMUX SPI1 RX request     */
S#define LL_DMAMUX_REQUEST_SPI1_TX         11U   /*!< DMAMUX SPI1 TX request     */
S#define LL_DMAMUX_REQUEST_SPI2_RX         12U   /*!< DMAMUX SPI2 RX request     */
S#define LL_DMAMUX_REQUEST_SPI2_TX         13U   /*!< DMAMUX SPI2 TX request     */
S#define LL_DMAMUX_REQUEST_SPI3_RX         14U   /*!< DMAMUX SPI3 RX request     */
S#define LL_DMAMUX_REQUEST_SPI3_TX         15U   /*!< DMAMUX SPI3 TX request     */
S#define LL_DMAMUX_REQUEST_I2C1_RX         16U   /*!< DMAMUX I2C1 RX request     */
S#define LL_DMAMUX_REQUEST_I2C1_TX         17U   /*!< DMAMUX I2C1 TX request     */
S#define LL_DMAMUX_REQUEST_I2C2_RX         18U   /*!< DMAMUX I2C2 RX request     */
S#define LL_DMAMUX_REQUEST_I2C2_TX         19U   /*!< DMAMUX I2C2 TX request     */
S#define LL_DMAMUX_REQUEST_I2C3_RX         20U   /*!< DMAMUX I2C3 RX request     */
S#define LL_DMAMUX_REQUEST_I2C3_TX         21U   /*!< DMAMUX I2C3 TX request     */
S#define LL_DMAMUX_REQUEST_I2C4_RX         22U   /*!< DMAMUX I2C4 RX request     */
S#define LL_DMAMUX_REQUEST_I2C4_TX         23U   /*!< DMAMUX I2C4 TX request     */
S#define LL_DMAMUX_REQUEST_USART1_RX       24U   /*!< DMAMUX USART1 RX request   */
S#define LL_DMAMUX_REQUEST_USART1_TX       25U   /*!< DMAMUX USART1 TX request   */
S#define LL_DMAMUX_REQUEST_USART2_RX       26U   /*!< DMAMUX USART2 RX request   */
S#define LL_DMAMUX_REQUEST_USART2_TX       27U   /*!< DMAMUX USART2 TX request   */
S#define LL_DMAMUX_REQUEST_USART3_RX       28U   /*!< DMAMUX USART3 RX request   */
S#define LL_DMAMUX_REQUEST_USART3_TX       29U   /*!< DMAMUX USART3 TX request   */
S#define LL_DMAMUX_REQUEST_UART4_RX        30U   /*!< DMAMUX UART4 RX request    */
S#define LL_DMAMUX_REQUEST_UART4_TX        31U   /*!< DMAMUX UART4 TX request    */
S#define LL_DMAMUX_REQUEST_UART5_RX        32U   /*!< DMAMUX UART5 RX request    */
S#define LL_DMAMUX_REQUEST_UART5_TX        33U   /*!< DMAMUX UART5 TX request    */
S#define LL_DMAMUX_REQUEST_LPUART1_RX      34U   /*!< DMAMUX LPUART1 RX request  */
S#define LL_DMAMUX_REQUEST_LPUART1_TX      35U   /*!< DMAMUX LPUART1 TX request  */
S#define LL_DMAMUX_REQUEST_SAI1_A          36U   /*!< DMAMUX SAI1 A request      */
S#define LL_DMAMUX_REQUEST_SAI1_B          37U   /*!< DMAMUX SAI1 B request      */
S#define LL_DMAMUX_REQUEST_SAI2_A          38U   /*!< DMAMUX SAI2 A request      */
S#define LL_DMAMUX_REQUEST_SAI2_B          39U   /*!< DMAMUX SAI2 B request      */
S#define LL_DMAMUX_REQUEST_OSPI1           40U   /*!< DMAMUX OCTOSPI1 request    */
S#define LL_DMAMUX_REQUEST_OSPI2           41U   /*!< DMAMUX OCTOSPI2 request    */
S#define LL_DMAMUX_REQUEST_TIM1_CH1        42U   /*!< DMAMUX TIM1 CH1 request    */
S#define LL_DMAMUX_REQUEST_TIM1_CH2        43U   /*!< DMAMUX TIM1 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM1_CH3        44U   /*!< DMAMUX TIM1 CH3 request    */
S#define LL_DMAMUX_REQUEST_TIM1_CH4        45U   /*!< DMAMUX TIM1 CH4 request    */
S#define LL_DMAMUX_REQUEST_TIM1_UP         46U   /*!< DMAMUX TIM1 UP request     */
S#define LL_DMAMUX_REQUEST_TIM1_TRIG       47U   /*!< DMAMUX TIM1 TRIG request   */
S#define LL_DMAMUX_REQUEST_TIM1_COM        48U   /*!< DMAMUX TIM1 COM request    */
S#define LL_DMAMUX_REQUEST_TIM8_CH1        49U   /*!< DMAMUX TIM8 CH1 request    */
S#define LL_DMAMUX_REQUEST_TIM8_CH2        50U   /*!< DMAMUX TIM8 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM8_CH3        51U   /*!< DMAMUX TIM8 CH3 request    */
S#define LL_DMAMUX_REQUEST_TIM8_CH4        52U   /*!< DMAMUX TIM8 CH4 request    */
S#define LL_DMAMUX_REQUEST_TIM8_UP         53U   /*!< DMAMUX TIM8 UP request     */
S#define LL_DMAMUX_REQUEST_TIM8_TRIG       54U   /*!< DMAMUX TIM8 TRIG request   */
S#define LL_DMAMUX_REQUEST_TIM8_COM        55U   /*!< DMAMUX TIM8 COM request    */
S#define LL_DMAMUX_REQUEST_TIM2_CH1        56U   /*!< DMAMUX TIM2 CH1 request    */
S#define LL_DMAMUX_REQUEST_TIM2_CH2        57U   /*!< DMAMUX TIM2 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM2_CH3        58U   /*!< DMAMUX TIM2 CH3 request    */
S#define LL_DMAMUX_REQUEST_TIM2_CH4        59U   /*!< DMAMUX TIM2 CH4 request    */
S#define LL_DMAMUX_REQUEST_TIM2_UP         60U   /*!< DMAMUX TIM2 UP request     */
S#define LL_DMAMUX_REQUEST_TIM3_CH1        61U   /*!< DMAMUX TIM3 CH1 request    */
S#define LL_DMAMUX_REQUEST_TIM3_CH2        62U   /*!< DMAMUX TIM3 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM3_CH3        63U   /*!< DMAMUX TIM3 CH3 request    */
S#define LL_DMAMUX_REQUEST_TIM3_CH4        64U   /*!< DMAMUX TIM3 CH4 request    */
S#define LL_DMAMUX_REQUEST_TIM3_UP         65U   /*!< DMAMUX TIM3 UP request     */
S#define LL_DMAMUX_REQUEST_TIM3_TRIG       66U   /*!< DMAMUX TIM3 TRIG request   */
S#define LL_DMAMUX_REQUEST_TIM4_CH1        67U   /*!< DMAMUX TIM4 CH1 request    */
S#define LL_DMAMUX_REQUEST_TIM4_CH2        68U   /*!< DMAMUX TIM4 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM4_CH3        69U   /*!< DMAMUX TIM4 CH3 request    */
S#define LL_DMAMUX_REQUEST_TIM4_CH4        70U   /*!< DMAMUX TIM4 CH4 request    */
S#define LL_DMAMUX_REQUEST_TIM4_UP         71U   /*!< DMAMUX TIM4 UP request     */
S#define LL_DMAMUX_REQUEST_TIM5_CH1        72U   /*!< DMAMUX TIM5 CH1 request    */
S#define LL_DMAMUX_REQUEST_TIM5_CH2        73U   /*!< DMAMUX TIM5 CH2 request    */
S#define LL_DMAMUX_REQUEST_TIM5_CH3        74U   /*!< DMAMUX TIM5 CH3 request    */
S#define LL_DMAMUX_REQUEST_TIM5_CH4        75U   /*!< DMAMUX TIM5 CH4 request    */
S#define LL_DMAMUX_REQUEST_TIM5_UP         76U   /*!< DMAMUX TIM5 UP request     */
S#define LL_DMAMUX_REQUEST_TIM5_TRIG       77U   /*!< DMAMUX TIM5 TRIG request   */
S#define LL_DMAMUX_REQUEST_TIM15_CH1       78U   /*!< DMAMUX TIM15 CH1 request   */
S#define LL_DMAMUX_REQUEST_TIM15_UP        79U   /*!< DMAMUX TIM15 UP request    */
S#define LL_DMAMUX_REQUEST_TIM15_TRIG      80U   /*!< DMAMUX TIM15 TRIG request  */
S#define LL_DMAMUX_REQUEST_TIM15_COM       81U   /*!< DMAMUX TIM15 COM request   */
S#define LL_DMAMUX_REQUEST_TIM16_CH1       82U   /*!< DMAMUX TIM16 CH1 request   */
S#define LL_DMAMUX_REQUEST_TIM16_UP        83U   /*!< DMAMUX TIM16 UP request    */
S#define LL_DMAMUX_REQUEST_TIM17_CH1       84U   /*!< DMAMUX TIM17 CH1 request   */
S#define LL_DMAMUX_REQUEST_TIM17_UP        85U   /*!< DMAMUX TIM17 UP request    */
S#define LL_DMAMUX_REQUEST_DFSDM1_FLT0     86U   /*!< DMAMUX DFSDM1_FLT0 request */
S#define LL_DMAMUX_REQUEST_DFSDM1_FLT1     87U   /*!< DMAMUX DFSDM1_FLT1 request */
S#define LL_DMAMUX_REQUEST_DFSDM1_FLT2     88U   /*!< DMAMUX DFSDM1_FLT2 request */
S#define LL_DMAMUX_REQUEST_DFSDM1_FLT3     89U   /*!< DMAMUX DFSDM1_FLT3 request */
S#define LL_DMAMUX_REQUEST_DCMI            90U   /*!< DMAMUX DCMI request        */
S#define LL_DMAMUX_REQUEST_AES_IN          91U   /*!< DMAMUX AES_IN request      */
S#define LL_DMAMUX_REQUEST_AES_OUT         92U   /*!< DMAMUX AES_OUT request     */
S#define LL_DMAMUX_REQUEST_HASH_IN         93U   /*!< DMAMUX HASH_IN request     */
S/**
S  * @}
S  */
N#else
N/** @defgroup DMA_LL_EC_REQUEST Transfer peripheral request
N  * @{
N  */
N#define LL_DMA_REQUEST_0                  0x00000000U /*!< DMA peripheral request 0  */
N#define LL_DMA_REQUEST_1                  0x00000001U /*!< DMA peripheral request 1  */
N#define LL_DMA_REQUEST_2                  0x00000002U /*!< DMA peripheral request 2  */
N#define LL_DMA_REQUEST_3                  0x00000003U /*!< DMA peripheral request 3  */
N#define LL_DMA_REQUEST_4                  0x00000004U /*!< DMA peripheral request 4  */
N#define LL_DMA_REQUEST_5                  0x00000005U /*!< DMA peripheral request 5  */
N#define LL_DMA_REQUEST_6                  0x00000006U /*!< DMA peripheral request 6  */
N#define LL_DMA_REQUEST_7                  0x00000007U /*!< DMA peripheral request 7  */
N/**
N  * @}
N  */
N#endif /* DMAMUX1 */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup DMA_LL_Exported_Macros DMA Exported Macros
N  * @{
N  */
N
N/** @defgroup DMA_LL_EM_WRITE_READ Common Write and read registers macros
N  * @{
N  */
N/**
N  * @brief  Write a value in DMA register
N  * @param  __INSTANCE__ DMA Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_DMA_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in DMA register
N  * @param  __INSTANCE__ DMA Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_DMA_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EM_CONVERT_DMAxCHANNELy Convert DMAxChannely
N  * @{
N  */
N/**
N  * @brief  Convert DMAx_Channely into DMAx
N  * @param  __CHANNEL_INSTANCE__ DMAx_Channely
N  * @retval DMAx
N  */
N#if defined(DMA2)
X#if 1L
N#define __LL_DMA_GET_INSTANCE(__CHANNEL_INSTANCE__)   \
N(((uint32_t)(__CHANNEL_INSTANCE__) > ((uint32_t)DMA1_Channel7)) ?  DMA2 : DMA1)
X#define __LL_DMA_GET_INSTANCE(__CHANNEL_INSTANCE__)   (((uint32_t)(__CHANNEL_INSTANCE__) > ((uint32_t)DMA1_Channel7)) ?  DMA2 : DMA1)
N#else
S#define __LL_DMA_GET_INSTANCE(__CHANNEL_INSTANCE__)  (DMA1)
N#endif
N
N/**
N  * @brief  Convert DMAx_Channely into LL_DMA_CHANNEL_y
N  * @param  __CHANNEL_INSTANCE__ DMAx_Channely
N  * @retval LL_DMA_CHANNEL_y
N  */
N#if defined (DMA2)
X#if 1L
N#if defined (DMA2_Channel6) && defined (DMA2_Channel7)
X#if 1L && 1L
N#define __LL_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   \
N(((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? LL_DMA_CHANNEL_1 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel1)) ? LL_DMA_CHANNEL_1 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? LL_DMA_CHANNEL_2 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel2)) ? LL_DMA_CHANNEL_2 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? LL_DMA_CHANNEL_3 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel3)) ? LL_DMA_CHANNEL_3 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? LL_DMA_CHANNEL_4 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel4)) ? LL_DMA_CHANNEL_4 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel5)) ? LL_DMA_CHANNEL_5 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel5)) ? LL_DMA_CHANNEL_5 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel6)) ? LL_DMA_CHANNEL_6 : \
N ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel6)) ? LL_DMA_CHANNEL_6 : \
N LL_DMA_CHANNEL_7)
X#define __LL_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   (((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? LL_DMA_CHANNEL_1 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel1)) ? LL_DMA_CHANNEL_1 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? LL_DMA_CHANNEL_2 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel2)) ? LL_DMA_CHANNEL_2 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? LL_DMA_CHANNEL_3 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel3)) ? LL_DMA_CHANNEL_3 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? LL_DMA_CHANNEL_4 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel4)) ? LL_DMA_CHANNEL_4 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel5)) ? LL_DMA_CHANNEL_5 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel5)) ? LL_DMA_CHANNEL_5 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel6)) ? LL_DMA_CHANNEL_6 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel6)) ? LL_DMA_CHANNEL_6 :  LL_DMA_CHANNEL_7)
N#else
S#define __LL_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   \
S(((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? LL_DMA_CHANNEL_1 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel1)) ? LL_DMA_CHANNEL_1 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? LL_DMA_CHANNEL_2 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel2)) ? LL_DMA_CHANNEL_2 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? LL_DMA_CHANNEL_3 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel3)) ? LL_DMA_CHANNEL_3 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? LL_DMA_CHANNEL_4 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel4)) ? LL_DMA_CHANNEL_4 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel5)) ? LL_DMA_CHANNEL_5 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel5)) ? LL_DMA_CHANNEL_5 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel6)) ? LL_DMA_CHANNEL_6 : \
S LL_DMA_CHANNEL_7)
X#define __LL_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   (((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? LL_DMA_CHANNEL_1 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel1)) ? LL_DMA_CHANNEL_1 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? LL_DMA_CHANNEL_2 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel2)) ? LL_DMA_CHANNEL_2 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? LL_DMA_CHANNEL_3 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel3)) ? LL_DMA_CHANNEL_3 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? LL_DMA_CHANNEL_4 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel4)) ? LL_DMA_CHANNEL_4 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel5)) ? LL_DMA_CHANNEL_5 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA2_Channel5)) ? LL_DMA_CHANNEL_5 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel6)) ? LL_DMA_CHANNEL_6 :  LL_DMA_CHANNEL_7)
N#endif
N#else
S#define __LL_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   \
S(((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? LL_DMA_CHANNEL_1 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? LL_DMA_CHANNEL_2 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? LL_DMA_CHANNEL_3 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? LL_DMA_CHANNEL_4 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel5)) ? LL_DMA_CHANNEL_5 : \
S ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel6)) ? LL_DMA_CHANNEL_6 : \
S LL_DMA_CHANNEL_7)
X#define __LL_DMA_GET_CHANNEL(__CHANNEL_INSTANCE__)   (((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel1)) ? LL_DMA_CHANNEL_1 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel2)) ? LL_DMA_CHANNEL_2 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel3)) ? LL_DMA_CHANNEL_3 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel4)) ? LL_DMA_CHANNEL_4 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel5)) ? LL_DMA_CHANNEL_5 :  ((uint32_t)(__CHANNEL_INSTANCE__) == ((uint32_t)DMA1_Channel6)) ? LL_DMA_CHANNEL_6 :  LL_DMA_CHANNEL_7)
N#endif
N
N/**
N  * @brief  Convert DMA Instance DMAx and LL_DMA_CHANNEL_y into DMAx_Channely
N  * @param  __DMA_INSTANCE__ DMAx
N  * @param  __CHANNEL__ LL_DMA_CHANNEL_y
N  * @retval DMAx_Channely
N  */
N#if defined (DMA2)
X#if 1L
N#if defined (DMA2_Channel6) && defined (DMA2_Channel7)
X#if 1L && 1L
N#define __LL_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   \
N((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA1_Channel1 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA2_Channel1 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA1_Channel2 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA2_Channel2 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA1_Channel3 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA2_Channel3 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA1_Channel4 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA2_Channel4 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA1_Channel5 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA2_Channel5 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA1_Channel6 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA2_Channel6 : \
N (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_7))) ? DMA1_Channel7 : \
N DMA2_Channel7)
X#define __LL_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   ((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA1_Channel1 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA2_Channel1 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA1_Channel2 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA2_Channel2 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA1_Channel3 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA2_Channel3 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA1_Channel4 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA2_Channel4 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA1_Channel5 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA2_Channel5 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA1_Channel6 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA2_Channel6 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_7))) ? DMA1_Channel7 :  DMA2_Channel7)
N#else
S#define __LL_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   \
S((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA1_Channel1 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA2_Channel1 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA1_Channel2 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA2_Channel2 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA1_Channel3 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA2_Channel3 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA1_Channel4 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA2_Channel4 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA1_Channel5 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA2_Channel5 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA1_Channel6 : \
S DMA1_Channel7)
X#define __LL_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   ((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA1_Channel1 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA2_Channel1 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA1_Channel2 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA2_Channel2 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA1_Channel3 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA2_Channel3 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA1_Channel4 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA2_Channel4 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA1_Channel5 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA2)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA2_Channel5 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA1_Channel6 :  DMA1_Channel7)
N#endif
N#else
S#define __LL_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   \
S((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA1_Channel1 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA1_Channel2 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA1_Channel3 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA1_Channel4 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA1_Channel5 : \
S (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA1_Channel6 : \
S DMA1_Channel7)
X#define __LL_DMA_GET_CHANNEL_INSTANCE(__DMA_INSTANCE__, __CHANNEL__)   ((((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_1))) ? DMA1_Channel1 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_2))) ? DMA1_Channel2 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_3))) ? DMA1_Channel3 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_4))) ? DMA1_Channel4 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_5))) ? DMA1_Channel5 :  (((uint32_t)(__DMA_INSTANCE__) == ((uint32_t)DMA1)) && ((uint32_t)(__CHANNEL__) == ((uint32_t)LL_DMA_CHANNEL_6))) ? DMA1_Channel6 :  DMA1_Channel7)
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup DMA_LL_Exported_Functions DMA Exported Functions
N * @{
N */
N
N/** @defgroup DMA_LL_EF_Configuration Configuration
N  * @{
N  */
N/**
N  * @brief  Enable DMA channel.
N  * @rmtoll CCR          EN            LL_DMA_EnableChannel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_EnableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_EnableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable DMA channel.
N  * @rmtoll CCR          EN            LL_DMA_DisableChannel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if DMA channel is enabled or disabled.
N  * @rmtoll CCR          EN            LL_DMA_IsEnabledChannel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsEnabledChannel(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_IsEnabledChannel(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_EN) == (DMA_CCR_EN));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Configure all parameters link to DMA transfer.
N  * @rmtoll CCR          DIR           LL_DMA_ConfigTransfer\n
N  *         CCR          MEM2MEM       LL_DMA_ConfigTransfer\n
N  *         CCR          CIRC          LL_DMA_ConfigTransfer\n
N  *         CCR          PINC          LL_DMA_ConfigTransfer\n
N  *         CCR          MINC          LL_DMA_ConfigTransfer\n
N  *         CCR          PSIZE         LL_DMA_ConfigTransfer\n
N  *         CCR          MSIZE         LL_DMA_ConfigTransfer\n
N  *         CCR          PL            LL_DMA_ConfigTransfer
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  Configuration This parameter must be a combination of all the following values:
N  *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY or @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH or @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
N  *         @arg @ref LL_DMA_MODE_NORMAL or @ref LL_DMA_MODE_CIRCULAR
N  *         @arg @ref LL_DMA_PERIPH_INCREMENT or @ref LL_DMA_PERIPH_NOINCREMENT
N  *         @arg @ref LL_DMA_MEMORY_INCREMENT or @ref LL_DMA_MEMORY_NOINCREMENT
N  *         @arg @ref LL_DMA_PDATAALIGN_BYTE or @ref LL_DMA_PDATAALIGN_HALFWORD or @ref LL_DMA_PDATAALIGN_WORD
N  *         @arg @ref LL_DMA_MDATAALIGN_BYTE or @ref LL_DMA_MDATAALIGN_HALFWORD or @ref LL_DMA_MDATAALIGN_WORD
N  *         @arg @ref LL_DMA_PRIORITY_LOW or @ref LL_DMA_PRIORITY_MEDIUM or @ref LL_DMA_PRIORITY_HIGH or @ref LL_DMA_PRIORITY_VERYHIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ConfigTransfer(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
Xstatic __inline void LL_DMA_ConfigTransfer(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N             DMA_CCR_DIR | DMA_CCR_MEM2MEM | DMA_CCR_CIRC | DMA_CCR_PINC | DMA_CCR_MINC | DMA_CCR_PSIZE | DMA_CCR_MSIZE | DMA_CCR_PL,
N             Configuration);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (4U)) | (0x1UL << (14U)) | (0x1UL << (5U)) | (0x1UL << (6U)) | (0x1UL << (7U)) | (0x3UL << (8U)) | (0x3UL << (10U)) | (0x3UL << (12U))))) | (Configuration))));
N}
N
N/**
N  * @brief  Set Data transfer direction (read from peripheral or from memory).
N  * @rmtoll CCR          DIR           LL_DMA_SetDataTransferDirection\n
N  *         CCR          MEM2MEM       LL_DMA_SetDataTransferDirection
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
N  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
N  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Direction)
Xstatic __inline void LL_DMA_SetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Direction)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N             DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (4U)) | (0x1UL << (14U))))) | (Direction))));
N}
N
N/**
N  * @brief  Get Data transfer direction (read from peripheral or from memory).
N  * @rmtoll CCR          DIR           LL_DMA_GetDataTransferDirection\n
N  *         CCR          MEM2MEM       LL_DMA_GetDataTransferDirection
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
N  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
N  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_DIR | DMA_CCR_MEM2MEM));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (4U)) | (0x1UL << (14U)))));
N}
N
N/**
N  * @brief  Set DMA mode circular or normal.
N  * @note The circular buffer mode cannot be used if the memory-to-memory
N  * data transfer is configured on the selected Channel.
N  * @rmtoll CCR          CIRC          LL_DMA_SetMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_MODE_NORMAL
N  *         @arg @ref LL_DMA_MODE_CIRCULAR
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
Xstatic __inline void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
N             Mode);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (5U))))) | (Mode))));
N}
N
N/**
N  * @brief  Get DMA mode circular or normal.
N  * @rmtoll CCR          CIRC          LL_DMA_GetMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_MODE_NORMAL
N  *         @arg @ref LL_DMA_MODE_CIRCULAR
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_CIRC));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Set Peripheral increment mode.
N  * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_PERIPH_INCREMENT
N  *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
Xstatic __inline void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
N             PeriphOrM2MSrcIncMode);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (6U))))) | (PeriphOrM2MSrcIncMode))));
N}
N
N/**
N  * @brief  Get Peripheral increment mode.
N  * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_PERIPH_INCREMENT
N  *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_PINC));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (6U)))));
N}
N
N/**
N  * @brief  Set Memory increment mode.
N  * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_MEMORY_INCREMENT
N  *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
Xstatic __inline void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
N             MemoryOrM2MDstIncMode);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x1UL << (7U))))) | (MemoryOrM2MDstIncMode))));
N}
N
N/**
N  * @brief  Get Memory increment mode.
N  * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_MEMORY_INCREMENT
N  *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_MINC));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Set Peripheral size.
N  * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_PDATAALIGN_BYTE
N  *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
N  *         @arg @ref LL_DMA_PDATAALIGN_WORD
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
Xstatic __inline void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
N             PeriphOrM2MSrcDataSize);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x3UL << (8U))))) | (PeriphOrM2MSrcDataSize))));
N}
N
N/**
N  * @brief  Get Peripheral size.
N  * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_PDATAALIGN_BYTE
N  *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
N  *         @arg @ref LL_DMA_PDATAALIGN_WORD
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_PSIZE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Set Memory size.
N  * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_MDATAALIGN_BYTE
N  *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
N  *         @arg @ref LL_DMA_MDATAALIGN_WORD
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
Xstatic __inline void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
N             MemoryOrM2MDstDataSize);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x3UL << (10U))))) | (MemoryOrM2MDstDataSize))));
N}
N
N/**
N  * @brief  Get Memory size.
N  * @rmtoll CCR          MSIZE         LL_DMA_GetMemorySize
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_MDATAALIGN_BYTE
N  *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
N  *         @arg @ref LL_DMA_MDATAALIGN_WORD
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_MSIZE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x3UL << (10U)))));
N}
N
N/**
N  * @brief  Set Channel priority level.
N  * @rmtoll CCR          PL            LL_DMA_SetChannelPriorityLevel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  Priority This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_PRIORITY_LOW
N  *         @arg @ref LL_DMA_PRIORITY_MEDIUM
N  *         @arg @ref LL_DMA_PRIORITY_HIGH
N  *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority)
Xstatic __inline void LL_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
N             Priority);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR))) & (~((0x3UL << (12U))))) | (Priority))));
N}
N
N/**
N  * @brief  Get Channel priority level.
N  * @rmtoll CCR          PL            LL_DMA_GetChannelPriorityLevel
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_PRIORITY_LOW
N  *         @arg @ref LL_DMA_PRIORITY_MEDIUM
N  *         @arg @ref LL_DMA_PRIORITY_HIGH
N  *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_PL));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x3UL << (12U)))));
N}
N
N/**
N  * @brief  Set Number of data to transfer.
N  * @note   This action has no effect if
N  *         channel is enabled.
N  * @rmtoll CNDTR        NDT           LL_DMA_SetDataLength
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
Xstatic __inline void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
N{
N  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
N             DMA_CNDTR_NDT, NbData);
X  (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR)) = ((((((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR))) & (~((0xFFFFUL << (0U))))) | (NbData))));
N}
N
N/**
N  * @brief  Get Number of data to transfer.
N  * @note   Once the channel is enabled, the return value indicate the
N  *         remaining bytes to be transmitted.
N  * @rmtoll CNDTR        NDT           LL_DMA_GetDataLength
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
N                   DMA_CNDTR_NDT));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Configure the Source and Destination addresses.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @note   Each IP using DMA provides an API to get directly the register adress (LL_PPP_DMA_GetRegAddr).
N  * @rmtoll CPAR         PA            LL_DMA_ConfigAddresses\n
N  *         CMAR         MA            LL_DMA_ConfigAddresses
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  SrcAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @param  DstAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
N  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
N  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
Xstatic __inline void LL_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
N                                            uint32_t DstAddress, uint32_t Direction)
N{
N  /* Direction Memory to Periph */
N  if (Direction == LL_DMA_DIRECTION_MEMORY_TO_PERIPH)
X  if (Direction == (0x1UL << (4U)))
N  {
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (SrcAddress));
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (DstAddress));
N  }
N  /* Direction Periph to Memory and Memory to Memory */
N  else
N  {
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (SrcAddress));
N    WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
X    ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (DstAddress));
N  }
N}
N
N/**
N  * @brief  Set the Memory address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CMAR         MA            LL_DMA_SetMemoryAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
Xstatic __inline void LL_DMA_SetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
N{
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (MemoryAddress));
N}
N
N/**
N  * @brief  Set the Peripheral address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CPAR         PA            LL_DMA_SetPeriphAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  PeriphAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
Xstatic __inline void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
N{
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, PeriphAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (PeriphAddress));
N}
N
N/**
N  * @brief  Get Memory address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @rmtoll CMAR         MA            LL_DMA_GetMemoryAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR)));
N}
N
N/**
N  * @brief  Get Peripheral address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
N  * @rmtoll CPAR         PA            LL_DMA_GetPeriphAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR)));
N}
N
N/**
N  * @brief  Set the Memory to Memory Source address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CPAR         PA            LL_DMA_SetM2MSrcAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
Xstatic __inline void LL_DMA_SetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
N{
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, MemoryAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR) = (MemoryAddress));
N}
N
N/**
N  * @brief  Set the Memory to Memory Destination address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @note   This API must not be called when the DMA channel is enabled.
N  * @rmtoll CMAR         MA            LL_DMA_SetM2MDstAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
Xstatic __inline void LL_DMA_SetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
N{
N  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR) = (MemoryAddress));
N}
N
N/**
N  * @brief  Get the Memory to Memory Source address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @rmtoll CPAR         PA            LL_DMA_GetM2MSrcAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR)));
N}
N
N/**
N  * @brief  Get the Memory to Memory Destination address.
N  * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
N  * @rmtoll CMAR         MA            LL_DMA_GetM2MDstAddress
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR)));
N}
N
N#if defined(DMAMUX1)
X#if 0L
S/**
S  * @brief  Set DMA request for DMA Channels on DMAMUX Channel x.
S  * @note   DMAMUX channel 0 to 6 are mapped to DMA1 channel 1 to 7.
S  *         DMAMUX channel 7 to 13 are mapped to DMA2 channel 1 to 7.
S  * @rmtoll CxCR         DMAREQ_ID     LL_DMA_SetPeriphRequest
S  * @param  DMAx DMAx Instance
S  * @param  Channel This parameter can be one of the following values:
S  *         @arg @ref LL_DMA_CHANNEL_1
S  *         @arg @ref LL_DMA_CHANNEL_2
S  *         @arg @ref LL_DMA_CHANNEL_3
S  *         @arg @ref LL_DMA_CHANNEL_4
S  *         @arg @ref LL_DMA_CHANNEL_5
S  *         @arg @ref LL_DMA_CHANNEL_6
S  *         @arg @ref LL_DMA_CHANNEL_7
S  * @param  Request This parameter can be one of the following values:
S  *         @arg @ref LL_DMAMUX_REQUEST_MEM2MEM
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR0
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR1
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR2
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR3
S  *         @arg @ref LL_DMAMUX_REQUEST_ADC1
S  *         @arg @ref LL_DMAMUX_REQUEST_DAC1_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_DAC1_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM6_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM7_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI2_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI2_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI3_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI3_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C2_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C2_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C3_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C3_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C4_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C4_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART2_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART2_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART3_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART3_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART4_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART4_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART5_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART5_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_LPUART1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_LPUART1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI1_A
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI1_B
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI2_A
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI2_B
S  *         @arg @ref LL_DMAMUX_REQUEST_OSPI1
S  *         @arg @ref LL_DMAMUX_REQUEST_OSPI2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_COM
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_COM
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_COM
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM16_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM16_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM17_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM17_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT0
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT1
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT2
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT3
S  *         @arg @ref LL_DMAMUX_REQUEST_DCMI
S  *         @arg @ref LL_DMAMUX_REQUEST_AES_IN
S  *         @arg @ref LL_DMAMUX_REQUEST_AES_OUT
S  *         @arg @ref LL_DMAMUX_REQUEST_HASH_IN
S  * @retval None
S  */
S__STATIC_INLINE void LL_DMA_SetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Request)
S{
S  MODIFY_REG(((DMAMUX_Channel_TypeDef*)(uint32_t)((uint32_t)DMAMUX1_Channel0 + (DMAMUX_CCR_SIZE*(Channel-1U)) + (uint32_t)(DMAMUX_CCR_SIZE*__LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(DMAx))))->CCR, DMAMUX_CxCR_DMAREQ_ID, Request);
S}
S
S/**
S  * @brief  Get DMA request for DMA Channels on DMAMUX Channel x.
S  * @note   DMAMUX channel 0 to 6 are mapped to DMA1 channel 1 to 7.
S  *         DMAMUX channel 7 to 13 are mapped to DMA2 channel 1 to 7.
S  * @rmtoll CxCR         DMAREQ_ID     LL_DMA_GetPeriphRequest
S  * @param  DMAx DMAx Instance
S  * @param  Channel This parameter can be one of the following values:
S  *         @arg @ref LL_DMA_CHANNEL_1
S  *         @arg @ref LL_DMA_CHANNEL_2
S  *         @arg @ref LL_DMA_CHANNEL_3
S  *         @arg @ref LL_DMA_CHANNEL_4
S  *         @arg @ref LL_DMA_CHANNEL_5
S  *         @arg @ref LL_DMA_CHANNEL_6
S  *         @arg @ref LL_DMA_CHANNEL_7
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_DMAMUX_REQUEST_MEM2MEM
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR0
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR1
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR2
S  *         @arg @ref LL_DMAMUX_REQUEST_GENERATOR3
S  *         @arg @ref LL_DMAMUX_REQUEST_ADC1
S  *         @arg @ref LL_DMAMUX_REQUEST_DAC1_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_DAC1_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM6_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM7_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI2_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI2_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI3_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_SPI3_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C2_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C2_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C3_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C3_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C4_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_I2C4_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART2_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART2_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART3_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_USART3_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART4_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART4_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART5_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_UART5_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_LPUART1_RX
S  *         @arg @ref LL_DMAMUX_REQUEST_LPUART1_TX
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI1_A
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI1_B
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI2_A
S  *         @arg @ref LL_DMAMUX_REQUEST_SAI2_B
S  *         @arg @ref LL_DMAMUX_REQUEST_OSPI1
S  *         @arg @ref LL_DMAMUX_REQUEST_OSPI2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM1_COM
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM8_COM
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM2_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM3_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM4_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH2
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH3
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_CH4
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM5_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_TRIG
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM15_COM
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM16_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM16_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM17_CH1
S  *         @arg @ref LL_DMAMUX_REQUEST_TIM17_UP
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT0
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT1
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT2
S  *         @arg @ref LL_DMAMUX_REQUEST_DFSDM1_FLT3
S  *         @arg @ref LL_DMAMUX_REQUEST_DCMI
S  *         @arg @ref LL_DMAMUX_REQUEST_AES_IN
S  *         @arg @ref LL_DMAMUX_REQUEST_AES_OUT
S  *         @arg @ref LL_DMAMUX_REQUEST_HASH_IN
S  */
S__STATIC_INLINE uint32_t LL_DMA_GetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Channel)
S{
S  return (READ_BIT(((DMAMUX_Channel_TypeDef*)((uint32_t)((uint32_t)DMAMUX1_Channel0 + (DMAMUX_CCR_SIZE*(Channel-1U)) + (uint32_t)(DMAMUX_CCR_SIZE*__LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(DMAx)))))->CCR, DMAMUX_CxCR_DMAREQ_ID));
S}
N#else
N/**
N  * @brief  Set DMA request for DMA instance on Channel x.
N  * @note   Please refer to Reference Manual to get the available mapping of Request value link to Channel Selection.
N  * @rmtoll CSELR        C1S           LL_DMA_SetPeriphRequest\n
N  *         CSELR        C2S           LL_DMA_SetPeriphRequest\n
N  *         CSELR        C3S           LL_DMA_SetPeriphRequest\n
N  *         CSELR        C4S           LL_DMA_SetPeriphRequest\n
N  *         CSELR        C5S           LL_DMA_SetPeriphRequest\n
N  *         CSELR        C6S           LL_DMA_SetPeriphRequest\n
N  *         CSELR        C7S           LL_DMA_SetPeriphRequest
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @param  PeriphRequest This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_REQUEST_0
N  *         @arg @ref LL_DMA_REQUEST_1
N  *         @arg @ref LL_DMA_REQUEST_2
N  *         @arg @ref LL_DMA_REQUEST_3
N  *         @arg @ref LL_DMA_REQUEST_4
N  *         @arg @ref LL_DMA_REQUEST_5
N  *         @arg @ref LL_DMA_REQUEST_6
N  *         @arg @ref LL_DMA_REQUEST_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_SetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphRequest)
Xstatic __inline void LL_DMA_SetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphRequest)
N{
N  MODIFY_REG(((DMA_Request_TypeDef *)((uint32_t)((uint32_t)DMAx + DMA_CSELR_OFFSET)))->CSELR,
N             DMA_CSELR_C1S << ((Channel - 1U) * 4U), PeriphRequest << DMA_POSITION_CSELR_CXS);
X  (((((DMA_Request_TypeDef *)((uint32_t)((uint32_t)DMAx + (uint32_t)(((((0x40000000UL) + 0x00020000UL)) + 0x00A8UL) - (((0x40000000UL) + 0x00020000UL))))))->CSELR)) = ((((((((DMA_Request_TypeDef *)((uint32_t)((uint32_t)DMAx + (uint32_t)(((((0x40000000UL) + 0x00020000UL)) + 0x00A8UL) - (((0x40000000UL) + 0x00020000UL))))))->CSELR))) & (~((0xFUL << (0U)) << ((Channel - 1U) * 4U)))) | (PeriphRequest << (__clz(__rbit((0xFUL << (0U)) << ((Channel-1U)*4U))))))));
N}
N
N/**
N  * @brief  Get DMA request for DMA instance on Channel x.
N  * @rmtoll CSELR        C1S           LL_DMA_GetPeriphRequest\n
N  *         CSELR        C2S           LL_DMA_GetPeriphRequest\n
N  *         CSELR        C3S           LL_DMA_GetPeriphRequest\n
N  *         CSELR        C4S           LL_DMA_GetPeriphRequest\n
N  *         CSELR        C5S           LL_DMA_GetPeriphRequest\n
N  *         CSELR        C6S           LL_DMA_GetPeriphRequest\n
N  *         CSELR        C7S           LL_DMA_GetPeriphRequest
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_DMA_REQUEST_0
N  *         @arg @ref LL_DMA_REQUEST_1
N  *         @arg @ref LL_DMA_REQUEST_2
N  *         @arg @ref LL_DMA_REQUEST_3
N  *         @arg @ref LL_DMA_REQUEST_4
N  *         @arg @ref LL_DMA_REQUEST_5
N  *         @arg @ref LL_DMA_REQUEST_6
N  *         @arg @ref LL_DMA_REQUEST_7
N  */
N__STATIC_INLINE uint32_t LL_DMA_GetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_GetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Request_TypeDef *)((uint32_t)((uint32_t)DMAx + DMA_CSELR_OFFSET)))->CSELR,
N                   DMA_CSELR_C1S << ((Channel - 1U) * 4U)) >> DMA_POSITION_CSELR_CXS);
X  return (((((DMA_Request_TypeDef *)((uint32_t)((uint32_t)DMAx + (uint32_t)(((((0x40000000UL) + 0x00020000UL)) + 0x00A8UL) - (((0x40000000UL) + 0x00020000UL))))))->CSELR) & ((0xFUL << (0U)) << ((Channel - 1U) * 4U))) >> (__clz(__rbit((0xFUL << (0U)) << ((Channel-1U)*4U)))));
N}
N#endif /* DMAMUX1 */
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EF_FLAG_Management FLAG_Management
N  * @{
N  */
N
N/**
N  * @brief  Get Channel 1 global interrupt flag.
N  * @rmtoll ISR          GIF1          LL_DMA_IsActiveFlag_GI1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI1(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI1(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF1) == (DMA_ISR_GIF1));
X  return (((DMAx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get Channel 2 global interrupt flag.
N  * @rmtoll ISR          GIF2          LL_DMA_IsActiveFlag_GI2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI2(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI2(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF2) == (DMA_ISR_GIF2));
X  return (((DMAx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get Channel 3 global interrupt flag.
N  * @rmtoll ISR          GIF3          LL_DMA_IsActiveFlag_GI3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI3(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI3(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF3) == (DMA_ISR_GIF3));
X  return (((DMAx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Get Channel 4 global interrupt flag.
N  * @rmtoll ISR          GIF4          LL_DMA_IsActiveFlag_GI4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI4(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI4(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF4) == (DMA_ISR_GIF4));
X  return (((DMAx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Get Channel 5 global interrupt flag.
N  * @rmtoll ISR          GIF5          LL_DMA_IsActiveFlag_GI5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI5(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI5(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF5) == (DMA_ISR_GIF5));
X  return (((DMAx->ISR) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Get Channel 6 global interrupt flag.
N  * @rmtoll ISR          GIF6          LL_DMA_IsActiveFlag_GI6
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI6(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI6(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF6) == (DMA_ISR_GIF6));
X  return (((DMAx->ISR) & ((0x1UL << (20U)))) == ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Get Channel 7 global interrupt flag.
N  * @rmtoll ISR          GIF7          LL_DMA_IsActiveFlag_GI7
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI7(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_GI7(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_GIF7) == (DMA_ISR_GIF7));
X  return (((DMAx->ISR) & ((0x1UL << (24U)))) == ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Get Channel 1 transfer complete flag.
N  * @rmtoll ISR          TCIF1         LL_DMA_IsActiveFlag_TC1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC1(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC1(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF1) == (DMA_ISR_TCIF1));
X  return (((DMAx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get Channel 2 transfer complete flag.
N  * @rmtoll ISR          TCIF2         LL_DMA_IsActiveFlag_TC2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC2(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC2(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF2) == (DMA_ISR_TCIF2));
X  return (((DMAx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Get Channel 3 transfer complete flag.
N  * @rmtoll ISR          TCIF3         LL_DMA_IsActiveFlag_TC3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC3(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC3(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF3) == (DMA_ISR_TCIF3));
X  return (((DMAx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Get Channel 4 transfer complete flag.
N  * @rmtoll ISR          TCIF4         LL_DMA_IsActiveFlag_TC4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC4(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC4(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
X  return (((DMAx->ISR) & ((0x1UL << (13U)))) == ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Get Channel 5 transfer complete flag.
N  * @rmtoll ISR          TCIF5         LL_DMA_IsActiveFlag_TC5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC5(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC5(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF5) == (DMA_ISR_TCIF5));
X  return (((DMAx->ISR) & ((0x1UL << (17U)))) == ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Get Channel 6 transfer complete flag.
N  * @rmtoll ISR          TCIF6         LL_DMA_IsActiveFlag_TC6
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC6(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC6(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF6) == (DMA_ISR_TCIF6));
X  return (((DMAx->ISR) & ((0x1UL << (21U)))) == ((0x1UL << (21U))));
N}
N
N/**
N  * @brief  Get Channel 7 transfer complete flag.
N  * @rmtoll ISR          TCIF7         LL_DMA_IsActiveFlag_TC7
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC7(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TC7(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF7) == (DMA_ISR_TCIF7));
X  return (((DMAx->ISR) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Get Channel 1 half transfer flag.
N  * @rmtoll ISR          HTIF1         LL_DMA_IsActiveFlag_HT1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT1(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT1(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF1) == (DMA_ISR_HTIF1));
X  return (((DMAx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get Channel 2 half transfer flag.
N  * @rmtoll ISR          HTIF2         LL_DMA_IsActiveFlag_HT2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT2(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT2(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF2) == (DMA_ISR_HTIF2));
X  return (((DMAx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Get Channel 3 half transfer flag.
N  * @rmtoll ISR          HTIF3         LL_DMA_IsActiveFlag_HT3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT3(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT3(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF3) == (DMA_ISR_HTIF3));
X  return (((DMAx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Get Channel 4 half transfer flag.
N  * @rmtoll ISR          HTIF4         LL_DMA_IsActiveFlag_HT4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT4(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT4(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF4) == (DMA_ISR_HTIF4));
X  return (((DMAx->ISR) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Get Channel 5 half transfer flag.
N  * @rmtoll ISR          HTIF5         LL_DMA_IsActiveFlag_HT5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT5(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT5(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF5) == (DMA_ISR_HTIF5));
X  return (((DMAx->ISR) & ((0x1UL << (18U)))) == ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Get Channel 6 half transfer flag.
N  * @rmtoll ISR          HTIF6         LL_DMA_IsActiveFlag_HT6
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT6(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT6(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF6) == (DMA_ISR_HTIF6));
X  return (((DMAx->ISR) & ((0x1UL << (22U)))) == ((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Get Channel 7 half transfer flag.
N  * @rmtoll ISR          HTIF7         LL_DMA_IsActiveFlag_HT7
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT7(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_HT7(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF7) == (DMA_ISR_HTIF7));
X  return (((DMAx->ISR) & ((0x1UL << (26U)))) == ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Get Channel 1 transfer error flag.
N  * @rmtoll ISR          TEIF1         LL_DMA_IsActiveFlag_TE1
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE1(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE1(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF1) == (DMA_ISR_TEIF1));
X  return (((DMAx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get Channel 2 transfer error flag.
N  * @rmtoll ISR          TEIF2         LL_DMA_IsActiveFlag_TE2
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE2(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE2(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF2) == (DMA_ISR_TEIF2));
X  return (((DMAx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Get Channel 3 transfer error flag.
N  * @rmtoll ISR          TEIF3         LL_DMA_IsActiveFlag_TE3
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE3(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE3(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF3) == (DMA_ISR_TEIF3));
X  return (((DMAx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Get Channel 4 transfer error flag.
N  * @rmtoll ISR          TEIF4         LL_DMA_IsActiveFlag_TE4
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE4(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE4(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
X  return (((DMAx->ISR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Get Channel 5 transfer error flag.
N  * @rmtoll ISR          TEIF5         LL_DMA_IsActiveFlag_TE5
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE5(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE5(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF5) == (DMA_ISR_TEIF5));
X  return (((DMAx->ISR) & ((0x1UL << (19U)))) == ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Get Channel 6 transfer error flag.
N  * @rmtoll ISR          TEIF6         LL_DMA_IsActiveFlag_TE6
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE6(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE6(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF6) == (DMA_ISR_TEIF6));
X  return (((DMAx->ISR) & ((0x1UL << (23U)))) == ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Get Channel 7 transfer error flag.
N  * @rmtoll ISR          TEIF7         LL_DMA_IsActiveFlag_TE7
N  * @param  DMAx DMAx Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE7(DMA_TypeDef *DMAx)
Xstatic __inline uint32_t LL_DMA_IsActiveFlag_TE7(DMA_TypeDef *DMAx)
N{
N  return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF7) == (DMA_ISR_TEIF7));
X  return (((DMAx->ISR) & ((0x1UL << (27U)))) == ((0x1UL << (27U))));
N}
N
N/**
N  * @brief  Clear Channel 1 global interrupt flag.
N  * @rmtoll IFCR         CGIF1         LL_DMA_ClearFlag_GI1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI1(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI1(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF1);
X  ((DMAx->IFCR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Channel 2 global interrupt flag.
N  * @rmtoll IFCR         CGIF2         LL_DMA_ClearFlag_GI2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI2(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI2(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF2);
X  ((DMAx->IFCR) = ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear Channel 3 global interrupt flag.
N  * @rmtoll IFCR         CGIF3         LL_DMA_ClearFlag_GI3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI3(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI3(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF3);
X  ((DMAx->IFCR) = ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear Channel 4 global interrupt flag.
N  * @rmtoll IFCR         CGIF4         LL_DMA_ClearFlag_GI4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI4(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI4(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
X  ((DMAx->IFCR) = ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Clear Channel 5 global interrupt flag.
N  * @rmtoll IFCR         CGIF5         LL_DMA_ClearFlag_GI5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI5(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI5(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF5);
X  ((DMAx->IFCR) = ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Clear Channel 6 global interrupt flag.
N  * @rmtoll IFCR         CGIF6         LL_DMA_ClearFlag_GI6
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI6(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI6(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF6);
X  ((DMAx->IFCR) = ((0x1UL << (20U))));
N}
N
N/**
N  * @brief  Clear Channel 7 global interrupt flag.
N  * @rmtoll IFCR         CGIF7         LL_DMA_ClearFlag_GI7
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_GI7(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_GI7(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF7);
X  ((DMAx->IFCR) = ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Clear Channel 1  transfer complete flag.
N  * @rmtoll IFCR         CTCIF1        LL_DMA_ClearFlag_TC1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC1(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC1(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF1);
X  ((DMAx->IFCR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear Channel 2  transfer complete flag.
N  * @rmtoll IFCR         CTCIF2        LL_DMA_ClearFlag_TC2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC2(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC2(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF2);
X  ((DMAx->IFCR) = ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Clear Channel 3  transfer complete flag.
N  * @rmtoll IFCR         CTCIF3        LL_DMA_ClearFlag_TC3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC3(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC3(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF3);
X  ((DMAx->IFCR) = ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear Channel 4  transfer complete flag.
N  * @rmtoll IFCR         CTCIF4        LL_DMA_ClearFlag_TC4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC4(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC4(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF4);
X  ((DMAx->IFCR) = ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Clear Channel 5  transfer complete flag.
N  * @rmtoll IFCR         CTCIF5        LL_DMA_ClearFlag_TC5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC5(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC5(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF5);
X  ((DMAx->IFCR) = ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Clear Channel 6  transfer complete flag.
N  * @rmtoll IFCR         CTCIF6        LL_DMA_ClearFlag_TC6
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC6(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC6(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF6);
X  ((DMAx->IFCR) = ((0x1UL << (21U))));
N}
N
N/**
N  * @brief  Clear Channel 7  transfer complete flag.
N  * @rmtoll IFCR         CTCIF7        LL_DMA_ClearFlag_TC7
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TC7(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TC7(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF7);
X  ((DMAx->IFCR) = ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Clear Channel 1  half transfer flag.
N  * @rmtoll IFCR         CHTIF1        LL_DMA_ClearFlag_HT1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT1(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT1(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF1);
X  ((DMAx->IFCR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear Channel 2  half transfer flag.
N  * @rmtoll IFCR         CHTIF2        LL_DMA_ClearFlag_HT2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT2(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT2(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF2);
X  ((DMAx->IFCR) = ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Clear Channel 3  half transfer flag.
N  * @rmtoll IFCR         CHTIF3        LL_DMA_ClearFlag_HT3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT3(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT3(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF3);
X  ((DMAx->IFCR) = ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Clear Channel 4  half transfer flag.
N  * @rmtoll IFCR         CHTIF4        LL_DMA_ClearFlag_HT4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT4(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT4(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF4);
X  ((DMAx->IFCR) = ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Clear Channel 5  half transfer flag.
N  * @rmtoll IFCR         CHTIF5        LL_DMA_ClearFlag_HT5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT5(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT5(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF5);
X  ((DMAx->IFCR) = ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Clear Channel 6  half transfer flag.
N  * @rmtoll IFCR         CHTIF6        LL_DMA_ClearFlag_HT6
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT6(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT6(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF6);
X  ((DMAx->IFCR) = ((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Clear Channel 7  half transfer flag.
N  * @rmtoll IFCR         CHTIF7        LL_DMA_ClearFlag_HT7
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_HT7(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_HT7(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF7);
X  ((DMAx->IFCR) = ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Clear Channel 1 transfer error flag.
N  * @rmtoll IFCR         CTEIF1        LL_DMA_ClearFlag_TE1
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE1(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE1(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF1);
X  ((DMAx->IFCR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear Channel 2 transfer error flag.
N  * @rmtoll IFCR         CTEIF2        LL_DMA_ClearFlag_TE2
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE2(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE2(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF2);
X  ((DMAx->IFCR) = ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Clear Channel 3 transfer error flag.
N  * @rmtoll IFCR         CTEIF3        LL_DMA_ClearFlag_TE3
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE3(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE3(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF3);
X  ((DMAx->IFCR) = ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Clear Channel 4 transfer error flag.
N  * @rmtoll IFCR         CTEIF4        LL_DMA_ClearFlag_TE4
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE4(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE4(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF4);
X  ((DMAx->IFCR) = ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Clear Channel 5 transfer error flag.
N  * @rmtoll IFCR         CTEIF5        LL_DMA_ClearFlag_TE5
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE5(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE5(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF5);
X  ((DMAx->IFCR) = ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Clear Channel 6 transfer error flag.
N  * @rmtoll IFCR         CTEIF6        LL_DMA_ClearFlag_TE6
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE6(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE6(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF6);
X  ((DMAx->IFCR) = ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Clear Channel 7 transfer error flag.
N  * @rmtoll IFCR         CTEIF7        LL_DMA_ClearFlag_TE7
N  * @param  DMAx DMAx Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_ClearFlag_TE7(DMA_TypeDef *DMAx)
Xstatic __inline void LL_DMA_ClearFlag_TE7(DMA_TypeDef *DMAx)
N{
N  WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF7);
X  ((DMAx->IFCR) = ((0x1UL << (27U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_LL_EF_IT_Management IT_Management
N  * @{
N  */
N/**
N  * @brief  Enable Transfer complete interrupt.
N  * @rmtoll CCR          TCIE          LL_DMA_EnableIT_TC
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TCIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable Half transfer interrupt.
N  * @rmtoll CCR          HTIE          LL_DMA_EnableIT_HT
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_EnableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_EnableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_HTIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable Transfer error interrupt.
N  * @rmtoll CCR          TEIE          LL_DMA_EnableIT_TE
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_EnableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_EnableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TEIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable Transfer complete interrupt.
N  * @rmtoll CCR          TCIE          LL_DMA_DisableIT_TC
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_DisableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_DisableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TCIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable Half transfer interrupt.
N  * @rmtoll CCR          HTIE          LL_DMA_DisableIT_HT
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_DisableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_DisableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_HTIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable Transfer error interrupt.
N  * @rmtoll CCR          TEIE          LL_DMA_DisableIT_TE
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval None
N  */
N__STATIC_INLINE void LL_DMA_DisableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline void LL_DMA_DisableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TEIE);
X  ((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if Transfer complete Interrupt is enabled.
N  * @rmtoll CCR          TCIE          LL_DMA_IsEnabledIT_TC
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsEnabledIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_IsEnabledIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_TCIE) == (DMA_CCR_TCIE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if Half transfer Interrupt is enabled.
N  * @rmtoll CCR          HTIE          LL_DMA_IsEnabledIT_HT
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsEnabledIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_IsEnabledIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_HTIE) == (DMA_CCR_HTIE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if Transfer error Interrupt is enabled.
N  * @rmtoll CCR          TEIE          LL_DMA_IsEnabledIT_TE
N  * @param  DMAx DMAx Instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_DMA_CHANNEL_1
N  *         @arg @ref LL_DMA_CHANNEL_2
N  *         @arg @ref LL_DMA_CHANNEL_3
N  *         @arg @ref LL_DMA_CHANNEL_4
N  *         @arg @ref LL_DMA_CHANNEL_5
N  *         @arg @ref LL_DMA_CHANNEL_6
N  *         @arg @ref LL_DMA_CHANNEL_7
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_DMA_IsEnabledIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
Xstatic __inline uint32_t LL_DMA_IsEnabledIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
N{
N  return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
N                   DMA_CCR_TEIE) == (DMA_CCR_TEIE));
X  return (((((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup DMA_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
Nuint32_t LL_DMA_Init(DMA_TypeDef *DMAx, uint32_t Channel, LL_DMA_InitTypeDef *DMA_InitStruct);
Nuint32_t LL_DMA_DeInit(DMA_TypeDef *DMAx, uint32_t Channel);
Nvoid LL_DMA_StructInit(LL_DMA_InitTypeDef *DMA_InitStruct);
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* DMA1 || DMA2 */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_DMA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 15 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_tim.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_tim.h
N  * @author  MCD Application Team
N  * @brief   Header file of TIM LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_TIM_H
N#define __STM32L4xx_LL_TIM_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (TIM1) || defined (TIM8) || defined (TIM2) || defined (TIM3) ||  defined (TIM4) || defined (TIM5) || defined (TIM15) || defined (TIM16) || defined (TIM17) || defined (TIM6) || defined (TIM7)
X#if 1L || 0L || 1L || 0L ||  0L || 0L || 1L || 1L || 0L || 1L || 1L
N
N/** @defgroup TIM_LL TIM
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup TIM_LL_Private_Variables TIM Private Variables
N  * @{
N  */
Nstatic const uint8_t OFFSET_TAB_CCMRx[] =
N{
N  0x00U,   /* 0: TIMx_CH1  */
N  0x00U,   /* 1: TIMx_CH1N */
N  0x00U,   /* 2: TIMx_CH2  */
N  0x00U,   /* 3: TIMx_CH2N */
N  0x04U,   /* 4: TIMx_CH3  */
N  0x04U,   /* 5: TIMx_CH3N */
N  0x04U,   /* 6: TIMx_CH4  */
N  0x3CU,   /* 7: TIMx_CH5  */
N  0x3CU    /* 8: TIMx_CH6  */
N};
N
Nstatic const uint8_t SHIFT_TAB_OCxx[] =
N{
N  0U,            /* 0: OC1M, OC1FE, OC1PE */
N  0U,            /* 1: - NA */
N  8U,            /* 2: OC2M, OC2FE, OC2PE */
N  0U,            /* 3: - NA */
N  0U,            /* 4: OC3M, OC3FE, OC3PE */
N  0U,            /* 5: - NA */
N  8U,            /* 6: OC4M, OC4FE, OC4PE */
N  0U,            /* 7: OC5M, OC5FE, OC5PE */
N  8U             /* 8: OC6M, OC6FE, OC6PE */
N};
N
Nstatic const uint8_t SHIFT_TAB_ICxx[] =
N{
N  0U,            /* 0: CC1S, IC1PSC, IC1F */
N  0U,            /* 1: - NA */
N  8U,            /* 2: CC2S, IC2PSC, IC2F */
N  0U,            /* 3: - NA */
N  0U,            /* 4: CC3S, IC3PSC, IC3F */
N  0U,            /* 5: - NA */
N  8U,            /* 6: CC4S, IC4PSC, IC4F */
N  0U,            /* 7: - NA */
N  0U             /* 8: - NA */
N};
N
Nstatic const uint8_t SHIFT_TAB_CCxP[] =
N{
N  0U,            /* 0: CC1P */
N  2U,            /* 1: CC1NP */
N  4U,            /* 2: CC2P */
N  6U,            /* 3: CC2NP */
N  8U,            /* 4: CC3P */
N  10U,           /* 5: CC3NP */
N  12U,           /* 6: CC4P */
N  16U,           /* 7: CC5P */
N  20U            /* 8: CC6P */
N};
N
Nstatic const uint8_t SHIFT_TAB_OISx[] =
N{
N  0U,            /* 0: OIS1 */
N  1U,            /* 1: OIS1N */
N  2U,            /* 2: OIS2 */
N  3U,            /* 3: OIS2N */
N  4U,            /* 4: OIS3 */
N  5U,            /* 5: OIS3N */
N  6U,            /* 6: OIS4 */
N  8U,            /* 7: OIS5 */
N  10U            /* 8: OIS6 */
N};
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup TIM_LL_Private_Constants TIM Private Constants
N  * @{
N  */
N
N/* Defines used for the bit position in the register and perform offsets */
N#define TIM_POSITION_BRK_SOURCE            (POSITION_VAL(Source) & 0x1FU)
N
N/* Generic bit definitions for TIMx_OR2 register */
N#define TIMx_OR2_BKINE     TIM1_OR2_BKINE     /*!< BRK BKIN input enable */
N#define TIMx_OR2_BKCOMP1E  TIM1_OR2_BKCMP1E   /*!< BRK COMP1 enable */
N#define TIMx_OR2_BKCOMP2E  TIM1_OR2_BKCMP2E   /*!< BRK COMP2 enable */
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define TIMx_OR2_BKDF1BK0E TIM1_OR2_BKDF1BK0E /*!< BRK DFSDM1_BREAK[0] enable */
N#endif /* DFSDM1_Channel0 */
N#define TIMx_OR2_BKINP     TIM1_OR2_BKINP     /*!< BRK BKIN input polarity */
N#define TIMx_OR2_BKCOMP1P  TIM1_OR2_BKCMP1P   /*!< BRK COMP1 input polarity */
N#define TIMx_OR2_BKCOMP2P  TIM1_OR2_BKCMP2P   /*!< BRK COMP2 input polarity */
N#define TIMx_OR2_ETRSEL    TIM1_OR2_ETRSEL    /*!< TIMx ETR source selection */
N
N/* Generic bit definitions for TIMx_OR3 register */
N#define TIMx_OR3_BK2INE    TIM1_OR3_BK2INE      /*!< BRK2 BKIN2 input enable */
N#define TIMx_OR3_BK2COMP1E TIM1_OR3_BK2CMP1E    /*!< BRK2 COMP1 enable */
N#define TIMx_OR3_BK2COMP2E TIM1_OR3_BK2CMP2E    /*!< BRK2 COMP2 enable */
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define TIMx_OR3_BK2DF1BK1E TIM1_OR3_BK2DF1BK1E /*!< BRK2 DFSDM1_BREAK[1] enable */
N#endif /* DFSDM1_Channel0 */
N#define TIMx_OR3_BK2INP    TIM1_OR3_BK2INP      /*!< BRK2 BKIN2 input polarity */
N#define TIMx_OR3_BK2COMP1P TIM1_OR3_BK2CMP1P    /*!< BRK2 COMP1 input polarity */
N#define TIMx_OR3_BK2COMP2P TIM1_OR3_BK2CMP2P    /*!< BRK2 COMP2 input polarity */
N
N/* Remap mask definitions */
N#define TIMx_OR1_RMP_SHIFT 16U
N#define TIMx_OR1_RMP_MASK  0x0000FFFFU
N#if defined(ADC3)
X#if 0L
S#define TIM1_OR1_RMP_MASK  ((TIM1_OR1_ETR_ADC1_RMP | TIM1_OR1_ETR_ADC3_RMP | TIM1_OR1_TI1_RMP) << TIMx_OR1_RMP_SHIFT)
N#else
N#define TIM1_OR1_RMP_MASK  ((TIM1_OR1_ETR_ADC1_RMP | TIM1_OR1_TI1_RMP) << TIMx_OR1_RMP_SHIFT)
N#endif /* ADC3 */
N#define TIM2_OR1_RMP_MASK  ((TIM2_OR1_TI4_RMP | TIM2_OR1_ETR1_RMP | TIM2_OR1_ITR1_RMP) << TIMx_OR1_RMP_SHIFT)
N#define TIM3_OR1_RMP_MASK  (TIM3_OR1_TI1_RMP << TIMx_OR1_RMP_SHIFT)
N#if defined(ADC2) && defined(ADC3)
X#if 0L && 0L
S#define TIM8_OR1_RMP_MASK  ((TIM8_OR1_ETR_ADC2_RMP | TIM8_OR1_ETR_ADC3_RMP | TIM8_OR1_TI1_RMP) << TIMx_OR1_RMP_SHIFT)
N#else
N#define TIM8_OR1_RMP_MASK  (TIM8_OR1_TI1_RMP << TIMx_OR1_RMP_SHIFT)
N#endif /* ADC2 & ADC3 */
N#define TIM15_OR1_RMP_MASK (TIM15_OR1_TI1_RMP << TIMx_OR1_RMP_SHIFT)
N#define TIM16_OR1_RMP_MASK (TIM16_OR1_TI1_RMP << TIMx_OR1_RMP_SHIFT)
N#define TIM17_OR1_RMP_MASK (TIM17_OR1_TI1_RMP << TIMx_OR1_RMP_SHIFT)
N
N/* Mask used to set the TDG[x:0] of the DTG bits of the TIMx_BDTR register */
N#define DT_DELAY_1 ((uint8_t)0x7F)
N#define DT_DELAY_2 ((uint8_t)0x3F)
N#define DT_DELAY_3 ((uint8_t)0x1F)
N#define DT_DELAY_4 ((uint8_t)0x1F)
N
N/* Mask used to set the DTG[7:5] bits of the DTG bits of the TIMx_BDTR register */
N#define DT_RANGE_1 ((uint8_t)0x00)
N#define DT_RANGE_2 ((uint8_t)0x80)
N#define DT_RANGE_3 ((uint8_t)0xC0)
N#define DT_RANGE_4 ((uint8_t)0xE0)
N
N/** Legacy definitions for compatibility purpose
N@cond 0
N*/
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define TIMx_OR2_BKDFBK0E   TIMx_OR2_BKDF1BK0E
S#define TIMx_OR3_BK2DFBK1E  TIMx_OR3_BK2DF1BK1E
N#endif /* DFSDM1_Channel0 */
N/**
N@endcond
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup TIM_LL_Private_Macros TIM Private Macros
N  * @{
N  */
N/** @brief  Convert channel id into channel index.
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval none
N  */
N#define TIM_GET_CHANNEL_INDEX( __CHANNEL__) \
N(((__CHANNEL__) == LL_TIM_CHANNEL_CH1) ? 0U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH1N) ? 1U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH2) ? 2U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH2N) ? 3U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH3) ? 4U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH3N) ? 5U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH4) ? 6U :\
N((__CHANNEL__) == LL_TIM_CHANNEL_CH5) ? 7U : 8U)
X#define TIM_GET_CHANNEL_INDEX( __CHANNEL__) (((__CHANNEL__) == LL_TIM_CHANNEL_CH1) ? 0U :((__CHANNEL__) == LL_TIM_CHANNEL_CH1N) ? 1U :((__CHANNEL__) == LL_TIM_CHANNEL_CH2) ? 2U :((__CHANNEL__) == LL_TIM_CHANNEL_CH2N) ? 3U :((__CHANNEL__) == LL_TIM_CHANNEL_CH3) ? 4U :((__CHANNEL__) == LL_TIM_CHANNEL_CH3N) ? 5U :((__CHANNEL__) == LL_TIM_CHANNEL_CH4) ? 6U :((__CHANNEL__) == LL_TIM_CHANNEL_CH5) ? 7U : 8U)
N
N/** @brief  Calculate the deadtime sampling period(in ps).
N  * @param  __TIMCLK__ timer input clock frequency (in Hz).
N  * @param  __CKD__ This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
N  * @retval none
N  */
N#define TIM_CALC_DTS(__TIMCLK__, __CKD__)                                                        \
N    (((__CKD__) == LL_TIM_CLOCKDIVISION_DIV1) ? ((uint64_t)1000000000000U/(__TIMCLK__))         : \
N     ((__CKD__) == LL_TIM_CLOCKDIVISION_DIV2) ? ((uint64_t)1000000000000U/((__TIMCLK__) >> 1U)) : \
N     ((uint64_t)1000000000000U/((__TIMCLK__) >> 2U)))
X#define TIM_CALC_DTS(__TIMCLK__, __CKD__)                                                            (((__CKD__) == LL_TIM_CLOCKDIVISION_DIV1) ? ((uint64_t)1000000000000U/(__TIMCLK__))         :      ((__CKD__) == LL_TIM_CLOCKDIVISION_DIV2) ? ((uint64_t)1000000000000U/((__TIMCLK__) >> 1U)) :      ((uint64_t)1000000000000U/((__TIMCLK__) >> 2U)))
N/**
N  * @}
N  */
N
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup TIM_LL_ES_INIT TIM Exported Init structure
N  * @{
N  */
N
N/**
N  * @brief  TIM Time Base configuration structure definition.
N  */
Ntypedef struct
N{
N  uint16_t Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                   This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.
N
N                                   This feature can be modified afterwards using unitary function @ref LL_TIM_SetPrescaler().*/
N
N  uint32_t CounterMode;       /*!< Specifies the counter mode.
N                                   This parameter can be a value of @ref TIM_LL_EC_COUNTERMODE.
N
N                                   This feature can be modified afterwards using unitary function @ref LL_TIM_SetCounterMode().*/
N
N  uint32_t Autoreload;        /*!< Specifies the auto reload value to be loaded into the active
N                                   Auto-Reload Register at the next update event.
N                                   This parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF.
N                                   Some timer instances may support 32 bits counters. In that case this parameter must be a number between 0x0000 and 0xFFFFFFFF.
N
N                                   This feature can be modified afterwards using unitary function @ref LL_TIM_SetAutoReload().*/
N
N  uint32_t ClockDivision;     /*!< Specifies the clock division.
N                                   This parameter can be a value of @ref TIM_LL_EC_CLOCKDIVISION.
N
N                                   This feature can be modified afterwards using unitary function @ref LL_TIM_SetClockDivision().*/
N
N  uint8_t RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                   reaches zero, an update event is generated and counting restarts
N                                   from the RCR value (N).
N                                   This means in PWM mode that (N+1) corresponds to:
N                                      - the number of PWM periods in edge-aligned mode
N                                      - the number of half PWM period in center-aligned mode
N                                   This parameter must be a number between 0x00 and 0xFF.
N
N                                   This feature can be modified afterwards using unitary function @ref LL_TIM_SetRepetitionCounter().*/
N} LL_TIM_InitTypeDef;
N
N/**
N  * @brief  TIM Output Compare configuration structure definition.
N  */
Ntypedef struct
N{
N  uint32_t OCMode;        /*!< Specifies the output mode.
N                               This parameter can be a value of @ref TIM_LL_EC_OCMODE.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetMode().*/
N
N  uint32_t OCState;       /*!< Specifies the TIM Output Compare state.
N                               This parameter can be a value of @ref TIM_LL_EC_OCSTATE.
N
N                               This feature can be modified afterwards using unitary functions @ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel().*/
N
N  uint32_t OCNState;      /*!< Specifies the TIM complementary Output Compare state.
N                               This parameter can be a value of @ref TIM_LL_EC_OCSTATE.
N
N                               This feature can be modified afterwards using unitary functions @ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel().*/
N
N  uint32_t CompareValue;  /*!< Specifies the Compare value to be loaded into the Capture Compare Register.
N                               This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.
N
N                               This feature can be modified afterwards using unitary function LL_TIM_OC_SetCompareCHx (x=1..6).*/
N
N  uint32_t OCPolarity;    /*!< Specifies the output polarity.
N                               This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetPolarity().*/
N
N  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
N                               This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetPolarity().*/
N
N
N  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetIdleState().*/
N
N  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetIdleState().*/
N} LL_TIM_OC_InitTypeDef;
N
N/**
N  * @brief  TIM Input Capture configuration structure definition.
N  */
N
Ntypedef struct
N{
N
N  uint32_t ICPolarity;    /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPolarity().*/
N
N  uint32_t ICActiveInput; /*!< Specifies the input.
N                               This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetActiveInput().*/
N
N  uint32_t ICPrescaler;   /*!< Specifies the Input Capture Prescaler.
N                               This parameter can be a value of @ref TIM_LL_EC_ICPSC.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPrescaler().*/
N
N  uint32_t ICFilter;      /*!< Specifies the input capture filter.
N                               This parameter can be a value of @ref TIM_LL_EC_IC_FILTER.
N
N                               This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetFilter().*/
N} LL_TIM_IC_InitTypeDef;
N
N
N/**
N  * @brief  TIM Encoder interface configuration structure definition.
N  */
Ntypedef struct
N{
N  uint32_t EncoderMode;     /*!< Specifies the encoder resolution (x2 or x4).
N                                 This parameter can be a value of @ref TIM_LL_EC_ENCODERMODE.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_SetEncoderMode().*/
N
N  uint32_t IC1Polarity;     /*!< Specifies the active edge of TI1 input.
N                                 This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPolarity().*/
N
N  uint32_t IC1ActiveInput;  /*!< Specifies the TI1 input source
N                                 This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetActiveInput().*/
N
N  uint32_t IC1Prescaler;    /*!< Specifies the TI1 input prescaler value.
N                                 This parameter can be a value of @ref TIM_LL_EC_ICPSC.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPrescaler().*/
N
N  uint32_t IC1Filter;       /*!< Specifies the TI1 input filter.
N                                 This parameter can be a value of @ref TIM_LL_EC_IC_FILTER.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetFilter().*/
N
N  uint32_t IC2Polarity;      /*!< Specifies the active edge of TI2 input.
N                                 This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPolarity().*/
N
N  uint32_t IC2ActiveInput;  /*!< Specifies the TI2 input source
N                                 This parameter can be a value of @ref TIM_LL_EC_ACTIVEINPUT.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetActiveInput().*/
N
N  uint32_t IC2Prescaler;    /*!< Specifies the TI2 input prescaler value.
N                                 This parameter can be a value of @ref TIM_LL_EC_ICPSC.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPrescaler().*/
N
N  uint32_t IC2Filter;       /*!< Specifies the TI2 input filter.
N                                 This parameter can be a value of @ref TIM_LL_EC_IC_FILTER.
N
N                                 This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetFilter().*/
N
N} LL_TIM_ENCODER_InitTypeDef;
N
N/**
N  * @brief  TIM Hall sensor interface configuration structure definition.
N  */
Ntypedef struct
N{
N
N  uint32_t IC1Polarity;        /*!< Specifies the active edge of TI1 input.
N                                    This parameter can be a value of @ref TIM_LL_EC_IC_POLARITY.
N
N                                    This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPolarity().*/
N
N  uint32_t IC1Prescaler;       /*!< Specifies the TI1 input prescaler value.
N                                    Prescaler must be set to get a maximum counter period longer than the
N                                    time interval between 2 consecutive changes on the Hall inputs.
N                                    This parameter can be a value of @ref TIM_LL_EC_ICPSC.
N
N                                    This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetPrescaler().*/
N
N  uint32_t IC1Filter;          /*!< Specifies the TI1 input filter.
N                                    This parameter can be a value of @ref TIM_LL_EC_IC_FILTER.
N
N                                    This feature can be modified afterwards using unitary function @ref LL_TIM_IC_SetFilter().*/
N
N  uint32_t CommutationDelay;   /*!< Specifies the compare value to be loaded into the Capture Compare Register.
N                                    A positive pulse (TRGO event) is generated with a programmable delay every time
N                                    a change occurs on the Hall inputs.
N                                    This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.
N
N                                    This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetCompareCH2().*/
N} LL_TIM_HALLSENSOR_InitTypeDef;
N
N/**
N  * @brief  BDTR (Break and Dead Time) structure definition
N  */
Ntypedef struct
N{
N  uint32_t OSSRState;            /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref TIM_LL_EC_OSSR
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_SetOffStates()
N
N                                      @note This bit-field cannot be modified as long as LOCK level 2 has been programmed. */
N
N  uint32_t OSSIState;            /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref TIM_LL_EC_OSSI
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_SetOffStates()
N
N                                      @note This bit-field cannot be modified as long as LOCK level 2 has been programmed. */
N
N  uint32_t LockLevel;            /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref TIM_LL_EC_LOCKLEVEL
N
N                                      @note The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register
N                                            has been written, their content is frozen until the next reset.*/
N
N  uint8_t DeadTime;              /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF.
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_OC_SetDeadTime()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed. */
N
N  uint16_t BreakState;           /*!< Specifies whether the TIM Break input is enabled or not.
N                                      This parameter can be a value of @ref TIM_LL_EC_BREAK_ENABLE
N
N                                      This feature can be modified afterwards using unitary functions @ref LL_TIM_EnableBRK() or @ref LL_TIM_DisableBRK()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N
N  uint32_t BreakPolarity;        /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref TIM_LL_EC_BREAK_POLARITY
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_ConfigBRK()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N
N  uint32_t BreakFilter;          /*!< Specifies the TIM Break Filter.
N                                      This parameter can be a value of @ref TIM_LL_EC_BREAK_FILTER
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_ConfigBRK()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N
N  uint32_t Break2State;          /*!< Specifies whether the TIM Break2 input is enabled or not.
N                                      This parameter can be a value of @ref TIM_LL_EC_BREAK2_ENABLE
N
N                                      This feature can be modified afterwards using unitary functions @ref LL_TIM_EnableBRK2() or @ref LL_TIM_DisableBRK2()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N
N  uint32_t Break2Polarity;        /*!< Specifies the TIM Break2 Input pin polarity.
N                                      This parameter can be a value of @ref TIM_LL_EC_BREAK2_POLARITY
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_ConfigBRK2()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N
N  uint32_t Break2Filter;          /*!< Specifies the TIM Break2 Filter.
N                                      This parameter can be a value of @ref TIM_LL_EC_BREAK2_FILTER
N
N                                      This feature can be modified afterwards using unitary function @ref LL_TIM_ConfigBRK2()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N
N  uint32_t AutomaticOutput;      /*!< Specifies whether the TIM Automatic Output feature is enabled or not.
N                                      This parameter can be a value of @ref TIM_LL_EC_AUTOMATICOUTPUT_ENABLE
N
N                                      This feature can be modified afterwards using unitary functions @ref LL_TIM_EnableAutomaticOutput() or @ref LL_TIM_DisableAutomaticOutput()
N
N                                      @note This bit-field can not be modified as long as LOCK level 1 has been programmed. */
N} LL_TIM_BDTR_InitTypeDef;
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup TIM_LL_Exported_Constants TIM Exported Constants
N  * @{
N  */
N
N/** @defgroup TIM_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_TIM_ReadReg function.
N  * @{
N  */
N#define LL_TIM_SR_UIF                          TIM_SR_UIF           /*!< Update interrupt flag */
N#define LL_TIM_SR_CC1IF                        TIM_SR_CC1IF         /*!< Capture/compare 1 interrupt flag */
N#define LL_TIM_SR_CC2IF                        TIM_SR_CC2IF         /*!< Capture/compare 2 interrupt flag */
N#define LL_TIM_SR_CC3IF                        TIM_SR_CC3IF         /*!< Capture/compare 3 interrupt flag */
N#define LL_TIM_SR_CC4IF                        TIM_SR_CC4IF         /*!< Capture/compare 4 interrupt flag */
N#define LL_TIM_SR_CC5IF                        TIM_SR_CC5IF         /*!< Capture/compare 5 interrupt flag */
N#define LL_TIM_SR_CC6IF                        TIM_SR_CC6IF         /*!< Capture/compare 6 interrupt flag */
N#define LL_TIM_SR_COMIF                        TIM_SR_COMIF         /*!< COM interrupt flag */
N#define LL_TIM_SR_TIF                          TIM_SR_TIF           /*!< Trigger interrupt flag */
N#define LL_TIM_SR_BIF                          TIM_SR_BIF           /*!< Break interrupt flag */
N#define LL_TIM_SR_B2IF                         TIM_SR_B2IF          /*!< Second break interrupt flag */
N#define LL_TIM_SR_CC1OF                        TIM_SR_CC1OF         /*!< Capture/Compare 1 overcapture flag */
N#define LL_TIM_SR_CC2OF                        TIM_SR_CC2OF         /*!< Capture/Compare 2 overcapture flag */
N#define LL_TIM_SR_CC3OF                        TIM_SR_CC3OF         /*!< Capture/Compare 3 overcapture flag */
N#define LL_TIM_SR_CC4OF                        TIM_SR_CC4OF         /*!< Capture/Compare 4 overcapture flag */
N#define LL_TIM_SR_SBIF                         TIM_SR_SBIF          /*!< System Break interrupt flag  */
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup TIM_LL_EC_BREAK_ENABLE Break Enable
N  * @{
N  */
N#define LL_TIM_BREAK_DISABLE            0x00000000U             /*!< Break function disabled */
N#define LL_TIM_BREAK_ENABLE             TIM_BDTR_BKE            /*!< Break function enabled */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BREAK2_ENABLE Break2 Enable
N  * @{
N  */
N#define LL_TIM_BREAK2_DISABLE            0x00000000U              /*!< Break2 function disabled */
N#define LL_TIM_BREAK2_ENABLE             TIM_BDTR_BK2E            /*!< Break2 function enabled */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_AUTOMATICOUTPUT_ENABLE Automatic output enable
N  * @{
N  */
N#define LL_TIM_AUTOMATICOUTPUT_DISABLE         0x00000000U             /*!< MOE can be set only by software */
N#define LL_TIM_AUTOMATICOUTPUT_ENABLE          TIM_BDTR_AOE            /*!< MOE can be set by software or automatically at the next update event */
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/** @defgroup TIM_LL_EC_IT IT Defines
N  * @brief    IT defines which can be used with LL_TIM_ReadReg and  LL_TIM_WriteReg functions.
N  * @{
N  */
N#define LL_TIM_DIER_UIE                        TIM_DIER_UIE         /*!< Update interrupt enable */
N#define LL_TIM_DIER_CC1IE                      TIM_DIER_CC1IE       /*!< Capture/compare 1 interrupt enable */
N#define LL_TIM_DIER_CC2IE                      TIM_DIER_CC2IE       /*!< Capture/compare 2 interrupt enable */
N#define LL_TIM_DIER_CC3IE                      TIM_DIER_CC3IE       /*!< Capture/compare 3 interrupt enable */
N#define LL_TIM_DIER_CC4IE                      TIM_DIER_CC4IE       /*!< Capture/compare 4 interrupt enable */
N#define LL_TIM_DIER_COMIE                      TIM_DIER_COMIE       /*!< COM interrupt enable */
N#define LL_TIM_DIER_TIE                        TIM_DIER_TIE         /*!< Trigger interrupt enable */
N#define LL_TIM_DIER_BIE                        TIM_DIER_BIE         /*!< Break interrupt enable */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_UPDATESOURCE Update Source
N  * @{
N  */
N#define LL_TIM_UPDATESOURCE_REGULAR            0x00000000U          /*!< Counter overflow/underflow, Setting the UG bit or Update generation through the slave mode controller generates an update request */
N#define LL_TIM_UPDATESOURCE_COUNTER            TIM_CR1_URS          /*!< Only counter overflow/underflow generates an update request */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ONEPULSEMODE One Pulse Mode
N  * @{
N  */
N#define LL_TIM_ONEPULSEMODE_SINGLE             TIM_CR1_OPM          /*!< Counter is not stopped at update event */
N#define LL_TIM_ONEPULSEMODE_REPETITIVE         0x00000000U          /*!< Counter stops counting at the next update event */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_COUNTERMODE Counter Mode
N  * @{
N  */
N#define LL_TIM_COUNTERMODE_UP                  0x00000000U          /*!<Counter used as upcounter */
N#define LL_TIM_COUNTERMODE_DOWN                TIM_CR1_DIR          /*!< Counter used as downcounter */
N#define LL_TIM_COUNTERMODE_CENTER_UP           TIM_CR1_CMS_0        /*!< The counter counts up and down alternatively. Output compare interrupt flags of output channels  are set only when the counter is counting down. */
N#define LL_TIM_COUNTERMODE_CENTER_DOWN         TIM_CR1_CMS_1        /*!<The counter counts up and down alternatively. Output compare interrupt flags of output channels  are set only when the counter is counting up */
N#define LL_TIM_COUNTERMODE_CENTER_UP_DOWN      TIM_CR1_CMS          /*!< The counter counts up and down alternatively. Output compare interrupt flags of output channels  are set only when the counter is counting up or down. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_CLOCKDIVISION Clock Division
N  * @{
N  */
N#define LL_TIM_CLOCKDIVISION_DIV1              0x00000000U          /*!< tDTS=tCK_INT */
N#define LL_TIM_CLOCKDIVISION_DIV2              TIM_CR1_CKD_0        /*!< tDTS=2*tCK_INT */
N#define LL_TIM_CLOCKDIVISION_DIV4              TIM_CR1_CKD_1        /*!< tDTS=4*tCK_INT */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_COUNTERDIRECTION Counter Direction
N  * @{
N  */
N#define LL_TIM_COUNTERDIRECTION_UP             0x00000000U          /*!< Timer counter counts up */
N#define LL_TIM_COUNTERDIRECTION_DOWN           TIM_CR1_DIR          /*!< Timer counter counts down */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_CCUPDATESOURCE Capture Compare  Update Source
N  * @{
N  */
N#define LL_TIM_CCUPDATESOURCE_COMG_ONLY        0x00000000U          /*!< Capture/compare control bits are updated by setting the COMG bit only */
N#define LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI    TIM_CR2_CCUS         /*!< Capture/compare control bits are updated by setting the COMG bit or when a rising edge occurs on trigger input (TRGI) */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_CCDMAREQUEST Capture Compare DMA Request
N  * @{
N  */
N#define LL_TIM_CCDMAREQUEST_CC                 0x00000000U          /*!< CCx DMA request sent when CCx event occurs */
N#define LL_TIM_CCDMAREQUEST_UPDATE             TIM_CR2_CCDS         /*!< CCx DMA requests sent when update event occurs */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_LOCKLEVEL Lock Level
N  * @{
N  */
N#define LL_TIM_LOCKLEVEL_OFF                   0x00000000U          /*!< LOCK OFF - No bit is write protected */
N#define LL_TIM_LOCKLEVEL_1                     TIM_BDTR_LOCK_0      /*!< LOCK Level 1 */
N#define LL_TIM_LOCKLEVEL_2                     TIM_BDTR_LOCK_1      /*!< LOCK Level 2 */
N#define LL_TIM_LOCKLEVEL_3                     TIM_BDTR_LOCK        /*!< LOCK Level 3 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_CHANNEL Channel
N  * @{
N  */
N#define LL_TIM_CHANNEL_CH1                     TIM_CCER_CC1E     /*!< Timer input/output channel 1 */
N#define LL_TIM_CHANNEL_CH1N                    TIM_CCER_CC1NE    /*!< Timer complementary output channel 1 */
N#define LL_TIM_CHANNEL_CH2                     TIM_CCER_CC2E     /*!< Timer input/output channel 2 */
N#define LL_TIM_CHANNEL_CH2N                    TIM_CCER_CC2NE    /*!< Timer complementary output channel 2 */
N#define LL_TIM_CHANNEL_CH3                     TIM_CCER_CC3E     /*!< Timer input/output channel 3 */
N#define LL_TIM_CHANNEL_CH3N                    TIM_CCER_CC3NE    /*!< Timer complementary output channel 3 */
N#define LL_TIM_CHANNEL_CH4                     TIM_CCER_CC4E     /*!< Timer input/output channel 4 */
N#define LL_TIM_CHANNEL_CH5                     TIM_CCER_CC5E     /*!< Timer output channel 5 */
N#define LL_TIM_CHANNEL_CH6                     TIM_CCER_CC6E     /*!< Timer output channel 6 */
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup TIM_LL_EC_OCSTATE Output Configuration State
N  * @{
N  */
N#define LL_TIM_OCSTATE_DISABLE                 0x00000000U             /*!< OCx is not active */
N#define LL_TIM_OCSTATE_ENABLE                  TIM_CCER_CC1E           /*!< OCx signal is output on the corresponding output pin */
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/** @defgroup TIM_LL_EC_OCMODE Output Configuration Mode
N  * @{
N  */
N#define LL_TIM_OCMODE_FROZEN                   0x00000000U                                              /*!<The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the output channel level */
N#define LL_TIM_OCMODE_ACTIVE                   TIM_CCMR1_OC1M_0                                         /*!<OCyREF is forced high on compare match*/
N#define LL_TIM_OCMODE_INACTIVE                 TIM_CCMR1_OC1M_1                                         /*!<OCyREF is forced low on compare match*/
N#define LL_TIM_OCMODE_TOGGLE                   (TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)                    /*!<OCyREF toggles on compare match*/
N#define LL_TIM_OCMODE_FORCED_INACTIVE          TIM_CCMR1_OC1M_2                                         /*!<OCyREF is forced low*/
N#define LL_TIM_OCMODE_FORCED_ACTIVE            (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_0)                    /*!<OCyREF is forced high*/
N#define LL_TIM_OCMODE_PWM1                     (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1)                    /*!<In upcounting, channel y is active as long as TIMx_CNT<TIMx_CCRy else inactive.  In downcounting, channel y is inactive as long as TIMx_CNT>TIMx_CCRy else active.*/
N#define LL_TIM_OCMODE_PWM2                     (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0) /*!<In upcounting, channel y is inactive as long as TIMx_CNT<TIMx_CCRy else active.  In downcounting, channel y is active as long as TIMx_CNT>TIMx_CCRy else inactive*/
N#define LL_TIM_OCMODE_RETRIG_OPM1              TIM_CCMR1_OC1M_3                                         /*!<Retrigerrable OPM mode 1*/
N#define LL_TIM_OCMODE_RETRIG_OPM2              (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0)                    /*!<Retrigerrable OPM mode 2*/
N#define LL_TIM_OCMODE_COMBINED_PWM1            (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_2)                    /*!<Combined PWM mode 1*/
N#define LL_TIM_OCMODE_COMBINED_PWM2            (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_2) /*!<Combined PWM mode 2*/
N#define LL_TIM_OCMODE_ASSYMETRIC_PWM1          (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2) /*!<Asymmetric PWM mode 1*/
N#define LL_TIM_OCMODE_ASSYMETRIC_PWM2          (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M)                      /*!<Asymmetric PWM mode 2*/
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_OCPOLARITY Output Configuration Polarity
N  * @{
N  */
N#define LL_TIM_OCPOLARITY_HIGH                 0x00000000U                 /*!< OCxactive high*/
N#define LL_TIM_OCPOLARITY_LOW                  TIM_CCER_CC1P               /*!< OCxactive low*/
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_OCIDLESTATE Output Configuration Idle State
N  * @{
N  */
N#define LL_TIM_OCIDLESTATE_LOW                 0x00000000U             /*!<OCx=0 (after a dead-time if OC is implemented) when MOE=0*/
N#define LL_TIM_OCIDLESTATE_HIGH                TIM_CR2_OIS1            /*!<OCx=1 (after a dead-time if OC is implemented) when MOE=0*/
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_GROUPCH5 GROUPCH5
N  * @{
N  */
N#define LL_TIM_GROUPCH5_NONE                   0x00000000U           /*!< No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC */
N#define LL_TIM_GROUPCH5_OC1REFC                TIM_CCR5_GC5C1        /*!< OC1REFC is the logical AND of OC1REFC and OC5REF */
N#define LL_TIM_GROUPCH5_OC2REFC                TIM_CCR5_GC5C2        /*!< OC2REFC is the logical AND of OC2REFC and OC5REF */
N#define LL_TIM_GROUPCH5_OC3REFC                TIM_CCR5_GC5C3        /*!< OC3REFC is the logical AND of OC3REFC and OC5REF */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ACTIVEINPUT Active Input Selection
N  * @{
N  */
N#define LL_TIM_ACTIVEINPUT_DIRECTTI            (TIM_CCMR1_CC1S_0 << 16U) /*!< ICx is mapped on TIx */
N#define LL_TIM_ACTIVEINPUT_INDIRECTTI          (TIM_CCMR1_CC1S_1 << 16U) /*!< ICx is mapped on TIy */
N#define LL_TIM_ACTIVEINPUT_TRC                 (TIM_CCMR1_CC1S << 16U)   /*!< ICx is mapped on TRC */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ICPSC Input Configuration Prescaler
N  * @{
N  */
N#define LL_TIM_ICPSC_DIV1                      0x00000000U                    /*!< No prescaler, capture is done each time an edge is detected on the capture input */
N#define LL_TIM_ICPSC_DIV2                      (TIM_CCMR1_IC1PSC_0 << 16U)    /*!< Capture is done once every 2 events */
N#define LL_TIM_ICPSC_DIV4                      (TIM_CCMR1_IC1PSC_1 << 16U)    /*!< Capture is done once every 4 events */
N#define LL_TIM_ICPSC_DIV8                      (TIM_CCMR1_IC1PSC << 16U)      /*!< Capture is done once every 8 events */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_IC_FILTER Input Configuration Filter
N  * @{
N  */
N#define LL_TIM_IC_FILTER_FDIV1                 0x00000000U                                                        /*!< No filter, sampling is done at fDTS */
N#define LL_TIM_IC_FILTER_FDIV1_N2              (TIM_CCMR1_IC1F_0 << 16U)                                          /*!< fSAMPLING=fCK_INT, N=2 */
N#define LL_TIM_IC_FILTER_FDIV1_N4              (TIM_CCMR1_IC1F_1 << 16U)                                          /*!< fSAMPLING=fCK_INT, N=4 */
N#define LL_TIM_IC_FILTER_FDIV1_N8              ((TIM_CCMR1_IC1F_1 | TIM_CCMR1_IC1F_0) << 16U)                     /*!< fSAMPLING=fCK_INT, N=8 */
N#define LL_TIM_IC_FILTER_FDIV2_N6              (TIM_CCMR1_IC1F_2 << 16U)                                          /*!< fSAMPLING=fDTS/2, N=6 */
N#define LL_TIM_IC_FILTER_FDIV2_N8              ((TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_0) << 16U)                     /*!< fSAMPLING=fDTS/2, N=8 */
N#define LL_TIM_IC_FILTER_FDIV4_N6              ((TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_1) << 16U)                     /*!< fSAMPLING=fDTS/4, N=6 */
N#define LL_TIM_IC_FILTER_FDIV4_N8              ((TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_1 | TIM_CCMR1_IC1F_0) << 16U)  /*!< fSAMPLING=fDTS/4, N=8 */
N#define LL_TIM_IC_FILTER_FDIV8_N6              (TIM_CCMR1_IC1F_3 << 16U)                                          /*!< fSAMPLING=fDTS/8, N=6 */
N#define LL_TIM_IC_FILTER_FDIV8_N8              ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_0) << 16U)                     /*!< fSAMPLING=fDTS/8, N=8 */
N#define LL_TIM_IC_FILTER_FDIV16_N5             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_1) << 16U)                     /*!< fSAMPLING=fDTS/16, N=5 */
N#define LL_TIM_IC_FILTER_FDIV16_N6             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_1 | TIM_CCMR1_IC1F_0) << 16U)  /*!< fSAMPLING=fDTS/16, N=6 */
N#define LL_TIM_IC_FILTER_FDIV16_N8             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_2) << 16U)                     /*!< fSAMPLING=fDTS/16, N=8 */
N#define LL_TIM_IC_FILTER_FDIV32_N5             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_0) << 16U)  /*!< fSAMPLING=fDTS/32, N=5 */
N#define LL_TIM_IC_FILTER_FDIV32_N6             ((TIM_CCMR1_IC1F_3 | TIM_CCMR1_IC1F_2 | TIM_CCMR1_IC1F_1) << 16U)  /*!< fSAMPLING=fDTS/32, N=6 */
N#define LL_TIM_IC_FILTER_FDIV32_N8             (TIM_CCMR1_IC1F << 16U)                                            /*!< fSAMPLING=fDTS/32, N=8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_IC_POLARITY Input Configuration Polarity
N  * @{
N  */
N#define LL_TIM_IC_POLARITY_RISING              0x00000000U                      /*!< The circuit is sensitive to TIxFP1 rising edge, TIxFP1 is not inverted */
N#define LL_TIM_IC_POLARITY_FALLING             TIM_CCER_CC1P                    /*!< The circuit is sensitive to TIxFP1 falling edge, TIxFP1 is inverted */
N#define LL_TIM_IC_POLARITY_BOTHEDGE            (TIM_CCER_CC1P | TIM_CCER_CC1NP) /*!< The circuit is sensitive to both TIxFP1 rising and falling edges, TIxFP1 is not inverted */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_CLOCKSOURCE Clock Source
N  * @{
N  */
N#define LL_TIM_CLOCKSOURCE_INTERNAL            0x00000000U                                          /*!< The timer is clocked by the internal clock provided from the RCC */
N#define LL_TIM_CLOCKSOURCE_EXT_MODE1           (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)   /*!< Counter counts at each rising or falling edge on a selected input*/
N#define LL_TIM_CLOCKSOURCE_EXT_MODE2           TIM_SMCR_ECE                                         /*!< Counter counts at each rising or falling edge on the external trigger input ETR */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ENCODERMODE Encoder Mode
N  * @{
N  */
N#define LL_TIM_ENCODERMODE_X2_TI1                     TIM_SMCR_SMS_0                                                     /*!< Quadrature encoder mode 1, x2 mode - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level */
N#define LL_TIM_ENCODERMODE_X2_TI2                     TIM_SMCR_SMS_1                                                     /*!< Quadrature encoder mode 2, x2 mode - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level */
N#define LL_TIM_ENCODERMODE_X4_TI12                   (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)                                   /*!< Quadrature encoder mode 3, x4 mode - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TRGO Trigger Output
N  * @{
N  */
N#define LL_TIM_TRGO_RESET                      0x00000000U                                     /*!< UG bit from the TIMx_EGR register is used as trigger output */
N#define LL_TIM_TRGO_ENABLE                     TIM_CR2_MMS_0                                   /*!< Counter Enable signal (CNT_EN) is used as trigger output */
N#define LL_TIM_TRGO_UPDATE                     TIM_CR2_MMS_1                                   /*!< Update event is used as trigger output */
N#define LL_TIM_TRGO_CC1IF                      (TIM_CR2_MMS_1 | TIM_CR2_MMS_0)                 /*!< CC1 capture or a compare match is used as trigger output */
N#define LL_TIM_TRGO_OC1REF                     TIM_CR2_MMS_2                                   /*!< OC1REF signal is used as trigger output */
N#define LL_TIM_TRGO_OC2REF                     (TIM_CR2_MMS_2 | TIM_CR2_MMS_0)                 /*!< OC2REF signal is used as trigger output */
N#define LL_TIM_TRGO_OC3REF                     (TIM_CR2_MMS_2 | TIM_CR2_MMS_1)                 /*!< OC3REF signal is used as trigger output */
N#define LL_TIM_TRGO_OC4REF                     (TIM_CR2_MMS_2 | TIM_CR2_MMS_1 | TIM_CR2_MMS_0) /*!< OC4REF signal is used as trigger output */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TRGO2 Trigger Output 2
N  * @{
N  */
N#define LL_TIM_TRGO2_RESET                     0x00000000U                                                         /*!< UG bit from the TIMx_EGR register is used as trigger output 2 */
N#define LL_TIM_TRGO2_ENABLE                    TIM_CR2_MMS2_0                                                      /*!< Counter Enable signal (CNT_EN) is used as trigger output 2 */
N#define LL_TIM_TRGO2_UPDATE                    TIM_CR2_MMS2_1                                                      /*!< Update event is used as trigger output 2 */
N#define LL_TIM_TRGO2_CC1F                      (TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)                                   /*!< CC1 capture or a compare match is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC1                       TIM_CR2_MMS2_2                                                      /*!< OC1REF signal is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC2                       (TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0)                                   /*!< OC2REF signal is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC3                       (TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1)                                   /*!< OC3REF signal is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC4                       (TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)                  /*!< OC4REF signal is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC5                       TIM_CR2_MMS2_3                                                      /*!< OC5REF signal is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC6                       (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_0)                                   /*!< OC6REF signal is used as trigger output 2 */
N#define LL_TIM_TRGO2_OC4_RISINGFALLING         (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1)                                   /*!< OC4REF rising or falling edges are used as trigger output 2 */
N#define LL_TIM_TRGO2_OC6_RISINGFALLING         (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)                  /*!< OC6REF rising or falling edges are used as trigger output 2 */
N#define LL_TIM_TRGO2_OC4_RISING_OC6_RISING     (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2)                                   /*!< OC4REF or OC6REF rising edges are used as trigger output 2 */
N#define LL_TIM_TRGO2_OC4_RISING_OC6_FALLING    (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0)                  /*!< OC4REF rising or OC6REF falling edges are used as trigger output 2 */
N#define LL_TIM_TRGO2_OC5_RISING_OC6_RISING     (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 |TIM_CR2_MMS2_1)                   /*!< OC5REF or OC6REF rising edges are used as trigger output 2 */
N#define LL_TIM_TRGO2_OC5_RISING_OC6_FALLING    (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0) /*!< OC5REF rising or OC6REF falling edges are used as trigger output 2 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_SLAVEMODE Slave Mode
N  * @{
N  */
N#define LL_TIM_SLAVEMODE_DISABLED              0x00000000U                         /*!< Slave mode disabled */
N#define LL_TIM_SLAVEMODE_RESET                 TIM_SMCR_SMS_2                      /*!< Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter */
N#define LL_TIM_SLAVEMODE_GATED                 (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)   /*!< Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high */
N#define LL_TIM_SLAVEMODE_TRIGGER               (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)   /*!< Trigger Mode - The counter starts at a rising edge of the trigger TRGI */
N#define LL_TIM_SLAVEMODE_COMBINED_RESETTRIGGER TIM_SMCR_SMS_3                      /*!< Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI)  reinitializes the counter, generates an update of the registers and starts the counter */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TS Trigger Selection
N  * @{
N  */
N#define LL_TIM_TS_ITR0                         0x00000000U                                                     /*!< Internal Trigger 0 (ITR0) is used as trigger input */
N#define LL_TIM_TS_ITR1                         TIM_SMCR_TS_0                                                   /*!< Internal Trigger 1 (ITR1) is used as trigger input */
N#define LL_TIM_TS_ITR2                         TIM_SMCR_TS_1                                                   /*!< Internal Trigger 2 (ITR2) is used as trigger input */
N#define LL_TIM_TS_ITR3                         (TIM_SMCR_TS_0 | TIM_SMCR_TS_1)                                 /*!< Internal Trigger 3 (ITR3) is used as trigger input */
N#define LL_TIM_TS_TI1F_ED                      TIM_SMCR_TS_2                                                   /*!< TI1 Edge Detector (TI1F_ED) is used as trigger input */
N#define LL_TIM_TS_TI1FP1                       (TIM_SMCR_TS_2 | TIM_SMCR_TS_0)                                 /*!< Filtered Timer Input 1 (TI1FP1) is used as trigger input */
N#define LL_TIM_TS_TI2FP2                       (TIM_SMCR_TS_2 | TIM_SMCR_TS_1)                                 /*!< Filtered Timer Input 2 (TI12P2) is used as trigger input */
N#define LL_TIM_TS_ETRF                         (TIM_SMCR_TS_2 | TIM_SMCR_TS_1 | TIM_SMCR_TS_0)                 /*!< Filtered external Trigger (ETRF) is used as trigger input */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ETR_POLARITY External Trigger Polarity
N  * @{
N  */
N#define LL_TIM_ETR_POLARITY_NONINVERTED        0x00000000U             /*!< ETR is non-inverted, active at high level or rising edge */
N#define LL_TIM_ETR_POLARITY_INVERTED           TIM_SMCR_ETP            /*!< ETR is inverted, active at low level or falling edge */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ETR_PRESCALER External Trigger Prescaler
N  * @{
N  */
N#define LL_TIM_ETR_PRESCALER_DIV1              0x00000000U             /*!< ETR prescaler OFF */
N#define LL_TIM_ETR_PRESCALER_DIV2              TIM_SMCR_ETPS_0         /*!< ETR frequency is divided by 2 */
N#define LL_TIM_ETR_PRESCALER_DIV4              TIM_SMCR_ETPS_1         /*!< ETR frequency is divided by 4 */
N#define LL_TIM_ETR_PRESCALER_DIV8              TIM_SMCR_ETPS           /*!< ETR frequency is divided by 8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ETR_FILTER External Trigger Filter
N  * @{
N  */
N#define LL_TIM_ETR_FILTER_FDIV1                0x00000000U                                          /*!< No filter, sampling is done at fDTS */
N#define LL_TIM_ETR_FILTER_FDIV1_N2             TIM_SMCR_ETF_0                                       /*!< fSAMPLING=fCK_INT, N=2 */
N#define LL_TIM_ETR_FILTER_FDIV1_N4             TIM_SMCR_ETF_1                                       /*!< fSAMPLING=fCK_INT, N=4 */
N#define LL_TIM_ETR_FILTER_FDIV1_N8             (TIM_SMCR_ETF_1 | TIM_SMCR_ETF_0)                    /*!< fSAMPLING=fCK_INT, N=8 */
N#define LL_TIM_ETR_FILTER_FDIV2_N6             TIM_SMCR_ETF_2                                       /*!< fSAMPLING=fDTS/2, N=6 */
N#define LL_TIM_ETR_FILTER_FDIV2_N8             (TIM_SMCR_ETF_2 | TIM_SMCR_ETF_0)                    /*!< fSAMPLING=fDTS/2, N=8 */
N#define LL_TIM_ETR_FILTER_FDIV4_N6             (TIM_SMCR_ETF_2 | TIM_SMCR_ETF_1)                    /*!< fSAMPLING=fDTS/4, N=6 */
N#define LL_TIM_ETR_FILTER_FDIV4_N8             (TIM_SMCR_ETF_2 | TIM_SMCR_ETF_1 | TIM_SMCR_ETF_0)   /*!< fSAMPLING=fDTS/4, N=8 */
N#define LL_TIM_ETR_FILTER_FDIV8_N6             TIM_SMCR_ETF_3                                       /*!< fSAMPLING=fDTS/8, N=8 */
N#define LL_TIM_ETR_FILTER_FDIV8_N8             (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_0)                    /*!< fSAMPLING=fDTS/16, N=5 */
N#define LL_TIM_ETR_FILTER_FDIV16_N5            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_1)                    /*!< fSAMPLING=fDTS/16, N=6 */
N#define LL_TIM_ETR_FILTER_FDIV16_N6            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_1 | TIM_SMCR_ETF_0)   /*!< fSAMPLING=fDTS/16, N=8 */
N#define LL_TIM_ETR_FILTER_FDIV16_N8            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_2)                    /*!< fSAMPLING=fDTS/16, N=5 */
N#define LL_TIM_ETR_FILTER_FDIV32_N5            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_2 | TIM_SMCR_ETF_0)   /*!< fSAMPLING=fDTS/32, N=5 */
N#define LL_TIM_ETR_FILTER_FDIV32_N6            (TIM_SMCR_ETF_3 | TIM_SMCR_ETF_2 | TIM_SMCR_ETF_1)   /*!< fSAMPLING=fDTS/32, N=6 */
N#define LL_TIM_ETR_FILTER_FDIV32_N8            TIM_SMCR_ETF                                         /*!< fSAMPLING=fDTS/32, N=8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_ETRSOURCE External Trigger Source
N  * @{
N  */
N#define LL_TIM_ETRSOURCE_LEGACY                0x00000000U                                                 /*!< ETR legacy mode */
N#define LL_TIM_ETRSOURCE_COMP1                 TIM1_OR2_ETRSEL_0                                 /*!< COMP1 output connected to ETR input */
N#define LL_TIM_ETRSOURCE_COMP2                 TIM1_OR2_ETRSEL_1                                 /*!< COMP2 output connected to ETR input */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BREAK_POLARITY break polarity
N  * @{
N  */
N#define LL_TIM_BREAK_POLARITY_LOW              0x00000000U               /*!< Break input BRK is active low */
N#define LL_TIM_BREAK_POLARITY_HIGH             TIM_BDTR_BKP              /*!< Break input BRK is active high */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BREAK_FILTER break filter
N  * @{
N  */
N#define LL_TIM_BREAK_FILTER_FDIV1              0x00000000U   /*!< No filter, BRK acts asynchronously */
N#define LL_TIM_BREAK_FILTER_FDIV1_N2           0x00010000U   /*!< fSAMPLING=fCK_INT, N=2 */
N#define LL_TIM_BREAK_FILTER_FDIV1_N4           0x00020000U   /*!< fSAMPLING=fCK_INT, N=4 */
N#define LL_TIM_BREAK_FILTER_FDIV1_N8           0x00030000U   /*!< fSAMPLING=fCK_INT, N=8 */
N#define LL_TIM_BREAK_FILTER_FDIV2_N6           0x00040000U   /*!< fSAMPLING=fDTS/2, N=6 */
N#define LL_TIM_BREAK_FILTER_FDIV2_N8           0x00050000U   /*!< fSAMPLING=fDTS/2, N=8 */
N#define LL_TIM_BREAK_FILTER_FDIV4_N6           0x00060000U   /*!< fSAMPLING=fDTS/4, N=6 */
N#define LL_TIM_BREAK_FILTER_FDIV4_N8           0x00070000U   /*!< fSAMPLING=fDTS/4, N=8 */
N#define LL_TIM_BREAK_FILTER_FDIV8_N6           0x00080000U   /*!< fSAMPLING=fDTS/8, N=6 */
N#define LL_TIM_BREAK_FILTER_FDIV8_N8           0x00090000U   /*!< fSAMPLING=fDTS/8, N=8 */
N#define LL_TIM_BREAK_FILTER_FDIV16_N5          0x000A0000U   /*!< fSAMPLING=fDTS/16, N=5 */
N#define LL_TIM_BREAK_FILTER_FDIV16_N6          0x000B0000U   /*!< fSAMPLING=fDTS/16, N=6 */
N#define LL_TIM_BREAK_FILTER_FDIV16_N8          0x000C0000U   /*!< fSAMPLING=fDTS/16, N=8 */
N#define LL_TIM_BREAK_FILTER_FDIV32_N5          0x000D0000U   /*!< fSAMPLING=fDTS/32, N=5 */
N#define LL_TIM_BREAK_FILTER_FDIV32_N6          0x000E0000U   /*!< fSAMPLING=fDTS/32, N=6 */
N#define LL_TIM_BREAK_FILTER_FDIV32_N8          0x000F0000U   /*!< fSAMPLING=fDTS/32, N=8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BREAK2_POLARITY BREAK2 POLARITY
N  * @{
N  */
N#define LL_TIM_BREAK2_POLARITY_LOW             0x00000000U             /*!< Break input BRK2 is active low */
N#define LL_TIM_BREAK2_POLARITY_HIGH            TIM_BDTR_BK2P           /*!< Break input BRK2 is active high */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BREAK2_FILTER BREAK2 FILTER
N  * @{
N  */
N#define LL_TIM_BREAK2_FILTER_FDIV1             0x00000000U   /*!< No filter, BRK acts asynchronously */
N#define LL_TIM_BREAK2_FILTER_FDIV1_N2          0x00100000U   /*!< fSAMPLING=fCK_INT, N=2 */
N#define LL_TIM_BREAK2_FILTER_FDIV1_N4          0x00200000U   /*!< fSAMPLING=fCK_INT, N=4 */
N#define LL_TIM_BREAK2_FILTER_FDIV1_N8          0x00300000U   /*!< fSAMPLING=fCK_INT, N=8 */
N#define LL_TIM_BREAK2_FILTER_FDIV2_N6          0x00400000U   /*!< fSAMPLING=fDTS/2, N=6 */
N#define LL_TIM_BREAK2_FILTER_FDIV2_N8          0x00500000U   /*!< fSAMPLING=fDTS/2, N=8 */
N#define LL_TIM_BREAK2_FILTER_FDIV4_N6          0x00600000U   /*!< fSAMPLING=fDTS/4, N=6 */
N#define LL_TIM_BREAK2_FILTER_FDIV4_N8          0x00700000U   /*!< fSAMPLING=fDTS/4, N=8 */
N#define LL_TIM_BREAK2_FILTER_FDIV8_N6          0x00800000U   /*!< fSAMPLING=fDTS/8, N=6 */
N#define LL_TIM_BREAK2_FILTER_FDIV8_N8          0x00900000U   /*!< fSAMPLING=fDTS/8, N=8 */
N#define LL_TIM_BREAK2_FILTER_FDIV16_N5         0x00A00000U   /*!< fSAMPLING=fDTS/16, N=5 */
N#define LL_TIM_BREAK2_FILTER_FDIV16_N6         0x00B00000U   /*!< fSAMPLING=fDTS/16, N=6 */
N#define LL_TIM_BREAK2_FILTER_FDIV16_N8         0x00C00000U   /*!< fSAMPLING=fDTS/16, N=8 */
N#define LL_TIM_BREAK2_FILTER_FDIV32_N5         0x00D00000U   /*!< fSAMPLING=fDTS/32, N=5 */
N#define LL_TIM_BREAK2_FILTER_FDIV32_N6         0x00E00000U   /*!< fSAMPLING=fDTS/32, N=6 */
N#define LL_TIM_BREAK2_FILTER_FDIV32_N8         0x00F00000U   /*!< fSAMPLING=fDTS/32, N=8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_OSSI OSSI
N  * @{
N  */
N#define LL_TIM_OSSI_DISABLE                    0x00000000U             /*!< When inactive, OCx/OCxN outputs are disabled */
N#define LL_TIM_OSSI_ENABLE                     TIM_BDTR_OSSI           /*!< When inactive, OxC/OCxN outputs are first forced with their inactive level then forced to their idle level after the deadtime */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_OSSR OSSR
N  * @{
N  */
N#define LL_TIM_OSSR_DISABLE                    0x00000000U             /*!< When inactive, OCx/OCxN outputs are disabled */
N#define LL_TIM_OSSR_ENABLE                     TIM_BDTR_OSSR           /*!< When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BREAK_INPUT BREAK INPUT
N  * @{
N  */
N#define LL_TIM_BREAK_INPUT_BKIN                0x00000000U  /*!< TIMx_BKIN input */
N#define LL_TIM_BREAK_INPUT_BKIN2               0x00000004U  /*!< TIMx_BKIN2 input */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BKIN_SOURCE BKIN SOURCE
N  * @{
N  */
N#define LL_TIM_BKIN_SOURCE_BKIN                TIM1_OR2_BKINE      /*!< BKIN input from AF controller */
N#define LL_TIM_BKIN_SOURCE_BKCOMP1             TIM1_OR2_BKCMP1E    /*!< internal signal: COMP1 output */
N#define LL_TIM_BKIN_SOURCE_BKCOMP2             TIM1_OR2_BKCMP2E    /*!< internal signal: COMP2 output */
N#if defined(DFSDM1_Channel0)
X#if 0L
S#define LL_TIM_BKIN_SOURCE_DF1BK               TIM1_OR2_BKDF1BK0E  /*!< internal signal: DFSDM1 break output */
N#endif /* DFSDM1_Channel0 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_BKIN_POLARITY BKIN POLARITY
N  * @{
N  */
N#define LL_TIM_BKIN_POLARITY_LOW               TIM1_OR2_BKINP           /*!< BRK BKIN input is active low */
N#define LL_TIM_BKIN_POLARITY_HIGH              0x00000000U              /*!< BRK BKIN input is active high */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_DMABURST_BASEADDR DMA Burst Base Address
N  * @{
N  */
N#define LL_TIM_DMABURST_BASEADDR_CR1           0x00000000U                                                      /*!< TIMx_CR1 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CR2           TIM_DCR_DBA_0                                                    /*!< TIMx_CR2 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_SMCR          TIM_DCR_DBA_1                                                    /*!< TIMx_SMCR register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_DIER          (TIM_DCR_DBA_1 |  TIM_DCR_DBA_0)                                 /*!< TIMx_DIER register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_SR            TIM_DCR_DBA_2                                                    /*!< TIMx_SR register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_EGR           (TIM_DCR_DBA_2 | TIM_DCR_DBA_0)                                  /*!< TIMx_EGR register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCMR1         (TIM_DCR_DBA_2 | TIM_DCR_DBA_1)                                  /*!< TIMx_CCMR1 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCMR2         (TIM_DCR_DBA_2 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)                  /*!< TIMx_CCMR2 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCER          TIM_DCR_DBA_3                                                    /*!< TIMx_CCER register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CNT           (TIM_DCR_DBA_3 | TIM_DCR_DBA_0)                                  /*!< TIMx_CNT register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_PSC           (TIM_DCR_DBA_3 | TIM_DCR_DBA_1)                                  /*!< TIMx_PSC register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_ARR           (TIM_DCR_DBA_3 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)                  /*!< TIMx_ARR register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_RCR           (TIM_DCR_DBA_3 | TIM_DCR_DBA_2)                                  /*!< TIMx_RCR register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCR1          (TIM_DCR_DBA_3 | TIM_DCR_DBA_2 | TIM_DCR_DBA_0)                  /*!< TIMx_CCR1 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCR2          (TIM_DCR_DBA_3 | TIM_DCR_DBA_2 | TIM_DCR_DBA_1)                  /*!< TIMx_CCR2 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCR3          (TIM_DCR_DBA_3 | TIM_DCR_DBA_2 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)  /*!< TIMx_CCR3 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCR4          TIM_DCR_DBA_4                                                    /*!< TIMx_CCR4 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_BDTR          (TIM_DCR_DBA_4 | TIM_DCR_DBA_0)                                  /*!< TIMx_BDTR register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCMR3         (TIM_DCR_DBA_4 | TIM_DCR_DBA_1)                                  /*!< TIMx_CCMR3 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCR5          (TIM_DCR_DBA_4 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)                  /*!< TIMx_CCR5 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_CCR6          (TIM_DCR_DBA_4 | TIM_DCR_DBA_2)                                  /*!< TIMx_CCR6 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_OR1           (TIM_DCR_DBA_4 | TIM_DCR_DBA_2 | TIM_DCR_DBA_0)                  /*!< TIMx_OR1 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_OR2           (TIM_DCR_DBA_4 | TIM_DCR_DBA_2 | TIM_DCR_DBA_1)                  /*!< TIMx_OR2 register is the DMA base address for DMA burst */
N#define LL_TIM_DMABURST_BASEADDR_OR3           (TIM_DCR_DBA_4 | TIM_DCR_DBA_2 | TIM_DCR_DBA_1 | TIM_DCR_DBA_0)  /*!< TIMx_OR3 register is the DMA base address for DMA burst */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_DMABURST_LENGTH DMA Burst Length
N  * @{
N  */
N#define LL_TIM_DMABURST_LENGTH_1TRANSFER       0x00000000U                                                     /*!< Transfer is done to 1 register starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_2TRANSFERS      TIM_DCR_DBL_0                                                   /*!< Transfer is done to 2 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_3TRANSFERS      TIM_DCR_DBL_1                                                   /*!< Transfer is done to 3 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_4TRANSFERS      (TIM_DCR_DBL_1 |  TIM_DCR_DBL_0)                                /*!< Transfer is done to 4 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_5TRANSFERS      TIM_DCR_DBL_2                                                   /*!< Transfer is done to 5 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_6TRANSFERS      (TIM_DCR_DBL_2 | TIM_DCR_DBL_0)                                 /*!< Transfer is done to 6 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_7TRANSFERS      (TIM_DCR_DBL_2 | TIM_DCR_DBL_1)                                 /*!< Transfer is done to 7 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_8TRANSFERS      (TIM_DCR_DBL_2 | TIM_DCR_DBL_1 | TIM_DCR_DBL_0)                 /*!< Transfer is done to 1 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_9TRANSFERS      TIM_DCR_DBL_3                                                   /*!< Transfer is done to 9 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_10TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_0)                                 /*!< Transfer is done to 10 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_11TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_1)                                 /*!< Transfer is done to 11 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_12TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_1 | TIM_DCR_DBL_0)                 /*!< Transfer is done to 12 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_13TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2)                                 /*!< Transfer is done to 13 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_14TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2 | TIM_DCR_DBL_0)                 /*!< Transfer is done to 14 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_15TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2 | TIM_DCR_DBL_1)                 /*!< Transfer is done to 15 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_16TRANSFERS     (TIM_DCR_DBL_3 | TIM_DCR_DBL_2 | TIM_DCR_DBL_1 | TIM_DCR_DBL_0) /*!< Transfer is done to 16 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_17TRANSFERS     TIM_DCR_DBL_4                                                   /*!< Transfer is done to 17 registers starting from the DMA burst base address */
N#define LL_TIM_DMABURST_LENGTH_18TRANSFERS     (TIM_DCR_DBL_4 |  TIM_DCR_DBL_0)                                /*!< Transfer is done to 18 registers starting from the DMA burst base address */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TIM1_ETR_ADC1_RMP  TIM1 External Trigger ADC1 Remap
N  * @{
N  */
N#define LL_TIM_TIM1_ETR_ADC1_RMP_NC   TIM1_OR1_RMP_MASK                                                /*!< TIM1_ETR is not connected to ADC1 analog watchdog x */
N#define LL_TIM_TIM1_ETR_ADC1_RMP_AWD1 (TIM1_OR1_ETR_ADC1_RMP_0 | TIM1_OR1_RMP_MASK)                    /*!< TIM1_ETR is connected to ADC1 analog watchdog 1 */
N#define LL_TIM_TIM1_ETR_ADC1_RMP_AWD2 (TIM1_OR1_ETR_ADC1_RMP_1 | TIM1_OR1_RMP_MASK)                    /*!< TIM1_ETR is connected to ADC1 analog watchdog 2 */
N#define LL_TIM_TIM1_ETR_ADC1_RMP_AWD3 (TIM1_OR1_ETR_ADC1_RMP | TIM1_OR1_RMP_MASK)                      /*!< TIM1_ETR is connected to ADC1 analog watchdog 3 */
N/**
N  * @}
N  */
N
N#if defined(ADC3)
X#if 0L
S/** @defgroup TIM_LL_EC_TIM1_ETR_ADC3_RMP  TIM1 External Trigger ADC3 Remap
S  * @{
S  */
S#define LL_TIM_TIM1_ETR_ADC3_RMP_NC   TIM1_OR1_RMP_MASK                                                /*!< TIM1_ETR is not connected to ADC3 analog watchdog  x*/
S#define LL_TIM_TIM1_ETR_ADC3_RMP_AWD1 (TIM1_OR1_ETR_ADC3_RMP_0 | TIM1_OR1_RMP_MASK)                    /*!< TIM1_ETR is connected to ADC3 analog watchdog 1 */
S#define LL_TIM_TIM1_ETR_ADC3_RMP_AWD2 (TIM1_OR1_ETR_ADC3_RMP_1 | TIM1_OR1_RMP_MASK)                    /*!< TIM1_ETR is connected to ADC3 analog watchdog 2 */
S#define LL_TIM_TIM1_ETR_ADC3_RMP_AWD3 (TIM1_OR1_ETR_ADC3_RMP | TIM1_OR1_RMP_MASK)                      /*!< TIM1_ETR is connected to ADC3 analog watchdog 3 */
S/**
S  * @}
S  */
N#endif /* ADC3 */
N
N/** @defgroup TIM_LL_EC_TIM1_TI1_RMP  TIM1 External Input Ch1 Remap
N  * @{
N  */
N#define LL_TIM_TIM1_TI1_RMP_GPIO  TIM1_OR1_RMP_MASK                                                    /*!< TIM1 input capture 1 is connected to GPIO */
N#define LL_TIM_TIM1_TI1_RMP_COMP1 (TIM1_OR1_TI1_RMP | TIM1_OR1_RMP_MASK)                               /*!< TIM1 input capture 1 is connected to COMP1 output */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TIM2_ITR1_RMP  TIM2 Internal Trigger1 Remap
N  * @{
N  */
N#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || defined (STM32L496xx) || defined (STM32L4A6xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined(STM32L4S9xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L
S#define LL_TIM_TIM2_ITR1_RMP_TIM8_TRGO  TIM2_OR1_RMP_MASK                                              /*!< TIM2_ITR1 is connected to TIM8_TRGO */
S#define LL_TIM_TIM2_ITR1_RMP_OTG_FS_SOF (TIM2_OR1_ITR1_RMP | TIM2_OR1_RMP_MASK)                        /*!< TIM2_ITR1 is connected to OTG_FS SOF */
N#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx || */
N       /* STM32L496xx || STM32L4A6xx || */
N       /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
N#if defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx)
X#if 1L || 0L || 0L || 0L || 0L || 0L || 0L || 0L
N#define LL_TIM_TIM2_ITR1_RMP_NONE          0x00000000U                                                 /* !< No internal trigger on TIM2_ITR1 */
N#define LL_TIM_TIM2_ITR1_RMP_USB_SOF       TIM2_OR1_ITR1_RMP                                           /* !< TIM2_ITR1 is connected to USB SOF */
N#endif /* STM32L431xx || STM32L432xx || STM32L442xx || STM32L433xx || STM32L443xx || */
N       /* STM32L451xx || STM32L452xx || STM32L462xx */
N#define LL_TIM_TIM2_ETR_RMP_GPIO TIM2_OR1_RMP_MASK                                                     /*!< TIM2_ETR is connected to GPIO */
N#define LL_TIM_TIM2_ETR_RMP_LSE  (TIM2_OR1_ETR1_RMP | TIM2_OR1_RMP_MASK)                               /*!< TIM2_ETR is connected to LSE  */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TIM2_TI4_RMP  TIM2 External Input Ch4 Remap
N  * @{
N  */
N#define LL_TIM_TIM2_TI4_RMP_GPIO        TIM2_OR1_RMP_MASK                                              /*!< TIM2 input capture 4 is connected to GPIO */
N#define LL_TIM_TIM2_TI4_RMP_COMP1       (TIM2_OR1_TI4_RMP_0 | TIM2_OR1_RMP_MASK)                       /*!< TIM2 input capture 4 is connected to COMP1_OUT */
N#define LL_TIM_TIM2_TI4_RMP_COMP2       (TIM2_OR1_TI4_RMP_1 | TIM2_OR1_RMP_MASK)                       /*!< TIM2 input capture 4 is connected to COMP2_OUT */
N#define LL_TIM_TIM2_TI4_RMP_COMP1_COMP2 (TIM2_OR1_TI4_RMP | TIM2_OR1_RMP_MASK)                         /*!< TIM2 input capture 4 is connected to logical OR between COMP1_OUT and COMP2_OUT */
N/**
N  * @}
N  */
N
N#if defined(TIM3)
X#if 0L
S/** @defgroup TIM_LL_EC_TIM3_TI1_RMP  TIM3 External Input Ch1 Remap
S  * @{
S  */
S#define LL_TIM_TIM3_TI1_RMP_GPIO         TIM3_OR1_RMP_MASK                                             /*!< TIM3 input capture 1 is connected to GPIO */
S#define LL_TIM_TIM3_TI1_RMP_COMP1        (TIM3_OR1_TI1_RMP_0 | TIM3_OR1_RMP_MASK)                      /*!< TIM3 input capture 1 is connected to COMP1_OUT */
S#define LL_TIM_TIM3_TI1_RMP_COMP2        (TIM3_OR1_TI1_RMP_1 | TIM3_OR1_RMP_MASK)                      /*!< TIM3 input capture 1 is connected to COMP2_OUT */
S#define LL_TIM_TIM3_TI1_RMP_COMP1_COMP2  (TIM3_OR1_TI1_RMP | TIM3_OR1_RMP_MASK)                        /*!< TIM3 input capture 1 is connected to logical OR between COMP1_OUT and COMP2_OUT */
S/**
S  * @}
S  */
N#endif /* TIM3 */
N
N#if defined(TIM8)
X#if 0L
S/** @defgroup TIM_LL_EC_TIM8_ETR_ADC2_RMP  TIM8 External Trigger ADC2 Remap
S  * @{
S  */
S#define LL_TIM_TIM8_ETR_ADC2_RMP_NC   TIM8_OR1_RMP_MASK                                                /*!< TIM8_ETR is not connected to ADC2 analog watchdog x */
S#define LL_TIM_TIM8_ETR_ADC2_RMP_AWD1 (TIM8_OR1_ETR_ADC2_RMP_0 | TIM8_OR1_RMP_MASK)                    /*!< TIM8_ETR is connected to ADC2 analog watchdog */
S#define LL_TIM_TIM8_ETR_ADC2_RMP_AWD2 (TIM8_OR1_ETR_ADC2_RMP_1 | TIM8_OR1_RMP_MASK)                    /*!< TIM8_ETR is connected to ADC2 analog watchdog 2 */
S#define LL_TIM_TIM8_ETR_ADC2_RMP_AWD3 (TIM8_OR1_ETR_ADC2_RMP | TIM8_OR1_RMP_MASK)                      /*!< TIM8_ETR is connected to ADC2 analog watchdog 3 */
S/**
S  * @}
S  */
S
S/** @defgroup TIM_LL_EC_TIM8_ETR_ADC3_RMP  TIM8 External Trigger ADC3 Remap
S  * @{
S  */
S#define LL_TIM_TIM8_ETR_ADC3_RMP_NC   TIM8_OR1_RMP_MASK                                                /*!< TIM8_ETR is not connected to ADC3 analog watchdog x */
S#define LL_TIM_TIM8_ETR_ADC3_RMP_AWD1 (TIM8_OR1_ETR_ADC3_RMP_0 | TIM8_OR1_RMP_MASK)                    /*!< TIM8_ETR is connected to ADC3 analog watchdog 1 */
S#define LL_TIM_TIM8_ETR_ADC3_RMP_AWD2 (TIM8_OR1_ETR_ADC3_RMP_1 | TIM8_OR1_RMP_MASK)                    /*!< TIM8_ETR is connected to ADC3 analog watchdog 2 */
S#define LL_TIM_TIM8_ETR_ADC3_RMP_AWD3 (TIM8_OR1_ETR_ADC3_RMP | TIM8_OR1_RMP_MASK)                      /*!< TIM8_ETR is connected to ADC3 analog watchdog 3 */
S/**
S  * @}
S  */
S
S/** @defgroup TIM_LL_EC_TIM8_TI1_RMP  TIM8 External Input Ch1 Remap
S  * @{
S  */
S#define LL_TIM_TIM8_TI1_RMP_GPIO  TIM8_OR1_RMP_MASK                                                    /*!< TIM8 input capture 1 is connected to GPIO */
S#define LL_TIM_TIM8_TI1_RMP_COMP2 (TIM8_OR1_TI1_RMP | TIM8_OR1_RMP_MASK)                               /*!< TIM8 input capture 1 is connected to COMP2 output */
S/**
S  * @}
S  */
N#endif /* TIM8 */
N
N/** @defgroup TIM_LL_EC_TIM15_TI1_RMP  TIM15 External Input Ch1 Remap
N  * @{
N  */
N#define LL_TIM_TIM15_TI1_RMP_GPIO TIM15_OR1_RMP_MASK                                                   /*!< TIM15 input capture 1 is connected to GPIO */
N#define LL_TIM_TIM15_TI1_RMP_LSE  (TIM15_OR1_TI1_RMP | TIM15_OR1_RMP_MASK)                             /*!< TIM15 input capture 1 is connected to LSE */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TIM15_ENCODERMODE  TIM15 ENCODERMODE
N  * @{
N  */
N#define LL_TIM_TIM15_ENCODERMODE_NOREDIRECTION TIM15_OR1_RMP_MASK                                      /*!< No redirection*/
N#define LL_TIM_TIM15_ENCODERMODE_TIM2          (TIM15_OR1_ENCODER_MODE_0 | TIM15_OR1_RMP_MASK)         /*!< TIM2 IC1 and TIM2 IC2 are connected to TIM15 IC1 and TIM15 IC2 respectively */
N#define LL_TIM_TIM15_ENCODERMODE_TIM3          (TIM15_OR1_ENCODER_MODE_1 | TIM15_OR1_RMP_MASK)         /*!< TIM3 IC1 and TIM3 IC2 are connected to TIM15 IC1 and TIM15 IC2 respectivel y*/
N#define LL_TIM_TIM15_ENCODERMODE_TIM4          (TIM15_OR1_ENCODER_MODE | TIM15_OR1_RMP_MASK)           /*!< TIM4 IC1 and TIM4 IC2 are connected to TIM15 IC1 and TIM15 IC2 respectively */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EC_TIM16_TI1_RMP  TIM16 External Input Ch1 Remap
N  * @{
N  */
N#define LL_TIM_TIM16_TI1_RMP_GPIO TIM16_OR1_RMP_MASK                                                   /*!< TIM16 input capture 1 is connected to GPIO */
N#define LL_TIM_TIM16_TI1_RMP_LSI  (TIM16_OR1_TI1_RMP_0 | TIM16_OR1_RMP_MASK)                           /*!< TIM16 input capture 1 is connected to LSI */
N#define LL_TIM_TIM16_TI1_RMP_LSE  (TIM16_OR1_TI1_RMP_1 | TIM16_OR1_RMP_MASK)                           /*!< TIM16 input capture 1 is connected to LSE */
N#define LL_TIM_TIM16_TI1_RMP_RTC  (TIM16_OR1_TI1_RMP_1 | TIM16_OR1_TI1_RMP_0 | TIM16_OR1_RMP_MASK)     /*!< TIM16 input capture 1 is connected to RTC wakeup interrupt */
N#if defined TIM16_OR1_TI1_RMP_2
X#if 1L
N#define LL_TIM_TIM16_TI1_RMP_MSI     (TIM16_OR1_TI1_RMP_2 | TIM16_OR1_RMP_MASK)                           /*!< TIM16 input capture 1 is connected to MSI */
N#define LL_TIM_TIM16_TI1_RMP_HSE_32  (TIM16_OR1_TI1_RMP_2 | TIM16_OR1_TI1_RMP_0 | TIM16_OR1_RMP_MASK)     /*!< TIM16 input capture 1 is connected to HSE/32 */
N#define LL_TIM_TIM16_TI1_RMP_MCO     (TIM16_OR1_TI1_RMP_2 | TIM16_OR1_TI1_RMP_1 | TIM16_OR1_RMP_MASK)     /*!< TIM16 input capture 1 is connected to MCO */
N#endif
N/**
N  * @}
N  */
N
N#if defined(TIM17)
X#if 0L
S/** @defgroup TIM_LL_EC_TIM17_TI1_RMP  TIM17 Timer Input Ch1 Remap
S  * @{
S  */
S#define LL_TIM_TIM17_TI1_RMP_GPIO   TIM17_OR1_RMP_MASK                                                 /*!< TIM17 input capture 1 is connected to GPIO */
S#define LL_TIM_TIM17_TI1_RMP_MSI    (TIM17_OR1_TI1_RMP_0 | TIM17_OR1_RMP_MASK)                         /*!< TIM17 input capture 1 is connected to MSI */
S#define LL_TIM_TIM17_TI1_RMP_HSE_32 (TIM17_OR1_TI1_RMP_1 | TIM17_OR1_RMP_MASK)                         /*!< TIM17 input capture 1 is connected to HSE/32 */
S#define LL_TIM_TIM17_TI1_RMP_MCO    (TIM17_OR1_TI1_RMP | TIM17_OR1_RMP_MASK)                           /*!< TIM17 input capture 1 is connected to MCO */
S/**
S  * @}
S  */
N#endif /* TIM17 */
N
N/** @defgroup TIM_LL_EC_OCREF_CLR_INT OCREF clear input selection
N  * @{
N  */
N#define LL_TIM_OCREF_CLR_INT_NC     0x00000000U         /*!< OCREF_CLR_INT is not connected */
N#define LL_TIM_OCREF_CLR_INT_ETR    TIM_SMCR_OCCS       /*!< OCREF_CLR_INT is connected to ETRF */
N/**
N  * @}
N  */
N
N/** Legacy definitions for compatibility purpose
N@cond 0
N*/
N#define LL_TIM_BKIN_SOURCE_DFBK  LL_TIM_BKIN_SOURCE_DF1BK
N/**
N@endcond
N  */
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup TIM_LL_Exported_Macros TIM Exported Macros
N  * @{
N  */
N
N/** @defgroup TIM_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N/**
N  * @brief  Write a value in TIM register.
N  * @param  __INSTANCE__ TIM Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_TIM_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG((__INSTANCE__)->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in TIM register.
N  * @param  __INSTANCE__ TIM Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_TIM_ReadReg(__INSTANCE__, __REG__) READ_REG((__INSTANCE__)->__REG__)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EM_Exported_Macros Exported_Macros
N  * @{
N  */
N
N/**
N  * @brief  HELPER macro retrieving the UIFCPY flag from the counter value.
N  * @note ex: @ref __LL_TIM_GETFLAG_UIFCPY (@ref LL_TIM_GetCounter ());
N  * @note  Relevant only if UIF flag remapping has been enabled  (UIF status bit is copied
N  *        to TIMx_CNT register bit 31)
N  * @param  __CNT__ Counter value
N  * @retval UIF status bit
N  */
N#define __LL_TIM_GETFLAG_UIFCPY(__CNT__)  \
N   (READ_BIT((__CNT__), TIM_CNT_UIFCPY) >> TIM_CNT_UIFCPY_Pos)
X#define __LL_TIM_GETFLAG_UIFCPY(__CNT__)     (READ_BIT((__CNT__), TIM_CNT_UIFCPY) >> TIM_CNT_UIFCPY_Pos)
N
N/**
N  * @brief  HELPER macro calculating DTG[0:7] in the TIMx_BDTR register to achieve the requested dead time duration.
N  * @note ex: @ref __LL_TIM_CALC_DEADTIME (80000000, @ref LL_TIM_GetClockDivision (), 120);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __CKD__ This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
N  * @param  __DT__ deadtime duration (in ns)
N  * @retval DTG[0:7]
N  */
N#define __LL_TIM_CALC_DEADTIME(__TIMCLK__, __CKD__, __DT__)  \
N    ( (((uint64_t)((__DT__)*1000U)) < ((DT_DELAY_1+1U) * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))           ? (uint8_t)(((uint64_t)((__DT__)*1000U) / TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  & DT_DELAY_1) :                                               \
N      (((uint64_t)((__DT__)*1000U)) < (64U + (DT_DELAY_2+1U)) * 2U * TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  ? (uint8_t)(DT_RANGE_2 | ((uint8_t)((uint8_t)((((uint64_t)((__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 1U) - (uint8_t) 64) & DT_DELAY_2)) :\
N      (((uint64_t)((__DT__)*1000U)) < (32U + (DT_DELAY_3+1U)) * 8U * TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  ? (uint8_t)(DT_RANGE_3 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 3U) - (uint8_t) 32) & DT_DELAY_3)) :\
N      (((uint64_t)((__DT__)*1000U)) < (32U + (DT_DELAY_4+1U)) * 16U * TIM_CALC_DTS((__TIMCLK__), (__CKD__))) ? (uint8_t)(DT_RANGE_4 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 4U) - (uint8_t) 32) & DT_DELAY_4)) :\
N       0U)
X#define __LL_TIM_CALC_DEADTIME(__TIMCLK__, __CKD__, __DT__)      ( (((uint64_t)((__DT__)*1000U)) < ((DT_DELAY_1+1U) * TIM_CALC_DTS((__TIMCLK__), (__CKD__))))           ? (uint8_t)(((uint64_t)((__DT__)*1000U) / TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  & DT_DELAY_1) :                                                     (((uint64_t)((__DT__)*1000U)) < (64U + (DT_DELAY_2+1U)) * 2U * TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  ? (uint8_t)(DT_RANGE_2 | ((uint8_t)((uint8_t)((((uint64_t)((__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 1U) - (uint8_t) 64) & DT_DELAY_2)) :      (((uint64_t)((__DT__)*1000U)) < (32U + (DT_DELAY_3+1U)) * 8U * TIM_CALC_DTS((__TIMCLK__), (__CKD__)))  ? (uint8_t)(DT_RANGE_3 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 3U) - (uint8_t) 32) & DT_DELAY_3)) :      (((uint64_t)((__DT__)*1000U)) < (32U + (DT_DELAY_4+1U)) * 16U * TIM_CALC_DTS((__TIMCLK__), (__CKD__))) ? (uint8_t)(DT_RANGE_4 | ((uint8_t)((uint8_t)(((((uint64_t)(__DT__)*1000U))/ TIM_CALC_DTS((__TIMCLK__), (__CKD__))) >> 4U) - (uint8_t) 32) & DT_DELAY_4)) :       0U)
N
N/**
N  * @brief  HELPER macro calculating the prescaler value to achieve the required counter clock frequency.
N  * @note ex: @ref __LL_TIM_CALC_PSC (80000000, 1000000);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __CNTCLK__ counter clock frequency (in Hz)
N  * @retval Prescaler value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __LL_TIM_CALC_PSC(__TIMCLK__, __CNTCLK__)   \
N   ((__TIMCLK__) >= (__CNTCLK__)) ? (uint32_t)((__TIMCLK__)/(__CNTCLK__) - 1U) : 0U
X#define __LL_TIM_CALC_PSC(__TIMCLK__, __CNTCLK__)      ((__TIMCLK__) >= (__CNTCLK__)) ? (uint32_t)((__TIMCLK__)/(__CNTCLK__) - 1U) : 0U
N
N/**
N  * @brief  HELPER macro calculating the auto-reload value to achieve the required output signal frequency.
N  * @note ex: @ref __LL_TIM_CALC_ARR (1000000, @ref LL_TIM_GetPrescaler (), 10000);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __PSC__ prescaler
N  * @param  __FREQ__ output signal frequency (in Hz)
N  * @retval  Auto-reload value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __LL_TIM_CALC_ARR(__TIMCLK__, __PSC__, __FREQ__) \
N     (((__TIMCLK__)/((__PSC__) + 1U)) >= (__FREQ__)) ? ((__TIMCLK__)/((__FREQ__) * ((__PSC__) + 1U)) - 1U) : 0U
X#define __LL_TIM_CALC_ARR(__TIMCLK__, __PSC__, __FREQ__)      (((__TIMCLK__)/((__PSC__) + 1U)) >= (__FREQ__)) ? ((__TIMCLK__)/((__FREQ__) * ((__PSC__) + 1U)) - 1U) : 0U
N
N/**
N  * @brief  HELPER macro calculating the compare value required to achieve the required timer output compare active/inactive delay.
N  * @note ex: @ref __LL_TIM_CALC_DELAY (1000000, @ref LL_TIM_GetPrescaler (), 10);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __PSC__ prescaler
N  * @param  __DELAY__ timer output compare active/inactive delay (in us)
N  * @retval Compare value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __LL_TIM_CALC_DELAY(__TIMCLK__, __PSC__, __DELAY__)  \
N((uint32_t)(((uint64_t)(__TIMCLK__) * (uint64_t)(__DELAY__)) \
N          / ((uint64_t)1000000U * (uint64_t)((__PSC__) + 1U))))
X#define __LL_TIM_CALC_DELAY(__TIMCLK__, __PSC__, __DELAY__)  ((uint32_t)(((uint64_t)(__TIMCLK__) * (uint64_t)(__DELAY__))           / ((uint64_t)1000000U * (uint64_t)((__PSC__) + 1U))))
N
N/**
N  * @brief  HELPER macro calculating the auto-reload value to achieve the required pulse duration (when the timer operates in one pulse mode).
N  * @note ex: @ref __LL_TIM_CALC_PULSE (1000000, @ref LL_TIM_GetPrescaler (), 10, 20);
N  * @param  __TIMCLK__ timer input clock frequency (in Hz)
N  * @param  __PSC__ prescaler
N  * @param  __DELAY__ timer output compare active/inactive delay (in us)
N  * @param  __PULSE__ pulse duration (in us)
N  * @retval Auto-reload value  (between Min_Data=0 and Max_Data=65535)
N  */
N#define __LL_TIM_CALC_PULSE(__TIMCLK__, __PSC__, __DELAY__, __PULSE__)  \
N ((uint32_t)(__LL_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__PULSE__)) \
N           + __LL_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__DELAY__))))
X#define __LL_TIM_CALC_PULSE(__TIMCLK__, __PSC__, __DELAY__, __PULSE__)   ((uint32_t)(__LL_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__PULSE__))            + __LL_TIM_CALC_DELAY((__TIMCLK__), (__PSC__), (__DELAY__))))
N
N/**
N  * @brief  HELPER macro retrieving the ratio of the input capture prescaler
N  * @note ex: @ref __LL_TIM_GET_ICPSC_RATIO (@ref LL_TIM_IC_GetPrescaler ());
N  * @param  __ICPSC__ This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ICPSC_DIV1
N  *         @arg @ref LL_TIM_ICPSC_DIV2
N  *         @arg @ref LL_TIM_ICPSC_DIV4
N  *         @arg @ref LL_TIM_ICPSC_DIV8
N  * @retval Input capture prescaler ratio (1, 2, 4 or 8)
N  */
N#define __LL_TIM_GET_ICPSC_RATIO(__ICPSC__)  \
N   ((uint32_t)(0x01U << (((__ICPSC__) >> 16U) >> TIM_CCMR1_IC1PSC_Pos)))
X#define __LL_TIM_GET_ICPSC_RATIO(__ICPSC__)     ((uint32_t)(0x01U << (((__ICPSC__) >> 16U) >> TIM_CCMR1_IC1PSC_Pos)))
N
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup TIM_LL_Exported_Functions TIM Exported Functions
N  * @{
N  */
N
N/** @defgroup TIM_LL_EF_Time_Base Time Base configuration
N  * @{
N  */
N/**
N  * @brief  Enable timer counter.
N  * @rmtoll CR1          CEN           LL_TIM_EnableCounter
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableCounter(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableCounter(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
X  ((TIMx->CR1) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable timer counter.
N  * @rmtoll CR1          CEN           LL_TIM_DisableCounter
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableCounter(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableCounter(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
X  ((TIMx->CR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicates whether the timer counter is enabled.
N  * @rmtoll CR1          CEN           LL_TIM_IsEnabledCounter
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledCounter(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledCounter(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->CR1, TIM_CR1_CEN) == (TIM_CR1_CEN)) ? 1UL : 0UL);
X  return ((((TIMx->CR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable update event generation.
N  * @rmtoll CR1          UDIS          LL_TIM_EnableUpdateEvent
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableUpdateEvent(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableUpdateEvent(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->CR1, TIM_CR1_UDIS);
X  ((TIMx->CR1) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable update event generation.
N  * @rmtoll CR1          UDIS          LL_TIM_DisableUpdateEvent
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableUpdateEvent(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableUpdateEvent(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->CR1, TIM_CR1_UDIS);
X  ((TIMx->CR1) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicates whether update event generation is enabled.
N  * @rmtoll CR1          UDIS          LL_TIM_IsEnabledUpdateEvent
N  * @param  TIMx Timer instance
N  * @retval Inverted state of bit (0 or 1).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledUpdateEvent(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledUpdateEvent(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->CR1, TIM_CR1_UDIS) == (uint32_t)RESET) ? 1UL : 0UL);
X  return ((((TIMx->CR1) & ((0x1UL << (1U)))) == (uint32_t)RESET) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set update event source
N  * @note Update event source set to LL_TIM_UPDATESOURCE_REGULAR: any of the following events
N  *       generate an update interrupt or DMA request if enabled:
N  *        - Counter overflow/underflow
N  *        - Setting the UG bit
N  *        - Update generation through the slave mode controller
N  * @note Update event source set to LL_TIM_UPDATESOURCE_COUNTER: only counter
N  *       overflow/underflow generates an update interrupt or DMA request if enabled.
N  * @rmtoll CR1          URS           LL_TIM_SetUpdateSource
N  * @param  TIMx Timer instance
N  * @param  UpdateSource This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_UPDATESOURCE_REGULAR
N  *         @arg @ref LL_TIM_UPDATESOURCE_COUNTER
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetUpdateSource(TIM_TypeDef *TIMx, uint32_t UpdateSource)
Xstatic __inline void LL_TIM_SetUpdateSource(TIM_TypeDef *TIMx, uint32_t UpdateSource)
N{
N  MODIFY_REG(TIMx->CR1, TIM_CR1_URS, UpdateSource);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~((0x1UL << (2U))))) | (UpdateSource))));
N}
N
N/**
N  * @brief  Get actual event update source
N  * @rmtoll CR1          URS           LL_TIM_GetUpdateSource
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_UPDATESOURCE_REGULAR
N  *         @arg @ref LL_TIM_UPDATESOURCE_COUNTER
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetUpdateSource(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetUpdateSource(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_URS));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Set one pulse mode (one shot v.s. repetitive).
N  * @rmtoll CR1          OPM           LL_TIM_SetOnePulseMode
N  * @param  TIMx Timer instance
N  * @param  OnePulseMode This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ONEPULSEMODE_SINGLE
N  *         @arg @ref LL_TIM_ONEPULSEMODE_REPETITIVE
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetOnePulseMode(TIM_TypeDef *TIMx, uint32_t OnePulseMode)
Xstatic __inline void LL_TIM_SetOnePulseMode(TIM_TypeDef *TIMx, uint32_t OnePulseMode)
N{
N  MODIFY_REG(TIMx->CR1, TIM_CR1_OPM, OnePulseMode);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~((0x1UL << (3U))))) | (OnePulseMode))));
N}
N
N/**
N  * @brief  Get actual one pulse mode.
N  * @rmtoll CR1          OPM           LL_TIM_GetOnePulseMode
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_ONEPULSEMODE_SINGLE
N  *         @arg @ref LL_TIM_ONEPULSEMODE_REPETITIVE
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetOnePulseMode(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetOnePulseMode(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_OPM));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Set the timer counter counting mode.
N  * @note Macro @ref IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to
N  *       check whether or not the counter mode selection feature is supported
N  *       by a timer instance.
N  * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
N  *       requires a timer reset to avoid unexpected direction
N  *       due to DIR bit readonly in center aligned mode.
N  * @rmtoll CR1          DIR           LL_TIM_SetCounterMode\n
N  *         CR1          CMS           LL_TIM_SetCounterMode
N  * @param  TIMx Timer instance
N  * @param  CounterMode This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_COUNTERMODE_UP
N  *         @arg @ref LL_TIM_COUNTERMODE_DOWN
N  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP
N  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_DOWN
N  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
Xstatic __inline void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
N{
N  MODIFY_REG(TIMx->CR1, (TIM_CR1_DIR | TIM_CR1_CMS), CounterMode);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~(((0x1UL << (4U)) | (0x3UL << (5U)))))) | (CounterMode))));
N}
N
N/**
N  * @brief  Get actual counter mode.
N  * @note Macro @ref IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to
N  *       check whether or not the counter mode selection feature is supported
N  *       by a timer instance.
N  * @rmtoll CR1          DIR           LL_TIM_GetCounterMode\n
N  *         CR1          CMS           LL_TIM_GetCounterMode
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_COUNTERMODE_UP
N  *         @arg @ref LL_TIM_COUNTERMODE_DOWN
N  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP
N  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_DOWN
N  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetCounterMode(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetCounterMode(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (4U)) | (0x3UL << (5U)))));
N}
N
N/**
N  * @brief  Enable auto-reload (ARR) preload.
N  * @rmtoll CR1          ARPE          LL_TIM_EnableARRPreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableARRPreload(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableARRPreload(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
X  ((TIMx->CR1) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable auto-reload (ARR) preload.
N  * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->CR1,TIM_CR1_ARPE);
X  ((TIMx->CR1) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicates whether auto-reload (ARR) preload is enabled.
N  * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE)) ? 1UL : 0UL);
X  return ((((TIMx->CR1) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
N  * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
N  *       whether or not the clock division feature is supported by the timer
N  *       instance.
N  * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
N  * @param  TIMx Timer instance
N  * @param  ClockDivision This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
Xstatic __inline void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
N{
N  MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
X  (((TIMx->CR1)) = ((((((TIMx->CR1))) & (~((0x3UL << (8U))))) | (ClockDivision))));
N}
N
N/**
N  * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
N  * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
N  *       whether or not the clock division feature is supported by the timer
N  *       instance.
N  * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
N  *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
X  return (uint32_t)(((TIMx->CR1) & ((0x3UL << (8U)))));
N}
N
N/**
N  * @brief  Set the counter value.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @rmtoll CNT          CNT           LL_TIM_SetCounter
N  * @param  TIMx Timer instance
N  * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF or 0xFFFFFFFF)
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
Xstatic __inline void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
N{
N  WRITE_REG(TIMx->CNT, Counter);
X  ((TIMx->CNT) = (Counter));
N}
N
N/**
N  * @brief  Get the counter value.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @rmtoll CNT          CNT           LL_TIM_GetCounter
N  * @param  TIMx Timer instance
N  * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF or 0xFFFFFFFF)
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CNT));
X  return (uint32_t)(((TIMx->CNT)));
N}
N
N/**
N  * @brief  Get the current direction of the counter
N  * @rmtoll CR1          DIR           LL_TIM_GetDirection
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
N  *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
X  return (uint32_t)(((TIMx->CR1) & ((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Set the prescaler value.
N  * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
N  * @note The prescaler can be changed on the fly as this control register is buffered. The new
N  *       prescaler ratio is taken into account at the next update event.
N  * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
N  * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
N  * @param  TIMx Timer instance
N  * @param  Prescaler between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
Xstatic __inline void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
N{
N  WRITE_REG(TIMx->PSC, Prescaler);
X  ((TIMx->PSC) = (Prescaler));
N}
N
N/**
N  * @brief  Get the prescaler value.
N  * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
N  * @param  TIMx Timer instance
N  * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->PSC));
X  return (uint32_t)(((TIMx->PSC)));
N}
N
N/**
N  * @brief  Set the auto-reload value.
N  * @note The counter is blocked while the auto-reload value is null.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
N  * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
N  * @param  TIMx Timer instance
N  * @param  AutoReload between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
Xstatic __inline void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
N{
N  WRITE_REG(TIMx->ARR, AutoReload);
X  ((TIMx->ARR) = (AutoReload));
N}
N
N/**
N  * @brief  Get the auto-reload value.
N  * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @param  TIMx Timer instance
N  * @retval Auto-reload value
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->ARR));
X  return (uint32_t)(((TIMx->ARR)));
N}
N
N/**
N  * @brief  Set the repetition counter value.
N  * @note For advanced timer instances RepetitionCounter can be up to 65535.
N  * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a repetition counter.
N  * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
N  * @param  TIMx Timer instance
N  * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
Xstatic __inline void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
N{
N  WRITE_REG(TIMx->RCR, RepetitionCounter);
X  ((TIMx->RCR) = (RepetitionCounter));
N}
N
N/**
N  * @brief  Get the repetition counter value.
N  * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a repetition counter.
N  * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
N  * @param  TIMx Timer instance
N  * @retval Repetition counter value
N  */
N__STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->RCR));
X  return (uint32_t)(((TIMx->RCR)));
N}
N
N/**
N  * @brief  Force a continuous copy of the update interrupt flag (UIF) into the timer counter register (bit 31).
N  * @note This allows both the counter value and a potential roll-over condition signalled by the UIFCPY flag to be read in an atomic way.
N  * @rmtoll CR1          UIFREMAP      LL_TIM_EnableUIFRemap
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableUIFRemap(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableUIFRemap(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->CR1, TIM_CR1_UIFREMAP);
X  ((TIMx->CR1) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable update interrupt flag (UIF) remapping.
N  * @rmtoll CR1          UIFREMAP      LL_TIM_DisableUIFRemap
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableUIFRemap(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableUIFRemap(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->CR1, TIM_CR1_UIFREMAP);
X  ((TIMx->CR1) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
N  * @{
N  */
N/**
N  * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
N  * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
N  *       they are updated only when a commutation event (COM) occurs.
N  * @note Only on channels that have a complementary output.
N  * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance is able to generate a commutation event.
N  * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
X  ((TIMx->CR2) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
N  * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance is able to generate a commutation event.
N  * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
X  ((TIMx->CR2) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
N  * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance is able to generate a commutation event.
N  * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
N  * @param  TIMx Timer instance
N  * @param  CCUpdateSource This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
N  *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
Xstatic __inline void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
N{
N  MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0x1UL << (2U))))) | (CCUpdateSource))));
N}
N
N/**
N  * @brief  Set the trigger of the capture/compare DMA request.
N  * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
N  * @param  TIMx Timer instance
N  * @param  DMAReqTrigger This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CCDMAREQUEST_CC
N  *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
Xstatic __inline void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
N{
N  MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0x1UL << (3U))))) | (DMAReqTrigger))));
N}
N
N/**
N  * @brief  Get actual trigger of the capture/compare DMA request.
N  * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
N  * @param  TIMx Timer instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_CCDMAREQUEST_CC
N  *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
N  */
N__STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
X  return (uint32_t)(((TIMx->CR2) & ((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Set the lock level to freeze the
N  *         configuration of several capture/compare parameters.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       the lock mechanism is supported by a timer instance.
N  * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
N  * @param  TIMx Timer instance
N  * @param  LockLevel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_LOCKLEVEL_OFF
N  *         @arg @ref LL_TIM_LOCKLEVEL_1
N  *         @arg @ref LL_TIM_LOCKLEVEL_2
N  *         @arg @ref LL_TIM_LOCKLEVEL_3
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
Xstatic __inline void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
N{
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x3UL << (8U))))) | (LockLevel))));
N}
N
N/**
N  * @brief  Enable capture/compare channels.
N  * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
N  *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
N  *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
N  *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
N  *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
N  *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
N  *         CCER         CC4E          LL_TIM_CC_EnableChannel\n
N  *         CCER         CC5E          LL_TIM_CC_EnableChannel\n
N  *         CCER         CC6E          LL_TIM_CC_EnableChannel
N  * @param  TIMx Timer instance
N  * @param  Channels This parameter can be a combination of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
Xstatic __inline void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
N{
N  SET_BIT(TIMx->CCER, Channels);
X  ((TIMx->CCER) |= (Channels));
N}
N
N/**
N  * @brief  Disable capture/compare channels.
N  * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
N  *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
N  *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
N  *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
N  *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
N  *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
N  *         CCER         CC4E          LL_TIM_CC_DisableChannel\n
N  *         CCER         CC5E          LL_TIM_CC_DisableChannel\n
N  *         CCER         CC6E          LL_TIM_CC_DisableChannel
N  * @param  TIMx Timer instance
N  * @param  Channels This parameter can be a combination of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
Xstatic __inline void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
N{
N  CLEAR_BIT(TIMx->CCER, Channels);
X  ((TIMx->CCER) &= ~(Channels));
N}
N
N/**
N  * @brief  Indicate whether channel(s) is(are) enabled.
N  * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC5E          LL_TIM_CC_IsEnabledChannel\n
N  *         CCER         CC6E          LL_TIM_CC_IsEnabledChannel
N  * @param  TIMx Timer instance
N  * @param  Channels This parameter can be a combination of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
Xstatic __inline uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
N{
N  return ((READ_BIT(TIMx->CCER, Channels) == (Channels)) ? 1UL : 0UL);
X  return ((((TIMx->CCER) & (Channels)) == (Channels)) ? 1UL : 0UL);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
N  * @{
N  */
N/**
N  * @brief  Configure an output channel.
N  * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
N  *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
N  *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
N  *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
N  *         CCMR3        CC5S          LL_TIM_OC_ConfigOutput\n
N  *         CCMR3        CC6S          LL_TIM_OC_ConfigOutput\n
N  *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
N  *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
N  *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
N  *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
N  *         CCER         CC5P          LL_TIM_OC_ConfigOutput\n
N  *         CCER         CC6P          LL_TIM_OC_ConfigOutput\n
N  *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
N  *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
N  *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
N  *         CR2          OIS4          LL_TIM_OC_ConfigOutput\n
N  *         CR2          OIS5          LL_TIM_OC_ConfigOutput\n
N  *         CR2          OIS6          LL_TIM_OC_ConfigOutput
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @param  Configuration This parameter must be a combination of all the following values:
N  *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
N  *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
Xstatic __inline void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x3UL << (0U)) << SHIFT_TAB_OCxx[iChannel])));
N  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
N             (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~(((0x1UL << (1U)) << SHIFT_TAB_CCxP[iChannel])))) | ((Configuration & (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel]))));
N  MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
N             (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~(((0x1UL << (8U)) << SHIFT_TAB_OISx[iChannel])))) | ((Configuration & (0x1UL << (8U))) << SHIFT_TAB_OISx[iChannel]))));
N}
N
N/**
N  * @brief  Define the behavior of the output reference signal OCxREF from which
N  *         OCx and OCxN (when relevant) are derived.
N  * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
N  *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
N  *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
N  *         CCMR2        OC4M          LL_TIM_OC_SetMode\n
N  *         CCMR3        OC5M          LL_TIM_OC_SetMode\n
N  *         CCMR3        OC6M          LL_TIM_OC_SetMode
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_OCMODE_FROZEN
N  *         @arg @ref LL_TIM_OCMODE_ACTIVE
N  *         @arg @ref LL_TIM_OCMODE_INACTIVE
N  *         @arg @ref LL_TIM_OCMODE_TOGGLE
N  *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
N  *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
N  *         @arg @ref LL_TIM_OCMODE_PWM1
N  *         @arg @ref LL_TIM_OCMODE_PWM2
N  *         @arg @ref LL_TIM_OCMODE_RETRIG_OPM1
N  *         @arg @ref LL_TIM_OCMODE_RETRIG_OPM2
N  *         @arg @ref LL_TIM_OCMODE_COMBINED_PWM1
N  *         @arg @ref LL_TIM_OCMODE_COMBINED_PWM2
N  *         @arg @ref LL_TIM_OCMODE_ASSYMETRIC_PWM1
N  *         @arg @ref LL_TIM_OCMODE_ASSYMETRIC_PWM2
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
Xstatic __inline void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0x1007UL << (4U)) | (0x3UL << (0U))) << SHIFT_TAB_OCxx[iChannel])))) | (Mode << SHIFT_TAB_OCxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the output compare mode of an output channel.
N  * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
N  *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
N  *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
N  *         CCMR2        OC4M          LL_TIM_OC_GetMode\n
N  *         CCMR3        OC5M          LL_TIM_OC_GetMode\n
N  *         CCMR3        OC6M          LL_TIM_OC_GetMode
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_OCMODE_FROZEN
N  *         @arg @ref LL_TIM_OCMODE_ACTIVE
N  *         @arg @ref LL_TIM_OCMODE_INACTIVE
N  *         @arg @ref LL_TIM_OCMODE_TOGGLE
N  *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
N  *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
N  *         @arg @ref LL_TIM_OCMODE_PWM1
N  *         @arg @ref LL_TIM_OCMODE_PWM2
N  *         @arg @ref LL_TIM_OCMODE_RETRIG_OPM1
N  *         @arg @ref LL_TIM_OCMODE_RETRIG_OPM2
N  *         @arg @ref LL_TIM_OCMODE_COMBINED_PWM1
N  *         @arg @ref LL_TIM_OCMODE_COMBINED_PWM2
N  *         @arg @ref LL_TIM_OCMODE_ASSYMETRIC_PWM1
N  *         @arg @ref LL_TIM_OCMODE_ASSYMETRIC_PWM2
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
X  return (((*pReg) & ((((0x1007UL << (4U)) | (0x3UL << (0U))) << SHIFT_TAB_OCxx[iChannel]))) >> SHIFT_TAB_OCxx[iChannel]);
N}
N
N/**
N  * @brief  Set the polarity of an output channel.
N  * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
N  *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
N  *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
N  *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
N  *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
N  *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
N  *         CCER         CC4P          LL_TIM_OC_SetPolarity\n
N  *         CCER         CC5P          LL_TIM_OC_SetPolarity\n
N  *         CCER         CC6P          LL_TIM_OC_SetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_OCPOLARITY_HIGH
N  *         @arg @ref LL_TIM_OCPOLARITY_LOW
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
Xstatic __inline void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~(((0x1UL << (1U)) << SHIFT_TAB_CCxP[iChannel])))) | (Polarity << SHIFT_TAB_CCxP[iChannel]))));
N}
N
N/**
N  * @brief  Get the polarity of an output channel.
N  * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
N  *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
N  *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
N  *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
N  *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
N  *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
N  *         CCER         CC4P          LL_TIM_OC_GetPolarity\n
N  *         CCER         CC5P          LL_TIM_OC_GetPolarity\n
N  *         CCER         CC6P          LL_TIM_OC_GetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_OCPOLARITY_HIGH
N  *         @arg @ref LL_TIM_OCPOLARITY_LOW
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
X  return (((TIMx->CCER) & (((0x1UL << (1U)) << SHIFT_TAB_CCxP[iChannel]))) >> SHIFT_TAB_CCxP[iChannel]);
N}
N
N/**
N  * @brief  Set the IDLE state of an output channel
N  * @note This function is significant only for the timer instances
N  *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
N  *       can be used to check whether or not a timer instance provides
N  *       a break input.
N  * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS4          LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS5          LL_TIM_OC_SetIdleState\n
N  *         CR2         OIS6          LL_TIM_OC_SetIdleState
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @param  IdleState This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_OCIDLESTATE_LOW
N  *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
Xstatic __inline void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~(((0x1UL << (8U)) << SHIFT_TAB_OISx[iChannel])))) | (IdleState << SHIFT_TAB_OISx[iChannel]))));
N}
N
N/**
N  * @brief  Get the IDLE state of an output channel
N  * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS4          LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS5          LL_TIM_OC_GetIdleState\n
N  *         CR2         OIS6          LL_TIM_OC_GetIdleState
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH1N
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH2N
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH3N
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_OCIDLESTATE_LOW
N  *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
X  return (((TIMx->CR2) & (((0x1UL << (8U)) << SHIFT_TAB_OISx[iChannel]))) >> SHIFT_TAB_OISx[iChannel]);
N}
N
N/**
N  * @brief  Enable fast mode for the output channel.
N  * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
N  * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
N  *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
N  *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
N  *         CCMR2        OC4FE          LL_TIM_OC_EnableFast\n
N  *         CCMR3        OC5FE          LL_TIM_OC_EnableFast\n
N  *         CCMR3        OC6FE          LL_TIM_OC_EnableFast
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) |= (((0x1UL << (2U)) << SHIFT_TAB_OCxx[iChannel])));
N
N}
N
N/**
N  * @brief  Disable fast mode for the output channel.
N  * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
N  *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
N  *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
N  *         CCMR2        OC4FE          LL_TIM_OC_DisableFast\n
N  *         CCMR3        OC5FE          LL_TIM_OC_DisableFast\n
N  *         CCMR3        OC6FE          LL_TIM_OC_DisableFast
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x1UL << (2U)) << SHIFT_TAB_OCxx[iChannel])));
N
N}
N
N/**
N  * @brief  Indicates whether fast mode is enabled for the output channel.
N  * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
N  *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
N  *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
N  *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
N  *         CCMR3        OC5FE          LL_TIM_OC_IsEnabledFast\n
N  *         CCMR3        OC6FE          LL_TIM_OC_IsEnabledFast
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
X  register uint32_t bitfield = (0x1UL << (2U)) << SHIFT_TAB_OCxx[iChannel];
N  return ((READ_BIT(*pReg, bitfield) == bitfield) ? 1UL : 0UL);
X  return ((((*pReg) & (bitfield)) == bitfield) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
N  * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
N  *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
N  *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
N  *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload\n
N  *         CCMR3        OC5PE          LL_TIM_OC_EnablePreload\n
N  *         CCMR3        OC6PE          LL_TIM_OC_EnablePreload
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) |= (((0x1UL << (3U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
N  * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
N  *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
N  *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
N  *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload\n
N  *         CCMR3        OC5PE          LL_TIM_OC_DisablePreload\n
N  *         CCMR3        OC6PE          LL_TIM_OC_DisablePreload
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x1UL << (3U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
N  * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
N  *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
N  *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
N  *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
N  *         CCMR3        OC5PE          LL_TIM_OC_IsEnabledPreload\n
N  *         CCMR3        OC6PE          LL_TIM_OC_IsEnabledPreload
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
X  register uint32_t bitfield = (0x1UL << (3U)) << SHIFT_TAB_OCxx[iChannel];
N  return ((READ_BIT(*pReg, bitfield) == bitfield) ? 1UL : 0UL);
X  return ((((*pReg) & (bitfield)) == bitfield) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable clearing the output channel on an external event.
N  * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
N  * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance can clear the OCxREF signal on an external event.
N  * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
N  *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
N  *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
N  *         CCMR2        OC4CE          LL_TIM_OC_EnableClear\n
N  *         CCMR3        OC5CE          LL_TIM_OC_EnableClear\n
N  *         CCMR3        OC6CE          LL_TIM_OC_EnableClear
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) |= (((0x1UL << (7U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Disable clearing the output channel on an external event.
N  * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance can clear the OCxREF signal on an external event.
N  * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
N  *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
N  *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
N  *         CCMR2        OC4CE          LL_TIM_OC_DisableClear\n
N  *         CCMR3        OC5CE          LL_TIM_OC_DisableClear\n
N  *         CCMR3        OC6CE          LL_TIM_OC_DisableClear
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
X  ((*pReg) &= ~(((0x1UL << (7U)) << SHIFT_TAB_OCxx[iChannel])));
N}
N
N/**
N  * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
N  * @note This function enables clearing the output channel on an external event.
N  * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
N  * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance can clear the OCxREF signal on an external event.
N  * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
N  *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
N  *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
N  *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
N  *         CCMR3        OC5CE          LL_TIM_OC_IsEnabledClear\n
N  *         CCMR3        OC6CE          LL_TIM_OC_IsEnabledClear
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  *         @arg @ref LL_TIM_CHANNEL_CH5
N  *         @arg @ref LL_TIM_CHANNEL_CH6
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
X  register uint32_t bitfield = (0x1UL << (7U)) << SHIFT_TAB_OCxx[iChannel];
N  return ((READ_BIT(*pReg, bitfield) == bitfield) ? 1UL : 0UL);
X  return ((((*pReg) & (bitfield)) == bitfield) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge of the Ocx and OCxN signals).
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       dead-time insertion feature is supported by a timer instance.
N  * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
N  * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
N  * @param  TIMx Timer instance
N  * @param  DeadTime between Min_Data=0 and Max_Data=255
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
Xstatic __inline void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
N{
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0xFFUL << (0U))))) | (DeadTime))));
N}
N
N/**
N  * @brief  Set compare value for output channel 1 (TIMx_CCR1).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 1 is supported by a timer instance.
N  * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
Xstatic __inline void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
N{
N  WRITE_REG(TIMx->CCR1, CompareValue);
X  ((TIMx->CCR1) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 2 (TIMx_CCR2).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 2 is supported by a timer instance.
N  * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
Xstatic __inline void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
N{
N  WRITE_REG(TIMx->CCR2, CompareValue);
X  ((TIMx->CCR2) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 3 (TIMx_CCR3).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel is supported by a timer instance.
N  * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
Xstatic __inline void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
N{
N  WRITE_REG(TIMx->CCR3, CompareValue);
X  ((TIMx->CCR3) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 4 (TIMx_CCR4).
N  * @note In 32-bit timer implementations compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 4 is supported by a timer instance.
N  * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
Xstatic __inline void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
N{
N  WRITE_REG(TIMx->CCR4, CompareValue);
X  ((TIMx->CCR4) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 5 (TIMx_CCR5).
N  * @note Macro @ref IS_TIM_CC5_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 5 is supported by a timer instance.
N  * @rmtoll CCR5         CCR5          LL_TIM_OC_SetCompareCH5
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetCompareCH5(TIM_TypeDef *TIMx, uint32_t CompareValue)
Xstatic __inline void LL_TIM_OC_SetCompareCH5(TIM_TypeDef *TIMx, uint32_t CompareValue)
N{
N  WRITE_REG(TIMx->CCR5, CompareValue);
X  ((TIMx->CCR5) = (CompareValue));
N}
N
N/**
N  * @brief  Set compare value for output channel 6 (TIMx_CCR6).
N  * @note Macro @ref IS_TIM_CC6_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 6 is supported by a timer instance.
N  * @rmtoll CCR6         CCR6          LL_TIM_OC_SetCompareCH6
N  * @param  TIMx Timer instance
N  * @param  CompareValue between Min_Data=0 and Max_Data=65535
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_OC_SetCompareCH6(TIM_TypeDef *TIMx, uint32_t CompareValue)
Xstatic __inline void LL_TIM_OC_SetCompareCH6(TIM_TypeDef *TIMx, uint32_t CompareValue)
N{
N  WRITE_REG(TIMx->CCR6, CompareValue);
X  ((TIMx->CCR6) = (CompareValue));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 1 is supported by a timer instance.
N  * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR1));
X  return (uint32_t)(((TIMx->CCR1)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 2 is supported by a timer instance.
N  * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR2));
X  return (uint32_t)(((TIMx->CCR2)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 3 is supported by a timer instance.
N  * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR3));
X  return (uint32_t)(((TIMx->CCR3)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
N  * @note In 32-bit timer implementations returned compare value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 4 is supported by a timer instance.
N  * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR4));
X  return (uint32_t)(((TIMx->CCR4)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR5) set for  output channel 5.
N  * @note Macro @ref IS_TIM_CC5_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 5 is supported by a timer instance.
N  * @rmtoll CCR5         CCR5          LL_TIM_OC_GetCompareCH5
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH5(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_OC_GetCompareCH5(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR5));
X  return (uint32_t)(((TIMx->CCR5)));
N}
N
N/**
N  * @brief  Get compare value (TIMx_CCR6) set for  output channel 6.
N  * @note Macro @ref IS_TIM_CC6_INSTANCE(TIMx) can be used to check whether or not
N  *       output channel 6 is supported by a timer instance.
N  * @rmtoll CCR6         CCR6          LL_TIM_OC_GetCompareCH6
N  * @param  TIMx Timer instance
N  * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH6(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_OC_GetCompareCH6(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR6));
X  return (uint32_t)(((TIMx->CCR6)));
N}
N
N/**
N  * @brief  Select on which reference signal the OC5REF is combined to.
N  * @note Macro @ref IS_TIM_COMBINED3PHASEPWM_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports the combined 3-phase PWM mode.
N  * @rmtoll CCR5         GC5C3          LL_TIM_SetCH5CombinedChannels\n
N  *         CCR5         GC5C2          LL_TIM_SetCH5CombinedChannels\n
N  *         CCR5         GC5C1          LL_TIM_SetCH5CombinedChannels
N  * @param  TIMx Timer instance
N  * @param  GroupCH5 This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_GROUPCH5_NONE
N  *         @arg @ref LL_TIM_GROUPCH5_OC1REFC
N  *         @arg @ref LL_TIM_GROUPCH5_OC2REFC
N  *         @arg @ref LL_TIM_GROUPCH5_OC3REFC
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetCH5CombinedChannels(TIM_TypeDef *TIMx, uint32_t GroupCH5)
Xstatic __inline void LL_TIM_SetCH5CombinedChannels(TIM_TypeDef *TIMx, uint32_t GroupCH5)
N{
N  MODIFY_REG(TIMx->CCR5, TIM_CCR5_CCR5, GroupCH5);
X  (((TIMx->CCR5)) = ((((((TIMx->CCR5))) & (~((0xFFFFFFFFUL << (0U))))) | (GroupCH5))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
N  * @{
N  */
N/**
N  * @brief  Configure input channel.
N  * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
N  *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
N  *         CCMR1        IC1F          LL_TIM_IC_Config\n
N  *         CCMR1        CC2S          LL_TIM_IC_Config\n
N  *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
N  *         CCMR1        IC2F          LL_TIM_IC_Config\n
N  *         CCMR2        CC3S          LL_TIM_IC_Config\n
N  *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
N  *         CCMR2        IC3F          LL_TIM_IC_Config\n
N  *         CCMR2        CC4S          LL_TIM_IC_Config\n
N  *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
N  *         CCMR2        IC4F          LL_TIM_IC_Config\n
N  *         CCER         CC1P          LL_TIM_IC_Config\n
N  *         CCER         CC1NP         LL_TIM_IC_Config\n
N  *         CCER         CC2P          LL_TIM_IC_Config\n
N  *         CCER         CC2NP         LL_TIM_IC_Config\n
N  *         CCER         CC3P          LL_TIM_IC_Config\n
N  *         CCER         CC3NP         LL_TIM_IC_Config\n
N  *         CCER         CC4P          LL_TIM_IC_Config\n
N  *         CCER         CC4NP         LL_TIM_IC_Config
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @param  Configuration This parameter must be a combination of all the following values:
N  *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
N  *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
N  *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING or @ref LL_TIM_IC_POLARITY_BOTHEDGE
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
Xstatic __inline void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
N             ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0xFUL << (4U)) | (0x3UL << (2U)) | (0x3UL << (0U))) << SHIFT_TAB_ICxx[iChannel])))) | (((Configuration >> 16U) & ((0xFUL << (4U)) | (0x3UL << (2U)) | (0x3UL << (0U)))) << SHIFT_TAB_ICxx[iChannel]))));
N  MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
N             (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~((((0x1UL << (3U)) | (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel])))) | ((Configuration & ((0x1UL << (3U)) | (0x1UL << (1U)))) << SHIFT_TAB_CCxP[iChannel]))));
N}
N
N/**
N  * @brief  Set the active input.
N  * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
N  *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
N  *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
N  *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @param  ICActiveInput This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
N  *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
N  *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
Xstatic __inline void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0x3UL << (0U))) << SHIFT_TAB_ICxx[iChannel])))) | ((ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the current active input.
N  * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
N  *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
N  *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
N  *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
N  *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
N  *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
X  return ((((*pReg) & ((((0x3UL << (0U))) << SHIFT_TAB_ICxx[iChannel]))) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
N}
N
N/**
N  * @brief  Set the prescaler of input channel.
N  * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
N  *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
N  *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
N  *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @param  ICPrescaler This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ICPSC_DIV1
N  *         @arg @ref LL_TIM_ICPSC_DIV2
N  *         @arg @ref LL_TIM_ICPSC_DIV4
N  *         @arg @ref LL_TIM_ICPSC_DIV8
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
Xstatic __inline void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0x3UL << (2U))) << SHIFT_TAB_ICxx[iChannel])))) | ((ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the current prescaler value acting on an  input channel.
N  * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
N  *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
N  *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
N  *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_ICPSC_DIV1
N  *         @arg @ref LL_TIM_ICPSC_DIV2
N  *         @arg @ref LL_TIM_ICPSC_DIV4
N  *         @arg @ref LL_TIM_ICPSC_DIV8
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
X  return ((((*pReg) & ((((0x3UL << (2U))) << SHIFT_TAB_ICxx[iChannel]))) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
N}
N
N/**
N  * @brief  Set the input filter duration.
N  * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
N  *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
N  *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
N  *         CCMR2        IC4F          LL_TIM_IC_SetFilter
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @param  ICFilter This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
Xstatic __inline void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
X  (((*pReg)) = ((((((*pReg))) & (~((((0xFUL << (4U))) << SHIFT_TAB_ICxx[iChannel])))) | ((ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]))));
N}
N
N/**
N  * @brief  Get the input filter duration.
N  * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
N  *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
N  *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
N  *         CCMR2        IC4F          LL_TIM_IC_GetFilter
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
N  *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
N  return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
X  return ((((*pReg) & ((((0xFUL << (4U))) << SHIFT_TAB_ICxx[iChannel]))) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
N}
N
N/**
N  * @brief  Set the input channel polarity.
N  * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
N  *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
N  *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
N  *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
N  *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
N  *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
N  *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
N  *         CCER         CC4NP         LL_TIM_IC_SetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @param  ICPolarity This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_IC_POLARITY_RISING
N  *         @arg @ref LL_TIM_IC_POLARITY_FALLING
N  *         @arg @ref LL_TIM_IC_POLARITY_BOTHEDGE
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
Xstatic __inline void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
N             ICPolarity << SHIFT_TAB_CCxP[iChannel]);
X  (((TIMx->CCER)) = ((((((TIMx->CCER))) & (~((((0x1UL << (3U)) | (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel])))) | (ICPolarity << SHIFT_TAB_CCxP[iChannel]))));
N}
N
N/**
N  * @brief  Get the current input channel polarity.
N  * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
N  *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
N  *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
N  *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
N  *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
N  *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
N  *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
N  *         CCER         CC4NP         LL_TIM_IC_GetPolarity
N  * @param  TIMx Timer instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CHANNEL_CH1
N  *         @arg @ref LL_TIM_CHANNEL_CH2
N  *         @arg @ref LL_TIM_CHANNEL_CH3
N  *         @arg @ref LL_TIM_CHANNEL_CH4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_TIM_IC_POLARITY_RISING
N  *         @arg @ref LL_TIM_IC_POLARITY_FALLING
N  *         @arg @ref LL_TIM_IC_POLARITY_BOTHEDGE
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
Xstatic __inline uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
N{
N  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
X  register uint8_t iChannel = (((Channel) == (0x1UL << (0U))) ? 0U :((Channel) == (0x1UL << (2U))) ? 1U :((Channel) == (0x1UL << (4U))) ? 2U :((Channel) == (0x1UL << (6U))) ? 3U :((Channel) == (0x1UL << (8U))) ? 4U :((Channel) == (0x1UL << (10U))) ? 5U :((Channel) == (0x1UL << (12U))) ? 6U :((Channel) == (0x1UL << (16U))) ? 7U : 8U);
N  return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
X  return (((TIMx->CCER) & ((((0x1UL << (3U)) | (0x1UL << (1U))) << SHIFT_TAB_CCxP[iChannel]))) >>
N          SHIFT_TAB_CCxP[iChannel]);
N}
N
N/**
N  * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
N  * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides an XOR input.
N  * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
X  ((TIMx->CR2) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
N  * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides an XOR input.
N  * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
X  ((TIMx->CR2) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
N  * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
N  * a timer instance provides an XOR input.
N  * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S)) ? 1UL : 0UL);
X  return ((((TIMx->CR2) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get captured value for input channel 1.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 1 is supported by a timer instance.
N  * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR1));
X  return (uint32_t)(((TIMx->CCR1)));
N}
N
N/**
N  * @brief  Get captured value for input channel 2.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 2 is supported by a timer instance.
N  * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR2));
X  return (uint32_t)(((TIMx->CCR2)));
N}
N
N/**
N  * @brief  Get captured value for input channel 3.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 3 is supported by a timer instance.
N  * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR3));
X  return (uint32_t)(((TIMx->CCR3)));
N}
N
N/**
N  * @brief  Get captured value for input channel 4.
N  * @note In 32-bit timer implementations returned captured value can be between 0x00000000 and 0xFFFFFFFF.
N  * @note Macro @ref IS_TIM_32B_COUNTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports a 32 bits counter.
N  * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
N  *       input channel 4 is supported by a timer instance.
N  * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
N  * @param  TIMx Timer instance
N  * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
N  */
N__STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
N{
N  return (uint32_t)(READ_REG(TIMx->CCR4));
X  return (uint32_t)(((TIMx->CCR4)));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
N  * @{
N  */
N/**
N  * @brief  Enable external clock mode 2.
N  * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
N  * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
X  ((TIMx->SMCR) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable external clock mode 2.
N  * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
X  ((TIMx->SMCR) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate whether external clock mode 2 is enabled.
N  * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE)) ? 1UL : 0UL);
X  return ((((TIMx->SMCR) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set the clock source of the counter clock.
N  * @note when selected clock source is external clock mode 1, the timer input
N  *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
N  *       function. This timer input must be configured by calling
N  *       the @ref LL_TIM_IC_Config() function.
N  * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode1.
N  * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports external clock mode2.
N  * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
N  *         SMCR         ECE           LL_TIM_SetClockSource
N  * @param  TIMx Timer instance
N  * @param  ClockSource This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
N  *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
N  *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
Xstatic __inline void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
N{
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x10007UL << (0U)) | (0x1UL << (14U))))) | (ClockSource))));
N}
N
N/**
N  * @brief  Set the encoder interface mode.
N  * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance supports the encoder mode.
N  * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
N  * @param  TIMx Timer instance
N  * @param  EncoderMode This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
N  *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
N  *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
Xstatic __inline void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
N{
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x10007UL << (0U))))) | (EncoderMode))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
N  * @{
N  */
N/**
N  * @brief  Set the trigger output (TRGO) used for timer synchronization .
N  * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance can operate as a master timer.
N  * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
N  * @param  TIMx Timer instance
N  * @param  TimerSynchronization This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_TRGO_RESET
N  *         @arg @ref LL_TIM_TRGO_ENABLE
N  *         @arg @ref LL_TIM_TRGO_UPDATE
N  *         @arg @ref LL_TIM_TRGO_CC1IF
N  *         @arg @ref LL_TIM_TRGO_OC1REF
N  *         @arg @ref LL_TIM_TRGO_OC2REF
N  *         @arg @ref LL_TIM_TRGO_OC3REF
N  *         @arg @ref LL_TIM_TRGO_OC4REF
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
Xstatic __inline void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
N{
N  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0x7UL << (4U))))) | (TimerSynchronization))));
N}
N
N/**
N  * @brief  Set the trigger output 2 (TRGO2) used for ADC synchronization .
N  * @note Macro @ref IS_TIM_TRGO2_INSTANCE(TIMx) can be used to check
N  *       whether or not a timer instance can be used for ADC synchronization.
N  * @rmtoll CR2          MMS2          LL_TIM_SetTriggerOutput2
N  * @param  TIMx Timer Instance
N  * @param  ADCSynchronization This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_TRGO2_RESET
N  *         @arg @ref LL_TIM_TRGO2_ENABLE
N  *         @arg @ref LL_TIM_TRGO2_UPDATE
N  *         @arg @ref LL_TIM_TRGO2_CC1F
N  *         @arg @ref LL_TIM_TRGO2_OC1
N  *         @arg @ref LL_TIM_TRGO2_OC2
N  *         @arg @ref LL_TIM_TRGO2_OC3
N  *         @arg @ref LL_TIM_TRGO2_OC4
N  *         @arg @ref LL_TIM_TRGO2_OC5
N  *         @arg @ref LL_TIM_TRGO2_OC6
N  *         @arg @ref LL_TIM_TRGO2_OC4_RISINGFALLING
N  *         @arg @ref LL_TIM_TRGO2_OC6_RISINGFALLING
N  *         @arg @ref LL_TIM_TRGO2_OC4_RISING_OC6_RISING
N  *         @arg @ref LL_TIM_TRGO2_OC4_RISING_OC6_FALLING
N  *         @arg @ref LL_TIM_TRGO2_OC5_RISING_OC6_RISING
N  *         @arg @ref LL_TIM_TRGO2_OC5_RISING_OC6_FALLING
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetTriggerOutput2(TIM_TypeDef *TIMx, uint32_t ADCSynchronization)
Xstatic __inline void LL_TIM_SetTriggerOutput2(TIM_TypeDef *TIMx, uint32_t ADCSynchronization)
N{
N  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS2, ADCSynchronization);
X  (((TIMx->CR2)) = ((((((TIMx->CR2))) & (~((0xFUL << (20U))))) | (ADCSynchronization))));
N}
N
N/**
N  * @brief  Set the synchronization mode of a slave timer.
N  * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
N  * @param  TIMx Timer instance
N  * @param  SlaveMode This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
N  *         @arg @ref LL_TIM_SLAVEMODE_RESET
N  *         @arg @ref LL_TIM_SLAVEMODE_GATED
N  *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
N  *         @arg @ref LL_TIM_SLAVEMODE_COMBINED_RESETTRIGGER
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
Xstatic __inline void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
N{
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x10007UL << (0U))))) | (SlaveMode))));
N}
N
N/**
N  * @brief  Set the selects the trigger input to be used to synchronize the counter.
N  * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
N  * @param  TIMx Timer instance
N  * @param  TriggerInput This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_TS_ITR0
N  *         @arg @ref LL_TIM_TS_ITR1
N  *         @arg @ref LL_TIM_TS_ITR2
N  *         @arg @ref LL_TIM_TS_ITR3
N  *         @arg @ref LL_TIM_TS_TI1F_ED
N  *         @arg @ref LL_TIM_TS_TI1FP1
N  *         @arg @ref LL_TIM_TS_TI2FP2
N  *         @arg @ref LL_TIM_TS_ETRF
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
Xstatic __inline void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
N{
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x7UL << (4U))))) | (TriggerInput))));
N}
N
N/**
N  * @brief  Enable the Master/Slave mode.
N  * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
X  ((TIMx->SMCR) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable the Master/Slave mode.
N  * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
X  ((TIMx->SMCR) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief Indicates whether the Master/Slave mode is enabled.
N  * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
N  * a timer instance can operate as a slave timer.
N  * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM)) ? 1UL : 0UL);
X  return ((((TIMx->SMCR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Configure the external trigger (ETR) input.
N  * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides an external trigger input.
N  * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
N  *         SMCR         ETPS          LL_TIM_ConfigETR\n
N  *         SMCR         ETF           LL_TIM_ConfigETR
N  * @param  TIMx Timer instance
N  * @param  ETRPolarity This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
N  *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
N  * @param  ETRPrescaler This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
N  *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
N  *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
N  *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
N  * @param  ETRFilter This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
N  *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
Xstatic __inline void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
N                                      uint32_t ETRFilter)
N{
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x1UL << (15U)) | (0x3UL << (12U)) | (0xFUL << (8U))))) | (ETRPolarity | ETRPrescaler | ETRFilter))));
N}
N
N/**
N  * @brief  Select the external trigger (ETR) input source.
N  * @note Macro @ref IS_TIM_ETRSEL_INSTANCE(TIMx) can be used to check whether or
N  *       not a timer instance supports ETR source selection.
N  * @rmtoll OR2          ETRSEL        LL_TIM_SetETRSource
N  * @param  TIMx Timer instance
N  * @param  ETRSource This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_ETRSOURCE_LEGACY
N  *         @arg @ref LL_TIM_ETRSOURCE_COMP1
N  *         @arg @ref LL_TIM_ETRSOURCE_COMP2
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetETRSource(TIM_TypeDef *TIMx, uint32_t ETRSource)
Xstatic __inline void LL_TIM_SetETRSource(TIM_TypeDef *TIMx, uint32_t ETRSource)
N{
N
N  MODIFY_REG(TIMx->OR2, TIMx_OR2_ETRSEL, ETRSource);
X  (((TIMx->OR2)) = ((((((TIMx->OR2))) & (~((0x7UL << (14U))))) | (ETRSource))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Break_Function Break function configuration
N  * @{
N  */
N/**
N  * @brief  Enable the break function.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
X  ((TIMx->BDTR) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable the break function.
N  * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
N  * @param  TIMx Timer instance
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
X  ((TIMx->BDTR) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Configure the break input.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK\n
N  *         BDTR         BKF           LL_TIM_ConfigBRK
N  * @param  TIMx Timer instance
N  * @param  BreakPolarity This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
N  *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
N  * @param  BreakFilter This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV1
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV1_N2
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV1_N4
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV1_N8
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV2_N6
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV2_N8
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV4_N6
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV4_N8
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV8_N6
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV8_N8
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV16_N5
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV16_N6
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV16_N8
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV32_N5
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV32_N6
N  *         @arg @ref LL_TIM_BREAK_FILTER_FDIV32_N8
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity, uint32_t BreakFilter)
Xstatic __inline void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity, uint32_t BreakFilter)
N{
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP | TIM_BDTR_BKF, BreakPolarity | BreakFilter);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x1UL << (13U)) | (0xFUL << (16U))))) | (BreakPolarity | BreakFilter))));
N}
N
N/**
N  * @brief  Enable the break 2 function.
N  * @note Macro @ref IS_TIM_BKIN2_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a second break input.
N  * @rmtoll BDTR         BK2E          LL_TIM_EnableBRK2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableBRK2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableBRK2(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->BDTR, TIM_BDTR_BK2E);
X  ((TIMx->BDTR) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable the break  2 function.
N  * @note Macro @ref IS_TIM_BKIN2_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a second break input.
N  * @rmtoll BDTR         BK2E          LL_TIM_DisableBRK2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableBRK2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableBRK2(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BK2E);
X  ((TIMx->BDTR) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Configure the break 2 input.
N  * @note Macro @ref IS_TIM_BKIN2_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a second break input.
N  * @rmtoll BDTR         BK2P          LL_TIM_ConfigBRK2\n
N  *         BDTR         BK2F          LL_TIM_ConfigBRK2
N  * @param  TIMx Timer instance
N  * @param  Break2Polarity This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK2_POLARITY_LOW
N  *         @arg @ref LL_TIM_BREAK2_POLARITY_HIGH
N  * @param  Break2Filter This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV1
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV1_N2
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV1_N4
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV1_N8
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV2_N6
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV2_N8
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV4_N6
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV4_N8
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV8_N6
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV8_N8
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV16_N5
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV16_N6
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV16_N8
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV32_N5
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV32_N6
N  *         @arg @ref LL_TIM_BREAK2_FILTER_FDIV32_N8
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ConfigBRK2(TIM_TypeDef *TIMx, uint32_t Break2Polarity, uint32_t Break2Filter)
Xstatic __inline void LL_TIM_ConfigBRK2(TIM_TypeDef *TIMx, uint32_t Break2Polarity, uint32_t Break2Filter)
N{
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_BK2P | TIM_BDTR_BK2F, Break2Polarity | Break2Filter);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x1UL << (25U)) | (0xFUL << (20U))))) | (Break2Polarity | Break2Filter))));
N}
N
N/**
N  * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
N  *         BDTR         OSSR          LL_TIM_SetOffStates
N  * @param  TIMx Timer instance
N  * @param  OffStateIdle This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_OSSI_DISABLE
N  *         @arg @ref LL_TIM_OSSI_ENABLE
N  * @param  OffStateRun This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_OSSR_DISABLE
N  *         @arg @ref LL_TIM_OSSR_ENABLE
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
Xstatic __inline void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
N{
N  MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
X  (((TIMx->BDTR)) = ((((((TIMx->BDTR))) & (~((0x1UL << (10U)) | (0x1UL << (11U))))) | (OffStateIdle | OffStateRun))));
N}
N
N/**
N  * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
X  ((TIMx->BDTR) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable automatic output (MOE can be set only by software).
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
X  ((TIMx->BDTR) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicate whether automatic output is enabled.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE)) ? 1UL : 0UL);
X  return ((((TIMx->BDTR) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
N  * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
N  *       software and is reset in case of break or break2 event
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
X  ((TIMx->BDTR) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
N  * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
N  *       software and is reset in case of break or break2 event.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
X  ((TIMx->BDTR) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Indicates whether outputs are enabled.
N  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
N  *       a timer instance provides a break input.
N  * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE)) ? 1UL : 0UL);
X  return ((((TIMx->BDTR) & ((0x1UL << (15U)))) == ((0x1UL << (15U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable the signals connected to the designated timer break input.
N  * @note Macro @ref IS_TIM_BREAKSOURCE_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance allows for break input selection.
N  * @rmtoll OR2          BKINE         LL_TIM_EnableBreakInputSource\n
N  *         OR2          BKCMP1E       LL_TIM_EnableBreakInputSource\n
N  *         OR2          BKCMP2E       LL_TIM_EnableBreakInputSource\n
N  *         OR2          BKDF1BK0E     LL_TIM_EnableBreakInputSource\n
N  *         OR3          BK2INE        LL_TIM_EnableBreakInputSource\n
N  *         OR3          BK2CMP1E      LL_TIM_EnableBreakInputSource\n
N  *         OR3          BK2CMP2E      LL_TIM_EnableBreakInputSource\n
N  *         OR3          BK2DF1BK1E    LL_TIM_EnableBreakInputSource
N  * @param  TIMx Timer instance
N  * @param  BreakInput This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK_INPUT_BKIN
N  *         @arg @ref LL_TIM_BREAK_INPUT_BKIN2
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKIN
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKCOMP1
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKCOMP2
N  *         @arg @ref LL_TIM_BKIN_SOURCE_DF1BK
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableBreakInputSource(TIM_TypeDef *TIMx, uint32_t BreakInput, uint32_t Source)
Xstatic __inline void LL_TIM_EnableBreakInputSource(TIM_TypeDef *TIMx, uint32_t BreakInput, uint32_t Source)
N{
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->OR2) + BreakInput));
N  SET_BIT(*pReg, Source);
X  ((*pReg) |= (Source));
N}
N
N/**
N  * @brief  Disable the signals connected to the designated timer break input.
N  * @note Macro @ref IS_TIM_BREAKSOURCE_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance allows for break input selection.
N  * @rmtoll OR2          BKINE         LL_TIM_DisableBreakInputSource\n
N  *         OR2          BKCMP1E       LL_TIM_DisableBreakInputSource\n
N  *         OR2          BKCMP2E       LL_TIM_DisableBreakInputSource\n
N  *         OR2          BKDF1BK0E     LL_TIM_DisableBreakInputSource\n
N  *         OR3          BK2INE        LL_TIM_DisableBreakInputSource\n
N  *         OR3          BK2CMP1E      LL_TIM_DisableBreakInputSource\n
N  *         OR3          BK2CMP2E      LL_TIM_DisableBreakInputSource\n
N  *         OR3          BK2DF1BK1E    LL_TIM_DisableBreakInputSource
N  * @param  TIMx Timer instance
N  * @param  BreakInput This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK_INPUT_BKIN
N  *         @arg @ref LL_TIM_BREAK_INPUT_BKIN2
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKIN
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKCOMP1
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKCOMP2
N  *         @arg @ref LL_TIM_BKIN_SOURCE_DF1BK
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableBreakInputSource(TIM_TypeDef *TIMx, uint32_t BreakInput, uint32_t Source)
Xstatic __inline void LL_TIM_DisableBreakInputSource(TIM_TypeDef *TIMx, uint32_t BreakInput, uint32_t Source)
N{
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->OR2) + BreakInput));
N  CLEAR_BIT(*pReg, Source);
X  ((*pReg) &= ~(Source));
N}
N
N/**
N  * @brief  Set the polarity of the break signal for the timer break input.
N  * @note Macro @ref IS_TIM_BREAKSOURCE_INSTANCE(TIMx) can be used to check whether
N  *       or not a timer instance allows for break input selection.
N  * @rmtoll OR2          BKINP         LL_TIM_SetBreakInputSourcePolarity\n
N  *         OR2          BKCMP1P       LL_TIM_SetBreakInputSourcePolarity\n
N  *         OR2          BKCMP2P       LL_TIM_SetBreakInputSourcePolarity\n
N  *         OR3          BK2INP        LL_TIM_SetBreakInputSourcePolarity\n
N  *         OR3          BK2CMP1P      LL_TIM_SetBreakInputSourcePolarity\n
N  *         OR3          BK2CMP2P      LL_TIM_SetBreakInputSourcePolarity
N  * @param  TIMx Timer instance
N  * @param  BreakInput This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BREAK_INPUT_BKIN
N  *         @arg @ref LL_TIM_BREAK_INPUT_BKIN2
N  * @param  Source This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKIN
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKCOMP1
N  *         @arg @ref LL_TIM_BKIN_SOURCE_BKCOMP2
N  * @param  Polarity This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_BKIN_POLARITY_LOW
N  *         @arg @ref LL_TIM_BKIN_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetBreakInputSourcePolarity(TIM_TypeDef *TIMx, uint32_t BreakInput, uint32_t Source,
Xstatic __inline void LL_TIM_SetBreakInputSourcePolarity(TIM_TypeDef *TIMx, uint32_t BreakInput, uint32_t Source,
N                                                        uint32_t Polarity)
N{
N  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->OR2) + BreakInput));
N  MODIFY_REG(*pReg, (TIMx_OR2_BKINP << TIM_POSITION_BRK_SOURCE), (Polarity << TIM_POSITION_BRK_SOURCE));
X  (((*pReg)) = ((((((*pReg))) & (~(((0x1UL << (9U)) << ((__clz(__rbit(Source))) & 0x1FU))))) | ((Polarity << ((__clz(__rbit(Source))) & 0x1FU))))));
N}
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
N  * @{
N  */
N/**
N  * @brief  Configures the timer DMA burst feature.
N  * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
N  *       not a timer instance supports the DMA burst mode.
N  * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
N  *         DCR          DBA           LL_TIM_ConfigDMABurst
N  * @param  TIMx Timer instance
N  * @param  DMABurstBaseAddress This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR3
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR5
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR6
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_OR1
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_OR2
N  *         @arg @ref LL_TIM_DMABURST_BASEADDR_OR3
N  * @param  DMABurstLength This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
N  *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
Xstatic __inline void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
N{
N  MODIFY_REG(TIMx->DCR, (TIM_DCR_DBL | TIM_DCR_DBA), (DMABurstBaseAddress | DMABurstLength));
X  (((TIMx->DCR)) = ((((((TIMx->DCR))) & (~(((0x1FUL << (8U)) | (0x1FUL << (0U)))))) | ((DMABurstBaseAddress | DMABurstLength)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_Timer_Inputs_Remapping Timer input remapping
N  * @{
N  */
N/**
N  * @brief  Remap TIM inputs (input channel, internal/external triggers).
N  * @note Macro @ref IS_TIM_REMAP_INSTANCE(TIMx) can be used to check whether or not
N  *       a some timer inputs can be remapped.
N  @if STM32L486xx
N  * @rmtoll TIM1_OR1    ETR_ADC1_RMP      LL_TIM_SetRemap\n
N  *         TIM1_OR1    ETR_ADC3_RMP      LL_TIM_SetRemap\n
N  *         TIM1_OR1    TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM8_OR1    ETR_ADC2_RMP      LL_TIM_SetRemap\n
N  *         TIM8_OR1    ETR_ADC3_RMP      LL_TIM_SetRemap\n
N  *         TIM8_OR1    TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM2_OR1    ITR1_RMP          LL_TIM_SetRemap\n
N  *         TIM2_OR1    TI4_RMP           LL_TIM_SetRemap\n
N  *         TIM2_OR1    TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM3_OR1    TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM15_OR1   TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM15_OR1   ENCODER_MODE      LL_TIM_SetRemap\n
N  *         TIM16_OR1   TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM17_OR1   TI1_RMP           LL_TIM_SetRemap
N  @endif
N  @if STM32L443xx
N  * @rmtoll TIM1_OR1    ETR_ADC1_RMP      LL_TIM_SetRemap\n
N  *         TIM1_OR1    ETR_ADC3_RMP      LL_TIM_SetRemap\n
N  *         TIM1_OR1    TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM2_OR1    ITR1_RMP          LL_TIM_SetRemap\n
N  *         TIM2_OR1    TI4_RMP           LL_TIM_SetRemap\n
N  *         TIM2_OR1    TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM15_OR1   TI1_RMP           LL_TIM_SetRemap\n
N  *         TIM15_OR1   ENCODER_MODE      LL_TIM_SetRemap\n
N  *         TIM16_OR1   TI1_RMP           LL_TIM_SetRemap\n
N  @endif
N  * @param  TIMx Timer instance
N  * @param  Remap Remap param depends on the TIMx. Description available only
N  *         in CHM version of the User Manual (not in .pdf).
N  *         Otherwise see Reference Manual description of OR registers.
N  *
N  *         Below description summarizes "Timer Instance" and "Remap" param combinations:
N  *
N  @if STM32L486xx
N  *         TIM1: any combination of TI1_RMP, ADC3_RMP, ADC1_RMP where
N  *
N  *            . . ADC1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_NC
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_AWD1
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_AWD2
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_AWD3
N  *
N  *            . . ADC3_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC3_RMP_NC
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC3_RMP_AWD1
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC3_RMP_AWD2
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC3_RMP_AWD3
N  *
N  *            . . TI1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM1_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM1_TI1_RMP_COMP1
N  *
N  *         TIM2: any combination of ITR1_RMP, ETR1_RMP, TI4_RMP where
N  *
N  *            ITR1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM2_ITR1_RMP_TIM8_TRGO
N  *            @arg @ref LL_TIM_TIM2_ITR1_RMP_OTG_FS_SOF
N  *
N  *            . . ETR1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM2_ETR_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM2_ETR_RMP_LSE
N  *
N  *            . . TI4_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_COMP1
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_COMP2
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_COMP1_COMP2
N  *
N  *         TIM3: one of the following values
N  *
N  *            @arg @ref LL_TIM_TIM3_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM3_TI1_RMP_COMP1
N  *            @arg @ref LL_TIM_TIM3_TI1_RMP_COMP2
N  *            @arg @ref LL_TIM_TIM3_TI1_RMP_COMP1_COMP2
N  *
N  *         TIM8: any combination of TI1_RMP, ADC3_RMP, ADC1_RMP where
N  *
N  *            . . ADC1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC2_RMP_NC
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC2_RMP_AWD1
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC2_RMP_AWD2
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC2_RMP_AWD3
N  *
N  *            . . ADC3_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC3_RMP_NC
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC3_RMP_AWD1
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC3_RMP_AWD2
N  *            @arg @ref LL_TIM_TIM8_ETR_ADC3_RMP_AWD3
N  *
N  *            . . TI1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM8_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM8_TI1_RMP_COMP2
N  *
N  *         TIM15: any combination of TI1_RMP, ENCODER_MODE where
N  *
N  *            . . TI1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM15_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM15_TI1_RMP_LSE
N  *
N  *            . . ENCODER_MODE can be one of the following values
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_NOREDIRECTION
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_TIM2
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_TIM3
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_TIM4
N  *
N  *         TIM16: one of the following values
N  *
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_LSI
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_LSE
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_RTC
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_MSI
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_HSE_32
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_MCO
N  *
N  *         TIM17: one of the following values
N  *
N  *            @arg @ref LL_TIM_TIM17_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM17_TI1_RMP_MSI
N  *            @arg @ref LL_TIM_TIM17_TI1_RMP_HSE_32
N  *            @arg @ref LL_TIM_TIM17_TI1_RMP_MCO
N   @endif
N  @if STM32L443xx
N  *         TIM1: any combination of TI1_RMP, ADC3_RMP, ADC1_RMP where
N  *
N  *            . . ADC1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_NC
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_AWD1
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_AWD2
N  *            @arg @ref LL_TIM_TIM1_ETR_ADC1_RMP_AWD3
N  *
N  *            . . TI1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM1_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM1_TI1_RMP_COMP1
N  *
N  *         TIM2: any combination of ITR1_RMP, ETR1_RMP, TI4_RMP where
N  *
N  *            ITR1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM2_ITR1_RMP_NONE
N  *            @arg @ref LL_TIM_TIM2_ITR1_RMP_USB_SOF
N  *
N  *            . . ETR1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM2_ETR_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM2_ETR_RMP_LSE
N  *
N  *            . . TI4_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_COMP1
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_COMP2
N  *            @arg @ref LL_TIM_TIM2_TI4_RMP_COMP1_COMP2
N  *
N  *         TIM15: any combination of TI1_RMP, ENCODER_MODE where
N  *
N  *            . . TI1_RMP can be one of the following values
N  *            @arg @ref LL_TIM_TIM15_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM15_TI1_RMP_LSE
N  *
N  *            . . ENCODER_MODE can be one of the following values
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_NOREDIRECTION
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_TIM2
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_TIM3
N  *            @arg @ref LL_TIM_TIM15_ENCODERMODE_TIM4
N  *
N  *         TIM16: one of the following values
N  *
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_GPIO
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_LSI
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_LSE
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_RTC
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_MSI
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_HSE_32
N  *            @arg @ref LL_TIM_TIM16_TI1_RMP_MCO
N  @endif
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetRemap(TIM_TypeDef *TIMx, uint32_t Remap)
Xstatic __inline void LL_TIM_SetRemap(TIM_TypeDef *TIMx, uint32_t Remap)
N{
N  MODIFY_REG(TIMx->OR1, (Remap >> TIMx_OR1_RMP_SHIFT), (Remap & TIMx_OR1_RMP_MASK));
X  (((TIMx->OR1)) = ((((((TIMx->OR1))) & (~((Remap >> 16U)))) | ((Remap & 0x0000FFFFU)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_OCREF_Clear OCREF_Clear_Management
N  * @{
N  */
N/**
N  * @brief  Set the OCREF clear input source
N  * @note The OCxREF signal of a given channel can be cleared when a high level is applied on the OCREF_CLR_INPUT
N  * @note This function can only be used in Output compare and PWM modes.
N  * @rmtoll SMCR          OCCS                LL_TIM_SetOCRefClearInputSource
N  * @param  TIMx Timer instance
N  * @param  OCRefClearInputSource This parameter can be one of the following values:
N  *         @arg @ref LL_TIM_OCREF_CLR_INT_NC
N  *         @arg @ref LL_TIM_OCREF_CLR_INT_ETR
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_SetOCRefClearInputSource(TIM_TypeDef *TIMx, uint32_t OCRefClearInputSource)
Xstatic __inline void LL_TIM_SetOCRefClearInputSource(TIM_TypeDef *TIMx, uint32_t OCRefClearInputSource)
N{
N  MODIFY_REG(TIMx->SMCR, TIM_SMCR_OCCS, OCRefClearInputSource);
X  (((TIMx->SMCR)) = ((((((TIMx->SMCR))) & (~((0x1UL << (3U))))) | (OCRefClearInputSource))));
N}
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
N  * @{
N  */
N/**
N  * @brief  Clear the update interrupt flag (UIF).
N  * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
X  ((TIMx->SR) = (~((0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
N  * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
N  * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
X  ((TIMx->SR) = (~((0x1UL << (1U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
N  * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
N  * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
X  ((TIMx->SR) = (~((0x1UL << (2U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
N  * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
N  * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
X  ((TIMx->SR) = (~((0x1UL << (3U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
N  * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
N  * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
X  ((TIMx->SR) = (~((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
N  * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 5 interrupt flag (CC5F).
N  * @rmtoll SR           CC5IF         LL_TIM_ClearFlag_CC5
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC5(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC5(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC5IF));
X  ((TIMx->SR) = (~((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 5 interrupt flag (CC5F) is set (Capture/Compare 5 interrupt is pending).
N  * @rmtoll SR           CC5IF         LL_TIM_IsActiveFlag_CC5
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC5(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC5(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC5IF) == (TIM_SR_CC5IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (16U)))) == ((0x1UL << (16U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 6 interrupt flag (CC6F).
N  * @rmtoll SR           CC6IF         LL_TIM_ClearFlag_CC6
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC6(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC6(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC6IF));
X  ((TIMx->SR) = (~((0x1UL << (17U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 6 interrupt flag (CC6F) is set (Capture/Compare 6 interrupt is pending).
N  * @rmtoll SR           CC6IF         LL_TIM_IsActiveFlag_CC6
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC6(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC6(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC6IF) == (TIM_SR_CC6IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (17U)))) == ((0x1UL << (17U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the commutation interrupt flag (COMIF).
N  * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
X  ((TIMx->SR) = (~((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
N  * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the trigger interrupt flag (TIF).
N  * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
X  ((TIMx->SR) = (~((0x1UL << (6U)))));
N}
N
N/**
N  * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
N  * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the break interrupt flag (BIF).
N  * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
X  ((TIMx->SR) = (~((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
N  * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the break 2 interrupt flag (B2IF).
N  * @rmtoll SR           B2IF          LL_TIM_ClearFlag_BRK2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_BRK2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_BRK2(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
X  ((TIMx->SR) = (~((0x1UL << (8U)))));
N}
N
N/**
N  * @brief  Indicate whether break 2 interrupt flag (B2IF) is set (break 2 interrupt is pending).
N  * @rmtoll SR           B2IF          LL_TIM_IsActiveFlag_BRK2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK2(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_BRK2(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
N  * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
X  ((TIMx->SR) = (~((0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
N  * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
N  * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
X  ((TIMx->SR) = (~((0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
N  * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
N  * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
X  ((TIMx->SR) = (~((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
N  * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
N  * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
X  ((TIMx->SR) = (~((0x1UL << (12U)))));
N}
N
N/**
N  * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
N  * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (12U)))) == ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Clear the system break interrupt flag (SBIF).
N  * @rmtoll SR           SBIF          LL_TIM_ClearFlag_SYSBRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_ClearFlag_SYSBRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_ClearFlag_SYSBRK(TIM_TypeDef *TIMx)
N{
N  WRITE_REG(TIMx->SR, ~(TIM_SR_SBIF));
X  ((TIMx->SR) = (~((0x1UL << (13U)))));
N}
N
N/**
N  * @brief  Indicate whether system break interrupt flag (SBIF) is set (system break interrupt is pending).
N  * @rmtoll SR           SBIF          LL_TIM_IsActiveFlag_SYSBRK
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_SYSBRK(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsActiveFlag_SYSBRK(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->SR, TIM_SR_SBIF) == (TIM_SR_SBIF)) ? 1UL : 0UL);
X  return ((((TIMx->SR) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_IT_Management IT-Management
N  * @{
N  */
N/**
N  * @brief  Enable update interrupt (UIE).
N  * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
X  ((TIMx->DIER) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable update interrupt (UIE).
N  * @rmtoll DIER         UIE           LL_TIM_DisableIT_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
X  ((TIMx->DIER) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicates whether the update interrupt (UIE) is enabled.
N  * @rmtoll DIER         UIE           LL_TIM_IsEnabledIT_UPDATE
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 1 interrupt (CC1IE).
N  * @rmtoll DIER         CC1IE         LL_TIM_EnableIT_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_CC1(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_CC1(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC1IE);
X  ((TIMx->DIER) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable capture/compare 1  interrupt (CC1IE).
N  * @rmtoll DIER         CC1IE         LL_TIM_DisableIT_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_CC1(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_CC1(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1IE);
X  ((TIMx->DIER) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 1 interrupt (CC1IE) is enabled.
N  * @rmtoll DIER         CC1IE         LL_TIM_IsEnabledIT_CC1
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC1IE) == (TIM_DIER_CC1IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 2 interrupt (CC2IE).
N  * @rmtoll DIER         CC2IE         LL_TIM_EnableIT_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_CC2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_CC2(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC2IE);
X  ((TIMx->DIER) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable capture/compare 2  interrupt (CC2IE).
N  * @rmtoll DIER         CC2IE         LL_TIM_DisableIT_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_CC2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_CC2(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2IE);
X  ((TIMx->DIER) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 2 interrupt (CC2IE) is enabled.
N  * @rmtoll DIER         CC2IE         LL_TIM_IsEnabledIT_CC2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC2IE) == (TIM_DIER_CC2IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (2U)))) == ((0x1UL << (2U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 3 interrupt (CC3IE).
N  * @rmtoll DIER         CC3IE         LL_TIM_EnableIT_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_CC3(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_CC3(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
X  ((TIMx->DIER) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable capture/compare 3  interrupt (CC3IE).
N  * @rmtoll DIER         CC3IE         LL_TIM_DisableIT_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_CC3(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_CC3(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3IE);
X  ((TIMx->DIER) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 3 interrupt (CC3IE) is enabled.
N  * @rmtoll DIER         CC3IE         LL_TIM_IsEnabledIT_CC3
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC3IE) == (TIM_DIER_CC3IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 4 interrupt (CC4IE).
N  * @rmtoll DIER         CC4IE         LL_TIM_EnableIT_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_CC4(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_CC4(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC4IE);
X  ((TIMx->DIER) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable capture/compare 4  interrupt (CC4IE).
N  * @rmtoll DIER         CC4IE         LL_TIM_DisableIT_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_CC4(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_CC4(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4IE);
X  ((TIMx->DIER) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 4 interrupt (CC4IE) is enabled.
N  * @rmtoll DIER         CC4IE         LL_TIM_IsEnabledIT_CC4
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC4IE) == (TIM_DIER_CC4IE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable commutation interrupt (COMIE).
N  * @rmtoll DIER         COMIE         LL_TIM_EnableIT_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_COM(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_COM(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_COMIE);
X  ((TIMx->DIER) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable commutation interrupt (COMIE).
N  * @rmtoll DIER         COMIE         LL_TIM_DisableIT_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_COM(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_COM(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_COMIE);
X  ((TIMx->DIER) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Indicates whether the commutation interrupt (COMIE) is enabled.
N  * @rmtoll DIER         COMIE         LL_TIM_IsEnabledIT_COM
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_COMIE) == (TIM_DIER_COMIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable trigger interrupt (TIE).
N  * @rmtoll DIER         TIE           LL_TIM_EnableIT_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_TIE);
X  ((TIMx->DIER) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable trigger interrupt (TIE).
N  * @rmtoll DIER         TIE           LL_TIM_DisableIT_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
X  ((TIMx->DIER) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Indicates whether the trigger interrupt (TIE) is enabled.
N  * @rmtoll DIER         TIE           LL_TIM_IsEnabledIT_TRIG
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_TIE) == (TIM_DIER_TIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable break interrupt (BIE).
N  * @rmtoll DIER         BIE           LL_TIM_EnableIT_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableIT_BRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableIT_BRK(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_BIE);
X  ((TIMx->DIER) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable break interrupt (BIE).
N  * @rmtoll DIER         BIE           LL_TIM_DisableIT_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableIT_BRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableIT_BRK(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_BIE);
X  ((TIMx->DIER) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicates whether the break interrupt (BIE) is enabled.
N  * @rmtoll DIER         BIE           LL_TIM_IsEnabledIT_BRK
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_BIE) == (TIM_DIER_BIE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_DMA_Management DMA-Management
N  * @{
N  */
N/**
N  * @brief  Enable update DMA request (UDE).
N  * @rmtoll DIER         UDE           LL_TIM_EnableDMAReq_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_UDE);
X  ((TIMx->DIER) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable update DMA request (UDE).
N  * @rmtoll DIER         UDE           LL_TIM_DisableDMAReq_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_UDE);
X  ((TIMx->DIER) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Indicates whether the update DMA request  (UDE) is enabled.
N  * @rmtoll DIER         UDE           LL_TIM_IsEnabledDMAReq_UPDATE
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_UDE) == (TIM_DIER_UDE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 1 DMA request (CC1DE).
N  * @rmtoll DIER         CC1DE         LL_TIM_EnableDMAReq_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC1DE);
X  ((TIMx->DIER) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable capture/compare 1  DMA request (CC1DE).
N  * @rmtoll DIER         CC1DE         LL_TIM_DisableDMAReq_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1DE);
X  ((TIMx->DIER) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 1 DMA request (CC1DE) is enabled.
N  * @rmtoll DIER         CC1DE         LL_TIM_IsEnabledDMAReq_CC1
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC1DE) == (TIM_DIER_CC1DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (9U)))) == ((0x1UL << (9U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 2 DMA request (CC2DE).
N  * @rmtoll DIER         CC2DE         LL_TIM_EnableDMAReq_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC2DE);
X  ((TIMx->DIER) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable capture/compare 2  DMA request (CC2DE).
N  * @rmtoll DIER         CC2DE         LL_TIM_DisableDMAReq_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2DE);
X  ((TIMx->DIER) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 2 DMA request (CC2DE) is enabled.
N  * @rmtoll DIER         CC2DE         LL_TIM_IsEnabledDMAReq_CC2
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC2DE) == (TIM_DIER_CC2DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (10U)))) == ((0x1UL << (10U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 3 DMA request (CC3DE).
N  * @rmtoll DIER         CC3DE         LL_TIM_EnableDMAReq_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC3DE);
X  ((TIMx->DIER) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Disable capture/compare 3  DMA request (CC3DE).
N  * @rmtoll DIER         CC3DE         LL_TIM_DisableDMAReq_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3DE);
X  ((TIMx->DIER) &= ~((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 3 DMA request (CC3DE) is enabled.
N  * @rmtoll DIER         CC3DE         LL_TIM_IsEnabledDMAReq_CC3
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC3DE) == (TIM_DIER_CC3DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (11U)))) == ((0x1UL << (11U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable capture/compare 4 DMA request (CC4DE).
N  * @rmtoll DIER         CC4DE         LL_TIM_EnableDMAReq_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_CC4DE);
X  ((TIMx->DIER) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable capture/compare 4  DMA request (CC4DE).
N  * @rmtoll DIER         CC4DE         LL_TIM_DisableDMAReq_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4DE);
X  ((TIMx->DIER) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Indicates whether the capture/compare 4 DMA request (CC4DE) is enabled.
N  * @rmtoll DIER         CC4DE         LL_TIM_IsEnabledDMAReq_CC4
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_CC4DE) == (TIM_DIER_CC4DE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (12U)))) == ((0x1UL << (12U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable commutation DMA request (COMDE).
N  * @rmtoll DIER         COMDE         LL_TIM_EnableDMAReq_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_COMDE);
X  ((TIMx->DIER) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable commutation DMA request (COMDE).
N  * @rmtoll DIER         COMDE         LL_TIM_DisableDMAReq_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_COMDE);
X  ((TIMx->DIER) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicates whether the commutation DMA request (COMDE) is enabled.
N  * @rmtoll DIER         COMDE         LL_TIM_IsEnabledDMAReq_COM
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_COMDE) == (TIM_DIER_COMDE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable trigger interrupt (TDE).
N  * @rmtoll DIER         TDE           LL_TIM_EnableDMAReq_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->DIER, TIM_DIER_TDE);
X  ((TIMx->DIER) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable trigger interrupt (TDE).
N  * @rmtoll DIER         TDE           LL_TIM_DisableDMAReq_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx)
N{
N  CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
X  ((TIMx->DIER) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Indicates whether the trigger interrupt (TDE) is enabled.
N  * @rmtoll DIER         TDE           LL_TIM_IsEnabledDMAReq_TRIG
N  * @param  TIMx Timer instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline uint32_t LL_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx)
N{
N  return ((READ_BIT(TIMx->DIER, TIM_DIER_TDE) == (TIM_DIER_TDE)) ? 1UL : 0UL);
X  return ((((TIMx->DIER) & ((0x1UL << (14U)))) == ((0x1UL << (14U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_LL_EF_EVENT_Management EVENT-Management
N  * @{
N  */
N/**
N  * @brief  Generate an update event.
N  * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_UG);
X  ((TIMx->EGR) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 1 event.
N  * @rmtoll EGR          CC1G          LL_TIM_GenerateEvent_CC1
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_CC1(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_CC1(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_CC1G);
X  ((TIMx->EGR) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 2 event.
N  * @rmtoll EGR          CC2G          LL_TIM_GenerateEvent_CC2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_CC2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_CC2(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_CC2G);
X  ((TIMx->EGR) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 3 event.
N  * @rmtoll EGR          CC3G          LL_TIM_GenerateEvent_CC3
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_CC3(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_CC3(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_CC3G);
X  ((TIMx->EGR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Generate Capture/Compare 4 event.
N  * @rmtoll EGR          CC4G          LL_TIM_GenerateEvent_CC4
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_CC4(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_CC4(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_CC4G);
X  ((TIMx->EGR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Generate commutation event.
N  * @rmtoll EGR          COMG          LL_TIM_GenerateEvent_COM
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_COM(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_COM(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_COMG);
X  ((TIMx->EGR) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Generate trigger event.
N  * @rmtoll EGR          TG            LL_TIM_GenerateEvent_TRIG
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_TRIG(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_TRIG(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_TG);
X  ((TIMx->EGR) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Generate break event.
N  * @rmtoll EGR          BG            LL_TIM_GenerateEvent_BRK
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_BRK(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_BRK(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_BG);
X  ((TIMx->EGR) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Generate break 2 event.
N  * @rmtoll EGR          B2G           LL_TIM_GenerateEvent_BRK2
N  * @param  TIMx Timer instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_TIM_GenerateEvent_BRK2(TIM_TypeDef *TIMx)
Xstatic __inline void LL_TIM_GenerateEvent_BRK2(TIM_TypeDef *TIMx)
N{
N  SET_BIT(TIMx->EGR, TIM_EGR_B2G);
X  ((TIMx->EGR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup TIM_LL_EF_Init Initialisation and deinitialisation functions
N  * @{
N  */
N
NErrorStatus LL_TIM_DeInit(TIM_TypeDef *TIMx);
Nvoid LL_TIM_StructInit(LL_TIM_InitTypeDef *TIM_InitStruct);
NErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct);
Nvoid LL_TIM_OC_StructInit(LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct);
NErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct);
Nvoid LL_TIM_IC_StructInit(LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
NErrorStatus LL_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef *TIM_IC_InitStruct);
Nvoid LL_TIM_ENCODER_StructInit(LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct);
NErrorStatus LL_TIM_ENCODER_Init(TIM_TypeDef *TIMx, LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct);
Nvoid LL_TIM_HALLSENSOR_StructInit(LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct);
NErrorStatus LL_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct);
Nvoid LL_TIM_BDTR_StructInit(LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct);
NErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct);
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* TIM1 || TIM8 || TIM2 || TIM3 ||  TIM4 || TIM5 || TIM15 || TIM16 || TIM17 || TIM6 || TIM7 */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_TIM_H */
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 16 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_gpio.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_gpio.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_GPIO_H
N#define __STM32L4xx_LL_GPIO_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI)
X#if 1L || 1L || 1L || 1L || 1L || 0L || 0L || 1L || 0L
N
N/** @defgroup GPIO_LL GPIO
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup GPIO_LL_Private_Macros GPIO Private Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup GPIO_LL_ES_INIT GPIO Exported Init structures
N  * @{
N  */
N
N/**
N  * @brief LL GPIO Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Pin;          /*!< Specifies the GPIO pins to be configured.
N                              This parameter can be any value of @ref GPIO_LL_EC_PIN */
N
N  uint32_t Mode;         /*!< Specifies the operating mode for the selected pins.
N                              This parameter can be a value of @ref GPIO_LL_EC_MODE.
N
N                              GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinMode().*/
N
N  uint32_t Speed;        /*!< Specifies the speed for the selected pins.
N                              This parameter can be a value of @ref GPIO_LL_EC_SPEED.
N
N                              GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinSpeed().*/
N
N  uint32_t OutputType;   /*!< Specifies the operating output type for the selected pins.
N                              This parameter can be a value of @ref GPIO_LL_EC_OUTPUT.
N
N                              GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinOutputType().*/
N
N  uint32_t Pull;         /*!< Specifies the operating Pull-up/Pull down for the selected pins.
N                              This parameter can be a value of @ref GPIO_LL_EC_PULL.
N
N                              GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinPull().*/
N
N  uint32_t Alternate;    /*!< Specifies the Peripheral to be connected to the selected pins.
N                              This parameter can be a value of @ref GPIO_LL_EC_AF.
N
N                              GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetAFPin_0_7() and LL_GPIO_SetAFPin_8_15().*/
N} LL_GPIO_InitTypeDef;
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup GPIO_LL_Exported_Constants GPIO Exported Constants
N  * @{
N  */
N
N/** @defgroup GPIO_LL_EC_PIN PIN
N  * @{
N  */
N#define LL_GPIO_PIN_0                      GPIO_BSRR_BS0 /*!< Select pin 0 */
N#define LL_GPIO_PIN_1                      GPIO_BSRR_BS1 /*!< Select pin 1 */
N#define LL_GPIO_PIN_2                      GPIO_BSRR_BS2 /*!< Select pin 2 */
N#define LL_GPIO_PIN_3                      GPIO_BSRR_BS3 /*!< Select pin 3 */
N#define LL_GPIO_PIN_4                      GPIO_BSRR_BS4 /*!< Select pin 4 */
N#define LL_GPIO_PIN_5                      GPIO_BSRR_BS5 /*!< Select pin 5 */
N#define LL_GPIO_PIN_6                      GPIO_BSRR_BS6 /*!< Select pin 6 */
N#define LL_GPIO_PIN_7                      GPIO_BSRR_BS7 /*!< Select pin 7 */
N#define LL_GPIO_PIN_8                      GPIO_BSRR_BS8 /*!< Select pin 8 */
N#define LL_GPIO_PIN_9                      GPIO_BSRR_BS9 /*!< Select pin 9 */
N#define LL_GPIO_PIN_10                     GPIO_BSRR_BS10 /*!< Select pin 10 */
N#define LL_GPIO_PIN_11                     GPIO_BSRR_BS11 /*!< Select pin 11 */
N#define LL_GPIO_PIN_12                     GPIO_BSRR_BS12 /*!< Select pin 12 */
N#define LL_GPIO_PIN_13                     GPIO_BSRR_BS13 /*!< Select pin 13 */
N#define LL_GPIO_PIN_14                     GPIO_BSRR_BS14 /*!< Select pin 14 */
N#define LL_GPIO_PIN_15                     GPIO_BSRR_BS15 /*!< Select pin 15 */
N#define LL_GPIO_PIN_ALL                    (GPIO_BSRR_BS0 | GPIO_BSRR_BS1  | GPIO_BSRR_BS2  | \
N                                           GPIO_BSRR_BS3  | GPIO_BSRR_BS4  | GPIO_BSRR_BS5  | \
N                                           GPIO_BSRR_BS6  | GPIO_BSRR_BS7  | GPIO_BSRR_BS8  | \
N                                           GPIO_BSRR_BS9  | GPIO_BSRR_BS10 | GPIO_BSRR_BS11 | \
N                                           GPIO_BSRR_BS12 | GPIO_BSRR_BS13 | GPIO_BSRR_BS14 | \
N                                           GPIO_BSRR_BS15) /*!< Select all pins */
X#define LL_GPIO_PIN_ALL                    (GPIO_BSRR_BS0 | GPIO_BSRR_BS1  | GPIO_BSRR_BS2  |                                            GPIO_BSRR_BS3  | GPIO_BSRR_BS4  | GPIO_BSRR_BS5  |                                            GPIO_BSRR_BS6  | GPIO_BSRR_BS7  | GPIO_BSRR_BS8  |                                            GPIO_BSRR_BS9  | GPIO_BSRR_BS10 | GPIO_BSRR_BS11 |                                            GPIO_BSRR_BS12 | GPIO_BSRR_BS13 | GPIO_BSRR_BS14 |                                            GPIO_BSRR_BS15)  
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_EC_MODE Mode
N  * @{
N  */
N#define LL_GPIO_MODE_INPUT                 (0x00000000U) /*!< Select input mode */
N#define LL_GPIO_MODE_OUTPUT                GPIO_MODER_MODE0_0  /*!< Select output mode */
N#define LL_GPIO_MODE_ALTERNATE             GPIO_MODER_MODE0_1  /*!< Select alternate function mode */
N#define LL_GPIO_MODE_ANALOG                GPIO_MODER_MODE0    /*!< Select analog mode */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_EC_OUTPUT Output Type
N  * @{
N  */
N#define LL_GPIO_OUTPUT_PUSHPULL            (0x00000000U) /*!< Select push-pull as output type */
N#define LL_GPIO_OUTPUT_OPENDRAIN           GPIO_OTYPER_OT0 /*!< Select open-drain as output type */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_EC_SPEED Output Speed
N  * @{
N  */
N#define LL_GPIO_SPEED_FREQ_LOW             (0x00000000U) /*!< Select I/O low output speed    */
N#define LL_GPIO_SPEED_FREQ_MEDIUM          GPIO_OSPEEDR_OSPEED0_0 /*!< Select I/O medium output speed */
N#define LL_GPIO_SPEED_FREQ_HIGH            GPIO_OSPEEDR_OSPEED0_1 /*!< Select I/O fast output speed   */
N#define LL_GPIO_SPEED_FREQ_VERY_HIGH       GPIO_OSPEEDR_OSPEED0   /*!< Select I/O high output speed   */
N/**
N  * @}
N  */
N#define LL_GPIO_SPEED_LOW                  LL_GPIO_SPEED_FREQ_LOW
N#define LL_GPIO_SPEED_MEDIUM               LL_GPIO_SPEED_FREQ_MEDIUM
N#define LL_GPIO_SPEED_FAST                 LL_GPIO_SPEED_FREQ_HIGH
N#define LL_GPIO_SPEED_HIGH                 LL_GPIO_SPEED_FREQ_VERY_HIGH
N
N/** @defgroup GPIO_LL_EC_PULL Pull Up Pull Down
N  * @{
N  */
N#define LL_GPIO_PULL_NO                    (0x00000000U) /*!< Select I/O no pull */
N#define LL_GPIO_PULL_UP                    GPIO_PUPDR_PUPD0_0 /*!< Select I/O pull up */
N#define LL_GPIO_PULL_DOWN                  GPIO_PUPDR_PUPD0_1 /*!< Select I/O pull down */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_EC_AF Alternate Function
N  * @{
N  */
N#define LL_GPIO_AF_0                       (0x0000000U) /*!< Select alternate function 0 */
N#define LL_GPIO_AF_1                       (0x0000001U) /*!< Select alternate function 1 */
N#define LL_GPIO_AF_2                       (0x0000002U) /*!< Select alternate function 2 */
N#define LL_GPIO_AF_3                       (0x0000003U) /*!< Select alternate function 3 */
N#define LL_GPIO_AF_4                       (0x0000004U) /*!< Select alternate function 4 */
N#define LL_GPIO_AF_5                       (0x0000005U) /*!< Select alternate function 5 */
N#define LL_GPIO_AF_6                       (0x0000006U) /*!< Select alternate function 6 */
N#define LL_GPIO_AF_7                       (0x0000007U) /*!< Select alternate function 7 */
N#define LL_GPIO_AF_8                       (0x0000008U) /*!< Select alternate function 8 */
N#define LL_GPIO_AF_9                       (0x0000009U) /*!< Select alternate function 9 */
N#define LL_GPIO_AF_10                      (0x000000AU) /*!< Select alternate function 10 */
N#define LL_GPIO_AF_11                      (0x000000BU) /*!< Select alternate function 11 */
N#define LL_GPIO_AF_12                      (0x000000CU) /*!< Select alternate function 12 */
N#define LL_GPIO_AF_13                      (0x000000DU) /*!< Select alternate function 13 */
N#define LL_GPIO_AF_14                      (0x000000EU) /*!< Select alternate function 14 */
N#define LL_GPIO_AF_15                      (0x000000FU) /*!< Select alternate function 15 */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIO_LL_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N
N/** @defgroup GPIO_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in GPIO register
N  * @param  __INSTANCE__ GPIO Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_GPIO_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in GPIO register
N  * @param  __INSTANCE__ GPIO Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_GPIO_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup GPIO_LL_Exported_Functions GPIO Exported Functions
N  * @{
N  */
N
N/** @defgroup GPIO_LL_EF_Port_Configuration Port Configuration
N  * @{
N  */
N
N/**
N  * @brief  Configure gpio mode for a dedicated pin on dedicated port.
N  * @note   I/O mode can be Input mode, General purpose output, Alternate function mode or Analog.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll MODER        MODEy         LL_GPIO_SetPinMode
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_MODE_INPUT
N  *         @arg @ref LL_GPIO_MODE_OUTPUT
N  *         @arg @ref LL_GPIO_MODE_ALTERNATE
N  *         @arg @ref LL_GPIO_MODE_ANALOG
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
Xstatic __inline void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
N{
N  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
X  (((GPIOx->MODER)) = ((((((GPIOx->MODER))) & (~(((0x3UL << (0U)) << ((__clz(__rbit(Pin))) * 2U))))) | ((Mode << ((__clz(__rbit(Pin))) * 2U))))));
N}
N
N/**
N  * @brief  Return gpio mode for a dedicated pin on dedicated port.
N  * @note   I/O mode can be Input mode, General purpose output, Alternate function mode or Analog.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll MODER        MODEy         LL_GPIO_GetPinMode
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_GPIO_MODE_INPUT
N  *         @arg @ref LL_GPIO_MODE_OUTPUT
N  *         @arg @ref LL_GPIO_MODE_ALTERNATE
N  *         @arg @ref LL_GPIO_MODE_ANALOG
N  */
N__STATIC_INLINE uint32_t LL_GPIO_GetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin)
Xstatic __inline uint32_t LL_GPIO_GetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin)
N{
N  return (uint32_t)(READ_BIT(GPIOx->MODER,
N                             (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U))) >> (POSITION_VAL(Pin) * 2U));
X  return (uint32_t)(((GPIOx->MODER) & (((0x3UL << (0U)) << ((__clz(__rbit(Pin))) * 2U)))) >> ((__clz(__rbit(Pin))) * 2U));
N}
N
N/**
N  * @brief  Configure gpio output type for several pins on dedicated port.
N  * @note   Output type as to be set when gpio pin is in output or
N  *         alternate modes. Possible type are Push-pull or Open-drain.
N  * @rmtoll OTYPER       OTy           LL_GPIO_SetPinOutputType
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @param  OutputType This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_OUTPUT_PUSHPULL
N  *         @arg @ref LL_GPIO_OUTPUT_OPENDRAIN
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType)
Xstatic __inline void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType)
N{
N  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
X  (((GPIOx->OTYPER)) = ((((((GPIOx->OTYPER))) & (~(PinMask))) | ((PinMask * OutputType)))));
N}
N
N/**
N  * @brief  Return gpio output type for several pins on dedicated port.
N  * @note   Output type as to be set when gpio pin is in output or
N  *         alternate modes. Possible type are Push-pull or Open-drain.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll OTYPER       OTy           LL_GPIO_GetPinOutputType
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_GPIO_OUTPUT_PUSHPULL
N  *         @arg @ref LL_GPIO_OUTPUT_OPENDRAIN
N  */
N__STATIC_INLINE uint32_t LL_GPIO_GetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t Pin)
Xstatic __inline uint32_t LL_GPIO_GetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t Pin)
N{
N  return (uint32_t)(READ_BIT(GPIOx->OTYPER, Pin) >> POSITION_VAL(Pin));
X  return (uint32_t)(((GPIOx->OTYPER) & (Pin)) >> (__clz(__rbit(Pin))));
N}
N
N/**
N  * @brief  Configure gpio speed for a dedicated pin on dedicated port.
N  * @note   I/O speed can be Low, Medium, Fast or High speed.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @note   Refer to datasheet for frequency specifications and the power
N  *         supply and load conditions for each speed.
N  * @rmtoll OSPEEDR      OSPEEDy       LL_GPIO_SetPinSpeed
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @param  Speed This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_SPEED_FREQ_LOW
N  *         @arg @ref LL_GPIO_SPEED_FREQ_MEDIUM
N  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
N  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
Xstatic __inline void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
N{
N  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U)),
N             (Speed << (POSITION_VAL(Pin) * 2U)));
X  (((GPIOx->OSPEEDR)) = ((((((GPIOx->OSPEEDR))) & (~(((0x3UL << (0U)) << ((__clz(__rbit(Pin))) * 2U))))) | ((Speed << ((__clz(__rbit(Pin))) * 2U))))));
N}
N
N/**
N  * @brief  Return gpio speed for a dedicated pin on dedicated port.
N  * @note   I/O speed can be Low, Medium, Fast or High speed.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @note   Refer to datasheet for frequency specifications and the power
N  *         supply and load conditions for each speed.
N  * @rmtoll OSPEEDR      OSPEEDy       LL_GPIO_GetPinSpeed
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_GPIO_SPEED_FREQ_LOW
N  *         @arg @ref LL_GPIO_SPEED_FREQ_MEDIUM
N  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
N  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
N  */
N__STATIC_INLINE uint32_t LL_GPIO_GetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin)
Xstatic __inline uint32_t LL_GPIO_GetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin)
N{
N  return (uint32_t)(READ_BIT(GPIOx->OSPEEDR,
N                             (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U))) >> (POSITION_VAL(Pin) * 2U));
X  return (uint32_t)(((GPIOx->OSPEEDR) & (((0x3UL << (0U)) << ((__clz(__rbit(Pin))) * 2U)))) >> ((__clz(__rbit(Pin))) * 2U));
N}
N
N/**
N  * @brief  Configure gpio pull-up or pull-down for a dedicated pin on a dedicated port.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll PUPDR        PUPDy         LL_GPIO_SetPinPull
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @param  Pull This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PULL_NO
N  *         @arg @ref LL_GPIO_PULL_UP
N  *         @arg @ref LL_GPIO_PULL_DOWN
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
Xstatic __inline void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
N{
N  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
X  (((GPIOx->PUPDR)) = ((((((GPIOx->PUPDR))) & (~(((0x3UL << (0U)) << ((__clz(__rbit(Pin))) * 2U))))) | ((Pull << ((__clz(__rbit(Pin))) * 2U))))));
N}
N
N/**
N  * @brief  Return gpio pull-up or pull-down for a dedicated pin on a dedicated port
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll PUPDR        PUPDy         LL_GPIO_GetPinPull
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_GPIO_PULL_NO
N  *         @arg @ref LL_GPIO_PULL_UP
N  *         @arg @ref LL_GPIO_PULL_DOWN
N  */
N__STATIC_INLINE uint32_t LL_GPIO_GetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin)
Xstatic __inline uint32_t LL_GPIO_GetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin)
N{
N  return (uint32_t)(READ_BIT(GPIOx->PUPDR,
N                             (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U))) >> (POSITION_VAL(Pin) * 2U));
X  return (uint32_t)(((GPIOx->PUPDR) & (((0x3UL << (0U)) << ((__clz(__rbit(Pin))) * 2U)))) >> ((__clz(__rbit(Pin))) * 2U));
N}
N
N/**
N  * @brief  Configure gpio alternate function of a dedicated pin from 0 to 7 for a dedicated port.
N  * @note   Possible values are from AF0 to AF15 depending on target.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll AFRL         AFSELy        LL_GPIO_SetAFPin_0_7
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  * @param  Alternate This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_AF_0
N  *         @arg @ref LL_GPIO_AF_1
N  *         @arg @ref LL_GPIO_AF_2
N  *         @arg @ref LL_GPIO_AF_3
N  *         @arg @ref LL_GPIO_AF_4
N  *         @arg @ref LL_GPIO_AF_5
N  *         @arg @ref LL_GPIO_AF_6
N  *         @arg @ref LL_GPIO_AF_7
N  *         @arg @ref LL_GPIO_AF_8
N  *         @arg @ref LL_GPIO_AF_9
N  *         @arg @ref LL_GPIO_AF_10
N  *         @arg @ref LL_GPIO_AF_11
N  *         @arg @ref LL_GPIO_AF_12
N  *         @arg @ref LL_GPIO_AF_13
N  *         @arg @ref LL_GPIO_AF_14
N  *         @arg @ref LL_GPIO_AF_15
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
Xstatic __inline void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
N{
N  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
N             (Alternate << (POSITION_VAL(Pin) * 4U)));
X  (((GPIOx->AFR[0])) = ((((((GPIOx->AFR[0]))) & (~(((0xFUL << (0U)) << ((__clz(__rbit(Pin))) * 4U))))) | ((Alternate << ((__clz(__rbit(Pin))) * 4U))))));
N}
N
N/**
N  * @brief  Return gpio alternate function of a dedicated pin from 0 to 7 for a dedicated port.
N  * @rmtoll AFRL         AFSELy        LL_GPIO_GetAFPin_0_7
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_GPIO_AF_0
N  *         @arg @ref LL_GPIO_AF_1
N  *         @arg @ref LL_GPIO_AF_2
N  *         @arg @ref LL_GPIO_AF_3
N  *         @arg @ref LL_GPIO_AF_4
N  *         @arg @ref LL_GPIO_AF_5
N  *         @arg @ref LL_GPIO_AF_6
N  *         @arg @ref LL_GPIO_AF_7
N  *         @arg @ref LL_GPIO_AF_8
N  *         @arg @ref LL_GPIO_AF_9
N  *         @arg @ref LL_GPIO_AF_10
N  *         @arg @ref LL_GPIO_AF_11
N  *         @arg @ref LL_GPIO_AF_12
N  *         @arg @ref LL_GPIO_AF_13
N  *         @arg @ref LL_GPIO_AF_14
N  *         @arg @ref LL_GPIO_AF_15
N  */
N__STATIC_INLINE uint32_t LL_GPIO_GetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin)
Xstatic __inline uint32_t LL_GPIO_GetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin)
N{
N  return (uint32_t)(READ_BIT(GPIOx->AFR[0],
N                             (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U))) >> (POSITION_VAL(Pin) * 4U));
X  return (uint32_t)(((GPIOx->AFR[0]) & (((0xFUL << (0U)) << ((__clz(__rbit(Pin))) * 4U)))) >> ((__clz(__rbit(Pin))) * 4U));
N}
N
N/**
N  * @brief  Configure gpio alternate function of a dedicated pin from 8 to 15 for a dedicated port.
N  * @note   Possible values are from AF0 to AF15 depending on target.
N  * @note   Warning: only one pin can be passed as parameter.
N  * @rmtoll AFRH         AFSELy        LL_GPIO_SetAFPin_8_15
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @param  Alternate This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_AF_0
N  *         @arg @ref LL_GPIO_AF_1
N  *         @arg @ref LL_GPIO_AF_2
N  *         @arg @ref LL_GPIO_AF_3
N  *         @arg @ref LL_GPIO_AF_4
N  *         @arg @ref LL_GPIO_AF_5
N  *         @arg @ref LL_GPIO_AF_6
N  *         @arg @ref LL_GPIO_AF_7
N  *         @arg @ref LL_GPIO_AF_8
N  *         @arg @ref LL_GPIO_AF_9
N  *         @arg @ref LL_GPIO_AF_10
N  *         @arg @ref LL_GPIO_AF_11
N  *         @arg @ref LL_GPIO_AF_12
N  *         @arg @ref LL_GPIO_AF_13
N  *         @arg @ref LL_GPIO_AF_14
N  *         @arg @ref LL_GPIO_AF_15
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
Xstatic __inline void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
N{
N  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
N             (Alternate << (POSITION_VAL(Pin >> 8U) * 4U)));
X  (((GPIOx->AFR[1])) = ((((((GPIOx->AFR[1]))) & (~(((0xFUL << (0U)) << ((__clz(__rbit(Pin >> 8U))) * 4U))))) | ((Alternate << ((__clz(__rbit(Pin >> 8U))) * 4U))))));
N}
N
N/**
N  * @brief  Return gpio alternate function of a dedicated pin from 8 to 15 for a dedicated port.
N  * @note   Possible values are from AF0 to AF15 depending on target.
N  * @rmtoll AFRH         AFSELy        LL_GPIO_GetAFPin_8_15
N  * @param  GPIOx GPIO Port
N  * @param  Pin This parameter can be one of the following values:
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_GPIO_AF_0
N  *         @arg @ref LL_GPIO_AF_1
N  *         @arg @ref LL_GPIO_AF_2
N  *         @arg @ref LL_GPIO_AF_3
N  *         @arg @ref LL_GPIO_AF_4
N  *         @arg @ref LL_GPIO_AF_5
N  *         @arg @ref LL_GPIO_AF_6
N  *         @arg @ref LL_GPIO_AF_7
N  *         @arg @ref LL_GPIO_AF_8
N  *         @arg @ref LL_GPIO_AF_9
N  *         @arg @ref LL_GPIO_AF_10
N  *         @arg @ref LL_GPIO_AF_11
N  *         @arg @ref LL_GPIO_AF_12
N  *         @arg @ref LL_GPIO_AF_13
N  *         @arg @ref LL_GPIO_AF_14
N  *         @arg @ref LL_GPIO_AF_15
N  */
N__STATIC_INLINE uint32_t LL_GPIO_GetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin)
Xstatic __inline uint32_t LL_GPIO_GetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin)
N{
N  return (uint32_t)(READ_BIT(GPIOx->AFR[1],
N                             (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U))) >> (POSITION_VAL(Pin >> 8U) * 4U));
X  return (uint32_t)(((GPIOx->AFR[1]) & (((0xFUL << (0U)) << ((__clz(__rbit(Pin >> 8U))) * 4U)))) >> ((__clz(__rbit(Pin >> 8U))) * 4U));
N}
N
N#if defined(GPIO_ASCR_ASC0)
X#if 0L
S/**
S  * @brief  Connect analog switch to ADC input of several pins for a dedicated port.
S  * @note   This bit must be set prior to the ADC conversion.
S  *         Only the IO which connected to the ADC input are effective.
S  *         Other IO must be kept reset value
S  * @rmtoll ASCR         ASCy          LL_GPIO_EnablePinAnalogControl
S  * @param  GPIOx GPIO Port
S  * @param  PinMask This parameter can be a combination of the following values:
S  *         @arg @ref LL_GPIO_PIN_0
S  *         @arg @ref LL_GPIO_PIN_1
S  *         @arg @ref LL_GPIO_PIN_2
S  *         @arg @ref LL_GPIO_PIN_3
S  *         @arg @ref LL_GPIO_PIN_4
S  *         @arg @ref LL_GPIO_PIN_5
S  *         @arg @ref LL_GPIO_PIN_6
S  *         @arg @ref LL_GPIO_PIN_7
S  *         @arg @ref LL_GPIO_PIN_8
S  *         @arg @ref LL_GPIO_PIN_9
S  *         @arg @ref LL_GPIO_PIN_10
S  *         @arg @ref LL_GPIO_PIN_11
S  *         @arg @ref LL_GPIO_PIN_12
S  *         @arg @ref LL_GPIO_PIN_13
S  *         @arg @ref LL_GPIO_PIN_14
S  *         @arg @ref LL_GPIO_PIN_15
S  *         @arg @ref LL_GPIO_PIN_ALL
S  * @retval None
S  */
S__STATIC_INLINE void LL_GPIO_EnablePinAnalogControl(GPIO_TypeDef *GPIOx, uint32_t PinMask)
S{
S  SET_BIT(GPIOx->ASCR, PinMask);
S}
S
S/**
S  * @brief  Disconnect analog switch to ADC input of several pins for a dedicated port.
S  * @rmtoll ASCR         ASCy          LL_GPIO_DisablePinAnalogControl
S  * @param  GPIOx GPIO Port
S  * @param  PinMask This parameter can be a combination of the following values:
S  *         @arg @ref LL_GPIO_PIN_0
S  *         @arg @ref LL_GPIO_PIN_1
S  *         @arg @ref LL_GPIO_PIN_2
S  *         @arg @ref LL_GPIO_PIN_3
S  *         @arg @ref LL_GPIO_PIN_4
S  *         @arg @ref LL_GPIO_PIN_5
S  *         @arg @ref LL_GPIO_PIN_6
S  *         @arg @ref LL_GPIO_PIN_7
S  *         @arg @ref LL_GPIO_PIN_8
S  *         @arg @ref LL_GPIO_PIN_9
S  *         @arg @ref LL_GPIO_PIN_10
S  *         @arg @ref LL_GPIO_PIN_11
S  *         @arg @ref LL_GPIO_PIN_12
S  *         @arg @ref LL_GPIO_PIN_13
S  *         @arg @ref LL_GPIO_PIN_14
S  *         @arg @ref LL_GPIO_PIN_15
S  *         @arg @ref LL_GPIO_PIN_ALL
S  * @retval None
S  */
S__STATIC_INLINE void LL_GPIO_DisablePinAnalogControl(GPIO_TypeDef *GPIOx, uint32_t PinMask)
S{
S  CLEAR_BIT(GPIOx->ASCR, PinMask);
S}
N#endif /* GPIO_ASCR_ASC0 */
N
N/**
N  * @brief  Lock configuration of several pins for a dedicated port.
N  * @note   When the lock sequence has been applied on a port bit, the
N  *         value of this port bit can no longer be modified until the
N  *         next reset.
N  * @note   Each lock bit freezes a specific configuration register
N  *         (control and alternate function registers).
N  * @rmtoll LCKR         LCKK          LL_GPIO_LockPin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline void LL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  __IO uint32_t temp;
X  volatile uint32_t temp;
N  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
X  ((GPIOx->LCKR) = ((0x1UL << (16U)) | PinMask));
N  WRITE_REG(GPIOx->LCKR, PinMask);
X  ((GPIOx->LCKR) = (PinMask));
N  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
X  ((GPIOx->LCKR) = ((0x1UL << (16U)) | PinMask));
N  temp = READ_REG(GPIOx->LCKR);
X  temp = ((GPIOx->LCKR));
N  (void) temp;
N}
N
N/**
N  * @brief  Return 1 if all pins passed as parameter, of a dedicated port, are locked. else Return 0.
N  * @rmtoll LCKR         LCKy          LL_GPIO_IsPinLocked
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_GPIO_IsPinLocked(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline uint32_t LL_GPIO_IsPinLocked(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  return (READ_BIT(GPIOx->LCKR, PinMask) == (PinMask));
X  return (((GPIOx->LCKR) & (PinMask)) == (PinMask));
N}
N
N/**
N  * @brief  Return 1 if one of the pin of a dedicated port is locked. else return 0.
N  * @rmtoll LCKR         LCKK          LL_GPIO_IsAnyPinLocked
N  * @param  GPIOx GPIO Port
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_GPIO_IsAnyPinLocked(GPIO_TypeDef *GPIOx)
Xstatic __inline uint32_t LL_GPIO_IsAnyPinLocked(GPIO_TypeDef *GPIOx)
N{
N  return (READ_BIT(GPIOx->LCKR, GPIO_LCKR_LCKK) == (GPIO_LCKR_LCKK));
X  return (((GPIOx->LCKR) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_LL_EF_Data_Access Data Access
N  * @{
N  */
N
N/**
N  * @brief  Return full input data register value for a dedicated port.
N  * @rmtoll IDR          IDy           LL_GPIO_ReadInputPort
N  * @param  GPIOx GPIO Port
N  * @retval Input data register value of port
N  */
N__STATIC_INLINE uint32_t LL_GPIO_ReadInputPort(GPIO_TypeDef *GPIOx)
Xstatic __inline uint32_t LL_GPIO_ReadInputPort(GPIO_TypeDef *GPIOx)
N{
N  return (uint32_t)(READ_REG(GPIOx->IDR));
X  return (uint32_t)(((GPIOx->IDR)));
N}
N
N/**
N  * @brief  Return if input data level for several pins of dedicated port is high or low.
N  * @rmtoll IDR          IDy           LL_GPIO_IsInputPinSet
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_GPIO_IsInputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline uint32_t LL_GPIO_IsInputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  return (READ_BIT(GPIOx->IDR, PinMask) == (PinMask));
X  return (((GPIOx->IDR) & (PinMask)) == (PinMask));
N}
N
N/**
N  * @brief  Write output data register for the port.
N  * @rmtoll ODR          ODy           LL_GPIO_WriteOutputPort
N  * @param  GPIOx GPIO Port
N  * @param  PortValue Level value for each pin of the port
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue)
Xstatic __inline void LL_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue)
N{
N  WRITE_REG(GPIOx->ODR, PortValue);
X  ((GPIOx->ODR) = (PortValue));
N}
N
N/**
N  * @brief  Return full output data register value for a dedicated port.
N  * @rmtoll ODR          ODy           LL_GPIO_ReadOutputPort
N  * @param  GPIOx GPIO Port
N  * @retval Output data register value of port
N  */
N__STATIC_INLINE uint32_t LL_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx)
Xstatic __inline uint32_t LL_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx)
N{
N  return (uint32_t)(READ_REG(GPIOx->ODR));
X  return (uint32_t)(((GPIOx->ODR)));
N}
N
N/**
N  * @brief  Return if input data level for several pins of dedicated port is high or low.
N  * @rmtoll ODR          ODy           LL_GPIO_IsOutputPinSet
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline uint32_t LL_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  return (READ_BIT(GPIOx->ODR, PinMask) == (PinMask));
X  return (((GPIOx->ODR) & (PinMask)) == (PinMask));
N}
N
N/**
N  * @brief  Set several pins to high level on dedicated gpio port.
N  * @rmtoll BSRR         BSy           LL_GPIO_SetOutputPin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  WRITE_REG(GPIOx->BSRR, PinMask);
X  ((GPIOx->BSRR) = (PinMask));
N}
N
N/**
N  * @brief  Set several pins to low level on dedicated gpio port.
N  * @rmtoll BRR          BRy           LL_GPIO_ResetOutputPin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  WRITE_REG(GPIOx->BRR, PinMask);
X  ((GPIOx->BRR) = (PinMask));
N}
N
N/**
N  * @brief  Toggle data value for several pin of dedicated port.
N  * @rmtoll ODR          ODy           LL_GPIO_TogglePin
N  * @param  GPIOx GPIO Port
N  * @param  PinMask This parameter can be a combination of the following values:
N  *         @arg @ref LL_GPIO_PIN_0
N  *         @arg @ref LL_GPIO_PIN_1
N  *         @arg @ref LL_GPIO_PIN_2
N  *         @arg @ref LL_GPIO_PIN_3
N  *         @arg @ref LL_GPIO_PIN_4
N  *         @arg @ref LL_GPIO_PIN_5
N  *         @arg @ref LL_GPIO_PIN_6
N  *         @arg @ref LL_GPIO_PIN_7
N  *         @arg @ref LL_GPIO_PIN_8
N  *         @arg @ref LL_GPIO_PIN_9
N  *         @arg @ref LL_GPIO_PIN_10
N  *         @arg @ref LL_GPIO_PIN_11
N  *         @arg @ref LL_GPIO_PIN_12
N  *         @arg @ref LL_GPIO_PIN_13
N  *         @arg @ref LL_GPIO_PIN_14
N  *         @arg @ref LL_GPIO_PIN_15
N  *         @arg @ref LL_GPIO_PIN_ALL
N  * @retval None
N  */
N__STATIC_INLINE void LL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
Xstatic __inline void LL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
N{
N  WRITE_REG(GPIOx->ODR, READ_REG(GPIOx->ODR) ^ PinMask);
X  ((GPIOx->ODR) = (((GPIOx->ODR)) ^ PinMask));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup GPIO_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
NErrorStatus LL_GPIO_DeInit(GPIO_TypeDef *GPIOx);
NErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct);
Nvoid        LL_GPIO_StructInit(LL_GPIO_InitTypeDef *GPIO_InitStruct);
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) */
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_GPIO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 17 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_i2c.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_i2c.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_I2C_H
N#define __STM32L4xx_LL_I2C_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (I2C1) || defined (I2C2) || defined (I2C3) || defined (I2C4)
X#if 1L || 1L || 1L || 0L
N
N/** @defgroup I2C_LL I2C
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2C_LL_Private_Constants I2C Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup I2C_LL_Private_Macros I2C Private Macros
N  * @{
N  */
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup I2C_LL_ES_INIT I2C Exported Init structure
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t PeripheralMode;      /*!< Specifies the peripheral mode.
N                                     This parameter can be a value of @ref I2C_LL_EC_PERIPHERAL_MODE
N
N                                     This feature can be modified afterwards using unitary function @ref LL_I2C_SetMode(). */
N
N  uint32_t Timing;              /*!< Specifies the SDA setup, hold time and the SCL high, low period values.
N                                     This parameter must be set by referring to the STM32CubeMX Tool and
N                                     the helper macro @ref __LL_I2C_CONVERT_TIMINGS()
N
N                                     This feature can be modified afterwards using unitary function @ref LL_I2C_SetTiming(). */
N
N  uint32_t AnalogFilter;        /*!< Enables or disables analog noise filter.
N                                     This parameter can be a value of @ref I2C_LL_EC_ANALOGFILTER_SELECTION
N
N                                     This feature can be modified afterwards using unitary functions @ref LL_I2C_EnableAnalogFilter() or LL_I2C_DisableAnalogFilter(). */
N
N  uint32_t DigitalFilter;       /*!< Configures the digital noise filter.
N                                     This parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F
N
N                                     This feature can be modified afterwards using unitary function @ref LL_I2C_SetDigitalFilter(). */
N
N  uint32_t OwnAddress1;         /*!< Specifies the device own address 1.
N                                     This parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF
N
N                                     This feature can be modified afterwards using unitary function @ref LL_I2C_SetOwnAddress1(). */
N
N  uint32_t TypeAcknowledge;     /*!< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive match code or next received byte.
N                                     This parameter can be a value of @ref I2C_LL_EC_I2C_ACKNOWLEDGE
N
N                                     This feature can be modified afterwards using unitary function @ref LL_I2C_AcknowledgeNextData(). */
N
N  uint32_t OwnAddrSize;         /*!< Specifies the device own address 1 size (7-bit or 10-bit).
N                                     This parameter can be a value of @ref I2C_LL_EC_OWNADDRESS1
N
N                                     This feature can be modified afterwards using unitary function @ref LL_I2C_SetOwnAddress1(). */
N} LL_I2C_InitTypeDef;
N/**
N  * @}
N  */
N#endif /*USE_FULL_LL_DRIVER*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup I2C_LL_Exported_Constants I2C Exported Constants
N  * @{
N  */
N
N/** @defgroup I2C_LL_EC_CLEAR_FLAG Clear Flags Defines
N  * @brief    Flags defines which can be used with LL_I2C_WriteReg function
N  * @{
N  */
N#define LL_I2C_ICR_ADDRCF                   I2C_ICR_ADDRCF          /*!< Address Matched flag   */
N#define LL_I2C_ICR_NACKCF                   I2C_ICR_NACKCF          /*!< Not Acknowledge flag   */
N#define LL_I2C_ICR_STOPCF                   I2C_ICR_STOPCF          /*!< Stop detection flag    */
N#define LL_I2C_ICR_BERRCF                   I2C_ICR_BERRCF          /*!< Bus error flag         */
N#define LL_I2C_ICR_ARLOCF                   I2C_ICR_ARLOCF          /*!< Arbitration Lost flag  */
N#define LL_I2C_ICR_OVRCF                    I2C_ICR_OVRCF           /*!< Overrun/Underrun flag  */
N#define LL_I2C_ICR_PECCF                    I2C_ICR_PECCF           /*!< PEC error flag         */
N#define LL_I2C_ICR_TIMOUTCF                 I2C_ICR_TIMOUTCF        /*!< Timeout detection flag */
N#define LL_I2C_ICR_ALERTCF                  I2C_ICR_ALERTCF         /*!< Alert flag             */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_I2C_ReadReg function
N  * @{
N  */
N#define LL_I2C_ISR_TXE                      I2C_ISR_TXE             /*!< Transmit data register empty        */
N#define LL_I2C_ISR_TXIS                     I2C_ISR_TXIS            /*!< Transmit interrupt status           */
N#define LL_I2C_ISR_RXNE                     I2C_ISR_RXNE            /*!< Receive data register not empty     */
N#define LL_I2C_ISR_ADDR                     I2C_ISR_ADDR            /*!< Address matched (slave mode)        */
N#define LL_I2C_ISR_NACKF                    I2C_ISR_NACKF           /*!< Not Acknowledge received flag       */
N#define LL_I2C_ISR_STOPF                    I2C_ISR_STOPF           /*!< Stop detection flag                 */
N#define LL_I2C_ISR_TC                       I2C_ISR_TC              /*!< Transfer Complete (master mode)     */
N#define LL_I2C_ISR_TCR                      I2C_ISR_TCR             /*!< Transfer Complete Reload            */
N#define LL_I2C_ISR_BERR                     I2C_ISR_BERR            /*!< Bus error                           */
N#define LL_I2C_ISR_ARLO                     I2C_ISR_ARLO            /*!< Arbitration lost                    */
N#define LL_I2C_ISR_OVR                      I2C_ISR_OVR             /*!< Overrun/Underrun (slave mode)       */
N#define LL_I2C_ISR_PECERR                   I2C_ISR_PECERR          /*!< PEC Error in reception (SMBus mode) */
N#define LL_I2C_ISR_TIMEOUT                  I2C_ISR_TIMEOUT         /*!< Timeout detection flag (SMBus mode) */
N#define LL_I2C_ISR_ALERT                    I2C_ISR_ALERT           /*!< SMBus alert (SMBus mode)            */
N#define LL_I2C_ISR_BUSY                     I2C_ISR_BUSY            /*!< Bus busy                            */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_IT IT Defines
N  * @brief    IT defines which can be used with LL_I2C_ReadReg and  LL_I2C_WriteReg functions
N  * @{
N  */
N#define LL_I2C_CR1_TXIE                     I2C_CR1_TXIE            /*!< TX Interrupt enable                         */
N#define LL_I2C_CR1_RXIE                     I2C_CR1_RXIE            /*!< RX Interrupt enable                         */
N#define LL_I2C_CR1_ADDRIE                   I2C_CR1_ADDRIE          /*!< Address match Interrupt enable (slave only) */
N#define LL_I2C_CR1_NACKIE                   I2C_CR1_NACKIE          /*!< Not acknowledge received Interrupt enable   */
N#define LL_I2C_CR1_STOPIE                   I2C_CR1_STOPIE          /*!< STOP detection Interrupt enable             */
N#define LL_I2C_CR1_TCIE                     I2C_CR1_TCIE            /*!< Transfer Complete interrupt enable          */
N#define LL_I2C_CR1_ERRIE                    I2C_CR1_ERRIE           /*!< Error interrupts enable                     */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_PERIPHERAL_MODE Peripheral Mode
N  * @{
N  */
N#define LL_I2C_MODE_I2C                    0x00000000U              /*!< I2C Master or Slave mode                                    */
N#define LL_I2C_MODE_SMBUS_HOST             I2C_CR1_SMBHEN           /*!< SMBus Host address acknowledge                              */
N#define LL_I2C_MODE_SMBUS_DEVICE           0x00000000U              /*!< SMBus Device default mode (Default address not acknowledge) */
N#define LL_I2C_MODE_SMBUS_DEVICE_ARP       I2C_CR1_SMBDEN           /*!< SMBus Device Default address acknowledge                    */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_ANALOGFILTER_SELECTION Analog Filter Selection
N  * @{
N  */
N#define LL_I2C_ANALOGFILTER_ENABLE          0x00000000U             /*!< Analog filter is enabled.  */
N#define LL_I2C_ANALOGFILTER_DISABLE         I2C_CR1_ANFOFF          /*!< Analog filter is disabled. */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_ADDRESSING_MODE Master Addressing Mode
N  * @{
N  */
N#define LL_I2C_ADDRESSING_MODE_7BIT         0x00000000U              /*!< Master operates in 7-bit addressing mode. */
N#define LL_I2C_ADDRESSING_MODE_10BIT        I2C_CR2_ADD10            /*!< Master operates in 10-bit addressing mode.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_OWNADDRESS1 Own Address 1 Length
N  * @{
N  */
N#define LL_I2C_OWNADDRESS1_7BIT             0x00000000U             /*!< Own address 1 is a 7-bit address. */
N#define LL_I2C_OWNADDRESS1_10BIT            I2C_OAR1_OA1MODE        /*!< Own address 1 is a 10-bit address.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_OWNADDRESS2 Own Address 2 Masks
N  * @{
N  */
N#define LL_I2C_OWNADDRESS2_NOMASK           I2C_OAR2_OA2NOMASK      /*!< Own Address2 No mask.                                */
N#define LL_I2C_OWNADDRESS2_MASK01           I2C_OAR2_OA2MASK01      /*!< Only Address2 bits[7:2] are compared.                */
N#define LL_I2C_OWNADDRESS2_MASK02           I2C_OAR2_OA2MASK02      /*!< Only Address2 bits[7:3] are compared.                */
N#define LL_I2C_OWNADDRESS2_MASK03           I2C_OAR2_OA2MASK03      /*!< Only Address2 bits[7:4] are compared.                */
N#define LL_I2C_OWNADDRESS2_MASK04           I2C_OAR2_OA2MASK04      /*!< Only Address2 bits[7:5] are compared.                */
N#define LL_I2C_OWNADDRESS2_MASK05           I2C_OAR2_OA2MASK05      /*!< Only Address2 bits[7:6] are compared.                */
N#define LL_I2C_OWNADDRESS2_MASK06           I2C_OAR2_OA2MASK06      /*!< Only Address2 bits[7] are compared.                  */
N#define LL_I2C_OWNADDRESS2_MASK07           I2C_OAR2_OA2MASK07      /*!< No comparison is done. All Address2 are acknowledged.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_I2C_ACKNOWLEDGE Acknowledge Generation
N  * @{
N  */
N#define LL_I2C_ACK                          0x00000000U              /*!< ACK is sent after current received byte. */
N#define LL_I2C_NACK                         I2C_CR2_NACK             /*!< NACK is sent after current received byte.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_ADDRSLAVE Slave Address Length
N  * @{
N  */
N#define LL_I2C_ADDRSLAVE_7BIT               0x00000000U              /*!< Slave Address in 7-bit. */
N#define LL_I2C_ADDRSLAVE_10BIT              I2C_CR2_ADD10            /*!< Slave Address in 10-bit.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_REQUEST Transfer Request Direction
N  * @{
N  */
N#define LL_I2C_REQUEST_WRITE                0x00000000U              /*!< Master request a write transfer. */
N#define LL_I2C_REQUEST_READ                 I2C_CR2_RD_WRN           /*!< Master request a read transfer.  */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_MODE Transfer End Mode
N  * @{
N  */
N#define LL_I2C_MODE_RELOAD                  I2C_CR2_RELOAD                                      /*!< Enable I2C Reload mode.                                   */
N#define LL_I2C_MODE_AUTOEND                 I2C_CR2_AUTOEND                                     /*!< Enable I2C Automatic end mode with no HW PEC comparison.  */
N#define LL_I2C_MODE_SOFTEND                 0x00000000U                                         /*!< Enable I2C Software end mode with no HW PEC comparison.   */
N#define LL_I2C_MODE_SMBUS_RELOAD            LL_I2C_MODE_RELOAD                                  /*!< Enable SMBUS Automatic end mode with HW PEC comparison.   */
N#define LL_I2C_MODE_SMBUS_AUTOEND_NO_PEC    LL_I2C_MODE_AUTOEND                                 /*!< Enable SMBUS Automatic end mode with HW PEC comparison.   */
N#define LL_I2C_MODE_SMBUS_SOFTEND_NO_PEC    LL_I2C_MODE_SOFTEND                                 /*!< Enable SMBUS Software end mode with HW PEC comparison.    */
N#define LL_I2C_MODE_SMBUS_AUTOEND_WITH_PEC  (uint32_t)(LL_I2C_MODE_AUTOEND | I2C_CR2_PECBYTE)   /*!< Enable SMBUS Automatic end mode with HW PEC comparison.   */
N#define LL_I2C_MODE_SMBUS_SOFTEND_WITH_PEC  (uint32_t)(LL_I2C_MODE_SOFTEND | I2C_CR2_PECBYTE)   /*!< Enable SMBUS Software end mode with HW PEC comparison.    */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_GENERATE Start And Stop Generation
N  * @{
N  */
N#define LL_I2C_GENERATE_NOSTARTSTOP         0x00000000U                                                                /*!< Don't Generate Stop and Start condition.                */
N#define LL_I2C_GENERATE_STOP                (uint32_t)(0x80000000U | I2C_CR2_STOP)                                     /*!< Generate Stop condition (Size should be set to 0).      */
N#define LL_I2C_GENERATE_START_READ          (uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN)                   /*!< Generate Start for read request.                        */
N#define LL_I2C_GENERATE_START_WRITE         (uint32_t)(0x80000000U | I2C_CR2_START)                                    /*!< Generate Start for write request.                       */
N#define LL_I2C_GENERATE_RESTART_7BIT_READ   (uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN)                   /*!< Generate Restart for read request, slave 7Bit address.  */
N#define LL_I2C_GENERATE_RESTART_7BIT_WRITE  (uint32_t)(0x80000000U | I2C_CR2_START)                                    /*!< Generate Restart for write request, slave 7Bit address. */
N#define LL_I2C_GENERATE_RESTART_10BIT_READ  (uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN | I2C_CR2_HEAD10R) /*!< Generate Restart for read request, slave 10Bit address. */
N#define LL_I2C_GENERATE_RESTART_10BIT_WRITE (uint32_t)(0x80000000U | I2C_CR2_START)                                    /*!< Generate Restart for write request, slave 10Bit address.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_DIRECTION Read Write Direction
N  * @{
N  */
N#define LL_I2C_DIRECTION_WRITE              0x00000000U              /*!< Write transfer request by master, slave enters receiver mode.  */
N#define LL_I2C_DIRECTION_READ               I2C_ISR_DIR              /*!< Read transfer request by master, slave enters transmitter mode.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_DMA_REG_DATA DMA Register Data
N  * @{
N  */
N#define LL_I2C_DMA_REG_DATA_TRANSMIT        0x00000000U              /*!< Get address of data register used for transmission */
N#define LL_I2C_DMA_REG_DATA_RECEIVE         0x00000001U              /*!< Get address of data register used for reception */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_SMBUS_TIMEOUTA_MODE SMBus TimeoutA Mode SCL SDA Timeout
N  * @{
N  */
N#define LL_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW      0x00000000U          /*!< TimeoutA is used to detect SCL low level timeout.              */
N#define LL_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH I2C_TIMEOUTR_TIDLE   /*!< TimeoutA is used to detect both SCL and SDA high level timeout.*/
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EC_SMBUS_TIMEOUT_SELECTION SMBus Timeout Selection
N  * @{
N  */
N#define LL_I2C_SMBUS_TIMEOUTA               I2C_TIMEOUTR_TIMOUTEN                                   /*!< TimeoutA enable bit                                */
N#define LL_I2C_SMBUS_TIMEOUTB               I2C_TIMEOUTR_TEXTEN                                     /*!< TimeoutB (extended clock) enable bit               */
N#define LL_I2C_SMBUS_ALL_TIMEOUT            (uint32_t)(I2C_TIMEOUTR_TIMOUTEN | I2C_TIMEOUTR_TEXTEN) /*!< TimeoutA and TimeoutB (extended clock) enable bits */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup I2C_LL_Exported_Macros I2C Exported Macros
N  * @{
N  */
N
N/** @defgroup I2C_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in I2C register
N  * @param  __INSTANCE__ I2C Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_I2C_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in I2C register
N  * @param  __INSTANCE__ I2C Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_I2C_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EM_CONVERT_TIMINGS Convert SDA SCL timings
N  * @{
N  */
N/**
N  * @brief  Configure the SDA setup, hold time and the SCL high, low period.
N  * @param  __PRESCALER__ This parameter must be a value between  Min_Data=0 and Max_Data=0xF.
N  * @param  __DATA_SETUP_TIME__ This parameter must be a value between Min_Data=0 and Max_Data=0xF. (tscldel = (SCLDEL+1)xtpresc)
N  * @param  __DATA_HOLD_TIME__ This parameter must be a value between Min_Data=0 and Max_Data=0xF. (tsdadel = SDADELxtpresc)
N  * @param  __CLOCK_HIGH_PERIOD__ This parameter must be a value between Min_Data=0 and Max_Data=0xFF. (tsclh = (SCLH+1)xtpresc)
N  * @param  __CLOCK_LOW_PERIOD__ This parameter must be a value between  Min_Data=0 and Max_Data=0xFF. (tscll = (SCLL+1)xtpresc)
N  * @retval Value between Min_Data=0 and Max_Data=0xFFFFFFFF
N  */
N#define __LL_I2C_CONVERT_TIMINGS(__PRESCALER__, __DATA_SETUP_TIME__, __DATA_HOLD_TIME__, __CLOCK_HIGH_PERIOD__, __CLOCK_LOW_PERIOD__)   \
N        ((((uint32_t)(__PRESCALER__)         << I2C_TIMINGR_PRESC_Pos)  & I2C_TIMINGR_PRESC)   | \
N         (((uint32_t)(__DATA_SETUP_TIME__)   << I2C_TIMINGR_SCLDEL_Pos) & I2C_TIMINGR_SCLDEL)  | \
N         (((uint32_t)(__DATA_HOLD_TIME__)    << I2C_TIMINGR_SDADEL_Pos) & I2C_TIMINGR_SDADEL)  | \
N         (((uint32_t)(__CLOCK_HIGH_PERIOD__) << I2C_TIMINGR_SCLH_Pos)   & I2C_TIMINGR_SCLH)    | \
N         (((uint32_t)(__CLOCK_LOW_PERIOD__)  << I2C_TIMINGR_SCLL_Pos)   & I2C_TIMINGR_SCLL))
X#define __LL_I2C_CONVERT_TIMINGS(__PRESCALER__, __DATA_SETUP_TIME__, __DATA_HOLD_TIME__, __CLOCK_HIGH_PERIOD__, __CLOCK_LOW_PERIOD__)           ((((uint32_t)(__PRESCALER__)         << I2C_TIMINGR_PRESC_Pos)  & I2C_TIMINGR_PRESC)   |          (((uint32_t)(__DATA_SETUP_TIME__)   << I2C_TIMINGR_SCLDEL_Pos) & I2C_TIMINGR_SCLDEL)  |          (((uint32_t)(__DATA_HOLD_TIME__)    << I2C_TIMINGR_SDADEL_Pos) & I2C_TIMINGR_SDADEL)  |          (((uint32_t)(__CLOCK_HIGH_PERIOD__) << I2C_TIMINGR_SCLH_Pos)   & I2C_TIMINGR_SCLH)    |          (((uint32_t)(__CLOCK_LOW_PERIOD__)  << I2C_TIMINGR_SCLL_Pos)   & I2C_TIMINGR_SCLL))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup I2C_LL_Exported_Functions I2C Exported Functions
N  * @{
N  */
N
N/** @defgroup I2C_LL_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable I2C peripheral (PE = 1).
N  * @rmtoll CR1          PE            LL_I2C_Enable
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_Enable(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_Enable(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_PE);
X  ((I2Cx->CR1) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable I2C peripheral (PE = 0).
N  * @note   When PE = 0, the I2C SCL and SDA lines are released.
N  *         Internal state machines and status bits are put back to their reset value.
N  *         When cleared, PE must be kept low for at least 3 APB clock cycles.
N  * @rmtoll CR1          PE            LL_I2C_Disable
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_Disable(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_Disable(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
X  ((I2Cx->CR1) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if the I2C peripheral is enabled or disabled.
N  * @rmtoll CR1          PE            LL_I2C_IsEnabled
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabled(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabled(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_PE) == (I2C_CR1_PE));
X  return (((I2Cx->CR1) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Configure Noise Filters (Analog and Digital).
N  * @note   If the analog filter is also enabled, the digital filter is added to analog filter.
N  *         The filters can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          ANFOFF        LL_I2C_ConfigFilters\n
N  *         CR1          DNF           LL_I2C_ConfigFilters
N  * @param  I2Cx I2C Instance.
N  * @param  AnalogFilter This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_ANALOGFILTER_ENABLE
N  *         @arg @ref LL_I2C_ANALOGFILTER_DISABLE
N  * @param  DigitalFilter This parameter must be a value between Min_Data=0x00 (Digital filter disabled) and Max_Data=0x0F (Digital filter enabled and filtering capability up to 15*ti2cclk).
N  *         This parameter is used to configure the digital noise filter on SDA and SCL input.
N  *         The digital filter will filter spikes with a length of up to DNF[3:0]*ti2cclk.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ConfigFilters(I2C_TypeDef *I2Cx, uint32_t AnalogFilter, uint32_t DigitalFilter)
Xstatic __inline void LL_I2C_ConfigFilters(I2C_TypeDef *I2Cx, uint32_t AnalogFilter, uint32_t DigitalFilter)
N{
N  MODIFY_REG(I2Cx->CR1, I2C_CR1_ANFOFF | I2C_CR1_DNF, AnalogFilter | (DigitalFilter << I2C_CR1_DNF_Pos));
X  (((I2Cx->CR1)) = ((((((I2Cx->CR1))) & (~((0x1UL << (12U)) | (0xFUL << (8U))))) | (AnalogFilter | (DigitalFilter << (8U))))));
N}
N
N/**
N  * @brief  Configure Digital Noise Filter.
N  * @note   If the analog filter is also enabled, the digital filter is added to analog filter.
N  *         This filter can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          DNF           LL_I2C_SetDigitalFilter
N  * @param  I2Cx I2C Instance.
N  * @param  DigitalFilter This parameter must be a value between Min_Data=0x00 (Digital filter disabled) and Max_Data=0x0F (Digital filter enabled and filtering capability up to 15*ti2cclk).
N  *         This parameter is used to configure the digital noise filter on SDA and SCL input.
N  *         The digital filter will filter spikes with a length of up to DNF[3:0]*ti2cclk.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetDigitalFilter(I2C_TypeDef *I2Cx, uint32_t DigitalFilter)
Xstatic __inline void LL_I2C_SetDigitalFilter(I2C_TypeDef *I2Cx, uint32_t DigitalFilter)
N{
N  MODIFY_REG(I2Cx->CR1, I2C_CR1_DNF, DigitalFilter << I2C_CR1_DNF_Pos);
X  (((I2Cx->CR1)) = ((((((I2Cx->CR1))) & (~((0xFUL << (8U))))) | (DigitalFilter << (8U)))));
N}
N
N/**
N  * @brief  Get the current Digital Noise Filter configuration.
N  * @rmtoll CR1          DNF           LL_I2C_GetDigitalFilter
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetDigitalFilter(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetDigitalFilter(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_DNF) >> I2C_CR1_DNF_Pos);
X  return (uint32_t)(((I2Cx->CR1) & ((0xFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @brief  Enable Analog Noise Filter.
N  * @note   This filter can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          ANFOFF        LL_I2C_EnableAnalogFilter
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableAnalogFilter(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableAnalogFilter(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ANFOFF);
X  ((I2Cx->CR1) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable Analog Noise Filter.
N  * @note   This filter can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          ANFOFF        LL_I2C_DisableAnalogFilter
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableAnalogFilter(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableAnalogFilter(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_ANFOFF);
X  ((I2Cx->CR1) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Check if Analog Noise Filter is enabled or disabled.
N  * @rmtoll CR1          ANFOFF        LL_I2C_IsEnabledAnalogFilter
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledAnalogFilter(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledAnalogFilter(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_ANFOFF) != (I2C_CR1_ANFOFF));
X  return (((I2Cx->CR1) & ((0x1UL << (12U)))) != ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Enable DMA transmission requests.
N  * @rmtoll CR1          TXDMAEN       LL_I2C_EnableDMAReq_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableDMAReq_TX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableDMAReq_TX(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_TXDMAEN);
X  ((I2Cx->CR1) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Disable DMA transmission requests.
N  * @rmtoll CR1          TXDMAEN       LL_I2C_DisableDMAReq_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableDMAReq_TX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableDMAReq_TX(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_TXDMAEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Check if DMA transmission requests are enabled or disabled.
N  * @rmtoll CR1          TXDMAEN       LL_I2C_IsEnabledDMAReq_TX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledDMAReq_TX(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledDMAReq_TX(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_TXDMAEN) == (I2C_CR1_TXDMAEN));
X  return (((I2Cx->CR1) & ((0x1UL << (14U)))) == ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Enable DMA reception requests.
N  * @rmtoll CR1          RXDMAEN       LL_I2C_EnableDMAReq_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableDMAReq_RX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableDMAReq_RX(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_RXDMAEN);
X  ((I2Cx->CR1) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable DMA reception requests.
N  * @rmtoll CR1          RXDMAEN       LL_I2C_DisableDMAReq_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableDMAReq_RX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableDMAReq_RX(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_RXDMAEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if DMA reception requests are enabled or disabled.
N  * @rmtoll CR1          RXDMAEN       LL_I2C_IsEnabledDMAReq_RX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledDMAReq_RX(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledDMAReq_RX(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_RXDMAEN) == (I2C_CR1_RXDMAEN));
X  return (((I2Cx->CR1) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Get the data register address used for DMA transfer
N  * @rmtoll TXDR         TXDATA        LL_I2C_DMA_GetRegAddr\n
N  *         RXDR         RXDATA        LL_I2C_DMA_GetRegAddr
N  * @param  I2Cx I2C Instance
N  * @param  Direction This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_DMA_REG_DATA_TRANSMIT
N  *         @arg @ref LL_I2C_DMA_REG_DATA_RECEIVE
N  * @retval Address of data register
N  */
N__STATIC_INLINE uint32_t LL_I2C_DMA_GetRegAddr(I2C_TypeDef *I2Cx, uint32_t Direction)
Xstatic __inline uint32_t LL_I2C_DMA_GetRegAddr(I2C_TypeDef *I2Cx, uint32_t Direction)
N{
N  register uint32_t data_reg_addr;
N
N  if (Direction == LL_I2C_DMA_REG_DATA_TRANSMIT)
X  if (Direction == 0x00000000U)
N  {
N    /* return address of TXDR register */
N    data_reg_addr = (uint32_t) & (I2Cx->TXDR);
N  }
N  else
N  {
N    /* return address of RXDR register */
N    data_reg_addr = (uint32_t) & (I2Cx->RXDR);
N  }
N
N  return data_reg_addr;
N}
N
N/**
N  * @brief  Enable Clock stretching.
N  * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          NOSTRETCH     LL_I2C_EnableClockStretching
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableClockStretching(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableClockStretching(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
X  ((I2Cx->CR1) &= ~((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Disable Clock stretching.
N  * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll CR1          NOSTRETCH     LL_I2C_DisableClockStretching
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableClockStretching(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableClockStretching(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
X  ((I2Cx->CR1) |= ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Check if Clock stretching is enabled or disabled.
N  * @rmtoll CR1          NOSTRETCH     LL_I2C_IsEnabledClockStretching
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledClockStretching(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledClockStretching(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH) != (I2C_CR1_NOSTRETCH));
X  return (((I2Cx->CR1) & ((0x1UL << (17U)))) != ((0x1UL << (17U))));
N}
N
N/**
N  * @brief  Enable hardware byte control in slave mode.
N  * @rmtoll CR1          SBC           LL_I2C_EnableSlaveByteControl
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableSlaveByteControl(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableSlaveByteControl(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_SBC);
X  ((I2Cx->CR1) |= ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Disable hardware byte control in slave mode.
N  * @rmtoll CR1          SBC           LL_I2C_DisableSlaveByteControl
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableSlaveByteControl(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableSlaveByteControl(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_SBC);
X  ((I2Cx->CR1) &= ~((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Check if hardware byte control in slave mode is enabled or disabled.
N  * @rmtoll CR1          SBC           LL_I2C_IsEnabledSlaveByteControl
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledSlaveByteControl(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledSlaveByteControl(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_SBC) == (I2C_CR1_SBC));
X  return (((I2Cx->CR1) & ((0x1UL << (16U)))) == ((0x1UL << (16U))));
N}
N
N/**
N  * @brief  Enable Wakeup from STOP.
N  * @note   Macro @ref IS_I2C_WAKEUP_FROMSTOP_INSTANCE(I2Cx) can be used to check whether or not
N  *         WakeUpFromStop feature is supported by the I2Cx Instance.
N  * @note   This bit can only be programmed when Digital Filter is disabled.
N  * @rmtoll CR1          WUPEN         LL_I2C_EnableWakeUpFromStop
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableWakeUpFromStop(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableWakeUpFromStop(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_WUPEN);
X  ((I2Cx->CR1) |= ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Disable Wakeup from STOP.
N  * @note   Macro @ref IS_I2C_WAKEUP_FROMSTOP_INSTANCE(I2Cx) can be used to check whether or not
N  *         WakeUpFromStop feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          WUPEN         LL_I2C_DisableWakeUpFromStop
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableWakeUpFromStop(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableWakeUpFromStop(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_WUPEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Check if Wakeup from STOP is enabled or disabled.
N  * @note   Macro @ref IS_I2C_WAKEUP_FROMSTOP_INSTANCE(I2Cx) can be used to check whether or not
N  *         WakeUpFromStop feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          WUPEN         LL_I2C_IsEnabledWakeUpFromStop
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledWakeUpFromStop(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledWakeUpFromStop(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_WUPEN) == (I2C_CR1_WUPEN));
X  return (((I2Cx->CR1) & ((0x1UL << (18U)))) == ((0x1UL << (18U))));
N}
N
N/**
N  * @brief  Enable General Call.
N  * @note   When enabled the Address 0x00 is ACKed.
N  * @rmtoll CR1          GCEN          LL_I2C_EnableGeneralCall
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableGeneralCall(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableGeneralCall(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_GCEN);
X  ((I2Cx->CR1) |= ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Disable General Call.
N  * @note   When disabled the Address 0x00 is NACKed.
N  * @rmtoll CR1          GCEN          LL_I2C_DisableGeneralCall
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_GCEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Check if General Call is enabled or disabled.
N  * @rmtoll CR1          GCEN          LL_I2C_IsEnabledGeneralCall
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledGeneralCall(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledGeneralCall(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_GCEN) == (I2C_CR1_GCEN));
X  return (((I2Cx->CR1) & ((0x1UL << (19U)))) == ((0x1UL << (19U))));
N}
N
N/**
N  * @brief  Configure the Master to operate in 7-bit or 10-bit addressing mode.
N  * @note   Changing this bit is not allowed, when the START bit is set.
N  * @rmtoll CR2          ADD10         LL_I2C_SetMasterAddressingMode
N  * @param  I2Cx I2C Instance.
N  * @param  AddressingMode This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_ADDRESSING_MODE_7BIT
N  *         @arg @ref LL_I2C_ADDRESSING_MODE_10BIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetMasterAddressingMode(I2C_TypeDef *I2Cx, uint32_t AddressingMode)
Xstatic __inline void LL_I2C_SetMasterAddressingMode(I2C_TypeDef *I2Cx, uint32_t AddressingMode)
N{
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_ADD10, AddressingMode);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x1UL << (11U))))) | (AddressingMode))));
N}
N
N/**
N  * @brief  Get the Master addressing mode.
N  * @rmtoll CR2          ADD10         LL_I2C_GetMasterAddressingMode
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_I2C_ADDRESSING_MODE_7BIT
N  *         @arg @ref LL_I2C_ADDRESSING_MODE_10BIT
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetMasterAddressingMode(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetMasterAddressingMode(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_ADD10));
X  return (uint32_t)(((I2Cx->CR2) & ((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Set the Own Address1.
N  * @rmtoll OAR1         OA1           LL_I2C_SetOwnAddress1\n
N  *         OAR1         OA1MODE       LL_I2C_SetOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @param  OwnAddress1 This parameter must be a value between Min_Data=0 and Max_Data=0x3FF.
N  * @param  OwnAddrSize This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_OWNADDRESS1_7BIT
N  *         @arg @ref LL_I2C_OWNADDRESS1_10BIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx, uint32_t OwnAddress1, uint32_t OwnAddrSize)
Xstatic __inline void LL_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx, uint32_t OwnAddress1, uint32_t OwnAddrSize)
N{
N  MODIFY_REG(I2Cx->OAR1, I2C_OAR1_OA1 | I2C_OAR1_OA1MODE, OwnAddress1 | OwnAddrSize);
X  (((I2Cx->OAR1)) = ((((((I2Cx->OAR1))) & (~((0x3FFUL << (0U)) | (0x1UL << (10U))))) | (OwnAddress1 | OwnAddrSize))));
N}
N
N/**
N  * @brief  Enable acknowledge on Own Address1 match address.
N  * @rmtoll OAR1         OA1EN         LL_I2C_EnableOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableOwnAddress1(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableOwnAddress1(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN);
X  ((I2Cx->OAR1) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable acknowledge on Own Address1 match address.
N  * @rmtoll OAR1         OA1EN         LL_I2C_DisableOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableOwnAddress1(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableOwnAddress1(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN);
X  ((I2Cx->OAR1) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if Own Address1 acknowledge is enabled or disabled.
N  * @rmtoll OAR1         OA1EN         LL_I2C_IsEnabledOwnAddress1
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledOwnAddress1(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledOwnAddress1(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->OAR1, I2C_OAR1_OA1EN) == (I2C_OAR1_OA1EN));
X  return (((I2Cx->OAR1) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Set the 7bits Own Address2.
N  * @note   This action has no effect if own address2 is enabled.
N  * @rmtoll OAR2         OA2           LL_I2C_SetOwnAddress2\n
N  *         OAR2         OA2MSK        LL_I2C_SetOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @param  OwnAddress2 Value between Min_Data=0 and Max_Data=0x7F.
N  * @param  OwnAddrMask This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_OWNADDRESS2_NOMASK
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK01
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK02
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK03
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK04
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK05
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK06
N  *         @arg @ref LL_I2C_OWNADDRESS2_MASK07
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2, uint32_t OwnAddrMask)
Xstatic __inline void LL_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2, uint32_t OwnAddrMask)
N{
N  MODIFY_REG(I2Cx->OAR2, I2C_OAR2_OA2 | I2C_OAR2_OA2MSK, OwnAddress2 | OwnAddrMask);
X  (((I2Cx->OAR2)) = ((((((I2Cx->OAR2))) & (~((0x7FUL << (1U)) | (0x7UL << (8U))))) | (OwnAddress2 | OwnAddrMask))));
N}
N
N/**
N  * @brief  Enable acknowledge on Own Address2 match address.
N  * @rmtoll OAR2         OA2EN         LL_I2C_EnableOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableOwnAddress2(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableOwnAddress2(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->OAR2, I2C_OAR2_OA2EN);
X  ((I2Cx->OAR2) |= ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Disable  acknowledge on Own Address2 match address.
N  * @rmtoll OAR2         OA2EN         LL_I2C_DisableOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_OA2EN);
X  ((I2Cx->OAR2) &= ~((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Check if Own Address1 acknowledge is enabled or disabled.
N  * @rmtoll OAR2         OA2EN         LL_I2C_IsEnabledOwnAddress2
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledOwnAddress2(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledOwnAddress2(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->OAR2, I2C_OAR2_OA2EN) == (I2C_OAR2_OA2EN));
X  return (((I2Cx->OAR2) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Configure the SDA setup, hold time and the SCL high, low period.
N  * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
N  * @rmtoll TIMINGR      TIMINGR       LL_I2C_SetTiming
N  * @param  I2Cx I2C Instance.
N  * @param  Timing This parameter must be a value between Min_Data=0 and Max_Data=0xFFFFFFFF.
N  * @note   This parameter is computed with the STM32CubeMX Tool.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetTiming(I2C_TypeDef *I2Cx, uint32_t Timing)
Xstatic __inline void LL_I2C_SetTiming(I2C_TypeDef *I2Cx, uint32_t Timing)
N{
N  WRITE_REG(I2Cx->TIMINGR, Timing);
X  ((I2Cx->TIMINGR) = (Timing));
N}
N
N/**
N  * @brief  Get the Timing Prescaler setting.
N  * @rmtoll TIMINGR      PRESC         LL_I2C_GetTimingPrescaler
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetTimingPrescaler(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetTimingPrescaler(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_PRESC) >> I2C_TIMINGR_PRESC_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFUL << (28U)))) >> (28U));
N}
N
N/**
N  * @brief  Get the SCL low period setting.
N  * @rmtoll TIMINGR      SCLL          LL_I2C_GetClockLowPeriod
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetClockLowPeriod(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetClockLowPeriod(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SCLL) >> I2C_TIMINGR_SCLL_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFFUL << (0U)))) >> (0U));
N}
N
N/**
N  * @brief  Get the SCL high period setting.
N  * @rmtoll TIMINGR      SCLH          LL_I2C_GetClockHighPeriod
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetClockHighPeriod(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetClockHighPeriod(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SCLH) >> I2C_TIMINGR_SCLH_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFFUL << (8U)))) >> (8U));
N}
N
N/**
N  * @brief  Get the SDA hold time.
N  * @rmtoll TIMINGR      SDADEL        LL_I2C_GetDataHoldTime
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetDataHoldTime(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetDataHoldTime(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SDADEL) >> I2C_TIMINGR_SDADEL_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Get the SDA setup time.
N  * @rmtoll TIMINGR      SCLDEL        LL_I2C_GetDataSetupTime
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetDataSetupTime(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetDataSetupTime(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMINGR, I2C_TIMINGR_SCLDEL) >> I2C_TIMINGR_SCLDEL_Pos);
X  return (uint32_t)(((I2Cx->TIMINGR) & ((0xFUL << (20U)))) >> (20U));
N}
N
N/**
N  * @brief  Configure peripheral mode.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          SMBHEN        LL_I2C_SetMode\n
N  *         CR1          SMBDEN        LL_I2C_SetMode
N  * @param  I2Cx I2C Instance.
N  * @param  PeripheralMode This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_MODE_I2C
N  *         @arg @ref LL_I2C_MODE_SMBUS_HOST
N  *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
N  *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode)
Xstatic __inline void LL_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode)
N{
N  MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBHEN | I2C_CR1_SMBDEN, PeripheralMode);
X  (((I2Cx->CR1)) = ((((((I2Cx->CR1))) & (~((0x1UL << (20U)) | (0x1UL << (21U))))) | (PeripheralMode))));
N}
N
N/**
N  * @brief  Get peripheral mode.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          SMBHEN        LL_I2C_GetMode\n
N  *         CR1          SMBDEN        LL_I2C_GetMode
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_I2C_MODE_I2C
N  *         @arg @ref LL_I2C_MODE_SMBUS_HOST
N  *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
N  *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetMode(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetMode(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_SMBHEN | I2C_CR1_SMBDEN));
X  return (uint32_t)(((I2Cx->CR1) & ((0x1UL << (20U)) | (0x1UL << (21U)))));
N}
N
N/**
N  * @brief  Enable SMBus alert (Host or Device mode)
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   SMBus Device mode:
N  *         - SMBus Alert pin is drived low and
N  *           Alert Response Address Header acknowledge is enabled.
N  *         SMBus Host mode:
N  *         - SMBus Alert pin management is supported.
N  * @rmtoll CR1          ALERTEN       LL_I2C_EnableSMBusAlert
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_ALERTEN);
X  ((I2Cx->CR1) |= ((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Disable SMBus alert (Host or Device mode)
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   SMBus Device mode:
N  *         - SMBus Alert pin is not drived (can be used as a standard GPIO) and
N  *           Alert Response Address Header acknowledge is disabled.
N  *         SMBus Host mode:
N  *         - SMBus Alert pin management is not supported.
N  * @rmtoll CR1          ALERTEN       LL_I2C_DisableSMBusAlert
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ALERTEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Check if SMBus alert (Host or Device mode) is enabled or disabled.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          ALERTEN       LL_I2C_IsEnabledSMBusAlert
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_ALERTEN) == (I2C_CR1_ALERTEN));
X  return (((I2Cx->CR1) & ((0x1UL << (22U)))) == ((0x1UL << (22U))));
N}
N
N/**
N  * @brief  Enable SMBus Packet Error Calculation (PEC).
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          PECEN         LL_I2C_EnableSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_PECEN);
X  ((I2Cx->CR1) |= ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Disable SMBus Packet Error Calculation (PEC).
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          PECEN         LL_I2C_DisableSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_PECEN);
X  ((I2Cx->CR1) &= ~((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Check if SMBus Packet Error Calculation (PEC) is enabled or disabled.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR1          PECEN         LL_I2C_IsEnabledSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_PECEN) == (I2C_CR1_PECEN));
X  return (((I2Cx->CR1) & ((0x1UL << (23U)))) == ((0x1UL << (23U))));
N}
N
N/**
N  * @brief  Configure the SMBus Clock Timeout.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   This configuration can only be programmed when associated Timeout is disabled (TimeoutA and/orTimeoutB).
N  * @rmtoll TIMEOUTR     TIMEOUTA      LL_I2C_ConfigSMBusTimeout\n
N  *         TIMEOUTR     TIDLE         LL_I2C_ConfigSMBusTimeout\n
N  *         TIMEOUTR     TIMEOUTB      LL_I2C_ConfigSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutA This parameter must be a value between  Min_Data=0 and Max_Data=0xFFF.
N  * @param  TimeoutAMode This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH
N  * @param  TimeoutB
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ConfigSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t TimeoutA, uint32_t TimeoutAMode,
Xstatic __inline void LL_I2C_ConfigSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t TimeoutA, uint32_t TimeoutAMode,
N                                               uint32_t TimeoutB)
N{
N  MODIFY_REG(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIMEOUTA | I2C_TIMEOUTR_TIDLE | I2C_TIMEOUTR_TIMEOUTB,
N             TimeoutA | TimeoutAMode | (TimeoutB << I2C_TIMEOUTR_TIMEOUTB_Pos));
X  (((I2Cx->TIMEOUTR)) = ((((((I2Cx->TIMEOUTR))) & (~((0xFFFUL << (0U)) | (0x1UL << (12U)) | (0xFFFUL << (16U))))) | (TimeoutA | TimeoutAMode | (TimeoutB << (16U))))));
N}
N
N/**
N  * @brief  Configure the SMBus Clock TimeoutA (SCL low timeout or SCL and SDA high timeout depends on TimeoutA mode).
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   These bits can only be programmed when TimeoutA is disabled.
N  * @rmtoll TIMEOUTR     TIMEOUTA      LL_I2C_SetSMBusTimeoutA
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutA This parameter must be a value between  Min_Data=0 and Max_Data=0xFFF.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetSMBusTimeoutA(I2C_TypeDef *I2Cx, uint32_t TimeoutA)
Xstatic __inline void LL_I2C_SetSMBusTimeoutA(I2C_TypeDef *I2Cx, uint32_t TimeoutA)
N{
N  WRITE_REG(I2Cx->TIMEOUTR, TimeoutA);
X  ((I2Cx->TIMEOUTR) = (TimeoutA));
N}
N
N/**
N  * @brief  Get the SMBus Clock TimeoutA setting.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMEOUTA      LL_I2C_GetSMBusTimeoutA
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetSMBusTimeoutA(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetSMBusTimeoutA(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIMEOUTA));
X  return (uint32_t)(((I2Cx->TIMEOUTR) & ((0xFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Set the SMBus Clock TimeoutA mode.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   This bit can only be programmed when TimeoutA is disabled.
N  * @rmtoll TIMEOUTR     TIDLE         LL_I2C_SetSMBusTimeoutAMode
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutAMode This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetSMBusTimeoutAMode(I2C_TypeDef *I2Cx, uint32_t TimeoutAMode)
Xstatic __inline void LL_I2C_SetSMBusTimeoutAMode(I2C_TypeDef *I2Cx, uint32_t TimeoutAMode)
N{
N  WRITE_REG(I2Cx->TIMEOUTR, TimeoutAMode);
X  ((I2Cx->TIMEOUTR) = (TimeoutAMode));
N}
N
N/**
N  * @brief  Get the SMBus Clock TimeoutA mode.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIDLE         LL_I2C_GetSMBusTimeoutAMode
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA_MODE_SCL_LOW
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA_MODE_SDA_SCL_HIGH
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetSMBusTimeoutAMode(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetSMBusTimeoutAMode(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIDLE));
X  return (uint32_t)(((I2Cx->TIMEOUTR) & ((0x1UL << (12U)))));
N}
N
N/**
N  * @brief  Configure the SMBus Extended Cumulative Clock TimeoutB (Master or Slave mode).
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   These bits can only be programmed when TimeoutB is disabled.
N  * @rmtoll TIMEOUTR     TIMEOUTB      LL_I2C_SetSMBusTimeoutB
N  * @param  I2Cx I2C Instance.
N  * @param  TimeoutB This parameter must be a value between  Min_Data=0 and Max_Data=0xFFF.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetSMBusTimeoutB(I2C_TypeDef *I2Cx, uint32_t TimeoutB)
Xstatic __inline void LL_I2C_SetSMBusTimeoutB(I2C_TypeDef *I2Cx, uint32_t TimeoutB)
N{
N  WRITE_REG(I2Cx->TIMEOUTR, TimeoutB << I2C_TIMEOUTR_TIMEOUTB_Pos);
X  ((I2Cx->TIMEOUTR) = (TimeoutB << (16U)));
N}
N
N/**
N  * @brief  Get the SMBus Extented Cumulative Clock TimeoutB setting.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMEOUTB      LL_I2C_GetSMBusTimeoutB
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetSMBusTimeoutB(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetSMBusTimeoutB(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->TIMEOUTR, I2C_TIMEOUTR_TIMEOUTB) >> I2C_TIMEOUTR_TIMEOUTB_Pos);
X  return (uint32_t)(((I2Cx->TIMEOUTR) & ((0xFFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Enable the SMBus Clock Timeout.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMOUTEN      LL_I2C_EnableSMBusTimeout\n
N  *         TIMEOUTR     TEXTEN        LL_I2C_EnableSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  ClockTimeout This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTB
N  *         @arg @ref LL_I2C_SMBUS_ALL_TIMEOUT
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout)
Xstatic __inline void LL_I2C_EnableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout)
N{
N  SET_BIT(I2Cx->TIMEOUTR, ClockTimeout);
X  ((I2Cx->TIMEOUTR) |= (ClockTimeout));
N}
N
N/**
N  * @brief  Disable the SMBus Clock Timeout.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMOUTEN      LL_I2C_DisableSMBusTimeout\n
N  *         TIMEOUTR     TEXTEN        LL_I2C_DisableSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  ClockTimeout This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTB
N  *         @arg @ref LL_I2C_SMBUS_ALL_TIMEOUT
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout)
Xstatic __inline void LL_I2C_DisableSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout)
N{
N  CLEAR_BIT(I2Cx->TIMEOUTR, ClockTimeout);
X  ((I2Cx->TIMEOUTR) &= ~(ClockTimeout));
N}
N
N/**
N  * @brief  Check if the SMBus Clock Timeout is enabled or disabled.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll TIMEOUTR     TIMOUTEN      LL_I2C_IsEnabledSMBusTimeout\n
N  *         TIMEOUTR     TEXTEN        LL_I2C_IsEnabledSMBusTimeout
N  * @param  I2Cx I2C Instance.
N  * @param  ClockTimeout This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTA
N  *         @arg @ref LL_I2C_SMBUS_TIMEOUTB
N  *         @arg @ref LL_I2C_SMBUS_ALL_TIMEOUT
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout)
Xstatic __inline uint32_t LL_I2C_IsEnabledSMBusTimeout(I2C_TypeDef *I2Cx, uint32_t ClockTimeout)
N{
N  return (READ_BIT(I2Cx->TIMEOUTR, (I2C_TIMEOUTR_TIMOUTEN | I2C_TIMEOUTR_TEXTEN)) == (ClockTimeout));
X  return (((I2Cx->TIMEOUTR) & (((0x1UL << (15U)) | (0x1UL << (31U))))) == (ClockTimeout));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EF_IT_Management IT_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable TXIS interrupt.
N  * @rmtoll CR1          TXIE          LL_I2C_EnableIT_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_TX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_TX(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_TXIE);
X  ((I2Cx->CR1) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable TXIS interrupt.
N  * @rmtoll CR1          TXIE          LL_I2C_DisableIT_TX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_TX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_TX(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_TXIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if the TXIS Interrupt is enabled or disabled.
N  * @rmtoll CR1          TXIE          LL_I2C_IsEnabledIT_TX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_TXIE) == (I2C_CR1_TXIE));
X  return (((I2Cx->CR1) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable RXNE interrupt.
N  * @rmtoll CR1          RXIE          LL_I2C_EnableIT_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_RX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_RX(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_RXIE);
X  ((I2Cx->CR1) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable RXNE interrupt.
N  * @rmtoll CR1          RXIE          LL_I2C_DisableIT_RX
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_RX(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_RX(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_RXIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Check if the RXNE Interrupt is enabled or disabled.
N  * @rmtoll CR1          RXIE          LL_I2C_IsEnabledIT_RX
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_RXIE) == (I2C_CR1_RXIE));
X  return (((I2Cx->CR1) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable Address match interrupt (slave mode only).
N  * @rmtoll CR1          ADDRIE        LL_I2C_EnableIT_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_ADDR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_ADDR(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_ADDRIE);
X  ((I2Cx->CR1) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable Address match interrupt (slave mode only).
N  * @rmtoll CR1          ADDRIE        LL_I2C_DisableIT_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_ADDR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_ADDR(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ADDRIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if Address match interrupt is enabled or disabled.
N  * @rmtoll CR1          ADDRIE        LL_I2C_IsEnabledIT_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_ADDR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_ADDR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_ADDRIE) == (I2C_CR1_ADDRIE));
X  return (((I2Cx->CR1) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Enable Not acknowledge received interrupt.
N  * @rmtoll CR1          NACKIE        LL_I2C_EnableIT_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_NACK(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_NACK(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_NACKIE);
X  ((I2Cx->CR1) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable Not acknowledge received interrupt.
N  * @rmtoll CR1          NACKIE        LL_I2C_DisableIT_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_NACK(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_NACK(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_NACKIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Check if Not acknowledge received interrupt is enabled or disabled.
N  * @rmtoll CR1          NACKIE        LL_I2C_IsEnabledIT_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_NACK(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_NACK(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_NACKIE) == (I2C_CR1_NACKIE));
X  return (((I2Cx->CR1) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable STOP detection interrupt.
N  * @rmtoll CR1          STOPIE        LL_I2C_EnableIT_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_STOP(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_STOP(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_STOPIE);
X  ((I2Cx->CR1) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable STOP detection interrupt.
N  * @rmtoll CR1          STOPIE        LL_I2C_DisableIT_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_STOP(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_STOP(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_STOPIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Check if STOP detection interrupt is enabled or disabled.
N  * @rmtoll CR1          STOPIE        LL_I2C_IsEnabledIT_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_STOP(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_STOP(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_STOPIE) == (I2C_CR1_STOPIE));
X  return (((I2Cx->CR1) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Enable Transfer Complete interrupt.
N  * @note   Any of these events will generate interrupt :
N  *         Transfer Complete (TC)
N  *         Transfer Complete Reload (TCR)
N  * @rmtoll CR1          TCIE          LL_I2C_EnableIT_TC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_TC(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_TC(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_TCIE);
X  ((I2Cx->CR1) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable Transfer Complete interrupt.
N  * @note   Any of these events will generate interrupt :
N  *         Transfer Complete (TC)
N  *         Transfer Complete Reload (TCR)
N  * @rmtoll CR1          TCIE          LL_I2C_DisableIT_TC
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_TC(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_TC(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_TCIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if Transfer Complete interrupt is enabled or disabled.
N  * @rmtoll CR1          TCIE          LL_I2C_IsEnabledIT_TC
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_TC(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_TC(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_TCIE) == (I2C_CR1_TCIE));
X  return (((I2Cx->CR1) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable Error interrupts.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   Any of these errors will generate interrupt :
N  *         Arbitration Loss (ARLO)
N  *         Bus Error detection (BERR)
N  *         Overrun/Underrun (OVR)
N  *         SMBus Timeout detection (TIMEOUT)
N  *         SMBus PEC error detection (PECERR)
N  *         SMBus Alert pin event detection (ALERT)
N  * @rmtoll CR1          ERRIE         LL_I2C_EnableIT_ERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR1, I2C_CR1_ERRIE);
X  ((I2Cx->CR1) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable Error interrupts.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   Any of these errors will generate interrupt :
N  *         Arbitration Loss (ARLO)
N  *         Bus Error detection (BERR)
N  *         Overrun/Underrun (OVR)
N  *         SMBus Timeout detection (TIMEOUT)
N  *         SMBus PEC error detection (PECERR)
N  *         SMBus Alert pin event detection (ALERT)
N  * @rmtoll CR1          ERRIE         LL_I2C_DisableIT_ERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ERRIE);
X  ((I2Cx->CR1) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if Error interrupts are enabled or disabled.
N  * @rmtoll CR1          ERRIE         LL_I2C_IsEnabledIT_ERR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR1, I2C_CR1_ERRIE) == (I2C_CR1_ERRIE));
X  return (((I2Cx->CR1) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EF_FLAG_management FLAG_management
N  * @{
N  */
N
N/**
N  * @brief  Indicate the status of Transmit data register empty flag.
N  * @note   RESET: When next data is written in Transmit data register.
N  *         SET: When Transmit data register is empty.
N  * @rmtoll ISR          TXE           LL_I2C_IsActiveFlag_TXE
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_TXE) == (I2C_ISR_TXE));
X  return (((I2Cx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Indicate the status of Transmit interrupt flag.
N  * @note   RESET: When next data is written in Transmit data register.
N  *         SET: When Transmit data register is empty.
N  * @rmtoll ISR          TXIS          LL_I2C_IsActiveFlag_TXIS
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TXIS(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_TXIS(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_TXIS) == (I2C_ISR_TXIS));
X  return (((I2Cx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Indicate the status of Receive data register not empty flag.
N  * @note   RESET: When Receive data register is read.
N  *         SET: When the received data is copied in Receive data register.
N  * @rmtoll ISR          RXNE          LL_I2C_IsActiveFlag_RXNE
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_RXNE) == (I2C_ISR_RXNE));
X  return (((I2Cx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Indicate the status of Address matched flag (slave mode).
N  * @note   RESET: Clear default value.
N  *         SET: When the received slave address matched with one of the enabled slave address.
N  * @rmtoll ISR          ADDR          LL_I2C_IsActiveFlag_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_ADDR) == (I2C_ISR_ADDR));
X  return (((I2Cx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Indicate the status of Not Acknowledge received flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a NACK is received after a byte transmission.
N  * @rmtoll ISR          NACKF         LL_I2C_IsActiveFlag_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_NACK(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_NACK(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_NACKF) == (I2C_ISR_NACKF));
X  return (((I2Cx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Indicate the status of Stop detection flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a Stop condition is detected.
N  * @rmtoll ISR          STOPF         LL_I2C_IsActiveFlag_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_STOPF) == (I2C_ISR_STOPF));
X  return (((I2Cx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Indicate the status of Transfer complete flag (master mode).
N  * @note   RESET: Clear default value.
N  *         SET: When RELOAD=0, AUTOEND=0 and NBYTES date have been transferred.
N  * @rmtoll ISR          TC            LL_I2C_IsActiveFlag_TC
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TC(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_TC(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_TC) == (I2C_ISR_TC));
X  return (((I2Cx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Indicate the status of Transfer complete flag (master mode).
N  * @note   RESET: Clear default value.
N  *         SET: When RELOAD=1 and NBYTES date have been transferred.
N  * @rmtoll ISR          TCR           LL_I2C_IsActiveFlag_TCR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TCR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_TCR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_TCR) == (I2C_ISR_TCR));
X  return (((I2Cx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Indicate the status of Bus error flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a misplaced Start or Stop condition is detected.
N  * @rmtoll ISR          BERR          LL_I2C_IsActiveFlag_BERR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_BERR) == (I2C_ISR_BERR));
X  return (((I2Cx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Indicate the status of Arbitration lost flag.
N  * @note   RESET: Clear default value.
N  *         SET: When arbitration lost.
N  * @rmtoll ISR          ARLO          LL_I2C_IsActiveFlag_ARLO
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_ARLO) == (I2C_ISR_ARLO));
X  return (((I2Cx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Indicate the status of Overrun/Underrun flag (slave mode).
N  * @note   RESET: Clear default value.
N  *         SET: When an overrun/underrun error occurs (Clock Stretching Disabled).
N  * @rmtoll ISR          OVR           LL_I2C_IsActiveFlag_OVR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_OVR) == (I2C_ISR_OVR));
X  return (((I2Cx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Indicate the status of SMBus PEC error flag in reception.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   RESET: Clear default value.
N  *         SET: When the received PEC does not match with the PEC register content.
N  * @rmtoll ISR          PECERR        LL_I2C_IsActiveSMBusFlag_PECERR
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_PECERR) == (I2C_ISR_PECERR));
X  return (((I2Cx->ISR) & ((0x1UL << (11U)))) == ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Indicate the status of SMBus Timeout detection flag.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   RESET: Clear default value.
N  *         SET: When a timeout or extended clock timeout occurs.
N  * @rmtoll ISR          TIMEOUT       LL_I2C_IsActiveSMBusFlag_TIMEOUT
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_TIMEOUT) == (I2C_ISR_TIMEOUT));
X  return (((I2Cx->ISR) & ((0x1UL << (12U)))) == ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Indicate the status of SMBus alert flag.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   RESET: Clear default value.
N  *         SET: When SMBus host configuration, SMBus alert enabled and
N  *              a falling edge event occurs on SMBA pin.
N  * @rmtoll ISR          ALERT         LL_I2C_IsActiveSMBusFlag_ALERT
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_ALERT) == (I2C_ISR_ALERT));
X  return (((I2Cx->ISR) & ((0x1UL << (13U)))) == ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Indicate the status of Bus Busy flag.
N  * @note   RESET: Clear default value.
N  *         SET: When a Start condition is detected.
N  * @rmtoll ISR          BUSY          LL_I2C_IsActiveFlag_BUSY
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->ISR, I2C_ISR_BUSY) == (I2C_ISR_BUSY));
X  return (((I2Cx->ISR) & ((0x1UL << (15U)))) == ((0x1UL << (15U))));
N}
N
N/**
N  * @brief  Clear Address Matched flag.
N  * @rmtoll ICR          ADDRCF        LL_I2C_ClearFlag_ADDR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_ADDRCF);
X  ((I2Cx->ICR) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear Not Acknowledge flag.
N  * @rmtoll ICR          NACKCF        LL_I2C_ClearFlag_NACK
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_NACK(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_NACK(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_NACKCF);
X  ((I2Cx->ICR) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear Stop detection flag.
N  * @rmtoll ICR          STOPCF        LL_I2C_ClearFlag_STOP
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_STOPCF);
X  ((I2Cx->ICR) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Clear Transmit data register empty flag (TXE).
N  * @note   This bit can be clear by software in order to flush the transmit data register (TXDR).
N  * @rmtoll ISR          TXE           LL_I2C_ClearFlag_TXE
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_TXE(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_TXE(I2C_TypeDef *I2Cx)
N{
N  WRITE_REG(I2Cx->ISR, I2C_ISR_TXE);
X  ((I2Cx->ISR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear Bus error flag.
N  * @rmtoll ICR          BERRCF        LL_I2C_ClearFlag_BERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_BERR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_BERR(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_BERRCF);
X  ((I2Cx->ICR) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear Arbitration lost flag.
N  * @rmtoll ICR          ARLOCF        LL_I2C_ClearFlag_ARLO
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_ARLO(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_ARLO(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_ARLOCF);
X  ((I2Cx->ICR) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear Overrun/Underrun flag.
N  * @rmtoll ICR          OVRCF         LL_I2C_ClearFlag_OVR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearFlag_OVR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearFlag_OVR(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_OVRCF);
X  ((I2Cx->ICR) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Clear SMBus PEC error flag.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll ICR          PECCF         LL_I2C_ClearSMBusFlag_PECERR
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_PECCF);
X  ((I2Cx->ICR) |= ((0x1UL << (11U))));
N}
N
N/**
N  * @brief  Clear SMBus Timeout detection flag.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll ICR          TIMOUTCF      LL_I2C_ClearSMBusFlag_TIMEOUT
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_TIMOUTCF);
X  ((I2Cx->ICR) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Clear SMBus Alert flag.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll ICR          ALERTCF       LL_I2C_ClearSMBusFlag_ALERT
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_ClearSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_ClearSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->ICR, I2C_ICR_ALERTCF);
X  ((I2Cx->ICR) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_LL_EF_Data_Management Data_Management
N  * @{
N  */
N
N/**
N  * @brief  Enable automatic STOP condition generation (master mode).
N  * @note   Automatic end mode : a STOP condition is automatically sent when NBYTES data are transferred.
N  *         This bit has no effect in slave mode or when RELOAD bit is set.
N  * @rmtoll CR2          AUTOEND       LL_I2C_EnableAutoEndMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableAutoEndMode(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableAutoEndMode(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR2, I2C_CR2_AUTOEND);
X  ((I2Cx->CR2) |= ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Disable automatic STOP condition generation (master mode).
N  * @note   Software end mode : TC flag is set when NBYTES data are transferre, stretching SCL low.
N  * @rmtoll CR2          AUTOEND       LL_I2C_DisableAutoEndMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableAutoEndMode(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableAutoEndMode(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR2, I2C_CR2_AUTOEND);
X  ((I2Cx->CR2) &= ~((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Check if automatic STOP condition is enabled or disabled.
N  * @rmtoll CR2          AUTOEND       LL_I2C_IsEnabledAutoEndMode
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledAutoEndMode(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledAutoEndMode(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR2, I2C_CR2_AUTOEND) == (I2C_CR2_AUTOEND));
X  return (((I2Cx->CR2) & ((0x1UL << (25U)))) == ((0x1UL << (25U))));
N}
N
N/**
N  * @brief  Enable reload mode (master mode).
N  * @note   The transfer is not completed after the NBYTES data transfer, NBYTES will be reloaded when TCR flag is set.
N  * @rmtoll CR2          RELOAD       LL_I2C_EnableReloadMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableReloadMode(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableReloadMode(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR2, I2C_CR2_RELOAD);
X  ((I2Cx->CR2) |= ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Disable reload mode (master mode).
N  * @note   The transfer is completed after the NBYTES data transfer(STOP or RESTART will follow).
N  * @rmtoll CR2          RELOAD       LL_I2C_DisableReloadMode
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableReloadMode(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableReloadMode(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR2, I2C_CR2_RELOAD);
X  ((I2Cx->CR2) &= ~((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Check if reload mode is enabled or disabled.
N  * @rmtoll CR2          RELOAD       LL_I2C_IsEnabledReloadMode
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledReloadMode(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledReloadMode(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR2, I2C_CR2_RELOAD) == (I2C_CR2_RELOAD));
X  return (((I2Cx->CR2) & ((0x1UL << (24U)))) == ((0x1UL << (24U))));
N}
N
N/**
N  * @brief  Configure the number of bytes for transfer.
N  * @note   Changing these bits when START bit is set is not allowed.
N  * @rmtoll CR2          NBYTES           LL_I2C_SetTransferSize
N  * @param  I2Cx I2C Instance.
N  * @param  TransferSize This parameter must be a value between Min_Data=0x00 and Max_Data=0xFF.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetTransferSize(I2C_TypeDef *I2Cx, uint32_t TransferSize)
Xstatic __inline void LL_I2C_SetTransferSize(I2C_TypeDef *I2Cx, uint32_t TransferSize)
N{
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_NBYTES, TransferSize << I2C_CR2_NBYTES_Pos);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0xFFUL << (16U))))) | (TransferSize << (16U)))));
N}
N
N/**
N  * @brief  Get the number of bytes configured for transfer.
N  * @rmtoll CR2          NBYTES           LL_I2C_GetTransferSize
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetTransferSize(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetTransferSize(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_NBYTES) >> I2C_CR2_NBYTES_Pos);
X  return (uint32_t)(((I2Cx->CR2) & ((0xFFUL << (16U)))) >> (16U));
N}
N
N/**
N  * @brief  Prepare the generation of a ACKnowledge or Non ACKnowledge condition after the address receive match code or next received byte.
N  * @note   Usage in Slave mode only.
N  * @rmtoll CR2          NACK          LL_I2C_AcknowledgeNextData
N  * @param  I2Cx I2C Instance.
N  * @param  TypeAcknowledge This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_ACK
N  *         @arg @ref LL_I2C_NACK
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx, uint32_t TypeAcknowledge)
Xstatic __inline void LL_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx, uint32_t TypeAcknowledge)
N{
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_NACK, TypeAcknowledge);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x1UL << (15U))))) | (TypeAcknowledge))));
N}
N
N/**
N  * @brief  Generate a START or RESTART condition
N  * @note   The START bit can be set even if bus is BUSY or I2C is in slave mode.
N  *         This action has no effect when RELOAD is set.
N  * @rmtoll CR2          START           LL_I2C_GenerateStartCondition
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_GenerateStartCondition(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_GenerateStartCondition(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR2, I2C_CR2_START);
X  ((I2Cx->CR2) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Generate a STOP condition after the current byte transfer (master mode).
N  * @rmtoll CR2          STOP          LL_I2C_GenerateStopCondition
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_GenerateStopCondition(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_GenerateStopCondition(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR2, I2C_CR2_STOP);
X  ((I2Cx->CR2) |= ((0x1UL << (14U))));
N}
N
N/**
N  * @brief  Enable automatic RESTART Read request condition for 10bit address header (master mode).
N  * @note   The master sends the complete 10bit slave address read sequence :
N  *         Start + 2 bytes 10bit address in Write direction + Restart + first 7 bits of 10bit address in Read direction.
N  * @rmtoll CR2          HEAD10R       LL_I2C_EnableAuto10BitRead
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableAuto10BitRead(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableAuto10BitRead(I2C_TypeDef *I2Cx)
N{
N  CLEAR_BIT(I2Cx->CR2, I2C_CR2_HEAD10R);
X  ((I2Cx->CR2) &= ~((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Disable automatic RESTART Read request condition for 10bit address header (master mode).
N  * @note   The master only sends the first 7 bits of 10bit address in Read direction.
N  * @rmtoll CR2          HEAD10R       LL_I2C_DisableAuto10BitRead
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_DisableAuto10BitRead(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_DisableAuto10BitRead(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR2, I2C_CR2_HEAD10R);
X  ((I2Cx->CR2) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Check if automatic RESTART Read request condition for 10bit address header is enabled or disabled.
N  * @rmtoll CR2          HEAD10R       LL_I2C_IsEnabledAuto10BitRead
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledAuto10BitRead(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledAuto10BitRead(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR2, I2C_CR2_HEAD10R) != (I2C_CR2_HEAD10R));
X  return (((I2Cx->CR2) & ((0x1UL << (12U)))) != ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Configure the transfer direction (master mode).
N  * @note   Changing these bits when START bit is set is not allowed.
N  * @rmtoll CR2          RD_WRN           LL_I2C_SetTransferRequest
N  * @param  I2Cx I2C Instance.
N  * @param  TransferRequest This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_REQUEST_WRITE
N  *         @arg @ref LL_I2C_REQUEST_READ
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetTransferRequest(I2C_TypeDef *I2Cx, uint32_t TransferRequest)
Xstatic __inline void LL_I2C_SetTransferRequest(I2C_TypeDef *I2Cx, uint32_t TransferRequest)
N{
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_RD_WRN, TransferRequest);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x1UL << (10U))))) | (TransferRequest))));
N}
N
N/**
N  * @brief  Get the transfer direction requested (master mode).
N  * @rmtoll CR2          RD_WRN           LL_I2C_GetTransferRequest
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_I2C_REQUEST_WRITE
N  *         @arg @ref LL_I2C_REQUEST_READ
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetTransferRequest(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetTransferRequest(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_RD_WRN));
X  return (uint32_t)(((I2Cx->CR2) & ((0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Configure the slave address for transfer (master mode).
N  * @note   Changing these bits when START bit is set is not allowed.
N  * @rmtoll CR2          SADD           LL_I2C_SetSlaveAddr
N  * @param  I2Cx I2C Instance.
N  * @param  SlaveAddr This parameter must be a value between Min_Data=0x00 and Max_Data=0x3F.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_SetSlaveAddr(I2C_TypeDef *I2Cx, uint32_t SlaveAddr)
Xstatic __inline void LL_I2C_SetSlaveAddr(I2C_TypeDef *I2Cx, uint32_t SlaveAddr)
N{
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_SADD, SlaveAddr);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x3FFUL << (0U))))) | (SlaveAddr))));
N}
N
N/**
N  * @brief  Get the slave address programmed for transfer.
N  * @rmtoll CR2          SADD           LL_I2C_GetSlaveAddr
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x0 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetSlaveAddr(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetSlaveAddr(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->CR2, I2C_CR2_SADD));
X  return (uint32_t)(((I2Cx->CR2) & ((0x3FFUL << (0U)))));
N}
N
N/**
N  * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
N  * @rmtoll CR2          SADD          LL_I2C_HandleTransfer\n
N  *         CR2          ADD10         LL_I2C_HandleTransfer\n
N  *         CR2          RD_WRN        LL_I2C_HandleTransfer\n
N  *         CR2          START         LL_I2C_HandleTransfer\n
N  *         CR2          STOP          LL_I2C_HandleTransfer\n
N  *         CR2          RELOAD        LL_I2C_HandleTransfer\n
N  *         CR2          NBYTES        LL_I2C_HandleTransfer\n
N  *         CR2          AUTOEND       LL_I2C_HandleTransfer\n
N  *         CR2          HEAD10R       LL_I2C_HandleTransfer
N  * @param  I2Cx I2C Instance.
N  * @param  SlaveAddr Specifies the slave address to be programmed.
N  * @param  SlaveAddrSize This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_ADDRSLAVE_7BIT
N  *         @arg @ref LL_I2C_ADDRSLAVE_10BIT
N  * @param  TransferSize Specifies the number of bytes to be programmed.
N  *                       This parameter must be a value between Min_Data=0 and Max_Data=255.
N  * @param  EndMode This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_MODE_RELOAD
N  *         @arg @ref LL_I2C_MODE_AUTOEND
N  *         @arg @ref LL_I2C_MODE_SOFTEND
N  *         @arg @ref LL_I2C_MODE_SMBUS_RELOAD
N  *         @arg @ref LL_I2C_MODE_SMBUS_AUTOEND_NO_PEC
N  *         @arg @ref LL_I2C_MODE_SMBUS_SOFTEND_NO_PEC
N  *         @arg @ref LL_I2C_MODE_SMBUS_AUTOEND_WITH_PEC
N  *         @arg @ref LL_I2C_MODE_SMBUS_SOFTEND_WITH_PEC
N  * @param  Request This parameter can be one of the following values:
N  *         @arg @ref LL_I2C_GENERATE_NOSTARTSTOP
N  *         @arg @ref LL_I2C_GENERATE_STOP
N  *         @arg @ref LL_I2C_GENERATE_START_READ
N  *         @arg @ref LL_I2C_GENERATE_START_WRITE
N  *         @arg @ref LL_I2C_GENERATE_RESTART_7BIT_READ
N  *         @arg @ref LL_I2C_GENERATE_RESTART_7BIT_WRITE
N  *         @arg @ref LL_I2C_GENERATE_RESTART_10BIT_READ
N  *         @arg @ref LL_I2C_GENERATE_RESTART_10BIT_WRITE
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_HandleTransfer(I2C_TypeDef *I2Cx, uint32_t SlaveAddr, uint32_t SlaveAddrSize,
Xstatic __inline void LL_I2C_HandleTransfer(I2C_TypeDef *I2Cx, uint32_t SlaveAddr, uint32_t SlaveAddrSize,
N                                           uint32_t TransferSize, uint32_t EndMode, uint32_t Request)
N{
N  MODIFY_REG(I2Cx->CR2, I2C_CR2_SADD | I2C_CR2_ADD10 | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP | I2C_CR2_RELOAD |
N             I2C_CR2_NBYTES | I2C_CR2_AUTOEND | I2C_CR2_HEAD10R,
N             SlaveAddr | SlaveAddrSize | (TransferSize << I2C_CR2_NBYTES_Pos) | EndMode | Request);
X  (((I2Cx->CR2)) = ((((((I2Cx->CR2))) & (~((0x3FFUL << (0U)) | (0x1UL << (11U)) | ((0x1UL << (10U)) & (uint32_t)(Request >> (31U - (10U)))) | (0x1UL << (13U)) | (0x1UL << (14U)) | (0x1UL << (24U)) | (0xFFUL << (16U)) | (0x1UL << (25U)) | (0x1UL << (12U))))) | (SlaveAddr | SlaveAddrSize | (TransferSize << (16U)) | EndMode | Request))));
N}
N
N/**
N  * @brief  Indicate the value of transfer direction (slave mode).
N  * @note   RESET: Write transfer, Slave enters in receiver mode.
N  *         SET: Read transfer, Slave enters in transmitter mode.
N  * @rmtoll ISR          DIR           LL_I2C_GetTransferDirection
N  * @param  I2Cx I2C Instance.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_I2C_DIRECTION_WRITE
N  *         @arg @ref LL_I2C_DIRECTION_READ
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetTransferDirection(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetTransferDirection(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->ISR, I2C_ISR_DIR));
X  return (uint32_t)(((I2Cx->ISR) & ((0x1UL << (16U)))));
N}
N
N/**
N  * @brief  Return the slave matched address.
N  * @rmtoll ISR          ADDCODE       LL_I2C_GetAddressMatchCode
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint32_t LL_I2C_GetAddressMatchCode(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetAddressMatchCode(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->ISR, I2C_ISR_ADDCODE) >> I2C_ISR_ADDCODE_Pos << 1);
X  return (uint32_t)(((I2Cx->ISR) & ((0x7FUL << (17U)))) >> (17U) << 1);
N}
N
N/**
N  * @brief  Enable internal comparison of the SMBus Packet Error byte (transmission or reception mode).
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @note   This feature is cleared by hardware when the PEC byte is transferred, or when a STOP condition or an Address Matched is received.
N  *         This bit has no effect when RELOAD bit is set.
N  *         This bit has no effect in device mode when SBC bit is not set.
N  * @rmtoll CR2          PECBYTE       LL_I2C_EnableSMBusPECCompare
N  * @param  I2Cx I2C Instance.
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_EnableSMBusPECCompare(I2C_TypeDef *I2Cx)
Xstatic __inline void LL_I2C_EnableSMBusPECCompare(I2C_TypeDef *I2Cx)
N{
N  SET_BIT(I2Cx->CR2, I2C_CR2_PECBYTE);
X  ((I2Cx->CR2) |= ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Check if the SMBus Packet Error byte internal comparison is requested or not.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll CR2          PECBYTE       LL_I2C_IsEnabledSMBusPECCompare
N  * @param  I2Cx I2C Instance.
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusPECCompare(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_IsEnabledSMBusPECCompare(I2C_TypeDef *I2Cx)
N{
N  return (READ_BIT(I2Cx->CR2, I2C_CR2_PECBYTE) == (I2C_CR2_PECBYTE));
X  return (((I2Cx->CR2) & ((0x1UL << (26U)))) == ((0x1UL << (26U))));
N}
N
N/**
N  * @brief  Get the SMBus Packet Error byte calculated.
N  * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
N  *         SMBus feature is supported by the I2Cx Instance.
N  * @rmtoll PECR         PEC           LL_I2C_GetSMBusPEC
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N*/
N__STATIC_INLINE uint32_t LL_I2C_GetSMBusPEC(I2C_TypeDef *I2Cx)
Xstatic __inline uint32_t LL_I2C_GetSMBusPEC(I2C_TypeDef *I2Cx)
N{
N  return (uint32_t)(READ_BIT(I2Cx->PECR, I2C_PECR_PEC));
X  return (uint32_t)(((I2Cx->PECR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Read Receive Data register.
N  * @rmtoll RXDR         RXDATA        LL_I2C_ReceiveData8
N  * @param  I2Cx I2C Instance.
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t LL_I2C_ReceiveData8(I2C_TypeDef *I2Cx)
Xstatic __inline uint8_t LL_I2C_ReceiveData8(I2C_TypeDef *I2Cx)
N{
N  return (uint8_t)(READ_BIT(I2Cx->RXDR, I2C_RXDR_RXDATA));
X  return (uint8_t)(((I2Cx->RXDR) & ((0xFFUL << (0U)))));
N}
N
N/**
N  * @brief  Write in Transmit Data Register .
N  * @rmtoll TXDR         TXDATA        LL_I2C_TransmitData8
N  * @param  I2Cx I2C Instance.
N  * @param  Data Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_I2C_TransmitData8(I2C_TypeDef *I2Cx, uint8_t Data)
Xstatic __inline void LL_I2C_TransmitData8(I2C_TypeDef *I2Cx, uint8_t Data)
N{
N  WRITE_REG(I2Cx->TXDR, Data);
X  ((I2Cx->TXDR) = (Data));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup I2C_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
Nuint32_t LL_I2C_Init(I2C_TypeDef *I2Cx, LL_I2C_InitTypeDef *I2C_InitStruct);
Nuint32_t LL_I2C_DeInit(I2C_TypeDef *I2Cx);
Nvoid LL_I2C_StructInit(LL_I2C_InitTypeDef *I2C_InitStruct);
N
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* I2C1 || I2C2 || I2C3 || I2C4 */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_I2C_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 18 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_spi.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_spi.h
N  * @author  MCD Application Team
N  * @brief   Header file of SPI LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_SPI_H
N#define __STM32L4xx_LL_SPI_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (SPI1) || defined (SPI2) || defined (SPI3)
X#if 1L || 1L || 1L
N
N/** @defgroup SPI_LL SPI
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup SPI_LL_ES_INIT SPI Exported Init structure
N  * @{
N  */
N
N/**
N  * @brief  SPI Init structures definition
N  */
Ntypedef struct
N{
N  uint32_t TransferDirection;       /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_LL_EC_TRANSFER_MODE.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferDirection().*/
N
N  uint32_t Mode;                    /*!< Specifies the SPI mode (Master/Slave).
N                                         This parameter can be a value of @ref SPI_LL_EC_MODE.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetMode().*/
N
N  uint32_t DataWidth;               /*!< Specifies the SPI data width.
N                                         This parameter can be a value of @ref SPI_LL_EC_DATAWIDTH.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetDataWidth().*/
N
N  uint32_t ClockPolarity;           /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_LL_EC_POLARITY.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPolarity().*/
N
N  uint32_t ClockPhase;              /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_LL_EC_PHASE.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPhase().*/
N
N  uint32_t NSS;                     /*!< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_LL_EC_NSS_MODE.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetNSSMode().*/
N
N  uint32_t BaudRate;                /*!< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_LL_EC_BAUDRATEPRESCALER.
N                                         @note The communication clock is derived from the master clock. The slave clock does not need to be set.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetBaudRatePrescaler().*/
N
N  uint32_t BitOrder;                /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_LL_EC_BIT_ORDER.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferBitOrder().*/
N
N  uint32_t CRCCalculation;          /*!< Specifies if the CRC calculation is enabled or not.
N                                         This parameter can be a value of @ref SPI_LL_EC_CRC_CALCULATION.
N
N                                         This feature can be modified afterwards using unitary functions @ref LL_SPI_EnableCRC() and @ref LL_SPI_DisableCRC().*/
N
N  uint32_t CRCPoly;                 /*!< Specifies the polynomial used for the CRC calculation.
N                                         This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF.
N
N                                         This feature can be modified afterwards using unitary function @ref LL_SPI_SetCRCPolynomial().*/
N
N} LL_SPI_InitTypeDef;
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SPI_LL_Exported_Constants SPI Exported Constants
N  * @{
N  */
N
N/** @defgroup SPI_LL_EC_GET_FLAG Get Flags Defines
N  * @brief    Flags defines which can be used with LL_SPI_ReadReg function
N  * @{
N  */
N#define LL_SPI_SR_RXNE                     SPI_SR_RXNE               /*!< Rx buffer not empty flag         */
N#define LL_SPI_SR_TXE                      SPI_SR_TXE                /*!< Tx buffer empty flag             */
N#define LL_SPI_SR_BSY                      SPI_SR_BSY                /*!< Busy flag                        */
N#define LL_SPI_SR_CRCERR                   SPI_SR_CRCERR             /*!< CRC error flag                   */
N#define LL_SPI_SR_MODF                     SPI_SR_MODF               /*!< Mode fault flag                  */
N#define LL_SPI_SR_OVR                      SPI_SR_OVR                /*!< Overrun flag                     */
N#define LL_SPI_SR_FRE                      SPI_SR_FRE                /*!< TI mode frame format error flag  */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_IT IT Defines
N  * @brief    IT defines which can be used with LL_SPI_ReadReg and  LL_SPI_WriteReg functions
N  * @{
N  */
N#define LL_SPI_CR2_RXNEIE                  SPI_CR2_RXNEIE            /*!< Rx buffer not empty interrupt enable */
N#define LL_SPI_CR2_TXEIE                   SPI_CR2_TXEIE             /*!< Tx buffer empty interrupt enable     */
N#define LL_SPI_CR2_ERRIE                   SPI_CR2_ERRIE             /*!< Error interrupt enable               */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_MODE Operation Mode
N  * @{
N  */
N#define LL_SPI_MODE_MASTER                 (SPI_CR1_MSTR | SPI_CR1_SSI)    /*!< Master configuration  */
N#define LL_SPI_MODE_SLAVE                  0x00000000U                     /*!< Slave configuration   */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_PROTOCOL Serial Protocol
N  * @{
N  */
N#define LL_SPI_PROTOCOL_MOTOROLA           0x00000000U               /*!< Motorola mode. Used as default value */
N#define LL_SPI_PROTOCOL_TI                 (SPI_CR2_FRF)             /*!< TI mode                              */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_PHASE Clock Phase
N  * @{
N  */
N#define LL_SPI_PHASE_1EDGE                 0x00000000U               /*!< First clock transition is the first data capture edge  */
N#define LL_SPI_PHASE_2EDGE                 (SPI_CR1_CPHA)            /*!< Second clock transition is the first data capture edge */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_POLARITY Clock Polarity
N  * @{
N  */
N#define LL_SPI_POLARITY_LOW                0x00000000U               /*!< Clock to 0 when idle */
N#define LL_SPI_POLARITY_HIGH               (SPI_CR1_CPOL)            /*!< Clock to 1 when idle */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_BAUDRATEPRESCALER Baud Rate Prescaler
N  * @{
N  */
N#define LL_SPI_BAUDRATEPRESCALER_DIV2      0x00000000U                                    /*!< BaudRate control equal to fPCLK/2   */
N#define LL_SPI_BAUDRATEPRESCALER_DIV4      (SPI_CR1_BR_0)                                 /*!< BaudRate control equal to fPCLK/4   */
N#define LL_SPI_BAUDRATEPRESCALER_DIV8      (SPI_CR1_BR_1)                                 /*!< BaudRate control equal to fPCLK/8   */
N#define LL_SPI_BAUDRATEPRESCALER_DIV16     (SPI_CR1_BR_1 | SPI_CR1_BR_0)                  /*!< BaudRate control equal to fPCLK/16  */
N#define LL_SPI_BAUDRATEPRESCALER_DIV32     (SPI_CR1_BR_2)                                 /*!< BaudRate control equal to fPCLK/32  */
N#define LL_SPI_BAUDRATEPRESCALER_DIV64     (SPI_CR1_BR_2 | SPI_CR1_BR_0)                  /*!< BaudRate control equal to fPCLK/64  */
N#define LL_SPI_BAUDRATEPRESCALER_DIV128    (SPI_CR1_BR_2 | SPI_CR1_BR_1)                  /*!< BaudRate control equal to fPCLK/128 */
N#define LL_SPI_BAUDRATEPRESCALER_DIV256    (SPI_CR1_BR_2 | SPI_CR1_BR_1 | SPI_CR1_BR_0)   /*!< BaudRate control equal to fPCLK/256 */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_BIT_ORDER Transmission Bit Order
N  * @{
N  */
N#define LL_SPI_LSB_FIRST                   (SPI_CR1_LSBFIRST)        /*!< Data is transmitted/received with the LSB first */
N#define LL_SPI_MSB_FIRST                   0x00000000U               /*!< Data is transmitted/received with the MSB first */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_TRANSFER_MODE Transfer Mode
N  * @{
N  */
N#define LL_SPI_FULL_DUPLEX                 0x00000000U                          /*!< Full-Duplex mode. Rx and Tx transfer on 2 lines */
N#define LL_SPI_SIMPLEX_RX                  (SPI_CR1_RXONLY)                     /*!< Simplex Rx mode.  Rx transfer only on 1 line    */
N#define LL_SPI_HALF_DUPLEX_RX              (SPI_CR1_BIDIMODE)                   /*!< Half-Duplex Rx mode. Rx transfer on 1 line      */
N#define LL_SPI_HALF_DUPLEX_TX              (SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE)  /*!< Half-Duplex Tx mode. Tx transfer on 1 line      */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_NSS_MODE Slave Select Pin Mode
N  * @{
N  */
N#define LL_SPI_NSS_SOFT                    (SPI_CR1_SSM)                     /*!< NSS managed internally. NSS pin not used and free              */
N#define LL_SPI_NSS_HARD_INPUT              0x00000000U                       /*!< NSS pin used in Input. Only used in Master mode                */
N#define LL_SPI_NSS_HARD_OUTPUT             (((uint32_t)SPI_CR2_SSOE << 16U)) /*!< NSS pin used in Output. Only used in Slave mode as chip select */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_DATAWIDTH Datawidth
N  * @{
N  */
N#define LL_SPI_DATAWIDTH_4BIT              (SPI_CR2_DS_0 | SPI_CR2_DS_1)                               /*!< Data length for SPI transfer:  4 bits */
N#define LL_SPI_DATAWIDTH_5BIT              (SPI_CR2_DS_2)                                              /*!< Data length for SPI transfer:  5 bits */
N#define LL_SPI_DATAWIDTH_6BIT              (SPI_CR2_DS_2 | SPI_CR2_DS_0)                               /*!< Data length for SPI transfer:  6 bits */
N#define LL_SPI_DATAWIDTH_7BIT              (SPI_CR2_DS_2 | SPI_CR2_DS_1)                               /*!< Data length for SPI transfer:  7 bits */
N#define LL_SPI_DATAWIDTH_8BIT              (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0)                /*!< Data length for SPI transfer:  8 bits */
N#define LL_SPI_DATAWIDTH_9BIT              (SPI_CR2_DS_3)                                              /*!< Data length for SPI transfer:  9 bits */
N#define LL_SPI_DATAWIDTH_10BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_0)                               /*!< Data length for SPI transfer: 10 bits */
N#define LL_SPI_DATAWIDTH_11BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_1)                               /*!< Data length for SPI transfer: 11 bits */
N#define LL_SPI_DATAWIDTH_12BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_1 | SPI_CR2_DS_0)                /*!< Data length for SPI transfer: 12 bits */
N#define LL_SPI_DATAWIDTH_13BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2)                               /*!< Data length for SPI transfer: 13 bits */
N#define LL_SPI_DATAWIDTH_14BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2 | SPI_CR2_DS_0)                /*!< Data length for SPI transfer: 14 bits */
N#define LL_SPI_DATAWIDTH_15BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2 | SPI_CR2_DS_1)                /*!< Data length for SPI transfer: 15 bits */
N#define LL_SPI_DATAWIDTH_16BIT             (SPI_CR2_DS_3 | SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0) /*!< Data length for SPI transfer: 16 bits */
N/**
N  * @}
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N
N/** @defgroup SPI_LL_EC_CRC_CALCULATION CRC Calculation
N  * @{
N  */
N#define LL_SPI_CRCCALCULATION_DISABLE      0x00000000U               /*!< CRC calculation disabled */
N#define LL_SPI_CRCCALCULATION_ENABLE       (SPI_CR1_CRCEN)           /*!< CRC calculation enabled  */
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/** @defgroup SPI_LL_EC_CRC_LENGTH CRC Length
N  * @{
N  */
N#define LL_SPI_CRC_8BIT                    0x00000000U               /*!<  8-bit CRC length */
N#define LL_SPI_CRC_16BIT                   (SPI_CR1_CRCL)            /*!< 16-bit CRC length */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_RX_FIFO_TH RX FIFO Threshold
N  * @{
N  */
N#define LL_SPI_RX_FIFO_TH_HALF             0x00000000U               /*!< RXNE event is generated if FIFO level is greater than or equel to 1/2 (16-bit) */
N#define LL_SPI_RX_FIFO_TH_QUARTER          (SPI_CR2_FRXTH)           /*!< RXNE event is generated if FIFO level is greater than or equel to 1/4 (8-bit)  */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_RX_FIFO RX FIFO Level
N  * @{
N  */
N#define LL_SPI_RX_FIFO_EMPTY               0x00000000U                       /*!< FIFO reception empty */
N#define LL_SPI_RX_FIFO_QUARTER_FULL        (SPI_SR_FRLVL_0)                  /*!< FIFO reception 1/4   */
N#define LL_SPI_RX_FIFO_HALF_FULL           (SPI_SR_FRLVL_1)                  /*!< FIFO reception 1/2   */
N#define LL_SPI_RX_FIFO_FULL                (SPI_SR_FRLVL_1 | SPI_SR_FRLVL_0) /*!< FIFO reception full  */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_TX_FIFO TX FIFO Level
N  * @{
N  */
N#define LL_SPI_TX_FIFO_EMPTY               0x00000000U                       /*!< FIFO transmission empty */
N#define LL_SPI_TX_FIFO_QUARTER_FULL        (SPI_SR_FTLVL_0)                  /*!< FIFO transmission 1/4   */
N#define LL_SPI_TX_FIFO_HALF_FULL           (SPI_SR_FTLVL_1)                  /*!< FIFO transmission 1/2   */
N#define LL_SPI_TX_FIFO_FULL                (SPI_SR_FTLVL_1 | SPI_SR_FTLVL_0) /*!< FIFO transmission full  */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EC_DMA_PARITY DMA Parity
N  * @{
N  */
N#define LL_SPI_DMA_PARITY_EVEN             0x00000000U   /*!< Select DMA parity Even */
N#define LL_SPI_DMA_PARITY_ODD              0x00000001U   /*!< Select DMA parity Odd  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup SPI_LL_Exported_Macros SPI Exported Macros
N  * @{
N  */
N
N/** @defgroup SPI_LL_EM_WRITE_READ Common Write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in SPI register
N  * @param  __INSTANCE__ SPI Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_SPI_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in SPI register
N  * @param  __INSTANCE__ SPI Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_SPI_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup SPI_LL_Exported_Functions SPI Exported Functions
N  * @{
N  */
N
N/** @defgroup SPI_LL_EF_Configuration Configuration
N  * @{
N  */
N
N/**
N  * @brief  Enable SPI peripheral
N  * @rmtoll CR1          SPE           LL_SPI_Enable
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_Enable(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_Enable(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR1, SPI_CR1_SPE);
X  ((SPIx->CR1) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable SPI peripheral
N  * @note   When disabling the SPI, follow the procedure described in the Reference Manual.
N  * @rmtoll CR1          SPE           LL_SPI_Disable
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_Disable(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_Disable(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
X  ((SPIx->CR1) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Check if SPI peripheral is enabled
N  * @rmtoll CR1          SPE           LL_SPI_IsEnabled
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabled(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabled(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
X  return ((((SPIx->CR1) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set SPI operation mode to Master or Slave
N  * @note   This bit should not be changed when communication is ongoing.
N  * @rmtoll CR1          MSTR          LL_SPI_SetMode\n
N  *         CR1          SSI           LL_SPI_SetMode
N  * @param  SPIx SPI Instance
N  * @param  Mode This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_MODE_MASTER
N  *         @arg @ref LL_SPI_MODE_SLAVE
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetMode(SPI_TypeDef *SPIx, uint32_t Mode)
Xstatic __inline void LL_SPI_SetMode(SPI_TypeDef *SPIx, uint32_t Mode)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (2U)) | (0x1UL << (8U))))) | (Mode))));
N}
N
N/**
N  * @brief  Get SPI operation mode (Master or Slave)
N  * @rmtoll CR1          MSTR          LL_SPI_GetMode\n
N  *         CR1          SSI           LL_SPI_GetMode
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_MODE_MASTER
N  *         @arg @ref LL_SPI_MODE_SLAVE
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetMode(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetMode(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (2U)) | (0x1UL << (8U)))));
N}
N
N/**
N  * @brief  Set serial protocol used
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR2          FRF           LL_SPI_SetStandard
N  * @param  SPIx SPI Instance
N  * @param  Standard This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_PROTOCOL_MOTOROLA
N  *         @arg @ref LL_SPI_PROTOCOL_TI
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard)
Xstatic __inline void LL_SPI_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard)
N{
N  MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (4U))))) | (Standard))));
N}
N
N/**
N  * @brief  Get serial protocol used
N  * @rmtoll CR2          FRF           LL_SPI_GetStandard
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_PROTOCOL_MOTOROLA
N  *         @arg @ref LL_SPI_PROTOCOL_TI
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetStandard(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetStandard(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_FRF));
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (4U)))));
N}
N
N/**
N  * @brief  Set clock phase
N  * @note   This bit should not be changed when communication is ongoing.
N  *         This bit is not used in SPI TI mode.
N  * @rmtoll CR1          CPHA          LL_SPI_SetClockPhase
N  * @param  SPIx SPI Instance
N  * @param  ClockPhase This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_PHASE_1EDGE
N  *         @arg @ref LL_SPI_PHASE_2EDGE
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetClockPhase(SPI_TypeDef *SPIx, uint32_t ClockPhase)
Xstatic __inline void LL_SPI_SetClockPhase(SPI_TypeDef *SPIx, uint32_t ClockPhase)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (0U))))) | (ClockPhase))));
N}
N
N/**
N  * @brief  Get clock phase
N  * @rmtoll CR1          CPHA          LL_SPI_GetClockPhase
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_PHASE_1EDGE
N  *         @arg @ref LL_SPI_PHASE_2EDGE
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetClockPhase(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetClockPhase(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_CPHA));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (0U)))));
N}
N
N/**
N  * @brief  Set clock polarity
N  * @note   This bit should not be changed when communication is ongoing.
N  *         This bit is not used in SPI TI mode.
N  * @rmtoll CR1          CPOL          LL_SPI_SetClockPolarity
N  * @param  SPIx SPI Instance
N  * @param  ClockPolarity This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_POLARITY_LOW
N  *         @arg @ref LL_SPI_POLARITY_HIGH
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity)
Xstatic __inline void LL_SPI_SetClockPolarity(SPI_TypeDef *SPIx, uint32_t ClockPolarity)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (1U))))) | (ClockPolarity))));
N}
N
N/**
N  * @brief  Get clock polarity
N  * @rmtoll CR1          CPOL          LL_SPI_GetClockPolarity
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_POLARITY_LOW
N  *         @arg @ref LL_SPI_POLARITY_HIGH
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetClockPolarity(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetClockPolarity(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_CPOL));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (1U)))));
N}
N
N/**
N  * @brief  Set baud rate prescaler
N  * @note   These bits should not be changed when communication is ongoing. SPI BaudRate = fPCLK/Prescaler.
N  * @rmtoll CR1          BR            LL_SPI_SetBaudRatePrescaler
N  * @param  SPIx SPI Instance
N  * @param  BaudRate This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV2
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV4
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV8
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV16
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV32
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV64
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV128
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV256
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetBaudRatePrescaler(SPI_TypeDef *SPIx, uint32_t BaudRate)
Xstatic __inline void LL_SPI_SetBaudRatePrescaler(SPI_TypeDef *SPIx, uint32_t BaudRate)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x7UL << (3U))))) | (BaudRate))));
N}
N
N/**
N  * @brief  Get baud rate prescaler
N  * @rmtoll CR1          BR            LL_SPI_GetBaudRatePrescaler
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV2
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV4
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV8
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV16
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV32
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV64
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV128
N  *         @arg @ref LL_SPI_BAUDRATEPRESCALER_DIV256
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetBaudRatePrescaler(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetBaudRatePrescaler(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_BR));
X  return (uint32_t)(((SPIx->CR1) & ((0x7UL << (3U)))));
N}
N
N/**
N  * @brief  Set transfer bit order
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR1          LSBFIRST      LL_SPI_SetTransferBitOrder
N  * @param  SPIx SPI Instance
N  * @param  BitOrder This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_LSB_FIRST
N  *         @arg @ref LL_SPI_MSB_FIRST
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetTransferBitOrder(SPI_TypeDef *SPIx, uint32_t BitOrder)
Xstatic __inline void LL_SPI_SetTransferBitOrder(SPI_TypeDef *SPIx, uint32_t BitOrder)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (7U))))) | (BitOrder))));
N}
N
N/**
N  * @brief  Get transfer bit order
N  * @rmtoll CR1          LSBFIRST      LL_SPI_GetTransferBitOrder
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_LSB_FIRST
N  *         @arg @ref LL_SPI_MSB_FIRST
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetTransferBitOrder(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetTransferBitOrder(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_LSBFIRST));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (7U)))));
N}
N
N/**
N  * @brief  Set transfer direction mode
N  * @note   For Half-Duplex mode, Rx Direction is set by default.
N  *         In master mode, the MOSI pin is used and in slave mode, the MISO pin is used for Half-Duplex.
N  * @rmtoll CR1          RXONLY        LL_SPI_SetTransferDirection\n
N  *         CR1          BIDIMODE      LL_SPI_SetTransferDirection\n
N  *         CR1          BIDIOE        LL_SPI_SetTransferDirection
N  * @param  SPIx SPI Instance
N  * @param  TransferDirection This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_FULL_DUPLEX
N  *         @arg @ref LL_SPI_SIMPLEX_RX
N  *         @arg @ref LL_SPI_HALF_DUPLEX_RX
N  *         @arg @ref LL_SPI_HALF_DUPLEX_TX
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetTransferDirection(SPI_TypeDef *SPIx, uint32_t TransferDirection)
Xstatic __inline void LL_SPI_SetTransferDirection(SPI_TypeDef *SPIx, uint32_t TransferDirection)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (10U)) | (0x1UL << (15U)) | (0x1UL << (14U))))) | (TransferDirection))));
N}
N
N/**
N  * @brief  Get transfer direction mode
N  * @rmtoll CR1          RXONLY        LL_SPI_GetTransferDirection\n
N  *         CR1          BIDIMODE      LL_SPI_GetTransferDirection\n
N  *         CR1          BIDIOE        LL_SPI_GetTransferDirection
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_FULL_DUPLEX
N  *         @arg @ref LL_SPI_SIMPLEX_RX
N  *         @arg @ref LL_SPI_HALF_DUPLEX_RX
N  *         @arg @ref LL_SPI_HALF_DUPLEX_TX
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetTransferDirection(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetTransferDirection(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (10U)) | (0x1UL << (15U)) | (0x1UL << (14U)))));
N}
N
N/**
N  * @brief  Set frame data width
N  * @rmtoll CR2          DS            LL_SPI_SetDataWidth
N  * @param  SPIx SPI Instance
N  * @param  DataWidth This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_DATAWIDTH_4BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_5BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_6BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_7BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_8BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_9BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_10BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_11BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_12BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_13BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_14BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_15BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_16BIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetDataWidth(SPI_TypeDef *SPIx, uint32_t DataWidth)
Xstatic __inline void LL_SPI_SetDataWidth(SPI_TypeDef *SPIx, uint32_t DataWidth)
N{
N  MODIFY_REG(SPIx->CR2, SPI_CR2_DS, DataWidth);
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0xFUL << (8U))))) | (DataWidth))));
N}
N
N/**
N  * @brief  Get frame data width
N  * @rmtoll CR2          DS            LL_SPI_GetDataWidth
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_DATAWIDTH_4BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_5BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_6BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_7BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_8BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_9BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_10BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_11BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_12BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_13BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_14BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_15BIT
N  *         @arg @ref LL_SPI_DATAWIDTH_16BIT
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetDataWidth(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetDataWidth(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_DS));
X  return (uint32_t)(((SPIx->CR2) & ((0xFUL << (8U)))));
N}
N
N/**
N  * @brief  Set threshold of RXFIFO that triggers an RXNE event
N  * @rmtoll CR2          FRXTH         LL_SPI_SetRxFIFOThreshold
N  * @param  SPIx SPI Instance
N  * @param  Threshold This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_RX_FIFO_TH_HALF
N  *         @arg @ref LL_SPI_RX_FIFO_TH_QUARTER
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetRxFIFOThreshold(SPI_TypeDef *SPIx, uint32_t Threshold)
Xstatic __inline void LL_SPI_SetRxFIFOThreshold(SPI_TypeDef *SPIx, uint32_t Threshold)
N{
N  MODIFY_REG(SPIx->CR2, SPI_CR2_FRXTH, Threshold);
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (12U))))) | (Threshold))));
N}
N
N/**
N  * @brief  Get threshold of RXFIFO that triggers an RXNE event
N  * @rmtoll CR2          FRXTH         LL_SPI_GetRxFIFOThreshold
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_RX_FIFO_TH_HALF
N  *         @arg @ref LL_SPI_RX_FIFO_TH_QUARTER
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetRxFIFOThreshold(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetRxFIFOThreshold(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_FRXTH));
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (12U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EF_CRC_Management CRC Management
N  * @{
N  */
N
N/**
N  * @brief  Enable CRC
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCEN         LL_SPI_EnableCRC
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableCRC(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableCRC(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR1, SPI_CR1_CRCEN);
X  ((SPIx->CR1) |= ((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Disable CRC
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCEN         LL_SPI_DisableCRC
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableCRC(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableCRC(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
X  ((SPIx->CR1) &= ~((0x1UL << (13U))));
N}
N
N/**
N  * @brief  Check if CRC is enabled
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCEN         LL_SPI_IsEnabledCRC
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledCRC(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledCRC(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR1, SPI_CR1_CRCEN) == (SPI_CR1_CRCEN)) ? 1UL : 0UL);
X  return ((((SPIx->CR1) & ((0x1UL << (13U)))) == ((0x1UL << (13U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set CRC Length
N  * @note   This bit should be written only when SPI is disabled (SPE = 0) for correct operation.
N  * @rmtoll CR1          CRCL          LL_SPI_SetCRCWidth
N  * @param  SPIx SPI Instance
N  * @param  CRCLength This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_CRC_8BIT
N  *         @arg @ref LL_SPI_CRC_16BIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetCRCWidth(SPI_TypeDef *SPIx, uint32_t CRCLength)
Xstatic __inline void LL_SPI_SetCRCWidth(SPI_TypeDef *SPIx, uint32_t CRCLength)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_CRCL, CRCLength);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (11U))))) | (CRCLength))));
N}
N
N/**
N  * @brief  Get CRC Length
N  * @rmtoll CR1          CRCL          LL_SPI_GetCRCWidth
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_CRC_8BIT
N  *         @arg @ref LL_SPI_CRC_16BIT
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetCRCWidth(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetCRCWidth(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_CRCL));
X  return (uint32_t)(((SPIx->CR1) & ((0x1UL << (11U)))));
N}
N
N/**
N  * @brief  Set CRCNext to transfer CRC on the line
N  * @note   This bit has to be written as soon as the last data is written in the SPIx_DR register.
N  * @rmtoll CR1          CRCNEXT       LL_SPI_SetCRCNext
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetCRCNext(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_SetCRCNext(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR1, SPI_CR1_CRCNEXT);
X  ((SPIx->CR1) |= ((0x1UL << (12U))));
N}
N
N/**
N  * @brief  Set polynomial for CRC calculation
N  * @rmtoll CRCPR        CRCPOLY       LL_SPI_SetCRCPolynomial
N  * @param  SPIx SPI Instance
N  * @param  CRCPoly This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetCRCPolynomial(SPI_TypeDef *SPIx, uint32_t CRCPoly)
Xstatic __inline void LL_SPI_SetCRCPolynomial(SPI_TypeDef *SPIx, uint32_t CRCPoly)
N{
N  WRITE_REG(SPIx->CRCPR, (uint16_t)CRCPoly);
X  ((SPIx->CRCPR) = ((uint16_t)CRCPoly));
N}
N
N/**
N  * @brief  Get polynomial for CRC calculation
N  * @rmtoll CRCPR        CRCPOLY       LL_SPI_GetCRCPolynomial
N  * @param  SPIx SPI Instance
N  * @retval Returned value is a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetCRCPolynomial(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetCRCPolynomial(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_REG(SPIx->CRCPR));
X  return (uint32_t)(((SPIx->CRCPR)));
N}
N
N/**
N  * @brief  Get Rx CRC
N  * @rmtoll RXCRCR       RXCRC         LL_SPI_GetRxCRC
N  * @param  SPIx SPI Instance
N  * @retval Returned value is a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetRxCRC(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetRxCRC(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_REG(SPIx->RXCRCR));
X  return (uint32_t)(((SPIx->RXCRCR)));
N}
N
N/**
N  * @brief  Get Tx CRC
N  * @rmtoll TXCRCR       TXCRC         LL_SPI_GetTxCRC
N  * @param  SPIx SPI Instance
N  * @retval Returned value is a number between Min_Data = 0x00 and Max_Data = 0xFFFF
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetTxCRC(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetTxCRC(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_REG(SPIx->TXCRCR));
X  return (uint32_t)(((SPIx->TXCRCR)));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EF_NSS_Management Slave Select Pin Management
N  * @{
N  */
N
N/**
N  * @brief  Set NSS mode
N  * @note   LL_SPI_NSS_SOFT Mode is not used in SPI TI mode.
N  * @rmtoll CR1          SSM           LL_SPI_SetNSSMode\n
N  * @rmtoll CR2          SSOE          LL_SPI_SetNSSMode
N  * @param  SPIx SPI Instance
N  * @param  NSS This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_NSS_SOFT
N  *         @arg @ref LL_SPI_NSS_HARD_INPUT
N  *         @arg @ref LL_SPI_NSS_HARD_OUTPUT
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetNSSMode(SPI_TypeDef *SPIx, uint32_t NSS)
Xstatic __inline void LL_SPI_SetNSSMode(SPI_TypeDef *SPIx, uint32_t NSS)
N{
N  MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
X  (((SPIx->CR1)) = ((((((SPIx->CR1))) & (~((0x1UL << (9U))))) | (NSS))));
N  MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (2U))))) | (((uint32_t)(NSS >> 16U))))));
N}
N
N/**
N  * @brief  Get NSS mode
N  * @rmtoll CR1          SSM           LL_SPI_GetNSSMode\n
N  * @rmtoll CR2          SSOE          LL_SPI_GetNSSMode
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_NSS_SOFT
N  *         @arg @ref LL_SPI_NSS_HARD_INPUT
N  *         @arg @ref LL_SPI_NSS_HARD_OUTPUT
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetNSSMode(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetNSSMode(SPI_TypeDef *SPIx)
N{
N  register uint32_t Ssm  = (READ_BIT(SPIx->CR1, SPI_CR1_SSM));
X  register uint32_t Ssm  = (((SPIx->CR1) & ((0x1UL << (9U)))));
N  register uint32_t Ssoe = (READ_BIT(SPIx->CR2,  SPI_CR2_SSOE) << 16U);
X  register uint32_t Ssoe = (((SPIx->CR2) & ((0x1UL << (2U)))) << 16U);
N  return (Ssm | Ssoe);
N}
N
N/**
N  * @brief  Enable NSS pulse management
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR2          NSSP          LL_SPI_EnableNSSPulseMgt
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableNSSPulseMgt(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableNSSPulseMgt(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR2, SPI_CR2_NSSP);
X  ((SPIx->CR2) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable NSS pulse management
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR2          NSSP          LL_SPI_DisableNSSPulseMgt
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableNSSPulseMgt(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableNSSPulseMgt(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_NSSP);
X  ((SPIx->CR2) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Check if NSS pulse is enabled
N  * @note   This bit should not be changed when communication is ongoing. This bit is not used in SPI TI mode.
N  * @rmtoll CR2          NSSP          LL_SPI_IsEnabledNSSPulse
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledNSSPulse(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledNSSPulse(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_NSSP) == (SPI_CR2_NSSP)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (3U)))) == ((0x1UL << (3U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EF_FLAG_Management FLAG Management
N  * @{
N  */
N
N/**
N  * @brief  Check if Rx buffer is not empty
N  * @rmtoll SR           RXNE          LL_SPI_IsActiveFlag_RXNE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_RXNE(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_RXNE(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if Tx buffer is empty
N  * @rmtoll SR           TXE           LL_SPI_IsActiveFlag_TXE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_TXE(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_TXE(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get CRC error flag
N  * @rmtoll SR           CRCERR        LL_SPI_IsActiveFlag_CRCERR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_CRCERR(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_CRCERR(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_CRCERR) == (SPI_SR_CRCERR)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (4U)))) == ((0x1UL << (4U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get mode fault error flag
N  * @rmtoll SR           MODF          LL_SPI_IsActiveFlag_MODF
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_MODF(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_MODF(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get overrun error flag
N  * @rmtoll SR           OVR           LL_SPI_IsActiveFlag_OVR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_OVR(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_OVR(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get busy flag
N  * @note   The BSY flag is cleared under any one of the following conditions:
N  * -When the SPI is correctly disabled
N  * -When a fault is detected in Master mode (MODF bit set to 1)
N  * -In Master mode, when it finishes a data transmission and no new data is ready to be
N  * sent
N  * -In Slave mode, when the BSY flag is set to '0' for at least one SPI clock cycle between
N  * each data transfer.
N  * @rmtoll SR           BSY           LL_SPI_IsActiveFlag_BSY
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_BSY(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_BSY(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get frame format error flag
N  * @rmtoll SR           FRE           LL_SPI_IsActiveFlag_FRE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_FRE(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsActiveFlag_FRE(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->SR, SPI_SR_FRE) == (SPI_SR_FRE)) ? 1UL : 0UL);
X  return ((((SPIx->SR) & ((0x1UL << (8U)))) == ((0x1UL << (8U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Get FIFO reception Level
N  * @rmtoll SR           FRLVL         LL_SPI_GetRxFIFOLevel
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_RX_FIFO_EMPTY
N  *         @arg @ref LL_SPI_RX_FIFO_QUARTER_FULL
N  *         @arg @ref LL_SPI_RX_FIFO_HALF_FULL
N  *         @arg @ref LL_SPI_RX_FIFO_FULL
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetRxFIFOLevel(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetRxFIFOLevel(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->SR, SPI_SR_FRLVL));
X  return (uint32_t)(((SPIx->SR) & ((0x3UL << (9U)))));
N}
N
N/**
N  * @brief  Get FIFO Transmission Level
N  * @rmtoll SR           FTLVL         LL_SPI_GetTxFIFOLevel
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_TX_FIFO_EMPTY
N  *         @arg @ref LL_SPI_TX_FIFO_QUARTER_FULL
N  *         @arg @ref LL_SPI_TX_FIFO_HALF_FULL
N  *         @arg @ref LL_SPI_TX_FIFO_FULL
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetTxFIFOLevel(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetTxFIFOLevel(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->SR, SPI_SR_FTLVL));
X  return (uint32_t)(((SPIx->SR) & ((0x3UL << (11U)))));
N}
N
N/**
N  * @brief  Clear CRC error flag
N  * @rmtoll SR           CRCERR        LL_SPI_ClearFlag_CRCERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_ClearFlag_CRCERR(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_ClearFlag_CRCERR(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->SR, SPI_SR_CRCERR);
X  ((SPIx->SR) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear mode fault error flag
N  * @note   Clearing this flag is done by a read access to the SPIx_SR
N  *         register followed by a write access to the SPIx_CR1 register
N  * @rmtoll SR           MODF          LL_SPI_ClearFlag_MODF
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_ClearFlag_MODF(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_ClearFlag_MODF(SPI_TypeDef *SPIx)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  tmpreg = SPIx->SR;
N  (void) tmpreg;
N  tmpreg = CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
X  tmpreg = ((SPIx->CR1) &= ~((0x1UL << (6U))));
N  (void) tmpreg;
N}
N
N/**
N  * @brief  Clear overrun error flag
N  * @note   Clearing this flag is done by a read access to the SPIx_DR
N  *         register followed by a read access to the SPIx_SR register
N  * @rmtoll SR           OVR           LL_SPI_ClearFlag_OVR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_ClearFlag_OVR(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_ClearFlag_OVR(SPI_TypeDef *SPIx)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  tmpreg = SPIx->DR;
N  (void) tmpreg;
N  tmpreg = SPIx->SR;
N  (void) tmpreg;
N}
N
N/**
N  * @brief  Clear frame format error flag
N  * @note   Clearing this flag is done by reading SPIx_SR register
N  * @rmtoll SR           FRE           LL_SPI_ClearFlag_FRE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_ClearFlag_FRE(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_ClearFlag_FRE(SPI_TypeDef *SPIx)
N{
N  __IO uint32_t tmpreg;
X  volatile uint32_t tmpreg;
N  tmpreg = SPIx->SR;
N  (void) tmpreg;
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EF_IT_Management Interrupt Management
N  * @{
N  */
N
N/**
N  * @brief  Enable error interrupt
N  * @note   This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode).
N  * @rmtoll CR2          ERRIE         LL_SPI_EnableIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableIT_ERR(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableIT_ERR(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR2, SPI_CR2_ERRIE);
X  ((SPIx->CR2) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Enable Rx buffer not empty interrupt
N  * @rmtoll CR2          RXNEIE        LL_SPI_EnableIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableIT_RXNE(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableIT_RXNE(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR2, SPI_CR2_RXNEIE);
X  ((SPIx->CR2) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable Tx buffer empty interrupt
N  * @rmtoll CR2          TXEIE         LL_SPI_EnableIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableIT_TXE(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableIT_TXE(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR2, SPI_CR2_TXEIE);
X  ((SPIx->CR2) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable error interrupt
N  * @note   This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode).
N  * @rmtoll CR2          ERRIE         LL_SPI_DisableIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableIT_ERR(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableIT_ERR(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_ERRIE);
X  ((SPIx->CR2) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable Rx buffer not empty interrupt
N  * @rmtoll CR2          RXNEIE        LL_SPI_DisableIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableIT_RXNE(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableIT_RXNE(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_RXNEIE);
X  ((SPIx->CR2) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable Tx buffer empty interrupt
N  * @rmtoll CR2          TXEIE         LL_SPI_DisableIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableIT_TXE(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableIT_TXE(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
X  ((SPIx->CR2) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Check if error interrupt is enabled
N  * @rmtoll CR2          ERRIE         LL_SPI_IsEnabledIT_ERR
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledIT_ERR(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledIT_ERR(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_ERRIE) == (SPI_CR2_ERRIE)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (5U)))) == ((0x1UL << (5U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if Rx buffer not empty interrupt is enabled
N  * @rmtoll CR2          RXNEIE        LL_SPI_IsEnabledIT_RXNE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledIT_RXNE(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledIT_RXNE(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_RXNEIE) == (SPI_CR2_RXNEIE)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (6U)))) == ((0x1UL << (6U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Check if Tx buffer empty interrupt
N  * @rmtoll CR2          TXEIE         LL_SPI_IsEnabledIT_TXE
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledIT_TXE(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledIT_TXE(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_TXEIE) == (SPI_CR2_TXEIE)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (7U)))) == ((0x1UL << (7U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EF_DMA_Management DMA Management
N  * @{
N  */
N
N/**
N  * @brief  Enable DMA Rx
N  * @rmtoll CR2          RXDMAEN       LL_SPI_EnableDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableDMAReq_RX(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableDMAReq_RX(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR2, SPI_CR2_RXDMAEN);
X  ((SPIx->CR2) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable DMA Rx
N  * @rmtoll CR2          RXDMAEN       LL_SPI_DisableDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableDMAReq_RX(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableDMAReq_RX(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_RXDMAEN);
X  ((SPIx->CR2) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Check if DMA Rx is enabled
N  * @rmtoll CR2          RXDMAEN       LL_SPI_IsEnabledDMAReq_RX
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledDMAReq_RX(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledDMAReq_RX(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_RXDMAEN) == (SPI_CR2_RXDMAEN)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (0U)))) == ((0x1UL << (0U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Enable DMA Tx
N  * @rmtoll CR2          TXDMAEN       LL_SPI_EnableDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_EnableDMAReq_TX(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_EnableDMAReq_TX(SPI_TypeDef *SPIx)
N{
N  SET_BIT(SPIx->CR2, SPI_CR2_TXDMAEN);
X  ((SPIx->CR2) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable DMA Tx
N  * @rmtoll CR2          TXDMAEN       LL_SPI_DisableDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_DisableDMAReq_TX(SPI_TypeDef *SPIx)
Xstatic __inline void LL_SPI_DisableDMAReq_TX(SPI_TypeDef *SPIx)
N{
N  CLEAR_BIT(SPIx->CR2, SPI_CR2_TXDMAEN);
X  ((SPIx->CR2) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Check if DMA Tx is enabled
N  * @rmtoll CR2          TXDMAEN       LL_SPI_IsEnabledDMAReq_TX
N  * @param  SPIx SPI Instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_SPI_IsEnabledDMAReq_TX(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_IsEnabledDMAReq_TX(SPI_TypeDef *SPIx)
N{
N  return ((READ_BIT(SPIx->CR2, SPI_CR2_TXDMAEN) == (SPI_CR2_TXDMAEN)) ? 1UL : 0UL);
X  return ((((SPIx->CR2) & ((0x1UL << (1U)))) == ((0x1UL << (1U)))) ? 1UL : 0UL);
N}
N
N/**
N  * @brief  Set parity of  Last DMA reception
N  * @rmtoll CR2          LDMARX        LL_SPI_SetDMAParity_RX
N  * @param  SPIx SPI Instance
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_DMA_PARITY_ODD
N  *         @arg @ref LL_SPI_DMA_PARITY_EVEN
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetDMAParity_RX(SPI_TypeDef *SPIx, uint32_t Parity)
Xstatic __inline void LL_SPI_SetDMAParity_RX(SPI_TypeDef *SPIx, uint32_t Parity)
N{
N  MODIFY_REG(SPIx->CR2, SPI_CR2_LDMARX, (Parity << SPI_CR2_LDMARX_Pos));
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (13U))))) | ((Parity << (13U))))));
N}
N
N/**
N  * @brief  Get parity configuration for  Last DMA reception
N  * @rmtoll CR2          LDMARX        LL_SPI_GetDMAParity_RX
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_DMA_PARITY_ODD
N  *         @arg @ref LL_SPI_DMA_PARITY_EVEN
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetDMAParity_RX(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetDMAParity_RX(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_LDMARX) >> SPI_CR2_LDMARX_Pos);
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (13U)))) >> (13U));
N}
N
N/**
N  * @brief  Set parity of  Last DMA transmission
N  * @rmtoll CR2          LDMATX        LL_SPI_SetDMAParity_TX
N  * @param  SPIx SPI Instance
N  * @param  Parity This parameter can be one of the following values:
N  *         @arg @ref LL_SPI_DMA_PARITY_ODD
N  *         @arg @ref LL_SPI_DMA_PARITY_EVEN
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_SetDMAParity_TX(SPI_TypeDef *SPIx, uint32_t Parity)
Xstatic __inline void LL_SPI_SetDMAParity_TX(SPI_TypeDef *SPIx, uint32_t Parity)
N{
N  MODIFY_REG(SPIx->CR2, SPI_CR2_LDMATX, (Parity << SPI_CR2_LDMATX_Pos));
X  (((SPIx->CR2)) = ((((((SPIx->CR2))) & (~((0x1UL << (14U))))) | ((Parity << (14U))))));
N}
N
N/**
N  * @brief  Get parity configuration for Last DMA transmission
N  * @rmtoll CR2          LDMATX        LL_SPI_GetDMAParity_TX
N  * @param  SPIx SPI Instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_SPI_DMA_PARITY_ODD
N  *         @arg @ref LL_SPI_DMA_PARITY_EVEN
N  */
N__STATIC_INLINE uint32_t LL_SPI_GetDMAParity_TX(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_GetDMAParity_TX(SPI_TypeDef *SPIx)
N{
N  return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_LDMATX) >> SPI_CR2_LDMATX_Pos);
X  return (uint32_t)(((SPIx->CR2) & ((0x1UL << (14U)))) >> (14U));
N}
N
N/**
N  * @brief  Get the data register address used for DMA transfer
N  * @rmtoll DR           DR            LL_SPI_DMA_GetRegAddr
N  * @param  SPIx SPI Instance
N  * @retval Address of data register
N  */
N__STATIC_INLINE uint32_t LL_SPI_DMA_GetRegAddr(SPI_TypeDef *SPIx)
Xstatic __inline uint32_t LL_SPI_DMA_GetRegAddr(SPI_TypeDef *SPIx)
N{
N  return (uint32_t) & (SPIx->DR);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_LL_EF_DATA_Management DATA Management
N  * @{
N  */
N
N/**
N  * @brief  Read 8-Bits in the data register
N  * @rmtoll DR           DR            LL_SPI_ReceiveData8
N  * @param  SPIx SPI Instance
N  * @retval RxData Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t LL_SPI_ReceiveData8(SPI_TypeDef *SPIx)
Xstatic __inline uint8_t LL_SPI_ReceiveData8(SPI_TypeDef *SPIx)
N{
N  return (uint8_t)(READ_REG(SPIx->DR));
X  return (uint8_t)(((SPIx->DR)));
N}
N
N/**
N  * @brief  Read 16-Bits in the data register
N  * @rmtoll DR           DR            LL_SPI_ReceiveData16
N  * @param  SPIx SPI Instance
N  * @retval RxData Value between Min_Data=0x00 and Max_Data=0xFFFF
N  */
N__STATIC_INLINE uint16_t LL_SPI_ReceiveData16(SPI_TypeDef *SPIx)
Xstatic __inline uint16_t LL_SPI_ReceiveData16(SPI_TypeDef *SPIx)
N{
N  return (uint16_t)(READ_REG(SPIx->DR));
X  return (uint16_t)(((SPIx->DR)));
N}
N
N/**
N  * @brief  Write 8-Bits in the data register
N  * @rmtoll DR           DR            LL_SPI_TransmitData8
N  * @param  SPIx SPI Instance
N  * @param  TxData Value between Min_Data=0x00 and Max_Data=0xFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_TransmitData8(SPI_TypeDef *SPIx, uint8_t TxData)
Xstatic __inline void LL_SPI_TransmitData8(SPI_TypeDef *SPIx, uint8_t TxData)
N{
N#if defined (__GNUC__)
X#if 0L
S  __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
S  *spidr = TxData;
N#else
N  *((__IO uint8_t *)&SPIx->DR) = TxData;
X  *((volatile uint8_t *)&SPIx->DR) = TxData;
N#endif
N}
N
N/**
N  * @brief  Write 16-Bits in the data register
N  * @rmtoll DR           DR            LL_SPI_TransmitData16
N  * @param  SPIx SPI Instance
N  * @param  TxData Value between Min_Data=0x00 and Max_Data=0xFFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_SPI_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData)
Xstatic __inline void LL_SPI_TransmitData16(SPI_TypeDef *SPIx, uint16_t TxData)
N{
N#if defined (__GNUC__)
X#if 0L
S  __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
S  *spidr = TxData;
N#else
N  *((__IO uint16_t *)&SPIx->DR) = TxData;
X  *((volatile uint16_t *)&SPIx->DR) = TxData;
N#endif
N}
N
N/**
N  * @}
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup SPI_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
NErrorStatus LL_SPI_DeInit(SPI_TypeDef *SPIx);
NErrorStatus LL_SPI_Init(SPI_TypeDef *SPIx, LL_SPI_InitTypeDef *SPI_InitStruct);
Nvoid        LL_SPI_StructInit(LL_SPI_InitTypeDef *SPI_InitStruct);
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* defined (SPI1) || defined (SPI2) || defined (SPI3) */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_SPI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 19 ".\Source\Main\inc\lib.h" 2
N#include "stm32l4xx_ll_adc.h"
L 1 ".\STM32L4 Low Layer drivers\inc\stm32l4xx_ll_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_adc.h
N  * @author  MCD Application Team
N  * @brief   Header file of ADC LL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L4xx_LL_ADC_H
N#define __STM32L4xx_LL_ADC_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l4xx.h"
N
N/** @addtogroup STM32L4xx_LL_Driver
N  * @{
N  */
N
N#if defined (ADC1) || defined (ADC2) || defined (ADC3)
X#if 1L || 0L || 0L
N
N/** @defgroup ADC_LL ADC
N  * @{
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup ADC_LL_Private_Constants ADC Private Constants
N  * @{
N  */
N
N/* Internal mask for ADC group regular sequencer:                             */
N/* To select into literal LL_ADC_REG_RANK_x the relevant bits for:            */
N/* - sequencer register offset                                                */
N/* - sequencer rank bits position into the selected register                  */
N
N/* Internal register offset for ADC group regular sequencer configuration */
N/* (offset placed into a spare area of literal definition) */
N#define ADC_SQR1_REGOFFSET                 (0x00000000U)
N#define ADC_SQR2_REGOFFSET                 (0x00000100U)
N#define ADC_SQR3_REGOFFSET                 (0x00000200U)
N#define ADC_SQR4_REGOFFSET                 (0x00000300U)
N
N#define ADC_REG_SQRX_REGOFFSET_MASK        (ADC_SQR1_REGOFFSET | ADC_SQR2_REGOFFSET | ADC_SQR3_REGOFFSET | ADC_SQR4_REGOFFSET)
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define ADC_SQRX_REGOFFSET_POS             (8U) /* Position of bits ADC_SQRx_REGOFFSET in ADC_REG_SQRX_REGOFFSET_MASK */
N#endif
N#define ADC_REG_RANK_ID_SQRX_MASK          (ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0)
N
N/* Definition of ADC group regular sequencer bits information to be inserted  */
N/* into ADC group regular sequencer ranks literals definition.                */
N#define ADC_REG_RANK_1_SQRX_BITOFFSET_POS  ( 6U) /* Value equivalent to POSITION_VAL(ADC_SQR1_SQ1) */
N#define ADC_REG_RANK_2_SQRX_BITOFFSET_POS  (12U) /* Value equivalent to POSITION_VAL(ADC_SQR1_SQ2) */
N#define ADC_REG_RANK_3_SQRX_BITOFFSET_POS  (18U) /* Value equivalent to POSITION_VAL(ADC_SQR1_SQ3) */
N#define ADC_REG_RANK_4_SQRX_BITOFFSET_POS  (24U) /* Value equivalent to POSITION_VAL(ADC_SQR1_SQ4) */
N#define ADC_REG_RANK_5_SQRX_BITOFFSET_POS  ( 0U) /* Value equivalent to POSITION_VAL(ADC_SQR2_SQ5) */
N#define ADC_REG_RANK_6_SQRX_BITOFFSET_POS  ( 6U) /* Value equivalent to POSITION_VAL(ADC_SQR2_SQ6) */
N#define ADC_REG_RANK_7_SQRX_BITOFFSET_POS  (12U) /* Value equivalent to POSITION_VAL(ADC_SQR2_SQ7) */
N#define ADC_REG_RANK_8_SQRX_BITOFFSET_POS  (18U) /* Value equivalent to POSITION_VAL(ADC_SQR2_SQ8) */
N#define ADC_REG_RANK_9_SQRX_BITOFFSET_POS  (24U) /* Value equivalent to POSITION_VAL(ADC_SQR2_SQ9) */
N#define ADC_REG_RANK_10_SQRX_BITOFFSET_POS ( 0U) /* Value equivalent to POSITION_VAL(ADC_SQR3_SQ10) */
N#define ADC_REG_RANK_11_SQRX_BITOFFSET_POS ( 6U) /* Value equivalent to POSITION_VAL(ADC_SQR3_SQ11) */
N#define ADC_REG_RANK_12_SQRX_BITOFFSET_POS (12U) /* Value equivalent to POSITION_VAL(ADC_SQR3_SQ12) */
N#define ADC_REG_RANK_13_SQRX_BITOFFSET_POS (18U) /* Value equivalent to POSITION_VAL(ADC_SQR3_SQ13) */
N#define ADC_REG_RANK_14_SQRX_BITOFFSET_POS (24U) /* Value equivalent to POSITION_VAL(ADC_SQR3_SQ14) */
N#define ADC_REG_RANK_15_SQRX_BITOFFSET_POS ( 0U) /* Value equivalent to POSITION_VAL(ADC_SQR4_SQ15) */
N#define ADC_REG_RANK_16_SQRX_BITOFFSET_POS ( 6U) /* Value equivalent to POSITION_VAL(ADC_SQR4_SQ16) */
N
N
N
N/* Internal mask for ADC group injected sequencer:                            */
N/* To select into literal LL_ADC_INJ_RANK_x the relevant bits for:            */
N/* - data register offset                                                     */
N/* - sequencer rank bits position into the selected register                  */
N
N/* Internal register offset for ADC group injected data register */
N/* (offset placed into a spare area of literal definition) */
N#define ADC_JDR1_REGOFFSET                 (0x00000000U)
N#define ADC_JDR2_REGOFFSET                 (0x00000100U)
N#define ADC_JDR3_REGOFFSET                 (0x00000200U)
N#define ADC_JDR4_REGOFFSET                 (0x00000300U)
N
N#define ADC_INJ_JDRX_REGOFFSET_MASK        (ADC_JDR1_REGOFFSET | ADC_JDR2_REGOFFSET | ADC_JDR3_REGOFFSET | ADC_JDR4_REGOFFSET)
N#define ADC_INJ_RANK_ID_JSQR_MASK          (ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0)
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define ADC_JDRX_REGOFFSET_POS             (8U) /* Position of bits ADC_JDRx_REGOFFSET in ADC_INJ_JDRX_REGOFFSET_MASK */
N#endif
N
N/* Definition of ADC group injected sequencer bits information to be inserted */
N/* into ADC group injected sequencer ranks literals definition.               */
N#define ADC_INJ_RANK_1_JSQR_BITOFFSET_POS  ( 8U) /* Value equivalent to POSITION_VAL(ADC_JSQR_JSQ1) */
N#define ADC_INJ_RANK_2_JSQR_BITOFFSET_POS  (14U) /* Value equivalent to POSITION_VAL(ADC_JSQR_JSQ2) */
N#define ADC_INJ_RANK_3_JSQR_BITOFFSET_POS  (20U) /* Value equivalent to POSITION_VAL(ADC_JSQR_JSQ3) */
N#define ADC_INJ_RANK_4_JSQR_BITOFFSET_POS  (26U) /* Value equivalent to POSITION_VAL(ADC_JSQR_JSQ4) */
N
N
N
N/* Internal mask for ADC group regular trigger:                               */
N/* To select into literal LL_ADC_REG_TRIG_x the relevant bits for:            */
N/* - regular trigger source                                                   */
N/* - regular trigger edge                                                     */
N#define ADC_REG_TRIG_EXT_EDGE_DEFAULT       (ADC_CFGR_EXTEN_0) /* Trigger edge set to rising edge (default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value) */
N
N/* Mask containing trigger source masks for each of possible                  */
N/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
N/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
N#define ADC_REG_TRIG_SOURCE_MASK            (((LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTSEL) << (4U * 0U)) | \
N                                             ((ADC_CFGR_EXTSEL)                            << (4U * 1U)) | \
N                                             ((ADC_CFGR_EXTSEL)                            << (4U * 2U)) | \
N                                             ((ADC_CFGR_EXTSEL)                            << (4U * 3U))  )
X#define ADC_REG_TRIG_SOURCE_MASK            (((LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTSEL) << (4U * 0U)) |                                              ((ADC_CFGR_EXTSEL)                            << (4U * 1U)) |                                              ((ADC_CFGR_EXTSEL)                            << (4U * 2U)) |                                              ((ADC_CFGR_EXTSEL)                            << (4U * 3U))  )
N
N/* Mask containing trigger edge masks for each of possible                    */
N/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
N/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
N#define ADC_REG_TRIG_EDGE_MASK              (((LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN) << (4U * 0U)) | \
N                                             ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)             << (4U * 1U)) | \
N                                             ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)             << (4U * 2U)) | \
N                                             ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)             << (4U * 3U))  )
X#define ADC_REG_TRIG_EDGE_MASK              (((LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN) << (4U * 0U)) |                                              ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)             << (4U * 1U)) |                                              ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)             << (4U * 2U)) |                                              ((ADC_REG_TRIG_EXT_EDGE_DEFAULT)             << (4U * 3U))  )
N
N/* Definition of ADC group regular trigger bits information.                  */
N#define ADC_REG_TRIG_EXTSEL_BITOFFSET_POS  ( 6U) /* Value equivalent to POSITION_VAL(ADC_CFGR_EXTSEL) */
N#define ADC_REG_TRIG_EXTEN_BITOFFSET_POS   (10U) /* Value equivalent to POSITION_VAL(ADC_CFGR_EXTEN) */
N
N
N
N/* Internal mask for ADC group injected trigger:                              */
N/* To select into literal LL_ADC_INJ_TRIG_x the relevant bits for:            */
N/* - injected trigger source                                                  */
N/* - injected trigger edge                                                    */
N#define ADC_INJ_TRIG_EXT_EDGE_DEFAULT      (ADC_JSQR_JEXTEN_0) /* Trigger edge set to rising edge (default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value) */
N
N/* Mask containing trigger source masks for each of possible                  */
N/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
N/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
N#define ADC_INJ_TRIG_SOURCE_MASK            (((LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTSEL) << (4U * 0U)) | \
N                                            ((ADC_JSQR_JEXTSEL)                             << (4U * 1U)) | \
N                                            ((ADC_JSQR_JEXTSEL)                             << (4U * 2U)) | \
N                                            ((ADC_JSQR_JEXTSEL)                             << (4U * 3U))  )
X#define ADC_INJ_TRIG_SOURCE_MASK            (((LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTSEL) << (4U * 0U)) |                                             ((ADC_JSQR_JEXTSEL)                             << (4U * 1U)) |                                             ((ADC_JSQR_JEXTSEL)                             << (4U * 2U)) |                                             ((ADC_JSQR_JEXTSEL)                             << (4U * 3U))  )
N
N/* Mask containing trigger edge masks for each of possible                    */
N/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
N/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
N#define ADC_INJ_TRIG_EDGE_MASK              (((LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN) << (4U * 0U)) | \
N                                             ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT)              << (4U * 1U)) | \
N                                             ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT)              << (4U * 2U)) | \
N                                             ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT)              << (4U * 3U))  )
X#define ADC_INJ_TRIG_EDGE_MASK              (((LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN) << (4U * 0U)) |                                              ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT)              << (4U * 1U)) |                                              ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT)              << (4U * 2U)) |                                              ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT)              << (4U * 3U))  )
N
N/* Definition of ADC group injected trigger bits information.                 */
N#define ADC_INJ_TRIG_EXTSEL_BITOFFSET_POS  ( 2U) /* Value equivalent to POSITION_VAL(ADC_JSQR_JEXTSEL) */
N#define ADC_INJ_TRIG_EXTEN_BITOFFSET_POS   ( 6U) /* Value equivalent to POSITION_VAL(ADC_JSQR_JEXTEN) */
N
N
N
N
N
N
N/* Internal mask for ADC channel:                                             */
N/* To select into literal LL_ADC_CHANNEL_x the relevant bits for:             */
N/* - channel identifier defined by number                                     */
N/* - channel identifier defined by bitfield                                   */
N/* - channel differentiation between external channels (connected to          */
N/*   GPIO pins) and internal channels (connected to internal paths)           */
N/* - channel sampling time defined by SMPRx register offset                   */
N/*   and SMPx bits positions into SMPRx register                              */
N#define ADC_CHANNEL_ID_NUMBER_MASK         (ADC_CFGR_AWD1CH)
N#define ADC_CHANNEL_ID_BITFIELD_MASK       (ADC_AWD2CR_AWD2CH)
N#define ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS (26U)/* Value equivalent to POSITION_VAL(ADC_CHANNEL_ID_NUMBER_MASK) */
N#define ADC_CHANNEL_ID_MASK                (ADC_CHANNEL_ID_NUMBER_MASK | ADC_CHANNEL_ID_BITFIELD_MASK | ADC_CHANNEL_ID_INTERNAL_CH_MASK)
N/* Equivalent mask of ADC_CHANNEL_NUMBER_MASK aligned on register LSB (bit 0) */
N#define ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 (ADC_SQR2_SQ5) /* Equivalent to shift: (ADC_CHANNEL_NUMBER_MASK >> POSITION_VAL(ADC_CHANNEL_NUMBER_MASK)) */
N
N/* Channel differentiation between external and internal channels */
N#define ADC_CHANNEL_ID_INTERNAL_CH         (0x80000000U) /* Marker of internal channel */
N#define ADC_CHANNEL_ID_INTERNAL_CH_2       (0x00080000U) /* Marker of internal channel for other ADC instances, in case of different ADC internal channels mapped on same channel number on different ADC instances */
N#define ADC_CHANNEL_ID_INTERNAL_CH_MASK    (ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2)
N
N/* Internal register offset for ADC channel sampling time configuration */
N/* (offset placed into a spare area of literal definition) */
N#define ADC_SMPR1_REGOFFSET                (0x00000000U)
N#define ADC_SMPR2_REGOFFSET                (0x02000000U)
N#define ADC_CHANNEL_SMPRX_REGOFFSET_MASK   (ADC_SMPR1_REGOFFSET | ADC_SMPR2_REGOFFSET)
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define ADC_SMPRX_REGOFFSET_POS            (25U) /* Position of bits ADC_SMPRx_REGOFFSET in ADC_CHANNEL_SMPRX_REGOFFSET_MASK */
N#endif
N
N#define ADC_CHANNEL_SMPx_BITOFFSET_MASK    (0x01F00000U)
N#define ADC_CHANNEL_SMPx_BITOFFSET_POS     (20U)           /* Value equivalent to POSITION_VAL(ADC_CHANNEL_SMPx_BITOFFSET_MASK) */
N
N/* Definition of channels ID number information to be inserted into           */
N/* channels literals definition.                                              */
N#define ADC_CHANNEL_0_NUMBER               (0x00000000U)
N#define ADC_CHANNEL_1_NUMBER               (                                                                                ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_2_NUMBER               (                                                            ADC_CFGR_AWD1CH_1                    )
N#define ADC_CHANNEL_3_NUMBER               (                                                            ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_4_NUMBER               (                                        ADC_CFGR_AWD1CH_2                                        )
N#define ADC_CHANNEL_5_NUMBER               (                                        ADC_CFGR_AWD1CH_2                     | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_6_NUMBER               (                                        ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1                    )
N#define ADC_CHANNEL_7_NUMBER               (                                        ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_8_NUMBER               (                    ADC_CFGR_AWD1CH_3                                                            )
N#define ADC_CHANNEL_9_NUMBER               (                    ADC_CFGR_AWD1CH_3                                         | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_10_NUMBER              (                    ADC_CFGR_AWD1CH_3                     | ADC_CFGR_AWD1CH_1                    )
N#define ADC_CHANNEL_11_NUMBER              (                    ADC_CFGR_AWD1CH_3                     | ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_12_NUMBER              (                    ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2                                        )
N#define ADC_CHANNEL_13_NUMBER              (                    ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2                     | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_14_NUMBER              (                    ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1                    )
N#define ADC_CHANNEL_15_NUMBER              (                    ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_16_NUMBER              (ADC_CFGR_AWD1CH_4                                                                                )
N#define ADC_CHANNEL_17_NUMBER              (ADC_CFGR_AWD1CH_4                                                             | ADC_CFGR_AWD1CH_0)
N#define ADC_CHANNEL_18_NUMBER              (ADC_CFGR_AWD1CH_4                                         | ADC_CFGR_AWD1CH_1                    )
N
N/* Definition of channels ID bitfield information to be inserted into         */
N/* channels literals definition.                                              */
N#define ADC_CHANNEL_0_BITFIELD             (ADC_AWD2CR_AWD2CH_0)
N#define ADC_CHANNEL_1_BITFIELD             (ADC_AWD2CR_AWD2CH_1)
N#define ADC_CHANNEL_2_BITFIELD             (ADC_AWD2CR_AWD2CH_2)
N#define ADC_CHANNEL_3_BITFIELD             (ADC_AWD2CR_AWD2CH_3)
N#define ADC_CHANNEL_4_BITFIELD             (ADC_AWD2CR_AWD2CH_4)
N#define ADC_CHANNEL_5_BITFIELD             (ADC_AWD2CR_AWD2CH_5)
N#define ADC_CHANNEL_6_BITFIELD             (ADC_AWD2CR_AWD2CH_6)
N#define ADC_CHANNEL_7_BITFIELD             (ADC_AWD2CR_AWD2CH_7)
N#define ADC_CHANNEL_8_BITFIELD             (ADC_AWD2CR_AWD2CH_8)
N#define ADC_CHANNEL_9_BITFIELD             (ADC_AWD2CR_AWD2CH_9)
N#define ADC_CHANNEL_10_BITFIELD            (ADC_AWD2CR_AWD2CH_10)
N#define ADC_CHANNEL_11_BITFIELD            (ADC_AWD2CR_AWD2CH_11)
N#define ADC_CHANNEL_12_BITFIELD            (ADC_AWD2CR_AWD2CH_12)
N#define ADC_CHANNEL_13_BITFIELD            (ADC_AWD2CR_AWD2CH_13)
N#define ADC_CHANNEL_14_BITFIELD            (ADC_AWD2CR_AWD2CH_14)
N#define ADC_CHANNEL_15_BITFIELD            (ADC_AWD2CR_AWD2CH_15)
N#define ADC_CHANNEL_16_BITFIELD            (ADC_AWD2CR_AWD2CH_16)
N#define ADC_CHANNEL_17_BITFIELD            (ADC_AWD2CR_AWD2CH_17)
N#define ADC_CHANNEL_18_BITFIELD            (ADC_AWD2CR_AWD2CH_18)
N
N/* Definition of channels sampling time information to be inserted into       */
N/* channels literals definition.                                              */
N#define ADC_CHANNEL_0_SMP                  (ADC_SMPR1_REGOFFSET | (( 0U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP0) */
N#define ADC_CHANNEL_1_SMP                  (ADC_SMPR1_REGOFFSET | (( 3U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP1) */
N#define ADC_CHANNEL_2_SMP                  (ADC_SMPR1_REGOFFSET | (( 6U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP2) */
N#define ADC_CHANNEL_3_SMP                  (ADC_SMPR1_REGOFFSET | (( 9U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP3) */
N#define ADC_CHANNEL_4_SMP                  (ADC_SMPR1_REGOFFSET | ((12U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP4) */
N#define ADC_CHANNEL_5_SMP                  (ADC_SMPR1_REGOFFSET | ((15U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP5) */
N#define ADC_CHANNEL_6_SMP                  (ADC_SMPR1_REGOFFSET | ((18U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP6) */
N#define ADC_CHANNEL_7_SMP                  (ADC_SMPR1_REGOFFSET | ((21U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP7) */
N#define ADC_CHANNEL_8_SMP                  (ADC_SMPR1_REGOFFSET | ((24U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP8) */
N#define ADC_CHANNEL_9_SMP                  (ADC_SMPR1_REGOFFSET | ((27U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR1_SMP9) */
N#define ADC_CHANNEL_10_SMP                 (ADC_SMPR2_REGOFFSET | (( 0U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP10) */
N#define ADC_CHANNEL_11_SMP                 (ADC_SMPR2_REGOFFSET | (( 3U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP11) */
N#define ADC_CHANNEL_12_SMP                 (ADC_SMPR2_REGOFFSET | (( 6U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP12) */
N#define ADC_CHANNEL_13_SMP                 (ADC_SMPR2_REGOFFSET | (( 9U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP13) */
N#define ADC_CHANNEL_14_SMP                 (ADC_SMPR2_REGOFFSET | ((12U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP14) */
N#define ADC_CHANNEL_15_SMP                 (ADC_SMPR2_REGOFFSET | ((15U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP15) */
N#define ADC_CHANNEL_16_SMP                 (ADC_SMPR2_REGOFFSET | ((18U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP16) */
N#define ADC_CHANNEL_17_SMP                 (ADC_SMPR2_REGOFFSET | ((21U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP17) */
N#define ADC_CHANNEL_18_SMP                 (ADC_SMPR2_REGOFFSET | ((24U) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) /* Value shifted is equivalent to POSITION_VAL(ADC_SMPR2_SMP18) */
N
N
N/* Internal mask for ADC mode single or differential ended:                   */
N/* To select into literals LL_ADC_SINGLE_ENDED or LL_ADC_SINGLE_DIFFERENTIAL  */
N/* the relevant bits for:                                                     */
N/* (concatenation of multiple bits used in different registers)               */
N/* - ADC calibration: calibration start, calibration factor get or set        */
N/* - ADC channels: set each ADC channel ending mode                           */
N#define ADC_SINGLEDIFF_CALIB_START_MASK    (ADC_CR_ADCALDIF)
N#define ADC_SINGLEDIFF_CALIB_FACTOR_MASK   (ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S)
N#define ADC_SINGLEDIFF_CHANNEL_MASK        (ADC_CHANNEL_ID_BITFIELD_MASK) /* Equivalent to ADC_DIFSEL_DIFSEL */
N#define ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK  (ADC_CALFACT_CALFACT_S_5) /* Bit chosen to perform of shift when single mode is selected, shift value out of channels bits range. */
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK   (0x00010000U)                           /* Selection of 1 bit to discriminate differential mode: mask of bit */
S#define ADC_SINGLEDIFF_CALIB_F_BIT_D_POS    (16U)                                   /* Selection of 1 bit to discriminate differential mode: position of bit */
S#define ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4 (ADC_SINGLEDIFF_CALIB_F_BIT_D_POS - 4U) /* Shift of bit ADC_SINGLEDIFF_CALIB_F_BIT_D to position to perform a shift of 4 ranks */
N#endif
N
N/* Internal mask for ADC analog watchdog:                                     */
N/* To select into literals LL_ADC_AWD_CHANNELx_xxx the relevant bits for:     */
N/* (concatenation of multiple bits used in different analog watchdogs,        */
N/* (feature of several watchdogs not available on all STM32 families)).       */
N/* - analog watchdog 1: monitored channel defined by number,                  */
N/*   selection of ADC group (ADC groups regular and-or injected).             */
N/* - analog watchdog 2 and 3: monitored channel defined by bitfield, no       */
N/*   selection on groups.                                                     */
N
N/* Internal register offset for ADC analog watchdog channel configuration */
N#define ADC_AWD_CR1_REGOFFSET              (0x00000000U)
N#define ADC_AWD_CR2_REGOFFSET              (0x00100000U)
N#define ADC_AWD_CR3_REGOFFSET              (0x00200000U)
N
N/* Register offset gap between AWD1 and AWD2-AWD3 configuration registers */
N/* (Set separately as ADC_AWD_CRX_REGOFFSET to spare 32 bits space */
N#define ADC_AWD_CR12_REGOFFSETGAP_MASK     (ADC_AWD2CR_AWD2CH_0)
N#define ADC_AWD_CR12_REGOFFSETGAP_VAL      (0x00000024U)
N
N#define ADC_AWD_CRX_REGOFFSET_MASK         (ADC_AWD_CR1_REGOFFSET | ADC_AWD_CR2_REGOFFSET | ADC_AWD_CR3_REGOFFSET)
N
N#define ADC_AWD_CR1_CHANNEL_MASK           (ADC_CFGR_AWD1CH | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)
N#define ADC_AWD_CR23_CHANNEL_MASK          (ADC_AWD2CR_AWD2CH)
N#define ADC_AWD_CR_ALL_CHANNEL_MASK        (ADC_AWD_CR1_CHANNEL_MASK | ADC_AWD_CR23_CHANNEL_MASK)
N
N#define ADC_AWD_CRX_REGOFFSET_POS          (20U) /* Position of bits ADC_AWD_CRx_REGOFFSET in ADC_AWD_CRX_REGOFFSET_MASK */
N
N/* Internal register offset for ADC analog watchdog threshold configuration */
N#define ADC_AWD_TR1_REGOFFSET              (ADC_AWD_CR1_REGOFFSET)
N#define ADC_AWD_TR2_REGOFFSET              (ADC_AWD_CR2_REGOFFSET)
N#define ADC_AWD_TR3_REGOFFSET              (ADC_AWD_CR3_REGOFFSET)
N#define ADC_AWD_TRX_REGOFFSET_MASK         (ADC_AWD_TR1_REGOFFSET | ADC_AWD_TR2_REGOFFSET | ADC_AWD_TR3_REGOFFSET)
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define ADC_AWD_TRX_REGOFFSET_POS          (ADC_AWD_CRX_REGOFFSET_POS)     /* Position of bits ADC_SQRx_REGOFFSET in ADC_AWD_TRX_REGOFFSET_MASK */
S#define ADC_AWD_TRX_BIT_HIGH_MASK          (0x00010000U)                   /* Selection of 1 bit to discriminate threshold high: mask of bit */
S#define ADC_AWD_TRX_BIT_HIGH_POS           (16U)                           /* Selection of 1 bit to discriminate threshold high: position of bit */
S#define ADC_AWD_TRX_BIT_HIGH_SHIFT4        (ADC_AWD_TRX_BIT_HIGH_POS - 4U) /* Shift of bit ADC_AWD_TRX_BIT_HIGH to position to perform a shift of 4 ranks */
N#endif
N
N/* Internal mask for ADC offset:                                              */
N/* Internal register offset for ADC offset number configuration */
N#define ADC_OFR1_REGOFFSET                 (0x00000000U)
N#define ADC_OFR2_REGOFFSET                 (0x00000001U)
N#define ADC_OFR3_REGOFFSET                 (0x00000002U)
N#define ADC_OFR4_REGOFFSET                 (0x00000003U)
N#define ADC_OFRx_REGOFFSET_MASK            (ADC_OFR1_REGOFFSET | ADC_OFR2_REGOFFSET | ADC_OFR3_REGOFFSET | ADC_OFR4_REGOFFSET)
N
N
N/* ADC registers bits positions */
N#define ADC_CFGR_RES_BITOFFSET_POS         ( 3U) /* Value equivalent to POSITION_VAL(ADC_CFGR_RES) */
N#define ADC_CFGR_AWD1SGL_BITOFFSET_POS     (22U) /* Value equivalent to POSITION_VAL(ADC_CFGR_AWD1SGL) */
N#define ADC_CFGR_AWD1EN_BITOFFSET_POS      (23U) /* Value equivalent to POSITION_VAL(ADC_CFGR_AWD1EN) */
N#define ADC_CFGR_JAWD1EN_BITOFFSET_POS     (24U) /* Value equivalent to POSITION_VAL(ADC_CFGR_JAWD1EN) */
N#define ADC_TR1_HT1_BITOFFSET_POS          (16U) /* Value equivalent to POSITION_VAL(ADC_TR1_HT1) */
N
N
N/* ADC registers bits groups */
N#define ADC_CR_BITS_PROPERTY_RS            (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN) /* ADC register CR bits with HW property "rs": Software can read as well as set this bit. Writing '0' has no effect on the bit value. */
N
N
N/* ADC internal channels related definitions */
N/* Internal voltage reference VrefInt */
N#define VREFINT_CAL_ADDR                   ((uint16_t*) (0x1FFF75AAU)) /* Internal voltage reference, address of parameter VREFINT_CAL: VrefInt ADC raw data acquired at temperature 30 DegC (tolerance: +-5 DegC), Vref+ = 3.0 V (tolerance: +-10 mV). */
N#define VREFINT_CAL_VREF                   ( 3000U)                    /* Analog voltage reference (Vref+) value with which temperature sensor has been calibrated in production (tolerance: +-10 mV) (unit: mV). */
N/* Temperature sensor */
N#define TEMPSENSOR_CAL1_ADDR               ((uint16_t*) (0x1FFF75A8U)) /* Internal temperature sensor, address of parameter TS_CAL1: On STM32L4, temperature sensor ADC raw data acquired at temperature  30 DegC (tolerance: +-5 DegC), Vref+ = 3.0 V (tolerance: +-10 mV). */
N#define TEMPSENSOR_CAL2_ADDR               ((uint16_t*) (0x1FFF75CAU)) /* Internal temperature sensor, address of parameter TS_CAL2: On STM32L4, temperature sensor ADC raw data acquired at temperature defined by TEMPSENSOR_CAL2_TEMP (tolerance: +-5 DegC), Vref+ = 3.0 V (tolerance: +-10 mV). */
N#define TEMPSENSOR_CAL1_TEMP               (( int32_t)   30)           /* Internal temperature sensor, temperature at which temperature sensor has been calibrated in production for data into TEMPSENSOR_CAL1_ADDR (tolerance: +-5 DegC) (unit: DegC). */
N#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
X#if 0L || 0L || 0L || 0L || 0L
S#define TEMPSENSOR_CAL2_TEMP               (( int32_t)  110)           /* Internal temperature sensor, temperature at which temperature sensor has been calibrated in production for data into TEMPSENSOR_CAL2_ADDR (tolerance: +-5 DegC) (unit: DegC). */
N#else
N#define TEMPSENSOR_CAL2_TEMP               (( int32_t)  130)           /* Internal temperature sensor, temperature at which temperature sensor has been calibrated in production for data into TEMPSENSOR_CAL2_ADDR (tolerance: +-5 DegC) (unit: DegC). */
N#endif
N#define TEMPSENSOR_CAL_VREFANALOG          ( 3000U)                    /* Analog voltage reference (Vref+) voltage with which temperature sensor has been calibrated in production (+-10 mV) (unit: mV). */
N
N
N/**
N  * @}
N  */
N
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup ADC_LL_Private_Macros ADC Private Macros
N  * @{
N  */
N
N/**
N  * @brief  Driver macro reserved for internal use: isolate bits with the
N  *         selected mask and shift them to the register LSB
N  *         (shift mask on register position bit 0).
N  * @param  __BITS__ Bits in register 32 bits
N  * @param  __MASK__ Mask in register 32 bits
N  * @retval Bits in register 32 bits
N  */
N#define __ADC_MASK_SHIFT(__BITS__, __MASK__)                                   \
N  (((__BITS__) & (__MASK__)) >> POSITION_VAL((__MASK__)))
X#define __ADC_MASK_SHIFT(__BITS__, __MASK__)                                     (((__BITS__) & (__MASK__)) >> POSITION_VAL((__MASK__)))
N
N/**
N  * @brief  Driver macro reserved for internal use: set a pointer to
N  *         a register from a register basis from which an offset
N  *         is applied.
N  * @param  __REG__ Register basis from which the offset is applied.
N  * @param  __REG_OFFFSET__ Offset to be applied (unit: number of registers).
N  * @retval Pointer to register address
N  */
N#define __ADC_PTR_REG_OFFSET(__REG__, __REG_OFFFSET__)                         \
N ((uint32_t *)((uint32_t) ((uint32_t)(&(__REG__)) + ((__REG_OFFFSET__) << 2U))))
X#define __ADC_PTR_REG_OFFSET(__REG__, __REG_OFFFSET__)                          ((uint32_t *)((uint32_t) ((uint32_t)(&(__REG__)) + ((__REG_OFFFSET__) << 2U))))
N
N/**
N  * @}
N  */
N
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup ADC_LL_ES_INIT ADC Exported Init structure
N  * @{
N  */
N
N/**
N  * @brief  Structure definition of some features of ADC common parameters
N  *         and multimode
N  *         (all ADC instances belonging to the same ADC common instance).
N  * @note   The setting of these parameters by function @ref LL_ADC_CommonInit()
N  *         is conditioned to ADC instances state (all ADC instances
N  *         sharing the same ADC common instance):
N  *         All ADC instances sharing the same ADC common instance must be
N  *         disabled.
N  */
Ntypedef struct
N{
N  uint32_t CommonClock;                 /*!< Set parameter common to several ADC: Clock source and prescaler.
N                                             This parameter can be a value of @ref ADC_LL_EC_COMMON_CLOCK_SOURCE
N                                             @note On this STM32 serie, if ADC group injected is used, some
N                                                   clock ratio constraints between ADC clock and AHB clock
N                                                   must be respected. Refer to reference manual.
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetCommonClock(). */
N
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S  uint32_t Multimode;                   /*!< Set ADC multimode configuration to operate in independent mode or multimode (for devices with several ADC instances).
S                                             This parameter can be a value of @ref ADC_LL_EC_MULTI_MODE
S                                             
S                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetMultimode(). */
S
S  uint32_t MultiDMATransfer;            /*!< Set ADC multimode conversion data transfer: no transfer or transfer by DMA.
S                                             This parameter can be a value of @ref ADC_LL_EC_MULTI_DMA_TRANSFER
S                                             
S                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetMultiDMATransfer(). */
S
S  uint32_t MultiTwoSamplingDelay;       /*!< Set ADC multimode delay between 2 sampling phases.
S                                             This parameter can be a value of @ref ADC_LL_EC_MULTI_TWOSMP_DELAY
S                                             
S                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetMultiTwoSamplingDelay(). */
N#endif /* ADC_MULTIMODE_SUPPORT */
N
N} LL_ADC_CommonInitTypeDef;
N
N/**
N  * @brief  Structure definition of some features of ADC instance.
N  * @note   These parameters have an impact on ADC scope: ADC instance.
N  *         Affects both group regular and group injected (availability
N  *         of ADC group injected depends on STM32 families).
N  *         Refer to corresponding unitary functions into
N  *         @ref ADC_LL_EF_Configuration_ADC_Instance .
N  * @note   The setting of these parameters by function @ref LL_ADC_Init()
N  *         is conditioned to ADC state:
N  *         ADC instance must be disabled.
N  *         This condition is applied to all ADC features, for efficiency
N  *         and compatibility over all STM32 families. However, the different
N  *         features can be set under different ADC state conditions
N  *         (setting possible with ADC enabled without conversion on going,
N  *         ADC enabled with conversion on going, ...)
N  *         Each feature can be updated afterwards with a unitary function
N  *         and potentially with ADC in a different state than disabled,
N  *         refer to description of each function for setting
N  *         conditioned to ADC state.
N  */
Ntypedef struct
N{
N  uint32_t Resolution;                  /*!< Set ADC resolution.
N                                             This parameter can be a value of @ref ADC_LL_EC_RESOLUTION
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetResolution(). */
N
N  uint32_t DataAlignment;               /*!< Set ADC conversion data alignment.
N                                             This parameter can be a value of @ref ADC_LL_EC_DATA_ALIGN
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetDataAlignment(). */
N
N  uint32_t LowPowerMode;                /*!< Set ADC low power mode.
N                                             This parameter can be a value of @ref ADC_LL_EC_LP_MODE
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_SetLowPowerMode(). */
N
N} LL_ADC_InitTypeDef;
N
N/**
N  * @brief  Structure definition of some features of ADC group regular.
N  * @note   These parameters have an impact on ADC scope: ADC group regular.
N  *         Refer to corresponding unitary functions into
N  *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
N  *         (functions with prefix "REG").
N  * @note   The setting of these parameters by function @ref LL_ADC_REG_Init()
N  *         is conditioned to ADC state:
N  *         ADC instance must be disabled.
N  *         This condition is applied to all ADC features, for efficiency
N  *         and compatibility over all STM32 families. However, the different
N  *         features can be set under different ADC state conditions
N  *         (setting possible with ADC enabled without conversion on going,
N  *         ADC enabled with conversion on going, ...)
N  *         Each feature can be updated afterwards with a unitary function
N  *         and potentially with ADC in a different state than disabled,
N  *         refer to description of each function for setting
N  *         conditioned to ADC state.
N  */
Ntypedef struct
N{
N  uint32_t TriggerSource;               /*!< Set ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line).
N                                             This parameter can be a value of @ref ADC_LL_EC_REG_TRIGGER_SOURCE
N                                             @note On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge
N                                                   (default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value).
N                                                   In case of need to modify trigger edge, use function @ref LL_ADC_REG_SetTriggerEdge().
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetTriggerSource(). */
N
N  uint32_t SequencerLength;             /*!< Set ADC group regular sequencer length.
N                                             This parameter can be a value of @ref ADC_LL_EC_REG_SEQ_SCAN_LENGTH
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetSequencerLength(). */
N
N  uint32_t SequencerDiscont;            /*!< Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks.
N                                             This parameter can be a value of @ref ADC_LL_EC_REG_SEQ_DISCONT_MODE
N                                             @note This parameter has an effect only if group regular sequencer is enabled
N                                                   (scan length of 2 ranks or more).
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetSequencerDiscont(). */
N
N  uint32_t ContinuousMode;              /*!< Set ADC continuous conversion mode on ADC group regular, whether ADC conversions are performed in single mode (one conversion per trigger) or in continuous mode (after the first trigger, following conversions launched successively automatically).
N                                             This parameter can be a value of @ref ADC_LL_EC_REG_CONTINUOUS_MODE
N                                             Note: It is not possible to enable both ADC group regular continuous mode and discontinuous mode.
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetContinuousMode(). */
N
N  uint32_t DMATransfer;                 /*!< Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.
N                                             This parameter can be a value of @ref ADC_LL_EC_REG_DMA_TRANSFER
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetDMATransfer(). */
N
N  uint32_t Overrun;                     /*!< Set ADC group regular behavior in case of overrun:
N                                             data preserved or overwritten.
N                                             This parameter can be a value of @ref ADC_LL_EC_REG_OVR_DATA_BEHAVIOR
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_REG_SetOverrun(). */
N
N} LL_ADC_REG_InitTypeDef;
N
N/**
N  * @brief  Structure definition of some features of ADC group injected.
N  * @note   These parameters have an impact on ADC scope: ADC group injected.
N  *         Refer to corresponding unitary functions into
N  *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
N  *         (functions with prefix "INJ").
N  * @note   The setting of these parameters by function @ref LL_ADC_INJ_Init()
N  *         is conditioned to ADC state:
N  *         ADC instance must be disabled.
N  *         This condition is applied to all ADC features, for efficiency
N  *         and compatibility over all STM32 families. However, the different
N  *         features can be set under different ADC state conditions
N  *         (setting possible with ADC enabled without conversion on going,
N  *         ADC enabled with conversion on going, ...)
N  *         Each feature can be updated afterwards with a unitary function
N  *         and potentially with ADC in a different state than disabled,
N  *         refer to description of each function for setting
N  *         conditioned to ADC state.
N  */
Ntypedef struct
N{
N  uint32_t TriggerSource;               /*!< Set ADC group injected conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line).
N                                             This parameter can be a value of @ref ADC_LL_EC_INJ_TRIGGER_SOURCE
N                                             @note On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge
N                                                   (default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value).
N                                                   In case of need to modify trigger edge, use function @ref LL_ADC_INJ_SetTriggerEdge().
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetTriggerSource(). */
N
N  uint32_t SequencerLength;             /*!< Set ADC group injected sequencer length.
N                                             This parameter can be a value of @ref ADC_LL_EC_INJ_SEQ_SCAN_LENGTH
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetSequencerLength(). */
N
N  uint32_t SequencerDiscont;            /*!< Set ADC group injected sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks.
N                                             This parameter can be a value of @ref ADC_LL_EC_INJ_SEQ_DISCONT_MODE
N                                             @note This parameter has an effect only if group injected sequencer is enabled
N                                                   (scan length of 2 ranks or more).
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetSequencerDiscont(). */
N
N  uint32_t TrigAuto;                    /*!< Set ADC group injected conversion trigger: independent or from ADC group regular.
N                                             This parameter can be a value of @ref ADC_LL_EC_INJ_TRIG_AUTO
N                                             Note: This parameter must be set to set to independent trigger if injected trigger source is set to an external trigger. 
N                                             
N                                             This feature can be modified afterwards using unitary function @ref LL_ADC_INJ_SetTrigAuto(). */
N
N} LL_ADC_INJ_InitTypeDef;
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ADC_LL_Exported_Constants ADC Exported Constants
N  * @{
N  */
N
N/** @defgroup ADC_LL_EC_FLAG ADC flags
N  * @brief    Flags defines which can be used with LL_ADC_ReadReg function
N  * @{
N  */
N#define LL_ADC_FLAG_ADRDY                  ADC_ISR_ADRDY      /*!< ADC flag ADC instance ready */
N#define LL_ADC_FLAG_EOC                    ADC_ISR_EOC        /*!< ADC flag ADC group regular end of unitary conversion */
N#define LL_ADC_FLAG_EOS                    ADC_ISR_EOS        /*!< ADC flag ADC group regular end of sequence conversions */
N#define LL_ADC_FLAG_OVR                    ADC_ISR_OVR        /*!< ADC flag ADC group regular overrun */
N#define LL_ADC_FLAG_EOSMP                  ADC_ISR_EOSMP      /*!< ADC flag ADC group regular end of sampling phase */
N#define LL_ADC_FLAG_JEOC                   ADC_ISR_JEOC       /*!< ADC flag ADC group injected end of unitary conversion */
N#define LL_ADC_FLAG_JEOS                   ADC_ISR_JEOS       /*!< ADC flag ADC group injected end of sequence conversions */
N#define LL_ADC_FLAG_JQOVF                  ADC_ISR_JQOVF      /*!< ADC flag ADC group injected contexts queue overflow */
N#define LL_ADC_FLAG_AWD1                   ADC_ISR_AWD1       /*!< ADC flag ADC analog watchdog 1 */
N#define LL_ADC_FLAG_AWD2                   ADC_ISR_AWD2       /*!< ADC flag ADC analog watchdog 2 */
N#define LL_ADC_FLAG_AWD3                   ADC_ISR_AWD3       /*!< ADC flag ADC analog watchdog 3 */
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S#define LL_ADC_FLAG_ADRDY_MST              ADC_CSR_ADRDY_MST  /*!< ADC flag ADC multimode master instance ready */
S#define LL_ADC_FLAG_ADRDY_SLV              ADC_CSR_ADRDY_SLV  /*!< ADC flag ADC multimode slave instance ready */
S#define LL_ADC_FLAG_EOC_MST                ADC_CSR_EOC_MST    /*!< ADC flag ADC multimode master group regular end of unitary conversion */
S#define LL_ADC_FLAG_EOC_SLV                ADC_CSR_EOC_SLV    /*!< ADC flag ADC multimode slave group regular end of unitary conversion */
S#define LL_ADC_FLAG_EOS_MST                ADC_CSR_EOS_MST    /*!< ADC flag ADC multimode master group regular end of sequence conversions */
S#define LL_ADC_FLAG_EOS_SLV                ADC_CSR_EOS_SLV    /*!< ADC flag ADC multimode slave group regular end of sequence conversions */
S#define LL_ADC_FLAG_OVR_MST                ADC_CSR_OVR_MST    /*!< ADC flag ADC multimode master group regular overrun */
S#define LL_ADC_FLAG_OVR_SLV                ADC_CSR_OVR_SLV    /*!< ADC flag ADC multimode slave group regular overrun */
S#define LL_ADC_FLAG_EOSMP_MST              ADC_CSR_EOSMP_MST  /*!< ADC flag ADC multimode master group regular end of sampling phase */
S#define LL_ADC_FLAG_EOSMP_SLV              ADC_CSR_EOSMP_SLV  /*!< ADC flag ADC multimode slave group regular end of sampling phase */
S#define LL_ADC_FLAG_JEOC_MST               ADC_CSR_JEOC_MST   /*!< ADC flag ADC multimode master group injected end of unitary conversion */
S#define LL_ADC_FLAG_JEOC_SLV               ADC_CSR_JEOC_SLV   /*!< ADC flag ADC multimode slave group injected end of unitary conversion */
S#define LL_ADC_FLAG_JEOS_MST               ADC_CSR_JEOS_MST   /*!< ADC flag ADC multimode master group injected end of sequence conversions */
S#define LL_ADC_FLAG_JEOS_SLV               ADC_CSR_JEOS_SLV   /*!< ADC flag ADC multimode slave group injected end of sequence conversions */
S#define LL_ADC_FLAG_JQOVF_MST              ADC_CSR_JQOVF_MST  /*!< ADC flag ADC multimode master group injected contexts queue overflow */
S#define LL_ADC_FLAG_JQOVF_SLV              ADC_CSR_JQOVF_SLV  /*!< ADC flag ADC multimode slave group injected contexts queue overflow */
S#define LL_ADC_FLAG_AWD1_MST               ADC_CSR_AWD1_MST   /*!< ADC flag ADC multimode master analog watchdog 1 of the ADC master */
S#define LL_ADC_FLAG_AWD1_SLV               ADC_CSR_AWD1_SLV   /*!< ADC flag ADC multimode slave analog watchdog 1 of the ADC slave */
S#define LL_ADC_FLAG_AWD2_MST               ADC_CSR_AWD2_MST   /*!< ADC flag ADC multimode master analog watchdog 2 of the ADC master */
S#define LL_ADC_FLAG_AWD2_SLV               ADC_CSR_AWD2_SLV   /*!< ADC flag ADC multimode slave analog watchdog 2 of the ADC slave */
S#define LL_ADC_FLAG_AWD3_MST               ADC_CSR_AWD3_MST   /*!< ADC flag ADC multimode master analog watchdog 3 of the ADC master */
S#define LL_ADC_FLAG_AWD3_SLV               ADC_CSR_AWD3_SLV   /*!< ADC flag ADC multimode slave analog watchdog 3 of the ADC slave */
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_IT ADC interruptions for configuration (interruption enable or disable)
N  * @brief    IT defines which can be used with LL_ADC_ReadReg and  LL_ADC_WriteReg functions
N  * @{
N  */
N#define LL_ADC_IT_ADRDY                    ADC_IER_ADRDYIE    /*!< ADC interruption ADC instance ready */
N#define LL_ADC_IT_EOC                      ADC_IER_EOCIE      /*!< ADC interruption ADC group regular end of unitary conversion */
N#define LL_ADC_IT_EOS                      ADC_IER_EOSIE      /*!< ADC interruption ADC group regular end of sequence conversions */
N#define LL_ADC_IT_OVR                      ADC_IER_OVRIE      /*!< ADC interruption ADC group regular overrun */
N#define LL_ADC_IT_EOSMP                    ADC_IER_EOSMPIE    /*!< ADC interruption ADC group regular end of sampling phase */
N#define LL_ADC_IT_JEOC                     ADC_IER_JEOCIE     /*!< ADC interruption ADC group injected end of unitary conversion */
N#define LL_ADC_IT_JEOS                     ADC_IER_JEOSIE     /*!< ADC interruption ADC group injected end of sequence conversions */
N#define LL_ADC_IT_JQOVF                    ADC_IER_JQOVFIE    /*!< ADC interruption ADC group injected contexts queue overflow */
N#define LL_ADC_IT_AWD1                     ADC_IER_AWD1IE     /*!< ADC interruption ADC analog watchdog 1 */
N#define LL_ADC_IT_AWD2                     ADC_IER_AWD2IE     /*!< ADC interruption ADC analog watchdog 2 */
N#define LL_ADC_IT_AWD3                     ADC_IER_AWD3IE     /*!< ADC interruption ADC analog watchdog 3 */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REGISTERS  ADC registers compliant with specific purpose
N  * @{
N  */
N/* List of ADC registers intended to be used (most commonly) with             */
N/* DMA transfer.                                                              */
N/* Refer to function @ref LL_ADC_DMA_GetRegAddr().                            */
N#define LL_ADC_DMA_REG_REGULAR_DATA          (0x00000000U) /* ADC group regular conversion data register (corresponding to register DR) to be used with ADC configured in independent mode. Without DMA transfer, register accessed by LL function @ref LL_ADC_REG_ReadConversionData32() and other functions @ref LL_ADC_REG_ReadConversionDatax() */
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S#define LL_ADC_DMA_REG_REGULAR_DATA_MULTI    (0x00000001U) /* ADC group regular conversion data register (corresponding to register CDR) to be used with ADC configured in multimode (available on STM32 devices with several ADC instances). Without DMA transfer, register accessed by LL function @ref LL_ADC_REG_ReadMultiConversionData32() */
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_COMMON_CLOCK_SOURCE  ADC common - Clock source
N  * @{
N  */
N#define LL_ADC_CLOCK_SYNC_PCLK_DIV1        (ADC_CCR_CKMODE_0)                                    /*!< ADC synchronous clock derived from AHB clock without prescaler */
N#define LL_ADC_CLOCK_SYNC_PCLK_DIV2        (ADC_CCR_CKMODE_1                   )                 /*!< ADC synchronous clock derived from AHB clock with prescaler division by 2 */
N#define LL_ADC_CLOCK_SYNC_PCLK_DIV4        (ADC_CCR_CKMODE_1 | ADC_CCR_CKMODE_0)                 /*!< ADC synchronous clock derived from AHB clock with prescaler division by 4 */
N#define LL_ADC_CLOCK_ASYNC_DIV1            (0x00000000U)                               /*!< ADC asynchronous clock without prescaler */
N#define LL_ADC_CLOCK_ASYNC_DIV2            (ADC_CCR_PRESC_0)                                     /*!< ADC asynchronous clock with prescaler division by 2   */
N#define LL_ADC_CLOCK_ASYNC_DIV4            (ADC_CCR_PRESC_1                  )                   /*!< ADC asynchronous clock with prescaler division by 4   */
N#define LL_ADC_CLOCK_ASYNC_DIV6            (ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0)                   /*!< ADC asynchronous clock with prescaler division by 6   */
N#define LL_ADC_CLOCK_ASYNC_DIV8            (ADC_CCR_PRESC_2                                    ) /*!< ADC asynchronous clock with prescaler division by 8   */
N#define LL_ADC_CLOCK_ASYNC_DIV10           (ADC_CCR_PRESC_2                   | ADC_CCR_PRESC_0) /*!< ADC asynchronous clock with prescaler division by 10  */
N#define LL_ADC_CLOCK_ASYNC_DIV12           (ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1                  ) /*!< ADC asynchronous clock with prescaler division by 12  */
N#define LL_ADC_CLOCK_ASYNC_DIV16           (ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0) /*!< ADC asynchronous clock with prescaler division by 16  */
N#define LL_ADC_CLOCK_ASYNC_DIV32           (ADC_CCR_PRESC_3)                                     /*!< ADC asynchronous clock with prescaler division by 32  */
N#define LL_ADC_CLOCK_ASYNC_DIV64           (ADC_CCR_PRESC_3 | ADC_CCR_PRESC_0)                   /*!< ADC asynchronous clock with prescaler division by 64  */
N#define LL_ADC_CLOCK_ASYNC_DIV128          (ADC_CCR_PRESC_3 | ADC_CCR_PRESC_1)                   /*!< ADC asynchronous clock with prescaler division by 128 */
N#define LL_ADC_CLOCK_ASYNC_DIV256          (ADC_CCR_PRESC_3 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0) /*!< ADC asynchronous clock with prescaler division by 256 */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_COMMON_PATH_INTERNAL  ADC common - Measurement path to internal channels
N  * @{
N  */
N/* Note: Other measurement paths to internal channels may be available        */
N/*       (connections to other peripherals).                                  */
N/*       If they are not listed below, they do not require any specific       */
N/*       path enable. In this case, Access to measurement path is done        */
N/*       only by selecting the corresponding ADC internal channel.            */
N#define LL_ADC_PATH_INTERNAL_NONE          (0x00000000U)/*!< ADC measurement pathes all disabled */
N#define LL_ADC_PATH_INTERNAL_VREFINT       (ADC_CCR_VREFEN)       /*!< ADC measurement path to internal channel VrefInt */
N#define LL_ADC_PATH_INTERNAL_TEMPSENSOR    (ADC_CCR_TSEN)         /*!< ADC measurement path to internal channel temperature sensor */
N#define LL_ADC_PATH_INTERNAL_VBAT          (ADC_CCR_VBATEN)       /*!< ADC measurement path to internal channel Vbat */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_RESOLUTION  ADC instance - Resolution
N  * @{
N  */
N#define LL_ADC_RESOLUTION_12B              (0x00000000U)             /*!< ADC resolution 12 bits */
N#define LL_ADC_RESOLUTION_10B              (                 ADC_CFGR_RES_0)   /*!< ADC resolution 10 bits */
N#define LL_ADC_RESOLUTION_8B               (ADC_CFGR_RES_1                 )   /*!< ADC resolution  8 bits */
N#define LL_ADC_RESOLUTION_6B               (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)   /*!< ADC resolution  6 bits */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_DATA_ALIGN  ADC instance - Data alignment
N  * @{
N  */
N#define LL_ADC_DATA_ALIGN_RIGHT            (0x00000000U)/*!< ADC conversion data alignment: right aligned (alignment on data register LSB bit 0)*/
N#define LL_ADC_DATA_ALIGN_LEFT             (ADC_CFGR_ALIGN)       /*!< ADC conversion data alignment: left aligned (aligment on data register MSB bit 15)*/
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_LP_MODE  ADC instance - Low power mode
N  * @{
N  */
N#define LL_ADC_LP_MODE_NONE                (0x00000000U)             /*!< No ADC low power mode activated */
N#define LL_ADC_LP_AUTOWAIT                 (ADC_CFGR_AUTDLY)                   /*!< ADC low power mode auto delay: Dynamic low power mode, ADC conversions are performed only when necessary (when previous ADC conversion data is read). See description with function @ref LL_ADC_SetLowPowerMode(). */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_OFFSET_NB  ADC instance - Offset number
N  * @{
N  */
N#define LL_ADC_OFFSET_1                    ADC_OFR1_REGOFFSET /*!< ADC offset number 1: ADC channel and offset level to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected) */
N#define LL_ADC_OFFSET_2                    ADC_OFR2_REGOFFSET /*!< ADC offset number 2: ADC channel and offset level to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected) */
N#define LL_ADC_OFFSET_3                    ADC_OFR3_REGOFFSET /*!< ADC offset number 3: ADC channel and offset level to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected) */
N#define LL_ADC_OFFSET_4                    ADC_OFR4_REGOFFSET /*!< ADC offset number 4: ADC channel and offset level to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected) */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_OFFSET_STATE ADC instance - Offset state
N  * @{
N  */
N#define LL_ADC_OFFSET_DISABLE              (0x00000000U)/*!< ADC offset disabled (among ADC selected offset number 1, 2, 3 or 4) */
N#define LL_ADC_OFFSET_ENABLE               (ADC_OFR1_OFFSET1_EN)  /*!< ADC offset enabled (among ADC selected offset number 1, 2, 3 or 4) */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_GROUPS  ADC instance - Groups
N  * @{
N  */
N#define LL_ADC_GROUP_REGULAR               (0x00000001U) /*!< ADC group regular (available on all STM32 devices) */
N#define LL_ADC_GROUP_INJECTED              (0x00000002U) /*!< ADC group injected (not available on all STM32 devices)*/
N#define LL_ADC_GROUP_REGULAR_INJECTED      (0x00000003U) /*!< ADC both groups regular and injected */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_CHANNEL  ADC instance - Channel number
N  * @{
N  */
N#define LL_ADC_CHANNEL_0                   (ADC_CHANNEL_0_NUMBER  | ADC_CHANNEL_0_SMP  | ADC_CHANNEL_0_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN0  */
N#define LL_ADC_CHANNEL_1                   (ADC_CHANNEL_1_NUMBER  | ADC_CHANNEL_1_SMP  | ADC_CHANNEL_1_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN1  */
N#define LL_ADC_CHANNEL_2                   (ADC_CHANNEL_2_NUMBER  | ADC_CHANNEL_2_SMP  | ADC_CHANNEL_2_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN2  */
N#define LL_ADC_CHANNEL_3                   (ADC_CHANNEL_3_NUMBER  | ADC_CHANNEL_3_SMP  | ADC_CHANNEL_3_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN3  */
N#define LL_ADC_CHANNEL_4                   (ADC_CHANNEL_4_NUMBER  | ADC_CHANNEL_4_SMP  | ADC_CHANNEL_4_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN4  */
N#define LL_ADC_CHANNEL_5                   (ADC_CHANNEL_5_NUMBER  | ADC_CHANNEL_5_SMP  | ADC_CHANNEL_5_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN5  */
N#define LL_ADC_CHANNEL_6                   (ADC_CHANNEL_6_NUMBER  | ADC_CHANNEL_6_SMP  | ADC_CHANNEL_6_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN6  */
N#define LL_ADC_CHANNEL_7                   (ADC_CHANNEL_7_NUMBER  | ADC_CHANNEL_7_SMP  | ADC_CHANNEL_7_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN7  */
N#define LL_ADC_CHANNEL_8                   (ADC_CHANNEL_8_NUMBER  | ADC_CHANNEL_8_SMP  | ADC_CHANNEL_8_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN8  */
N#define LL_ADC_CHANNEL_9                   (ADC_CHANNEL_9_NUMBER  | ADC_CHANNEL_9_SMP  | ADC_CHANNEL_9_BITFIELD ) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN9  */
N#define LL_ADC_CHANNEL_10                  (ADC_CHANNEL_10_NUMBER | ADC_CHANNEL_10_SMP | ADC_CHANNEL_10_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN10 */
N#define LL_ADC_CHANNEL_11                  (ADC_CHANNEL_11_NUMBER | ADC_CHANNEL_11_SMP | ADC_CHANNEL_11_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN11 */
N#define LL_ADC_CHANNEL_12                  (ADC_CHANNEL_12_NUMBER | ADC_CHANNEL_12_SMP | ADC_CHANNEL_12_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN12 */
N#define LL_ADC_CHANNEL_13                  (ADC_CHANNEL_13_NUMBER | ADC_CHANNEL_13_SMP | ADC_CHANNEL_13_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN13 */
N#define LL_ADC_CHANNEL_14                  (ADC_CHANNEL_14_NUMBER | ADC_CHANNEL_14_SMP | ADC_CHANNEL_14_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN14 */
N#define LL_ADC_CHANNEL_15                  (ADC_CHANNEL_15_NUMBER | ADC_CHANNEL_15_SMP | ADC_CHANNEL_15_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN15 */
N#define LL_ADC_CHANNEL_16                  (ADC_CHANNEL_16_NUMBER | ADC_CHANNEL_16_SMP | ADC_CHANNEL_16_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN16 */
N#define LL_ADC_CHANNEL_17                  (ADC_CHANNEL_17_NUMBER | ADC_CHANNEL_17_SMP | ADC_CHANNEL_17_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN17 */
N#define LL_ADC_CHANNEL_18                  (ADC_CHANNEL_18_NUMBER | ADC_CHANNEL_18_SMP | ADC_CHANNEL_18_BITFIELD) /*!< ADC external channel (channel connected to GPIO pin) ADCx_IN18 */
N#define LL_ADC_CHANNEL_VREFINT             (LL_ADC_CHANNEL_0  | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to VrefInt: Internal voltage reference. On STM32L4, ADC channel available only on ADC instance: ADC1. */
N#define LL_ADC_CHANNEL_TEMPSENSOR          (LL_ADC_CHANNEL_17 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to Temperature sensor. On STM32L4, ADC channel available only on ADC instances: ADC1, ADC3. */
N#define LL_ADC_CHANNEL_VBAT                (LL_ADC_CHANNEL_18 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to Vbat/3: Vbat voltage through a divider ladder of factor 1/3 to have Vbat always below Vdda. On STM32L4, ADC channel available only on ADC instances: ADC1, ADC3. */
N#if defined(ADC1) && !defined(ADC2)
X#if 1L && !0L
N#define LL_ADC_CHANNEL_DAC1CH1             (LL_ADC_CHANNEL_17 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2) /*!< ADC internal channel connected to DAC1 channel 1, channel specific to ADC1. This channel is shared with ADC internal channel connected to temperature sensor, selection is done using function @ref LL_ADC_SetCommonPathInternalCh(). */
N#define LL_ADC_CHANNEL_DAC1CH2             (LL_ADC_CHANNEL_18 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2) /*!< ADC internal channel connected to DAC1 channel 2, channel specific to ADC1. This channel is shared with ADC internal channel connected to Vbat, selection is done using function @ref LL_ADC_SetCommonPathInternalCh(). */
N#elif defined(ADC2)
S#define LL_ADC_CHANNEL_DAC1CH1_ADC2        (LL_ADC_CHANNEL_17 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2) /*!< ADC internal channel connected to DAC1 channel 1, channel specific to ADC2 */
S#define LL_ADC_CHANNEL_DAC1CH2_ADC2        (LL_ADC_CHANNEL_18 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2) /*!< ADC internal channel connected to DAC1 channel 2, channel specific to ADC2 */
S#if defined(ADC3)
S#define LL_ADC_CHANNEL_DAC1CH1_ADC3        (LL_ADC_CHANNEL_14 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to DAC1 channel 1, channel specific to ADC3 */
S#define LL_ADC_CHANNEL_DAC1CH2_ADC3        (LL_ADC_CHANNEL_15 | ADC_CHANNEL_ID_INTERNAL_CH) /*!< ADC internal channel connected to DAC1 channel 2, channel specific to ADC3 */
S#endif
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_TRIGGER_SOURCE  ADC group regular - Trigger source
N  * @{
N  */
N#define LL_ADC_REG_TRIG_SOFTWARE           (0x00000000U)                                                                                                   /*!< ADC group regular conversion trigger internal: SW start. */
N#define LL_ADC_REG_TRIG_EXT_TIM1_TRGO      (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                         /*!< ADC group regular conversion trigger from external IP: TIM1 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM1_TRGO2     (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                         /*!< ADC group regular conversion trigger from external IP: TIM1 TRGO2. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM1_CH1       (ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                                                                 /*!< ADC group regular conversion trigger from external IP: TIM1 channel 1 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM1_CH2       (ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                                             /*!< ADC group regular conversion trigger from external IP: TIM1 channel 2 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM1_CH3       (ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                                             /*!< ADC group regular conversion trigger from external IP: TIM1 channel 3 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM2_TRGO      (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                     /*!< ADC group regular conversion trigger from external IP: TIM2 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM2_CH2       (ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                         /*!< ADC group regular conversion trigger from external IP: TIM2 channel 2 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM3_TRGO      (ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                                             /*!< ADC group regular conversion trigger from external IP: TIM3 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM3_CH4       (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT) /*!< ADC group regular conversion trigger from external IP: TIM3 channel 4 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM4_TRGO      (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                         /*!< ADC group regular conversion trigger from external IP: TIM4 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM4_CH4       (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                         /*!< ADC group regular conversion trigger from external IP: TIM4 channel 4 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM6_TRGO      (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                     /*!< ADC group regular conversion trigger from external IP: TIM6 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM8_TRGO      (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                     /*!< ADC group regular conversion trigger from external IP: TIM8 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM8_TRGO2     (ADC_CFGR_EXTSEL_3 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                                             /*!< ADC group regular conversion trigger from external IP: TIM8 TRGO2. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_TIM15_TRGO     (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                     /*!< ADC group regular conversion trigger from external IP: TIM15 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_REG_TRIG_EXT_EXTI_LINE11    (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)                                         /*!< ADC group regular conversion trigger from external IP: external interrupt line 11. Trigger edge set to rising edge (default setting). */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_TRIGGER_EDGE  ADC group regular - Trigger edge
N  * @{
N  */
N#define LL_ADC_REG_TRIG_EXT_RISING         (                   ADC_CFGR_EXTEN_0)   /*!< ADC group regular conversion trigger polarity set to rising edge */
N#define LL_ADC_REG_TRIG_EXT_FALLING        (ADC_CFGR_EXTEN_1                   )   /*!< ADC group regular conversion trigger polarity set to falling edge */
N#define LL_ADC_REG_TRIG_EXT_RISINGFALLING  (ADC_CFGR_EXTEN_1 | ADC_CFGR_EXTEN_0)   /*!< ADC group regular conversion trigger polarity set to both rising and falling edges */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_CONTINUOUS_MODE  ADC group regular - Continuous mode
N* @{
N*/
N#define LL_ADC_REG_CONV_SINGLE             (0x00000000U)           /*!< ADC conversions are performed in single mode: one conversion per trigger */
N#define LL_ADC_REG_CONV_CONTINUOUS         (ADC_CFGR_CONT)         /*!< ADC conversions are performed in continuous mode: after the first trigger, following conversions launched successively automatically */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_DMA_TRANSFER  ADC group regular - DMA transfer of ADC conversion data
N  * @{
N  */
N#define LL_ADC_REG_DMA_TRANSFER_NONE       (0x00000000U)                        /*!< ADC conversions are not transferred by DMA */
N#define LL_ADC_REG_DMA_TRANSFER_LIMITED    (                  ADC_CFGR_DMAEN)   /*!< ADC conversion data are transferred by DMA, in limited mode (one shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular. */
N#define LL_ADC_REG_DMA_TRANSFER_UNLIMITED  (ADC_CFGR_DMACFG | ADC_CFGR_DMAEN)   /*!< ADC conversion data are transferred by DMA, in unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transferred (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. */
N/**
N  * @}
N  */
N
N#if defined(ADC_CFGR_DFSDMCFG) &&defined(DFSDM1_Channel0)
X#if 0L &&0L
S/** @defgroup ADC_LL_EC_REG_DFSDM_TRANSFER ADC group regular - DFSDM transfer of ADC conversion data
S  * @{
S  */
S#define LL_ADC_REG_DFSDM_TRANSFER_NONE     (0x00000000U)           /*!< ADC conversions are not transferred by DFSDM. */
S#define LL_ADC_REG_DFSDM_TRANSFER_ENABLE   (ADC_CFGR_DFSDMCFG)     /*!< ADC conversion data are transfered to DFSDM for post processing. The ADC conversion data format must be 16-bit signed and right aligned, refer to reference manual. DFSDM transfer cannot be used if DMA transfer is enabled. */
S/**
S  * @}
S  */
N#endif
N
N#if defined(ADC_SMPR1_SMPPLUS)
X#if 0L
S/** @defgroup ADC_LL_EC_SAMPLINGTIME_COMMON_CONFIG ADC instance - ADC sampling time common configuration
S  * @{
S  */
S#define LL_ADC_SAMPLINGTIME_COMMON_DEFAULT      (0x00000000U)       /*!< ADC sampling time let to default settings. */
S#define LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5 (ADC_SMPR1_SMPPLUS) /*!< ADC additional sampling time 3.5 ADC clock cycles replacing 2.5 ADC clock cycles (this applies to all channels mapped with selection sampling time 2.5 ADC clock cycles, whatever channels mapped on ADC groups regular or injected). */
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup ADC_LL_EC_REG_OVR_DATA_BEHAVIOR  ADC group regular - Overrun behavior on conversion data
N* @{
N*/
N#define LL_ADC_REG_OVR_DATA_PRESERVED      (0x00000000U)          /*!< ADC group regular behavior in case of overrun: data preserved */
N#define LL_ADC_REG_OVR_DATA_OVERWRITTEN    (ADC_CFGR_OVRMOD)      /*!< ADC group regular behavior in case of overrun: data overwritten */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_SEQ_SCAN_LENGTH  ADC group regular - Sequencer scan length
N  * @{
N  */
N#define LL_ADC_REG_SEQ_SCAN_DISABLE        (0x00000000U)                                               /*!< ADC group regular sequencer disable (equivalent to sequencer of 1 rank: ADC conversion on only 1 channel) */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS  (                                             ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 2 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS  (                              ADC_SQR1_L_1               ) /*!< ADC group regular sequencer enable with 3 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS  (                              ADC_SQR1_L_1 | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 4 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS  (               ADC_SQR1_L_2                              ) /*!< ADC group regular sequencer enable with 5 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS  (               ADC_SQR1_L_2                | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 6 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS  (               ADC_SQR1_L_2 | ADC_SQR1_L_1               ) /*!< ADC group regular sequencer enable with 7 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS  (               ADC_SQR1_L_2 | ADC_SQR1_L_1 | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 8 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS  (ADC_SQR1_L_3                                             ) /*!< ADC group regular sequencer enable with 9 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS (ADC_SQR1_L_3                               | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 10 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS (ADC_SQR1_L_3                | ADC_SQR1_L_1               ) /*!< ADC group regular sequencer enable with 11 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS (ADC_SQR1_L_3                | ADC_SQR1_L_1 | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 12 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2                              ) /*!< ADC group regular sequencer enable with 13 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2                | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 14 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2 | ADC_SQR1_L_1               ) /*!< ADC group regular sequencer enable with 15 ranks in the sequence */
N#define LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2 | ADC_SQR1_L_1 | ADC_SQR1_L_0) /*!< ADC group regular sequencer enable with 16 ranks in the sequence */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_SEQ_DISCONT_MODE  ADC group regular - Sequencer discontinuous mode
N  * @{
N  */
N#define LL_ADC_REG_SEQ_DISCONT_DISABLE     (0x00000000U)                                                                /*!< ADC group regular sequencer discontinuous mode disable */
N#define LL_ADC_REG_SEQ_DISCONT_1RANK       (                                                               ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every rank */
N#define LL_ADC_REG_SEQ_DISCONT_2RANKS      (                                          ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enabled with sequence interruption every 2 ranks */
N#define LL_ADC_REG_SEQ_DISCONT_3RANKS      (                     ADC_CFGR_DISCNUM_1                      | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every 3 ranks */
N#define LL_ADC_REG_SEQ_DISCONT_4RANKS      (                     ADC_CFGR_DISCNUM_1 | ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every 4 ranks */
N#define LL_ADC_REG_SEQ_DISCONT_5RANKS      (ADC_CFGR_DISCNUM_2                                           | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every 5 ranks */
N#define LL_ADC_REG_SEQ_DISCONT_6RANKS      (ADC_CFGR_DISCNUM_2                      | ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every 6 ranks */
N#define LL_ADC_REG_SEQ_DISCONT_7RANKS      (ADC_CFGR_DISCNUM_2 | ADC_CFGR_DISCNUM_1                      | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every 7 ranks */
N#define LL_ADC_REG_SEQ_DISCONT_8RANKS      (ADC_CFGR_DISCNUM_2 | ADC_CFGR_DISCNUM_1 | ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN) /*!< ADC group regular sequencer discontinuous mode enable with sequence interruption every 8 ranks */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_REG_SEQ_RANKS  ADC group regular - Sequencer ranks
N  * @{
N  */
N#define LL_ADC_REG_RANK_1                  (ADC_SQR1_REGOFFSET | ADC_REG_RANK_1_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 1 */
N#define LL_ADC_REG_RANK_2                  (ADC_SQR1_REGOFFSET | ADC_REG_RANK_2_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 2 */
N#define LL_ADC_REG_RANK_3                  (ADC_SQR1_REGOFFSET | ADC_REG_RANK_3_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 3 */
N#define LL_ADC_REG_RANK_4                  (ADC_SQR1_REGOFFSET | ADC_REG_RANK_4_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 4 */
N#define LL_ADC_REG_RANK_5                  (ADC_SQR2_REGOFFSET | ADC_REG_RANK_5_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 5 */
N#define LL_ADC_REG_RANK_6                  (ADC_SQR2_REGOFFSET | ADC_REG_RANK_6_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 6 */
N#define LL_ADC_REG_RANK_7                  (ADC_SQR2_REGOFFSET | ADC_REG_RANK_7_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 7 */
N#define LL_ADC_REG_RANK_8                  (ADC_SQR2_REGOFFSET | ADC_REG_RANK_8_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 8 */
N#define LL_ADC_REG_RANK_9                  (ADC_SQR2_REGOFFSET | ADC_REG_RANK_9_SQRX_BITOFFSET_POS)  /*!< ADC group regular sequencer rank 9 */
N#define LL_ADC_REG_RANK_10                 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_10_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 10 */
N#define LL_ADC_REG_RANK_11                 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_11_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 11 */
N#define LL_ADC_REG_RANK_12                 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_12_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 12 */
N#define LL_ADC_REG_RANK_13                 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_13_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 13 */
N#define LL_ADC_REG_RANK_14                 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_14_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 14 */
N#define LL_ADC_REG_RANK_15                 (ADC_SQR4_REGOFFSET | ADC_REG_RANK_15_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 15 */
N#define LL_ADC_REG_RANK_16                 (ADC_SQR4_REGOFFSET | ADC_REG_RANK_16_SQRX_BITOFFSET_POS) /*!< ADC group regular sequencer rank 16 */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_TRIGGER_SOURCE  ADC group injected - Trigger source
N  * @{
N  */
N#define LL_ADC_INJ_TRIG_SOFTWARE           (0x00000000U)                                                                                                       /*!< ADC group injected conversion trigger internal: SW start.. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM1_TRGO      (ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                                                                     /*!< ADC group injected conversion trigger from external IP: TIM1 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2     (ADC_JSQR_JEXTSEL_3 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                                                /*!< ADC group injected conversion trigger from external IP: TIM1 TRGO2. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM1_CH4       (ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                                                /*!< ADC group injected conversion trigger from external IP: TIM1 channel 4 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM2_TRGO      (ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                                                /*!< ADC group injected conversion trigger from external IP: TIM2 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM2_CH1       (ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group injected conversion trigger from external IP: TIM2 channel 1 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM3_TRGO      (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group injected conversion trigger from external IP: TIM3 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM3_CH1       (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group injected conversion trigger from external IP: TIM3 channel 1 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM3_CH3       (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group injected conversion trigger from external IP: TIM3 channel 3 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM3_CH4       (ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                                                /*!< ADC group injected conversion trigger from external IP: TIM3 channel 4 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM4_TRGO      (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group injected conversion trigger from external IP: TIM4 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM6_TRGO      (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group injected conversion trigger from external IP: TIM6 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM8_CH4       (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                      /*!< ADC group injected conversion trigger from external IP: TIM8 channel 4 event (capture compare: input capture or output capture). Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM8_TRGO      (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group injected conversion trigger from external IP: TIM8 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2     (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group injected conversion trigger from external IP: TIM8 TRGO2. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_TIM15_TRGO     (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT) /*!< ADC group injected conversion trigger from external IP: TIM15 TRGO. Trigger edge set to rising edge (default setting). */
N#define LL_ADC_INJ_TRIG_EXT_EXTI_LINE15    (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)                                           /*!< ADC group injected conversion trigger from external IP: external interrupt line 15. Trigger edge set to rising edge (default setting). */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_TRIGGER_EDGE  ADC group injected - Trigger edge
N  * @{
N  */
N#define LL_ADC_INJ_TRIG_EXT_RISING         (                    ADC_JSQR_JEXTEN_0) /*!< ADC group injected conversion trigger polarity set to rising edge */
N#define LL_ADC_INJ_TRIG_EXT_FALLING        (ADC_JSQR_JEXTEN_1                    ) /*!< ADC group injected conversion trigger polarity set to falling edge */
N#define LL_ADC_INJ_TRIG_EXT_RISINGFALLING  (ADC_JSQR_JEXTEN_1 | ADC_JSQR_JEXTEN_0) /*!< ADC group injected conversion trigger polarity set to both rising and falling edges */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_TRIG_AUTO  ADC group injected - Automatic trigger mode
N* @{
N*/
N#define LL_ADC_INJ_TRIG_INDEPENDENT        (0x00000000U)          /*!< ADC group injected conversion trigger independent. Setting mandatory if ADC group injected injected trigger source is set to an external trigger. */
N#define LL_ADC_INJ_TRIG_FROM_GRP_REGULAR   (ADC_CFGR_JAUTO)       /*!< ADC group injected conversion trigger from ADC group regular. Setting compliant only with group injected trigger source set to SW start, without any further action on  ADC group injected conversion start or stop: in this case, ADC group injected is controlled only from ADC group regular. */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_CONTEXT_QUEUE  ADC group injected - Context queue mode
N  * @{
N  */
N#define LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE (0x00000000U)          /* Group injected sequence context queue is enabled and can contain up to 2 contexts. When all contexts have been processed, the queue maintains the last context active perpetually. */
N#define LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY   (ADC_CFGR_JQM)         /* Group injected sequence context queue is enabled and can contain up to 2 contexts. When all contexts have been processed, the queue is empty and injected group triggers are disabled. */
N#define LL_ADC_INJ_QUEUE_DISABLE               (ADC_CFGR_JQDIS)       /* Group injected sequence context queue is disabled: only 1 sequence can be configured and is active perpetually. */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_SEQ_SCAN_LENGTH  ADC group injected - Sequencer scan length
N  * @{
N  */
N#define LL_ADC_INJ_SEQ_SCAN_DISABLE        (0x00000000U)                   /*!< ADC group injected sequencer disable (equivalent to sequencer of 1 rank: ADC conversion on only 1 channel) */
N#define LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS  (                ADC_JSQR_JL_0) /*!< ADC group injected sequencer enable with 2 ranks in the sequence */
N#define LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS  (ADC_JSQR_JL_1                ) /*!< ADC group injected sequencer enable with 3 ranks in the sequence */
N#define LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS  (ADC_JSQR_JL_1 | ADC_JSQR_JL_0) /*!< ADC group injected sequencer enable with 4 ranks in the sequence */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_SEQ_DISCONT_MODE  ADC group injected - Sequencer discontinuous mode
N  * @{
N  */
N#define LL_ADC_INJ_SEQ_DISCONT_DISABLE     (0x00000000U)          /*!< ADC group injected sequencer discontinuous mode disable */
N#define LL_ADC_INJ_SEQ_DISCONT_1RANK       (ADC_CFGR_JDISCEN)     /*!< ADC group injected sequencer discontinuous mode enable with sequence interruption every rank */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_INJ_SEQ_RANKS  ADC group injected - Sequencer ranks
N  * @{
N  */
N#define LL_ADC_INJ_RANK_1                  (ADC_JDR1_REGOFFSET | ADC_INJ_RANK_1_JSQR_BITOFFSET_POS) /*!< ADC group injected sequencer rank 1 */
N#define LL_ADC_INJ_RANK_2                  (ADC_JDR2_REGOFFSET | ADC_INJ_RANK_2_JSQR_BITOFFSET_POS) /*!< ADC group injected sequencer rank 2 */
N#define LL_ADC_INJ_RANK_3                  (ADC_JDR3_REGOFFSET | ADC_INJ_RANK_3_JSQR_BITOFFSET_POS) /*!< ADC group injected sequencer rank 3 */
N#define LL_ADC_INJ_RANK_4                  (ADC_JDR4_REGOFFSET | ADC_INJ_RANK_4_JSQR_BITOFFSET_POS) /*!< ADC group injected sequencer rank 4 */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_CHANNEL_SAMPLINGTIME  Channel - Sampling time
N  * @{
N  */
N#define LL_ADC_SAMPLINGTIME_2CYCLES_5      (0x00000000U)                                               /*!< Sampling time 2.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_6CYCLES_5      (                                        ADC_SMPR2_SMP10_0) /*!< Sampling time 6.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_12CYCLES_5     (                    ADC_SMPR2_SMP10_1                    ) /*!< Sampling time 12.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_24CYCLES_5     (                    ADC_SMPR2_SMP10_1 | ADC_SMPR2_SMP10_0) /*!< Sampling time 24.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_47CYCLES_5     (ADC_SMPR2_SMP10_2                                        ) /*!< Sampling time 47.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_92CYCLES_5     (ADC_SMPR2_SMP10_2                     | ADC_SMPR2_SMP10_0) /*!< Sampling time 92.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_247CYCLES_5    (ADC_SMPR2_SMP10_2 | ADC_SMPR2_SMP10_1                    ) /*!< Sampling time 247.5 ADC clock cycles */
N#define LL_ADC_SAMPLINGTIME_640CYCLES_5    (ADC_SMPR2_SMP10_2 | ADC_SMPR2_SMP10_1 | ADC_SMPR2_SMP10_0) /*!< Sampling time 640.5 ADC clock cycles */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_CHANNEL_SINGLE_DIFF_ENDING  Channel - Single or differential ending
N  * @{
N  */
N#define LL_ADC_SINGLE_ENDED                (                  ADC_CALFACT_CALFACT_S)         /*!< ADC channel ending set to single ended (literal also used to set calibration mode) */
N#define LL_ADC_DIFFERENTIAL_ENDED          (ADC_CR_ADCALDIF | ADC_CALFACT_CALFACT_D)         /*!< ADC channel ending set to differential (literal also used to set calibration mode) */
N#define LL_ADC_BOTH_SINGLE_DIFF_ENDED      (LL_ADC_SINGLE_ENDED | LL_ADC_DIFFERENTIAL_ENDED) /*!< ADC channel ending set to both single ended and differential (literal used only to set calibration factors) */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_AWD_NUMBER Analog watchdog - Analog watchdog number
N  * @{
N  */
N#define LL_ADC_AWD1                        (ADC_AWD_CR1_CHANNEL_MASK  | ADC_AWD_CR1_REGOFFSET) /*!< ADC analog watchdog number 1 */
N#define LL_ADC_AWD2                        (ADC_AWD_CR23_CHANNEL_MASK | ADC_AWD_CR2_REGOFFSET) /*!< ADC analog watchdog number 2 */
N#define LL_ADC_AWD3                        (ADC_AWD_CR23_CHANNEL_MASK | ADC_AWD_CR3_REGOFFSET) /*!< ADC analog watchdog number 3 */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_AWD_CHANNELS  Analog watchdog - Monitored channels
N  * @{
N  */
N#define LL_ADC_AWD_DISABLE                 (0x00000000U)                                                                                       /*!< ADC analog watchdog monitoring disabled */
N#define LL_ADC_AWD_ALL_CHANNELS_REG        (ADC_AWD_CR23_CHANNEL_MASK                                    | ADC_CFGR_AWD1EN                   ) /*!< ADC analog watchdog monitoring of all channels, converted by group regular only */
N#define LL_ADC_AWD_ALL_CHANNELS_INJ        (ADC_AWD_CR23_CHANNEL_MASK                 | ADC_CFGR_JAWD1EN                                     ) /*!< ADC analog watchdog monitoring of all channels, converted by group injected only */
N#define LL_ADC_AWD_ALL_CHANNELS_REG_INJ    (ADC_AWD_CR23_CHANNEL_MASK                 | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN                   ) /*!< ADC analog watchdog monitoring of all channels, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_0_REG           ((LL_ADC_CHANNEL_0  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN0, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_0_INJ           ((LL_ADC_CHANNEL_0  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN0, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_0_REG_INJ       ((LL_ADC_CHANNEL_0  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN0, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_1_REG           ((LL_ADC_CHANNEL_1  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN1, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_1_INJ           ((LL_ADC_CHANNEL_1  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN1, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_1_REG_INJ       ((LL_ADC_CHANNEL_1  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN1, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_2_REG           ((LL_ADC_CHANNEL_2  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN2, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_2_INJ           ((LL_ADC_CHANNEL_2  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN2, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_2_REG_INJ       ((LL_ADC_CHANNEL_2  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN2, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_3_REG           ((LL_ADC_CHANNEL_3  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN3, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_3_INJ           ((LL_ADC_CHANNEL_3  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN3, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_3_REG_INJ       ((LL_ADC_CHANNEL_3  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN3, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_4_REG           ((LL_ADC_CHANNEL_4  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN4, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_4_INJ           ((LL_ADC_CHANNEL_4  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN4, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_4_REG_INJ       ((LL_ADC_CHANNEL_4  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN4, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_5_REG           ((LL_ADC_CHANNEL_5  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN5, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_5_INJ           ((LL_ADC_CHANNEL_5  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN5, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_5_REG_INJ       ((LL_ADC_CHANNEL_5  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN5, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_6_REG           ((LL_ADC_CHANNEL_6  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN6, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_6_INJ           ((LL_ADC_CHANNEL_6  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN6, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_6_REG_INJ       ((LL_ADC_CHANNEL_6  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN6, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_7_REG           ((LL_ADC_CHANNEL_7  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN7, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_7_INJ           ((LL_ADC_CHANNEL_7  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN7, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_7_REG_INJ       ((LL_ADC_CHANNEL_7  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN7, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_8_REG           ((LL_ADC_CHANNEL_8  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN8, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_8_INJ           ((LL_ADC_CHANNEL_8  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN8, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_8_REG_INJ       ((LL_ADC_CHANNEL_8  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN8, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_9_REG           ((LL_ADC_CHANNEL_9  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN9, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_9_INJ           ((LL_ADC_CHANNEL_9  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN9, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_9_REG_INJ       ((LL_ADC_CHANNEL_9  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN9, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_10_REG          ((LL_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN10, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_10_INJ          ((LL_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN10, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_10_REG_INJ      ((LL_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN10, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_11_REG          ((LL_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN11, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_11_INJ          ((LL_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN11, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_11_REG_INJ      ((LL_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN11, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_12_REG          ((LL_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN12, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_12_INJ          ((LL_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN12, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_12_REG_INJ      ((LL_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN12, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_13_REG          ((LL_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN13, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_13_INJ          ((LL_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN13, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_13_REG_INJ      ((LL_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN13, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_14_REG          ((LL_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN14, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_14_INJ          ((LL_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN14, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_14_REG_INJ      ((LL_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN14, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_15_REG          ((LL_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN15, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_15_INJ          ((LL_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN15, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_15_REG_INJ      ((LL_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN15, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_16_REG          ((LL_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN16, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_16_INJ          ((LL_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN16, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_16_REG_INJ      ((LL_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN16, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_17_REG          ((LL_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN17, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_17_INJ          ((LL_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN17, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_17_REG_INJ      ((LL_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN17, converted by either group regular or injected */
N#define LL_ADC_AWD_CHANNEL_18_REG          ((LL_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN18, converted by group regular only */
N#define LL_ADC_AWD_CHANNEL_18_INJ          ((LL_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN18, converted by group injected only */
N#define LL_ADC_AWD_CHANNEL_18_REG_INJ      ((LL_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC external channel (channel connected to GPIO pin) ADCx_IN18, converted by either group regular or injected */
N#define LL_ADC_AWD_CH_VREFINT_REG          ((LL_ADC_CHANNEL_VREFINT       & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to VrefInt: Internal voltage reference, converted by group regular only */
N#define LL_ADC_AWD_CH_VREFINT_INJ          ((LL_ADC_CHANNEL_VREFINT       & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to VrefInt: Internal voltage reference, converted by group injected only */
N#define LL_ADC_AWD_CH_VREFINT_REG_INJ      ((LL_ADC_CHANNEL_VREFINT       & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to VrefInt: Internal voltage reference, converted by either group regular or injected */
N#define LL_ADC_AWD_CH_TEMPSENSOR_REG       ((LL_ADC_CHANNEL_TEMPSENSOR    & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to Temperature sensor, converted by group regular only */
N#define LL_ADC_AWD_CH_TEMPSENSOR_INJ       ((LL_ADC_CHANNEL_TEMPSENSOR    & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to Temperature sensor, converted by group injected only */
N#define LL_ADC_AWD_CH_TEMPSENSOR_REG_INJ   ((LL_ADC_CHANNEL_TEMPSENSOR    & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to Temperature sensor, converted by either group regular or injected */
N#define LL_ADC_AWD_CH_VBAT_REG             ((LL_ADC_CHANNEL_VBAT          & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to Vbat/3: Vbat voltage through a divider ladder of factor 1/3 to have Vbat always below Vdda, converted by group regular only */
N#define LL_ADC_AWD_CH_VBAT_INJ             ((LL_ADC_CHANNEL_VBAT          & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to Vbat/3: Vbat voltage through a divider ladder of factor 1/3 to have Vbat always below Vdda, converted by group injected only */
N#define LL_ADC_AWD_CH_VBAT_REG_INJ         ((LL_ADC_CHANNEL_VBAT          & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to Vbat/3: Vbat voltage through a divider ladder of factor 1/3 to have Vbat always below Vdda */
N#if defined(ADC1) && !defined(ADC2)
X#if 1L && !0L
N#define LL_ADC_AWD_CH_DAC1CH1_REG          ((LL_ADC_CHANNEL_DAC1CH1       & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC1, converted by group regular only */
N#define LL_ADC_AWD_CH_DAC1CH1_INJ          ((LL_ADC_CHANNEL_DAC1CH1       & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC1, converted by group injected only */
N#define LL_ADC_AWD_CH_DAC1CH1_REG_INJ      ((LL_ADC_CHANNEL_DAC1CH1       & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC1, converted by either group regular or injected */
N#define LL_ADC_AWD_CH_DAC1CH2_REG          ((LL_ADC_CHANNEL_DAC1CH2       & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC1, converted by group regular only */
N#define LL_ADC_AWD_CH_DAC1CH2_INJ          ((LL_ADC_CHANNEL_DAC1CH2       & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC1, converted by group injected only */
N#define LL_ADC_AWD_CH_DAC1CH2_REG_INJ      ((LL_ADC_CHANNEL_DAC1CH2       & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC1, converted by either group regular or injected */
N#elif defined(ADC2)
S#define LL_ADC_AWD_CH_DAC1CH1_ADC2_REG     ((LL_ADC_CHANNEL_DAC1CH1_ADC2  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC2, converted by group regular only */
S#define LL_ADC_AWD_CH_DAC1CH1_ADC2_INJ     ((LL_ADC_CHANNEL_DAC1CH1_ADC2  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC2, converted by group injected only */
S#define LL_ADC_AWD_CH_DAC1CH1_ADC2_REG_INJ ((LL_ADC_CHANNEL_DAC1CH1_ADC2  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC2, converted by either group regular or injected */
S#define LL_ADC_AWD_CH_DAC1CH2_ADC2_REG     ((LL_ADC_CHANNEL_DAC1CH2_ADC2  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC2, converted by group regular only */
S#define LL_ADC_AWD_CH_DAC1CH2_ADC2_INJ     ((LL_ADC_CHANNEL_DAC1CH2_ADC2  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC2, converted by group injected only */
S#define LL_ADC_AWD_CH_DAC1CH2_ADC2_REG_INJ ((LL_ADC_CHANNEL_DAC1CH2_ADC2  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC2, converted by either group regular or injected */
S#if defined(ADC3)
S#define LL_ADC_AWD_CH_DAC1CH1_ADC3_REG     ((LL_ADC_CHANNEL_DAC1CH1_ADC3  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC3, converted by group regular only */
S#define LL_ADC_AWD_CH_DAC1CH1_ADC3_INJ     ((LL_ADC_CHANNEL_DAC1CH1_ADC3  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC3, converted by group injected only */
S#define LL_ADC_AWD_CH_DAC1CH1_ADC3_REG_INJ ((LL_ADC_CHANNEL_DAC1CH1_ADC3  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC3, converted by either group regular or injected */
S#define LL_ADC_AWD_CH_DAC1CH2_ADC3_REG     ((LL_ADC_CHANNEL_DAC1CH2_ADC3  & ADC_CHANNEL_ID_MASK)                    | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC3, converted by group regular only */
S#define LL_ADC_AWD_CH_DAC1CH2_ADC3_INJ     ((LL_ADC_CHANNEL_DAC1CH2_ADC3  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN                   | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC3, converted by group injected only */
S#define LL_ADC_AWD_CH_DAC1CH2_ADC3_REG_INJ ((LL_ADC_CHANNEL_DAC1CH2_ADC3  & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) /*!< ADC analog watchdog monitoring of ADC internal channel connected to DAC1 channel 1, channel specific to ADC3, converted by either group regular or injected */
S#endif
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_AWD_THRESHOLDS  Analog watchdog - Thresholds
N  * @{
N  */
N#define LL_ADC_AWD_THRESHOLD_HIGH          (ADC_TR1_HT1              ) /*!< ADC analog watchdog threshold high */
N#define LL_ADC_AWD_THRESHOLD_LOW           (              ADC_TR1_LT1) /*!< ADC analog watchdog threshold low */
N#define LL_ADC_AWD_THRESHOLDS_HIGH_LOW     (ADC_TR1_HT1 | ADC_TR1_LT1) /*!< ADC analog watchdog both thresholds high and low concatenated into the same data */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_OVS_SCOPE  Oversampling - Oversampling scope
N  * @{
N  */
N#define LL_ADC_OVS_DISABLE                 (0x00000000U)                                         /*!< ADC oversampling disabled. */
N#define LL_ADC_OVS_GRP_REGULAR_CONTINUED   (                                    ADC_CFGR2_ROVSE) /*!< ADC oversampling on conversions of ADC group regular. If group injected interrupts group regular: when ADC group injected is triggered, the oversampling on ADC group regular is temporary stopped and continued afterwards. */
N#define LL_ADC_OVS_GRP_REGULAR_RESUMED     (ADC_CFGR2_ROVSM |                   ADC_CFGR2_ROVSE) /*!< ADC oversampling on conversions of ADC group regular. If group injected interrupts group regular: when ADC group injected is triggered, the oversampling on ADC group regular is resumed from start (oversampler buffer reset). */
N#define LL_ADC_OVS_GRP_INJECTED            (                  ADC_CFGR2_JOVSE                  ) /*!< ADC oversampling on conversions of ADC group injected. */
N#define LL_ADC_OVS_GRP_INJ_REG_RESUMED     (                  ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSE) /*!< ADC oversampling on conversions of both ADC groups regular and injected. If group injected interrupting group regular: when ADC group injected is triggered, the oversampling on ADC group regular is resumed from start (oversampler buffer reset). */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_OVS_DISCONT_MODE  Oversampling - Discontinuous mode
N  * @{
N  */
N#define LL_ADC_OVS_REG_CONT                (0x00000000U)          /*!< ADC oversampling discontinuous mode: continuous mode (all conversions of oversampling ratio are done from 1 trigger) */
N#define LL_ADC_OVS_REG_DISCONT             (ADC_CFGR2_TROVS)      /*!< ADC oversampling discontinuous mode: discontinuous mode (each conversion of oversampling ratio needs a trigger) */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_OVS_RATIO  Oversampling - Ratio
N  * @{
N  */
N#define LL_ADC_OVS_RATIO_2                 (0x00000000U)                                            /*!< ADC oversampling ratio of 2 (2 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_4                 (                                      ADC_CFGR2_OVSR_0) /*!< ADC oversampling ratio of 4 (4 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_8                 (                   ADC_CFGR2_OVSR_1                   ) /*!< ADC oversampling ratio of 8 (8 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_16                (                   ADC_CFGR2_OVSR_1 | ADC_CFGR2_OVSR_0) /*!< ADC oversampling ratio of 16 (16 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_32                (ADC_CFGR2_OVSR_2                                      ) /*!< ADC oversampling ratio of 32 (32 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_64                (ADC_CFGR2_OVSR_2                    | ADC_CFGR2_OVSR_0) /*!< ADC oversampling ratio of 64 (64 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_128               (ADC_CFGR2_OVSR_2 | ADC_CFGR2_OVSR_1                   ) /*!< ADC oversampling ratio of 128 (128 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N#define LL_ADC_OVS_RATIO_256               (ADC_CFGR2_OVSR_2 | ADC_CFGR2_OVSR_1 | ADC_CFGR2_OVSR_0) /*!< ADC oversampling ratio of 256 (256 ADC conversions are performed, sum of these conversions data is computed to result as the ADC oversampling conversion data (before potential shift) */
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EC_OVS_SHIFT  Oversampling - Data shift
N  * @{
N  */
N#define LL_ADC_OVS_SHIFT_NONE              (0x00000000U)                                                               /*!< ADC oversampling no shift (sum of the ADC conversions data is not divided to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_1           (                                                         ADC_CFGR2_OVSS_0) /*!< ADC oversampling shift of 1 (sum of the ADC conversions data is divided by 2 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_2           (                                      ADC_CFGR2_OVSS_1                   ) /*!< ADC oversampling shift of 2 (sum of the ADC conversions data is divided by 4 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_3           (                                      ADC_CFGR2_OVSS_1 | ADC_CFGR2_OVSS_0) /*!< ADC oversampling shift of 3 (sum of the ADC conversions data is divided by 8 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_4           (                   ADC_CFGR2_OVSS_2                                      ) /*!< ADC oversampling shift of 4 (sum of the ADC conversions data is divided by 16 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_5           (                   ADC_CFGR2_OVSS_2                    | ADC_CFGR2_OVSS_0) /*!< ADC oversampling shift of 5 (sum of the ADC conversions data is divided by 32 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_6           (                   ADC_CFGR2_OVSS_2 | ADC_CFGR2_OVSS_1                   ) /*!< ADC oversampling shift of 6 (sum of the ADC conversions data is divided by 64 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_7           (                   ADC_CFGR2_OVSS_2 | ADC_CFGR2_OVSS_1 | ADC_CFGR2_OVSS_0) /*!< ADC oversampling shift of 7 (sum of the ADC conversions data is divided by 128 to result as the ADC oversampling conversion data) */
N#define LL_ADC_OVS_SHIFT_RIGHT_8           (ADC_CFGR2_OVSS_3                                                         ) /*!< ADC oversampling shift of 8 (sum of the ADC conversions data is divided by 256 to result as the ADC oversampling conversion data) */
N/**
N  * @}
N  */
N
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S/** @defgroup ADC_LL_EC_MULTI_MODE  Multimode - Mode
S  * @{
S  */
S#define LL_ADC_MULTI_INDEPENDENT           (0x00000000U)                                                       /*!< ADC dual mode disabled (ADC independent mode) */
S#define LL_ADC_MULTI_DUAL_REG_SIMULT       (                 ADC_CCR_DUAL_2 | ADC_CCR_DUAL_1                 ) /*!< ADC dual mode enabled: group regular simultaneous */
S#define LL_ADC_MULTI_DUAL_REG_INTERL       (                 ADC_CCR_DUAL_2 | ADC_CCR_DUAL_1 | ADC_CCR_DUAL_0) /*!< ADC dual mode enabled: Combined group regular interleaved */
S#define LL_ADC_MULTI_DUAL_INJ_SIMULT       (                 ADC_CCR_DUAL_2                  | ADC_CCR_DUAL_0) /*!< ADC dual mode enabled: group injected simultaneous */
S#define LL_ADC_MULTI_DUAL_INJ_ALTERN       (ADC_CCR_DUAL_3                                   | ADC_CCR_DUAL_0) /*!< ADC dual mode enabled: group injected alternate trigger. Works only with external triggers (not internal SW start) */
S#define LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM  (                                                   ADC_CCR_DUAL_0) /*!< ADC dual mode enabled: Combined group regular simultaneous + group injected simultaneous */
S#define LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT  (                                  ADC_CCR_DUAL_1                 ) /*!< ADC dual mode enabled: Combined group regular simultaneous + group injected alternate trigger */
S#define LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM  (                                  ADC_CCR_DUAL_1 | ADC_CCR_DUAL_0) /*!< ADC dual mode enabled: Combined group regular interleaved + group injected simultaneous */
S/**
S  * @}
S  */
S
S/** @defgroup ADC_LL_EC_MULTI_DMA_TRANSFER  Multimode - DMA transfer
S  * @{
S  */
S#define LL_ADC_MULTI_REG_DMA_EACH_ADC        (0x00000000U)                                      /*!< ADC multimode group regular conversions are transferred by DMA: each ADC uses its own DMA channel, with its individual DMA transfer settings */
S#define LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B (                 ADC_CCR_MDMA_1                 ) /*!< ADC multimode group regular conversions are transferred by DMA, one DMA channel for both ADC (DMA of ADC master), in limited mode (one shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular. Setting for ADC resolution of 12 and 10 bits */
S#define LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B   (                 ADC_CCR_MDMA_1 | ADC_CCR_MDMA_0) /*!< ADC multimode group regular conversions are transferred by DMA, one DMA channel for both ADC (DMA of ADC master), in limited mode (one shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular. Setting for ADC resolution of 8 and 6 bits */
S#define LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B (ADC_CCR_DMACFG | ADC_CCR_MDMA_1                 ) /*!< ADC multimode group regular conversions are transferred by DMA, one DMA channel for both ADC (DMA of ADC master), in unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transferred (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. Setting for ADC resolution of 12 and 10 bits */
S#define LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B   (ADC_CCR_DMACFG | ADC_CCR_MDMA_1 | ADC_CCR_MDMA_0) /*!< ADC multimode group regular conversions are transferred by DMA, one DMA channel for both ADC (DMA of ADC master), in unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transferred (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. Setting for ADC resolution of 8 and 6 bits */
S/**
S  * @}
S  */
S
S/** @defgroup ADC_LL_EC_MULTI_TWOSMP_DELAY  Multimode - Delay between two sampling phases
S  * @{
S  */
S#define LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE   (0x00000000U)                                                           /*!< ADC multimode delay between two sampling phases: 1 ADC clock cycle */
S#define LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES  (                                                      ADC_CCR_DELAY_0) /*!< ADC multimode delay between two sampling phases: 2 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES  (                                    ADC_CCR_DELAY_1                  ) /*!< ADC multimode delay between two sampling phases: 3 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES  (                                    ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0) /*!< ADC multimode delay between two sampling phases: 4 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES  (                  ADC_CCR_DELAY_2                                    ) /*!< ADC multimode delay between two sampling phases: 5 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES  (                  ADC_CCR_DELAY_2                   | ADC_CCR_DELAY_0) /*!< ADC multimode delay between two sampling phases: 6 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES  (                  ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1                  ) /*!< ADC multimode delay between two sampling phases: 7 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES  (                  ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0) /*!< ADC multimode delay between two sampling phases: 8 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES  (ADC_CCR_DELAY_3                                                      ) /*!< ADC multimode delay between two sampling phases: 9 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES (ADC_CCR_DELAY_3                                     | ADC_CCR_DELAY_0) /*!< ADC multimode delay between two sampling phases: 10 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES (ADC_CCR_DELAY_3                   | ADC_CCR_DELAY_1                  ) /*!< ADC multimode delay between two sampling phases: 11 ADC clock cycles */
S#define LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES (ADC_CCR_DELAY_3                   | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0) /*!< ADC multimode delay between two sampling phases: 12 ADC clock cycles */
S/**
S  * @}
S  */
S
S/** @defgroup ADC_LL_EC_MULTI_MASTER_SLAVE  Multimode - ADC master or slave
S  * @{
S  */
S#define LL_ADC_MULTI_MASTER                (                    ADC_CDR_RDATA_MST) /*!< In multimode, selection among several ADC instances: ADC master */
S#define LL_ADC_MULTI_SLAVE                 (ADC_CDR_RDATA_SLV                    ) /*!< In multimode, selection among several ADC instances: ADC slave */
S#define LL_ADC_MULTI_MASTER_SLAVE          (ADC_CDR_RDATA_SLV | ADC_CDR_RDATA_MST) /*!< In multimode, selection among several ADC instances: both ADC master and ADC slave */
S/**
S  * @}
S  */
S
N#endif /* ADC_MULTIMODE_SUPPORT */
N
N/** @defgroup ADC_LL_EC_LEGACY ADC literals legacy naming
N  * @{
N  */
N#define LL_ADC_REG_TRIG_SW_START           (LL_ADC_REG_TRIG_SOFTWARE)
N#define LL_ADC_REG_TRIG_EXT_TIM1_CC1       (LL_ADC_REG_TRIG_EXT_TIM1_CH1)
N#define LL_ADC_REG_TRIG_EXT_TIM1_CC2       (LL_ADC_REG_TRIG_EXT_TIM1_CH2)
N#define LL_ADC_REG_TRIG_EXT_TIM1_CC3       (LL_ADC_REG_TRIG_EXT_TIM1_CH3)
N#define LL_ADC_REG_TRIG_EXT_TIM2_CC2       (LL_ADC_REG_TRIG_EXT_TIM2_CH2)
N#define LL_ADC_REG_TRIG_EXT_TIM3_CC4       (LL_ADC_REG_TRIG_EXT_TIM3_CH4)
N#define LL_ADC_REG_TRIG_EXT_TIM4_CC4       (LL_ADC_REG_TRIG_EXT_TIM4_CH4)
N
N#define LL_ADC_INJ_TRIG_SW_START           (LL_ADC_INJ_TRIG_SOFTWARE)
N#define LL_ADC_INJ_TRIG_EXT_TIM1_CC4       (LL_ADC_INJ_TRIG_EXT_TIM1_CH4)
N#define LL_ADC_INJ_TRIG_EXT_TIM2_CC1       (LL_ADC_INJ_TRIG_EXT_TIM2_CH1)
N#define LL_ADC_INJ_TRIG_EXT_TIM3_CC1       (LL_ADC_INJ_TRIG_EXT_TIM3_CH1)
N#define LL_ADC_INJ_TRIG_EXT_TIM3_CC3       (LL_ADC_INJ_TRIG_EXT_TIM3_CH3)
N#define LL_ADC_INJ_TRIG_EXT_TIM3_CC4       (LL_ADC_INJ_TRIG_EXT_TIM3_CH4)
N#define LL_ADC_INJ_TRIG_EXT_TIM8_CC4       (LL_ADC_INJ_TRIG_EXT_TIM8_CH4)
N
N#define LL_ADC_OVS_DATA_SHIFT_NONE        (LL_ADC_OVS_SHIFT_NONE)
N#define LL_ADC_OVS_DATA_SHIFT_1           (LL_ADC_OVS_SHIFT_RIGHT_1)
N#define LL_ADC_OVS_DATA_SHIFT_2           (LL_ADC_OVS_SHIFT_RIGHT_2)
N#define LL_ADC_OVS_DATA_SHIFT_3           (LL_ADC_OVS_SHIFT_RIGHT_3)
N#define LL_ADC_OVS_DATA_SHIFT_4           (LL_ADC_OVS_SHIFT_RIGHT_4)
N#define LL_ADC_OVS_DATA_SHIFT_5           (LL_ADC_OVS_SHIFT_RIGHT_5)
N#define LL_ADC_OVS_DATA_SHIFT_6           (LL_ADC_OVS_SHIFT_RIGHT_6)
N#define LL_ADC_OVS_DATA_SHIFT_7           (LL_ADC_OVS_SHIFT_RIGHT_7)
N#define LL_ADC_OVS_DATA_SHIFT_8           (LL_ADC_OVS_SHIFT_RIGHT_8)
N
N/**
N  * @}
N  */
N
N
N/** @defgroup ADC_LL_EC_HW_DELAYS  Definitions of ADC hardware constraints delays
N  * @note   Only ADC IP HW delays are defined in ADC LL driver driver,
N  *         not timeout values.
N  *         For details on delays values, refer to descriptions in source code
N  *         above each literal definition.
N  * @{
N  */
N  
N/* Note: Only ADC IP HW delays are defined in ADC LL driver driver,           */
N/*       not timeout values.                                                  */
N/*       Timeout values for ADC operations are dependent to device clock      */
N/*       configuration (system clock versus ADC clock),                       */
N/*       and therefore must be defined in user application.                   */
N/*       Indications for estimation of ADC timeout delays, for this           */
N/*       STM32 serie:                                                         */
N/*       - ADC calibration time: maximum delay is 112/fADC.                   */
N/*         (refer to device datasheet, parameter "tCAL")                      */
N/*       - ADC enable time: maximum delay is 1 conversion cycle.              */
N/*         (refer to device datasheet, parameter "tSTAB")                     */
N/*       - ADC disable time: maximum delay should be a few ADC clock cycles   */
N/*       - ADC stop conversion time: maximum delay should be a few ADC clock  */
N/*         cycles                                                             */
N/*       - ADC conversion time: duration depending on ADC clock and ADC       */
N/*         configuration.                                                     */
N/*         (refer to device reference manual, section "Timing")               */
N
N/* Delay for ADC stabilization time (ADC voltage regulator start-up time)     */
N/* Delay set to maximum value (refer to device datasheet,                     */
N/* parameter "tADCVREG_STUP").                                                */
N/* Unit: us                                                                   */
N#define LL_ADC_DELAY_INTERNAL_REGUL_STAB_US (  10U)  /*!< Delay for ADC stabilization time (ADC voltage regulator start-up time) */
N
N/* Delay for internal voltage reference stabilization time.                   */
N/* Delay set to maximum value (refer to device datasheet,                     */
N/* parameter "tstart_vrefint").                                               */
N/* Unit: us                                                                   */
N#define LL_ADC_DELAY_VREFINT_STAB_US       (  12U)  /*!< Delay for internal voltage reference stabilization time */
N
N/* Delay for temperature sensor stabilization time.                           */
N/* Literal set to maximum value (refer to device datasheet,                   */
N/* parameter "tSTART").                                                       */
N/* Unit: us                                                                   */
N#define LL_ADC_DELAY_TEMPSENSOR_STAB_US    ( 120U)  /*!< Delay for temperature sensor stabilization time */
N
N/* Delay required between ADC end of calibration and ADC enable.              */
N/* Note: On this STM32 serie, a minimum number of ADC clock cycles            */
N/*       are required between ADC end of calibration and ADC enable.          */
N/*       Wait time can be computed in user application by waiting for the     */
N/*       equivalent number of CPU cycles, by taking into account              */
N/*       ratio of CPU clock versus ADC clock prescalers.                      */
N/* Unit: ADC clock cycles.                                                    */
N#define LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES ( 4U)  /*!< Delay required between ADC end of calibration and ADC enable */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ADC_LL_Exported_Macros ADC Exported Macros
N  * @{
N  */
N
N/** @defgroup ADC_LL_EM_WRITE_READ Common write and read registers Macros
N  * @{
N  */
N
N/**
N  * @brief  Write a value in ADC register
N  * @param  __INSTANCE__ ADC Instance
N  * @param  __REG__ Register to be written
N  * @param  __VALUE__ Value to be written in the register
N  * @retval None
N  */
N#define LL_ADC_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
N
N/**
N  * @brief  Read a value in ADC register
N  * @param  __INSTANCE__ ADC Instance
N  * @param  __REG__ Register to be read
N  * @retval Register value
N  */
N#define LL_ADC_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EM_HELPER_MACRO ADC helper macro
N  * @{
N  */
N
N/**
N  * @brief  Helper macro to get ADC channel number in decimal format
N  *         from literals LL_ADC_CHANNEL_x.
N  * @note   Example:
N  *           __LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_CHANNEL_4)
N  *           will return decimal number "4".
N  * @note   The input can be a value from functions where a channel
N  *         number is returned, either defined with number
N  *         or with bitfield (only one bit must be set).
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval Value between Min_Data=0 and Max_Data=18
N  */
N#define __LL_ADC_CHANNEL_TO_DECIMAL_NB(__CHANNEL__)                                        \
N  ((((__CHANNEL__) & ADC_CHANNEL_ID_BITFIELD_MASK) == 0U)                                  \
N    ? (                                                                                    \
N       ((__CHANNEL__) & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS \
N      )                                                                                    \
N      :                                                                                    \
N      (                                                                                    \
N       POSITION_VAL((__CHANNEL__))                                                         \
N      )                                                                                    \
N  )
X#define __LL_ADC_CHANNEL_TO_DECIMAL_NB(__CHANNEL__)                                          ((((__CHANNEL__) & ADC_CHANNEL_ID_BITFIELD_MASK) == 0U)                                      ? (                                                                                           ((__CHANNEL__) & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS       )                                                                                          :                                                                                          (                                                                                           POSITION_VAL((__CHANNEL__))                                                               )                                                                                      )
N
N/**
N  * @brief  Helper macro to get ADC channel in literal format LL_ADC_CHANNEL_x
N  *         from number in decimal format.
N  * @note   Example:
N  *           __LL_ADC_DECIMAL_NB_TO_CHANNEL(4)
N  *           will return a data equivalent to "LL_ADC_CHANNEL_4".
N  * @param  __DECIMAL_NB__ Value between Min_Data=0 and Max_Data=18
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).\n
N  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
N  *                      comparison with internal channel parameter to be done
N  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  */
N#define __LL_ADC_DECIMAL_NB_TO_CHANNEL(__DECIMAL_NB__)                                                          \
N  (((__DECIMAL_NB__) <= 9U)                                                                                     \
N    ? (                                                                                                         \
N       ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)                                       |        \
N       (ADC_AWD2CR_AWD2CH_0 << (__DECIMAL_NB__))                                                       |        \
N       (ADC_SMPR1_REGOFFSET | (((uint32_t) (3U * (__DECIMAL_NB__))) << ADC_CHANNEL_SMPx_BITOFFSET_POS))         \
N      )                                                                                                         \
N      :                                                                                                         \
N      (                                                                                                         \
N       ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)                                              | \
N       (ADC_AWD2CR_AWD2CH_0 << (__DECIMAL_NB__))                                                              | \
N       (ADC_SMPR2_REGOFFSET | (((uint32_t) (3U * ((__DECIMAL_NB__) - 10U))) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) \
N      )                                                                                                         \
N  )
X#define __LL_ADC_DECIMAL_NB_TO_CHANNEL(__DECIMAL_NB__)                                                            (((__DECIMAL_NB__) <= 9U)                                                                                         ? (                                                                                                                ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)                                       |               (ADC_AWD2CR_AWD2CH_0 << (__DECIMAL_NB__))                                                       |               (ADC_SMPR1_REGOFFSET | (((uint32_t) (3U * (__DECIMAL_NB__))) << ADC_CHANNEL_SMPx_BITOFFSET_POS))               )                                                                                                               :                                                                                                               (                                                                                                                ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)                                              |        (ADC_AWD2CR_AWD2CH_0 << (__DECIMAL_NB__))                                                              |        (ADC_SMPR2_REGOFFSET | (((uint32_t) (3U * ((__DECIMAL_NB__) - 10U))) << ADC_CHANNEL_SMPx_BITOFFSET_POS))       )                                                                                                           )
N
N/**
N  * @brief  Helper macro to determine whether the selected channel
N  *         corresponds to literal definitions of driver.
N  * @note   The different literal definitions of ADC channels are:
N  *         - ADC internal channel:
N  *           LL_ADC_CHANNEL_VREFINT, LL_ADC_CHANNEL_TEMPSENSOR, ...
N  *         - ADC external channel (channel connected to a GPIO pin):
N  *           LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...
N  * @note   The channel parameter must be a value defined from literal
N  *         definition of a ADC internal channel (LL_ADC_CHANNEL_VREFINT,
N  *         LL_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         ADC external channel (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...),
N  *         must not be a value from functions where a channel number is
N  *         returned from ADC registers,
N  *         because internal and external channels share the same channel
N  *         number in ADC registers. The differentiation is made only with
N  *         parameters definitions of driver.
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval Value "0" if the channel corresponds to a parameter definition of a ADC external channel (channel connected to a GPIO pin).
N  *         Value "1" if the channel corresponds to a parameter definition of a ADC internal channel.
N  */
N#define __LL_ADC_IS_CHANNEL_INTERNAL(__CHANNEL__)                              \
N  (((__CHANNEL__) & ADC_CHANNEL_ID_INTERNAL_CH_MASK) != 0U)
X#define __LL_ADC_IS_CHANNEL_INTERNAL(__CHANNEL__)                                (((__CHANNEL__) & ADC_CHANNEL_ID_INTERNAL_CH_MASK) != 0U)
N
N/**
N  * @brief  Helper macro to convert a channel defined from parameter
N  *         definition of a ADC internal channel (LL_ADC_CHANNEL_VREFINT,
N  *         LL_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         to its equivalent parameter definition of a ADC external channel
N  *         (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...).
N  * @note   The channel parameter can be, additionally to a value
N  *         defined from parameter definition of a ADC internal channel
N  *         (LL_ADC_CHANNEL_VREFINT, LL_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         a value defined from parameter definition of
N  *         ADC external channel (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...)
N  *         or a value from functions where a channel number is returned
N  *         from ADC registers.
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1
N  *         @arg @ref LL_ADC_CHANNEL_2
N  *         @arg @ref LL_ADC_CHANNEL_3
N  *         @arg @ref LL_ADC_CHANNEL_4
N  *         @arg @ref LL_ADC_CHANNEL_5
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  */
N#define __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(__CHANNEL__)                     \
N  ((__CHANNEL__) & ~ADC_CHANNEL_ID_INTERNAL_CH_MASK)
X#define __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(__CHANNEL__)                       ((__CHANNEL__) & ~ADC_CHANNEL_ID_INTERNAL_CH_MASK)
N
N/**
N  * @brief  Helper macro to determine whether the internal channel
N  *         selected is available on the ADC instance selected.
N  * @note   The channel parameter must be a value defined from parameter
N  *         definition of a ADC internal channel (LL_ADC_CHANNEL_VREFINT,
N  *         LL_ADC_CHANNEL_TEMPSENSOR, ...),
N  *         must not be a value defined from parameter definition of
N  *         ADC external channel (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...)
N  *         or a value from functions where a channel number is
N  *         returned from ADC registers,
N  *         because internal and external channels share the same channel
N  *         number in ADC registers. The differentiation is made only with
N  *         parameters definitions of driver.
N  * @param  __ADC_INSTANCE__ ADC instance
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.
N  * @retval Value "0" if the internal channel selected is not available on the ADC instance selected.
N  *         Value "1" if the internal channel selected is available on the ADC instance selected.
N  */
N#if defined (ADC1) && defined (ADC2) && defined (ADC3)
X#if 1L && 0L && 0L
S#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)  \
S  (((__ADC_INSTANCE__) == ADC1)                                                \
S    ? (                                                                        \
S       ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)    ||                         \
S       ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR) ||                         \
S       ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)                                  \
S      )                                                                        \
S      :                                                                        \
S      ((__ADC_INSTANCE__) == ADC2)                                             \
S      ? (                                                                      \
S         ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)      ||                     \
S         ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1_ADC2) ||                     \
S         ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2_ADC2)                        \
S        )                                                                      \
S        :                                                                      \
S        ((__ADC_INSTANCE__) == ADC3)                                           \
S        ? (                                                                    \
S           ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)      ||                   \
S           ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR)   ||                   \
S           ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)         ||                   \
S           ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1_ADC3) ||                   \
S           ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2_ADC3)                      \
S          )                                                                    \
S          :                                                                    \
S          (0U)                                                                 \
S  )
X#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)    (((__ADC_INSTANCE__) == ADC1)                                                    ? (                                                                               ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)    ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR) ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)                                        )                                                                              :                                                                              ((__ADC_INSTANCE__) == ADC2)                                                   ? (                                                                               ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)      ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1_ADC2) ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2_ADC2)                                )                                                                              :                                                                              ((__ADC_INSTANCE__) == ADC3)                                                   ? (                                                                               ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)      ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR)   ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)         ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1_ADC3) ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2_ADC3)                                )                                                                              :                                                                              (0U)                                                                   )
S#elif defined (ADC1) && defined (ADC2)
X#elif 1L && 0L
S#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)  \
S  (((__ADC_INSTANCE__) == ADC1)                                                \
S    ? (                                                                        \
S       ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)    ||                         \
S       ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR) ||                         \
S       ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)                                  \
S      )                                                                        \
S      :                                                                        \
S      ((__ADC_INSTANCE__) == ADC2)                                             \
S      ? (                                                                      \
S         ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)      ||                     \
S         ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1_ADC2) ||                     \
S         ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2_ADC2)                        \
S        )                                                                      \
S        :                                                                      \
S        (0U)                                                                   \
S  )
X#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)    (((__ADC_INSTANCE__) == ADC1)                                                    ? (                                                                               ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)    ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR) ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)                                        )                                                                              :                                                                              ((__ADC_INSTANCE__) == ADC2)                                                   ? (                                                                               ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)      ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1_ADC2) ||                              ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2_ADC2)                                )                                                                              :                                                                              (0U)                                                                     )
N#elif defined (ADC1)
X#elif 1L
N#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)  \
N  (                                                                            \
N    ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)    ||                            \
N    ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR) ||                            \
N    ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)       ||                            \
N    ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1)    ||                            \
N    ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2)                                  \
N  )
X#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__, __CHANNEL__)    (                                                                                ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT)    ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR) ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT)       ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH1)    ||                                ((__CHANNEL__) == LL_ADC_CHANNEL_DAC1CH2)                                    )
N#endif
N
N/**
N  * @brief  Helper macro to define ADC analog watchdog parameter:
N  *         define a single channel to monitor with analog watchdog
N  *         from sequencer channel and groups definition.
N  * @note   To be used with function @ref LL_ADC_SetAnalogWDMonitChannels().
N  *         Example:
N  *           LL_ADC_SetAnalogWDMonitChannels(
N  *             ADC1, LL_ADC_AWD1,
N  *             __LL_ADC_ANALOGWD_CHANNEL_GROUP(LL_ADC_CHANNEL4, LL_ADC_GROUP_REGULAR))
N  * @param  __CHANNEL__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).\n
N  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
N  *                      comparison with internal channel parameter to be done
N  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  * @param  __GROUP__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_GROUP_REGULAR
N  *         @arg @ref LL_ADC_GROUP_INJECTED
N  *         @arg @ref LL_ADC_GROUP_REGULAR_INJECTED
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_AWD_DISABLE
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG        (0)
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_INJ        (0)
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG          (0)(1)
N  *         @arg @ref LL_ADC_AWD_CH_VREFINT_INJ          (0)(1)
N  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG_INJ         (1)
N  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_REG       (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_INJ       (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_REG_INJ      (4)
N  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG             (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_VBAT_INJ             (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG_INJ            (4)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_REG          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_INJ          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_REG_INJ         (2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_REG          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_INJ          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_REG_INJ         (2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC2_REG     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC2_INJ     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC2_REG_INJ    (2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC2_REG     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC2_INJ     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC2_REG_INJ    (2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC3_REG     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC3_INJ     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC3_REG_INJ    (3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC3_REG     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC3_INJ     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC3_REG_INJ    (3)(6)
N  *         
N  *         (0) On STM32L4, parameter available only on analog watchdog number: AWD1.\n
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.
N  */
N#define __LL_ADC_ANALOGWD_CHANNEL_GROUP(__CHANNEL__, __GROUP__)                                           \
N  (((__GROUP__) == LL_ADC_GROUP_REGULAR)                                                                  \
N    ? (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)                        \
N      :                                                                                                   \
N      ((__GROUP__) == LL_ADC_GROUP_INJECTED)                                                              \
N       ? (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)                    \
N         :                                                                                                \
N         (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)  \
N  )
X#define __LL_ADC_ANALOGWD_CHANNEL_GROUP(__CHANNEL__, __GROUP__)                                             (((__GROUP__) == LL_ADC_GROUP_REGULAR)                                                                      ? (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)                              :                                                                                                         ((__GROUP__) == LL_ADC_GROUP_INJECTED)                                                                     ? (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)                             :                                                                                                         (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)    )
N
N/**
N  * @brief  Helper macro to set the value of ADC analog watchdog threshold high
N  *         or low in function of ADC resolution, when ADC resolution is
N  *         different of 12 bits.
N  * @note   To be used with function @ref LL_ADC_ConfigAnalogWDThresholds()
N  *         or @ref LL_ADC_SetAnalogWDThresholds().
N  *         Example, with a ADC resolution of 8 bits, to set the value of
N  *         analog watchdog threshold high (on 8 bits):
N  *           LL_ADC_SetAnalogWDThresholds
N  *            (< ADCx param >,
N  *             __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(LL_ADC_RESOLUTION_8B, <threshold_value_8_bits>)
N  *            );
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @param  __AWD_THRESHOLD__ Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N#define __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD__) \
N  ((__AWD_THRESHOLD__) << ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U )))
X#define __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD__)   ((__AWD_THRESHOLD__) << ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U )))
N
N/**
N  * @brief  Helper macro to get the value of ADC analog watchdog threshold high
N  *         or low in function of ADC resolution, when ADC resolution is 
N  *         different of 12 bits.
N  * @note   To be used with function @ref LL_ADC_GetAnalogWDThresholds().
N  *         Example, with a ADC resolution of 8 bits, to get the value of
N  *         analog watchdog threshold high (on 8 bits):
N  *           < threshold_value_6_bits > = __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION
N  *            (LL_ADC_RESOLUTION_8B,
N  *             LL_ADC_GetAnalogWDThresholds(<ADCx param>, LL_ADC_AWD_THRESHOLD_HIGH)
N  *            );
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @param  __AWD_THRESHOLD_12_BITS__ Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N#define __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD_12_BITS__) \
N  ((__AWD_THRESHOLD_12_BITS__) >> ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U )))
X#define __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__, __AWD_THRESHOLD_12_BITS__)   ((__AWD_THRESHOLD_12_BITS__) >> ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U )))
N
N/**
N  * @brief  Helper macro to get the ADC analog watchdog threshold high
N  *         or low from raw value containing both thresholds concatenated.
N  * @note   To be used with function @ref LL_ADC_GetAnalogWDThresholds().
N  *         Example, to get analog watchdog threshold high from the register raw value:
N  *           __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(LL_ADC_AWD_THRESHOLD_HIGH, <raw_value_with_both_thresholds>);
N  * @param  __AWD_THRESHOLD_TYPE__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD_THRESHOLD_HIGH
N  *         @arg @ref LL_ADC_AWD_THRESHOLD_LOW
N  * @param  __AWD_THRESHOLDS__ Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__, __AWD_THRESHOLDS__)       \
S  (((__AWD_THRESHOLDS__) >> (((__AWD_THRESHOLD_TYPE__) & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4)) & LL_ADC_AWD_THRESHOLD_LOW)
X#define __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__, __AWD_THRESHOLDS__)         (((__AWD_THRESHOLDS__) >> (((__AWD_THRESHOLD_TYPE__) & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4)) & LL_ADC_AWD_THRESHOLD_LOW)
N#else
N#define __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__, __AWD_THRESHOLDS__)       \
N  (((__AWD_THRESHOLDS__) >> POSITION_VAL((__AWD_THRESHOLD_TYPE__))) & LL_ADC_AWD_THRESHOLD_LOW)
X#define __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__, __AWD_THRESHOLDS__)         (((__AWD_THRESHOLDS__) >> POSITION_VAL((__AWD_THRESHOLD_TYPE__))) & LL_ADC_AWD_THRESHOLD_LOW)
N#endif
N
N/**
N  * @brief  Helper macro to set the ADC calibration value with both single ended
N  *         and differential modes calibration factors concatenated.
N  * @note   To be used with function @ref LL_ADC_SetCalibrationFactor().
N  *         Example, to set calibration factors single ended to 0x55
N  *         and differential ended to 0x2A:
N  *           LL_ADC_SetCalibrationFactor(
N  *             ADC1,
N  *             __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(0x55, 0x2A))
N  * @param  __CALIB_FACTOR_SINGLE_ENDED__ Value between Min_Data=0x00 and Max_Data=0x7F
N  * @param  __CALIB_FACTOR_DIFFERENTIAL__ Value between Min_Data=0x00 and Max_Data=0x7F
N  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
N  */
N#if defined(CORE_CM0PLUS)
X#if 0L
S#define __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(__CALIB_FACTOR_SINGLE_ENDED__, __CALIB_FACTOR_DIFFERENTIAL__)        \
S  (((__CALIB_FACTOR_DIFFERENTIAL__) << ADC_CALFACT_CALFACT_D_Pos) | (__CALIB_FACTOR_SINGLE_ENDED__))
X#define __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(__CALIB_FACTOR_SINGLE_ENDED__, __CALIB_FACTOR_DIFFERENTIAL__)          (((__CALIB_FACTOR_DIFFERENTIAL__) << ADC_CALFACT_CALFACT_D_Pos) | (__CALIB_FACTOR_SINGLE_ENDED__))
N#else
N#define __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(__CALIB_FACTOR_SINGLE_ENDED__, __CALIB_FACTOR_DIFFERENTIAL__)        \
N  (((__CALIB_FACTOR_DIFFERENTIAL__) << POSITION_VAL(ADC_CALFACT_CALFACT_D)) | (__CALIB_FACTOR_SINGLE_ENDED__))
X#define __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(__CALIB_FACTOR_SINGLE_ENDED__, __CALIB_FACTOR_DIFFERENTIAL__)          (((__CALIB_FACTOR_DIFFERENTIAL__) << POSITION_VAL(ADC_CALFACT_CALFACT_D)) | (__CALIB_FACTOR_SINGLE_ENDED__))
N#endif
N
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S/**
S  * @brief  Helper macro to get the ADC multimode conversion data of ADC master
S  *         or ADC slave from raw value with both ADC conversion data concatenated.
S  * @note   This macro is intended to be used when multimode transfer by DMA
S  *         is enabled: refer to function @ref LL_ADC_SetMultiDMATransfer().
S  *         In this case the transferred data need to processed with this macro
S  *         to separate the conversion data of ADC master and ADC slave.
S  * @param  __ADC_MULTI_MASTER_SLAVE__ This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_MASTER
S  *         @arg @ref LL_ADC_MULTI_SLAVE
S  * @param  __ADC_MULTI_CONV_DATA__ Value between Min_Data=0x000 and Max_Data=0xFFF
S  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
S  */
S#define __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE(__ADC_MULTI_MASTER_SLAVE__, __ADC_MULTI_CONV_DATA__)  \
S  (((__ADC_MULTI_CONV_DATA__) >> POSITION_VAL((__ADC_MULTI_MASTER_SLAVE__))) & ADC_CDR_RDATA_MST)
X#define __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE(__ADC_MULTI_MASTER_SLAVE__, __ADC_MULTI_CONV_DATA__)    (((__ADC_MULTI_CONV_DATA__) >> POSITION_VAL((__ADC_MULTI_MASTER_SLAVE__))) & ADC_CDR_RDATA_MST)
N#endif
N
N/**
N  * @brief  Helper macro to select the ADC common instance
N  *         to which is belonging the selected ADC instance.
N  * @note   ADC common register instance can be used for:
N  *         - Set parameters common to several ADC instances
N  *         - Multimode (for devices with several ADC instances)
N  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
N  * @param  __ADCx__ ADC instance
N  * @retval ADC common register instance
N  */
N#if defined(ADC1) && defined(ADC2) && defined(ADC3)
X#if 1L && 0L && 0L
S#define __LL_ADC_COMMON_INSTANCE(__ADCx__)                                     \
S  (ADC123_COMMON)
X#define __LL_ADC_COMMON_INSTANCE(__ADCx__)                                       (ADC123_COMMON)
S#elif defined(ADC1) && defined(ADC2)
X#elif 1L && 0L
S#define __LL_ADC_COMMON_INSTANCE(__ADCx__)                                     \
S  (ADC12_COMMON)
X#define __LL_ADC_COMMON_INSTANCE(__ADCx__)                                       (ADC12_COMMON)
N#else
N#define __LL_ADC_COMMON_INSTANCE(__ADCx__)                                     \
N  (ADC1_COMMON)
X#define __LL_ADC_COMMON_INSTANCE(__ADCx__)                                       (ADC1_COMMON)
N#endif
N
N/**
N  * @brief  Helper macro to check if all ADC instances sharing the same
N  *         ADC common instance are disabled.
N  * @note   This check is required by functions with setting conditioned to
N  *         ADC state:
N  *         All ADC instances of the ADC common group must be disabled.
N  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
N  * @note   On devices with only 1 ADC common instance, parameter of this macro
N  *         is useless and can be ignored (parameter kept for compatibility
N  *         with devices featuring several ADC common instances).
N  * @param  __ADCXY_COMMON__ ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
N  * @retval Value "0" if all ADC instances sharing the same ADC common instance
N  *         are disabled.
N  *         Value "1" if at least one ADC instance sharing the same ADC common instance
N  *         is enabled.
N  */
N#if defined(ADC1) && defined(ADC2) && defined(ADC3)
X#if 1L && 0L && 0L
S#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__)              \
S  (LL_ADC_IsEnabled(ADC1) |                                                    \
S   LL_ADC_IsEnabled(ADC2) |                                                    \
S   LL_ADC_IsEnabled(ADC3)  )
X#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__)                (LL_ADC_IsEnabled(ADC1) |                                                       LL_ADC_IsEnabled(ADC2) |                                                       LL_ADC_IsEnabled(ADC3)  )
S#elif defined(ADC1) && defined(ADC2)
X#elif 1L && 0L
S#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__)              \
S  (LL_ADC_IsEnabled(ADC1) |                                                    \
S   LL_ADC_IsEnabled(ADC2)  )
X#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__)                (LL_ADC_IsEnabled(ADC1) |                                                       LL_ADC_IsEnabled(ADC2)  )
N#else
N#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__)              \
N  (LL_ADC_IsEnabled(ADC1))
X#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__)                (LL_ADC_IsEnabled(ADC1))
N#endif
N
N/**
N  * @brief  Helper macro to define the ADC conversion data full-scale digital
N  *         value corresponding to the selected ADC resolution.
N  * @note   ADC conversion data full-scale corresponds to voltage range
N  *         determined by analog voltage references Vref+ and Vref-
N  *         (refer to reference manual).
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
N  */
N#define __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                             \
N  (0xFFFU >> ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U)))
X#define __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                               (0xFFFU >> ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U)))
N
N/**
N  * @brief  Helper macro to convert the ADC conversion data from
N  *         a resolution to another resolution.
N  * @param  __DATA__ ADC conversion data to be converted 
N  * @param  __ADC_RESOLUTION_CURRENT__ Resolution of the data to be converted
N  *         This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @param  __ADC_RESOLUTION_TARGET__ Resolution of the data after conversion
N  *         This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval ADC conversion data to the requested resolution
N  */
N#define __LL_ADC_CONVERT_DATA_RESOLUTION(__DATA__,\
N                                         __ADC_RESOLUTION_CURRENT__,\
N                                         __ADC_RESOLUTION_TARGET__)            \
N  (((__DATA__)                                                                 \
N    << ((__ADC_RESOLUTION_CURRENT__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U)))    \
N   >> ((__ADC_RESOLUTION_TARGET__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U))       \
N  )
X#define __LL_ADC_CONVERT_DATA_RESOLUTION(__DATA__,                                         __ADC_RESOLUTION_CURRENT__,                                         __ADC_RESOLUTION_TARGET__)              (((__DATA__)                                                                     << ((__ADC_RESOLUTION_CURRENT__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U)))       >> ((__ADC_RESOLUTION_TARGET__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U))         )
N
N/**
N  * @brief  Helper macro to calculate the voltage (unit: mVolt)
N  *         corresponding to a ADC conversion data (unit: digital value).
N  * @note   Analog reference voltage (Vref+) must be either known from
N  *         user board environment or can be calculated using ADC measurement
N  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
N  * @param  __VREFANALOG_VOLTAGE__ Analog reference voltage (unit: mV)
N  * @param  __ADC_DATA__ ADC conversion data (resolution 12 bits)
N  *                       (unit: digital value).
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
N  */
N#define __LL_ADC_CALC_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,\
N                                      __ADC_DATA__,\
N                                      __ADC_RESOLUTION__)                      \
N  ((__ADC_DATA__) * (__VREFANALOG_VOLTAGE__)                                   \
N   / __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                                \
N  )
X#define __LL_ADC_CALC_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,                                      __ADC_DATA__,                                      __ADC_RESOLUTION__)                        ((__ADC_DATA__) * (__VREFANALOG_VOLTAGE__)                                      / __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)                                  )
N
N/* Legacy define */
N#define __LL_ADC_CALC_DATA_VOLTAGE()  __LL_ADC_CALC_DATA_TO_VOLTAGE()
N
N/**
N  * @brief  Helper macro to calculate analog reference voltage (Vref+)
N  *         (unit: mVolt) from ADC conversion data of internal voltage
N  *         reference VrefInt.
N  * @note   Computation is using VrefInt calibration value
N  *         stored in system memory for each device during production.
N  * @note   This voltage depends on user board environment: voltage level
N  *         connected to pin Vref+.
N  *         On devices with small package, the pin Vref+ is not present
N  *         and internally bonded to pin Vdda.
N  * @note   On this STM32 serie, calibration data of internal voltage reference
N  *         VrefInt corresponds to a resolution of 12 bits,
N  *         this is the recommended ADC resolution to convert voltage of
N  *         internal voltage reference VrefInt.
N  *         Otherwise, this macro performs the processing to scale
N  *         ADC conversion data to 12 bits.
N  * @param  __VREFINT_ADC_DATA__ ADC conversion data (resolution 12 bits)
N  *         of internal voltage reference VrefInt (unit: digital value).
N  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval Analog reference voltage (unit: mV)
N  */
N#define __LL_ADC_CALC_VREFANALOG_VOLTAGE(__VREFINT_ADC_DATA__,\
N                                         __ADC_RESOLUTION__)                   \
N  (((uint32_t)(*VREFINT_CAL_ADDR) * VREFINT_CAL_VREF)                          \
N    / __LL_ADC_CONVERT_DATA_RESOLUTION((__VREFINT_ADC_DATA__),                 \
N                                       (__ADC_RESOLUTION__),                   \
N                                       LL_ADC_RESOLUTION_12B)                  \
N  )
X#define __LL_ADC_CALC_VREFANALOG_VOLTAGE(__VREFINT_ADC_DATA__,                                         __ADC_RESOLUTION__)                     (((uint32_t)(*VREFINT_CAL_ADDR) * VREFINT_CAL_VREF)                              / __LL_ADC_CONVERT_DATA_RESOLUTION((__VREFINT_ADC_DATA__),                                                        (__ADC_RESOLUTION__),                                                          LL_ADC_RESOLUTION_12B)                    )
N
N/**
N  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
N  *         from ADC conversion data of internal temperature sensor.
N  * @note   Computation is using temperature sensor calibration values
N  *         stored in system memory for each device during production.
N  * @note   Calculation formula:
N  *           Temperature = ((TS_ADC_DATA - TS_CAL1)
N  *                           * (TS_CAL2_TEMP - TS_CAL1_TEMP))
N  *                         / (TS_CAL2 - TS_CAL1) + TS_CAL1_TEMP
N  *           with TS_ADC_DATA = temperature sensor raw data measured by ADC
N  *                Avg_Slope = (TS_CAL2 - TS_CAL1)
N  *                            / (TS_CAL2_TEMP - TS_CAL1_TEMP)
N  *                TS_CAL1   = equivalent TS_ADC_DATA at temperature
N  *                            TEMP_DEGC_CAL1 (calibrated in factory)
N  *                TS_CAL2   = equivalent TS_ADC_DATA at temperature
N  *                            TEMP_DEGC_CAL2 (calibrated in factory)
N  *         Caution: Calculation relevancy under reserve that calibration
N  *                  parameters are correct (address and data).
N  *                  To calculate temperature using temperature sensor
N  *                  datasheet typical values (generic values less, therefore
N  *                  less accurate than calibrated values),
N  *                  use helper macro @ref __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS().
N  * @note   As calculation input, the analog reference voltage (Vref+) must be
N  *         defined as it impacts the ADC LSB equivalent voltage.
N  * @note   Analog reference voltage (Vref+) must be either known from
N  *         user board environment or can be calculated using ADC measurement
N  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
N  * @note   On this STM32 serie, calibration data of temperature sensor
N  *         corresponds to a resolution of 12 bits,
N  *         this is the recommended ADC resolution to convert voltage of
N  *         temperature sensor.
N  *         Otherwise, this macro performs the processing to scale
N  *         ADC conversion data to 12 bits.
N  * @param  __VREFANALOG_VOLTAGE__  Analog reference voltage (unit: mV)
N  * @param  __TEMPSENSOR_ADC_DATA__ ADC conversion data of internal
N  *                                 temperature sensor (unit: digital value).
N  * @param  __ADC_RESOLUTION__      ADC resolution at which internal temperature
N  *                                 sensor voltage has been measured.
N  *         This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval Temperature (unit: degree Celsius)
N  */
N#define __LL_ADC_CALC_TEMPERATURE(__VREFANALOG_VOLTAGE__,\
N                                  __TEMPSENSOR_ADC_DATA__,\
N                                  __ADC_RESOLUTION__)                              \
N  (((( ((int32_t)((__LL_ADC_CONVERT_DATA_RESOLUTION((__TEMPSENSOR_ADC_DATA__),     \
N                                                    (__ADC_RESOLUTION__),          \
N                                                    LL_ADC_RESOLUTION_12B)         \
N                   * (__VREFANALOG_VOLTAGE__))                                     \
N                  / TEMPSENSOR_CAL_VREFANALOG)                                     \
N        - (int32_t) *TEMPSENSOR_CAL1_ADDR)                                         \
N     ) * (int32_t)(TEMPSENSOR_CAL2_TEMP - TEMPSENSOR_CAL1_TEMP)                    \
N    ) / (int32_t)((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) \
N   ) + TEMPSENSOR_CAL1_TEMP                                                        \
N  )
X#define __LL_ADC_CALC_TEMPERATURE(__VREFANALOG_VOLTAGE__,                                  __TEMPSENSOR_ADC_DATA__,                                  __ADC_RESOLUTION__)                                (((( ((int32_t)((__LL_ADC_CONVERT_DATA_RESOLUTION((__TEMPSENSOR_ADC_DATA__),                                                         (__ADC_RESOLUTION__),                                                              LL_ADC_RESOLUTION_12B)                            * (__VREFANALOG_VOLTAGE__))                                                       / TEMPSENSOR_CAL_VREFANALOG)                                             - (int32_t) *TEMPSENSOR_CAL1_ADDR)                                              ) * (int32_t)(TEMPSENSOR_CAL2_TEMP - TEMPSENSOR_CAL1_TEMP)                        ) / (int32_t)((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR)    ) + TEMPSENSOR_CAL1_TEMP                                                          )
N
N/**
N  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
N  *         from ADC conversion data of internal temperature sensor.
N  * @note   Computation is using temperature sensor typical values
N  *         (refer to device datasheet).
N  * @note   Calculation formula:
N  *           Temperature = (TS_TYP_CALx_VOLT(uV) - TS_ADC_DATA * Conversion_uV)
N  *                         / Avg_Slope + CALx_TEMP
N  *           with TS_ADC_DATA      = temperature sensor raw data measured by ADC
N  *                                   (unit: digital value)
N  *                Avg_Slope        = temperature sensor slope
N  *                                   (unit: uV/Degree Celsius)
N  *                TS_TYP_CALx_VOLT = temperature sensor digital value at
N  *                                   temperature CALx_TEMP (unit: mV)
N  *         Caution: Calculation relevancy under reserve the temperature sensor
N  *                  of the current device has characteristics in line with
N  *                  datasheet typical values.
N  *                  If temperature sensor calibration values are available on
N  *                  on this device (presence of macro __LL_ADC_CALC_TEMPERATURE()),
N  *                  temperature calculation will be more accurate using
N  *                  helper macro @ref __LL_ADC_CALC_TEMPERATURE().
N  * @note   As calculation input, the analog reference voltage (Vref+) must be
N  *         defined as it impacts the ADC LSB equivalent voltage.
N  * @note   Analog reference voltage (Vref+) must be either known from
N  *         user board environment or can be calculated using ADC measurement
N  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
N  * @note   ADC measurement data must correspond to a resolution of 12 bits
N  *         (full scale digital value 4095). If not the case, the data must be
N  *         preliminarily rescaled to an equivalent resolution of 12 bits.
N  * @param  __TEMPSENSOR_TYP_AVGSLOPE__   Device datasheet data: Temperature sensor slope typical value (unit: uV/DegCelsius).
N  *                                       On STM32L4, refer to device datasheet parameter "Avg_Slope".
N  * @param  __TEMPSENSOR_TYP_CALX_V__     Device datasheet data: Temperature sensor voltage typical value (at temperature and Vref+ defined in parameters below) (unit: mV).
N  *                                       On STM32L4, refer to device datasheet parameter "V30" (corresponding to TS_CAL1).
N  * @param  __TEMPSENSOR_CALX_TEMP__      Device datasheet data: Temperature at which temperature sensor voltage (see parameter above) is corresponding (unit: mV)
N  * @param  __VREFANALOG_VOLTAGE__        Analog voltage reference (Vref+) voltage (unit: mV)
N  * @param  __TEMPSENSOR_ADC_DATA__       ADC conversion data of internal temperature sensor (unit: digital value).
N  * @param  __ADC_RESOLUTION__            ADC resolution at which internal temperature sensor voltage has been measured.
N  *         This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval Temperature (unit: degree Celsius)
N  */
N#define __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(__TEMPSENSOR_TYP_AVGSLOPE__,\
N                                             __TEMPSENSOR_TYP_CALX_V__,\
N                                             __TEMPSENSOR_CALX_TEMP__,\
N                                             __VREFANALOG_VOLTAGE__,\
N                                             __TEMPSENSOR_ADC_DATA__,\
N                                             __ADC_RESOLUTION__)               \
N  ((( (                                                                        \
N       (int32_t)((((__TEMPSENSOR_ADC_DATA__) * (__VREFANALOG_VOLTAGE__))       \
N                  / __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__))                \
N                 * 1000)                                                       \
N       -                                                                       \
N       (int32_t)(((__TEMPSENSOR_TYP_CALX_V__))                                 \
N                 * 1000)                                                       \
N      )                                                                        \
N    ) / (__TEMPSENSOR_TYP_AVGSLOPE__)                                          \
N   ) + (__TEMPSENSOR_CALX_TEMP__)                                              \
N  )
X#define __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(__TEMPSENSOR_TYP_AVGSLOPE__,                                             __TEMPSENSOR_TYP_CALX_V__,                                             __TEMPSENSOR_CALX_TEMP__,                                             __VREFANALOG_VOLTAGE__,                                             __TEMPSENSOR_ADC_DATA__,                                             __ADC_RESOLUTION__)                 ((( (                                                                               (int32_t)((((__TEMPSENSOR_ADC_DATA__) * (__VREFANALOG_VOLTAGE__))                         / __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__))                                 * 1000)                                                              -                                                                              (int32_t)(((__TEMPSENSOR_TYP_CALX_V__))                                                  * 1000)                                                             )                                                                            ) / (__TEMPSENSOR_TYP_AVGSLOPE__)                                             ) + (__TEMPSENSOR_CALX_TEMP__)                                                )
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup ADC_LL_Exported_Functions ADC Exported Functions
N  * @{
N  */
N
N/** @defgroup ADC_LL_EF_DMA_Management ADC DMA management
N  * @{
N  */
N/* Note: LL ADC functions to set DMA transfer are located into sections of    */
N/*       configuration of ADC instance, groups and multimode (if available):  */
N/*       @ref LL_ADC_REG_SetDMATransfer(), ...                                */
N
N/**
N  * @brief  Function to help to configure DMA transfer from ADC: retrieve the
N  *         ADC register address from ADC instance and a list of ADC registers
N  *         intended to be used (most commonly) with DMA transfer.
N  * @note   These ADC registers are data registers:
N  *         when ADC conversion data is available in ADC data registers,
N  *         ADC generates a DMA transfer request.
N  * @note   This macro is intended to be used with LL DMA driver, refer to
N  *         function "LL_DMA_ConfigAddresses()".
N  *         Example:
N  *           LL_DMA_ConfigAddresses(DMA1,
N  *                                  LL_DMA_CHANNEL_1,
N  *                                  LL_ADC_DMA_GetRegAddr(ADC1, LL_ADC_DMA_REG_REGULAR_DATA),
N  *                                  (uint32_t)&< array or variable >,
N  *                                  LL_DMA_DIRECTION_PERIPH_TO_MEMORY);
N  * @note   For devices with several ADC: in multimode, some devices
N  *         use a different data register outside of ADC instance scope
N  *         (common data register). This macro manages this register difference,
N  *         only ADC instance has to be set as parameter.
N  * @rmtoll DR       RDATA          LL_ADC_DMA_GetRegAddr\n
N  *         CDR      RDATA_MST      LL_ADC_DMA_GetRegAddr\n
N  *         CDR      RDATA_SLV      LL_ADC_DMA_GetRegAddr
N  * @param  ADCx ADC instance
N  * @param  Register This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_DMA_REG_REGULAR_DATA
N  *         @arg @ref LL_ADC_DMA_REG_REGULAR_DATA_MULTI (1)
N  *         
N  *         (1) Available on devices with several ADC instances.
N  * @retval ADC register address
N  */
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S__STATIC_INLINE uint32_t LL_ADC_DMA_GetRegAddr(ADC_TypeDef *ADCx, uint32_t Register)
S{
S  register uint32_t data_reg_addr = 0U;
S  
S  if (Register == LL_ADC_DMA_REG_REGULAR_DATA)
S  {
S    /* Retrieve address of register DR */
S    data_reg_addr = (uint32_t)&(ADCx->DR);
S  }
S  else /* (Register == LL_ADC_DMA_REG_REGULAR_DATA_MULTI) */
S  {
S    /* Retrieve address of register CDR */
S    data_reg_addr = (uint32_t)&((__LL_ADC_COMMON_INSTANCE(ADCx))->CDR);
S  }
S  
S  return data_reg_addr;
S}
N#else
N__STATIC_INLINE uint32_t LL_ADC_DMA_GetRegAddr(ADC_TypeDef *ADCx, uint32_t Register)
Xstatic __inline uint32_t LL_ADC_DMA_GetRegAddr(ADC_TypeDef *ADCx, uint32_t Register)
N{
N  /* Prevent unused argument(s) compilation warning */
N  (void)(Register);
N  
N  /* Retrieve address of register DR */
N  return (uint32_t)&(ADCx->DR);
N}
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_Common Configuration of ADC hierarchical scope: common to several ADC instances
N  * @{
N  */
N
N/**
N  * @brief  Set parameter common to several ADC: Clock source and prescaler.
N  * @note   On this STM32 serie, if ADC group injected is used, some
N  *         clock ratio constraints between ADC clock and AHB clock
N  *         must be respected.
N  *         Refer to reference manual.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         All ADC instances of the ADC common group must be disabled.
N  *         This check can be done with function @ref LL_ADC_IsEnabled() for each
N  *         ADC instance or by using helper macro helper macro
N  *         @ref __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE().
N  * @rmtoll CCR      CKMODE         LL_ADC_SetCommonClock\n
N  *         CCR      PRESC          LL_ADC_SetCommonClock
N  * @param  ADCxy_COMMON ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
N  * @param  CommonClock This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV1
N  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV2
N  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV4
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV1
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV2
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV4
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV6
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV8
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV10
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV12
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV16
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV32
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV64
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
Xstatic __inline void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
N{
N  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
X  (((ADCxy_COMMON->CCR)) = ((((((ADCxy_COMMON->CCR))) & (~((0x3UL << (16U)) | (0xFUL << (18U))))) | (CommonClock))));
N}
N
N/**
N  * @brief  Get parameter common to several ADC: Clock source and prescaler.
N  * @rmtoll CCR      CKMODE         LL_ADC_GetCommonClock\n
N  *         CCR      PRESC          LL_ADC_GetCommonClock
N  * @param  ADCxy_COMMON ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV1
N  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV2
N  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV4
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV1
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV2
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV4
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV6
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV8
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV10
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV12
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV16
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV32
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV64
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
N  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON)
Xstatic __inline uint32_t LL_ADC_GetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON)
N{
N  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC));
X  return (uint32_t)(((ADCxy_COMMON->CCR) & ((0x3UL << (16U)) | (0xFUL << (18U)))));
N}
N
N/**
N  * @brief  Set parameter common to several ADC: measurement path to internal
N  *         channels (VrefInt, temperature sensor, ...).
N  * @note   One or several values can be selected.
N  *         Example: (LL_ADC_PATH_INTERNAL_VREFINT |
N  *                   LL_ADC_PATH_INTERNAL_TEMPSENSOR)
N  * @note   Stabilization time of measurement path to internal channel:
N  *         After enabling internal paths, before starting ADC conversion,
N  *         a delay is required for internal voltage reference and
N  *         temperature sensor stabilization time.
N  *         Refer to device datasheet.
N  *         Refer to literal @ref LL_ADC_DELAY_VREFINT_STAB_US.
N  *         Refer to literal @ref LL_ADC_DELAY_TEMPSENSOR_STAB_US.
N  * @note   ADC internal channel sampling time constraint:
N  *         For ADC conversion of internal channels,
N  *         a sampling time minimum value is required.
N  *         Refer to device datasheet.
N  * @rmtoll CCR      VREFEN         LL_ADC_SetCommonPathInternalCh\n
N  *         CCR      TSEN           LL_ADC_SetCommonPathInternalCh\n
N  *         CCR      VBATEN         LL_ADC_SetCommonPathInternalCh
N  * @param  ADCxy_COMMON ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
N  * @param  PathInternal This parameter can be a combination of the following values:
N  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
N  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
N  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
N  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
Xstatic __inline void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
N{
N  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
X  (((ADCxy_COMMON->CCR)) = ((((((ADCxy_COMMON->CCR))) & (~((0x1UL << (22U)) | (0x1UL << (23U)) | (0x1UL << (24U))))) | (PathInternal))));
N}
N
N/**
N  * @brief  Get parameter common to several ADC: measurement path to internal
N  *         channels (VrefInt, temperature sensor, ...).
N  * @note   One or several values can be selected.
N  *         Example: (LL_ADC_PATH_INTERNAL_VREFINT |
N  *                   LL_ADC_PATH_INTERNAL_TEMPSENSOR)
N  * @rmtoll CCR      VREFEN         LL_ADC_GetCommonPathInternalCh\n
N  *         CCR      TSEN           LL_ADC_GetCommonPathInternalCh\n
N  *         CCR      VBATEN         LL_ADC_GetCommonPathInternalCh
N  * @param  ADCxy_COMMON ADC common instance
N  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
N  * @retval Returned value can be a combination of the following values:
N  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
N  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
N  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
N  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
Xstatic __inline uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
N{
N  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
X  return (uint32_t)(((ADCxy_COMMON->CCR) & ((0x1UL << (22U)) | (0x1UL << (23U)) | (0x1UL << (24U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_Instance Configuration of ADC hierarchical scope: ADC instance
N  * @{
N  */
N
N/**
N  * @brief  Set ADC calibration factor in the mode single-ended
N  *         or differential (for devices with differential mode available).
N  * @note   This function is intended to set calibration parameters
N  *         without having to perform a new calibration using
N  *         @ref LL_ADC_StartCalibration().
N  * @note   For devices with differential mode available:
N  *         Calibration of offset is specific to each of
N  *         single-ended and differential modes
N  *         (calibration factor must be specified for each of these
N  *         differential modes, if used afterwards and if the application
N  *         requires their calibration).
N  * @note   In case of setting calibration factors of both modes single ended
N  *         and differential (parameter LL_ADC_BOTH_SINGLE_DIFF_ENDED):
N  *         both calibration factors must be concatenated.
N  *         To perform this processing, use helper macro
N  *         @ref __LL_ADC_CALIB_FACTOR_SINGLE_DIFF().
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled, without calibration on going, without conversion
N  *         on going on group regular.
N  * @rmtoll CALFACT  CALFACT_S      LL_ADC_SetCalibrationFactor\n
N  *         CALFACT  CALFACT_D      LL_ADC_SetCalibrationFactor
N  * @param  ADCx ADC instance
N  * @param  SingleDiff This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_SINGLE_ENDED
N  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
N  *         @arg @ref LL_ADC_BOTH_SINGLE_DIFF_ENDED
N  * @param  CalibrationFactor Value between Min_Data=0x00 and Max_Data=0x7F
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetCalibrationFactor(ADC_TypeDef *ADCx, uint32_t SingleDiff, uint32_t CalibrationFactor)
Xstatic __inline void LL_ADC_SetCalibrationFactor(ADC_TypeDef *ADCx, uint32_t SingleDiff, uint32_t CalibrationFactor)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  MODIFY_REG(ADCx->CALFACT,
S             SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK,
S             CalibrationFactor << (((SingleDiff & ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK) >> ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4) & ~(SingleDiff & ADC_CALFACT_CALFACT_S)));
N#else
N  MODIFY_REG(ADCx->CALFACT,
N             SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK,
N             CalibrationFactor << POSITION_VAL(SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK));
X  (((ADCx->CALFACT)) = ((((((ADCx->CALFACT))) & (~(SingleDiff & ((0x7FUL << (16U)) | (0x7FUL << (0U)))))) | (CalibrationFactor << (__clz(__rbit(SingleDiff & ((0x7FUL << (16U)) | (0x7FUL << (0U))))))))));
N#endif
N}
N
N/**
N  * @brief  Get ADC calibration factor in the mode single-ended
N  *         or differential (for devices with differential mode available).
N  * @note   Calibration factors are set by hardware after performing
N  *         a calibration run using function @ref LL_ADC_StartCalibration().
N  * @note   For devices with differential mode available:
N  *         Calibration of offset is specific to each of
N  *         single-ended and differential modes
N  * @rmtoll CALFACT  CALFACT_S      LL_ADC_GetCalibrationFactor\n
N  *         CALFACT  CALFACT_D      LL_ADC_GetCalibrationFactor
N  * @param  ADCx ADC instance
N  * @param  SingleDiff This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_SINGLE_ENDED
N  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
N  * @retval Value between Min_Data=0x00 and Max_Data=0x7F
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetCalibrationFactor(ADC_TypeDef *ADCx, uint32_t SingleDiff)
Xstatic __inline uint32_t LL_ADC_GetCalibrationFactor(ADC_TypeDef *ADCx, uint32_t SingleDiff)
N{
N  /* Retrieve bits with position in register depending on parameter           */
N  /* "SingleDiff".                                                            */
N  /* Parameter used with mask "ADC_SINGLEDIFF_CALIB_FACTOR_MASK" because      */
N  /* containing other bits reserved for other purpose.                        */
N#if defined(CORE_CM0PLUS)
X#if 0L
S  return (uint32_t)(READ_BIT(ADCx->CALFACT, (SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK)) >> ((SingleDiff & ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK) >> ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4));
N#else
N  return (uint32_t)(READ_BIT(ADCx->CALFACT, (SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK)) >> POSITION_VAL(SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK));
X  return (uint32_t)(((ADCx->CALFACT) & ((SingleDiff & ((0x7FUL << (16U)) | (0x7FUL << (0U)))))) >> (__clz(__rbit(SingleDiff & ((0x7FUL << (16U)) | (0x7FUL << (0U)))))));
N#endif
N}
N
N/**
N  * @brief  Set ADC resolution.
N  *         Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     RES            LL_ADC_SetResolution
N  * @param  ADCx ADC instance
N  * @param  Resolution This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetResolution(ADC_TypeDef *ADCx, uint32_t Resolution)
Xstatic __inline void LL_ADC_SetResolution(ADC_TypeDef *ADCx, uint32_t Resolution)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_RES, Resolution);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x3UL << (3U))))) | (Resolution))));
N}
N
N/**
N  * @brief  Get ADC resolution.
N  *         Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @rmtoll CFGR     RES            LL_ADC_GetResolution
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_RESOLUTION_12B
N  *         @arg @ref LL_ADC_RESOLUTION_10B
N  *         @arg @ref LL_ADC_RESOLUTION_8B
N  *         @arg @ref LL_ADC_RESOLUTION_6B
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetResolution(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetResolution(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
X  return (uint32_t)(((ADCx->CFGR) & ((0x3UL << (3U)))));
N}
N
N/**
N  * @brief  Set ADC conversion data alignment.
N  * @note   Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     ALIGN          LL_ADC_SetDataAlignment
N  * @param  ADCx ADC instance
N  * @param  DataAlignment This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_DATA_ALIGN_RIGHT
N  *         @arg @ref LL_ADC_DATA_ALIGN_LEFT
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetDataAlignment(ADC_TypeDef *ADCx, uint32_t DataAlignment)
Xstatic __inline void LL_ADC_SetDataAlignment(ADC_TypeDef *ADCx, uint32_t DataAlignment)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_ALIGN, DataAlignment);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (5U))))) | (DataAlignment))));
N}
N
N/**
N  * @brief  Get ADC conversion data alignment.
N  * @note   Refer to reference manual for alignments formats
N  *         dependencies to ADC resolutions.
N  * @rmtoll CFGR     ALIGN          LL_ADC_GetDataAlignment
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_DATA_ALIGN_RIGHT
N  *         @arg @ref LL_ADC_DATA_ALIGN_LEFT
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetDataAlignment(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetDataAlignment(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_ALIGN));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (5U)))));
N}
N
N/**
N  * @brief  Set ADC low power mode.
N  * @note   Description of ADC low power modes:
N  *         - ADC low power mode "auto wait": Dynamic low power mode,
N  *           ADC conversions occurrences are limited to the minimum necessary
N  *           in order to reduce power consumption.
N  *           New ADC conversion starts only when the previous
N  *           unitary conversion data (for ADC group regular)
N  *           or previous sequence conversions data (for ADC group injected)
N  *           has been retrieved by user software.
N  *           In the meantime, ADC remains idle: does not performs any
N  *           other conversion.
N  *           This mode allows to automatically adapt the ADC conversions
N  *           triggers to the speed of the software that reads the data.
N  *           Moreover, this avoids risk of overrun for low frequency
N  *           applications.
N  *           How to use this low power mode:
N  *           - Do not use with interruption or DMA since these modes
N  *             have to clear immediately the EOC flag to free the
N  *             IRQ vector sequencer.
N  *           - Do use with polling: 1. Start conversion,
N  *             2. Later on, when conversion data is needed: poll for end of
N  *             conversion  to ensure that conversion is completed and
N  *             retrieve ADC conversion data. This will trig another
N  *             ADC conversion start.
N  *         - ADC low power mode "auto power-off" (feature available on
N  *           this device if parameter LL_ADC_LP_MODE_AUTOOFF is available):
N  *           the ADC automatically powers-off after a conversion and
N  *           automatically wakes up when a new conversion is triggered
N  *           (with startup time between trigger and start of sampling).
N  *           This feature can be combined with low power mode "auto wait".
N  * @note   With ADC low power mode "auto wait", the ADC conversion data read
N  *         is corresponding to previous ADC conversion start, independently
N  *         of delay during which ADC was idle.
N  *         Therefore, the ADC conversion data may be outdated: does not
N  *         correspond to the current voltage level on the selected
N  *         ADC channel.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     AUTDLY         LL_ADC_SetLowPowerMode
N  * @param  ADCx ADC instance
N  * @param  LowPowerMode This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_LP_MODE_NONE
N  *         @arg @ref LL_ADC_LP_AUTOWAIT
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetLowPowerMode(ADC_TypeDef *ADCx, uint32_t LowPowerMode)
Xstatic __inline void LL_ADC_SetLowPowerMode(ADC_TypeDef *ADCx, uint32_t LowPowerMode)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_AUTDLY, LowPowerMode);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (14U))))) | (LowPowerMode))));
N}
N
N/**
N  * @brief  Get ADC low power mode:
N  * @note   Description of ADC low power modes:
N  *         - ADC low power mode "auto wait": Dynamic low power mode,
N  *           ADC conversions occurrences are limited to the minimum necessary
N  *           in order to reduce power consumption.
N  *           New ADC conversion starts only when the previous
N  *           unitary conversion data (for ADC group regular)
N  *           or previous sequence conversions data (for ADC group injected)
N  *           has been retrieved by user software.
N  *           In the meantime, ADC remains idle: does not performs any
N  *           other conversion.
N  *           This mode allows to automatically adapt the ADC conversions
N  *           triggers to the speed of the software that reads the data.
N  *           Moreover, this avoids risk of overrun for low frequency
N  *           applications.
N  *           How to use this low power mode:
N  *           - Do not use with interruption or DMA since these modes
N  *             have to clear immediately the EOC flag to free the
N  *             IRQ vector sequencer.
N  *           - Do use with polling: 1. Start conversion,
N  *             2. Later on, when conversion data is needed: poll for end of
N  *             conversion  to ensure that conversion is completed and
N  *             retrieve ADC conversion data. This will trig another
N  *             ADC conversion start.
N  *         - ADC low power mode "auto power-off" (feature available on
N  *           this device if parameter LL_ADC_LP_MODE_AUTOOFF is available):
N  *           the ADC automatically powers-off after a conversion and
N  *           automatically wakes up when a new conversion is triggered
N  *           (with startup time between trigger and start of sampling).
N  *           This feature can be combined with low power mode "auto wait".
N  * @note   With ADC low power mode "auto wait", the ADC conversion data read
N  *         is corresponding to previous ADC conversion start, independently
N  *         of delay during which ADC was idle.
N  *         Therefore, the ADC conversion data may be outdated: does not
N  *         correspond to the current voltage level on the selected
N  *         ADC channel.
N  * @rmtoll CFGR     AUTDLY         LL_ADC_GetLowPowerMode
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_LP_MODE_NONE
N  *         @arg @ref LL_ADC_LP_AUTOWAIT
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetLowPowerMode(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetLowPowerMode(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_AUTDLY));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (14U)))));
N}
N
N/**
N  * @brief  Set ADC selected offset number 1, 2, 3 or 4.
N  * @note   This function set the 2 items of offset configuration:
N  *         - ADC channel to which the offset programmed will be applied
N  *           (independently of channel mapped on ADC group regular
N  *           or group injected)
N  *         - Offset level (offset to be subtracted from the raw
N  *           converted data).
N  * @note   Caution: Offset format is dependent to ADC resolution:
N  *         offset has to be left-aligned on bit 11, the LSB (right bits)
N  *         are set to 0.
N  * @note   This function enables the offset, by default. It can be forced
N  *         to disable state using function LL_ADC_SetOffsetState().
N  * @note   If a channel is mapped on several offsets numbers, only the offset
N  *         with the lowest value is considered for the subtraction.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @note   On STM32L4, some fast channels are available: fast analog inputs
N  *         coming from GPIO pads (ADC_IN1..5).
N  * @rmtoll OFR1     OFFSET1_CH     LL_ADC_SetOffset\n
N  *         OFR1     OFFSET1        LL_ADC_SetOffset\n
N  *         OFR1     OFFSET1_EN     LL_ADC_SetOffset\n
N  *         OFR2     OFFSET2_CH     LL_ADC_SetOffset\n
N  *         OFR2     OFFSET2        LL_ADC_SetOffset\n
N  *         OFR2     OFFSET2_EN     LL_ADC_SetOffset\n
N  *         OFR3     OFFSET3_CH     LL_ADC_SetOffset\n
N  *         OFR3     OFFSET3        LL_ADC_SetOffset\n
N  *         OFR3     OFFSET3_EN     LL_ADC_SetOffset\n
N  *         OFR4     OFFSET4_CH     LL_ADC_SetOffset\n
N  *         OFR4     OFFSET4        LL_ADC_SetOffset\n
N  *         OFR4     OFFSET4_EN     LL_ADC_SetOffset
N  * @param  ADCx ADC instance
N  * @param  Offsety This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_1
N  *         @arg @ref LL_ADC_OFFSET_2
N  *         @arg @ref LL_ADC_OFFSET_3
N  *         @arg @ref LL_ADC_OFFSET_4
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
Xstatic __inline void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
N{
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->OFR1)) + ((Offsety) << 2U))));
N  
N  MODIFY_REG(*preg,
N             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
N             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
X  (((*preg)) = ((((((*preg))) & (~((0x1UL << (31U)) | (0x1FUL << (26U)) | (0xFFFUL << (0U))))) | ((0x1UL << (31U)) | (Channel & ((0x1FUL << (26U)))) | OffsetLevel))));
N}
N
N/**
N  * @brief  Get for the ADC selected offset number 1, 2, 3 or 4:
N  *         Channel to which the offset programmed will be applied
N  *         (independently of channel mapped on ADC group regular
N  *         or group injected)
N  * @note   Usage of the returned channel number:
N  *         - To reinject this channel into another function LL_ADC_xxx:
N  *           the returned channel number is only partly formatted on definition
N  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
N  *           with parts of literals LL_ADC_CHANNEL_x or using
N  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Then the selected literal LL_ADC_CHANNEL_x can be used
N  *           as parameter for another function.
N  *         - To get the channel number in decimal format:
N  *           process the returned value with the helper macro
N  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  * @note   On STM32L4, some fast channels are available: fast analog inputs
N  *         coming from GPIO pads (ADC_IN1..5).
N  * @rmtoll OFR1     OFFSET1_CH     LL_ADC_GetOffsetChannel\n
N  *         OFR2     OFFSET2_CH     LL_ADC_GetOffsetChannel\n
N  *         OFR3     OFFSET3_CH     LL_ADC_GetOffsetChannel\n
N  *         OFR4     OFFSET4_CH     LL_ADC_GetOffsetChannel
N  * @param  ADCx ADC instance
N  * @param  Offsety This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_1
N  *         @arg @ref LL_ADC_OFFSET_2
N  *         @arg @ref LL_ADC_OFFSET_3
N  *         @arg @ref LL_ADC_OFFSET_4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).\n
N  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
N  *                      comparison with internal channel parameter to be done
N  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
Xstatic __inline uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
N{
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->OFR1)) + ((Offsety) << 2U))));
N  
N  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
X  return (uint32_t) ((*preg) & ((0x1FUL << (26U))));
N}
N
N/**
N  * @brief  Get for the ADC selected offset number 1, 2, 3 or 4:
N  *         Offset level (offset to be subtracted from the raw
N  *         converted data).
N  * @note   Caution: Offset format is dependent to ADC resolution:
N  *         offset has to be left-aligned on bit 11, the LSB (right bits)
N  *         are set to 0.
N  * @rmtoll OFR1     OFFSET1        LL_ADC_GetOffsetLevel\n
N  *         OFR2     OFFSET2        LL_ADC_GetOffsetLevel\n
N  *         OFR3     OFFSET3        LL_ADC_GetOffsetLevel\n
N  *         OFR4     OFFSET4        LL_ADC_GetOffsetLevel
N  * @param  ADCx ADC instance
N  * @param  Offsety This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_1
N  *         @arg @ref LL_ADC_OFFSET_2
N  *         @arg @ref LL_ADC_OFFSET_3
N  *         @arg @ref LL_ADC_OFFSET_4
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetOffsetLevel(ADC_TypeDef *ADCx, uint32_t Offsety)
Xstatic __inline uint32_t LL_ADC_GetOffsetLevel(ADC_TypeDef *ADCx, uint32_t Offsety)
N{
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->OFR1)) + ((Offsety) << 2U))));
N  
N  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1);
X  return (uint32_t) ((*preg) & ((0xFFFUL << (0U))));
N}
N
N/**
N  * @brief  Set for the ADC selected offset number 1, 2, 3 or 4:
N  *         force offset state disable or enable
N  *         without modifying offset channel or offset value.
N  * @note   This function should be needed only in case of offset to be
N  *         enabled-disabled dynamically, and should not be needed in other cases:
N  *         function LL_ADC_SetOffset() automatically enables the offset.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll OFR1     OFFSET1_EN     LL_ADC_SetOffsetState\n
N  *         OFR2     OFFSET2_EN     LL_ADC_SetOffsetState\n
N  *         OFR3     OFFSET3_EN     LL_ADC_SetOffsetState\n
N  *         OFR4     OFFSET4_EN     LL_ADC_SetOffsetState
N  * @param  ADCx ADC instance
N  * @param  Offsety This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_1
N  *         @arg @ref LL_ADC_OFFSET_2
N  *         @arg @ref LL_ADC_OFFSET_3
N  *         @arg @ref LL_ADC_OFFSET_4
N  * @param  OffsetState This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_DISABLE
N  *         @arg @ref LL_ADC_OFFSET_ENABLE
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
Xstatic __inline void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
N{
N  register uint32_t *preg = (uint32_t *)((uint32_t)
N                            ((uint32_t)(&ADCx->OFR1) + (Offsety*4U)));
N  
N  MODIFY_REG(*preg,
N             ADC_OFR1_OFFSET1_EN,
N             OffsetState);
X  (((*preg)) = ((((((*preg))) & (~((0x1UL << (31U))))) | (OffsetState))));
N}
N
N/**
N  * @brief  Get for the ADC selected offset number 1, 2, 3 or 4:
N  *         offset state disabled or enabled.
N  * @rmtoll OFR1     OFFSET1_EN     LL_ADC_GetOffsetState\n
N  *         OFR2     OFFSET2_EN     LL_ADC_GetOffsetState\n
N  *         OFR3     OFFSET3_EN     LL_ADC_GetOffsetState\n
N  *         OFR4     OFFSET4_EN     LL_ADC_GetOffsetState
N  * @param  ADCx ADC instance
N  * @param  Offsety This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_1
N  *         @arg @ref LL_ADC_OFFSET_2
N  *         @arg @ref LL_ADC_OFFSET_3
N  *         @arg @ref LL_ADC_OFFSET_4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_OFFSET_DISABLE
N  *         @arg @ref LL_ADC_OFFSET_ENABLE
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety)
Xstatic __inline uint32_t LL_ADC_GetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety)
N{
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->OFR1)) + ((Offsety) << 2U))));
N  
N  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_EN);
X  return (uint32_t) ((*preg) & ((0x1UL << (31U))));
N}
N
N#if defined(ADC_SMPR1_SMPPLUS)
X#if 0L
S/**
S  * @brief  Set ADC sampling time common configuration impacting
S  *         settings of sampling time channel wise.
S  * @note   On this STM32 serie, setting of this feature is conditioned to
S  *         ADC state:
S  *         ADC must be disabled or enabled without conversion on going
S  *         on either groups regular or injected.
S  * @rmtoll SMPR1    SMPPLUS        LL_ADC_SetSamplingTimeCommonConfig
S  * @param  ADCx ADC instance
S  * @param  SamplingTimeCommonConfig This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_DEFAULT
S  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5
S  * @retval None
S  */
S__STATIC_INLINE void LL_ADC_SetSamplingTimeCommonConfig(ADC_TypeDef *ADCx, uint32_t SamplingTimeCommonConfig)
S{
S  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
S}
S
S/**
S  * @brief  Get ADC sampling time common configuration impacting
S  *         settings of sampling time channel wise.
S  * @rmtoll SMPR1    SMPPLUS        LL_ADC_GetSamplingTimeCommonConfig
S  * @param  ADCx ADC instance
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_DEFAULT
S  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5
S  */
S__STATIC_INLINE uint32_t LL_ADC_GetSamplingTimeCommonConfig(ADC_TypeDef *ADCx)
S{
S  return (uint32_t)(READ_BIT(ADCx->SMPR1, ADC_SMPR1_SMPPLUS));
S}
N#endif /* ADC_SMPR1_SMPPLUS */
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_Group_Regular Configuration of ADC hierarchical scope: group regular
N  * @{
N  */
N
N/**
N  * @brief  Set ADC group regular conversion trigger source:
N  *         internal (SW start) or from external IP (timer event,
N  *         external interrupt line).
N  * @note   On this STM32 serie, setting trigger source to external trigger
N  *         also set trigger polarity to rising edge 
N  *         (default setting for compatibility with some ADC on other
N  *         STM32 families having this setting set by HW default value).
N  *         In case of need to modify trigger edge, use
N  *         function @ref LL_ADC_REG_SetTriggerEdge().
N  * @note   Availability of parameters of trigger sources from timer 
N  *         depends on timers availability on the selected device.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR     EXTSEL         LL_ADC_REG_SetTriggerSource\n
N  *         CFGR     EXTEN          LL_ADC_REG_SetTriggerSource
N  * @param  ADCx ADC instance
N  * @param  TriggerSource This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_TRIG_SOFTWARE
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH1
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH3
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_CH4
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_CH4
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM6_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM15_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_EXTI_LINE11
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
Xstatic __inline void LL_ADC_REG_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL, TriggerSource);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x3UL << (10U)) | (0xFUL << (6U))))) | (TriggerSource))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion trigger source:
N  *         internal (SW start) or from external IP (timer event,
N  *         external interrupt line).
N  * @note   To determine whether group regular trigger source is
N  *         internal (SW start) or external, without detail
N  *         of which peripheral is selected as external trigger,
N  *         (equivalent to 
N  *         "if(LL_ADC_REG_GetTriggerSource(ADC1) == LL_ADC_REG_TRIG_SOFTWARE)")
N  *         use function @ref LL_ADC_REG_IsTriggerSourceSWStart.
N  * @note   Availability of parameters of trigger sources from timer 
N  *         depends on timers availability on the selected device.
N  * @rmtoll CFGR     EXTSEL         LL_ADC_REG_GetTriggerSource\n
N  *         CFGR     EXTEN          LL_ADC_REG_GetTriggerSource
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_TRIG_SOFTWARE
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH1
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH3
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_CH4
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_CH4
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM6_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO2
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM15_TRGO
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_EXTI_LINE11
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerSource(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetTriggerSource(ADC_TypeDef *ADCx)
N{
N  register uint32_t TriggerSource = READ_BIT(ADCx->CFGR, ADC_CFGR_EXTSEL | ADC_CFGR_EXTEN);
X  register uint32_t TriggerSource = ((ADCx->CFGR) & ((0xFUL << (6U)) | (0x3UL << (10U))));
N  
N  /* Value for shift of {0; 4; 8; 12} depending on value of bitfield          */
N  /* corresponding to ADC_CFGR_EXTEN {0; 1; 2; 3}.                            */
N  register uint32_t ShiftExten = ((TriggerSource & ADC_CFGR_EXTEN) >> (ADC_REG_TRIG_EXTEN_BITOFFSET_POS - 2U));
X  register uint32_t ShiftExten = ((TriggerSource & (0x3UL << (10U))) >> ((10U) - 2U));
N  
N  /* Set bitfield corresponding to ADC_CFGR_EXTEN and ADC_CFGR_EXTSEL         */
N  /* to match with triggers literals definition.                              */
N  return ((TriggerSource
N           & (ADC_REG_TRIG_SOURCE_MASK >> ShiftExten) & ADC_CFGR_EXTSEL)
X           & (((((0x00000000U) & (0xFUL << (6U))) << (4U * 0U)) | (((0xFUL << (6U))) << (4U * 1U)) | (((0xFUL << (6U))) << (4U * 2U)) | (((0xFUL << (6U))) << (4U * 3U)) ) >> ShiftExten) & (0xFUL << (6U)))
N          | ((ADC_REG_TRIG_EDGE_MASK >> ShiftExten) & ADC_CFGR_EXTEN)
X          | ((((((0x00000000U) & (0x3UL << (10U))) << (4U * 0U)) | ((((0x1UL << (10U)))) << (4U * 1U)) | ((((0x1UL << (10U)))) << (4U * 2U)) | ((((0x1UL << (10U)))) << (4U * 3U)) ) >> ShiftExten) & (0x3UL << (10U)))
N         );
N}
N
N/**
N  * @brief  Get ADC group regular conversion trigger source internal (SW start)
N  *         or external.
N  * @note   In case of group regular trigger source set to external trigger,
N  *         to determine which peripheral is selected as external trigger,
N  *         use function @ref LL_ADC_REG_GetTriggerSource().
N  * @rmtoll CFGR     EXTEN          LL_ADC_REG_IsTriggerSourceSWStart
N  * @param  ADCx ADC instance
N  * @retval Value "0" if trigger source external trigger
N  *         Value "1" if trigger source SW start.
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_IsTriggerSourceSWStart(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN));
X  return (uint32_t)(((ADCx->CFGR) & ((0x3UL << (10U)))) == ((0x00000000U) & (0x3UL << (10U))));
N}
N
N/**
N  * @brief  Set ADC group regular conversion trigger polarity.
N  * @note   Applicable only for trigger source set to external trigger.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR     EXTEN          LL_ADC_REG_SetTriggerEdge
N  * @param  ADCx ADC instance
N  * @param  ExternalTriggerEdge This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISING
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_FALLING
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISINGFALLING
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)
Xstatic __inline void LL_ADC_REG_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_EXTEN, ExternalTriggerEdge);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x3UL << (10U))))) | (ExternalTriggerEdge))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion trigger polarity.
N  * @note   Applicable only for trigger source set to external trigger.
N  * @rmtoll CFGR     EXTEN          LL_ADC_REG_GetTriggerEdge
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISING
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_FALLING
N  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISINGFALLING
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerEdge(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetTriggerEdge(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN));
X  return (uint32_t)(((ADCx->CFGR) & ((0x3UL << (10U)))));
N}
N
N/**
N  * @brief  Set ADC group regular sequencer length and scan direction.
N  * @note   Description of ADC group regular sequencer features:
N  *         - For devices with sequencer fully configurable
N  *           (function "LL_ADC_REG_SetSequencerRanks()" available):
N  *           sequencer length and each rank affectation to a channel
N  *           are configurable.
N  *           This function performs configuration of:
N  *           - Sequence length: Number of ranks in the scan sequence.
N  *           - Sequence direction: Unless specified in parameters, sequencer
N  *             scan direction is forward (from rank 1 to rank n).
N  *           Sequencer ranks are selected using
N  *           function "LL_ADC_REG_SetSequencerRanks()".
N  *         - For devices with sequencer not fully configurable
N  *           (function "LL_ADC_REG_SetSequencerChannels()" available):
N  *           sequencer length and each rank affectation to a channel
N  *           are defined by channel number.
N  *           This function performs configuration of:
N  *           - Sequence length: Number of ranks in the scan sequence is
N  *             defined by number of channels set in the sequence,
N  *             rank of each channel is fixed by channel HW number.
N  *             (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
N  *           - Sequence direction: Unless specified in parameters, sequencer
N  *             scan direction is forward (from lowest channel number to
N  *             highest channel number).
N  *           Sequencer ranks are selected using
N  *           function "LL_ADC_REG_SetSequencerChannels()".
N  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
N  *         ADC conversion on only 1 channel.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll SQR1     L              LL_ADC_REG_SetSequencerLength
N  * @param  ADCx ADC instance
N  * @param  SequencerNbRanks This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_DISABLE
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetSequencerLength(ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)
Xstatic __inline void LL_ADC_REG_SetSequencerLength(ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)
N{
N  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
X  (((ADCx->SQR1)) = ((((((ADCx->SQR1))) & (~((0xFUL << (0U))))) | (SequencerNbRanks))));
N}
N
N/**
N  * @brief  Get ADC group regular sequencer length and scan direction.
N  * @note   Description of ADC group regular sequencer features:
N  *         - For devices with sequencer fully configurable
N  *           (function "LL_ADC_REG_SetSequencerRanks()" available):
N  *           sequencer length and each rank affectation to a channel
N  *           are configurable.
N  *           This function retrieves:
N  *           - Sequence length: Number of ranks in the scan sequence.
N  *           - Sequence direction: Unless specified in parameters, sequencer
N  *             scan direction is forward (from rank 1 to rank n).
N  *           Sequencer ranks are selected using
N  *           function "LL_ADC_REG_SetSequencerRanks()".
N  *         - For devices with sequencer not fully configurable
N  *           (function "LL_ADC_REG_SetSequencerChannels()" available):
N  *           sequencer length and each rank affectation to a channel
N  *           are defined by channel number.
N  *           This function retrieves:
N  *           - Sequence length: Number of ranks in the scan sequence is
N  *             defined by number of channels set in the sequence,
N  *             rank of each channel is fixed by channel HW number.
N  *             (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
N  *           - Sequence direction: Unless specified in parameters, sequencer
N  *             scan direction is forward (from lowest channel number to
N  *             highest channel number).
N  *           Sequencer ranks are selected using
N  *           function "LL_ADC_REG_SetSequencerChannels()".
N  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
N  *         ADC conversion on only 1 channel.
N  * @rmtoll SQR1     L              LL_ADC_REG_GetSequencerLength
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_DISABLE
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerLength(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetSequencerLength(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->SQR1, ADC_SQR1_L));
X  return (uint32_t)(((ADCx->SQR1) & ((0xFUL << (0U)))));
N}
N
N/**
N  * @brief  Set ADC group regular sequencer discontinuous mode:
N  *         sequence subdivided and scan conversions interrupted every selected
N  *         number of ranks.
N  * @note   It is not possible to enable both ADC group regular 
N  *         continuous mode and sequencer discontinuous mode.
N  * @note   It is not possible to enable both ADC auto-injected mode
N  *         and ADC group regular sequencer discontinuous mode.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR     DISCEN         LL_ADC_REG_SetSequencerDiscont\n
N  *         CFGR     DISCNUM        LL_ADC_REG_SetSequencerDiscont
N  * @param  ADCx ADC instance
N  * @param  SeqDiscont This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_DISABLE
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_1RANK
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_2RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_3RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_4RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_5RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_6RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_7RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_8RANKS
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont)
Xstatic __inline void LL_ADC_REG_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DISCEN | ADC_CFGR_DISCNUM, SeqDiscont);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (16U)) | (0x7UL << (17U))))) | (SeqDiscont))));
N}
N
N/**
N  * @brief  Get ADC group regular sequencer discontinuous mode:
N  *         sequence subdivided and scan conversions interrupted every selected
N  *         number of ranks.
N  * @rmtoll CFGR     DISCEN         LL_ADC_REG_GetSequencerDiscont\n
N  *         CFGR     DISCNUM        LL_ADC_REG_GetSequencerDiscont
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_DISABLE
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_1RANK
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_2RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_3RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_4RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_5RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_6RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_7RANKS
N  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_8RANKS
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerDiscont(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetSequencerDiscont(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_DISCEN | ADC_CFGR_DISCNUM));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (16U)) | (0x7UL << (17U)))));
N}
N
N/**
N  * @brief  Set ADC group regular sequence: channel on the selected
N  *         scan sequence rank.
N  * @note   This function performs configuration of:
N  *         - Channels ordering into each rank of scan sequence:
N  *           whatever channel can be placed into whatever rank.
N  * @note   On this STM32 serie, ADC group regular sequencer is
N  *         fully configurable: sequencer length and each rank
N  *         affectation to a channel are configurable.
N  *         Refer to description of function @ref LL_ADC_REG_SetSequencerLength().
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   On this STM32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref LL_ADC_SetCommonPathInternalCh().
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll SQR1     SQ1            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR1     SQ2            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR1     SQ3            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR1     SQ4            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR2     SQ5            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR2     SQ6            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR2     SQ7            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR2     SQ8            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR2     SQ9            LL_ADC_REG_SetSequencerRanks\n
N  *         SQR3     SQ10           LL_ADC_REG_SetSequencerRanks\n
N  *         SQR3     SQ11           LL_ADC_REG_SetSequencerRanks\n
N  *         SQR3     SQ12           LL_ADC_REG_SetSequencerRanks\n
N  *         SQR3     SQ13           LL_ADC_REG_SetSequencerRanks\n
N  *         SQR3     SQ14           LL_ADC_REG_SetSequencerRanks\n
N  *         SQR4     SQ15           LL_ADC_REG_SetSequencerRanks\n
N  *         SQR4     SQ16           LL_ADC_REG_SetSequencerRanks
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_RANK_1
N  *         @arg @ref LL_ADC_REG_RANK_2
N  *         @arg @ref LL_ADC_REG_RANK_3
N  *         @arg @ref LL_ADC_REG_RANK_4
N  *         @arg @ref LL_ADC_REG_RANK_5
N  *         @arg @ref LL_ADC_REG_RANK_6
N  *         @arg @ref LL_ADC_REG_RANK_7
N  *         @arg @ref LL_ADC_REG_RANK_8
N  *         @arg @ref LL_ADC_REG_RANK_9
N  *         @arg @ref LL_ADC_REG_RANK_10
N  *         @arg @ref LL_ADC_REG_RANK_11
N  *         @arg @ref LL_ADC_REG_RANK_12
N  *         @arg @ref LL_ADC_REG_RANK_13
N  *         @arg @ref LL_ADC_REG_RANK_14
N  *         @arg @ref LL_ADC_REG_RANK_15
N  *         @arg @ref LL_ADC_REG_RANK_16
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
Xstatic __inline void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
N{
N  /* Set bits with content of parameter "Channel" with bits position          */
N  /* in register and register position depending on parameter "Rank".         */
N  /* Parameters "Rank" and "Channel" are used with masks because containing   */
N  /* other bits reserved for other purpose.                                   */
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, __ADC_MASK_SHIFT(Rank, ADC_REG_SQRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->SQR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  MODIFY_REG(*preg,
N             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
N             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
X  (((*preg)) = ((((((*preg))) & (~(((0x1FUL << (0U))) << (Rank & (((0x1FUL << (0U)))))))) | (((Channel & ((0x1FUL << (26U)))) >> (26U)) << (Rank & (((0x1FUL << (0U)))))))));
N}
N
N/**
N  * @brief  Get ADC group regular sequence: channel on the selected
N  *         scan sequence rank.
N  * @note   On this STM32 serie, ADC group regular sequencer is
N  *         fully configurable: sequencer length and each rank
N  *         affectation to a channel are configurable.
N  *         Refer to description of function @ref LL_ADC_REG_SetSequencerLength().
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   Usage of the returned channel number:
N  *         - To reinject this channel into another function LL_ADC_xxx:
N  *           the returned channel number is only partly formatted on definition
N  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
N  *           with parts of literals LL_ADC_CHANNEL_x or using
N  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Then the selected literal LL_ADC_CHANNEL_x can be used
N  *           as parameter for another function.
N  *         - To get the channel number in decimal format:
N  *           process the returned value with the helper macro
N  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  * @rmtoll SQR1     SQ1            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR1     SQ2            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR1     SQ3            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR1     SQ4            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR2     SQ5            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR2     SQ6            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR2     SQ7            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR2     SQ8            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR2     SQ9            LL_ADC_REG_GetSequencerRanks\n
N  *         SQR3     SQ10           LL_ADC_REG_GetSequencerRanks\n
N  *         SQR3     SQ11           LL_ADC_REG_GetSequencerRanks\n
N  *         SQR3     SQ12           LL_ADC_REG_GetSequencerRanks\n
N  *         SQR3     SQ13           LL_ADC_REG_GetSequencerRanks\n
N  *         SQR3     SQ14           LL_ADC_REG_GetSequencerRanks\n
N  *         SQR4     SQ15           LL_ADC_REG_GetSequencerRanks\n
N  *         SQR4     SQ16           LL_ADC_REG_GetSequencerRanks
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_RANK_1
N  *         @arg @ref LL_ADC_REG_RANK_2
N  *         @arg @ref LL_ADC_REG_RANK_3
N  *         @arg @ref LL_ADC_REG_RANK_4
N  *         @arg @ref LL_ADC_REG_RANK_5
N  *         @arg @ref LL_ADC_REG_RANK_6
N  *         @arg @ref LL_ADC_REG_RANK_7
N  *         @arg @ref LL_ADC_REG_RANK_8
N  *         @arg @ref LL_ADC_REG_RANK_9
N  *         @arg @ref LL_ADC_REG_RANK_10
N  *         @arg @ref LL_ADC_REG_RANK_11
N  *         @arg @ref LL_ADC_REG_RANK_12
N  *         @arg @ref LL_ADC_REG_RANK_13
N  *         @arg @ref LL_ADC_REG_RANK_14
N  *         @arg @ref LL_ADC_REG_RANK_15
N  *         @arg @ref LL_ADC_REG_RANK_16
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).\n
N  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
N  *                      comparison with internal channel parameter to be done
N  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint32_t LL_ADC_REG_GetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, __ADC_MASK_SHIFT(Rank, ADC_REG_SQRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->SQR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  return (uint32_t) ((READ_BIT(*preg,
N                              ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK))
X  return (uint32_t) ((((*preg) & (((0x1FUL << (0U))) << (Rank & (((0x1FUL << (0U)))))))
N                     >> (Rank & ADC_REG_RANK_ID_SQRX_MASK)) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS
X                     >> (Rank & (((0x1FUL << (0U)))))) << (26U)
N                    );
N}
N
N/**
N  * @brief  Set ADC continuous conversion mode on ADC group regular.
N  * @note   Description of ADC continuous conversion mode:
N  *         - single mode: one conversion per trigger
N  *         - continuous mode: after the first trigger, following
N  *           conversions launched successively automatically.
N  * @note   It is not possible to enable both ADC group regular 
N  *         continuous mode and sequencer discontinuous mode.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR     CONT           LL_ADC_REG_SetContinuousMode
N  * @param  ADCx ADC instance
N  * @param  Continuous This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_CONV_SINGLE
N  *         @arg @ref LL_ADC_REG_CONV_CONTINUOUS
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetContinuousMode(ADC_TypeDef *ADCx, uint32_t Continuous)
Xstatic __inline void LL_ADC_REG_SetContinuousMode(ADC_TypeDef *ADCx, uint32_t Continuous)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_CONT, Continuous);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (13U))))) | (Continuous))));
N}
N
N/**
N  * @brief  Get ADC continuous conversion mode on ADC group regular.
N  * @note   Description of ADC continuous conversion mode:
N  *         - single mode: one conversion per trigger
N  *         - continuous mode: after the first trigger, following
N  *           conversions launched successively automatically.
N  * @rmtoll CFGR     CONT           LL_ADC_REG_GetContinuousMode
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_CONV_SINGLE
N  *         @arg @ref LL_ADC_REG_CONV_CONTINUOUS
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetContinuousMode(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetContinuousMode(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_CONT));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (13U)))));
N}
N
N/**
N  * @brief  Set ADC group regular conversion data transfer: no transfer or
N  *         transfer by DMA, and DMA requests mode.
N  * @note   If transfer by DMA selected, specifies the DMA requests
N  *         mode:
N  *         - Limited mode (One shot mode): DMA transfer requests are stopped
N  *           when number of DMA data transfers (number of
N  *           ADC conversions) is reached.
N  *           This ADC mode is intended to be used with DMA mode non-circular.
N  *         - Unlimited mode: DMA transfer requests are unlimited,
N  *           whatever number of DMA data transfers (number of
N  *           ADC conversions).
N  *           This ADC mode is intended to be used with DMA mode circular.
N  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
N  *         mode non-circular:
N  *         when DMA transfers size will be reached, DMA will stop transfers of
N  *         ADC conversions data ADC will raise an overrun error
N  *        (overrun flag and interruption if enabled).
N  * @note   For devices with several ADC instances: ADC multimode DMA
N  *         settings are available using function @ref LL_ADC_SetMultiDMATransfer().
N  * @note   To configure DMA source address (peripheral address),
N  *         use function @ref LL_ADC_DMA_GetRegAddr().
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     DMAEN          LL_ADC_REG_SetDMATransfer\n
N  *         CFGR     DMACFG         LL_ADC_REG_SetDMATransfer
N  * @param  ADCx ADC instance
N  * @param  DMATransfer This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_NONE
N  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_LIMITED
N  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_UNLIMITED
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetDMATransfer(ADC_TypeDef *ADCx, uint32_t DMATransfer)
Xstatic __inline void LL_ADC_REG_SetDMATransfer(ADC_TypeDef *ADCx, uint32_t DMATransfer)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMAEN | ADC_CFGR_DMACFG, DMATransfer);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (0U)) | (0x1UL << (1U))))) | (DMATransfer))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data transfer: no transfer or
N  *         transfer by DMA, and DMA requests mode.
N  * @note   If transfer by DMA selected, specifies the DMA requests
N  *         mode:
N  *         - Limited mode (One shot mode): DMA transfer requests are stopped
N  *           when number of DMA data transfers (number of
N  *           ADC conversions) is reached.
N  *           This ADC mode is intended to be used with DMA mode non-circular.
N  *         - Unlimited mode: DMA transfer requests are unlimited,
N  *           whatever number of DMA data transfers (number of
N  *           ADC conversions).
N  *           This ADC mode is intended to be used with DMA mode circular.
N  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
N  *         mode non-circular:
N  *         when DMA transfers size will be reached, DMA will stop transfers of
N  *         ADC conversions data ADC will raise an overrun error
N  *         (overrun flag and interruption if enabled).
N  * @note   For devices with several ADC instances: ADC multimode DMA
N  *         settings are available using function @ref LL_ADC_GetMultiDMATransfer().
N  * @note   To configure DMA source address (peripheral address),
N  *         use function @ref LL_ADC_DMA_GetRegAddr().
N  * @rmtoll CFGR     DMAEN          LL_ADC_REG_GetDMATransfer\n
N  *         CFGR     DMACFG         LL_ADC_REG_GetDMATransfer
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_NONE
N  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_LIMITED
N  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_UNLIMITED
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetDMATransfer(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetDMATransfer(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_DMAEN | ADC_CFGR_DMACFG));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (0U)) | (0x1UL << (1U)))));
N}
N
N#if defined(ADC_CFGR_DFSDMCFG) &&defined(DFSDM1_Channel0)
X#if 0L &&0L
S/**
S  * @brief  Set ADC group regular conversion data transfer to DFSDM.
S  * @note   DFSDM transfer cannot be used if DMA transfer is enabled.
S  * @note   To configure DFSDM source address (peripheral address),
S  *         use the same function as for DMA transfer:
S  *         function @ref LL_ADC_DMA_GetRegAddr().
S  * @note   On this STM32 serie, setting of this feature is conditioned to
S  *         ADC state:
S  *         ADC must be disabled or enabled without conversion on going
S  *         on either groups regular or injected.
S  * @rmtoll CFGR     DFSDMCFG       LL_ADC_REG_GetDFSDMTransfer
S  * @param  ADCx ADC instance
S  * @param  DFSDMTransfer This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_REG_DFSDM_TRANSFER_NONE
S  *         @arg @ref LL_ADC_REG_DFSDM_TRANSFER_ENABLE
S  * @retval None
S  */
S__STATIC_INLINE void LL_ADC_REG_SetDFSDMTransfer(ADC_TypeDef *ADCx, uint32_t DFSDMTransfer)
S{
S  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DFSDMCFG, DFSDMTransfer);
S}
S
S/**
S  * @brief  Get ADC group regular conversion data transfer to DFSDM.
S  * @rmtoll CFGR     DFSDMCFG       LL_ADC_REG_GetDFSDMTransfer
S  * @param  ADCx ADC instance
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_ADC_REG_DFSDM_TRANSFER_NONE
S  *         @arg @ref LL_ADC_REG_DFSDM_TRANSFER_ENABLE
S  */
S__STATIC_INLINE uint32_t LL_ADC_REG_GetDFSDMTransfer(ADC_TypeDef *ADCx)
S{
S  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_DFSDMCFG));
S}
N#endif
N
N/**
N  * @brief  Set ADC group regular behavior in case of overrun:
N  *         data preserved or overwritten.
N  * @note   Compatibility with devices without feature overrun:
N  *         other devices without this feature have a behavior
N  *         equivalent to data overwritten.
N  *         The default setting of overrun is data preserved.
N  *         Therefore, for compatibility with all devices, parameter
N  *         overrun should be set to data overwritten.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @rmtoll CFGR     OVRMOD         LL_ADC_REG_SetOverrun
N  * @param  ADCx ADC instance
N  * @param  Overrun This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_REG_OVR_DATA_PRESERVED
N  *         @arg @ref LL_ADC_REG_OVR_DATA_OVERWRITTEN
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_SetOverrun(ADC_TypeDef *ADCx, uint32_t Overrun)
Xstatic __inline void LL_ADC_REG_SetOverrun(ADC_TypeDef *ADCx, uint32_t Overrun)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_OVRMOD, Overrun);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (12U))))) | (Overrun))));
N}
N
N/**
N  * @brief  Get ADC group regular behavior in case of overrun:
N  *         data preserved or overwritten.
N  * @rmtoll CFGR     OVRMOD         LL_ADC_REG_GetOverrun
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_REG_OVR_DATA_PRESERVED
N  *         @arg @ref LL_ADC_REG_OVR_DATA_OVERWRITTEN
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_GetOverrun(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_GetOverrun(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_OVRMOD));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (12U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_Group_Injected Configuration of ADC hierarchical scope: group injected
N  * @{
N  */
N
N/**
N  * @brief  Set ADC group injected conversion trigger source:
N  *         internal (SW start) or from external IP (timer event,
N  *         external interrupt line).
N  * @note   On this STM32 serie, setting trigger source to external trigger
N  *         also set trigger polarity to rising edge 
N  *         (default setting for compatibility with some ADC on other
N  *         STM32 families having this setting set by HW default value).
N  *         In case of need to modify trigger edge, use
N  *         function @ref LL_ADC_INJ_SetTriggerEdge().
N  * @note   Availability of parameters of trigger sources from timer 
N  *         depends on timers availability on the selected device.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must not be disabled. Can be enabled with or without conversion
N  *         on going on either groups regular or injected.
N  * @rmtoll JSQR     JEXTSEL        LL_ADC_INJ_SetTriggerSource\n
N  *         JSQR     JEXTEN         LL_ADC_INJ_SetTriggerSource
N  * @param  ADCx ADC instance
N  * @param  TriggerSource This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_SOFTWARE
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_CH1
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH1
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH3
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM6_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM15_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE15
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
Xstatic __inline void LL_ADC_INJ_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
N{
N  MODIFY_REG(ADCx->JSQR, ADC_JSQR_JEXTSEL | ADC_JSQR_JEXTEN, TriggerSource);
X  (((ADCx->JSQR)) = ((((((ADCx->JSQR))) & (~((0xFUL << (2U)) | (0x3UL << (6U))))) | (TriggerSource))));
N}
N
N/**
N  * @brief  Get ADC group injected conversion trigger source:
N  *         internal (SW start) or from external IP (timer event,
N  *         external interrupt line).
N  * @note   To determine whether group injected trigger source is
N  *         internal (SW start) or external, without detail
N  *         of which peripheral is selected as external trigger,
N  *         (equivalent to 
N  *         "if(LL_ADC_INJ_GetTriggerSource(ADC1) == LL_ADC_INJ_TRIG_SOFTWARE)")
N  *         use function @ref LL_ADC_INJ_IsTriggerSourceSWStart.
N  * @note   Availability of parameters of trigger sources from timer 
N  *         depends on timers availability on the selected device.
N  * @rmtoll JSQR     JEXTSEL        LL_ADC_INJ_GetTriggerSource\n
N  *         JSQR     JEXTEN         LL_ADC_INJ_GetTriggerSource
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_SOFTWARE
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_CH1
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH1
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH3
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM6_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM15_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE15
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetTriggerSource(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_GetTriggerSource(ADC_TypeDef *ADCx)
N{
N  register uint32_t TriggerSource = READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTSEL | ADC_JSQR_JEXTEN);
X  register uint32_t TriggerSource = ((ADCx->JSQR) & ((0xFUL << (2U)) | (0x3UL << (6U))));
N  
N  /* Value for shift of {0; 4; 8; 12} depending on value of bitfield          */
N  /* corresponding to ADC_JSQR_JEXTEN {0; 1; 2; 3}.                           */
N  register uint32_t ShiftJexten = ((TriggerSource & ADC_JSQR_JEXTEN) >> (ADC_INJ_TRIG_EXTEN_BITOFFSET_POS - 2U));
X  register uint32_t ShiftJexten = ((TriggerSource & (0x3UL << (6U))) >> (( 6U) - 2U));
N  
N  /* Set bitfield corresponding to ADC_JSQR_JEXTEN and ADC_JSQR_JEXTSEL       */
N  /* to match with triggers literals definition.                              */
N  return ((TriggerSource
N           & (ADC_INJ_TRIG_SOURCE_MASK >> ShiftJexten) & ADC_JSQR_JEXTSEL)
X           & (((((0x00000000U) & (0xFUL << (2U))) << (4U * 0U)) | (((0xFUL << (2U))) << (4U * 1U)) | (((0xFUL << (2U))) << (4U * 2U)) | (((0xFUL << (2U))) << (4U * 3U)) ) >> ShiftJexten) & (0xFUL << (2U)))
N          | ((ADC_INJ_TRIG_EDGE_MASK >> ShiftJexten) & ADC_JSQR_JEXTEN)
X          | ((((((0x00000000U) & (0x3UL << (6U))) << (4U * 0U)) | ((((0x1UL << (6U)))) << (4U * 1U)) | ((((0x1UL << (6U)))) << (4U * 2U)) | ((((0x1UL << (6U)))) << (4U * 3U)) ) >> ShiftJexten) & (0x3UL << (6U)))
N         );
N}
N
N/**
N  * @brief  Get ADC group injected conversion trigger source internal (SW start)
N            or external
N  * @note   In case of group injected trigger source set to external trigger,
N  *         to determine which peripheral is selected as external trigger,
N  *         use function @ref LL_ADC_INJ_GetTriggerSource.
N  * @rmtoll JSQR     JEXTEN         LL_ADC_INJ_IsTriggerSourceSWStart
N  * @param  ADCx ADC instance
N  * @retval Value "0" if trigger source external trigger
N  *         Value "1" if trigger source SW start.
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_IsTriggerSourceSWStart(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_IsTriggerSourceSWStart(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN));
X  return (uint32_t)(((ADCx->JSQR) & ((0x3UL << (6U)))) == ((0x00000000U) & (0x3UL << (6U))));
N}
N
N/**
N  * @brief  Set ADC group injected conversion trigger polarity.
N  *         Applicable only for trigger source set to external trigger.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must not be disabled. Can be enabled with or without conversion
N  *         on going on either groups regular or injected.
N  * @rmtoll JSQR     JEXTEN         LL_ADC_INJ_SetTriggerEdge
N  * @param  ADCx ADC instance
N  * @param  ExternalTriggerEdge This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISING
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_FALLING
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISINGFALLING
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)
Xstatic __inline void LL_ADC_INJ_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)
N{
N  MODIFY_REG(ADCx->JSQR, ADC_JSQR_JEXTEN, ExternalTriggerEdge);
X  (((ADCx->JSQR)) = ((((((ADCx->JSQR))) & (~((0x3UL << (6U))))) | (ExternalTriggerEdge))));
N}
N
N/**
N  * @brief  Get ADC group injected conversion trigger polarity.
N  *         Applicable only for trigger source set to external trigger.
N  * @rmtoll JSQR     JEXTEN         LL_ADC_INJ_GetTriggerEdge
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISING
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_FALLING
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISINGFALLING
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetTriggerEdge(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_GetTriggerEdge(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN));
X  return (uint32_t)(((ADCx->JSQR) & ((0x3UL << (6U)))));
N}
N
N/**
N  * @brief  Set ADC group injected sequencer length and scan direction.
N  * @note   This function performs configuration of:
N  *         - Sequence length: Number of ranks in the scan sequence.
N  *         - Sequence direction: Unless specified in parameters, sequencer
N  *           scan direction is forward (from rank 1 to rank n).
N  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
N  *         ADC conversion on only 1 channel.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must not be disabled. Can be enabled with or without conversion
N  *         on going on either groups regular or injected.
N  * @rmtoll JSQR     JL             LL_ADC_INJ_SetSequencerLength
N  * @param  ADCx ADC instance
N  * @param  SequencerNbRanks This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_DISABLE
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetSequencerLength(ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)
Xstatic __inline void LL_ADC_INJ_SetSequencerLength(ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)
N{
N  MODIFY_REG(ADCx->JSQR, ADC_JSQR_JL, SequencerNbRanks);
X  (((ADCx->JSQR)) = ((((((ADCx->JSQR))) & (~((0x3UL << (0U))))) | (SequencerNbRanks))));
N}
N
N/**
N  * @brief  Get ADC group injected sequencer length and scan direction.
N  * @note   This function retrieves:
N  *         - Sequence length: Number of ranks in the scan sequence.
N  *         - Sequence direction: Unless specified in parameters, sequencer
N  *           scan direction is forward (from rank 1 to rank n).
N  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
N  *         ADC conversion on only 1 channel.
N  * @rmtoll JSQR     JL             LL_ADC_INJ_GetSequencerLength
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_DISABLE
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetSequencerLength(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_GetSequencerLength(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->JSQR, ADC_JSQR_JL));
X  return (uint32_t)(((ADCx->JSQR) & ((0x3UL << (0U)))));
N}
N
N/**
N  * @brief  Set ADC group injected sequencer discontinuous mode:
N  *         sequence subdivided and scan conversions interrupted every selected
N  *         number of ranks.
N  * @note   It is not possible to enable both ADC group injected
N  *         auto-injected mode and sequencer discontinuous mode.
N  * @rmtoll CFGR     JDISCEN        LL_ADC_INJ_SetSequencerDiscont
N  * @param  ADCx ADC instance
N  * @param  SeqDiscont This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_DISABLE
N  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_1RANK
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont)
Xstatic __inline void LL_ADC_INJ_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JDISCEN, SeqDiscont);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (20U))))) | (SeqDiscont))));
N}
N
N/**
N  * @brief  Get ADC group injected sequencer discontinuous mode:
N  *         sequence subdivided and scan conversions interrupted every selected
N  *         number of ranks.
N  * @rmtoll CFGR     JDISCEN        LL_ADC_INJ_GetSequencerDiscont
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_DISABLE
N  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_1RANK
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetSequencerDiscont(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_GetSequencerDiscont(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JDISCEN));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (20U)))));
N}
N
N/**
N  * @brief  Set ADC group injected sequence: channel on the selected
N  *         sequence rank.
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   On this STM32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref LL_ADC_SetCommonPathInternalCh().
N  * @note   On STM32L4, some fast channels are available: fast analog inputs
N  *         coming from GPIO pads (ADC_IN1..5).
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must not be disabled. Can be enabled with or without conversion
N  *         on going on either groups regular or injected.
N  * @rmtoll JSQR     JSQ1           LL_ADC_INJ_SetSequencerRanks\n
N  *         JSQR     JSQ2           LL_ADC_INJ_SetSequencerRanks\n
N  *         JSQR     JSQ3           LL_ADC_INJ_SetSequencerRanks\n
N  *         JSQR     JSQ4           LL_ADC_INJ_SetSequencerRanks
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
Xstatic __inline void LL_ADC_INJ_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
N{
N  /* Set bits with content of parameter "Channel" with bits position          */
N  /* in register depending on parameter "Rank".                               */
N  /* Parameters "Rank" and "Channel" are used with masks because containing   */
N  /* other bits reserved for other purpose.                                   */
N  MODIFY_REG(ADCx->JSQR,
N             (ADC_CHANNEL_ID_NUMBER_MASK >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_INJ_RANK_ID_JSQR_MASK),
N             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_INJ_RANK_ID_JSQR_MASK));
X  (((ADCx->JSQR)) = ((((((ADCx->JSQR))) & (~((((0x1FUL << (26U))) >> (26U)) << (Rank & (((0x1FUL << (0U)))))))) | (((Channel & ((0x1FUL << (26U)))) >> (26U)) << (Rank & (((0x1FUL << (0U)))))))));
N}
N
N/**
N  * @brief  Get ADC group injected sequence: channel on the selected
N  *         sequence rank.
N  * @note   Depending on devices and packages, some channels may not be available.
N  *         Refer to device datasheet for channels availability.
N  * @note   Usage of the returned channel number:
N  *         - To reinject this channel into another function LL_ADC_xxx:
N  *           the returned channel number is only partly formatted on definition
N  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
N  *           with parts of literals LL_ADC_CHANNEL_x or using
N  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Then the selected literal LL_ADC_CHANNEL_x can be used
N  *           as parameter for another function.
N  *         - To get the channel number in decimal format:
N  *           process the returned value with the helper macro
N  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  * @rmtoll JSQR     JSQ1           LL_ADC_INJ_GetSequencerRanks\n
N  *         JSQR     JSQ2           LL_ADC_INJ_GetSequencerRanks\n
N  *         JSQR     JSQ3           LL_ADC_INJ_GetSequencerRanks\n
N  *         JSQR     JSQ4           LL_ADC_INJ_GetSequencerRanks
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).\n
N  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
N  *                      comparison with internal channel parameter to be done
N  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint32_t LL_ADC_INJ_GetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N  return (uint32_t)((READ_BIT(ADCx->JSQR,
N                             (ADC_CHANNEL_ID_NUMBER_MASK >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_INJ_RANK_ID_JSQR_MASK))
X  return (uint32_t)((((ADCx->JSQR) & ((((0x1FUL << (26U))) >> (26U)) << (Rank & (((0x1FUL << (0U)))))))
N                    >> (Rank & ADC_INJ_RANK_ID_JSQR_MASK)) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS
X                    >> (Rank & (((0x1FUL << (0U)))))) << (26U)
N                   );
N}
N
N/**
N  * @brief  Set ADC group injected conversion trigger:
N  *         independent or from ADC group regular.
N  * @note   This mode can be used to extend number of data registers
N  *         updated after one ADC conversion trigger and with data 
N  *         permanently kept (not erased by successive conversions of scan of
N  *         ADC sequencer ranks), up to 5 data registers:
N  *         1 data register on ADC group regular, 4 data registers
N  *         on ADC group injected.            
N  * @note   If ADC group injected injected trigger source is set to an
N  *         external trigger, this feature must be must be set to
N  *         independent trigger.
N  *         ADC group injected automatic trigger is compliant only with 
N  *         group injected trigger source set to SW start, without any 
N  *         further action on  ADC group injected conversion start or stop: 
N  *         in this case, ADC group injected is controlled only 
N  *         from ADC group regular.
N  * @note   It is not possible to enable both ADC group injected
N  *         auto-injected mode and sequencer discontinuous mode.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     JAUTO          LL_ADC_INJ_SetTrigAuto
N  * @param  ADCx ADC instance
N  * @param  TrigAuto This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_INDEPENDENT
N  *         @arg @ref LL_ADC_INJ_TRIG_FROM_GRP_REGULAR
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetTrigAuto(ADC_TypeDef *ADCx, uint32_t TrigAuto)
Xstatic __inline void LL_ADC_INJ_SetTrigAuto(ADC_TypeDef *ADCx, uint32_t TrigAuto)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JAUTO, TrigAuto);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (25U))))) | (TrigAuto))));
N}
N
N/**
N  * @brief  Get ADC group injected conversion trigger:
N  *         independent or from ADC group regular.
N  * @rmtoll CFGR     JAUTO          LL_ADC_INJ_GetTrigAuto
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_INDEPENDENT
N  *         @arg @ref LL_ADC_INJ_TRIG_FROM_GRP_REGULAR
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetTrigAuto(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_GetTrigAuto(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JAUTO));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (25U)))));
N}
N
N/**
N  * @brief  Set ADC group injected contexts queue mode.
N  * @note   A context is a setting of group injected sequencer:
N  *         - group injected trigger
N  *         - sequencer length
N  *         - sequencer ranks
N  *         If contexts queue is disabled:
N  *         - only 1 sequence can be configured
N  *           and is active perpetually.
N  *         If contexts queue is enabled:
N  *         - up to 2 contexts can be queued
N  *           and are checked in and out as a FIFO stack (first-in, first-out).
N  *         - If a new context is set when queues is full, error is triggered
N  *           by interruption "Injected Queue Overflow".
N  *         - Two behaviors are possible when all contexts have been processed:
N  *           the contexts queue can maintain the last context active perpetually
N  *           or can be empty and injected group triggers are disabled.
N  *         - Triggers can be only external (not internal SW start)
N  *         - Caution: The sequence must be fully configured in one time
N  *           (one write of register JSQR makes a check-in of a new context
N  *           into the queue).
N  *           Therefore functions to set separately injected trigger and
N  *           sequencer channels cannot be used, register JSQR must be set
N  *           using function @ref LL_ADC_INJ_ConfigQueueContext().
N  * @note   This parameter can be modified only when no conversion is on going
N  *         on either groups regular or injected.
N  * @note   A modification of the context mode (bit JQDIS) causes the contexts
N  *         queue to be flushed and the register JSQR is cleared.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     JQM            LL_ADC_INJ_SetQueueMode\n
N  *         CFGR     JQDIS          LL_ADC_INJ_SetQueueMode
N  * @param  ADCx ADC instance
N  * @param  QueueMode This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_QUEUE_DISABLE
N  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE
N  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_SetQueueMode(ADC_TypeDef *ADCx, uint32_t QueueMode)
Xstatic __inline void LL_ADC_INJ_SetQueueMode(ADC_TypeDef *ADCx, uint32_t QueueMode)
N{
N  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
X  (((ADCx->CFGR)) = ((((((ADCx->CFGR))) & (~((0x1UL << (21U)) | (0x1UL << (31U))))) | (QueueMode))));
N}
N
N/**
N  * @brief  Get ADC group injected context queue mode.
N  * @rmtoll CFGR     JQM            LL_ADC_INJ_GetQueueMode\n
N  *         CFGR     JQDIS          LL_ADC_INJ_GetQueueMode
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_QUEUE_DISABLE
N  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE
N  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_GetQueueMode(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_GetQueueMode(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS));
X  return (uint32_t)(((ADCx->CFGR) & ((0x1UL << (21U)) | (0x1UL << (31U)))));
N}
N
N/**
N  * @brief  Set one context on ADC group injected that will be checked in
N  *         contexts queue.
N  * @note   A context is a setting of group injected sequencer:
N  *         - group injected trigger
N  *         - sequencer length
N  *         - sequencer ranks
N  *         This function is intended to be used when contexts queue is enabled,
N  *         because the sequence must be fully configured in one time
N  *         (functions to set separately injected trigger and sequencer channels
N  *         cannot be used):
N  *         Refer to function @ref LL_ADC_INJ_SetQueueMode().
N  * @note   In the contexts queue, only the active context can be read.
N  *         The parameters of this function can be read using functions:
N  *         @arg @ref LL_ADC_INJ_GetTriggerSource()
N  *         @arg @ref LL_ADC_INJ_GetTriggerEdge()
N  *         @arg @ref LL_ADC_INJ_GetSequencerRanks()
N  * @note   On this STM32 serie, to measure internal channels (VrefInt,
N  *         TempSensor, ...), measurement paths to internal channels must be
N  *         enabled separately.
N  *         This can be done using function @ref LL_ADC_SetCommonPathInternalCh().
N  * @note   On STM32L4, some fast channels are available: fast analog inputs
N  *         coming from GPIO pads (ADC_IN1..5).
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must not be disabled. Can be enabled with or without conversion
N  *         on going on either groups regular or injected.
N  * @rmtoll JSQR     JEXTSEL        LL_ADC_INJ_ConfigQueueContext\n
N  *         JSQR     JEXTEN         LL_ADC_INJ_ConfigQueueContext\n
N  *         JSQR     JL             LL_ADC_INJ_ConfigQueueContext\n
N  *         JSQR     JSQ1           LL_ADC_INJ_ConfigQueueContext\n
N  *         JSQR     JSQ2           LL_ADC_INJ_ConfigQueueContext\n
N  *         JSQR     JSQ3           LL_ADC_INJ_ConfigQueueContext\n
N  *         JSQR     JSQ4           LL_ADC_INJ_ConfigQueueContext
N  * @param  ADCx ADC instance
N  * @param  TriggerSource This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_SOFTWARE
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_CH1
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH1
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH3
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM6_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH4
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM15_TRGO
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE15
N  * @param  ExternalTriggerEdge This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISING
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_FALLING
N  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISINGFALLING
N  *
N  *         Note: This parameter is discarded in case of SW start:
N  *               parameter "TriggerSource" set to "LL_ADC_INJ_TRIG_SOFTWARE".
N  * @param  SequencerNbRanks This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_DISABLE
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS
N  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS
N  * @param  Rank1_Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @param  Rank2_Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @param  Rank3_Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @param  Rank4_Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_ConfigQueueContext(ADC_TypeDef *ADCx,
Xstatic __inline void LL_ADC_INJ_ConfigQueueContext(ADC_TypeDef *ADCx,
N                                                   uint32_t TriggerSource,
N                                                   uint32_t ExternalTriggerEdge,
N                                                   uint32_t SequencerNbRanks,
N                                                   uint32_t Rank1_Channel,
N                                                   uint32_t Rank2_Channel,
N                                                   uint32_t Rank3_Channel,
N                                                   uint32_t Rank4_Channel)
N{
N  /* Set bits with content of parameter "Rankx_Channel" with bits position    */
N  /* in register depending on literal "LL_ADC_INJ_RANK_x".                    */
N  /* Parameters "Rankx_Channel" and "LL_ADC_INJ_RANK_x" are used with masks   */
N  /* because containing other bits reserved for other purpose.                */
N  /* If parameter "TriggerSource" is set to SW start, then parameter          */
N  /* "ExternalTriggerEdge" is discarded.                                      */
N  register uint32_t is_trigger_not_sw = (uint32_t)(TriggerSource != LL_ADC_INJ_TRIG_SOFTWARE);
X  register uint32_t is_trigger_not_sw = (uint32_t)(TriggerSource != (0x00000000U));
N  MODIFY_REG(ADCx->JSQR           ,
N             ADC_JSQR_JEXTSEL |
N             ADC_JSQR_JEXTEN  |
N             ADC_JSQR_JSQ4    |
N             ADC_JSQR_JSQ3    |
N             ADC_JSQR_JSQ2    |
N             ADC_JSQR_JSQ1    |
N             ADC_JSQR_JL          ,
N             TriggerSource       |
N             (ExternalTriggerEdge * (is_trigger_not_sw)) |
N             (((Rank4_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (LL_ADC_INJ_RANK_4 & ADC_INJ_RANK_ID_JSQR_MASK)) |
N             (((Rank3_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (LL_ADC_INJ_RANK_3 & ADC_INJ_RANK_ID_JSQR_MASK)) |
N             (((Rank2_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (LL_ADC_INJ_RANK_2 & ADC_INJ_RANK_ID_JSQR_MASK)) |
N             (((Rank1_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (LL_ADC_INJ_RANK_1 & ADC_INJ_RANK_ID_JSQR_MASK)) |
N             SequencerNbRanks
N            );
X  (((ADCx->JSQR)) = ((((((ADCx->JSQR))) & (~((0xFUL << (2U)) | (0x3UL << (6U)) | (0x1FUL << (26U)) | (0x1FUL << (20U)) | (0x1FUL << (14U)) | (0x1FUL << (8U)) | (0x3UL << (0U))))) | (TriggerSource | (ExternalTriggerEdge * (is_trigger_not_sw)) | (((Rank4_Channel & ((0x1FUL << (26U)))) >> (26U)) << (((0x00000300U) | (26U)) & (((0x1FUL << (0U)))))) | (((Rank3_Channel & ((0x1FUL << (26U)))) >> (26U)) << (((0x00000200U) | (20U)) & (((0x1FUL << (0U)))))) | (((Rank2_Channel & ((0x1FUL << (26U)))) >> (26U)) << (((0x00000100U) | (14U)) & (((0x1FUL << (0U)))))) | (((Rank1_Channel & ((0x1FUL << (26U)))) >> (26U)) << (((0x00000000U) | ( 8U)) & (((0x1FUL << (0U)))))) | SequencerNbRanks))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_Channels Configuration of ADC hierarchical scope: channels
N  * @{
N  */
N
N/**
N  * @brief  Set sampling time of the selected ADC channel
N  *         Unit: ADC clock cycles.
N  * @note   On this device, sampling time is on channel scope: independently
N  *         of channel mapped on ADC group regular or injected.
N  * @note   In case of internal channel (VrefInt, TempSensor, ...) to be
N  *         converted:
N  *         sampling time constraints must be respected (sampling time can be
N  *         adjusted in function of ADC clock frequency and sampling time
N  *         setting).
N  *         Refer to device datasheet for timings values (parameters TS_vrefint,
N  *         TS_temp, ...).
N  * @note   Conversion time is the addition of sampling time and processing time.
N  *         On this STM32 serie, ADC processing time is:
N  *         - 12.5 ADC clock cycles at ADC resolution 12 bits
N  *         - 10.5 ADC clock cycles at ADC resolution 10 bits
N  *         - 8.5 ADC clock cycles at ADC resolution 8 bits
N  *         - 6.5 ADC clock cycles at ADC resolution 6 bits
N  * @note   In case of ADC conversion of internal channel (VrefInt,
N  *         temperature sensor, ...), a sampling time minimum value
N  *         is required.
N  *         Refer to device datasheet.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll SMPR1    SMP0           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP1           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP2           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP3           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP4           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP5           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP6           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP7           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP8           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR1    SMP9           LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP10          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP11          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP12          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP13          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP14          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP15          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP16          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP17          LL_ADC_SetChannelSamplingTime\n
N  *         SMPR2    SMP18          LL_ADC_SetChannelSamplingTime
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @param  SamplingTime This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_SAMPLINGTIME_2CYCLES_5   (1)
N  *         @arg @ref LL_ADC_SAMPLINGTIME_6CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_12CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_24CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_47CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_92CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
N  *
N  *         (1) On some devices, ADC sampling time 2.5 ADC clock cycles
N  *             can be replaced by 3.5 ADC clock cycles.
N  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
Xstatic __inline void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
N{
N  /* Set bits with content of parameter "SamplingTime" with bits position     */
N  /* in register and register position depending on parameter "Channel".      */
N  /* Parameter "Channel" is used with masks because containing                */
N  /* other bits reserved for other purpose.                                   */
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
S  
S  MODIFY_REG(*preg,
S             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
S             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->SMPR1)) + (((((Channel) & (((0x00000000U) | (0x02000000U)))) >> (__clz(__rbit((((0x00000000U) | (0x02000000U)))))))) << 2U))));
N  
N  MODIFY_REG(*preg,
N             ADC_SMPR1_SMP0 << __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPx_BITOFFSET_MASK),
N             SamplingTime   << __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPx_BITOFFSET_MASK));
X  (((*preg)) = ((((((*preg))) & (~((0x7UL << (0U)) << (((Channel) & ((0x01F00000U))) >> (__clz(__rbit(((0x01F00000U))))))))) | (SamplingTime << (((Channel) & ((0x01F00000U))) >> (__clz(__rbit(((0x01F00000U))))))))));
N#endif
N}
N
N/**
N  * @brief  Get sampling time of the selected ADC channel
N  *         Unit: ADC clock cycles.
N  * @note   On this device, sampling time is on channel scope: independently
N  *         of channel mapped on ADC group regular or injected.
N  * @note   Conversion time is the addition of sampling time and processing time.
N  *         On this STM32 serie, ADC processing time is:
N  *         - 12.5 ADC clock cycles at ADC resolution 12 bits
N  *         - 10.5 ADC clock cycles at ADC resolution 10 bits
N  *         - 8.5 ADC clock cycles at ADC resolution 8 bits
N  *         - 6.5 ADC clock cycles at ADC resolution 6 bits
N  * @rmtoll SMPR1    SMP0           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP1           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP2           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP3           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP4           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP5           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP6           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP7           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP8           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR1    SMP9           LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP10          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP11          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP12          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP13          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP14          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP15          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP16          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP17          LL_ADC_GetChannelSamplingTime\n
N  *         SMPR2    SMP18          LL_ADC_GetChannelSamplingTime
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_0
N  *         @arg @ref LL_ADC_CHANNEL_1            (7)
N  *         @arg @ref LL_ADC_CHANNEL_2            (7)
N  *         @arg @ref LL_ADC_CHANNEL_3            (7)
N  *         @arg @ref LL_ADC_CHANNEL_4            (7)
N  *         @arg @ref LL_ADC_CHANNEL_5            (7)
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  *         @arg @ref LL_ADC_CHANNEL_16
N  *         @arg @ref LL_ADC_CHANNEL_17
N  *         @arg @ref LL_ADC_CHANNEL_18
N  *         @arg @ref LL_ADC_CHANNEL_VREFINT      (1)
N  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR   (4)
N  *         @arg @ref LL_ADC_CHANNEL_VBAT         (4)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2         (5)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6)
N  *         @arg @ref LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)
N  *         
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.\n
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.\n
N  *         (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
N  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_SAMPLINGTIME_2CYCLES_5   (1)
N  *         @arg @ref LL_ADC_SAMPLINGTIME_6CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_12CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_24CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_47CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_92CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
N  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
N  *
N  *         (1) On some devices, ADC sampling time 2.5 ADC clock cycles
N  *             can be replaced by 3.5 ADC clock cycles.
N  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel)
Xstatic __inline uint32_t LL_ADC_GetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
S  
S  return (uint32_t)(READ_BIT(*preg,
S                             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS))
S                    >> ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS)
S                   );
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->SMPR1)) + (((((Channel) & (((0x00000000U) | (0x02000000U)))) >> (__clz(__rbit((((0x00000000U) | (0x02000000U)))))))) << 2U))));
N  
N  return (uint32_t)(READ_BIT(*preg,
N                             ADC_SMPR1_SMP0 << __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPx_BITOFFSET_MASK))
X  return (uint32_t)(((*preg) & ((0x7UL << (0U)) << (((Channel) & ((0x01F00000U))) >> (__clz(__rbit(((0x01F00000U))))))))
N                    >> __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPx_BITOFFSET_MASK)
X                    >> (((Channel) & ((0x01F00000U))) >> (__clz(__rbit(((0x01F00000U))))))
N                   );
N#endif
N}
N
N/**
N  * @brief  Set mode single-ended or differential input of the selected
N  *         ADC channel.
N  * @note   Channel ending is on channel scope: independently of channel mapped
N  *         on ADC group regular or injected.
N  *         In differential mode: Differential measurement is carried out
N  *         between the selected channel 'i' (positive input) and
N  *         channel 'i+1' (negative input). Only channel 'i' has to be
N  *         configured, channel 'i+1' is configured automatically.
N  * @note   Refer to Reference Manual to ensure the selected channel is
N  *         available in differential mode.
N  *         For example, internal channels (VrefInt, TempSensor, ...) are
N  *         not available in differential mode.
N  * @note   When configuring a channel 'i' in differential mode,
N  *         the channel 'i+1' is not usable separately.
N  * @note   On STM32L4, channels 16, 17, 18 of ADC1, ADC2, ADC3 (if available)
N  *         are internally fixed to single-ended inputs configuration.
N  * @note   For ADC channels configured in differential mode, both inputs
N  *         should be biased at (Vref+)/2 +/-200mV.
N  *         (Vref+ is the analog voltage reference)
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @note   One or several values can be selected.
N  *         Example: (LL_ADC_CHANNEL_4 | LL_ADC_CHANNEL_12 | ...)
N  * @rmtoll DIFSEL   DIFSEL         LL_ADC_SetChannelSingleDiff
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_1
N  *         @arg @ref LL_ADC_CHANNEL_2
N  *         @arg @ref LL_ADC_CHANNEL_3
N  *         @arg @ref LL_ADC_CHANNEL_4
N  *         @arg @ref LL_ADC_CHANNEL_5
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  * @param  SingleDiff This parameter can be a combination of the following values:
N  *         @arg @ref LL_ADC_SINGLE_ENDED
N  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
Xstatic __inline void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
N{
N  /* Bits of channels in single or differential mode are set only for         */
N  /* differential mode (for single mode, mask of bits allowed to be set is    */
N  /* shifted out of range of bits of channels in single or differential mode. */
N  MODIFY_REG(ADCx->DIFSEL,
N             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
N             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL << (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
X  (((ADCx->DIFSEL)) = ((((((ADCx->DIFSEL))) & (~(Channel & (((0x7FFFFUL << (0U))))))) | ((Channel & (((0x7FFFFUL << (0U))))) & ((0x7FFFFUL << (0U)) << (SingleDiff & ((0x20UL << (0U)))))))));
N}
N
N/**
N  * @brief  Get mode single-ended or differential input of the selected
N  *         ADC channel.
N  * @note   When configuring a channel 'i' in differential mode,
N  *         the channel 'i+1' is not usable separately.
N  *         Therefore, to ensure a channel is configured in single-ended mode,
N  *         the configuration of channel itself and the channel 'i-1' must be
N  *         read back (to ensure that the selected channel channel has not been
N  *         configured in differential mode by the previous channel).
N  * @note   Refer to Reference Manual to ensure the selected channel is
N  *         available in differential mode.
N  *         For example, internal channels (VrefInt, TempSensor, ...) are
N  *         not available in differential mode.
N  * @note   When configuring a channel 'i' in differential mode,
N  *         the channel 'i+1' is not usable separately.
N  * @note   On STM32L4, channels 16, 17, 18 of ADC1, ADC2, ADC3 (if available)
N  *         are internally fixed to single-ended inputs configuration.
N  * @note   One or several values can be selected. In this case, the value
N  *         returned is null if all channels are in single ended-mode.
N  *         Example: (LL_ADC_CHANNEL_4 | LL_ADC_CHANNEL_12 | ...)
N  * @rmtoll DIFSEL   DIFSEL         LL_ADC_GetChannelSingleDiff
N  * @param  ADCx ADC instance
N  * @param  Channel This parameter can be a combination of the following values:
N  *         @arg @ref LL_ADC_CHANNEL_1
N  *         @arg @ref LL_ADC_CHANNEL_2
N  *         @arg @ref LL_ADC_CHANNEL_3
N  *         @arg @ref LL_ADC_CHANNEL_4
N  *         @arg @ref LL_ADC_CHANNEL_5
N  *         @arg @ref LL_ADC_CHANNEL_6
N  *         @arg @ref LL_ADC_CHANNEL_7
N  *         @arg @ref LL_ADC_CHANNEL_8
N  *         @arg @ref LL_ADC_CHANNEL_9
N  *         @arg @ref LL_ADC_CHANNEL_10
N  *         @arg @ref LL_ADC_CHANNEL_11
N  *         @arg @ref LL_ADC_CHANNEL_12
N  *         @arg @ref LL_ADC_CHANNEL_13
N  *         @arg @ref LL_ADC_CHANNEL_14
N  *         @arg @ref LL_ADC_CHANNEL_15
N  * @retval 0: channel in single-ended mode, else: channel in differential mode
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel)
Xstatic __inline uint32_t LL_ADC_GetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel)
N{
N  return (uint32_t)(READ_BIT(ADCx->DIFSEL, (Channel & ADC_SINGLEDIFF_CHANNEL_MASK)));
X  return (uint32_t)(((ADCx->DIFSEL) & ((Channel & (((0x7FFFFUL << (0U))))))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_AnalogWatchdog Configuration of ADC transversal scope: analog watchdog
N  * @{
N  */
N
N/**
N  * @brief  Set ADC analog watchdog monitored channels:
N  *         a single channel, multiple channels or all channels,
N  *         on ADC groups regular and-or injected.
N  * @note   Once monitored channels are selected, analog watchdog
N  *         is enabled.
N  * @note   In case of need to define a single channel to monitor
N  *         with analog watchdog from sequencer channel definition,
N  *         use helper macro @ref __LL_ADC_ANALOGWD_CHANNEL_GROUP().
N  * @note   On this STM32 serie, there are 2 kinds of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC groups regular and-or injected.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  *         - AWD flexible (instances AWD2, AWD3):
N  *           - channels monitored: flexible on channels monitored, selection is
N  *             channel wise, from from 1 to all channels.
N  *             Specificity of this analog watchdog: Multiple channels can
N  *             be selected. For example:
N  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
N  *           - groups monitored: not selection possible (monitoring on both
N  *             groups regular and injected).
N  *             Channels selected are monitored on groups regular and injected:
N  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
N  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
N  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
N  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
N  *             the 2 LSB are ignored.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     AWD1CH         LL_ADC_SetAnalogWDMonitChannels\n
N  *         CFGR     AWD1SGL        LL_ADC_SetAnalogWDMonitChannels\n
N  *         CFGR     AWD1EN         LL_ADC_SetAnalogWDMonitChannels\n
N  *         CFGR     JAWD1EN        LL_ADC_SetAnalogWDMonitChannels\n
N  *         AWD2CR   AWD2CH         LL_ADC_SetAnalogWDMonitChannels\n
N  *         AWD3CR   AWD3CH         LL_ADC_SetAnalogWDMonitChannels
N  * @param  ADCx ADC instance
N  * @param  AWDy This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD1
N  *         @arg @ref LL_ADC_AWD2
N  *         @arg @ref LL_ADC_AWD3
N  * @param  AWDChannelGroup This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD_DISABLE
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG        (0)
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_INJ        (0)
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG          (0)(1)
N  *         @arg @ref LL_ADC_AWD_CH_VREFINT_INJ          (0)(1)
N  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG_INJ         (1)
N  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_REG       (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_INJ       (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_REG_INJ      (4)
N  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG             (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_VBAT_INJ             (0)(4)
N  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG_INJ            (4)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_REG          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_INJ          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_REG_INJ         (2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_REG          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_INJ          (0)(2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_REG_INJ         (2)(5)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC2_REG     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC2_INJ     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC2_REG_INJ    (2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC2_REG     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC2_INJ     (0)(2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC2_REG_INJ    (2)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC3_REG     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC3_INJ     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH1_ADC3_REG_INJ    (3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC3_REG     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC3_INJ     (0)(3)(6)
N  *         @arg @ref LL_ADC_AWD_CH_DAC1CH2_ADC3_REG_INJ    (3)(6)
N  *         
N  *         (0) On STM32L4, parameter available only on analog watchdog number: AWD1.\n
N  *         (1) On STM32L4, parameter available only on ADC instance: ADC1.\n
N  *         (2) On STM32L4, parameter available only on ADC instance: ADC2.\n
N  *         (3) On STM32L4, parameter available only on ADC instance: ADC3.\n
N  *         (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.
N  *         (5) On STM32L4, parameter available on devices with only 1 ADC instance.\n
N  *         (6) On STM32L4, parameter available on devices with several ADC instances.
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDChannelGroup)
Xstatic __inline void LL_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDChannelGroup)
N{
N  /* Set bits with content of parameter "AWDChannelGroup" with bits position  */
N  /* in register and register position depending on parameter "AWDy".         */
N  /* Parameters "AWDChannelGroup" and "AWDy" are used with masks because      */
N  /* containing other bits reserved for other purpose.                        */
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR, ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
S                                                             + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK) * ADC_AWD_CR12_REGOFFSETGAP_VAL));
S  
S  MODIFY_REG(*preg,
S             (AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK),
S             AWDChannelGroup & AWDy);
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR, __ADC_MASK_SHIFT(AWDy, ADC_AWD_CRX_REGOFFSET_MASK)
N                                                             + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK) * ADC_AWD_CR12_REGOFFSETGAP_VAL));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->CFGR)) + (((((AWDy) & (((0x00000000U) | (0x00100000U) | (0x00200000U)))) >> (__clz(__rbit((((0x00000000U) | (0x00100000U) | (0x00200000U))))))) + ((AWDy & ((0x00001UL << (0U)))) * (0x00000024U))) << 2U))));
N  
N  MODIFY_REG(*preg,
N             (AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK),
N             AWDChannelGroup & AWDy);
X  (((*preg)) = ((((((*preg))) & (~((AWDy & (((0x1FUL << (26U)) | (0x1UL << (24U)) | (0x1UL << (23U)) | (0x1UL << (22U))) | ((0x7FFFFUL << (0U)))))))) | (AWDChannelGroup & AWDy))));
N#endif
N}
N
N/**
N  * @brief  Get ADC analog watchdog monitored channel.
N  * @note   Usage of the returned channel number:
N  *         - To reinject this channel into another function LL_ADC_xxx:
N  *           the returned channel number is only partly formatted on definition
N  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
N  *           with parts of literals LL_ADC_CHANNEL_x or using
N  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Then the selected literal LL_ADC_CHANNEL_x can be used
N  *           as parameter for another function.
N  *         - To get the channel number in decimal format:
N  *           process the returned value with the helper macro
N  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
N  *           Applicable only when the analog watchdog is set to monitor
N  *           one channel.
N  * @note   On this STM32 serie, there are 2 kinds of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC groups regular and-or injected.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  *         - AWD flexible (instances AWD2, AWD3):
N  *           - channels monitored: flexible on channels monitored, selection is
N  *             channel wise, from from 1 to all channels.
N  *             Specificity of this analog watchdog: Multiple channels can
N  *             be selected. For example:
N  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
N  *           - groups monitored: not selection possible (monitoring on both
N  *             groups regular and injected).
N  *             Channels selected are monitored on groups regular and injected:
N  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
N  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
N  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
N  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
N  *             the 2 LSB are ignored.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR     AWD1CH         LL_ADC_GetAnalogWDMonitChannels\n
N  *         CFGR     AWD1SGL        LL_ADC_GetAnalogWDMonitChannels\n
N  *         CFGR     AWD1EN         LL_ADC_GetAnalogWDMonitChannels\n
N  *         CFGR     JAWD1EN        LL_ADC_GetAnalogWDMonitChannels\n
N  *         AWD2CR   AWD2CH         LL_ADC_GetAnalogWDMonitChannels\n
N  *         AWD3CR   AWD3CH         LL_ADC_GetAnalogWDMonitChannels
N  * @param  ADCx ADC instance
N  * @param  AWDy This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD1
N  *         @arg @ref LL_ADC_AWD2 (1)
N  *         @arg @ref LL_ADC_AWD3 (1)
N  *         
N  *         (1) On this AWD number, monitored channel can be retrieved
N  *             if only 1 channel is programmed (or none or all channels).
N  *             This function cannot retrieve monitored channel if
N  *             multiple channels are programmed simultaneously
N  *             by bitfield.
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_AWD_DISABLE
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG        (0)
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_INJ        (0)
N  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_INJ           (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG_INJ
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_INJ          (0)
N  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG_INJ
N  *         
N  *         (0) On STM32L4, parameter available only on analog watchdog number: AWD1.
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy)
Xstatic __inline uint32_t LL_ADC_GetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy)
N{
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR, ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
N                                                             + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK) * ADC_AWD_CR12_REGOFFSETGAP_VAL));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->CFGR)) + ((((AWDy & ((0x00000000U) | (0x00100000U) | (0x00200000U))) >> (20U)) + ((AWDy & ((0x00001UL << (0U)))) * (0x00000024U))) << 2U))));
N  
N  register uint32_t AnalogWDMonitChannels = (READ_BIT(*preg, AWDy) & AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK);
X  register uint32_t AnalogWDMonitChannels = (((*preg) & (AWDy)) & AWDy & (((0x1FUL << (26U)) | (0x1UL << (24U)) | (0x1UL << (23U)) | (0x1UL << (22U))) | ((0x7FFFFUL << (0U)))));
N  
N  /* If "AnalogWDMonitChannels" == 0, then the selected AWD is disabled       */
N  /* (parameter value LL_ADC_AWD_DISABLE).                                    */
N  /* Else, the selected AWD is enabled and is monitoring a group of channels  */
N  /* or a single channel.                                                     */
N  if(AnalogWDMonitChannels != 0)
N  {
N    if(AWDy == LL_ADC_AWD1)
X    if(AWDy == (((0x1FUL << (26U)) | (0x1UL << (24U)) | (0x1UL << (23U)) | (0x1UL << (22U))) | (0x00000000U)))
N    {
N      if((AnalogWDMonitChannels & ADC_CFGR_AWD1SGL) == 0)
X      if((AnalogWDMonitChannels & (0x1UL << (22U))) == 0)
N      {
N        /* AWD monitoring a group of channels */
N        AnalogWDMonitChannels = ((  AnalogWDMonitChannels
N                                  | (ADC_AWD_CR23_CHANNEL_MASK)
X                                  | (((0x7FFFFUL << (0U))))
N                                 )
N                                 & (~(ADC_CFGR_AWD1CH))
X                                 & (~((0x1FUL << (26U))))
N                                );
N      }
N      else
N      {
N        /* AWD monitoring a single channel */
N        AnalogWDMonitChannels = (AnalogWDMonitChannels
N                                 | (ADC_AWD2CR_AWD2CH_0 << (AnalogWDMonitChannels >> ADC_CFGR_AWD1CH_Pos))
X                                 | ((0x00001UL << (0U)) << (AnalogWDMonitChannels >> (26U)))
N                                );
N      }
N    }
N    else
N    {
N      if((AnalogWDMonitChannels & ADC_AWD_CR23_CHANNEL_MASK) == ADC_AWD_CR23_CHANNEL_MASK)
X      if((AnalogWDMonitChannels & ((0x7FFFFUL << (0U)))) == ((0x7FFFFUL << (0U))))
N      {
N        /* AWD monitoring a group of channels */
N        AnalogWDMonitChannels = (  ADC_AWD_CR23_CHANNEL_MASK
X        AnalogWDMonitChannels = (  ((0x7FFFFUL << (0U)))
N                                 | ((ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN))
X                                 | (((0x1UL << (24U)) | (0x1UL << (23U))))
N                                );
N      }
N      else
N      {
N        /* AWD monitoring a single channel */
N        /* AWD monitoring a group of channels */
N        AnalogWDMonitChannels = (  AnalogWDMonitChannels
N                                 | (ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)
X                                 | ((0x1UL << (24U)) | (0x1UL << (23U)) | (0x1UL << (22U)))
N                                 | (__LL_ADC_CHANNEL_TO_DECIMAL_NB(AnalogWDMonitChannels) << ADC_CFGR_AWD1CH_Pos)
X                                 | (((((AnalogWDMonitChannels) & ((0x7FFFFUL << (0U)))) == 0U) ? ( ((AnalogWDMonitChannels) & ((0x1FUL << (26U)))) >> (26U) ) : ( (__clz(__rbit((AnalogWDMonitChannels)))) ) ) << (26U))
N                                );
N      }
N    }
N  }
N  
N  return AnalogWDMonitChannels;
N
N}
N
N/**
N  * @brief  Set ADC analog watchdog thresholds value of both thresholds
N  *         high and low.
N  * @note   If value of only one threshold high or low must be set,
N  *         use function @ref LL_ADC_SetAnalogWDThresholds().
N  * @note   In case of ADC resolution different of 12 bits,
N  *         analog watchdog thresholds data require a specific shift.
N  *         Use helper macro @ref __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION().
N  * @note   On this STM32 serie, there are 2 kinds of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC groups regular and-or injected.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  *         - AWD flexible (instances AWD2, AWD3):
N  *           - channels monitored: flexible on channels monitored, selection is
N  *             channel wise, from from 1 to all channels.
N  *             Specificity of this analog watchdog: Multiple channels can
N  *             be selected. For example:
N  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
N  *           - groups monitored: not selection possible (monitoring on both
N  *             groups regular and injected).
N  *             Channels selected are monitored on groups regular and injected:
N  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
N  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
N  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
N  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
N  *             the 2 LSB are ignored.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll TR1      HT1            LL_ADC_ConfigAnalogWDThresholds\n
N  *         TR2      HT2            LL_ADC_ConfigAnalogWDThresholds\n
N  *         TR3      HT3            LL_ADC_ConfigAnalogWDThresholds\n
N  *         TR1      LT1            LL_ADC_ConfigAnalogWDThresholds\n
N  *         TR2      LT2            LL_ADC_ConfigAnalogWDThresholds\n
N  *         TR3      LT3            LL_ADC_ConfigAnalogWDThresholds
N  * @param  ADCx ADC instance
N  * @param  AWDy This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD1
N  *         @arg @ref LL_ADC_AWD2
N  *         @arg @ref LL_ADC_AWD3
N  * @param  AWDThresholdHighValue Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @param  AWDThresholdLowValue Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ConfigAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdHighValue, uint32_t AWDThresholdLowValue)
Xstatic __inline void LL_ADC_ConfigAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdHighValue, uint32_t AWDThresholdLowValue)
N{
N  /* Set bits with content of parameter "AWDThresholdxxxValue" with bits      */
N  /* position in register and register position depending on parameter        */
N  /* "AWDy".                                                                  */
N  /* Parameters "AWDy" and "AWDThresholdxxxValue" are used with masks because */
N  /* containing other bits reserved for other purpose.                        */
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, __ADC_MASK_SHIFT(AWDy, ADC_AWD_TRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->TR1)) + (((((AWDy) & ((((0x00000000U)) | ((0x00100000U)) | ((0x00200000U))))) >> (__clz(__rbit(((((0x00000000U)) | ((0x00100000U)) | ((0x00200000U))))))))) << 2U))));
N#endif
N  
N  MODIFY_REG(*preg,
N             ADC_TR1_HT1 | ADC_TR1_LT1,
N             (AWDThresholdHighValue << ADC_TR1_HT1_BITOFFSET_POS) | AWDThresholdLowValue);
X  (((*preg)) = ((((((*preg))) & (~((0xFFFUL << (16U)) | (0xFFFUL << (0U))))) | ((AWDThresholdHighValue << (16U)) | AWDThresholdLowValue))));
N}
N
N/**
N  * @brief  Set ADC analog watchdog threshold value of threshold
N  *         high or low.
N  * @note   If values of both thresholds high or low must be set,
N  *         use function @ref LL_ADC_ConfigAnalogWDThresholds().
N  * @note   In case of ADC resolution different of 12 bits,
N  *         analog watchdog thresholds data require a specific shift.
N  *         Use helper macro @ref __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION().
N  * @note   On this STM32 serie, there are 2 kinds of analog watchdog
N  *         instance:
N  *         - AWD standard (instance AWD1):
N  *           - channels monitored: can monitor 1 channel or all channels.
N  *           - groups monitored: ADC groups regular and-or injected.
N  *           - resolution: resolution is not limited (corresponds to
N  *             ADC resolution configured).
N  *         - AWD flexible (instances AWD2, AWD3):
N  *           - channels monitored: flexible on channels monitored, selection is
N  *             channel wise, from from 1 to all channels.
N  *             Specificity of this analog watchdog: Multiple channels can
N  *             be selected. For example:
N  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
N  *           - groups monitored: not selection possible (monitoring on both
N  *             groups regular and injected).
N  *             Channels selected are monitored on groups regular and injected:
N  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
N  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
N  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
N  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
N  *             the 2 LSB are ignored.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either ADC groups regular or injected.
N  * @rmtoll TR1      HT1            LL_ADC_SetAnalogWDThresholds\n
N  *         TR2      HT2            LL_ADC_SetAnalogWDThresholds\n
N  *         TR3      HT3            LL_ADC_SetAnalogWDThresholds\n
N  *         TR1      LT1            LL_ADC_SetAnalogWDThresholds\n
N  *         TR2      LT2            LL_ADC_SetAnalogWDThresholds\n
N  *         TR3      LT3            LL_ADC_SetAnalogWDThresholds
N  * @param  ADCx ADC instance
N  * @param  AWDy This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD1
N  *         @arg @ref LL_ADC_AWD2
N  *         @arg @ref LL_ADC_AWD3
N  * @param  AWDThresholdsHighLow This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD_THRESHOLD_HIGH
N  *         @arg @ref LL_ADC_AWD_THRESHOLD_LOW
N  * @param  AWDThresholdValue Value between Min_Data=0x000 and Max_Data=0xFFF
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow, uint32_t AWDThresholdValue)
Xstatic __inline void LL_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow, uint32_t AWDThresholdValue)
N{
N  /* Set bits with content of parameter "AWDThresholdValue" with bits         */
N  /* position in register and register position depending on parameters       */
N  /* "AWDThresholdsHighLow" and "AWDy".                                       */
N  /* Parameters "AWDy" and "AWDThresholdValue" are used with masks because    */
N  /* containing other bits reserved for other purpose.                        */
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));
S  
S  MODIFY_REG(*preg,
S             AWDThresholdsHighLow,
S             AWDThresholdValue << ((AWDThresholdsHighLow & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, __ADC_MASK_SHIFT(AWDy, ADC_AWD_TRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->TR1)) + (((((AWDy) & ((((0x00000000U)) | ((0x00100000U)) | ((0x00200000U))))) >> (__clz(__rbit(((((0x00000000U)) | ((0x00100000U)) | ((0x00200000U))))))))) << 2U))));
N  
N  MODIFY_REG(*preg,
N             AWDThresholdsHighLow,
N             AWDThresholdValue << POSITION_VAL(AWDThresholdsHighLow));
X  (((*preg)) = ((((((*preg))) & (~(AWDThresholdsHighLow))) | (AWDThresholdValue << (__clz(__rbit(AWDThresholdsHighLow)))))));
N#endif
N}
N
N/**
N  * @brief  Get ADC analog watchdog threshold value of threshold high,
N  *         threshold low or raw data with ADC thresholds high and low
N  *         concatenated.
N  * @note   If raw data with ADC thresholds high and low is retrieved,
N  *         the data of each threshold high or low can be isolated
N  *         using helper macro:
N  *         @ref __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW().
N  * @note   In case of ADC resolution different of 12 bits,
N  *         analog watchdog thresholds data require a specific shift.
N  *         Use helper macro @ref __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION().
N  * @rmtoll TR1      HT1            LL_ADC_GetAnalogWDThresholds\n
N  *         TR2      HT2            LL_ADC_GetAnalogWDThresholds\n
N  *         TR3      HT3            LL_ADC_GetAnalogWDThresholds\n
N  *         TR1      LT1            LL_ADC_GetAnalogWDThresholds\n
N  *         TR2      LT2            LL_ADC_GetAnalogWDThresholds\n
N  *         TR3      LT3            LL_ADC_GetAnalogWDThresholds
N  * @param  ADCx ADC instance
N  * @param  AWDy This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD1
N  *         @arg @ref LL_ADC_AWD2
N  *         @arg @ref LL_ADC_AWD3
N  * @param  AWDThresholdsHighLow This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_AWD_THRESHOLD_HIGH
N  *         @arg @ref LL_ADC_AWD_THRESHOLD_LOW
N  *         @arg @ref LL_ADC_AWD_THRESHOLDS_HIGH_LOW
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N*/
N__STATIC_INLINE uint32_t LL_ADC_GetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow)
Xstatic __inline uint32_t LL_ADC_GetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));
S  
S  return (uint32_t)(READ_BIT(*preg,
S                             (AWDThresholdsHighLow | ADC_TR1_LT1))
S                    >> (((AWDThresholdsHighLow & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4) & ~(AWDThresholdsHighLow & ADC_TR1_LT1))
S                   );
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, __ADC_MASK_SHIFT(AWDy, ADC_AWD_TRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->TR1)) + (((((AWDy) & ((((0x00000000U)) | ((0x00100000U)) | ((0x00200000U))))) >> (__clz(__rbit(((((0x00000000U)) | ((0x00100000U)) | ((0x00200000U))))))))) << 2U))));
N  
N  return (uint32_t)(READ_BIT(*preg,
N                             (AWDThresholdsHighLow | ADC_TR1_LT1))
X  return (uint32_t)(((*preg) & ((AWDThresholdsHighLow | (0xFFFUL << (0U)))))
N                    >> POSITION_VAL(AWDThresholdsHighLow)
X                    >> (__clz(__rbit(AWDThresholdsHighLow)))
N                   );
N#endif
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_oversampling Configuration of ADC transversal scope: oversampling
N  * @{
N  */
N
N/**
N  * @brief  Set ADC oversampling scope: ADC groups regular and-or injected
N  *         (availability of ADC group injected depends on STM32 families).
N  * @note   If both groups regular and injected are selected,
N  *         specify behavior of ADC group injected interrupting
N  *         group regular: when ADC group injected is triggered,
N  *         the oversampling on ADC group regular is either
N  *         temporary stopped and continued, or resumed from start
N  *         (oversampler buffer reset).
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR2    ROVSE          LL_ADC_SetOverSamplingScope\n
N  *         CFGR2    JOVSE          LL_ADC_SetOverSamplingScope\n
N  *         CFGR2    ROVSM          LL_ADC_SetOverSamplingScope
N  * @param  ADCx ADC instance
N  * @param  OvsScope This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_DISABLE
N  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_CONTINUED
N  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_RESUMED
N  *         @arg @ref LL_ADC_OVS_GRP_INJECTED
N  *         @arg @ref LL_ADC_OVS_GRP_INJ_REG_RESUMED
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetOverSamplingScope(ADC_TypeDef *ADCx, uint32_t OvsScope)
Xstatic __inline void LL_ADC_SetOverSamplingScope(ADC_TypeDef *ADCx, uint32_t OvsScope)
N{
N  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_ROVSE | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSM, OvsScope);
X  (((ADCx->CFGR2)) = ((((((ADCx->CFGR2))) & (~((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (10U))))) | (OvsScope))));
N}
N
N/**
N  * @brief  Get ADC oversampling scope: ADC groups regular and-or injected
N  *         (availability of ADC group injected depends on STM32 families).
N  * @note   If both groups regular and injected are selected,
N  *         specify behavior of ADC group injected interrupting
N  *         group regular: when ADC group injected is triggered,
N  *         the oversampling on ADC group regular is either
N  *         temporary stopped and continued, or resumed from start
N  *         (oversampler buffer reset).
N  * @rmtoll CFGR2    ROVSE          LL_ADC_GetOverSamplingScope\n
N  *         CFGR2    JOVSE          LL_ADC_GetOverSamplingScope\n
N  *         CFGR2    ROVSM          LL_ADC_GetOverSamplingScope
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_DISABLE
N  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_CONTINUED
N  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_RESUMED
N  *         @arg @ref LL_ADC_OVS_GRP_INJECTED
N  *         @arg @ref LL_ADC_OVS_GRP_INJ_REG_RESUMED
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingScope(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetOverSamplingScope(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_ROVSE | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSM));
X  return (uint32_t)(((ADCx->CFGR2) & ((0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (10U)))));
N}
N
N/**
N  * @brief  Set ADC oversampling discontinuous mode (triggered mode)
N  *         on the selected ADC group.
N  * @note   Number of oversampled conversions are done either in:
N  *         - continuous mode (all conversions of oversampling ratio
N  *           are done from 1 trigger)
N  *         - discontinuous mode (each conversion of oversampling ratio
N  *           needs a trigger)
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on group regular.
N  * @note   On this STM32 serie, oversampling discontinuous mode 
N  *         (triggered mode) can be used only when oversampling is 
N  *         set on group regular only and in resumed mode.
N  * @rmtoll CFGR2    TROVS          LL_ADC_SetOverSamplingDiscont
N  * @param  ADCx ADC instance
N  * @param  OverSamplingDiscont This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_REG_CONT
N  *         @arg @ref LL_ADC_OVS_REG_DISCONT
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_SetOverSamplingDiscont(ADC_TypeDef *ADCx, uint32_t OverSamplingDiscont)
Xstatic __inline void LL_ADC_SetOverSamplingDiscont(ADC_TypeDef *ADCx, uint32_t OverSamplingDiscont)
N{
N  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_TROVS, OverSamplingDiscont);
X  (((ADCx->CFGR2)) = ((((((ADCx->CFGR2))) & (~((0x1UL << (9U))))) | (OverSamplingDiscont))));
N}
N
N/**
N  * @brief  Get ADC oversampling discontinuous mode (triggered mode)
N  *         on the selected ADC group.
N  * @note   Number of oversampled conversions are done either in:
N  *         - continuous mode (all conversions of oversampling ratio
N  *           are done from 1 trigger)
N  *         - discontinuous mode (each conversion of oversampling ratio
N  *           needs a trigger)
N  * @rmtoll CFGR2    TROVS          LL_ADC_GetOverSamplingDiscont
N  * @param  ADCx ADC instance
N  * @retval Returned value can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_REG_CONT
N  *         @arg @ref LL_ADC_OVS_REG_DISCONT
N  */
N__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingDiscont(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetOverSamplingDiscont(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_TROVS));
X  return (uint32_t)(((ADCx->CFGR2) & ((0x1UL << (9U)))));
N}
N
N/**
N  * @brief  Set ADC oversampling
N  *         (impacting both ADC groups regular and injected)
N  * @note   This function set the 2 items of oversampling configuration:
N  *         - ratio
N  *         - shift
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be disabled or enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CFGR2    OVSS           LL_ADC_ConfigOverSamplingRatioShift\n
N  *         CFGR2    OVSR           LL_ADC_ConfigOverSamplingRatioShift
N  * @param  ADCx ADC instance
N  * @param  Ratio This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_RATIO_2
N  *         @arg @ref LL_ADC_OVS_RATIO_4
N  *         @arg @ref LL_ADC_OVS_RATIO_8
N  *         @arg @ref LL_ADC_OVS_RATIO_16
N  *         @arg @ref LL_ADC_OVS_RATIO_32
N  *         @arg @ref LL_ADC_OVS_RATIO_64
N  *         @arg @ref LL_ADC_OVS_RATIO_128
N  *         @arg @ref LL_ADC_OVS_RATIO_256
N  * @param  Shift This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_SHIFT_NONE
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_1
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_2
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_3
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_4
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_5
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_6
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_7
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_8
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ConfigOverSamplingRatioShift(ADC_TypeDef *ADCx, uint32_t Ratio, uint32_t Shift)
Xstatic __inline void LL_ADC_ConfigOverSamplingRatioShift(ADC_TypeDef *ADCx, uint32_t Ratio, uint32_t Shift)
N{
N  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_OVSS | ADC_CFGR2_OVSR), (Shift | Ratio));
X  (((ADCx->CFGR2)) = ((((((ADCx->CFGR2))) & (~(((0xFUL << (5U)) | (0x7UL << (2U)))))) | ((Shift | Ratio)))));
N}
N
N/**
N  * @brief  Get ADC oversampling ratio
N  *        (impacting both ADC groups regular and injected)
N  * @rmtoll CFGR2    OVSR           LL_ADC_GetOverSamplingRatio
N  * @param  ADCx ADC instance
N  * @retval Ratio This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_RATIO_2
N  *         @arg @ref LL_ADC_OVS_RATIO_4
N  *         @arg @ref LL_ADC_OVS_RATIO_8
N  *         @arg @ref LL_ADC_OVS_RATIO_16
N  *         @arg @ref LL_ADC_OVS_RATIO_32
N  *         @arg @ref LL_ADC_OVS_RATIO_64
N  *         @arg @ref LL_ADC_OVS_RATIO_128
N  *         @arg @ref LL_ADC_OVS_RATIO_256
N*/
N__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingRatio(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetOverSamplingRatio(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_OVSR));
X  return (uint32_t)(((ADCx->CFGR2) & ((0x7UL << (2U)))));
N}
N
N/**
N  * @brief  Get ADC oversampling shift
N  *        (impacting both ADC groups regular and injected)
N  * @rmtoll CFGR2    OVSS           LL_ADC_GetOverSamplingShift
N  * @param  ADCx ADC instance
N  * @retval Shift This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_OVS_SHIFT_NONE
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_1
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_2
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_3
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_4
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_5
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_6
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_7
N  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_8
N*/
N__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingShift(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_GetOverSamplingShift(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_OVSS));
X  return (uint32_t)(((ADCx->CFGR2) & ((0xFUL << (5U)))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Configuration_ADC_Multimode Configuration of ADC hierarchical scope: multimode
N  * @{
N  */
N
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S/**
S  * @brief  Set ADC multimode configuration to operate in independent mode
S  *         or multimode (for devices with several ADC instances).
S  * @note   If multimode configuration: the selected ADC instance is
S  *         either master or slave depending on hardware.
S  *         Refer to reference manual.
S  * @note   On this STM32 serie, setting of this feature is conditioned to
S  *         ADC state:
S  *         All ADC instances of the ADC common group must be disabled.
S  *         This check can be done with function @ref LL_ADC_IsEnabled() for each
S  *         ADC instance or by using helper macro
S  *         @ref __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE().
S  * @rmtoll CCR      DUAL           LL_ADC_SetMultimode
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @param  Multimode This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_INDEPENDENT
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIMULT
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INTERL
S  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_SIMULT
S  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_ALTERN
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
S  * @retval None
S  */
S__STATIC_INLINE void LL_ADC_SetMultimode(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t Multimode)
S{
S  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_DUAL, Multimode);
S}
S
S/**
S  * @brief  Get ADC multimode configuration to operate in independent mode
S  *         or multimode (for devices with several ADC instances).
S  * @note   If multimode configuration: the selected ADC instance is
S  *         either master or slave depending on hardware.
S  *         Refer to reference manual.
S  * @rmtoll CCR      DUAL           LL_ADC_GetMultimode
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_INDEPENDENT
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIMULT
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INTERL
S  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_SIMULT
S  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_ALTERN
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
S  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
S  */
S__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
S}
S
S/**
S  * @brief  Set ADC multimode conversion data transfer: no transfer
S  *         or transfer by DMA.
S  * @note   If ADC multimode transfer by DMA is not selected:
S  *         each ADC uses its own DMA channel, with its individual
S  *         DMA transfer settings.
S  *         If ADC multimode transfer by DMA is selected:
S  *         One DMA channel is used for both ADC (DMA of ADC master)
S  *         Specifies the DMA requests mode:
S  *         - Limited mode (One shot mode): DMA transfer requests are stopped
S  *           when number of DMA data transfers (number of
S  *           ADC conversions) is reached.
S  *           This ADC mode is intended to be used with DMA mode non-circular.
S  *         - Unlimited mode: DMA transfer requests are unlimited,
S  *           whatever number of DMA data transfers (number of
S  *           ADC conversions).
S  *           This ADC mode is intended to be used with DMA mode circular.
S  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
S  *         mode non-circular:
S  *         when DMA transfers size will be reached, DMA will stop transfers of
S  *         ADC conversions data ADC will raise an overrun error
S  *         (overrun flag and interruption if enabled).
S  * @note   How to retrieve multimode conversion data:
S  *         Whatever multimode transfer by DMA setting: using function
S  *         @ref LL_ADC_REG_ReadMultiConversionData32().
S  *         If ADC multimode transfer by DMA is selected: conversion data
S  *         is a raw data with ADC master and slave concatenated.
S  *         A macro is available to get the conversion data of
S  *         ADC master or ADC slave: see helper macro
S  *         @ref __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE().
S  * @note   On this STM32 serie, setting of this feature is conditioned to
S  *         ADC state:
S  *         All ADC instances of the ADC common group must be disabled
S  *         or enabled without conversion on going on group regular.
S  * @rmtoll CCR      MDMA           LL_ADC_SetMultiDMATransfer\n
S  *         CCR      DMACFG         LL_ADC_SetMultiDMATransfer
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @param  MultiDMATransfer This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_EACH_ADC
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B
S  * @retval None
S  */
S__STATIC_INLINE void LL_ADC_SetMultiDMATransfer(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t MultiDMATransfer)
S{
S  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG, MultiDMATransfer);
S}
S
S/**
S  * @brief  Get ADC multimode conversion data transfer: no transfer
S  *         or transfer by DMA.
S  * @note   If ADC multimode transfer by DMA is not selected:
S  *         each ADC uses its own DMA channel, with its individual
S  *         DMA transfer settings.
S  *         If ADC multimode transfer by DMA is selected:
S  *         One DMA channel is used for both ADC (DMA of ADC master)
S  *         Specifies the DMA requests mode:
S  *         - Limited mode (One shot mode): DMA transfer requests are stopped
S  *           when number of DMA data transfers (number of
S  *           ADC conversions) is reached.
S  *           This ADC mode is intended to be used with DMA mode non-circular.
S  *         - Unlimited mode: DMA transfer requests are unlimited,
S  *           whatever number of DMA data transfers (number of
S  *           ADC conversions).
S  *           This ADC mode is intended to be used with DMA mode circular.
S  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
S  *         mode non-circular:
S  *         when DMA transfers size will be reached, DMA will stop transfers of
S  *         ADC conversions data ADC will raise an overrun error
S  *         (overrun flag and interruption if enabled).
S  * @note   How to retrieve multimode conversion data:
S  *         Whatever multimode transfer by DMA setting: using function
S  *         @ref LL_ADC_REG_ReadMultiConversionData32().
S  *         If ADC multimode transfer by DMA is selected: conversion data
S  *         is a raw data with ADC master and slave concatenated.
S  *         A macro is available to get the conversion data of
S  *         ADC master or ADC slave: see helper macro
S  *         @ref __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE().
S  * @rmtoll CCR      MDMA           LL_ADC_GetMultiDMATransfer\n
S  *         CCR      DMACFG         LL_ADC_GetMultiDMATransfer
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_EACH_ADC
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B
S  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B
S  */
S__STATIC_INLINE uint32_t LL_ADC_GetMultiDMATransfer(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG));
S}
S
S/**
S  * @brief  Set ADC multimode delay between 2 sampling phases.
S  * @note   The sampling delay range depends on ADC resolution:
S  *         - ADC resolution 12 bits can have maximum delay of 12 cycles.
S  *         - ADC resolution 10 bits can have maximum delay of 10 cycles.
S  *         - ADC resolution  8 bits can have maximum delay of  8 cycles.
S  *         - ADC resolution  6 bits can have maximum delay of  6 cycles.
S  * @note   On this STM32 serie, setting of this feature is conditioned to
S  *         ADC state:
S  *         All ADC instances of the ADC common group must be disabled.
S  *         This check can be done with function @ref LL_ADC_IsEnabled() for each
S  *         ADC instance or by using helper macro helper macro
S  *         @ref __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE().
S  * @rmtoll CCR      DELAY          LL_ADC_SetMultiTwoSamplingDelay
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @param  MultiTwoSamplingDelay This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES  (1)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES  (1)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES  (2)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES  (2)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES (2)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES (3)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES (3)
S  *         
S  *         (1) Parameter available only if ADC resolution is 12, 10 or 8 bits.\n
S  *         (2) Parameter available only if ADC resolution is 12 or 10 bits.\n
S  *         (3) Parameter available only if ADC resolution is 12 bits.
S  * @retval None
S  */
S__STATIC_INLINE void LL_ADC_SetMultiTwoSamplingDelay(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t MultiTwoSamplingDelay)
S{
S  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_DELAY, MultiTwoSamplingDelay);
S}
S
S/**
S  * @brief  Get ADC multimode delay between 2 sampling phases.
S  * @rmtoll CCR      DELAY          LL_ADC_GetMultiTwoSamplingDelay
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval Returned value can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES  (1)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES  (1)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES  (2)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES  (2)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES (2)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES (3)
S  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES (3)
S  *         
S  *         (1) Parameter available only if ADC resolution is 12, 10 or 8 bits.\n
S  *         (2) Parameter available only if ADC resolution is 12 or 10 bits.\n
S  *         (3) Parameter available only if ADC resolution is 12 bits.
S  */
S__STATIC_INLINE uint32_t LL_ADC_GetMultiTwoSamplingDelay(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DELAY));
S}
N#endif /* ADC_MULTIMODE_SUPPORT */
N
N/**
N  * @}
N  */
N/** @defgroup ADC_LL_EF_Configuration_Leg_Functions Configuration of ADC alternate functions name
N  * @{
N  */
N/* Old functions name kept for legacy purpose, to be replaced by the          */
N/* current functions name.                                                    */
N__STATIC_INLINE void LL_ADC_REG_SetTrigSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
Xstatic __inline void LL_ADC_REG_SetTrigSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
N{
N  LL_ADC_REG_SetTriggerSource(ADCx, TriggerSource);
N}
N__STATIC_INLINE void LL_ADC_INJ_SetTrigSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
Xstatic __inline void LL_ADC_INJ_SetTrigSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
N{
N  LL_ADC_INJ_SetTriggerSource(ADCx, TriggerSource);
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Operation_ADC_Instance Operation on ADC hierarchical scope: ADC instance
N  * @{
N  */
N
N/**
N  * @brief  Put ADC instance in deep power down state.
N  * @note   In case of ADC calibration necessary: When ADC is in deep-power-down
N  *         state, the internal analog calibration is lost. After exiting from
N  *         deep power down, calibration must be relaunched or calibration factor
N  *         (preliminarily saved) must be set back into calibration register.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @rmtoll CR       DEEPPWD        LL_ADC_EnableDeepPowerDown
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableDeepPowerDown(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableDeepPowerDown(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_DEEPPWD);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (29U))))));
N}
N
N/**
N  * @brief  Disable ADC deep power down mode.
N  * @note   In case of ADC calibration necessary: When ADC is in deep-power-down
N  *         state, the internal analog calibration is lost. After exiting from
N  *         deep power down, calibration must be relaunched or calibration factor
N  *         (preliminarily saved) must be set back into calibration register.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
X  ((ADCx->CR) &= ~(((0x1UL << (29U)) | ((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U))))));
N}
N
N/**
N  * @brief  Get the selected ADC instance deep power down state.
N  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
N  * @param  ADCx ADC instance
N  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (29U)))) == ((0x1UL << (29U))));
N}
N
N/**
N  * @brief  Enable ADC instance internal voltage regulator.
N  * @note   On this STM32 serie, after ADC internal voltage regulator enable,
N  *         a delay for ADC internal voltage regulator stabilization
N  *         is required before performing a ADC calibration or ADC enable.
N  *         Refer to device datasheet, parameter tADCVREG_STUP.
N  *         Refer to literal @ref LL_ADC_DELAY_INTERNAL_REGUL_STAB_US.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADVREGEN);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (28U))))));
N}
N
N/**
N  * @brief  Disable ADC internal voltage regulator.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @rmtoll CR       ADVREGEN       LL_ADC_DisableInternalRegulator
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableInternalRegulator(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableInternalRegulator(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
X  ((ADCx->CR) &= ~(((0x1UL << (28U)) | ((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U))))));
N}
N
N/**
N  * @brief  Get the selected ADC instance internal voltage regulator state.
N  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
N  * @param  ADCx ADC instance
N  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (28U)))) == ((0x1UL << (28U))));
N}
N
N/**
N  * @brief  Enable the selected ADC instance.
N  * @note   On this STM32 serie, after ADC enable, a delay for 
N  *         ADC internal analog stabilization is required before performing a
N  *         ADC conversion start.
N  *         Refer to device datasheet, parameter tSTAB.
N  * @note   On this STM32 serie, flag LL_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled and ADC internal voltage regulator enabled.
N  * @rmtoll CR       ADEN           LL_ADC_Enable
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_Enable(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_Enable(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADEN);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (0U))))));
N}
N
N/**
N  * @brief  Disable the selected ADC instance.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be not disabled. Must be enabled without conversion on going
N  *         on either groups regular or injected.
N  * @rmtoll CR       ADDIS          LL_ADC_Disable
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_Disable(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADDIS);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (1U))))));
N}
N
N/**
N  * @brief  Get the selected ADC instance enable state.
N  * @note   On this STM32 serie, flag LL_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
N  * @param  ADCx ADC instance
N  * @retval 0: ADC is disabled, 1: ADC is enabled.
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get the selected ADC instance disable state.
N  * @rmtoll CR       ADDIS          LL_ADC_IsDisableOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no ADC disable command on going.
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsDisableOngoing(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Start ADC calibration in the mode single-ended
N  *         or differential (for devices with differential mode available).
N  * @note   On this STM32 serie, a minimum number of ADC clock cycles
N  *         are required between ADC end of calibration and ADC enable.
N  *         Refer to literal @ref LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES.
N  * @note   For devices with differential mode available:
N  *         Calibration of offset is specific to each of
N  *         single-ended and differential modes
N  *         (calibration run must be performed for each of these
N  *         differential modes, if used afterwards and if the application
N  *         requires their calibration).
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be ADC disabled.
N  * @rmtoll CR       ADCAL          LL_ADC_StartCalibration\n
N  *         CR       ADCALDIF       LL_ADC_StartCalibration
N  * @param  ADCx ADC instance
N  * @param  SingleDiff This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_SINGLE_ENDED
N  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_StartCalibration(ADC_TypeDef *ADCx, uint32_t SingleDiff)
Xstatic __inline void LL_ADC_StartCalibration(ADC_TypeDef *ADCx, uint32_t SingleDiff)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_ADCALDIF | ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADCAL | (SingleDiff & ADC_SINGLEDIFF_CALIB_START_MASK));
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~((0x1UL << (30U)) | ((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (31U)) | (SingleDiff & ((0x1UL << (30U))))))));
N}
N
N/**
N  * @brief  Get ADC calibration state.
N  * @rmtoll CR       ADCAL          LL_ADC_IsCalibrationOnGoing
N  * @param  ADCx ADC instance
N  * @retval 0: calibration complete, 1: calibration in progress.
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsCalibrationOnGoing(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsCalibrationOnGoing(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (31U)))) == ((0x1UL << (31U))));
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Operation_ADC_Group_Regular Operation on ADC hierarchical scope: group regular
N  * @{
N  */
N
N/**
N  * @brief  Start ADC group regular conversion.
N  * @note   On this STM32 serie, this function is relevant for both 
N  *         internal trigger (SW start) and external trigger:
N  *         - If ADC trigger has been set to software start, ADC conversion
N  *           starts immediately.
N  *         - If ADC trigger has been set to external trigger, ADC conversion
N  *           will start at next trigger event (on the selected trigger edge)
N  *           following the ADC start conversion command.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled without conversion on going on group regular,
N  *         without conversion stop command on going on group regular,
N  *         without ADC disable command on going.
N  * @rmtoll CR       ADSTART        LL_ADC_REG_StartConversion
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADSTART);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (2U))))));
N}
N
N/**
N  * @brief  Stop ADC group regular conversion.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled with conversion on going on group regular,
N  *         without ADC disable command on going.
N  * @rmtoll CR       ADSTP          LL_ADC_REG_StopConversion
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_REG_StopConversion(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_REG_StopConversion(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_ADSTP);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (4U))))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion state.
N  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no conversion is on going on ADC group regular.
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get ADC group regular command of conversion stop state
N  * @rmtoll CR       ADSTP          LL_ADC_REG_IsStopConversionOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no command of conversion stop is on going on ADC group regular.
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_IsStopConversionOngoing(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTP) == (ADC_CR_ADSTP));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         all ADC configurations: all ADC resolutions and
N  *         all oversampling increased data width (for devices
N  *         with feature oversampling).
N  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData32
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_ADC_REG_ReadConversionData32(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_REG_ReadConversionData32(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
X  return (uint32_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 12 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData12
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData12(ADC_TypeDef *ADCx)
Xstatic __inline uint16_t LL_ADC_REG_ReadConversionData12(ADC_TypeDef *ADCx)
N{
N  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
X  return (uint16_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 10 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData10
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x000 and Max_Data=0x3FF
N  */
N__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData10(ADC_TypeDef *ADCx)
Xstatic __inline uint16_t LL_ADC_REG_ReadConversionData10(ADC_TypeDef *ADCx)
N{
N  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
X  return (uint16_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 8 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData8
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t LL_ADC_REG_ReadConversionData8(ADC_TypeDef *ADCx)
Xstatic __inline uint8_t LL_ADC_REG_ReadConversionData8(ADC_TypeDef *ADCx)
N{
N  return (uint8_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
X  return (uint8_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         ADC resolution 6 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
N  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData6
N  * @param  ADCx ADC instance
N  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint8_t LL_ADC_REG_ReadConversionData6(ADC_TypeDef *ADCx)
Xstatic __inline uint8_t LL_ADC_REG_ReadConversionData6(ADC_TypeDef *ADCx)
N{
N  return (uint8_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
X  return (uint8_t)(((ADCx->DR) & ((0xFFFFUL << (0U)))));
N}
N
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S/**
S  * @brief  Get ADC multimode conversion data of ADC master, ADC slave
S  *         or raw data with ADC master and slave concatenated.
S  * @note   If raw data with ADC master and slave concatenated is retrieved,
S  *         a macro is available to get the conversion data of
S  *         ADC master or ADC slave: see helper macro
S  *         @ref __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE().
S  *         (however this macro is mainly intended for multimode
S  *         transfer by DMA, because this function can do the same
S  *         by getting multimode conversion data of ADC master or ADC slave
S  *         separately).
S  * @rmtoll CDR      RDATA_MST      LL_ADC_REG_ReadMultiConversionData32\n
S  *         CDR      RDATA_SLV      LL_ADC_REG_ReadMultiConversionData32
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @param  ConversionData This parameter can be one of the following values:
S  *         @arg @ref LL_ADC_MULTI_MASTER
S  *         @arg @ref LL_ADC_MULTI_SLAVE
S  *         @arg @ref LL_ADC_MULTI_MASTER_SLAVE
S  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
S  */
S__STATIC_INLINE uint32_t LL_ADC_REG_ReadMultiConversionData32(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t ConversionData)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CDR,
S                             ConversionData)
S                    >> POSITION_VAL(ConversionData)
S                   );
S}
N#endif /* ADC_MULTIMODE_SUPPORT */
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_Operation_ADC_Group_Injected Operation on ADC hierarchical scope: group injected
N  * @{
N  */
N
N/**
N  * @brief  Start ADC group injected conversion.
N  * @note   On this STM32 serie, this function is relevant for both 
N  *         internal trigger (SW start) and external trigger:
N  *         - If ADC trigger has been set to software start, ADC conversion
N  *           starts immediately.
N  *         - If ADC trigger has been set to external trigger, ADC conversion
N  *           will start at next trigger event (on the selected trigger edge)
N  *           following the ADC start conversion command.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled without conversion on going on group injected,
N  *         without conversion stop command on going on group injected,
N  *         without ADC disable command on going.
N  * @rmtoll CR       JADSTART       LL_ADC_INJ_StartConversion
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_StartConversion(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_INJ_StartConversion(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_JADSTART);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (3U))))));
N}
N
N/**
N  * @brief  Stop ADC group injected conversion.
N  * @note   On this STM32 serie, setting of this feature is conditioned to
N  *         ADC state:
N  *         ADC must be enabled with conversion on going on group injected,
N  *         without ADC disable command on going.
N  * @rmtoll CR       JADSTP         LL_ADC_INJ_StopConversion
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_INJ_StopConversion(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_INJ_StopConversion(ADC_TypeDef *ADCx)
N{
N  /* Note: Write register with some additional bits forced to state reset     */
N  /*       instead of modifying only the selected bit for this function,      */
N  /*       to not interfere with bits with HW property "rs".                  */
N  MODIFY_REG(ADCx->CR,
N             ADC_CR_BITS_PROPERTY_RS,
N             ADC_CR_JADSTP);
X  (((ADCx->CR)) = ((((((ADCx->CR))) & (~(((0x1UL << (31U)) | (0x1UL << (5U)) | (0x1UL << (4U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (0U)))))) | ((0x1UL << (5U))))));
N}
N
N/**
N  * @brief  Get ADC group injected conversion state.
N  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no conversion is on going on ADC group injected.
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get ADC group injected command of conversion stop state
N  * @rmtoll CR       JADSTP         LL_ADC_INJ_IsStopConversionOngoing
N  * @param  ADCx ADC instance
N  * @retval 0: no command of conversion stop is on going on ADC group injected.
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_IsStopConversionOngoing(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_INJ_IsStopConversionOngoing(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_JADSTP) == (ADC_CR_JADSTP));
X  return (uint32_t)(((ADCx->CR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Get ADC group regular conversion data, range fit for
N  *         all ADC configurations: all ADC resolutions and
N  *         all oversampling increased data width (for devices
N  *         with feature oversampling).
N  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData32\n
N  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData32\n
N  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData32\n
N  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData32
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
N  */
N__STATIC_INLINE uint32_t LL_ADC_INJ_ReadConversionData32(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint32_t LL_ADC_INJ_ReadConversionData32(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, __ADC_MASK_SHIFT(Rank, ADC_INJ_JDRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->JDR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  return (uint32_t)(READ_BIT(*preg,
N                             ADC_JDR1_JDATA)
X  return (uint32_t)(((*preg) & ((0xFFFFUL << (0U))))
N                   );
N}
N
N/**
N  * @brief  Get ADC group injected conversion data, range fit for
N  *         ADC resolution 12 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
N  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData12\n
N  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData12\n
N  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData12\n
N  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData12
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
N  */
N__STATIC_INLINE uint16_t LL_ADC_INJ_ReadConversionData12(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint16_t LL_ADC_INJ_ReadConversionData12(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, __ADC_MASK_SHIFT(Rank, ADC_INJ_JDRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->JDR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  return (uint16_t)(READ_BIT(*preg,
N                             ADC_JDR1_JDATA)
X  return (uint16_t)(((*preg) & ((0xFFFFUL << (0U))))
N                   );
N}
N
N/**
N  * @brief  Get ADC group injected conversion data, range fit for
N  *         ADC resolution 10 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
N  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData10\n
N  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData10\n
N  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData10\n
N  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData10
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @retval Value between Min_Data=0x000 and Max_Data=0x3FF
N  */
N__STATIC_INLINE uint16_t LL_ADC_INJ_ReadConversionData10(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint16_t LL_ADC_INJ_ReadConversionData10(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, __ADC_MASK_SHIFT(Rank, ADC_INJ_JDRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->JDR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  return (uint16_t)(READ_BIT(*preg,
N                             ADC_JDR1_JDATA)
X  return (uint16_t)(((*preg) & ((0xFFFFUL << (0U))))
N                   );
N}
N
N/**
N  * @brief  Get ADC group injected conversion data, range fit for
N  *         ADC resolution 8 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
N  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData8\n
N  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData8\n
N  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData8\n
N  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData8
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
N  */
N__STATIC_INLINE uint8_t LL_ADC_INJ_ReadConversionData8(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint8_t LL_ADC_INJ_ReadConversionData8(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, __ADC_MASK_SHIFT(Rank, ADC_INJ_JDRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->JDR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  return (uint8_t)(READ_BIT(*preg,
N                            ADC_JDR1_JDATA)
X  return (uint8_t)(((*preg) & ((0xFFFFUL << (0U))))
N                  );
N}
N
N/**
N  * @brief  Get ADC group injected conversion data, range fit for
N  *         ADC resolution 6 bits.
N  * @note   For devices with feature oversampling: Oversampling
N  *         can increase data width, function for extended range
N  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
N  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData6\n
N  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData6\n
N  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData6\n
N  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData6
N  * @param  ADCx ADC instance
N  * @param  Rank This parameter can be one of the following values:
N  *         @arg @ref LL_ADC_INJ_RANK_1
N  *         @arg @ref LL_ADC_INJ_RANK_2
N  *         @arg @ref LL_ADC_INJ_RANK_3
N  *         @arg @ref LL_ADC_INJ_RANK_4
N  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
N  */
N__STATIC_INLINE uint8_t LL_ADC_INJ_ReadConversionData6(ADC_TypeDef *ADCx, uint32_t Rank)
Xstatic __inline uint8_t LL_ADC_INJ_ReadConversionData6(ADC_TypeDef *ADCx, uint32_t Rank)
N{
N#if defined(CORE_CM0PLUS)
X#if 0L
S  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));
N#else
N  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1, __ADC_MASK_SHIFT(Rank, ADC_INJ_JDRX_REGOFFSET_MASK));
X  register uint32_t *preg = ((uint32_t *)((uint32_t) ((uint32_t)(&(ADCx->JDR1)) + (((((Rank) & (((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))) >> (__clz(__rbit((((0x00000000U) | (0x00000100U) | (0x00000200U) | (0x00000300U)))))))) << 2U))));
N#endif
N  
N  return (uint8_t)(READ_BIT(*preg,
N                            ADC_JDR1_JDATA)
X  return (uint8_t)(((*preg) & ((0xFFFFUL << (0U))))
N                  );
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_FLAG_Management ADC flag management
N  * @{
N  */
N
N/**
N  * @brief  Get flag ADC ready.
N  * @note   On this STM32 serie, flag LL_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @rmtoll ISR      ADRDY          LL_ADC_IsActiveFlag_ADRDY
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_ADRDY(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_ADRDY(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular end of unitary conversion.
N  * @rmtoll ISR      EOC            LL_ADC_IsActiveFlag_EOC
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_EOC(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_EOC(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular end of sequence conversions.
N  * @rmtoll ISR      EOS            LL_ADC_IsActiveFlag_EOS
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_EOS(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_EOS(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_EOS) == (LL_ADC_FLAG_EOS));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular overrun.
N  * @rmtoll ISR      OVR            LL_ADC_IsActiveFlag_OVR
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_OVR(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_OVR(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_OVR) == (LL_ADC_FLAG_OVR));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get flag ADC group regular end of sampling phase.
N  * @rmtoll ISR      EOSMP          LL_ADC_IsActiveFlag_EOSMP
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_EOSMP(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_EOSMP(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_EOSMP) == (LL_ADC_FLAG_EOSMP));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get flag ADC group injected end of unitary conversion.
N  * @rmtoll ISR      JEOC           LL_ADC_IsActiveFlag_JEOC
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_JEOC(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_JEOC(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_JEOC) == (LL_ADC_FLAG_JEOC));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Get flag ADC group injected end of sequence conversions.
N  * @rmtoll ISR      JEOS           LL_ADC_IsActiveFlag_JEOS
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_JEOS(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_JEOS(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_JEOS) == (LL_ADC_FLAG_JEOS));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Get flag ADC group injected contexts queue overflow.
N  * @rmtoll ISR      JQOVF          LL_ADC_IsActiveFlag_JQOVF
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_JQOVF(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_JQOVF(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_JQOVF) == (LL_ADC_FLAG_JQOVF));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Get flag ADC analog watchdog 1 flag
N  * @rmtoll ISR      AWD1           LL_ADC_IsActiveFlag_AWD1
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_AWD1(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_AWD1(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_AWD1) == (LL_ADC_FLAG_AWD1));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Get flag ADC analog watchdog 2.
N  * @rmtoll ISR      AWD2           LL_ADC_IsActiveFlag_AWD2
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_AWD2(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_AWD2(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_AWD2) == (LL_ADC_FLAG_AWD2));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Get flag ADC analog watchdog 3.
N  * @rmtoll ISR      AWD3           LL_ADC_IsActiveFlag_AWD3
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_AWD3(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsActiveFlag_AWD3(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->ISR, LL_ADC_FLAG_AWD3) == (LL_ADC_FLAG_AWD3));
X  return (uint32_t)(((ADCx->ISR) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Clear flag ADC ready.
N  * @note   On this STM32 serie, flag LL_ADC_FLAG_ADRDY is raised when the ADC
N  *         is enabled and when conversion clock is active.
N  *         (not only core clock: this ADC has a dual clock domain)
N  * @rmtoll ISR      ADRDY          LL_ADC_ClearFlag_ADRDY
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_ADRDY(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_ADRDY(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_ADRDY);
X  ((ADCx->ISR) = ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular end of unitary conversion.
N  * @rmtoll ISR      EOC            LL_ADC_ClearFlag_EOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_EOC(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_EOC(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
X  ((ADCx->ISR) = ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular end of sequence conversions.
N  * @rmtoll ISR      EOS            LL_ADC_ClearFlag_EOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_EOS(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_EOS(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOS);
X  ((ADCx->ISR) = ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular overrun.
N  * @rmtoll ISR      OVR            LL_ADC_ClearFlag_OVR
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_OVR(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_OVR(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_OVR);
X  ((ADCx->ISR) = ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Clear flag ADC group regular end of sampling phase.
N  * @rmtoll ISR      EOSMP          LL_ADC_ClearFlag_EOSMP
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_EOSMP(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_EOSMP(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOSMP);
X  ((ADCx->ISR) = ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Clear flag ADC group injected end of unitary conversion.
N  * @rmtoll ISR      JEOC           LL_ADC_ClearFlag_JEOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_JEOC(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_JEOC(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
X  ((ADCx->ISR) = ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Clear flag ADC group injected end of sequence conversions.
N  * @rmtoll ISR      JEOS           LL_ADC_ClearFlag_JEOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_JEOS(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_JEOS(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
X  ((ADCx->ISR) = ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Clear flag ADC group injected contexts queue overflow.
N  * @rmtoll ISR      JQOVF          LL_ADC_ClearFlag_JQOVF
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_JQOVF(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_JQOVF(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JQOVF);
X  ((ADCx->ISR) = ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Clear flag ADC analog watchdog 1.
N  * @rmtoll ISR      AWD1           LL_ADC_ClearFlag_AWD1
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD1);
X  ((ADCx->ISR) = ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Clear flag ADC analog watchdog 2.
N  * @rmtoll ISR      AWD2           LL_ADC_ClearFlag_AWD2
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_AWD2(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_AWD2(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD2);
X  ((ADCx->ISR) = ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Clear flag ADC analog watchdog 3.
N  * @rmtoll ISR      AWD3           LL_ADC_ClearFlag_AWD3
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_ClearFlag_AWD3(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_ClearFlag_AWD3(ADC_TypeDef *ADCx)
N{
N  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD3);
X  ((ADCx->ISR) = ((0x1UL << (9U))));
N}
N
N#if defined(ADC_MULTIMODE_SUPPORT)
X#if 0L
S/**
S  * @brief  Get flag multimode ADC ready of the ADC master.
S  * @rmtoll CSR      ADRDY_MST      LL_ADC_IsActiveFlag_MST_ADRDY
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_ADRDY(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_ADRDY_MST) == (LL_ADC_FLAG_ADRDY_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC ready of the ADC slave.
S  * @rmtoll CSR      ADRDY_SLV      LL_ADC_IsActiveFlag_SLV_ADRDY
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_ADRDY(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_ADRDY_SLV) == (LL_ADC_FLAG_ADRDY_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular end of unitary conversion of the ADC master.
S  * @rmtoll CSR      EOC_MST        LL_ADC_IsActiveFlag_MST_EOC
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_EOC(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOC_SLV) == (LL_ADC_FLAG_EOC_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular end of unitary conversion of the ADC slave.
S  * @rmtoll CSR      EOC_SLV        LL_ADC_IsActiveFlag_SLV_EOC
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_EOC(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOC_SLV) == (LL_ADC_FLAG_EOC_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular end of sequence conversions of the ADC master.
S  * @rmtoll CSR      EOS_MST        LL_ADC_IsActiveFlag_MST_EOS
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_EOS(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOS_MST) == (LL_ADC_FLAG_EOS_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular end of sequence conversions of the ADC slave.
S  * @rmtoll CSR      EOS_SLV        LL_ADC_IsActiveFlag_SLV_EOS
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_EOS(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOS_SLV) == (LL_ADC_FLAG_EOS_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular overrun of the ADC master.
S  * @rmtoll CSR      OVR_MST        LL_ADC_IsActiveFlag_MST_OVR
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_OVR(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_OVR_MST) == (LL_ADC_FLAG_OVR_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular overrun of the ADC slave.
S  * @rmtoll CSR      OVR_SLV        LL_ADC_IsActiveFlag_SLV_OVR
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_OVR(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_OVR_SLV) == (LL_ADC_FLAG_OVR_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular end of sampling of the ADC master.
S  * @rmtoll CSR      EOSMP_MST      LL_ADC_IsActiveFlag_MST_EOSMP
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_EOSMP(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOSMP_MST) == (LL_ADC_FLAG_EOSMP_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC group regular end of sampling of the ADC slave.
S  * @rmtoll CSR      EOSMP_SLV      LL_ADC_IsActiveFlag_SLV_EOSMP
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_EOSMP(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOSMP_SLV) == (LL_ADC_FLAG_EOSMP_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group injected end of unitary conversion of the ADC master.
S  * @rmtoll CSR      JEOC_MST       LL_ADC_IsActiveFlag_MST_JEOC
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_JEOC(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOC_MST) == (LL_ADC_FLAG_JEOC_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC group injected end of unitary conversion of the ADC slave.
S  * @rmtoll CSR      JEOC_SLV       LL_ADC_IsActiveFlag_SLV_JEOC
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_JEOC(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOC_SLV) == (LL_ADC_FLAG_JEOC_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group injected end of sequence conversions of the ADC master.
S  * @rmtoll CSR      JEOS_MST       LL_ADC_IsActiveFlag_MST_JEOS
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_JEOS(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOS_MST) == (LL_ADC_FLAG_JEOS_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC group injected end of sequence conversions of the ADC slave.
S  * @rmtoll CSR      JEOS_SLV       LL_ADC_IsActiveFlag_SLV_JEOS
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_JEOS(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOS_SLV) == (LL_ADC_FLAG_JEOS_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC group injected context queue overflow of the ADC master.
S  * @rmtoll CSR      JQOVF_MST      LL_ADC_IsActiveFlag_MST_JQOVF
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_JQOVF(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JQOVF_MST) == (LL_ADC_FLAG_JQOVF_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC group injected context queue overflow of the ADC slave.
S  * @rmtoll CSR      JQOVF_SLV      LL_ADC_IsActiveFlag_SLV_JQOVF
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_JQOVF(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JQOVF_SLV) == (LL_ADC_FLAG_JQOVF_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC analog watchdog 1 of the ADC master.
S  * @rmtoll CSR      AWD1_MST       LL_ADC_IsActiveFlag_MST_AWD1
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_AWD1(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD1_MST) == (LL_ADC_FLAG_AWD1_MST));
S}
S
S/**
S  * @brief  Get flag multimode analog watchdog 1 of the ADC slave.
S  * @rmtoll CSR      AWD1_SLV       LL_ADC_IsActiveFlag_SLV_AWD1
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_AWD1(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD1_SLV) == (LL_ADC_FLAG_AWD1_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC analog watchdog 2 of the ADC master.
S  * @rmtoll CSR      AWD2_MST       LL_ADC_IsActiveFlag_MST_AWD2
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_AWD2(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD2_MST) == (LL_ADC_FLAG_AWD2_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC analog watchdog 2 of the ADC slave.
S  * @rmtoll CSR      AWD2_SLV       LL_ADC_IsActiveFlag_SLV_AWD2
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_AWD2(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD2_SLV) == (LL_ADC_FLAG_AWD2_SLV));
S}
S
S/**
S  * @brief  Get flag multimode ADC analog watchdog 3 of the ADC master.
S  * @rmtoll CSR      AWD3_MST       LL_ADC_IsActiveFlag_MST_AWD3
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_AWD3(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD3_MST) == (LL_ADC_FLAG_AWD3_MST));
S}
S
S/**
S  * @brief  Get flag multimode ADC analog watchdog 3 of the ADC slave.
S  * @rmtoll CSR      AWD3_SLV       LL_ADC_IsActiveFlag_SLV_AWD3
S  * @param  ADCxy_COMMON ADC common instance
S  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
S  * @retval State of bit (1 or 0).
S  */
S__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_AWD3(ADC_Common_TypeDef *ADCxy_COMMON)
S{
S  return (uint32_t)(READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD3_SLV) == (LL_ADC_FLAG_AWD3_SLV));
S}
N#endif /* ADC_MULTIMODE_SUPPORT */
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_LL_EF_IT_Management ADC IT management
N  * @{
N  */
N
N/**
N  * @brief  Enable ADC ready.
N  * @rmtoll IER      ADRDYIE        LL_ADC_EnableIT_ADRDY
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_ADRDY(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_ADRDY(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_ADRDY);
X  ((ADCx->IER) |= ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group regular end of unitary conversion.
N  * @rmtoll IER      EOCIE          LL_ADC_EnableIT_EOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_EOC(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_EOC(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_EOC);
X  ((ADCx->IER) |= ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group regular end of sequence conversions.
N  * @rmtoll IER      EOSIE          LL_ADC_EnableIT_EOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_EOS(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_EOS(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_EOS);
X  ((ADCx->IER) |= ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Enable ADC group regular interruption overrun.
N  * @rmtoll IER      OVRIE          LL_ADC_EnableIT_OVR
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_OVR(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_OVR(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_OVR);
X  ((ADCx->IER) |= ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group regular end of sampling.
N  * @rmtoll IER      EOSMPIE        LL_ADC_EnableIT_EOSMP
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_EOSMP(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_EOSMP(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_EOSMP);
X  ((ADCx->IER) |= ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group injected end of unitary conversion.
N  * @rmtoll IER      JEOCIE         LL_ADC_EnableIT_JEOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_JEOC(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_JEOC(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_JEOC);
X  ((ADCx->IER) |= ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group injected end of sequence conversions.
N  * @rmtoll IER      JEOSIE         LL_ADC_EnableIT_JEOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_JEOS(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_JEOS(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_JEOS);
X  ((ADCx->IER) |= ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Enable interruption ADC group injected context queue overflow.
N  * @rmtoll IER      JQOVFIE        LL_ADC_EnableIT_JQOVF
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_JQOVF(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_JQOVF(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_JQOVF);
X  ((ADCx->IER) |= ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Enable interruption ADC analog watchdog 1.
N  * @rmtoll IER      AWD1IE         LL_ADC_EnableIT_AWD1
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_AWD1);
X  ((ADCx->IER) |= ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Enable interruption ADC analog watchdog 2.
N  * @rmtoll IER      AWD2IE         LL_ADC_EnableIT_AWD2
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_AWD2(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_AWD2(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_AWD2);
X  ((ADCx->IER) |= ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Enable interruption ADC analog watchdog 3.
N  * @rmtoll IER      AWD3IE         LL_ADC_EnableIT_AWD3
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_EnableIT_AWD3(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_EnableIT_AWD3(ADC_TypeDef *ADCx)
N{
N  SET_BIT(ADCx->IER, LL_ADC_IT_AWD3);
X  ((ADCx->IER) |= ((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Disable interruption ADC ready.
N  * @rmtoll IER      ADRDYIE        LL_ADC_DisableIT_ADRDY
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_ADRDY(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_ADRDY(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_ADRDY);
X  ((ADCx->IER) &= ~((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of unitary conversion.
N  * @rmtoll IER      EOCIE          LL_ADC_DisableIT_EOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
X  ((ADCx->IER) &= ~((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of sequence conversions.
N  * @rmtoll IER      EOSIE          LL_ADC_DisableIT_EOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_EOS(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_EOS(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOS);
X  ((ADCx->IER) &= ~((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular overrun.
N  * @rmtoll IER      OVRIE          LL_ADC_DisableIT_OVR
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_OVR(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_OVR(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_OVR);
X  ((ADCx->IER) &= ~((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of sampling.
N  * @rmtoll IER      EOSMPIE        LL_ADC_DisableIT_EOSMP
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_EOSMP(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_EOSMP(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOSMP);
X  ((ADCx->IER) &= ~((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group regular end of unitary conversion.
N  * @rmtoll IER      JEOCIE         LL_ADC_DisableIT_JEOC
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
X  ((ADCx->IER) &= ~((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group injected end of sequence conversions.
N  * @rmtoll IER      JEOSIE         LL_ADC_DisableIT_JEOS
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_JEOS(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_JEOS(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOS);
X  ((ADCx->IER) &= ~((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Disable interruption ADC group injected context queue overflow.
N  * @rmtoll IER      JQOVFIE        LL_ADC_DisableIT_JQOVF
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_JQOVF(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_JQOVF(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JQOVF);
X  ((ADCx->IER) &= ~((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Disable interruption ADC analog watchdog 1.
N  * @rmtoll IER      AWD1IE         LL_ADC_DisableIT_AWD1
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD1);
X  ((ADCx->IER) &= ~((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Disable interruption ADC analog watchdog 2.
N  * @rmtoll IER      AWD2IE         LL_ADC_DisableIT_AWD2
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_AWD2(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_AWD2(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD2);
X  ((ADCx->IER) &= ~((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Disable interruption ADC analog watchdog 3.
N  * @rmtoll IER      AWD3IE         LL_ADC_DisableIT_AWD3
N  * @param  ADCx ADC instance
N  * @retval None
N  */
N__STATIC_INLINE void LL_ADC_DisableIT_AWD3(ADC_TypeDef *ADCx)
Xstatic __inline void LL_ADC_DisableIT_AWD3(ADC_TypeDef *ADCx)
N{
N  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD3);
X  ((ADCx->IER) &= ~((0x1UL << (9U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC ready
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      ADRDYIE        LL_ADC_IsEnabledIT_ADRDY
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_ADRDY(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_ADRDY(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_ADRDY) == (LL_ADC_IT_ADRDY));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (0U)))) == ((0x1UL << (0U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular end of unitary conversion
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      EOCIE          LL_ADC_IsEnabledIT_EOC
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_EOC(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_EOC(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_EOC) == (LL_ADC_IT_EOC));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (2U)))) == ((0x1UL << (2U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular end of sequence conversions
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      EOSIE          LL_ADC_IsEnabledIT_EOS
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_EOS(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_EOS(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_EOS) == (LL_ADC_IT_EOS));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (3U)))) == ((0x1UL << (3U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular overrun
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      OVRIE          LL_ADC_IsEnabledIT_OVR
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_OVR(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_OVR(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_OVR) == (LL_ADC_IT_OVR));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (4U)))) == ((0x1UL << (4U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group regular end of sampling
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      EOSMPIE        LL_ADC_IsEnabledIT_EOSMP
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_EOSMP(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_EOSMP(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_EOSMP) == (LL_ADC_IT_EOSMP));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (1U)))) == ((0x1UL << (1U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group injected end of unitary conversion
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      JEOCIE         LL_ADC_IsEnabledIT_JEOC
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_JEOC(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_JEOC(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_JEOC) == (LL_ADC_IT_JEOC));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (5U)))) == ((0x1UL << (5U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group injected end of sequence conversions
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      JEOSIE         LL_ADC_IsEnabledIT_JEOS
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_JEOS(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_JEOS(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_JEOS) == (LL_ADC_IT_JEOS));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (6U)))) == ((0x1UL << (6U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC group injected context queue overflow interrupt state
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      JQOVFIE        LL_ADC_IsEnabledIT_JQOVF
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_JQOVF(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_JQOVF(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_JQOVF) == (LL_ADC_IT_JQOVF));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (10U)))) == ((0x1UL << (10U))));
N}
N
N/**
N  * @brief  Get state of interruption ADC analog watchdog 1
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      AWD1IE         LL_ADC_IsEnabledIT_AWD1
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_AWD1(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_AWD1(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_AWD1) == (LL_ADC_IT_AWD1));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (7U)))) == ((0x1UL << (7U))));
N}
N
N/**
N  * @brief  Get state of interruption Get ADC analog watchdog 2
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      AWD2IE         LL_ADC_IsEnabledIT_AWD2
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_AWD2(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_AWD2(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_AWD2) == (LL_ADC_IT_AWD2));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (8U)))) == ((0x1UL << (8U))));
N}
N
N/**
N  * @brief  Get state of interruption Get ADC analog watchdog 3
N  *         (0: interrupt disabled, 1: interrupt enabled).
N  * @rmtoll IER      AWD3IE         LL_ADC_IsEnabledIT_AWD3
N  * @param  ADCx ADC instance
N  * @retval State of bit (1 or 0).
N  */
N__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_AWD3(ADC_TypeDef *ADCx)
Xstatic __inline uint32_t LL_ADC_IsEnabledIT_AWD3(ADC_TypeDef *ADCx)
N{
N  return (uint32_t)(READ_BIT(ADCx->IER, LL_ADC_IT_AWD3) == (LL_ADC_IT_AWD3));
X  return (uint32_t)(((ADCx->IER) & ((0x1UL << (9U)))) == ((0x1UL << (9U))));
N}
N
N/**
N  * @}
N  */
N
N#if defined(USE_FULL_LL_DRIVER)
X#if 1L
N/** @defgroup ADC_LL_EF_Init Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization of some features of ADC common parameters and multimode */
NErrorStatus LL_ADC_CommonDeInit(ADC_Common_TypeDef *ADCxy_COMMON);
NErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct);
Nvoid        LL_ADC_CommonStructInit(LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct);
N
N/* De-initialization of ADC instance, ADC group regular and ADC group injected */
N/* (availability of ADC group injected depends on STM32 families) */
NErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx);
N
N/* Initialization of some features of ADC instance */
NErrorStatus LL_ADC_Init(ADC_TypeDef *ADCx, LL_ADC_InitTypeDef *ADC_InitStruct);
Nvoid        LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct);
N
N/* Initialization of some features of ADC instance and ADC group regular */
NErrorStatus LL_ADC_REG_Init(ADC_TypeDef *ADCx, LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct);
Nvoid        LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct);
N
N/* Initialization of some features of ADC instance and ADC group injected */
NErrorStatus LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct);
Nvoid        LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct);
N
N/**
N  * @}
N  */
N#endif /* USE_FULL_LL_DRIVER */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* ADC1 || ADC2 || ADC3 */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __STM32L4xx_LL_ADC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 20 ".\Source\Main\inc\lib.h" 2
N//-----------------------------------------------------------------------------------------------
N
N#include "CRC16.h"
L 1 ".\Source\Protocols\inc\CRC16.h" 1
N#ifndef __CRC_16_H
N#define __CRC_16_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Nunsigned short CRC16( 
N                     const unsigned char *puchMsg, 
N                     unsigned short usDataLen 
N                    );                             /* The function returns the CRC as a unsigned short type */
N                    
Nextern const unsigned char auchCRCHi[];
Nextern const char auchCRCLo[];                    
N
N#ifdef __cplusplus
N}
N#endif
N					
N#endif //__CRC_16_H
L 23 ".\Source\Main\inc\lib.h" 2
N
N#endif
L 5 ".\Source\Ext_Dev\inc\relay.h" 2
N
Nnamespace relay
N{
N  class TRelay
N  {
N  public:
N    typedef GPIO_TypeDef * TPort;
N    typedef std::uint32_t TClkMask;
N    typedef std::uint32_t TPinMask;
N    typedef char * TSign;
N	 
N    TRelay(const TPort, const TClkMask, const TPinMask, TSign Sign);
N	~TRelay();
N	    
N    void toggle() const;
N    void on() const;
N    void off() const;
N  protected:
N  private:
N    TPort GPIOx;        //
N    TClkMask ClkMask;   //   
N    TPinMask PinMask;   //
N    TSign Sign;         //
N  };
N}
N
N#endif
L 22 ".\Source\Main\inc\main.h" 2
N
N#include "Flash_driver.h"
L 1 ".\Source\MCU_Drivers\inc\Flash_driver.h" 1
N#ifndef __FLASH_DRIVER_H
N#define __FLASH_DRIVER_H
N
N#include "lib.h"
N
Nextern unsigned int Image$$SETS_ROM$$Base;
N
N/*  ,   Flash   64 (Page 63)
N*/
Nclass TFlash
N{
Npublic:
N  TFlash(); //        \
N                 - get_settings()
X  TFlash(); 
N  ~TFlash();
N	
N  void get_sets( uint8_t *Dest, uint16_t BytesQty );
N  void write_sets( const uint8_t *Src, uint16_t BytesQty );
N	void write_data( const uint8_t *Src );
N  
N  constexpr static uint8_t  MAX_PROG_TIME_MS = 10U;
N  constexpr static uint32_t PAGE_SIZE        = 0x800;
N  
N	uint8_t DataPageCtr;
N	constexpr static uint8_t  DATA_PAGE_QTY = 95U;
N//	constexpr static uint8_t  DATA_PAGE_QTY = 2U;
N
Nprotected:
Nprivate:                                                                                
N  void erase_page( uint32_t ) const;                                                    //   
N  bool write_page( const uint8_t *Src, uint16_t BytesQty, uint32_t ) const;             //   
N  void rdp_ob() const;                                                                  //    ,   
N  bool prog( const uint32_t *pData, uint32_t StartAddr, const uint32_t EndAddr ) const;       
N  void clear_all_error() const;                                                         //   
N                                                                                                 
N  constexpr static uint32_t FLASH_USER_START_ADDR = (uint32_t) &Image$$SETS_ROM$$Base;  //    
N	
N	constexpr static uint32_t DATA_START_ADDR = 0x0800E000;
N	
N  
N  void init_tmr();
N  void start_tmr() const;
N  void stop_tmr() const;
N  
N  TIM_TypeDef *Tmr;
N};
N
Nextern TFlash Flash;
N
N#endif
L 24 ".\Source\Main\inc\main.h" 2
N#include "sens_types.h"
N
N#define DBG_VERSION
N#ifdef DBG_VERSION
N  #define DBG_PRINT_1_STR(X)        printf(#X" = %s\n", (X).data())
N  #define DBG_PRINT_2_STR(X, Y)     printf(#X" = %s\n"#Y" = %s\n", (X).data(), (Y).data())
N  #define DBG_PRINT_3_STR(X, Y, Z)  printf(#X" = %s\n"#Y" = %s\n"#Z" = %s\n", (X).data(), (Y).data(), (Z).data())
N#else
S  #define DBG_PRINT_1_STR(X)        
S  #define DBG_PRINT_2_STR(X, Y)     
S  #define DBG_PRINT_3_STR(X, Y, Z)  
N#endif
N
N/* Private define ------------------------------------------------------------*/
N//#define USE_FULL_LL_DRIVER
N
N#ifndef NVIC_PRIORITYGROUP_0
N#define NVIC_PRIORITYGROUP_0         ((uint32_t)0x00000007) /*!< 0 bit  for pre-emption priority,
N                                                                 4 bits for subpriority */
N#define NVIC_PRIORITYGROUP_1         ((uint32_t)0x00000006) /*!< 1 bit  for pre-emption priority,
N                                                                 3 bits for subpriority */
N#define NVIC_PRIORITYGROUP_2         ((uint32_t)0x00000005) /*!< 2 bits for pre-emption priority,
N                                                                 2 bits for subpriority */
N#define NVIC_PRIORITYGROUP_3         ((uint32_t)0x00000004) /*!< 3 bits for pre-emption priority,
N                                                                 1 bit  for subpriority */
N#define NVIC_PRIORITYGROUP_4         ((uint32_t)0x00000003) /*!< 4 bits for pre-emption priority,
N                                                                 0 bit  for subpriority */
N#endif
N
N/* ITM Trace Enable Register Definitions */
N#define ITM_TER_PRINTF_Pos                   0U                                            /*!< ITM TER: PRINTF Position */
N#define ITM_TER_PRINTF_Msk                   (1UL << ITM_TER_PRINTF_Pos)                   /*!< ITM TER: PRINTF Mask */
N
N#define LD4                          LL_GPIO_PIN_8
N#define LD9                          LL_GPIO_PIN_12
N#define LED_BLUE_ONE                 LD4  
N#define LED_BLUE_TWO                 LD9
N                                     
N#define LD8                          LL_GPIO_PIN_14
N#define LED_ORANGE_TWO               LD8
N
N
N/*    */
N#define SECOND         1000U
N#define DECISECOND     100U
N
N#define MAIN_TIMER     TIM7
N
N/*    Data Watchpoint and Trace Unit*/
N#define    DWT_CYCCNT    *(volatile unsigned long *)0xE0001004
N#define    DWT_CONTROL   *(volatile unsigned long *)0xE0001000
N#define    SCB_DEMCR     *(volatile unsigned long *)0xE000EDFC
N
N/*      */
N#define N_ELEMENTS(X)    (sizeof(X) / sizeof(*(X)))
N
Nnamespace TClkSrc
N{
N  enum T : uint8_t
N  {
N    _MIN   = 0,
N    _HSE   = 0,
N    _HSI16 = 1,
N    _MSI   = 2,
N    _PLL   = 3,
N    
N    _MAX,
N  };
N}
N
Nnamespace TVcoreRange
N{
N  enum T : uint8_t
N  {
N    _MIN    = 0,
N    _RANGE1 = 0,
N    _RANGE2 = 1,
N    
N    _MAX,
N  }; 
N}
N
Nnamespace TLatency
N{
N  enum T : uint8_t
N  {
N    _MIN  = 0,
N    _0_WS = 0,
N    _1_WS = 1,
N    _2_WS = 2,
N    _3_WS = 3,
N    _4_WS = 4,
N    
N    _MAX,
N  }; 
N}
N
Nconstexpr uint16_t MAX_COVER_OPENED_ANGLE   = 271U; // ,     ,  
Nconstexpr uint16_t MAX_COVER_UNSEALED_ANGLE = 271U; // ,     ,  
N
N//extern const relay::TRelay RelOne;
Nextern const relay::TRelay RelTwo;
Nextern const relay::TRelay RelFour;
Nextern const relay::TRelay RelThree;
N
Nextern uint32_t RtosHeapSize;
N
N//extern USART::TUSART Usart;
N//extern MPU_9250::TAccGyroMagDriver_HL AccMagGyro;
N
N//******************************************************************************
N//     (declaration)
N//******************************************************************************
N
N#endif /* __MAIN_H */
L 6 "Source\Tasks\src\settings.cpp" 2
N#include "rtos_headers.h"
L 1 ".\Source\Main\inc\rtos_headers.h" 1
N#ifndef __RTOS_HEADERS_H
N#define __RTOS_HEADERS_H
N
N#pragma anon_unions
N
N#include "FreeRTOSConfig.h"
L 1 ".\Source\RTOS\inc\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N/* Ensure stdint is only used by the compiler, and not the assembler. */
N#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
X#if 0L || 1L || 0L
N #include <stdint.h>
N// extern uint32_t SystemCoreClock;
N#endif
N
N#define configUSE_PREEMPTION                    1 //1 -   ( + taskYIELD()/portYIELD_FROM_ISR() = ); 0 - 
N#define configUSE_IDLE_HOOK                     1 //      void vApplicationIdleHook( void );
N#define configUSE_TICK_HOOK                     0
N
N#define configCPU_CLOCK_HZ                      ( HSE_VALUE )
N//#define configCPU_CLOCK_HZ                      ( 32000000 )
N
N#define configTICK_RATE_HZ                      ( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES                    ( 7 )
N#define configMINIMAL_STACK_SIZE                ( ( uint16_t ) 64 )
N//#define configTOTAL_HEAP_SIZE                   ( ( size_t ) ( 10 * 1024 ) )
N#define configTOTAL_HEAP_SIZE                   ( ( size_t ) ( 4 * 1024 ) )
N#define configMAX_TASK_NAME_LEN                 ( 16 )
N#define configUSE_TRACE_FACILITY                1
N#define configUSE_16_BIT_TICKS                  0
N#define configIDLE_SHOULD_YIELD                 0
N#define configUSE_MUTEXES                       1
N#define configQUEUE_REGISTRY_SIZE               8
N#define configCHECK_FOR_STACK_OVERFLOW          1 //1 -     
N#define configUSE_RECURSIVE_MUTEXES             1
N#define configUSE_MALLOC_FAILED_HOOK            0
N#define configUSE_APPLICATION_TASK_TAG          0
N#define configUSE_COUNTING_SEMAPHORES           1
N#define configGENERATE_RUN_TIME_STATS           0
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES                   0
N#define configMAX_CO_ROUTINE_PRIORITIES         ( 2 )
N
N/* Software timer definitions. */
N#define configUSE_TIMERS                        1
N#define configTIMER_TASK_PRIORITY               ( 2 )
N#define configTIMER_QUEUE_LENGTH                10
N#define configTIMER_TASK_STACK_DEPTH            ( configMINIMAL_STACK_SIZE )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N#define INCLUDE_vTaskPrioritySet                1
N#define INCLUDE_uxTaskPriorityGet               1
N#define INCLUDE_vTaskDelete                     1
N#define INCLUDE_vTaskCleanUpResources           1
N#define INCLUDE_vTaskSuspend                    1
N#define INCLUDE_vTaskDelayUntil                 1
N#define INCLUDE_vTaskDelay                      1
N#define INCLUDE_xQueueGetMutexHolder            1
N#define INCLUDE_xTaskGetSchedulerState          1
N#define INCLUDE_eTaskGetState                   1
N#define INCLUDE_xTaskGetCurrentTaskHandle       1
N
N/* Cortex-M specific definitions. */
N#ifdef __NVIC_PRIO_BITS
N /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
N #define configPRIO_BITS                        __NVIC_PRIO_BITS
N#else
S #define configPRIO_BITS                        4        /* 15 priority levels */
N#endif
N
N/* The lowest interrupt priority that can be used in a call to a "set priority"
Nfunction. */
N#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY     0xf
N
N/* The highest interrupt priority that can be used by any interrupt service
Nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
NINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
NPRIORITY THAN THIS! (higher priorities are lower numeric values. */
N#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  3
N
N/* Interrupt priorities used by the kernel port layer itself.  These are generic
Nto all Cortex-M ports, and do not rely on any particular library functions. */
N#define configKERNEL_INTERRUPT_PRIORITY     ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY  ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N
N/* Normal assert() semantics without relying on the provision of an assert.h
Nheader file. */
N#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }
N
N/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
N   standard names. */
N#define vPortSVCHandler    SVC_Handler
N#define xPortPendSVHandler PendSV_Handler
N
N/* IMPORTANT: This define MUST be commented when used with STM32Cube firmware,
N              to prevent overwriting SysTick_Handler defined within STM32Cube HAL */
N#define xPortSysTickHandler SysTick_Handler
N
N#endif /* FREERTOS_CONFIG_H */
N
L 7 ".\Source\Main\inc\rtos_headers.h" 2
N#include "FreeRTOS.h"
L 1 ".\Source\RTOS\inc\FreeRTOS.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS ::std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 201112L <= __STDC_VERSION__) || (1L && 201103L <= 201103L)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::ptrdiff_t;
N      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X      #if !0L || (1L && 201103L <= 201103L)
N        using ::std::max_align_t;
N      #endif
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 ".\Source\RTOS\inc\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 ".\Source\RTOS\inc\projdefs.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#ifndef pdTICKS_TO_MS
N  #define pdTICKS_TO_MS( xTicks )    ( ( ( TickType_t ) ( xTicks ) * 1000u ) / configTICK_RATE_HZ )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 ".\Source\RTOS\inc\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 ".\Source\RTOS\inc\portable.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 ".\Source\RTOS\inc\deprecated_definitions.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 ".\Source\RTOS\inc\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 ".\Source\RTOS\inc\portmacro.h" 1
N/*
N * FreeRTOS Kernel V10.2.1
N * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
N#define portYIELD()																\
N{																				\
N	/* Set a PendSV to request a context switch. */								\
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
N																				\
N	/* Barriers are normally not required but do ensure the code is completely	\
N	within the specified behaviour for the architecture. */						\
N	__dsb( portSY_FULL_READ_WRITE );											\
N	__isb( portSY_FULL_READ_WRITE );											\
N}
X#define portYIELD()																{																					 									portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;																													 							__dsb( portSY_FULL_READ_WRITE );												__isb( portSY_FULL_READ_WRITE );											}
N/*-----------------------------------------------------------*/
N
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
N#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
N
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
N#endif
N
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 1 == 1
N
N	/* Check the configuration. */
N	#if( configMAX_PRIORITIES > 32 )
X	#if( ( 7 ) > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
N	#endif
N
N	/* Store/clear the ready priorities in a bit map. */
N	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
N	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
N
N	/*-----------------------------------------------------------*/
N
N	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
N
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
N	void vPortValidateInterruptPriority( void );
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#define portINLINE __inline
N
N#ifndef portFORCE_INLINE
N	#define portFORCE_INLINE __forceinline
N#endif
N
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
Xstatic __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
N{
N	__asm
N	{
N		/* Barrier instructions are not used as this function is only used to
N		lower the BASEPRI value. */
N		msr basepri, ulBASEPRI
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortRaiseBASEPRI( void )
Xstatic __forceinline void vPortRaiseBASEPRI( void )
N{
Nuint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulNewBASEPRI = ( 3 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
Xstatic __forceinline void vPortClearBASEPRIFromISR( void )
N{
N	__asm
N	{
N		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
N		used to lower the mask in an interrupt, so memory barriers are not 
N		used. */
N		msr basepri, #0
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
Xstatic __forceinline uint32_t ulPortRaiseBASEPRI( void )
N{
Nuint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulReturn, ulNewBASEPRI = ( 3 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		mrs ulReturn, basepri
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N
N	return ulReturn;
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
Xstatic __forceinline BaseType_t xPortIsInsideInterrupt( void )
N{
Nuint32_t ulCurrentInterrupt;
NBaseType_t xReturn;
N
N	/* Obtain the number of the currently executing interrupt. */
N	__asm
N	{
N		mrs ulCurrentInterrupt, ipsr
N	}
N
N	if( ulCurrentInterrupt == 0 )
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N	else
N	{
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N	}
N
N	return xReturn;
N}
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 ".\Source\RTOS\inc\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 ".\Source\RTOS\inc\mpu_wrappers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueGenericReceive					MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 ".\Source\RTOS\inc\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 ".\Source\RTOS\inc\FreeRTOS.h" 2
N
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
N	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
S	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
N	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
S	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
N	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
S	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
S	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
N	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
S	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
S	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
S	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
S	#define configASSERT( x )
S	#define configASSERT_DEFINED 0
N#else
N	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 1 == 1
N
N	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
N	#endif /* configTIMER_TASK_PRIORITY */
N
N	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
N	#endif /* configTIMER_QUEUE_LENGTH */
N
N	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
N	#endif /* configTIMER_TASK_STACK_DEPTH */
N
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
S	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 8 < 1 )
S	#define vQueueAddToRegistry( xQueue, pcName )
S	#define vQueueUnregisterQueue( xQueue )
S	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
N	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
N	/* Defaults to 0 for backward compatibility. */
N	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
N	/* Defaults to 1 for backward compatibility. */
N	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 0 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 1 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N	#define pcTaskGetTaskName pcTaskGetName
N	#define pcTimerGetTimerName pcTimerGetName
N	#define pcQueueGetQueueName pcQueueGetName
N	#define vTaskGetTaskInfo vTaskGetInfo
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ ( 16 ) ];
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t			uxDummy20;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t uxDummy8;
N		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 8 ".\Source\Main\inc\rtos_headers.h" 2
N#include "croutine.h"
L 1 ".\Source\RTOS\inc\croutine.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef CO_ROUTINE_H
N#define CO_ROUTINE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include croutine.h"
N#endif
N
N#include "list.h"
L 1 ".\Source\RTOS\inc\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
L 78 ".\Source\RTOS\inc\croutine.h" 2
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Used to hide the implementation of the co-routine control block.  The
Ncontrol block structure however has to be included in the header due to
Nthe macro implementation of the co-routine functionality. */
Ntypedef void * CoRoutineHandle_t;
N
N/* Defines the prototype to which co-routine functions must conform. */
Ntypedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );
N
Ntypedef struct corCoRoutineControlBlock
N{
N	crCOROUTINE_CODE 	pxCoRoutineFunction;
N	ListItem_t			xGenericListItem;	/*< List item used to place the CRCB in ready and blocked queues. */
N	ListItem_t			xEventListItem;		/*< List item used to place the CRCB in event lists. */
N	UBaseType_t 		uxPriority;			/*< The priority of the co-routine in relation to other co-routines. */
N	UBaseType_t 		uxIndex;			/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. */
N	uint16_t 			uxState;			/*< Used internally by the co-routine implementation. */
N} CRCB_t; /* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. */
N
N/**
N * croutine. h
N *<pre>
N BaseType_t xCoRoutineCreate(
N                                 crCOROUTINE_CODE pxCoRoutineCode,
N                                 UBaseType_t uxPriority,
N                                 UBaseType_t uxIndex
N                               );</pre>
N *
N * Create a new co-routine and add it to the list of co-routines that are
N * ready to run.
N *
N * @param pxCoRoutineCode Pointer to the co-routine function.  Co-routine
N * functions require special syntax - see the co-routine section of the WEB
N * documentation for more information.
N *
N * @param uxPriority The priority with respect to other co-routines at which
N *  the co-routine will run.
N *
N * @param uxIndex Used to distinguish between different co-routines that
N * execute the same function.  See the example below and the co-routine section
N * of the WEB documentation for further information.
N *
N * @return pdPASS if the co-routine was successfully created and added to a ready
N * list, otherwise an error code defined with ProjDefs.h.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N // This may not be necessary for const variables.
N static const char cLedToFlash[ 2 ] = { 5, 6 };
N static const TickType_t uxFlashRates[ 2 ] = { 200, 400 };
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N         // This co-routine just delays for a fixed period, then toggles
N         // an LED.  Two co-routines are created using this function, so
N         // the uxIndex parameter is used to tell the co-routine which
N         // LED to flash and how int32_t to delay.  This assumes xQueue has
N         // already been created.
N         vParTestToggleLED( cLedToFlash[ uxIndex ] );
N         crDELAY( xHandle, uxFlashRates[ uxIndex ] );
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }
N
N // Function that creates two co-routines.
N void vOtherFunction( void )
N {
N uint8_t ucParameterToPass;
N TaskHandle_t xHandle;
N
N     // Create two co-routines at priority 0.  The first is given index 0
N     // so (from the code above) toggles LED 5 every 200 ticks.  The second
N     // is given index 1 so toggles LED 6 every 400 ticks.
N     for( uxIndex = 0; uxIndex < 2; uxIndex++ )
N     {
N         xCoRoutineCreate( vFlashCoRoutine, 0, uxIndex );
N     }
N }
N   </pre>
N * \defgroup xCoRoutineCreate xCoRoutineCreate
N * \ingroup Tasks
N */
NBaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex );
N
N
N/**
N * croutine. h
N *<pre>
N void vCoRoutineSchedule( void );</pre>
N *
N * Run a co-routine.
N *
N * vCoRoutineSchedule() executes the highest priority co-routine that is able
N * to run.  The co-routine will execute until it either blocks, yields or is
N * preempted by a task.  Co-routines execute cooperatively so one
N * co-routine cannot be preempted by another, but can be preempted by a task.
N *
N * If an application comprises of both tasks and co-routines then
N * vCoRoutineSchedule should be called from the idle task (in an idle task
N * hook).
N *
N * Example usage:
N   <pre>
N // This idle task hook will schedule a co-routine each time it is called.
N // The rest of the idle task will execute between co-routine calls.
N void vApplicationIdleHook( void )
N {
N	vCoRoutineSchedule();
N }
N
N // Alternatively, if you do not require any other part of the idle task to
N // execute, the idle task hook can call vCoRoutineScheduler() within an
N // infinite loop.
N void vApplicationIdleHook( void )
N {
N    for( ;; )
N    {
N        vCoRoutineSchedule();
N    }
N }
N </pre>
N * \defgroup vCoRoutineSchedule vCoRoutineSchedule
N * \ingroup Tasks
N */
Nvoid vCoRoutineSchedule( void );
N
N/**
N * croutine. h
N * <pre>
N crSTART( CoRoutineHandle_t xHandle );</pre>
N *
N * This macro MUST always be called at the start of a co-routine function.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static int32_t ulAVariable;
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N          // Co-routine functionality goes here.
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }</pre>
N * \defgroup crSTART crSTART
N * \ingroup Tasks
N */
N#define crSTART( pxCRCB ) switch( ( ( CRCB_t * )( pxCRCB ) )->uxState ) { case 0:
N
N/**
N * croutine. h
N * <pre>
N crEND();</pre>
N *
N * This macro MUST always be called at the end of a co-routine function.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static int32_t ulAVariable;
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N          // Co-routine functionality goes here.
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }</pre>
N * \defgroup crSTART crSTART
N * \ingroup Tasks
N */
N#define crEND() }
N
N/*
N * These macros are intended for internal use by the co-routine implementation
N * only.  The macros should not be used directly by application writers.
N */
N#define crSET_STATE0( xHandle ) ( ( CRCB_t * )( xHandle ) )->uxState = (__LINE__ * 2); return; case (__LINE__ * 2):
N#define crSET_STATE1( xHandle ) ( ( CRCB_t * )( xHandle ) )->uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1):
N
N/**
N * croutine. h
N *<pre>
N crDELAY( CoRoutineHandle_t xHandle, TickType_t xTicksToDelay );</pre>
N *
N * Delay a co-routine for a fixed period of time.
N *
N * crDELAY can only be called from the co-routine function itself - not
N * from within a function called by the co-routine function.  This is because
N * co-routines do not maintain their own stack.
N *
N * @param xHandle The handle of the co-routine to delay.  This is the xHandle
N * parameter of the co-routine function.
N *
N * @param xTickToDelay The number of ticks that the co-routine should delay
N * for.  The actual amount of time this equates to is defined by
N * configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant portTICK_PERIOD_MS
N * can be used to convert ticks to milliseconds.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N // This may not be necessary for const variables.
N // We are to delay for 200ms.
N static const xTickType xDelayTime = 200 / portTICK_PERIOD_MS;
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N        // Delay for 200ms.
N        crDELAY( xHandle, xDelayTime );
N
N        // Do something here.
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }</pre>
N * \defgroup crDELAY crDELAY
N * \ingroup Tasks
N */
N#define crDELAY( xHandle, xTicksToDelay )												\
N	if( ( xTicksToDelay ) > 0 )															\
N	{																					\
N		vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );							\
N	}																					\
N	crSET_STATE0( ( xHandle ) );
X#define crDELAY( xHandle, xTicksToDelay )													if( ( xTicksToDelay ) > 0 )																{																							vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );								}																						crSET_STATE0( ( xHandle ) );
N
N/**
N * <pre>
N crQUEUE_SEND(
N                  CoRoutineHandle_t xHandle,
N                  QueueHandle_t pxQueue,
N                  void *pvItemToQueue,
N                  TickType_t xTicksToWait,
N                  BaseType_t *pxResult
N             )</pre>
N *
N * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
N * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
N *
N * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
N * xQueueSend() and xQueueReceive() can only be used from tasks.
N *
N * crQUEUE_SEND can only be called from the co-routine function itself - not
N * from within a function called by the co-routine function.  This is because
N * co-routines do not maintain their own stack.
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xHandle The handle of the calling co-routine.  This is the xHandle
N * parameter of the co-routine function.
N *
N * @param pxQueue The handle of the queue on which the data will be posted.
N * The handle is obtained as the return value when the queue is created using
N * the xQueueCreate() API function.
N *
N * @param pvItemToQueue A pointer to the data being posted onto the queue.
N * The number of bytes of each queued item is specified when the queue is
N * created.  This number of bytes is copied from pvItemToQueue into the queue
N * itself.
N *
N * @param xTickToDelay The number of ticks that the co-routine should block
N * to wait for space to become available on the queue, should space not be
N * available immediately. The actual amount of time this equates to is defined
N * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
N * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see example
N * below).
N *
N * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
N * data was successfully posted onto the queue, otherwise it will be set to an
N * error defined within ProjDefs.h.
N *
N * Example usage:
N   <pre>
N // Co-routine function that blocks for a fixed period then posts a number onto
N // a queue.
N static void prvCoRoutineFlashTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static BaseType_t xNumberToPost = 0;
N static BaseType_t xResult;
N
N    // Co-routines must begin with a call to crSTART().
N    crSTART( xHandle );
N
N    for( ;; )
N    {
N        // This assumes the queue has already been created.
N        crQUEUE_SEND( xHandle, xCoRoutineQueue, &xNumberToPost, NO_DELAY, &xResult );
N
N        if( xResult != pdPASS )
N        {
N            // The message was not posted!
N        }
N
N        // Increment the number to be posted onto the queue.
N        xNumberToPost++;
N
N        // Delay for 100 ticks.
N        crDELAY( xHandle, 100 );
N    }
N
N    // Co-routines must end with a call to crEND().
N    crEND();
N }</pre>
N * \defgroup crQUEUE_SEND crQUEUE_SEND
N * \ingroup Tasks
N */
N#define crQUEUE_SEND( xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult )			\
N{																						\
N	*( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );	\
N	if( *( pxResult ) == errQUEUE_BLOCKED )												\
N	{																					\
N		crSET_STATE0( ( xHandle ) );													\
N		*pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );					\
N	}																					\
N	if( *pxResult == errQUEUE_YIELD )													\
N	{																					\
N		crSET_STATE1( ( xHandle ) );													\
N		*pxResult = pdPASS;																\
N	}																					\
N}
X#define crQUEUE_SEND( xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult )			{																							*( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );		if( *( pxResult ) == errQUEUE_BLOCKED )													{																							crSET_STATE0( ( xHandle ) );															*pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );						}																						if( *pxResult == errQUEUE_YIELD )														{																							crSET_STATE1( ( xHandle ) );															*pxResult = pdPASS;																	}																					}
N
N/**
N * croutine. h
N * <pre>
N  crQUEUE_RECEIVE(
N                     CoRoutineHandle_t xHandle,
N                     QueueHandle_t pxQueue,
N                     void *pvBuffer,
N                     TickType_t xTicksToWait,
N                     BaseType_t *pxResult
N                 )</pre>
N *
N * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
N * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
N *
N * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
N * xQueueSend() and xQueueReceive() can only be used from tasks.
N *
N * crQUEUE_RECEIVE can only be called from the co-routine function itself - not
N * from within a function called by the co-routine function.  This is because
N * co-routines do not maintain their own stack.
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xHandle The handle of the calling co-routine.  This is the xHandle
N * parameter of the co-routine function.
N *
N * @param pxQueue The handle of the queue from which the data will be received.
N * The handle is obtained as the return value when the queue is created using
N * the xQueueCreate() API function.
N *
N * @param pvBuffer The buffer into which the received item is to be copied.
N * The number of bytes of each queued item is specified when the queue is
N * created.  This number of bytes is copied into pvBuffer.
N *
N * @param xTickToDelay The number of ticks that the co-routine should block
N * to wait for data to become available from the queue, should data not be
N * available immediately. The actual amount of time this equates to is defined
N * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
N * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see the
N * crQUEUE_SEND example).
N *
N * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
N * data was successfully retrieved from the queue, otherwise it will be set to
N * an error code as defined within ProjDefs.h.
N *
N * Example usage:
N <pre>
N // A co-routine receives the number of an LED to flash from a queue.  It
N // blocks on the queue until the number is received.
N static void prvCoRoutineFlashWorkTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static BaseType_t xResult;
N static UBaseType_t uxLEDToFlash;
N
N    // All co-routines must start with a call to crSTART().
N    crSTART( xHandle );
N
N    for( ;; )
N    {
N        // Wait for data to become available on the queue.
N        crQUEUE_RECEIVE( xHandle, xCoRoutineQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
N
N        if( xResult == pdPASS )
N        {
N            // We received the LED to flash - flash it!
N            vParTestToggleLED( uxLEDToFlash );
N        }
N    }
N
N    crEND();
N }</pre>
N * \defgroup crQUEUE_RECEIVE crQUEUE_RECEIVE
N * \ingroup Tasks
N */
N#define crQUEUE_RECEIVE( xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult )			\
N{																						\
N	*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );		\
N	if( *( pxResult ) == errQUEUE_BLOCKED ) 											\
N	{																					\
N		crSET_STATE0( ( xHandle ) );													\
N		*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );				\
N	}																					\
N	if( *( pxResult ) == errQUEUE_YIELD )												\
N	{																					\
N		crSET_STATE1( ( xHandle ) );													\
N		*( pxResult ) = pdPASS;															\
N	}																					\
N}
X#define crQUEUE_RECEIVE( xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult )			{																							*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );			if( *( pxResult ) == errQUEUE_BLOCKED ) 												{																							crSET_STATE0( ( xHandle ) );															*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );					}																						if( *( pxResult ) == errQUEUE_YIELD )													{																							crSET_STATE1( ( xHandle ) );															*( pxResult ) = pdPASS;																}																					}
N
N/**
N * croutine. h
N * <pre>
N  crQUEUE_SEND_FROM_ISR(
N                            QueueHandle_t pxQueue,
N                            void *pvItemToQueue,
N                            BaseType_t xCoRoutinePreviouslyWoken
N                       )</pre>
N *
N * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
N * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
N * functions used by tasks.
N *
N * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
N * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
N * xQueueReceiveFromISR() can only be used to pass data between a task and and
N * ISR.
N *
N * crQUEUE_SEND_FROM_ISR can only be called from an ISR to send data to a queue
N * that is being used from within a co-routine.
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xCoRoutinePreviouslyWoken This is included so an ISR can post onto
N * the same queue multiple times from a single interrupt.  The first call
N * should always pass in pdFALSE.  Subsequent calls should pass in
N * the value returned from the previous call.
N *
N * @return pdTRUE if a co-routine was woken by posting onto the queue.  This is
N * used by the ISR to determine if a context switch may be required following
N * the ISR.
N *
N * Example usage:
N <pre>
N // A co-routine that blocks on a queue waiting for characters to be received.
N static void vReceivingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N char cRxedChar;
N BaseType_t xResult;
N
N     // All co-routines must start with a call to crSTART().
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N         // Wait for data to become available on the queue.  This assumes the
N         // queue xCommsRxQueue has already been created!
N         crQUEUE_RECEIVE( xHandle, xCommsRxQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
N
N         // Was a character received?
N         if( xResult == pdPASS )
N         {
N             // Process the character here.
N         }
N     }
N
N     // All co-routines must end with a call to crEND().
N     crEND();
N }
N
N // An ISR that uses a queue to send characters received on a serial port to
N // a co-routine.
N void vUART_ISR( void )
N {
N char cRxedChar;
N BaseType_t xCRWokenByPost = pdFALSE;
N
N     // We loop around reading characters until there are none left in the UART.
N     while( UART_RX_REG_NOT_EMPTY() )
N     {
N         // Obtain the character from the UART.
N         cRxedChar = UART_RX_REG;
N
N         // Post the character onto a queue.  xCRWokenByPost will be pdFALSE
N         // the first time around the loop.  If the post causes a co-routine
N         // to be woken (unblocked) then xCRWokenByPost will be set to pdTRUE.
N         // In this manner we can ensure that if more than one co-routine is
N         // blocked on the queue only one is woken by this ISR no matter how
N         // many characters are posted to the queue.
N         xCRWokenByPost = crQUEUE_SEND_FROM_ISR( xCommsRxQueue, &cRxedChar, xCRWokenByPost );
N     }
N }</pre>
N * \defgroup crQUEUE_SEND_FROM_ISR crQUEUE_SEND_FROM_ISR
N * \ingroup Tasks
N */
N#define crQUEUE_SEND_FROM_ISR( pxQueue, pvItemToQueue, xCoRoutinePreviouslyWoken ) xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )
N
N
N/**
N * croutine. h
N * <pre>
N  crQUEUE_SEND_FROM_ISR(
N                            QueueHandle_t pxQueue,
N                            void *pvBuffer,
N                            BaseType_t * pxCoRoutineWoken
N                       )</pre>
N *
N * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
N * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
N * functions used by tasks.
N *
N * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
N * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
N * xQueueReceiveFromISR() can only be used to pass data between a task and and
N * ISR.
N *
N * crQUEUE_RECEIVE_FROM_ISR can only be called from an ISR to receive data
N * from a queue that is being used from within a co-routine (a co-routine
N * posted to the queue).
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvBuffer A pointer to a buffer into which the received item will be
N * placed.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from the queue into
N * pvBuffer.
N *
N * @param pxCoRoutineWoken A co-routine may be blocked waiting for space to become
N * available on the queue.  If crQUEUE_RECEIVE_FROM_ISR causes such a
N * co-routine to unblock *pxCoRoutineWoken will get set to pdTRUE, otherwise
N * *pxCoRoutineWoken will remain unchanged.
N *
N * @return pdTRUE an item was successfully received from the queue, otherwise
N * pdFALSE.
N *
N * Example usage:
N <pre>
N // A co-routine that posts a character to a queue then blocks for a fixed
N // period.  The character is incremented each time.
N static void vSendingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // cChar holds its value while this co-routine is blocked and must therefore
N // be declared static.
N static char cCharToTx = 'a';
N BaseType_t xResult;
N
N     // All co-routines must start with a call to crSTART().
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N         // Send the next character to the queue.
N         crQUEUE_SEND( xHandle, xCoRoutineQueue, &cCharToTx, NO_DELAY, &xResult );
N
N         if( xResult == pdPASS )
N         {
N             // The character was successfully posted to the queue.
N         }
N		 else
N		 {
N			// Could not post the character to the queue.
N		 }
N
N         // Enable the UART Tx interrupt to cause an interrupt in this
N		 // hypothetical UART.  The interrupt will obtain the character
N		 // from the queue and send it.
N		 ENABLE_RX_INTERRUPT();
N
N		 // Increment to the next character then block for a fixed period.
N		 // cCharToTx will maintain its value across the delay as it is
N		 // declared static.
N		 cCharToTx++;
N		 if( cCharToTx > 'x' )
N		 {
N			cCharToTx = 'a';
N		 }
N		 crDELAY( 100 );
N     }
N
N     // All co-routines must end with a call to crEND().
N     crEND();
N }
N
N // An ISR that uses a queue to receive characters to send on a UART.
N void vUART_ISR( void )
N {
N char cCharToTx;
N BaseType_t xCRWokenByPost = pdFALSE;
N
N     while( UART_TX_REG_EMPTY() )
N     {
N         // Are there any characters in the queue waiting to be sent?
N		 // xCRWokenByPost will automatically be set to pdTRUE if a co-routine
N		 // is woken by the post - ensuring that only a single co-routine is
N		 // woken no matter how many times we go around this loop.
N         if( crQUEUE_RECEIVE_FROM_ISR( pxQueue, &cCharToTx, &xCRWokenByPost ) )
N		 {
N			 SEND_CHARACTER( cCharToTx );
N		 }
N     }
N }</pre>
N * \defgroup crQUEUE_RECEIVE_FROM_ISR crQUEUE_RECEIVE_FROM_ISR
N * \ingroup Tasks
N */
N#define crQUEUE_RECEIVE_FROM_ISR( pxQueue, pvBuffer, pxCoRoutineWoken ) xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )
N
N/*
N * This function is intended for internal use by the co-routine macros only.
N * The macro nature of the co-routine implementation requires that the
N * prototype appears here.  The function should not be used by application
N * writers.
N *
N * Removes the current co-routine from its ready list and places it in the
N * appropriate delayed list.
N */
Nvoid vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList );
N
N/*
N * This function is intended for internal use by the queue implementation only.
N * The function should not be used by application writers.
N *
N * Removes the highest priority co-routine from the event list and places it in
N * the pending ready list.
N */
NBaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList );
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* CO_ROUTINE_H */
L 9 ".\Source\Main\inc\rtos_headers.h" 2
N#include "task.h"
L 1 ".\Source\RTOS\inc\task.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 ".\Source\RTOS\inc\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
S#define LIST_H
S
S/*
S * The list structure members are modified from within interrupts, and therefore
S * by rights should be declared volatile.  However, they are only modified in a
S * functionally atomic way (within critical sections of with the scheduler
S * suspended) and are either passed by reference into a function or indexed via
S * a volatile variable.  Therefore, in all use cases tested so far, the volatile
S * qualifier can be omitted in order to provide a moderate performance
S * improvement without adversely affecting functional behaviour.  The assembly
S * instructions generated by the IAR, ARM and GCC compilers when the respective
S * compiler's options were set for maximum optimisation has been inspected and
S * deemed to be as intended.  That said, as compiler technology advances, and
S * especially if aggressive cross module optimisation is used (a use case that
S * has not been exercised to any great extend) then it is feasible that the
S * volatile qualifier will be needed for correct optimisation.  It is expected
S * that a compiler removing essential code because, without the volatile
S * qualifier on the list structure members and with aggressive cross module
S * optimisation, the compiler deemed the code unnecessary will result in
S * complete and obvious failure of the scheduler.  If this is ever experienced
S * then the volatile qualifier can be inserted in the relevant places within the
S * list structures by simply defining configLIST_VOLATILE to volatile in
S * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
S * If configLIST_VOLATILE is not defined then the preprocessor directives below
S * will simply #define configLIST_VOLATILE away completely.
S *
S * To use volatile list structure members then add the following line to
S * FreeRTOSConfig.h (without the quotes):
S * "#define configLIST_VOLATILE volatile"
S */
S#ifndef configLIST_VOLATILE
S	#define configLIST_VOLATILE
S#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/* Macros that can be used to place known values within the list structures,
Sthen check that the known values do not get corrupted during the execution of
Sthe application.   These may catch the list data structures being overwritten in
Smemory.  They will not catch data errors caused by incorrect configuration or
Suse of FreeRTOS.*/
S#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
S	/* Define the macros to do nothing. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
S	#define listTEST_LIST_INTEGRITY( pxList )
S#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
S
S
S/*
S * Definition of the only type of object that a list can contain.
S */
Sstruct xLIST_ITEM
S{
S	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
S	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
S	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
S	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
S	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
S	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S};
Stypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
S
Sstruct xMINI_LIST_ITEM
S{
S	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S	configLIST_VOLATILE TickType_t xItemValue;
S	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
S	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
S};
Stypedef struct xMINI_LIST_ITEM MiniListItem_t;
S
S/*
S * Definition of the type of queue used by the scheduler.
S */
Stypedef struct xLIST
S{
S	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
S	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
S	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
S	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S} List_t;
S
S/*
S * Access macro to set the owner of a list item.  The owner of a list item
S * is the object (usually a TCB) that contains the list item.
S *
S * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
S * \ingroup LinkedList
S */
S#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
S
S/*
S * Access macro to get the owner of a list item.  The owner of a list item
S * is the object (usually a TCB) that contains the list item.
S *
S * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
S * \ingroup LinkedList
S */
S#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
S
S/*
S * Access macro to set the value of the list item.  In most cases the value is
S * used to sort the list in descending order.
S *
S * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
S * \ingroup LinkedList
S */
S#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
S
S/*
S * Access macro to retrieve the value of the list item.  The value can
S * represent anything - for example the priority of a task, or the time at
S * which a task should be unblocked.
S *
S * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
S * \ingroup LinkedList
S */
S#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
S
S/*
S * Access macro to retrieve the value of the list item at the head of a given
S * list.
S *
S * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
S * \ingroup LinkedList
S */
S#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
S
S/*
S * Return the list item at the head of the list.
S *
S * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
S * \ingroup LinkedList
S */
S#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
S
S/*
S * Return the list item at the head of the list.
S *
S * \page listGET_NEXT listGET_NEXT
S * \ingroup LinkedList
S */
S#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
S
S/*
S * Return the list item that marks the end of the list
S *
S * \page listGET_END_MARKER listGET_END_MARKER
S * \ingroup LinkedList
S */
S#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
S
S/*
S * Access macro to determine if a list contains any items.  The macro will
S * only have the value true if the list is empty.
S *
S * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
S * \ingroup LinkedList
S */
S#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
S
S/*
S * Access macro to return the number of items in the list.
S */
S#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
S
S/*
S * Access function to obtain the owner of the next entry in a list.
S *
S * The list member pxIndex is used to walk through a list.  Calling
S * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
S * and returns that entry's pxOwner parameter.  Using multiple calls to this
S * function it is therefore possible to move through every item contained in
S * a list.
S *
S * The pxOwner parameter of a list item is a pointer to the object that owns
S * the list item.  In the scheduler this is normally a task control block.
S * The pxOwner parameter effectively creates a two way link between the list
S * item and its owner.
S *
S * @param pxTCB pxTCB is set to the address of the owner of the next list item.
S * @param pxList The list from which the next item owner is to be returned.
S *
S * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
S * \ingroup LinkedList
S */
S#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
S{																							\
SList_t * const pxConstList = ( pxList );													\
S	/* Increment the index to the next item and return the item, ensuring */				\
S	/* we don't return the marker used at the end of the list.  */							\
S	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
S	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
S	{																						\
S		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
S	}																						\
S	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
S}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
S
S
S/*
S * Access function to obtain the owner of the first entry in a list.  Lists
S * are normally sorted in ascending item value order.
S *
S * This function returns the pxOwner member of the first item in the list.
S * The pxOwner parameter of a list item is a pointer to the object that owns
S * the list item.  In the scheduler this is normally a task control block.
S * The pxOwner parameter effectively creates a two way link between the list
S * item and its owner.
S *
S * @param pxList The list from which the owner of the head item is to be
S * returned.
S *
S * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
S * \ingroup LinkedList
S */
S#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
S
S/*
S * Check to see if a list item is within a list.  The list item maintains a
S * "container" pointer that points to the list it is in.  All this macro does
S * is check to see if the container and the list match.
S *
S * @param pxList The list we want to know if the list item is within.
S * @param pxListItem The list item we want to know if is in the list.
S * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
S */
S#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
S
S/*
S * Return the list a list item is contained within (referenced from).
S *
S * @param pxListItem The list item being queried.
S * @return A pointer to the List_t object that references the pxListItem
S */
S#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
S
S/*
S * This provides a crude means of knowing if a list has been initialised, as
S * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
S * function.
S */
S#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
S
S/*
S * Must be called before a list is used!  This initialises all the members
S * of the list structure and inserts the xListEnd item into the list as a
S * marker to the back of the list.
S *
S * @param pxList Pointer to the list being initialised.
S *
S * \page vListInitialise vListInitialise
S * \ingroup LinkedList
S */
Svoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
S
S/*
S * Must be called before a list item is used.  This sets the list container to
S * null so the item does not think that it is already contained in a list.
S *
S * @param pxItem Pointer to the list item being initialised.
S *
S * \page vListInitialiseItem vListInitialiseItem
S * \ingroup LinkedList
S */
Svoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
S
S/*
S * Insert a list item into a list.  The item will be inserted into the list in
S * a position determined by its item value (descending item value order).
S *
S * @param pxList The list into which the item is to be inserted.
S *
S * @param pxNewListItem The item that is to be placed in the list.
S *
S * \page vListInsert vListInsert
S * \ingroup LinkedList
S */
Svoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
S
S/*
S * Insert a list item into a list.  The item will be inserted in a position
S * such that it will be the last item within the list returned by multiple
S * calls to listGET_OWNER_OF_NEXT_ENTRY.
S *
S * The list member pxIndex is used to walk through a list.  Calling
S * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
S * Placing an item in a list using vListInsertEnd effectively places the item
S * in the list position pointed to by pxIndex.  This means that every other
S * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
S * the pxIndex parameter again points to the item being inserted.
S *
S * @param pxList The list into which the item is to be inserted.
S *
S * @param pxNewListItem The list item to be inserted into the list.
S *
S * \page vListInsertEnd vListInsertEnd
S * \ingroup LinkedList
S */
Svoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
S
S/*
S * Remove an item from a list.  The list item has a pointer to the list that
S * it is in, so only the list item need be passed into the function.
S *
S * @param uxListRemove The item to be removed.  The item will remove itself from
S * the list pointed to by it's pxContainer parameter.
S *
S * @return The number of items that remain in the list after the list item has
S * been removed.
S *
S * \page uxListRemove uxListRemove
S * \ingroup LinkedList
S */
SUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif
N
L 79 ".\Source\RTOS\inc\task.h" 2
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V9.0.0"
N#define tskKERNEL_VERSION_MAJOR 9
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 0
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,
N							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X							TaskHandle_t * const pxCreatedTask ) ;  
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
S									const char * const pcName,
S									const uint32_t ulStackDepth,
S									void * const pvParameters,
S									UBaseType_t uxPriority,
S									StackType_t * const puxStackBuffer,
S									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vtoggle_led();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N
Nvoid vApplicationIdleHook(void);
N
N#ifdef __cplusplus
N}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 10 ".\Source\Main\inc\rtos_headers.h" 2
N#include "queue.h"
L 1 ".\Source\RTOS\inc\queue.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
N#endif
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreateStatic(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize,
N							  uint8_t *pucQueueStorageBuffer,
N							  StaticQueue_t *pxQueueBuffer
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @param pucQueueStorageBuffer If uxItemSize is not zero then
N * pucQueueStorageBuffer must point to a uint8_t array that is at least large
N * enough to hold the maximum number of items that can be in the queue at any
N * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
N * zero then pucQueueStorageBuffer can be NULL.
N *
N * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
N * will be used to hold the queue's data structure.
N *
N * @return If the queue is created then a handle to the created queue is
N * returned.  If pxQueueBuffer is NULL then NULL is returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N #define QUEUE_LENGTH 10
N #define ITEM_SIZE sizeof( uint32_t )
N
N // xQueueBuffer will hold the queue structure.
N StaticQueue_t xQueueBuffer;
N
N // ucQueueStorage will hold the items posted to the queue.  Must be at least
N // [(queue length) * ( queue item size)] bytes long.
N uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
N							ITEM_SIZE	  // The size of each item in the queue
N							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
N							&xQueueBuffer ); // The buffer that will hold the queue structure.
N
N	// The queue is guaranteed to be created successfully as no dynamic memory
N	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreateStatic xQueueCreateStatic
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
NQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 8 > 0 )
N	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) ;  
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 8 > 0 )
N	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
X	void vQueueUnregisterQueue( QueueHandle_t xQueue ) ;
N#endif
N
N/*
N * The queue registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
N * up and return the name of a queue in the queue registry from the queue's
N * handle.
N *
N * @param xQueue The handle of the queue the name of which will be returned.
N * @return If the queue is in the registry then a pointer to the name of the
N * queue is returned.  If the queue is not in the registry then NULL is
N * returned.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 8 > 0 )
N	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	const char *pcQueueGetName( QueueHandle_t xQueue ) ;  
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* QUEUE_H */
N
L 11 ".\Source\Main\inc\rtos_headers.h" 2
N#include "semphr.h"
L 1 ".\Source\RTOS\inc\semphr.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef SEMAPHORE_H
N#define SEMAPHORE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
N#endif
N
N#include "queue.h"
N
Ntypedef QueueHandle_t SemaphoreHandle_t;
N
N#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
N#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
N#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
N
N
N/**
N * semphr. h
N * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
N * The queue length is 1 as this is a binary semaphore.  The data size is 0
N * as we don't want to actually store any data - we just want to know if the
N * queue is empty or full.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
N    // This is a macro so pass the variable in directly.
N    vSemaphoreCreateBinary( xSemaphore );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define vSemaphoreCreateBinary( xSemaphore )																							\
N		{																																	\
N			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
N			if( ( xSemaphore ) != NULL )																									\
N			{																																\
N				( void ) xSemaphoreGive( ( xSemaphore ) );																					\
N			}																																\
N		}
X	#define vSemaphoreCreateBinary( xSemaphore )																									{																																				( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );				if( ( xSemaphore ) != NULL )																												{																																				( void ) xSemaphoreGive( ( xSemaphore ) );																								}																																		}
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @return Handle to the created semaphore, or NULL if the memory required to
N * hold the semaphore's data structures could not be allocated.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateBinary xSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * NOTE: In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the semaphore is created then a handle to the created semaphore is
N * returned.  If pxSemaphoreBuffer is NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // The semaphore's data structures will be placed in the xSemaphoreBuffer
N    // variable, the address of which is passed into the function.  The
N    // function's parameter is not NULL, so the function will not attempt any
N    // dynamic memory allocation, and therefore the function will not return
N    // return NULL.
N    xSemaphore = xSemaphoreCreateBinary( &xSemaphoreBuffer );
N
N    // Rest of task code goes here.
N }
N </pre>
N * \defgroup xSemaphoreCreateBinaryStatic xSemaphoreCreateBinaryStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>xSemaphoreTake(
N *                   SemaphoreHandle_t xSemaphore,
N *                   TickType_t xBlockTime
N *               )</pre>
N *
N * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting().
N *
N * @param xSemaphore A handle to the semaphore being taken - obtained when
N * the semaphore was created.
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  A block
N * time of portMAX_DELAY can be used to block indefinitely (provided
N * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE
N * if xBlockTime expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N // A task that creates a semaphore.
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = xSemaphoreCreateBinary();
N }
N
N // A task that uses the semaphore.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xSemaphore != NULL )
N    {
N        // See if we can obtain the semaphore.  If the semaphore is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the semaphore and can now access the
N            // shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource.  Release the
N            // semaphore.
N            xSemaphoreGive( xSemaphore );
N        }
N        else
N        {
N            // We could not obtain the semaphore and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTake xSemaphoreTake
N * \ingroup Semaphores
N */
N#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )
N
N/**
N * semphr. h
N * xSemaphoreTakeRecursive(
N *                          SemaphoreHandle_t xMutex,
N *                          TickType_t xBlockTime
N *                        )
N *
N * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being obtained.  This is the
N * handle returned by xSemaphoreCreateRecursiveMutex();
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  If
N * the task already owns the semaphore then xSemaphoreTakeRecursive() will
N * return immediately no matter what the value of xBlockTime.
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
N * expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, but instead buried in a more complex
N			// call structure.  This is just for illustrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
N#endif
N
N/**
N * semphr. h
N * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
N *
N * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
N *
N * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
N * an alternative which can be used from an ISR.
N *
N * This macro must also not be used on semaphores created using
N * xSemaphoreCreateRecursiveMutex().
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
N * Semaphores are implemented using queues.  An error can occur if there is
N * no space on the queue to post a message - indicating that the
N * semaphore was not first obtained correctly.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = vSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N        {
N            // We would expect this call to fail because we cannot give
N            // a semaphore without first "taking" it!
N        }
N
N        // Obtain the semaphore - don't block if the semaphore is not
N        // immediately available.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
N        {
N            // We now have the semaphore and can access the shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource so can free the
N            // semaphore.
N            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N            {
N                // We would not expect this call to fail because we must have
N                // obtained the semaphore to get here.
N            }
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGive xSemaphoreGive
N * \ingroup Semaphores
N */
N#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
N
N/**
N * semphr. h
N * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
N *
N * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being released, or 'given'.  This is the
N * handle returned by xSemaphoreCreateMutex();
N *
N * @return pdTRUE if the semaphore was given.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, it would be more likely that the calls
N			// to xSemaphoreGiveRecursive() would be called as a call stack
N			// unwound.  This is just for demonstrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
N#endif
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreGiveFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR.
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
N *
N * Example usage:
N <pre>
N \#define LONG_TIME 0xffff
N \#define TICKS_TO_WAIT	10
N SemaphoreHandle_t xSemaphore = NULL;
N
N // Repetitive task.
N void vATask( void * pvParameters )
N {
N    for( ;; )
N    {
N        // We want this task to run every 10 ticks of a timer.  The semaphore
N        // was created before this task was started.
N
N        // Block waiting for the semaphore to become available.
N        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
N        {
N            // It is time to execute.
N
N            // ...
N
N            // We have finished our task.  Return to the top of the loop where
N            // we will block on the semaphore until it is time to execute
N            // again.  Note when using the semaphore for synchronisation with an
N			// ISR in this manner there is no need to 'give' the semaphore back.
N        }
N    }
N }
N
N // Timer ISR
N void vTimerISR( void * pvParameters )
N {
N static uint8_t ucLocalTickCount = 0;
N static BaseType_t xHigherPriorityTaskWoken;
N
N    // A timer tick has occurred.
N
N    // ... Do other time functions.
N
N    // Is it time for vATask () to run?
N	xHigherPriorityTaskWoken = pdFALSE;
N    ucLocalTickCount++;
N    if( ucLocalTickCount >= TICKS_TO_WAIT )
N    {
N        // Unblock the task by releasing the semaphore.
N        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
N
N        // Reset the count so we release the semaphore again in 10 ticks time.
N        ucLocalTickCount = 0;
N    }
N
N    if( xHigherPriorityTaskWoken != pdFALSE )
N    {
N        // We can force a context switch here.  Context switching from an
N        // ISR uses port specific syntax.  Check the demo task for your port
N        // to find the syntax required.
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
N * \ingroup Semaphores
N */
N#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreTakeFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
N * previously been created with a call to xSemaphoreCreateBinary() or
N * xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR, however taking a semaphore from an ISR
N * is not a common operation.  It is likely to only be useful when taking a
N * counting semaphore when an interrupt is obtaining an object from a resource
N * pool (when the semaphore count indicates the number of resources available).
N *
N * @param xSemaphore A handle to the semaphore being taken.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully taken, otherwise
N * pdFALSE
N */
N#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return If the mutex was successfully created then a handle to the created
N * semaphore is returned.  If there was not enough heap to allocate the mutex
N * data structures then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateMutex xSemaphoreCreateMutex
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will be used to hold the mutex's data structure, removing the need for
N * the memory to be allocated dynamically.
N *
N * @return If the mutex was successfully created then a handle to the created
N * mutex is returned.  If pxMutexBuffer was NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A mutex cannot be used before it has been created.  xMutexBuffer is
N    // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
N    // attempted.
N    xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateMutexStatic xSemaphoreCreateMutexStatic
N * \ingroup Semaphores
N */
N #if( configSUPPORT_STATIC_ALLOCATION == 1 )
X #if( 0 == 1 )
S	#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
N * SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateRecursiveMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutex xSemaphoreCreateRecursiveMutex
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 1 == 1 ) && ( 1 == 1 ) )
N	#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the recursive mutex's data structure,
N * removing the need for the memory to be allocated dynamically.
N *
N * @return If the recursive mutex was successfully created then a handle to the
N * created recursive mutex is returned.  If pxMutexBuffer was NULL then NULL is
N * returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A recursive semaphore cannot be used before it is created.  Here a
N    // recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().
N    // The address of xMutexBuffer is passed into the function, and will hold
N    // the mutexes data structures - so no dynamic memory allocation will be
N    // attempted.
N    xSemaphore = xSemaphoreCreateRecursiveMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutexStatic xSemaphoreCreateRecursiveMutexStatic
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 0 == 1 ) && ( 1 == 1 ) )
S	#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer can
N * instead optionally provide the memory that will get used by the counting
N * semaphore.  xSemaphoreCreateCountingStatic() therefore allows a counting
N * semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @return Handle to the created semaphore.  Null if the semaphore could not be
N *         created.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
N    // The max value to which the semaphore can count should be 10, and the
N    // initial value assigned to the count should be 0.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer must
N * provide the memory.  xSemaphoreCreateCountingStatic() therefore allows a
N * counting semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the counting semaphore was successfully created then a handle to
N * the created counting semaphore is returned.  If pxSemaphoreBuffer was NULL
N * then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Counting semaphore cannot be used before they have been created.  Create
N    // a counting semaphore using xSemaphoreCreateCountingStatic().  The max
N    // value to which the semaphore can count is 10, and the initial value
N    // assigned to the count will be 0.  The address of xSemaphoreBuffer is
N    // passed in and will be used to hold the semaphore structure, so no dynamic
N    // memory allocation will be used.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );
N
N    // No memory allocation was attempted so xSemaphore cannot be NULL, so there
N    // is no need to check its value.
N }
N </pre>
N * \defgroup xSemaphoreCreateCountingStatic xSemaphoreCreateCountingStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
N *
N * Delete a semaphore.  This function must be used with care.  For example,
N * do not delete a mutex type semaphore if the mutex is held by a task.
N *
N * @param xSemaphore A handle to the semaphore to be deleted.
N *
N * \defgroup vSemaphoreDelete vSemaphoreDelete
N * \ingroup Semaphores
N */
N#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
N *
N * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
N * If xMutex is not a mutex type semaphore, or the mutex is available (not held
N * by a task), return NULL.
N *
N * Note: This is a good way of determining if the calling task is the mutex
N * holder, but not a good way of determining the identity of the mutex holder as
N * the holder may change between the function exiting and the returned value
N * being tested.
N */
N#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>UBaseType_t uxSemaphoreGetCount( SemaphoreHandle_t xSemaphore );</pre>
N *
N * If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns
N * its current count value.  If the semaphore is a binary semaphore then
N * uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the
N * semaphore is not available.
N *
N */
N#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
N
N#endif /* SEMAPHORE_H */
N
N
L 12 ".\Source\Main\inc\rtos_headers.h" 2
N#include "portmacro.h"
N#include "timers.h"
L 1 ".\Source\RTOS\inc\timers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef TIMERS_H
N#define TIMERS_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include timers.h"
N#endif
N
N/*lint -e537 This headers are only multiply included if the application code
Nhappens to also be including task.h. */
N#include "task.h"
N/*lint +e537 */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N/* IDs for commands that can be sent/received on the timer queue.  These are to
Nbe used solely through the macros that make up the public software timer API,
Nas defined below.  The commands that are sent from interrupts must use the
Nhighest numbers as tmrFIRST_FROM_ISR_COMMAND is used to determine if the task
Nor interrupt version of the queue send function should be used. */
N#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR 	( ( BaseType_t ) -2 )
N#define tmrCOMMAND_EXECUTE_CALLBACK				( ( BaseType_t ) -1 )
N#define tmrCOMMAND_START_DONT_TRACE				( ( BaseType_t ) 0 )
N#define tmrCOMMAND_START					    ( ( BaseType_t ) 1 )
N#define tmrCOMMAND_RESET						( ( BaseType_t ) 2 )
N#define tmrCOMMAND_STOP							( ( BaseType_t ) 3 )
N#define tmrCOMMAND_CHANGE_PERIOD				( ( BaseType_t ) 4 )
N#define tmrCOMMAND_DELETE						( ( BaseType_t ) 5 )
N
N#define tmrFIRST_FROM_ISR_COMMAND				( ( BaseType_t ) 6 )
N#define tmrCOMMAND_START_FROM_ISR				( ( BaseType_t ) 6 )
N#define tmrCOMMAND_RESET_FROM_ISR				( ( BaseType_t ) 7 )
N#define tmrCOMMAND_STOP_FROM_ISR				( ( BaseType_t ) 8 )
N#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR		( ( BaseType_t ) 9 )
N
N
N/**
N * Type by which software timers are referenced.  For example, a call to
N * xTimerCreate() returns an TimerHandle_t variable that can then be used to
N * reference the subject timer in calls to other software timer API functions
N * (for example, xTimerStart(), xTimerReset(), etc.).
N */
Ntypedef void * TimerHandle_t;
N
N/*
N * Defines the prototype to which timer callback functions must conform.
N */
Ntypedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );
N
N/*
N * Defines the prototype to which functions used with the
N * xTimerPendFunctionCallFromISR() function must conform.
N */
Ntypedef void (*PendedFunction_t)( void *, uint32_t );
N
N/**
N * TimerHandle_t xTimerCreate( 	const char * const pcTimerName,
N * 								TickType_t xTimerPeriodInTicks,
N * 								UBaseType_t uxAutoReload,
N * 								void * pvTimerID,
N * 								TimerCallbackFunction_t pxCallbackFunction );
N *
N * Creates a new software timer instance, and returns a handle by which the
N * created software timer can be referenced.
N *
N * Internally, within the FreeRTOS implementation, software timers use a block
N * of memory, in which the timer data structure is stored.  If a software timer
N * is created using xTimerCreate() then the required memory is automatically
N * dynamically allocated inside the xTimerCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a software timer is created using
N * xTimerCreateStatic() then the application writer must provide the memory that
N * will get used by the software timer.  xTimerCreateStatic() therefore allows a
N * software timer to be created without using any dynamic memory allocation.
N *
N * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
N * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
N * xTimerChangePeriodFromISR() API functions can all be used to transition a
N * timer into the active state.
N *
N * @param pcTimerName A text name that is assigned to the timer.  This is done
N * purely to assist debugging.  The kernel itself only ever references a timer
N * by its handle, and never by its name.
N *
N * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
N * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
N * has been specified in milliseconds.  For example, if the timer must expire
N * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
N * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
N * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
N * equal to 1000.
N *
N * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
N * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
N * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
N * enter the dormant state after it expires.
N *
N * @param pvTimerID An identifier that is assigned to the timer being created.
N * Typically this would be used in the timer callback function to identify which
N * timer expired when the same callback function is assigned to more than one
N * timer.
N *
N * @param pxCallbackFunction The function to call when the timer expires.
N * Callback functions must have the prototype defined by TimerCallbackFunction_t,
N * which is	"void vCallbackFunction( TimerHandle_t xTimer );".
N *
N * @return If the timer is successfully created then a handle to the newly
N * created timer is returned.  If the timer cannot be created (because either
N * there is insufficient FreeRTOS heap remaining to allocate the timer
N * structures, or the timer period was set to 0) then NULL is returned.
N *
N * Example usage:
N * @verbatim
N * #define NUM_TIMERS 5
N *
N * // An array to hold handles to the created timers.
N * TimerHandle_t xTimers[ NUM_TIMERS ];
N *
N * // An array to hold a count of the number of times each timer expires.
N * int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
N *
N * // Define a callback function that will be used by multiple timer instances.
N * // The callback function does nothing but count the number of times the
N * // associated timer expires, and stop the timer once the timer has expired
N * // 10 times.
N * void vTimerCallback( TimerHandle_t pxTimer )
N * {
N * int32_t lArrayIndex;
N * const int32_t xMaxExpiryCountBeforeStopping = 10;
N *
N * 	   // Optionally do something if the pxTimer parameter is NULL.
N * 	   configASSERT( pxTimer );
N *
N *     // Which timer expired?
N *     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
N *
N *     // Increment the number of times that pxTimer has expired.
N *     lExpireCounters[ lArrayIndex ] += 1;
N *
N *     // If the timer has expired 10 times then stop it from running.
N *     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
N *     {
N *         // Do not use a block time if calling a timer API function from a
N *         // timer callback function, as doing so could cause a deadlock!
N *         xTimerStop( pxTimer, 0 );
N *     }
N * }
N *
N * void main( void )
N * {
N * int32_t x;
N *
N *     // Create then start some timers.  Starting the timers before the scheduler
N *     // has been started means the timers will start running immediately that
N *     // the scheduler starts.
N *     for( x = 0; x < NUM_TIMERS; x++ )
N *     {
N *         xTimers[ x ] = xTimerCreate(    "Timer",       // Just a text name, not used by the kernel.
N *                                         ( 100 * x ),   // The timer period in ticks.
N *                                         pdTRUE,        // The timers will auto-reload themselves when they expire.
N *                                         ( void * ) x,  // Assign each timer a unique id equal to its array index.
N *                                         vTimerCallback // Each timer calls the same callback when it expires.
N *                                     );
N *
N *         if( xTimers[ x ] == NULL )
N *         {
N *             // The timer was not created.
N *         }
N *         else
N *         {
N *             // Start the timer.  No block time is specified, and even if one was
N *             // it would be ignored because the scheduler has not yet been
N *             // started.
N *             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
N *             {
N *                 // The timer could not be set into the Active state.
N *             }
N *         }
N *     }
N *
N *     // ...
N *     // Create tasks here.
N *     // ...
N *
N *     // Starting the scheduler will start the timers running as they have already
N *     // been set into the active state.
N *     vTaskStartScheduler();
N *
N *     // Should not reach here.
N *     for( ;; );
N * }
N * @endverbatim
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
N								const TickType_t xTimerPeriodInTicks,
N								const UBaseType_t uxAutoReload,
N								void * const pvTimerID,
N								TimerCallbackFunction_t pxCallbackFunction ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X								TimerCallbackFunction_t pxCallbackFunction ) ;  
N#endif
N
N/**
N * TimerHandle_t xTimerCreateStatic(const char * const pcTimerName,
N * 									TickType_t xTimerPeriodInTicks,
N * 									UBaseType_t uxAutoReload,
N * 									void * pvTimerID,
N * 									TimerCallbackFunction_t pxCallbackFunction,
N *									StaticTimer_t *pxTimerBuffer );
N *
N * Creates a new software timer instance, and returns a handle by which the
N * created software timer can be referenced.
N *
N * Internally, within the FreeRTOS implementation, software timers use a block
N * of memory, in which the timer data structure is stored.  If a software timer
N * is created using xTimerCreate() then the required memory is automatically
N * dynamically allocated inside the xTimerCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a software timer is created using
N * xTimerCreateStatic() then the application writer must provide the memory that
N * will get used by the software timer.  xTimerCreateStatic() therefore allows a
N * software timer to be created without using any dynamic memory allocation.
N *
N * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
N * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
N * xTimerChangePeriodFromISR() API functions can all be used to transition a
N * timer into the active state.
N *
N * @param pcTimerName A text name that is assigned to the timer.  This is done
N * purely to assist debugging.  The kernel itself only ever references a timer
N * by its handle, and never by its name.
N *
N * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
N * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
N * has been specified in milliseconds.  For example, if the timer must expire
N * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
N * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
N * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
N * equal to 1000.
N *
N * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
N * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
N * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
N * enter the dormant state after it expires.
N *
N * @param pvTimerID An identifier that is assigned to the timer being created.
N * Typically this would be used in the timer callback function to identify which
N * timer expired when the same callback function is assigned to more than one
N * timer.
N *
N * @param pxCallbackFunction The function to call when the timer expires.
N * Callback functions must have the prototype defined by TimerCallbackFunction_t,
N * which is "void vCallbackFunction( TimerHandle_t xTimer );".
N *
N * @param pxTimerBuffer Must point to a variable of type StaticTimer_t, which
N * will be then be used to hold the software timer's data structures, removing
N * the need for the memory to be allocated dynamically.
N *
N * @return If the timer is created then a handle to the created timer is
N * returned.  If pxTimerBuffer was NULL then NULL is returned.
N *
N * Example usage:
N * @verbatim
N *
N * // The buffer used to hold the software timer's data structure.
N * static StaticTimer_t xTimerBuffer;
N *
N * // A variable that will be incremented by the software timer's callback
N * // function.
N * UBaseType_t uxVariableToIncrement = 0;
N *
N * // A software timer callback function that increments a variable passed to
N * // it when the software timer was created.  After the 5th increment the
N * // callback function stops the software timer.
N * static void prvTimerCallback( TimerHandle_t xExpiredTimer )
N * {
N * UBaseType_t *puxVariableToIncrement;
N * BaseType_t xReturned;
N *
N *     // Obtain the address of the variable to increment from the timer ID.
N *     puxVariableToIncrement = ( UBaseType_t * ) pvTimerGetTimerID( xExpiredTimer );
N *
N *     // Increment the variable to show the timer callback has executed.
N *     ( *puxVariableToIncrement )++;
N *
N *     // If this callback has executed the required number of times, stop the
N *     // timer.
N *     if( *puxVariableToIncrement == 5 )
N *     {
N *         // This is called from a timer callback so must not block.
N *         xTimerStop( xExpiredTimer, staticDONT_BLOCK );
N *     }
N * }
N *
N *
N * void main( void )
N * {
N *     // Create the software time.  xTimerCreateStatic() has an extra parameter
N *     // than the normal xTimerCreate() API function.  The parameter is a pointer
N *     // to the StaticTimer_t structure that will hold the software timer
N *     // structure.  If the parameter is passed as NULL then the structure will be
N *     // allocated dynamically, just as if xTimerCreate() had been called.
N *     xTimer = xTimerCreateStatic( "T1",             // Text name for the task.  Helps debugging only.  Not used by FreeRTOS.
N *                                  xTimerPeriod,     // The period of the timer in ticks.
N *                                  pdTRUE,           // This is an auto-reload timer.
N *                                  ( void * ) &uxVariableToIncrement,    // A variable incremented by the software timer's callback function
N *                                  prvTimerCallback, // The function to execute when the timer expires.
N *                                  &xTimerBuffer );  // The buffer that will hold the software timer structure.
N *
N *     // The scheduler has not started yet so a block time is not used.
N *     xReturned = xTimerStart( xTimer, 0 );
N *
N *     // ...
N *     // Create tasks here.
N *     // ...
N *
N *     // Starting the scheduler will start the timers running as they have already
N *     // been set into the active state.
N *     vTaskStartScheduler();
N *
N *     // Should not reach here.
N *     for( ;; );
N * }
N * @endverbatim
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,
S										const TickType_t xTimerPeriodInTicks,
S										const UBaseType_t uxAutoReload,
S										void * const pvTimerID,
S										TimerCallbackFunction_t pxCallbackFunction,
S										StaticTimer_t *pxTimerBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * void *pvTimerGetTimerID( TimerHandle_t xTimer );
N *
N * Returns the ID assigned to the timer.
N *
N * IDs are assigned to timers using the pvTimerID parameter of the call to
N * xTimerCreated() that was used to create the timer, and by calling the
N * vTimerSetTimerID() API function.
N *
N * If the same callback function is assigned to multiple timers then the timer
N * ID can be used as time specific (timer local) storage.
N *
N * @param xTimer The timer being queried.
N *
N * @return The ID assigned to the timer being queried.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N */
Nvoid *pvTimerGetTimerID( const TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
Xvoid *pvTimerGetTimerID( const TimerHandle_t xTimer ) ;
N
N/**
N * void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );
N *
N * Sets the ID assigned to the timer.
N *
N * IDs are assigned to timers using the pvTimerID parameter of the call to
N * xTimerCreated() that was used to create the timer.
N *
N * If the same callback function is assigned to multiple timers then the timer
N * ID can be used as time specific (timer local) storage.
N *
N * @param xTimer The timer being updated.
N *
N * @param pvNewID The ID to assign to the timer.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N */
Nvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) PRIVILEGED_FUNCTION;
Xvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) ;
N
N/**
N * BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );
N *
N * Queries a timer to see if it is active or dormant.
N *
N * A timer will be dormant if:
N *     1) It has been created but not started, or
N *     2) It is an expired one-shot timer that has not been restarted.
N *
N * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
N * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
N * xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the
N * active state.
N *
N * @param xTimer The timer being queried.
N *
N * @return pdFALSE will be returned if the timer is dormant.  A value other than
N * pdFALSE will be returned if the timer is active.
N *
N * Example usage:
N * @verbatim
N * // This function assumes xTimer has already been created.
N * void vAFunction( TimerHandle_t xTimer )
N * {
N *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
N *     {
N *         // xTimer is active, do something.
N *     }
N *     else
N *     {
N *         // xTimer is not active, do something else.
N *     }
N * }
N * @endverbatim
N */
NBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) ;
N
N/**
N * TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );
N *
N * Simply returns the handle of the timer service/daemon task.  It it not valid
N * to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) ;
N
N/**
N * BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerStart() starts a timer that was previously created using the
N * xTimerCreate() API function.  If the timer had already been started and was
N * already in the active state, then xTimerStart() has equivalent functionality
N * to the xTimerReset() API function.
N *
N * Starting a timer ensures the timer is in the active state.  If the timer
N * is not stopped, deleted, or reset in the mean time, the callback function
N * associated with the timer will get called 'n' ticks after xTimerStart() was
N * called, where 'n' is the timers defined period.
N *
N * It is valid to call xTimerStart() before the scheduler has been started, but
N * when this is done the timer will not actually start until the scheduler is
N * started, and the timers expiry time will be relative to when the scheduler is
N * started, not relative to when xTimerStart() was called.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart()
N * to be available.
N *
N * @param xTimer The handle of the timer being started/restarted.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the start command to be successfully
N * sent to the timer command queue, should the queue already be full when
N * xTimerStart() was called.  xTicksToWait is ignored if xTimerStart() is called
N * before the scheduler is started.
N *
N * @return pdFAIL will be returned if the start command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system, although the
N * timers expiry time is relative to when xTimerStart() is actually called.  The
N * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N *
N */
N#define xTimerStart( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerStop() stops a timer that was previously started using either of the
N * The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(),
N * xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.
N *
N * Stopping a timer ensures the timer is not in the active state.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop()
N * to be available.
N *
N * @param xTimer The handle of the timer being stopped.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the stop command to be successfully
N * sent to the timer command queue, should the queue already be full when
N * xTimerStop() was called.  xTicksToWait is ignored if xTimerStop() is called
N * before the scheduler is started.
N *
N * @return pdFAIL will be returned if the stop command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system.  The timer
N * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N *
N */
N#define xTimerStop( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerChangePeriod( 	TimerHandle_t xTimer,
N *										TickType_t xNewPeriod,
N *										TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerChangePeriod() changes the period of a timer that was previously
N * created using the xTimerCreate() API function.
N *
N * xTimerChangePeriod() can be called to change the period of an active or
N * dormant state timer.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for
N * xTimerChangePeriod() to be available.
N *
N * @param xTimer The handle of the timer that is having its period changed.
N *
N * @param xNewPeriod The new period for xTimer. Timer periods are specified in
N * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
N * that has been specified in milliseconds.  For example, if the timer must
N * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
N * if the timer must expire after 500ms, then xNewPeriod can be set to
N * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
N * or equal to 1000.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the change period command to be
N * successfully sent to the timer command queue, should the queue already be
N * full when xTimerChangePeriod() was called.  xTicksToWait is ignored if
N * xTimerChangePeriod() is called before the scheduler is started.
N *
N * @return pdFAIL will be returned if the change period command could not be
N * sent to the timer command queue even after xTicksToWait ticks had passed.
N * pdPASS will be returned if the command was successfully sent to the timer
N * command queue.  When the command is actually processed will depend on the
N * priority of the timer service/daemon task relative to other tasks in the
N * system.  The timer service/daemon task priority is set by the
N * configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This function assumes xTimer has already been created.  If the timer
N * // referenced by xTimer is already active when it is called, then the timer
N * // is deleted.  If the timer referenced by xTimer is not active when it is
N * // called, then the period of the timer is set to 500ms and the timer is
N * // started.
N * void vAFunction( TimerHandle_t xTimer )
N * {
N *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
N *     {
N *         // xTimer is already active - delete it.
N *         xTimerDelete( xTimer );
N *     }
N *     else
N *     {
N *         // xTimer is not active, change its period to 500ms.  This will also
N *         // cause the timer to start.  Block for a maximum of 100 ticks if the
N *         // change period command cannot immediately be sent to the timer
N *         // command queue.
N *         if( xTimerChangePeriod( xTimer, 500 / portTICK_PERIOD_MS, 100 ) == pdPASS )
N *         {
N *             // The command was successfully sent.
N *         }
N *         else
N *         {
N *             // The command could not be sent, even after waiting for 100 ticks
N *             // to pass.  Take appropriate action here.
N *         }
N *     }
N * }
N * @endverbatim
N */
N #define xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerDelete() deletes a timer that was previously created using the
N * xTimerCreate() API function.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for
N * xTimerDelete() to be available.
N *
N * @param xTimer The handle of the timer being deleted.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the delete command to be
N * successfully sent to the timer command queue, should the queue already be
N * full when xTimerDelete() was called.  xTicksToWait is ignored if xTimerDelete()
N * is called before the scheduler is started.
N *
N * @return pdFAIL will be returned if the delete command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system.  The timer
N * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N *
N * See the xTimerChangePeriod() API function example usage scenario.
N */
N#define xTimerDelete( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerReset() re-starts a timer that was previously created using the
N * xTimerCreate() API function.  If the timer had already been started and was
N * already in the active state, then xTimerReset() will cause the timer to
N * re-evaluate its expiry time so that it is relative to when xTimerReset() was
N * called.  If the timer was in the dormant state then xTimerReset() has
N * equivalent functionality to the xTimerStart() API function.
N *
N * Resetting a timer ensures the timer is in the active state.  If the timer
N * is not stopped, deleted, or reset in the mean time, the callback function
N * associated with the timer will get called 'n' ticks after xTimerReset() was
N * called, where 'n' is the timers defined period.
N *
N * It is valid to call xTimerReset() before the scheduler has been started, but
N * when this is done the timer will not actually start until the scheduler is
N * started, and the timers expiry time will be relative to when the scheduler is
N * started, not relative to when xTimerReset() was called.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset()
N * to be available.
N *
N * @param xTimer The handle of the timer being reset/started/restarted.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the reset command to be successfully
N * sent to the timer command queue, should the queue already be full when
N * xTimerReset() was called.  xTicksToWait is ignored if xTimerReset() is called
N * before the scheduler is started.
N *
N * @return pdFAIL will be returned if the reset command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system, although the
N * timers expiry time is relative to when xTimerStart() is actually called.  The
N * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N * @verbatim
N * // When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass
N * // without a key being pressed, then the LCD back-light is switched off.  In
N * // this case, the timer is a one-shot timer.
N *
N * TimerHandle_t xBacklightTimer = NULL;
N *
N * // The callback function assigned to the one-shot timer.  In this case the
N * // parameter is not used.
N * void vBacklightTimerCallback( TimerHandle_t pxTimer )
N * {
N *     // The timer expired, therefore 5 seconds must have passed since a key
N *     // was pressed.  Switch off the LCD back-light.
N *     vSetBacklightState( BACKLIGHT_OFF );
N * }
N *
N * // The key press event handler.
N * void vKeyPressEventHandler( char cKey )
N * {
N *     // Ensure the LCD back-light is on, then reset the timer that is
N *     // responsible for turning the back-light off after 5 seconds of
N *     // key inactivity.  Wait 10 ticks for the command to be successfully sent
N *     // if it cannot be sent immediately.
N *     vSetBacklightState( BACKLIGHT_ON );
N *     if( xTimerReset( xBacklightTimer, 100 ) != pdPASS )
N *     {
N *         // The reset command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // Perform the rest of the key processing here.
N * }
N *
N * void main( void )
N * {
N * int32_t x;
N *
N *     // Create then start the one-shot timer that is responsible for turning
N *     // the back-light off if no keys are pressed within a 5 second period.
N *     xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.
N *                                     ( 5000 / portTICK_PERIOD_MS), // The timer period in ticks.
N *                                     pdFALSE,                    // The timer is a one-shot timer.
N *                                     0,                          // The id is not used by the callback so can take any value.
N *                                     vBacklightTimerCallback     // The callback function that switches the LCD back-light off.
N *                                   );
N *
N *     if( xBacklightTimer == NULL )
N *     {
N *         // The timer was not created.
N *     }
N *     else
N *     {
N *         // Start the timer.  No block time is specified, and even if one was
N *         // it would be ignored because the scheduler has not yet been
N *         // started.
N *         if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )
N *         {
N *             // The timer could not be set into the Active state.
N *         }
N *     }
N *
N *     // ...
N *     // Create tasks here.
N *     // ...
N *
N *     // Starting the scheduler will start the timer running as it has already
N *     // been set into the active state.
N *     vTaskStartScheduler();
N *
N *     // Should not reach here.
N *     for( ;; );
N * }
N * @endverbatim
N */
N#define xTimerReset( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerStartFromISR( 	TimerHandle_t xTimer,
N *									BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerStart() that can be called from an interrupt service
N * routine.
N *
N * @param xTimer The handle of the timer being started/restarted.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerStartFromISR() writes a message to the timer
N * command queue, so has the potential to transition the timer service/daemon
N * task out of the Blocked state.  If calling xTimerStartFromISR() causes the
N * timer service/daemon task to leave the Blocked state, and the timer service/
N * daemon task has a priority equal to or greater than the currently executing
N * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
N * get set to pdTRUE internally within the xTimerStartFromISR() function.  If
N * xTimerStartFromISR() sets this value to pdTRUE then a context switch should
N * be performed before the interrupt exits.
N *
N * @return pdFAIL will be returned if the start command could not be sent to
N * the timer command queue.  pdPASS will be returned if the command was
N * successfully sent to the timer command queue.  When the command is actually
N * processed will depend on the priority of the timer service/daemon task
N * relative to other tasks in the system, although the timers expiry time is
N * relative to when xTimerStartFromISR() is actually called.  The timer
N * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xBacklightTimer has already been created.  When a
N * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
N * // without a key being pressed, then the LCD back-light is switched off.  In
N * // this case, the timer is a one-shot timer, and unlike the example given for
N * // the xTimerReset() function, the key press event handler is an interrupt
N * // service routine.
N *
N * // The callback function assigned to the one-shot timer.  In this case the
N * // parameter is not used.
N * void vBacklightTimerCallback( TimerHandle_t pxTimer )
N * {
N *     // The timer expired, therefore 5 seconds must have passed since a key
N *     // was pressed.  Switch off the LCD back-light.
N *     vSetBacklightState( BACKLIGHT_OFF );
N * }
N *
N * // The key press interrupt service routine.
N * void vKeyPressEventInterruptHandler( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // Ensure the LCD back-light is on, then restart the timer that is
N *     // responsible for turning the back-light off after 5 seconds of
N *     // key inactivity.  This is an interrupt service routine so can only
N *     // call FreeRTOS API functions that end in "FromISR".
N *     vSetBacklightState( BACKLIGHT_ON );
N *
N *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
N *     // as both cause the timer to re-calculate its expiry time.
N *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
N *     // declared (in this function).
N *     if( xTimerStartFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The start command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // Perform the rest of the key processing here.
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerStartFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
N
N/**
N * BaseType_t xTimerStopFromISR( 	TimerHandle_t xTimer,
N *									BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerStop() that can be called from an interrupt service
N * routine.
N *
N * @param xTimer The handle of the timer being stopped.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerStopFromISR() writes a message to the timer
N * command queue, so has the potential to transition the timer service/daemon
N * task out of the Blocked state.  If calling xTimerStopFromISR() causes the
N * timer service/daemon task to leave the Blocked state, and the timer service/
N * daemon task has a priority equal to or greater than the currently executing
N * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
N * get set to pdTRUE internally within the xTimerStopFromISR() function.  If
N * xTimerStopFromISR() sets this value to pdTRUE then a context switch should
N * be performed before the interrupt exits.
N *
N * @return pdFAIL will be returned if the stop command could not be sent to
N * the timer command queue.  pdPASS will be returned if the command was
N * successfully sent to the timer command queue.  When the command is actually
N * processed will depend on the priority of the timer service/daemon task
N * relative to other tasks in the system.  The timer service/daemon task
N * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xTimer has already been created and started.  When
N * // an interrupt occurs, the timer should be simply stopped.
N *
N * // The interrupt service routine that stops the timer.
N * void vAnExampleInterruptServiceRoutine( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // The interrupt has occurred - simply stop the timer.
N *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
N *     // (within this function).  As this is an interrupt service routine, only
N *     // FreeRTOS API functions that end in "FromISR" can be used.
N *     if( xTimerStopFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The stop command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerStopFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )
N
N/**
N * BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer,
N *										 TickType_t xNewPeriod,
N *										 BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerChangePeriod() that can be called from an interrupt
N * service routine.
N *
N * @param xTimer The handle of the timer that is having its period changed.
N *
N * @param xNewPeriod The new period for xTimer. Timer periods are specified in
N * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
N * that has been specified in milliseconds.  For example, if the timer must
N * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
N * if the timer must expire after 500ms, then xNewPeriod can be set to
N * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
N * or equal to 1000.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerChangePeriodFromISR() writes a message to the
N * timer command queue, so has the potential to transition the timer service/
N * daemon task out of the Blocked state.  If calling xTimerChangePeriodFromISR()
N * causes the timer service/daemon task to leave the Blocked state, and the
N * timer service/daemon task has a priority equal to or greater than the
N * currently executing task (the task that was interrupted), then
N * *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the
N * xTimerChangePeriodFromISR() function.  If xTimerChangePeriodFromISR() sets
N * this value to pdTRUE then a context switch should be performed before the
N * interrupt exits.
N *
N * @return pdFAIL will be returned if the command to change the timers period
N * could not be sent to the timer command queue.  pdPASS will be returned if the
N * command was successfully sent to the timer command queue.  When the command
N * is actually processed will depend on the priority of the timer service/daemon
N * task relative to other tasks in the system.  The timer service/daemon task
N * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xTimer has already been created and started.  When
N * // an interrupt occurs, the period of xTimer should be changed to 500ms.
N *
N * // The interrupt service routine that changes the period of xTimer.
N * void vAnExampleInterruptServiceRoutine( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // The interrupt has occurred - change the period of xTimer to 500ms.
N *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
N *     // (within this function).  As this is an interrupt service routine, only
N *     // FreeRTOS API functions that end in "FromISR" can be used.
N *     if( xTimerChangePeriodFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The command to change the timers period was not executed
N *         // successfully.  Take appropriate action here.
N *     }
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerChangePeriodFromISR( xTimer, xNewPeriod, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )
N
N/**
N * BaseType_t xTimerResetFromISR( 	TimerHandle_t xTimer,
N *									BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerReset() that can be called from an interrupt service
N * routine.
N *
N * @param xTimer The handle of the timer that is to be started, reset, or
N * restarted.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerResetFromISR() writes a message to the timer
N * command queue, so has the potential to transition the timer service/daemon
N * task out of the Blocked state.  If calling xTimerResetFromISR() causes the
N * timer service/daemon task to leave the Blocked state, and the timer service/
N * daemon task has a priority equal to or greater than the currently executing
N * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
N * get set to pdTRUE internally within the xTimerResetFromISR() function.  If
N * xTimerResetFromISR() sets this value to pdTRUE then a context switch should
N * be performed before the interrupt exits.
N *
N * @return pdFAIL will be returned if the reset command could not be sent to
N * the timer command queue.  pdPASS will be returned if the command was
N * successfully sent to the timer command queue.  When the command is actually
N * processed will depend on the priority of the timer service/daemon task
N * relative to other tasks in the system, although the timers expiry time is
N * relative to when xTimerResetFromISR() is actually called.  The timer service/daemon
N * task priority is set by the configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xBacklightTimer has already been created.  When a
N * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
N * // without a key being pressed, then the LCD back-light is switched off.  In
N * // this case, the timer is a one-shot timer, and unlike the example given for
N * // the xTimerReset() function, the key press event handler is an interrupt
N * // service routine.
N *
N * // The callback function assigned to the one-shot timer.  In this case the
N * // parameter is not used.
N * void vBacklightTimerCallback( TimerHandle_t pxTimer )
N * {
N *     // The timer expired, therefore 5 seconds must have passed since a key
N *     // was pressed.  Switch off the LCD back-light.
N *     vSetBacklightState( BACKLIGHT_OFF );
N * }
N *
N * // The key press interrupt service routine.
N * void vKeyPressEventInterruptHandler( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // Ensure the LCD back-light is on, then reset the timer that is
N *     // responsible for turning the back-light off after 5 seconds of
N *     // key inactivity.  This is an interrupt service routine so can only
N *     // call FreeRTOS API functions that end in "FromISR".
N *     vSetBacklightState( BACKLIGHT_ON );
N *
N *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
N *     // as both cause the timer to re-calculate its expiry time.
N *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
N *     // declared (in this function).
N *     if( xTimerResetFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The reset command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // Perform the rest of the key processing here.
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerResetFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
N
N
N/**
N * BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
N *                                          void *pvParameter1,
N *                                          uint32_t ulParameter2,
N *                                          BaseType_t *pxHigherPriorityTaskWoken );
N *
N *
N * Used from application interrupt service routines to defer the execution of a
N * function to the RTOS daemon task (the timer service task, hence this function
N * is implemented in timers.c and is prefixed with 'Timer').
N *
N * Ideally an interrupt service routine (ISR) is kept as short as possible, but
N * sometimes an ISR either has a lot of processing to do, or needs to perform
N * processing that is not deterministic.  In these cases
N * xTimerPendFunctionCallFromISR() can be used to defer processing of a function
N * to the RTOS daemon task.
N *
N * A mechanism is provided that allows the interrupt to return directly to the
N * task that will subsequently execute the pended callback function.  This
N * allows the callback function to execute contiguously in time with the
N * interrupt - just as if the callback had executed in the interrupt itself.
N *
N * @param xFunctionToPend The function to execute from the timer service/
N * daemon task.  The function must conform to the PendedFunction_t
N * prototype.
N *
N * @param pvParameter1 The value of the callback function's first parameter.
N * The parameter has a void * type to allow it to be used to pass any type.
N * For example, unsigned longs can be cast to a void *, or the void * can be
N * used to point to a structure.
N *
N * @param ulParameter2 The value of the callback function's second parameter.
N *
N * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
N * will result in a message being sent to the timer daemon task.  If the
N * priority of the timer daemon task (which is set using
N * configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of
N * the currently running task (the task the interrupt interrupted) then
N * *pxHigherPriorityTaskWoken will be set to pdTRUE within
N * xTimerPendFunctionCallFromISR(), indicating that a context switch should be
N * requested before the interrupt exits.  For that reason
N * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
N * example code below.
N *
N * @return pdPASS is returned if the message was successfully sent to the
N * timer daemon task, otherwise pdFALSE is returned.
N *
N * Example usage:
N * @verbatim
N *
N *	// The callback function that will execute in the context of the daemon task.
N *  // Note callback functions must all use this same prototype.
N *  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
N *	{
N *		BaseType_t xInterfaceToService;
N *
N *		// The interface that requires servicing is passed in the second
N *      // parameter.  The first parameter is not used in this case.
N *		xInterfaceToService = ( BaseType_t ) ulParameter2;
N *
N *		// ...Perform the processing here...
N *	}
N *
N *	// An ISR that receives data packets from multiple interfaces
N *  void vAnISR( void )
N *	{
N *		BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
N *
N *		// Query the hardware to determine which interface needs processing.
N *		xInterfaceToService = prvCheckInterfaces();
N *
N *      // The actual processing is to be deferred to a task.  Request the
N *      // vProcessInterface() callback function is executed, passing in the
N *		// number of the interface that needs processing.  The interface to
N *		// service is passed in the second parameter.  The first parameter is
N *		// not used in this case.
N *		xHigherPriorityTaskWoken = pdFALSE;
N *		xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );
N *
N *		// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
N *		// switch should be requested.  The macro used is port specific and will
N *		// be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
N *		// the documentation page for the port being used.
N *		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
N *
N *	}
N * @endverbatim
N */
NBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N /**
N  * BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
N  *                                    void *pvParameter1,
N  *                                    uint32_t ulParameter2,
N  *                                    TickType_t xTicksToWait );
N  *
N  *
N  * Used to defer the execution of a function to the RTOS daemon task (the timer
N  * service task, hence this function is implemented in timers.c and is prefixed
N  * with 'Timer').
N  *
N  * @param xFunctionToPend The function to execute from the timer service/
N  * daemon task.  The function must conform to the PendedFunction_t
N  * prototype.
N  *
N  * @param pvParameter1 The value of the callback function's first parameter.
N  * The parameter has a void * type to allow it to be used to pass any type.
N  * For example, unsigned longs can be cast to a void *, or the void * can be
N  * used to point to a structure.
N  *
N  * @param ulParameter2 The value of the callback function's second parameter.
N  *
N  * @param xTicksToWait Calling this function will result in a message being
N  * sent to the timer daemon task on a queue.  xTicksToWait is the amount of
N  * time the calling task should remain in the Blocked state (so not using any
N  * processing time) for space to become available on the timer queue if the
N  * queue is found to be full.
N  *
N  * @return pdPASS is returned if the message was successfully sent to the
N  * timer daemon task, otherwise pdFALSE is returned.
N  *
N  */
NBaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) ;
N
N/**
N * const char * const pcTimerGetName( TimerHandle_t xTimer );
N *
N * Returns the name that was assigned to a timer when the timer was created.
N *
N * @param xTimer The handle of the timer being queried.
N *
N * @return The name assigned to the timer specified by the xTimer parameter.
N */
Nconst char * pcTimerGetName( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xconst char * pcTimerGetName( TimerHandle_t xTimer ) ;  
N
N/**
N * TickType_t xTimerGetPeriod( TimerHandle_t xTimer );
N *
N * Returns the period of a timer.
N *
N * @param xTimer The handle of the timer being queried.
N *
N * @return The period of the timer in ticks.
N */
NTickType_t xTimerGetPeriod( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
XTickType_t xTimerGetPeriod( TimerHandle_t xTimer ) ;
N
N/**
N* TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );
N*
N* Returns the time in ticks at which the timer will expire.  If this is less
N* than the current tick count then the expiry time has overflowed from the
N* current time.
N*
N* @param xTimer The handle of the timer being queried.
N*
N* @return If the timer is running then the time in ticks at which the timer
N* will next expire is returned.  If the timer is not running then the return
N* value is undefined.
N*/
NTickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
XTickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) ;
N
N/*
N * Functions beyond this part are not part of the public API and are intended
N * for use by the kernel only.
N */
NBaseType_t xTimerCreateTimerTask( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerCreateTimerTask( void ) ;
NBaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) ;
N
N#ifdef __cplusplus
N}
N#endif
N#endif /* TIMERS_H */
N
N
N
L 14 ".\Source\Main\inc\rtos_headers.h" 2
N
N//-----  FreeRTOS -----------------------------------------------------------------------------------------
N//void coding_switch( void * );                  //  
N//void discrete_out( void * );                   //  
N//void base_to_pc( void * );                     //   ;   
N//void base_to_sens( void * );                   //   ;   
N//void sens_to_master( void * );                 //    (  );   
N//void mems( void * );                           //  -
N//void dev_ctrl( void * );                       // 
N//void logger_ctrl( void * );                    //   (        Flash)
N//void vLedCtrl( void * );
N//void vPushButton( void * );
N
Nvoid lev_gauge_to_pc( void * );                //   
N//---------------------------------------------------------------------------------------------------------------
N
N//-----  FreeRTOS ---------------------------------------------------------------------------------------
Nextern SemaphoreHandle_t I2C_RxSem;            //   I2C
Nextern SemaphoreHandle_t I2C_TxSem;            //   I2C
Nextern SemaphoreHandle_t CodeSwTmr_TrigSem;    // CodeSwTmr 
Nextern SemaphoreHandle_t DoUncalibTmr_TrigSem; // DoUncalibTmr                                     
Nextern SemaphoreHandle_t RawDataMems_RdySem;   //   ( ).    INT
N//extern SemaphoreHandle_t FlashData_WrSem;      //    Flash 
Nextern SemaphoreHandle_t SlaveRtoTrigSem;      //  RTO  Slave-  USART
Nextern SemaphoreHandle_t SlaveCommErrSem;      // /   USART  Slave-
Nextern SemaphoreHandle_t MasterRtoTrigSem;     //  RTO  Master-  USART
Nextern SemaphoreHandle_t MasterCommErrSem;     // /   USART  Master-
Nextern SemaphoreHandle_t PdSem;                //    
N//extern SemaphoreHandle_t FlashTmr_TrigSem;     //    Flash
N//extern SemaphoreHandle_t MemsWaitStopSem;      //    mems-
N//extern SemaphoreHandle_t TxSPI1_RdySem;        //   SPI1
N//extern SemaphoreHandle_t RxSPI1_RdySem;        //   SPI1
Nextern SemaphoreHandle_t WrFlash;              //     Flash
Nextern SemaphoreHandle_t BtnTimer_TrigSem;     //
Nextern SemaphoreHandle_t LedTimer_TrigSem;     //
Nextern SemaphoreHandle_t DmaAdcMeas_CompSem;   //DMA       
N
N//   
N//extern SemaphoreHandle_t MemsDevRdySem;        //  
N//extern SemaphoreHandle_t MemsDevDoneSem;       // 
N//extern SemaphoreHandle_t DevMemsStartSem;      //     
N//extern SemaphoreHandle_t DevSensStartSem;      //     
N//extern SemaphoreHandle_t DevSensResSem;        //      
N//extern SemaphoreHandle_t SensDevOkSem;         //     
N//extern SemaphoreHandle_t SensDevResSem;        //      
N//extern SemaphoreHandle_t SensWrAxisRotateSem;  //  AxisRotate  
N//extern SemaphoreHandle_t SensAxisRotateOkSem;  // AxisRotate    
N
N//  
N//extern SemaphoreHandle_t AccCalib_X_UP_Sem;
N//extern SemaphoreHandle_t AccCalib_X_DOWN_Sem;
N//extern SemaphoreHandle_t AccCalib_Y_UP_Sem;
N//extern SemaphoreHandle_t AccCalib_Y_DOWN_Sem;
N//extern SemaphoreHandle_t AccCalib_Z_UP_Sem;
N//extern SemaphoreHandle_t AccCalib_Z_DOWN_Sem;
N     
N//   
N//extern SemaphoreHandle_t User_Zeroing_Out_Sem;
N//extern SemaphoreHandle_t Factory_Zeroing_Out_Sem;
N
Nextern SemaphoreHandle_t Tmr_TrigSem;
Nextern SemaphoreHandle_t DiffExti_TrigSem;
N//---------------------------------------------------------------------------------------------------------------
N
N//-----  FreeRTOS ---------------------------------------------------------------------------------------
Nextern SemaphoreHandle_t MainMut;              // ,    
Nextern SemaphoreHandle_t SENSMut;              //   
N//---------------------------------------------------------------------------------------------------------------
N
N//-----  FreeRTOS ----------------------------------------------------------------------------------------
Nextern TimerHandle_t CodeSwTmr;                //   
Nvoid code_sw_tmr( TimerHandle_t );             //   
N                                               
Nextern TimerHandle_t DoUncalibTmr;             //      
Nvoid do_uncalib_tmr( TimerHandle_t );          //       
N                                               
Nextern TimerHandle_t PdTmr;                    // 
Nvoid pd_tmr( TimerHandle_t );                  // 
N
N
Nextern TimerHandle_t BtnTimer;
Nvoid vTimerCallback(TimerHandle_t xTimer);
N
N//extern TimerHandle_t MemsTmr;                  //   mems-
N//void mems_tmr( TimerHandle_t );                //    mems-
N//---------------------------------------------------------------------------------------------------------------
N
N#endif //__RTOS_HEADERS_H
L 7 "Source\Tasks\src\settings.cpp" 2
N#include "Flash_driver.h"
N#include "SensProc.h"
L 1 ".\Source\Line\inc\SensProc.h" 1
N//   : $HeadURL: http://s005.sensor:18080/svn/Sens/trunk/SensProc/SensProc.h $
N// $Revision: 8 $  $Date: 2015-12-25 16:23:16 +0300 (, 25  2015) $  $Author: bryakin $
N//  0.6
N//     S_PROGNUM -   32-  (     )
N
N#ifndef SENSPROC_H
N#define SENSPROC_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#include <stdint.h>
N
N//   
N#define USERMODE  2
N#define ADMINMODE 1
N#define SUPERMODE 0
N
N//   " "
N//  
N#define READ_ALL      0xC0
N#define READ_ADM      0x80
N#define READ_SUP      0x40
N#define WRITE_ALL     0x30
N#define WRITE_ADM     0x20
N#define WRITE_SUP     0x10
N#define WRITE_NON     0x00
N//  
N#define S_FLOAT       0x00
N#define S_BYTE        0x01  //   int8_t , 0x80 - 
N//#define S_LONG    0x02    //   int16_t  0x8000 - 
N//#define S_UBYTE   0x03    //   uint8_t  0x80 - 
N//#define S_UWORD   0x04    //   uint16_t 0x8000 - 
N#define S_EIZM    	 0x08    //  
N#define S_VARFLOATTBL 0x09  //    Float,     Float[],   
N#define S_FLOATTBL    0x0A  //    Float,     Float[]
N#define S_FRAMTABLE   0x0B  //   -  !
N#define S_PROGNUM     0x0C    //  .   uint32_t.      .
N#define S_BITS        0x0D    //    uint16_t,   - .   
N#define S_ADDR        0x0E    //   .   .     uint8_t
N#define S_TABLE       0x0F    // .   
N
N
N//  
Ntypedef struct {
N  uint8_t ID;     //  
N  uint8_t Type;   //      
N  __attribute__((packed)) void * Pointer;
N} SensOneParam;
N
N//  
Ntypedef struct {
N  void * Data;   //   
N  uint32_t Length;  //   (   S_TABLE  float  S_FLOATTBL)
N  uint32_t * VarLength; //     
N} SensTable;
N
N#define SAVETIMEOUT 5000 //   -      
N
N/////////////////////////////////////////////////////////
Nchar SensAnswerPkg(uint8_t * buf); //     
Nvoid SensPkgProc(void);            //   -    
N
N//    
Nuint8_t GetAccessMode(void);             //    
Nvoid ResetAccess(void);                  //       
N
N////////////////////////////////////////////////////////////////////////////////////
N//  
Nvoid FloatToS3B(__packed uint8_t*buf,float inf); //  Float -> 3 
Nfloat S3BToFloat(__packed uint8_t * buf);        //  3  -> float
Nfloat theerr(void);           //  0xFFFFFFFF
Nuint8_t iserr(const float f); //   3 ,  
Nuint8_t isok(float f);        //  1,       
N
Nconst SensOneParam * FindParam(uint8_t idp); //    
N
N/////////////////////////////////////////////////////////
N//         SensDev   
N
Nextern const SensOneParam Params[];
N
N//         
Nuint8_t ThePredef(uint8_t,uint8_t*);  //   
N
N//   ,   
N//  -    
N//       :
N//   0    (  )
N//   1     (  )
N//   8     (  )
N// 255    (     )
N//   -  buf[3]
Nuint8_t SetTCPnt(uint8_t * buf);
N
Nvoid SetSaveData(void);   // ,             
N
N//extern MySettings DSt;    //    
N
N//         
N//   "USER" -    (  )
N//    -     USER
N//   -     0,   
Nvoid SaveConst(uint8_t);                 //     
N//          
Nvoid LoadConst(void);
Nvoid LoadTCTab(void);
N//        
N// 0 -    
N//uint8_t GetReadOnly(void);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
L 9 "Source\Tasks\src\settings.cpp" 2
N
NTSettings Settings;
N
NTSettings::TSettings()
N:
N__THR(               {  15,                                      50 } ),
N__HYST(              {   5,                                      40 } ),
N__BIAS(              { -15,                                      15 } ),
N__AXIS_ROTATE(       { TAxisRotate::__0_DEG, TAxisRotate::__270_DEG } ),
N__ROLL_BIAS_ANGLE(   {  -7,                                       7 } ),
N__PITCH_BIAS_ANGLE(  {  -7,                                       7 } ),
N__LOW_DIF( __THR.Min - __HYST.Min ),
N__MB_ADDR(           {   1,                                     247 } ),
N__U_SPEED(           {   0,                                       9 } ),
N__U_PAR(             {   0,                                       3 } ),
N//__CALIB(             {   0,                                       5 } ) //       g
N__CALIB(             {   0,                                       1 } ), //   
N__ACCESS(            { 230,                                     232 } )  //  
N{
N
N}
N
NTSettings::~TSettings()
N{
N
N}
N
Nbool TSettings::chk_thr( int16_t Param ) const
N{
N  return chk_param( __THR, Param );
N}
N
Nbool TSettings::chk_hyst( int16_t Param ) const
N{
N  return chk_param( __HYST, Param );
N}
N
Nbool TSettings::chk_bias( int16_t Param ) const  
N{
N  return chk_param( __BIAS, Param );
N}
N
Nbool TSettings::chk_axis_rotate( int16_t Param ) const
N{
N  return chk_param( __AXIS_ROTATE, Param );
N}
N
Nbool TSettings::chk_roll_bias_angle( int16_t Param ) const
N{
N  return chk_param( __ROLL_BIAS_ANGLE, Param );
N}
N
Nbool TSettings::chk_pitch_bias_angle( int16_t Param ) const
N{
N  return chk_param( __PITCH_BIAS_ANGLE, Param );
N}
N
Nbool TSettings::chk_mb_addr( int16_t Param ) const   
N{
N  return chk_param( __MB_ADDR, Param );
N}
N
Nbool TSettings::chk_u_baud_rate( int16_t Param ) const  
N{
N  return chk_param( __U_SPEED, Param );
N}
N
Nbool TSettings::chk_u_par( int16_t Param ) const  
N{
N  return chk_param( __U_PAR, Param );
N}
N
Nvoid TSettings::chk_dev( MySettings &New )
N{
N//  New.DevSets.Thr = ( chk_param( __THR, New.DevSets.Thr ) )
N////                    ? Model.get_thr()                             //   
N////                    : roundf( New.DevSets.Thr );                  //  
N
N////  New.DevSets.Hyst = ( chk_param( __HYST, New.DevSets.Hyst ) )
N////                     ? Model.get_hyst()                           //   
N////                     : roundf( New.DevSets.Hyst );                //  
N
N  //   
N  if ( New.DevSets.Thr - New.DevSets.Hyst < __LOW_DIF )        //      ""  , ...
N  {                                                               
N    New.DevSets.Hyst = New.DevSets.Thr - __LOW_DIF;            //...        
N  }
N
N//  New.DevSets.Bias = ( chk_param( __BIAS, New.DevSets.Bias ) )
N//                     ? Model.get_bias()                           //   
N//                     : roundf( New.DevSets.Bias );                //  
N}
N
Nbool TSettings::chk_calib( int16_t Param ) const
N{
N  return ( chk_param( __CALIB, Param ) );
N}
N
Nbool TSettings::chk_access( int16_t Param ) const
N{
N  return ( chk_param( __ACCESS, Param ) );
N}
N
N//void TSettings::chk_if( 
N//                       uint8_t BaudRateNbr, 
N//                       uint8_t ParityAndStopsNbr
N//                      )
N//{
N//  constexpr uint8_t BAUD_RATE_DEF_VAL        = 5U;
N//  constexpr uint8_t PARITY_AND_STOPS_DEF_VAL = 3U;
N//    
N//  bool ReinitFlag = false; //   
N//  
N//  TBaudRate BaudRate[] =
N//  {
N//    TUsart::TBaudRate::_1200,   //0
N//    TUsart::TBaudRate::_2400,   //1
N//    TUsart::TBaudRate::_4800,   //2
N//    TUsart::TBaudRate::_9600,   //3
N//    TUsart::TBaudRate::_14400,  //4
N//    TUsart::TBaudRate::_19200,  //5 -   
N//    TUsart::TBaudRate::_38400,  //6
N//    TUsart::TBaudRate::_56000,  //7
N//    TUsart::TBaudRate::_57600,  //8
N//    TUsart::TBaudRate::_115200, //9
N//  };
N//  
N//  struct TParityAndStops
N//  {
N//    TUsart::TParity Parity;
N//    TUsart::TStops  Stops;
N//  };
N
N//  TParityAndStops ParityAndStops[] =
N//  {
N//    { TUsart::TParity::_NONE, TUsart::TStops::_STOPBITS_1 }, //0
N//    { TUsart::TParity::_NONE, TUsart::TStops::_STOPBITS_2 }, //1
N//    { TUsart::TParity::_ODD,  TUsart::TStops::_STOPBITS_1 }, //2
N//    { TUsart::TParity::_EVEN, TUsart::TStops::_STOPBITS_1 }, //3 -   
N//  };
N
N//  if ( chk_baud_rate_nbr( BaudRateNbr ) != true ) //  Flash  -  ,
N//  {
N//    Sets.BaudRate = BaudRate[BAUD_RATE_DEF_VAL];  //   
N//  }
N//  else
N//  {
N//    if ( Sets.BaudRate != BaudRate[BaudRateNbr] )
N//    {
N//      Sets.BaudRate = BaudRate[BaudRateNbr];
N//      
N//      ReinitFlag    = true;
N//    }
N//    else
N//    {
N//    
N//    }
N//  }
N
N//  if ( chk_parity_and_stops_nbr( ParityAndStopsNbr ) != true ) //  Flash  -  ,
N//  {
N//    Sets.Parity = ParityAndStops[ PARITY_AND_STOPS_DEF_VAL ].Parity; //   
N//    Sets.Stops  = ParityAndStops[ PARITY_AND_STOPS_DEF_VAL ].Stops;  //   
N//  }
N//  else
N//  {
N//    if (
N//        Sets.Parity != ParityAndStops[ParityAndStopsNbr].Parity
N//        ||
N//        Sets.Stops != ParityAndStops[ParityAndStopsNbr].Stops
N//       )
N//    {
N//      Sets.Parity = ParityAndStops[ParityAndStopsNbr].Parity;
N//      Sets.Stops  = ParityAndStops[ParityAndStopsNbr].Stops;
N//      
N//      ReinitFlag  = true;
N//    }
N//    else
N//    {
N//    
N//    }
N//  }
N//  
N//  if ( ReinitFlag )
N//  {
N//    // USART
N//    //  hw_init();
N//  }
N//}
