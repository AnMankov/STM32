; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\i2c_driver.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\i2c_driver.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\i2c_driver.crf Source\MCU_Drivers\src\I2C_driver.cpp]
                          THUMB

                          AREA ||i.I2C1_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_ER_IRQHandler PROC
;;;516    
;;;517    extern "C" void I2C1_ER_IRQHandler(void)
000000  4770              BX       lr
;;;518    {
;;;519    
;;;520    }
;;;521    
                          ENDP


                          AREA ||i.I2C1_EV_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C1_EV_IRQHandler PROC
;;;493    //******************************************************************************
;;;494    extern "C" void I2C1_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;495    {  
;;;496    //  I2CClockSource = LL_RCC_GetI2CClockSource(LL_RCC_I2C1_CLKSOURCE);
;;;497    //  I2CClockFreq = LL_RCC_GetI2CClockFreq(LL_RCC_I2C1_CLKSOURCE);
;;;498      
;;;499      if (LL_I2C_IsActiveFlag_TXIS(I2C1))
000002  bf00              NOP      
000004  4812              LDR      r0,|L2.80|
000006  6980              LDR      r0,[r0,#0x18]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b110              CBZ      r0,|L2.20|
;;;500      {
;;;501        dks_txis_active();
00000e  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_txis_activeEv ; [local to I2C_driver_cpp]::dks_txis_active()
000012  e01c              B        |L2.78|
                  |L2.20|
;;;502      }
;;;503      else if (LL_I2C_IsActiveFlag_RXNE(I2C1)) //если байт принят
000014  bf00              NOP      
000016  480e              LDR      r0,|L2.80|
000018  6980              LDR      r0,[r0,#0x18]
00001a  f3c00080          UBFX     r0,r0,#2,#1
00001e  b110              CBZ      r0,|L2.38|
;;;504      {
;;;505        dks_rxne_active();
000020  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_rxne_activeEv ; [local to I2C_driver_cpp]::dks_rxne_active()
000024  e013              B        |L2.78|
                  |L2.38|
;;;506      }
;;;507      else if (LL_I2C_IsActiveFlag_STOP(I2C1) && OperationFlag == I2C::TOperation::_READ)
000026  bf00              NOP      
000028  4809              LDR      r0,|L2.80|
00002a  6980              LDR      r0,[r0,#0x18]
00002c  f3c01040          UBFX     r0,r0,#5,#1
000030  b128              CBZ      r0,|L2.62|
000032  4808              LDR      r0,|L2.84|
000034  7800              LDRB     r0,[r0,#0]  ; OperationFlag
000036  b910              CBNZ     r0,|L2.62|
;;;508      {
;;;509    	 dks_stop_active();
000038  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_stop_activeEv ; [local to I2C_driver_cpp]::dks_stop_active()
00003c  e007              B        |L2.78|
                  |L2.62|
;;;510      }
;;;511      else if (LL_I2C_IsActiveFlag_TC(I2C1))
00003e  bf00              NOP      
000040  4803              LDR      r0,|L2.80|
000042  6980              LDR      r0,[r0,#0x18]
000044  f3c01080          UBFX     r0,r0,#6,#1
000048  b108              CBZ      r0,|L2.78|
;;;512      {
;;;513        dks_tc_active();
00004a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113dks_tc_activeEv ; [local to I2C_driver_cpp]::dks_tc_active()
                  |L2.78|
;;;514      }
;;;515    }
00004e  bd10              POP      {r4,pc}
;;;516    
                          ENDP

                  |L2.80|
                          DCD      0x40005400
                  |L2.84|
                          DCD      OperationFlag

                          AREA ||i.I2C2_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_ER_IRQHandler PROC
;;;526    
;;;527    extern "C" void I2C2_ER_IRQHandler(void)
000000  4770              BX       lr
;;;528    {
;;;529    
;;;530    }
                          ENDP


                          AREA ||i.I2C2_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_EV_IRQHandler PROC
;;;521    
;;;522    extern "C" void I2C2_EV_IRQHandler(void)
000000  4770              BX       lr
;;;523    {
;;;524    
;;;525    }
;;;526    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_Enable(I2C_TypeDef*)
;;;406      */
;;;407    __STATIC_INLINE void LL_I2C_Enable(I2C_TypeDef *I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;408    {
;;;409      SET_BIT(I2Cx->CR1, I2C_CR1_PE);
000002  f0410101          ORR      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;410    }
000008  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113dks_tc_activeEv||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113dks_tc_activeEv PROC ; [local to I2C_driver_cpp]::dks_tc_active()
;;;449    
;;;450    __INLINE static void dks_tc_active(void)
000000  b510              PUSH     {r4,lr}
;;;451    {
;;;452      switch (OperationFlag)
000002  482a              LDR      r0,|L6.172|
000004  7800              LDRB     r0,[r0,#0]  ; OperationFlag
000006  b110              CBZ      r0,|L6.14|
000008  2801              CMP      r0,#1
00000a  d14b              BNE      |L6.164|
00000c  e028              B        |L6.96|
                  |L6.14|
;;;453      {
;;;454        case I2C::TOperation::_READ:
;;;455    		     LL_I2C_SetSlaveAddr(I2C1, RxSlaveAddr << 1);          //Конфигурирует SLAVE адрес для обмена (режим мастера) \
00000e  4828              LDR      r0,|L6.176|
000010  7800              LDRB     r0,[r0,#0]  ; RxSlaveAddr
000012  0041              LSLS     r1,r0,#1
000014  4827              LDR      r0,|L6.180|
000016  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_SetSlaveAddrEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetSlaveAddr(I2C_TypeDef*, unsigned)
;;;456                                                                   //Нельзя изменять при установленном START бите
;;;457    	       LL_I2C_SetTransferRequest(I2C1, LL_I2C_REQUEST_READ); //Кофигурирует направление обмена (в режиме мастера) \
00001a  f44f6180          MOV      r1,#0x400
00001e  4825              LDR      r0,|L6.180|
000020  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c125LL_I2C_SetTransferRequestEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferRequest(I2C_TypeDef*, unsigned)
;;;458    	                                                             //Нельзя изменять при установленном START бите
;;;459             LL_I2C_SetTransferSize(I2C1, RxBufSize);              //Количество байтов для считывания
000024  4824              LDR      r0,|L6.184|
000026  7801              LDRB     r1,[r0,#0]  ; RxBufSize
000028  4822              LDR      r0,|L6.180|
00002a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferSize(I2C_TypeDef*, unsigned)
;;;460    	       LL_I2C_DisableIT_TX(I2C1);                            //Disable TXIS interrupt
00002e  4821              LDR      r0,|L6.180|
000030  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TXEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_DisableIT_TX(I2C_TypeDef*)
;;;461    	       LL_I2C_DisableIT_TC(I2C1);                            //Disable Transfer Complete interrupt
000034  481f              LDR      r0,|L6.180|
000036  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TCEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_DisableIT_TC(I2C_TypeDef*)
;;;462             LL_I2C_EnableIT_RX(I2C1);                             //Enable RXNE interrupt
00003a  bf00              NOP      
00003c  481d              LDR      r0,|L6.180|
00003e  6800              LDR      r0,[r0,#0]
000040  f0400004          ORR      r0,r0,#4
000044  491b              LDR      r1,|L6.180|
000046  6008              STR      r0,[r1,#0]
000048  bf00              NOP      
;;;463             LL_I2C_EnableAutoEndMode(I2C1);                       //Automatic end: Стоп условие отправляется автоматически, когда было передано/принято NBYTES данных
00004a  bf00              NOP      
00004c  4608              MOV      r0,r1
00004e  6840              LDR      r0,[r0,#4]
000050  f0407000          ORR      r0,r0,#0x2000000
000054  6048              STR      r0,[r1,#4]
000056  bf00              NOP      
;;;464             LL_I2C_GenerateStartCondition(I2C1);                  //Generate a RESTART condition
000058  4608              MOV      r0,r1
00005a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c129LL_I2C_GenerateStartConditionEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_GenerateStartCondition(I2C_TypeDef*)
;;;465                                                                   //Флаг TC, при AUTOEND = 1, не работает
;;;466                                                                   //TXIS сбрасывается при 
;;;467      	     break;
00005e  e022              B        |L6.166|
                  |L6.96|
;;;468        case I2C::TOperation::_WRITE:
;;;469    //         LL_I2C_ClearFlag_STOP(I2C1); //Clear Stop detection flag
;;;470    //         RelThree.toggle(); 
;;;471    	       LL_I2C_GenerateStopCondition(I2C1); //генерирует STOP условие (в режиме мастера) + сброс флага TC
000060  bf00              NOP      
000062  4814              LDR      r0,|L6.180|
000064  6840              LDR      r0,[r0,#4]
000066  f4404080          ORR      r0,r0,#0x4000
00006a  4912              LDR      r1,|L6.180|
00006c  6048              STR      r0,[r1,#4]
00006e  bf00              NOP      
;;;472    //         LL_I2C_DisableIT_TX(I2C1);          //Disable TXIS interrupt
;;;473    	       LL_I2C_DisableIT_TC(I2C1);          //Disable Transfer Complete interrupt
000070  4608              MOV      r0,r1
000072  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TCEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_DisableIT_TC(I2C_TypeDef*)
;;;474    			
;;;475    //  RelFour.toggle();
;;;476    			   TxHigherPriorityTaskWoken = pdFALSE;
000076  2000              MOVS     r0,#0
000078  4910              LDR      r1,|L6.188|
00007a  6008              STR      r0,[r1,#0]  ; TxHigherPriorityTaskWoken
;;;477    			   if (xSemaphoreGiveFromISR(I2C_TxSem, &TxHigherPriorityTaskWoken) == pdFAIL) //отправить семафор окончания записи
00007c  4810              LDR      r0,|L6.192|
00007e  6800              LDR      r0,[r0,#0]  ; I2C_TxSem
000080  f7fffffe          BL       xQueueGiveFromISR
;;;478             {
;;;479               //семафор уже был доступен, т.е. ранее отдан другой задачей или прерыванием
;;;480             }  
;;;481    	       if ( TxHigherPriorityTaskWoken == pdPASS )
000084  480d              LDR      r0,|L6.188|
000086  6800              LDR      r0,[r0,#0]  ; TxHigherPriorityTaskWoken
000088  2801              CMP      r0,#1
00008a  d10a              BNE      |L6.162|
;;;482    	       {
;;;483                portYIELD_FROM_ISR(TxHigherPriorityTaskWoken);  //принудительное переключение контекста для разблокировки задачи - обработчика
00008c  480b              LDR      r0,|L6.188|
00008e  6800              LDR      r0,[r0,#0]  ; TxHigherPriorityTaskWoken
000090  b138              CBZ      r0,|L6.162|
000092  f04f5080          MOV      r0,#0x10000000
000096  490b              LDR      r1,|L6.196|
000098  6008              STR      r0,[r1,#0]
00009a  f3bf8f4f          DSB      
00009e  f3bf8f6f          ISB      
                  |L6.162|
;;;484    	       }
;;;485      	     break;
0000a2  e000              B        |L6.166|
                  |L6.164|
;;;486        default:
;;;487      	     break;
0000a4  bf00              NOP      
                  |L6.166|
0000a6  bf00              NOP                            ;467
;;;488      }
;;;489    } 
0000a8  bd10              POP      {r4,pc}
;;;490    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L6.172|
                          DCD      OperationFlag
                  |L6.176|
                          DCD      RxSlaveAddr
                  |L6.180|
                          DCD      0x40005400
                  |L6.184|
                          DCD      RxBufSize
                  |L6.188|
                          DCD      TxHigherPriorityTaskWoken
                  |L6.192|
                          DCD      I2C_TxSem
                  |L6.196|
                          DCD      0xe000ed04

                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_Disable(I2C_TypeDef*)
;;;420      */
;;;421    __STATIC_INLINE void LL_I2C_Disable(I2C_TypeDef *I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;422    {
;;;423      CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;424    }
000008  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_rxne_activeEv||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_rxne_activeEv PROC ; [local to I2C_driver_cpp]::dks_rxne_active()
;;;398    
;;;399    __INLINE static void dks_rxne_active(void)
000000  4816              LDR      r0,|L8.92|
;;;400    {
;;;401      switch (OperationFlag)
000002  7800              LDRB     r0,[r0,#0]  ; OperationFlag
000004  b110              CBZ      r0,|L8.12|
000006  2801              CMP      r0,#1
000008  d125              BNE      |L8.86|
00000a  e023              B        |L8.84|
                  |L8.12|
;;;402      {
;;;403        case I2C::TOperation::_READ:
;;;404    	      
;;;405    //			if (RxByteCtr == 0)
;;;406    //			{
;;;407    //			  RelFour.off();
;;;408    //			}
;;;409    	      RxBufPtr[RxByteCtr++] = LL_I2C_ReceiveData8(I2C1); //считать принятый байт => флаг RXNE сбросится
00000c  bf00              NOP      
00000e  4814              LDR      r0,|L8.96|
000010  6a40              LDR      r0,[r0,#0x24]
000012  b2c0              UXTB     r0,r0
000014  4913              LDR      r1,|L8.100|
000016  780a              LDRB     r2,[r1,#0]  ; RxByteCtr
000018  7809              LDRB     r1,[r1,#0]  ; RxByteCtr
00001a  1c49              ADDS     r1,r1,#1
00001c  4b11              LDR      r3,|L8.100|
00001e  7019              STRB     r1,[r3,#0]
000020  4911              LDR      r1,|L8.104|
000022  6809              LDR      r1,[r1,#0]  ; RxBufPtr
000024  5488              STRB     r0,[r1,r2]
;;;410    			if (RxByteCtr == RxBufSize)
000026  4618              MOV      r0,r3
000028  7800              LDRB     r0,[r0,#0]  ; RxByteCtr
00002a  4910              LDR      r1,|L8.108|
00002c  7809              LDRB     r1,[r1,#0]  ; RxBufSize
00002e  4288              CMP      r0,r1
000030  d10f              BNE      |L8.82|
;;;411    			{
;;;412               LL_I2C_DisableIT_RX(I2C1);  //Disable RXNE interrupt
000032  bf00              NOP      
000034  480a              LDR      r0,|L8.96|
000036  6800              LDR      r0,[r0,#0]
000038  f0200004          BIC      r0,r0,#4
00003c  4908              LDR      r1,|L8.96|
00003e  6008              STR      r0,[r1,#0]
000040  bf00              NOP      
;;;413               LL_I2C_EnableIT_STOP(I2C1); //Enable STOP detection interrupt
000042  bf00              NOP      
000044  4608              MOV      r0,r1
000046  6800              LDR      r0,[r0,#0]
000048  f0400020          ORR      r0,r0,#0x20
00004c  6008              STR      r0,[r1,#0]
00004e  bf00              NOP      
000050  bf00              NOP      
                  |L8.82|
;;;414    			}
;;;415      	      break;
000052  e001              B        |L8.88|
                  |L8.84|
;;;416        case I2C::TOperation::_WRITE:
;;;417      	      break;
000054  e000              B        |L8.88|
                  |L8.86|
;;;418        default:
;;;419      	      break;
000056  bf00              NOP      
                  |L8.88|
000058  bf00              NOP                            ;415
;;;420      }
;;;421    } 
00005a  4770              BX       lr
;;;422    
                          ENDP

                  |L8.92|
                          DCD      OperationFlag
                  |L8.96|
                          DCD      0x40005400
                  |L8.100|
                          DCD      RxByteCtr
                  |L8.104|
                          DCD      RxBufPtr
                  |L8.108|
                          DCD      RxBufSize

                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_stop_activeEv||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_stop_activeEv PROC ; [local to I2C_driver_cpp]::dks_stop_active()
;;;422    
;;;423    __INLINE static void dks_stop_active(void)
000000  b510              PUSH     {r4,lr}
;;;424    {
;;;425      LL_I2C_ClearFlag_STOP(I2C1); //Clear Stop detection flag
000002  4816              LDR      r0,|L9.92|
000004  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_STOPEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_STOP(I2C_TypeDef*)
;;;426      LL_I2C_DisableIT_STOP(I2C1); //Disable STOP detection interrupt
000008  bf00              NOP      
00000a  4814              LDR      r0,|L9.92|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0200020          BIC      r0,r0,#0x20
000012  4912              LDR      r1,|L9.92|
000014  6008              STR      r0,[r1,#0]
000016  bf00              NOP      
;;;427    //         RelThree.toggle(); 
;;;428      		
;;;429      switch (OperationFlag)
000018  4811              LDR      r0,|L9.96|
00001a  7800              LDRB     r0,[r0,#0]  ; OperationFlag
00001c  b110              CBZ      r0,|L9.36|
00001e  2801              CMP      r0,#1
000020  d118              BNE      |L9.84|
000022  e016              B        |L9.82|
                  |L9.36|
;;;430      {
;;;431        case I2C::TOperation::_READ:
;;;432    //         RelThree.toggle();
;;;433             RxHigherPriorityTaskWoken = pdFALSE;
000024  2000              MOVS     r0,#0
000026  490f              LDR      r1,|L9.100|
000028  6008              STR      r0,[r1,#0]  ; RxHigherPriorityTaskWoken
;;;434             if (xSemaphoreGiveFromISR(I2C_RxSem, &RxHigherPriorityTaskWoken) == pdFAIL) //отправить семафор окончания считывания
00002a  480f              LDR      r0,|L9.104|
00002c  6800              LDR      r0,[r0,#0]  ; I2C_RxSem
00002e  f7fffffe          BL       xQueueGiveFromISR
;;;435             {
;;;436               //семафор уже был доступен, т.е. ранее отдан другой задачей или прерыванием
;;;437             } 
;;;438             if (RxHigherPriorityTaskWoken == pdPASS)
000032  480c              LDR      r0,|L9.100|
000034  6800              LDR      r0,[r0,#0]  ; RxHigherPriorityTaskWoken
000036  2801              CMP      r0,#1
000038  d10a              BNE      |L9.80|
;;;439             {
;;;440               portYIELD_FROM_ISR(RxHigherPriorityTaskWoken);  //принудительное переключение контекста для разблокировки задачи - обработчика
00003a  480a              LDR      r0,|L9.100|
00003c  6800              LDR      r0,[r0,#0]  ; RxHigherPriorityTaskWoken
00003e  b138              CBZ      r0,|L9.80|
000040  f04f5080          MOV      r0,#0x10000000
000044  4909              LDR      r1,|L9.108|
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
                  |L9.80|
;;;441             }
;;;442      	      break;
000050  e001              B        |L9.86|
                  |L9.82|
;;;443        case I2C::TOperation::_WRITE:
;;;444      	      break;
000052  e000              B        |L9.86|
                  |L9.84|
;;;445        default:
;;;446      	      break;
000054  bf00              NOP      
                  |L9.86|
000056  bf00              NOP                            ;442
;;;447      }
;;;448    } 
000058  bd10              POP      {r4,pc}
;;;449    
                          ENDP

00005a  0000              DCW      0x0000
                  |L9.92|
                          DCD      0x40005400
                  |L9.96|
                          DCD      OperationFlag
                  |L9.100|
                          DCD      RxHigherPriorityTaskWoken
                  |L9.104|
                          DCD      I2C_RxSem
                  |L9.108|
                          DCD      0xe000ed04

                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_txis_activeEv||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_txis_activeEv PROC ; [local to I2C_driver_cpp]::dks_txis_active()
;;;341    //******************************************************************************
;;;342    __INLINE static void dks_txis_active(void)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344        LL_I2C_ClearFlag_STOP(I2C1); //Clear Stop detection flag
000002  4819              LDR      r0,|L10.104|
000004  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_STOPEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_STOP(I2C_TypeDef*)
;;;345    	 if (!IsTxSlaveRegAddr) //Если адрес регистра в slave не отправлен
000008  4818              LDR      r0,|L10.108|
00000a  7800              LDRB     r0,[r0,#0]  ; IsTxSlaveRegAddr
00000c  b980              CBNZ     r0,|L10.48|
;;;346    	 {
;;;347    	   LL_I2C_TransmitData8(I2C1, StartRegAddr); //Запись адреса регистра в slave в регистр передачи данных I2C \
00000e  4818              LDR      r0,|L10.112|
000010  7801              LDRB     r1,[r0,#0]  ; StartRegAddr
000012  4815              LDR      r0,|L10.104|
000014  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c120LL_I2C_TransmitData8EP11I2C_TypeDefh ; [local to I2C_driver_cpp]::LL_I2C_TransmitData8(I2C_TypeDef*, unsigned char)
;;;348    		                                            START сброшен, ACK принят
;;;349          LL_I2C_EnableIT_TC(I2C1);                 //Enable Transfer Complete interrupt
000018  bf00              NOP      
00001a  4813              LDR      r0,|L10.104|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400040          ORR      r0,r0,#0x40
000022  4911              LDR      r1,|L10.104|
000024  6008              STR      r0,[r1,#0]
000026  bf00              NOP      
;;;350          IsTxSlaveRegAddr = true;
000028  2001              MOVS     r0,#1
00002a  4910              LDR      r1,|L10.108|
00002c  7008              STRB     r0,[r1,#0]
00002e  e01a              B        |L10.102|
                  |L10.48|
;;;351    	 }
;;;352    	 else
;;;353    	 {
;;;354    	   switch (OperationFlag)
000030  4810              LDR      r0,|L10.116|
000032  7800              LDRB     r0,[r0,#0]  ; OperationFlag
000034  b110              CBZ      r0,|L10.60|
000036  2801              CMP      r0,#1
000038  d114              BNE      |L10.100|
00003a  e000              B        |L10.62|
                  |L10.60|
;;;355    		{
;;;356    		  case I2C::TOperation::_READ:
;;;357    		        break;
00003c  e012              B        |L10.100|
                  |L10.62|
;;;358    		  case I2C::TOperation::_WRITE:
;;;359    	          LL_I2C_TransmitData8(I2C1, TxBufPtr[--TxBufSize]);      //Запись очередного байта в slave
00003e  480e              LDR      r0,|L10.120|
000040  7800              LDRB     r0,[r0,#0]  ; TxBufSize
000042  1e40              SUBS     r0,r0,#1
000044  b2c0              UXTB     r0,r0
000046  4a0c              LDR      r2,|L10.120|
000048  7010              STRB     r0,[r2,#0]
00004a  4a0c              LDR      r2,|L10.124|
00004c  6812              LDR      r2,[r2,#0]  ; TxBufPtr
00004e  5c11              LDRB     r1,[r2,r0]
000050  4805              LDR      r0,|L10.104|
000052  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c120LL_I2C_TransmitData8EP11I2C_TypeDefh ; [local to I2C_driver_cpp]::LL_I2C_TransmitData8(I2C_TypeDef*, unsigned char)
;;;360    				 if (!TxBufSize)
000056  4808              LDR      r0,|L10.120|
000058  7800              LDRB     r0,[r0,#0]  ; TxBufSize
00005a  b910              CBNZ     r0,|L10.98|
;;;361    				 {
;;;362                   LL_I2C_DisableIT_TX(I2C1);                            //Disable TXIS interrupt
00005c  4802              LDR      r0,|L10.104|
00005e  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TXEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_DisableIT_TX(I2C_TypeDef*)
                  |L10.98|
;;;363    //	            LL_I2C_EnableIT_TC(I2C1);                            //Enable Transfer Complete interrupt
;;;364    				 }
;;;365                 break;
000062  bf00              NOP      
                  |L10.100|
000064  bf00              NOP                            ;357
                  |L10.102|
;;;366    		}
;;;367    	 }
;;;368    //	 else //Адрес регистра в slave уже отправлен
;;;369    //	 {
;;;370    //	   switch (OperationFlag)
;;;371    //		{
;;;372    //		  case I2C::TOperation::_READ:
;;;373    //		       LL_I2C_SetSlaveAddr(I2C1, RxSlaveAddr);                //Конфигурирует SLAVE адрес для обмена (режим мастера) \
;;;374    //				 										                          //Нельзя изменять при установленном START бите
;;;375    //	          LL_I2C_SetTransferRequest(I2C1, LL_I2C_REQUEST_READ);  //Кофигурирует направление обмена (в режиме мастера) \
;;;376    //	                                                                 //Нельзя изменять при установленном START бите
;;;377    //             LL_I2C_SetTransferSize(I2C1, RxBufSize);               //Количество байтов для считывания
;;;378    //	          LL_I2C_DisableIT_TX(I2C1);                             //Disable TXIS interrupt
;;;379    //				 LL_I2C_EnableIT_RX(I2C1);                              //Enable RXNE interrupt
;;;380    //             LL_I2C_EnableAutoEndMode(I2C1);                        //Automatic end: Стоп условие отправляется автоматически, когда было передано/принято NBYTES данных
;;;381    //             LL_I2C_GenerateStartCondition(I2C1);                   //Generate a RESTART condition
;;;382    //				                                                        //Флаг TC, при AUTOEND = 1, не работает
;;;383    //																						  //TXIS сбрасывается при 
;;;384    ////             RxIdx = AccGyroMag.TransferSize;
;;;385    //		       break;
;;;386    //		  case I2C::TOperation::_WRITE:
;;;387    //	          LL_I2C_TransmitData8(I2C1, TxBufPtr[TxBufSize--]);      //Запись очередного байта в slave
;;;388    //				 if (!TxBufSize)
;;;389    //				 {
;;;390    //	            LL_I2C_EnableIT_TC(I2C1);                            //Enable Transfer Complete interrupt
;;;391    //				 }
;;;392    //		       break;
;;;393    //		  default:
;;;394    //		       break;
;;;395    //		}
;;;396    //	 }
;;;397    } 
000066  bd10              POP      {r4,pc}
;;;398    
                          ENDP

                  |L10.104|
                          DCD      0x40005400
                  |L10.108|
                          DCD      IsTxSlaveRegAddr
                  |L10.112|
                          DCD      StartRegAddr
                  |L10.116|
                          DCD      OperationFlag
                  |L10.120|
                          DCD      TxBufSize
                  |L10.124|
                          DCD      TxBufPtr

                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TCEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TCEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_DisableIT_TC(I2C_TypeDef*)
;;;1443     */
;;;1444   __STATIC_INLINE void LL_I2C_DisableIT_TC(I2C_TypeDef *I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;1445   {
;;;1446     CLEAR_BIT(I2Cx->CR1, I2C_CR1_TCIE);
000002  f0210140          BIC      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;1447   }
000008  4770              BX       lr
;;;1448   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TXEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TXEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_DisableIT_TX(I2C_TypeDef*)
;;;1272     */
;;;1273   __STATIC_INLINE void LL_I2C_DisableIT_TX(I2C_TypeDef *I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;1274   {
;;;1275     CLEAR_BIT(I2Cx->CR1, I2C_CR1_TXIE);
000002  f0210102          BIC      r1,r1,#2
000006  6001              STR      r1,[r0,#0]
;;;1276   }
000008  4770              BX       lr
;;;1277   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_SetSlaveAddrEP11I2C_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_SetSlaveAddrEP11I2C_TypeDefj PROC ; [local to I2C_driver_cpp]::LL_I2C_SetSlaveAddr(I2C_TypeDef*, unsigned)
;;;2051     */
;;;2052   __STATIC_INLINE void LL_I2C_SetSlaveAddr(I2C_TypeDef *I2Cx, uint32_t SlaveAddr)
000000  6842              LDR      r2,[r0,#4]
;;;2053   {
;;;2054     MODIFY_REG(I2Cx->CR2, I2C_CR2_SADD, SlaveAddr);
000002  f36f0209          BFC      r2,#0,#10
000006  430a              ORRS     r2,r2,r1
000008  6042              STR      r2,[r0,#4]
;;;2055   }
00000a  4770              BX       lr
;;;2056   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c120LL_I2C_TransmitData8EP11I2C_TypeDefh||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c120LL_I2C_TransmitData8EP11I2C_TypeDefh PROC ; [local to I2C_driver_cpp]::LL_I2C_TransmitData8(I2C_TypeDef*, unsigned char)
;;;2199     */
;;;2200   __STATIC_INLINE void LL_I2C_TransmitData8(I2C_TypeDef *I2Cx, uint8_t Data)
000000  6281              STR      r1,[r0,#0x28]
;;;2201   {
;;;2202     WRITE_REG(I2Cx->TXDR, Data);
;;;2203   }
000002  4770              BX       lr
;;;2204   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_ARLO(I2C_TypeDef*)
;;;1782     */
;;;1783   __STATIC_INLINE void LL_I2C_ClearFlag_ARLO(I2C_TypeDef *I2Cx)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;1784   {
;;;1785     SET_BIT(I2Cx->ICR, I2C_ICR_ARLOCF);
000002  f4417100          ORR      r1,r1,#0x200
000006  61c1              STR      r1,[r0,#0x1c]
;;;1786   }
000008  4770              BX       lr
;;;1787   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_STOPEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_STOPEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_STOP(I2C_TypeDef*)
;;;1748     */
;;;1749   __STATIC_INLINE void LL_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;1750   {
;;;1751     SET_BIT(I2Cx->ICR, I2C_ICR_STOPCF);
000002  f0410120          ORR      r1,r1,#0x20
000006  61c1              STR      r1,[r0,#0x1c]
;;;1752   }
000008  4770              BX       lr
;;;1753   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj PROC ; [local to I2C_driver_cpp]::LL_I2C_SetTransferSize(I2C_TypeDef*, unsigned)
;;;1924     */
;;;1925   __STATIC_INLINE void LL_I2C_SetTransferSize(I2C_TypeDef *I2Cx, uint32_t TransferSize)
000000  6842              LDR      r2,[r0,#4]
;;;1926   {
;;;1927     MODIFY_REG(I2Cx->CR2, I2C_CR2_NBYTES, TransferSize << I2C_CR2_NBYTES_Pos);
000002  f422027f          BIC      r2,r2,#0xff0000
000006  ea424201          ORR      r2,r2,r1,LSL #16
00000a  6042              STR      r2,[r0,#4]
;;;1928   }
00000c  4770              BX       lr
;;;1929   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c125LL_I2C_SetTransferRequestEP11I2C_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c125LL_I2C_SetTransferRequestEP11I2C_TypeDefj PROC ; [local to I2C_driver_cpp]::LL_I2C_SetTransferRequest(I2C_TypeDef*, unsigned)
;;;2025     */
;;;2026   __STATIC_INLINE void LL_I2C_SetTransferRequest(I2C_TypeDef *I2Cx, uint32_t TransferRequest)
000000  6842              LDR      r2,[r0,#4]
;;;2027   {
;;;2028     MODIFY_REG(I2Cx->CR2, I2C_CR2_RD_WRN, TransferRequest);
000002  f4226280          BIC      r2,r2,#0x400
000006  430a              ORRS     r2,r2,r1
000008  6042              STR      r2,[r0,#4]
;;;2029   }
00000a  4770              BX       lr
;;;2030   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c129LL_I2C_GenerateStartConditionEP11I2C_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c129LL_I2C_GenerateStartConditionEP11I2C_TypeDef PROC ; [local to I2C_driver_cpp]::LL_I2C_GenerateStartCondition(I2C_TypeDef*)
;;;1963     */
;;;1964   __STATIC_INLINE void LL_I2C_GenerateStartCondition(I2C_TypeDef *I2Cx)
000000  6841              LDR      r1,[r0,#4]
;;;1965   {
;;;1966     SET_BIT(I2Cx->CR2, I2C_CR2_START);
000002  f4415100          ORR      r1,r1,#0x2000
000006  6041              STR      r1,[r0,#4]
;;;1967   }
000008  4770              BX       lr
;;;1968   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c130LL_I2C_SetMasterAddressingModeEP11I2C_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c130LL_I2C_SetMasterAddressingModeEP11I2C_TypeDefj PROC ; [local to I2C_driver_cpp]::LL_I2C_SetMasterAddressingMode(I2C_TypeDef*, unsigned)
;;;765      */
;;;766    __STATIC_INLINE void LL_I2C_SetMasterAddressingMode(I2C_TypeDef *I2Cx, uint32_t AddressingMode)
000000  6842              LDR      r2,[r0,#4]
;;;767    {
;;;768      MODIFY_REG(I2Cx->CR2, I2C_CR2_ADD10, AddressingMode);
000002  f4226200          BIC      r2,r2,#0x800
000006  430a              ORRS     r2,r2,r1
000008  6042              STR      r2,[r0,#4]
;;;769    }
00000a  4770              BX       lr
;;;770    
                          ENDP


                          AREA ||i._ZN3I2C4TI2C10read_burstEPhhhh||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C10read_burstEPhhhh PROC ; I2C::TI2C::read_burst(unsigned char*, unsigned char, unsigned char, unsigned char)
;;;284      
;;;285      void TI2C::read_burst(uint8_t *DataBurst, uint8_t _TransferSize, uint8_t _StartRegAddr, uint8_t SlaveAddr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;286      {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;287        start: constexpr uint32_t DELAY_TIME_MS = 100;
000010  bf00              NOP      
                  |L21.18|
000012  f04f0964          MOV      r9,#0x64
;;;288    		__disable_irq();
000016  b672              CPSID    i
;;;289    	     OperationFlag = TOperation::_READ; //Общий флаг процесса - считывание, которое начинается с записи адреса slave.
000018  2000              MOVS     r0,#0
00001a  4915              LDR      r1,|L21.112|
00001c  7008              STRB     r0,[r1,#0]
;;;290    		  RxBufSize     = _TransferSize;     //
00001e  4815              LDR      r0,|L21.116|
000020  7006              STRB     r6,[r0,#0]
;;;291    		  RxBufPtr      = DataBurst;
000022  4815              LDR      r0,|L21.120|
000024  6005              STR      r5,[r0,#0]  ; RxBufPtr
;;;292    		  StartRegAddr  = _StartRegAddr;
000026  4815              LDR      r0,|L21.124|
000028  7007              STRB     r7,[r0,#0]
;;;293    		  RxSlaveAddr   = SlaveAddr;
00002a  4815              LDR      r0,|L21.128|
00002c  f8808000          STRB     r8,[r0,#0]
;;;294    		  RxByteCtr     = 0U;
000030  2000              MOVS     r0,#0
000032  4914              LDR      r1,|L21.132|
000034  7008              STRB     r0,[r1,#0]
;;;295    		__enable_irq();
000036  b662              CPSIE    i
;;;296        
;;;297    		LL_I2C_SetTransferSize( HW.If, 1U);            //Количество байтов для записи
000038  2101              MOVS     r1,#1
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferSize(I2C_TypeDef*, unsigned)
;;;298        start_transfer(SlaveAddr);
000040  4641              MOV      r1,r8
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       _ZN3I2C4TI2C14start_transferEh ; I2C::TI2C::start_transfer(unsigned char)
;;;299        
;;;300    	  if ( xSemaphoreTake( I2C_RxSem, pdMS_TO_TICKS(DELAY_TIME_MS) ) == pdFALSE ) //ждать семафор окончания приема кадра с данными из прерывания
000048  2300              MOVS     r3,#0
00004a  2264              MOVS     r2,#0x64
00004c  4619              MOV      r1,r3
00004e  480e              LDR      r0,|L21.136|
000050  6800              LDR      r0,[r0,#0]  ; I2C_RxSem
000052  f7fffffe          BL       xQueueGenericReceive
000056  b948              CBNZ     r0,|L21.108|
;;;301    		{
;;;302          LL_I2C_Disable( HW.If );
000058  69a0              LDR      r0,[r4,#0x18]
00005a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Disable(I2C_TypeDef*)
;;;303          LL_I2C_ClearFlag_ARLO( HW.If );
00005e  69a0              LDR      r0,[r4,#0x18]
000060  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_ARLO(I2C_TypeDef*)
;;;304          LL_I2C_Enable( HW.If );
000064  69a0              LDR      r0,[r4,#0x18]
000066  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Enable(I2C_TypeDef*)
;;;305          goto start;
00006a  e7d2              B        |L21.18|
                  |L21.108|
;;;306    		}
;;;307      }
00006c  e8bd87f0          POP      {r4-r10,pc}
;;;308      
                          ENDP

                  |L21.112|
                          DCD      OperationFlag
                  |L21.116|
                          DCD      RxBufSize
                  |L21.120|
                          DCD      RxBufPtr
                  |L21.124|
                          DCD      StartRegAddr
                  |L21.128|
                          DCD      RxSlaveAddr
                  |L21.132|
                          DCD      RxByteCtr
                  |L21.136|
                          DCD      I2C_RxSem

                          AREA ||i._ZN3I2C4TI2C11i2c_hw_initEv||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C11i2c_hw_initEv PROC ; I2C::TI2C::i2c_hw_init()
;;;96       
;;;97       void TI2C::i2c_hw_init()
000000  b530              PUSH     {r4,r5,lr}
;;;98       {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;99         LL_I2C_InitTypeDef I2C_InitStruct;
;;;100    
;;;101        do
000006  bf00              NOP      
                  |L22.8|
;;;102        {
;;;103          LL_I2C_Disable( HW.If ); // SCL и SDA отпущены, Внутренний автомат и биты статуса сброшены
000008  69a0              LDR      r0,[r4,#0x18]
00000a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Disable(I2C_TypeDef*)
;;;104        } while (LL_I2C_IsEnabled( HW.If ));
00000e  69a0              LDR      r0,[r4,#0x18]
000010  6801              LDR      r1,[r0,#0]
000012  f0010101          AND      r1,r1,#1
000016  2900              CMP      r1,#0
000018  d1f6              BNE      |L22.8|
;;;105    
;;;106        LL_I2C_EnableClockStretching( HW.If ); //I2C д.б. отключен
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  6801              LDR      r1,[r0,#0]
00001e  f4213100          BIC      r1,r1,#0x20000
000022  6001              STR      r1,[r0,#0]
000024  bf00              NOP      
;;;107    
;;;108    	  do 
000026  bf00              NOP      
                  |L22.40|
;;;109    	  {
;;;110          switch (Mode)
000028  f894008c          LDRB     r0,[r4,#0x8c]
00002c  b130              CBZ      r0,|L22.60|
00002e  2801              CMP      r0,#1
000030  d005              BEQ      |L22.62|
000032  2802              CMP      r0,#2
000034  d006              BEQ      |L22.68|
000036  2803              CMP      r0,#3
000038  d106              BNE      |L22.72|
00003a  e004              B        |L22.70|
                  |L22.60|
;;;111    		  {
;;;112    		    case TMode::_SLAVE:
;;;113    //	  	       I2C_InitTypeDef.OwnAddress1 = ; //реализация по необходимости
;;;114    //             I2C_InitTypeDef.TypeAcknowledge = LL_I2C_ACK; //реализация по необходимости
;;;115    //             I2C_InitTypeDef.OwnAddrSize = LL_I2C_OWNADDRESS1_7BIT; //реализация по необходимости
;;;116    		    case TMode::_MASTER:
00003c  bf00              NOP      
                  |L22.62|
;;;117    		         I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
00003e  2000              MOVS     r0,#0
000040  9000              STR      r0,[sp,#0]
;;;118    		         break;
000042  e002              B        |L22.74|
                  |L22.68|
;;;119    		    case TMode::_SMBUS_HOST: 
;;;120    		         //реализация по необходимости
;;;121    		         break;
000044  e001              B        |L22.74|
                  |L22.70|
;;;122    		    case TMode::_SMBUS_DEVICE: 
;;;123    		         //реализация по необходимости
;;;124    		         break;
000046  e000              B        |L22.74|
                  |L22.72|
;;;125    		    default:
;;;126    		         break;
000048  bf00              NOP      
                  |L22.74|
00004a  bf00              NOP                            ;118
;;;127    		  }
;;;128    		  switch (Rate)
00004c  f894008d          LDRB     r0,[r4,#0x8d]
000050  b120              CBZ      r0,|L22.92|
000052  2801              CMP      r0,#1
000054  d005              BEQ      |L22.98|
000056  2802              CMP      r0,#2
000058  d10b              BNE      |L22.114|
00005a  e007              B        |L22.108|
                  |L22.92|
;;;129    		  {
;;;130    		    case TRate::_STANDARD:
;;;131    	  	        I2C_InitStruct.Timing = 0x10B07DB7;  /* I2C Timing Configuration Tool for STM32F3xx and STM32F0xx devices v1.0.1
00005c  4817              LDR      r0,|L22.188|
00005e  9001              STR      r0,[sp,#4]
;;;132                                                          * Device Mode                   - Master, 
;;;133      	       	 										          * I2C Speed Mode                - Standard Mode, 
;;;134      	       	 										          * I2C Speed Frequency           - 100kHz, 
;;;135      	       	 										          * I2C Clock Source Frequency    - 64000kHz, 
;;;136      	       	 										          * Analog Filter Delay           - ON, 
;;;137      	       	 										          * Coefficient of Digital Filter - 0, 
;;;138      	       	 										          * Rise Time (ns)                - 100, 
;;;139      	       	 										          * Fall Time (ns)                - 50
;;;140      	       	 										          * Master, настраивается только при отключенном I2C
;;;141      	       	 */
;;;142    		         break;
000060  e008              B        |L22.116|
                  |L22.98|
;;;143    		    case TRate::_FAST:
;;;144    #ifndef __DEBUG__
;;;145    //             I2C_InitStruct.Timing = 0x00E02577; //72МГц, 400кГц, Rise Time = 100ns, Fall Time = 50ns
;;;146    //             I2C_InitStruct.Timing = 0x00500C29; //26МГц, 400кГц, Rise Time = 100ns, Fall Time = 50ns
;;;147                 I2C_InitStruct.Timing = 0x00200411; //12МГц, 400кГц, Rise Time = 100ns, Fall Time = 50ns
000062  4817              LDR      r0,|L22.192|
000064  9001              STR      r0,[sp,#4]
;;;148    #else		  
;;;149                 I2C_InitStruct.Timing = 0x00C02169; //400kHz
;;;150    #endif
;;;151                 /* I2C Timing Configuration Tool for STM32F3xx and STM32F0xx devices v1.0.1
;;;152                    * Device Mode                   - Master, 
;;;153      	       	    * I2C Speed Mode                - Fast Mode, 
;;;154      	       	    * I2C Speed Frequency           - 400kHz, 
;;;155      	       	    * I2C Clock Source Frequency    - 64000kHz, 
;;;156      	       	    * Analog Filter Delay           - ON, 
;;;157      	       	    * Coefficient of Digital Filter - 0, 
;;;158      	       	    * Rise Time (ns)                - 100, 
;;;159      	       	    * Fall Time (ns)                - 50
;;;160      	       	    * Master, настраивается только при отключенном I2C
;;;161      	       	  */	       
;;;162    		        I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
000066  2000              MOVS     r0,#0
000068  9000              STR      r0,[sp,#0]
;;;163    		        break;
00006a  e003              B        |L22.116|
                  |L22.108|
;;;164    		   case TRate::_FAST_MODE_PLUS:
;;;165    	         I2C_InitStruct.Timing = 0x00900B1F; /* I2C Timing Configuration Tool for STM32F3xx and STM32F0xx devices v1.0.1
00006c  4815              LDR      r0,|L22.196|
00006e  9001              STR      r0,[sp,#4]
;;;166                                                        * Device Mode                   - Master, 
;;;167      	       	 										          * I2C Speed Mode                - Fast Mode Plus, 
;;;168      	       	 										          * I2C Speed Frequency           - 1000kHz, 
;;;169      	       	 										          * I2C Clock Source Frequency    - 64000kHz, 
;;;170      	       	 										          * Analog Filter Delay           - ON, 
;;;171      	       	 										          * Coefficient of Digital Filter - 0, 
;;;172      	       	 										          * Rise Time (ns)                - 100, 
;;;173      	       	 										          * Fall Time (ns)                - 50
;;;174      	       	 										          * Master, настраивается только при отключенном I2C
;;;175      	       	 										        */
;;;176    		        break;
000070  e000              B        |L22.116|
                  |L22.114|
;;;177    		   default:
;;;178    		        break;
000072  bf00              NOP      
                  |L22.116|
000074  bf00              NOP                            ;142
;;;179    		 }
;;;180         I2C_InitStruct.AnalogFilter = LL_I2C_ANALOGFILTER_ENABLE;
000076  2000              MOVS     r0,#0
000078  9002              STR      r0,[sp,#8]
;;;181         I2C_InitStruct.DigitalFilter = 0x00U; //Min_Data = 0x00
00007a  9003              STR      r0,[sp,#0xc]
;;;182        
;;;183    	 } while (SUCCESS != LL_I2C_Init( HW.If, &I2C_InitStruct ));
00007c  4669              MOV      r1,sp
00007e  69a0              LDR      r0,[r4,#0x18]
000080  f7fffffe          BL       LL_I2C_Init
000084  2800              CMP      r0,#0
000086  d1cf              BNE      |L22.40|
;;;184    
;;;185    	 
;;;186    	 uint32_t AddressingMode = ((Addressing == TAddressing::_7_BIT) ? LL_I2C_ADDRESSING_MODE_7BIT 
000088  f894008e          LDRB     r0,[r4,#0x8e]
00008c  b908              CBNZ     r0,|L22.146|
00008e  2000              MOVS     r0,#0
000090  e001              B        |L22.150|
                  |L22.146|
;;;187    	                                                                : LL_I2C_ADDRESSING_MODE_10BIT);
000092  f44f6000          MOV      r0,#0x800
                  |L22.150|
000096  4605              MOV      r5,r0
;;;188    	 LL_I2C_SetMasterAddressingMode( HW.If, AddressingMode ); //конфигурация мастера для работы в 7-ми или 10-ти битном режиме  
000098  4629              MOV      r1,r5
00009a  69a0              LDR      r0,[r4,#0x18]
00009c  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c130LL_I2C_SetMasterAddressingModeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetMasterAddressingMode(I2C_TypeDef*, unsigned)
;;;189    	 LL_I2C_DisableReloadMode( HW.If );
0000a0  69a0              LDR      r0,[r4,#0x18]
0000a2  6841              LDR      r1,[r0,#4]
0000a4  f0217180          BIC      r1,r1,#0x1000000
0000a8  6041              STR      r1,[r0,#4]
0000aa  bf00              NOP      
;;;190    
;;;191    	 i2c_set_interrupt(); //настройка NVIC
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       _ZN3I2C4TI2C17i2c_set_interruptEv ; I2C::TI2C::i2c_set_interrupt()
;;;192    
;;;193        LL_I2C_Enable( HW.If ); //Включить I2C
0000b2  69a0              LDR      r0,[r4,#0x18]
0000b4  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Enable(I2C_TypeDef*)
;;;194      }
0000b8  b007              ADD      sp,sp,#0x1c
0000ba  bd30              POP      {r4,r5,pc}
;;;195    
                          ENDP

                  |L22.188|
                          DCD      0x10b07db7
                  |L22.192|
                          DCD      0x00200411
                  |L22.196|
                          DCD      0x00900b1f

                          AREA ||i._ZN3I2C4TI2C11write_burstEPhhhh||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C11write_burstEPhhhh PROC ; I2C::TI2C::write_burst(unsigned char*, unsigned char, unsigned char, unsigned char)
;;;233    
;;;234      void TI2C::write_burst(uint8_t *DataBurst, uint8_t Size, uint8_t _StartRegAddr, uint8_t SlaveAddr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;235      {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;236        start: constexpr uint32_t DELAY_TIME_MS = 100;
000010  bf00              NOP      
                  |L23.18|
000012  f04f0964          MOV      r9,#0x64
;;;237        
;;;238        uint8_t BufSize = 0;
000016  f04f0a00          MOV      r10,#0
;;;239    	  
;;;240    		__disable_irq();
00001a  b672              CPSID    i
;;;241    		  TxBufSize     = Size; //
00001c  4814              LDR      r0,|L23.112|
00001e  7006              STRB     r6,[r0,#0]
;;;242    		  BufSize       = TxBufSize;
000020  f890a000          LDRB     r10,[r0,#0]  ; TxBufSize
;;;243    		  TxBufPtr      = DataBurst;
000024  4813              LDR      r0,|L23.116|
000026  6005              STR      r5,[r0,#0]  ; TxBufPtr
;;;244            OperationFlag = TOperation::_WRITE; //Общий флаг процесса - запись, которая начинается с записи адреса slave.
000028  2001              MOVS     r0,#1
00002a  4913              LDR      r1,|L23.120|
00002c  7008              STRB     r0,[r1,#0]
;;;245    		  StartRegAddr  = _StartRegAddr;
00002e  4813              LDR      r0,|L23.124|
000030  7007              STRB     r7,[r0,#0]
;;;246    		__enable_irq();
000032  b662              CPSIE    i
;;;247    		LL_I2C_SetTransferSize(  HW.If , 1U + BufSize );            //Количество байтов для записи
000034  f10a0101          ADD      r1,r10,#1
000038  69a0              LDR      r0,[r4,#0x18]
00003a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferSize(I2C_TypeDef*, unsigned)
;;;248        start_transfer( SlaveAddr );
00003e  4641              MOV      r1,r8
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       _ZN3I2C4TI2C14start_transferEh ; I2C::TI2C::start_transfer(unsigned char)
;;;249    		
;;;250    	  if ( xSemaphoreTake( I2C_TxSem, pdMS_TO_TICKS(DELAY_TIME_MS) ) == pdFALSE) //ждать семафор окончания отправки кадра с данными из прерывания
000046  2300              MOVS     r3,#0
000048  2264              MOVS     r2,#0x64
00004a  4619              MOV      r1,r3
00004c  480c              LDR      r0,|L23.128|
00004e  6800              LDR      r0,[r0,#0]  ; I2C_TxSem
000050  f7fffffe          BL       xQueueGenericReceive
000054  b948              CBNZ     r0,|L23.106|
;;;251    		{
;;;252          LL_I2C_Disable(  HW.If  );
000056  69a0              LDR      r0,[r4,#0x18]
000058  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Disable(I2C_TypeDef*)
;;;253          LL_I2C_ClearFlag_ARLO(  HW.If  );
00005c  69a0              LDR      r0,[r4,#0x18]
00005e  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_ARLO(I2C_TypeDef*)
;;;254          LL_I2C_Enable(  HW.If  );
000062  69a0              LDR      r0,[r4,#0x18]
000064  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Enable(I2C_TypeDef*)
;;;255          goto start;
000068  e7d3              B        |L23.18|
                  |L23.106|
;;;256    		}
;;;257      }
00006a  e8bd87f0          POP      {r4-r10,pc}
;;;258    
                          ENDP

00006e  0000              DCW      0x0000
                  |L23.112|
                          DCD      TxBufSize
                  |L23.116|
                          DCD      TxBufPtr
                  |L23.120|
                          DCD      OperationFlag
                  |L23.124|
                          DCD      StartRegAddr
                  |L23.128|
                          DCD      I2C_TxSem

                          AREA ||i._ZN3I2C4TI2C14pin_clk_configEv||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C14pin_clk_configEv PROC ; I2C::TI2C::pin_clk_config()
;;;70       
;;;71       void TI2C::pin_clk_config()
000000  b530              PUSH     {r4,r5,lr}
;;;72       {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;73         /*тактирование GPIO, к которым подключены SDA и SCL и тактирование интерфейса I2C*/
;;;74         HW.SDA.en_clk( HW.SDA.ClkPortMask);
000006  e9d40113          LDRD     r0,r1,[r4,#0x4c]
00000a  4788              BLX      r1
;;;75         HW.SCL.en_clk( HW.SCL.ClkPortMask );
00000c  e9d4010e          LDRD     r0,r1,[r4,#0x38]
000010  4788              BLX      r1
;;;76         HW.Clk.en_periph( HW.Clk.PeriphMask );
000012  e9d41008          LDRD     r1,r0,[r4,#0x20]
000016  4788              BLX      r1
;;;77         
;;;78         /* инициализация выводов с I2C */
;;;79         LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;80         do
000018  bf00              NOP      
                  |L24.26|
;;;81         {
;;;82           GPIO_InitStruct.Pin = HW.SDA.Nbr;
00001a  6ca0              LDR      r0,[r4,#0x48]
00001c  9001              STR      r0,[sp,#4]
;;;83           GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
00001e  2002              MOVS     r0,#2
000020  9002              STR      r0,[sp,#8]
;;;84           GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
000022  9003              STR      r0,[sp,#0xc]
;;;85           GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
000024  2001              MOVS     r0,#1
000026  9004              STR      r0,[sp,#0x10]
;;;86           GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
000028  2000              MOVS     r0,#0
00002a  9005              STR      r0,[sp,#0x14]
;;;87           GPIO_InitStruct.Alternate = LL_GPIO_AF_4;
00002c  2004              MOVS     r0,#4
00002e  9006              STR      r0,[sp,#0x18]
;;;88         } while ( SUCCESS != LL_GPIO_Init( HW.SDA.Gpio, &GPIO_InitStruct ) );
000030  a901              ADD      r1,sp,#4
000032  6c60              LDR      r0,[r4,#0x44]
000034  f7fffffe          BL       LL_GPIO_Init
000038  2800              CMP      r0,#0
00003a  d1ee              BNE      |L24.26|
;;;89     	  do
00003c  bf00              NOP      
                  |L24.62|
;;;90     	  {
;;;91            GPIO_InitStruct.Pin = HW.SCL.Nbr;
00003e  6b60              LDR      r0,[r4,#0x34]
000040  9001              STR      r0,[sp,#4]
;;;92     	  } while ( SUCCESS != LL_GPIO_Init( HW.SCL.Gpio, &GPIO_InitStruct ) );
000042  a901              ADD      r1,sp,#4
000044  6b20              LDR      r0,[r4,#0x30]
000046  f7fffffe          BL       LL_GPIO_Init
00004a  2800              CMP      r0,#0
00004c  d1f7              BNE      |L24.62|
;;;93         
;;;94         LL_RCC_SetI2CClockSource( HW.Clk.SrcMask ); //вырбрать источник тактирования I2C - SYSCLK
00004e  6aa0              LDR      r0,[r4,#0x28]
000050  4a07              LDR      r2,|L24.112|
000052  eb026110          ADD      r1,r2,r0,LSR #24
000056  680a              LDR      r2,[r1,#0]
000058  0c05              LSRS     r5,r0,#16
00005a  2303              MOVS     r3,#3
00005c  40ab              LSLS     r3,r3,r5
00005e  439a              BICS     r2,r2,r3
000060  b2c3              UXTB     r3,r0
000062  0c05              LSRS     r5,r0,#16
000064  40ab              LSLS     r3,r3,r5
000066  431a              ORRS     r2,r2,r3
000068  600a              STR      r2,[r1,#0]
00006a  bf00              NOP      
;;;95       }
00006c  b007              ADD      sp,sp,#0x1c
00006e  bd30              POP      {r4,r5,pc}
;;;96       
                          ENDP

                  |L24.112|
                          DCD      0x40021088

                          AREA ||i._ZN3I2C4TI2C14start_transferEh||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C14start_transferEh PROC ; I2C::TI2C::start_transfer(unsigned char)
;;;308      
;;;309      void TI2C::start_transfer(uint8_t SlaveAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;310      {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;311    		LL_I2C_DisableAutoEndMode( HW.If );                       //Software end: TC флаг устанавливается, когда было передано/принято NBYTES данных. \
000006  69a0              LDR      r0,[r4,#0x18]
000008  6841              LDR      r1,[r0,#4]
00000a  f0217100          BIC      r1,r1,#0x2000000
00000e  6041              STR      r1,[r0,#4]
000010  bf00              NOP      
;;;312    	                                                                  Растяжка SCL
;;;313    		LL_I2C_SetMasterAddressingMode( HW.If, LL_I2C_ADDRESSING_MODE_7BIT );
000012  2100              MOVS     r1,#0
000014  69a0              LDR      r0,[r4,#0x18]
000016  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c130LL_I2C_SetMasterAddressingModeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetMasterAddressingMode(I2C_TypeDef*, unsigned)
;;;314    		LL_I2C_SetSlaveAddr( HW.If, SlaveAddr << 1 ); //Конфигурирует SLAVE адрес для обмена (режим мастера). \
00001a  0069              LSLS     r1,r5,#1
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_SetSlaveAddrEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetSlaveAddr(I2C_TypeDef*, unsigned)
;;;315    														                        Нельзя изменять при установленном START бите
;;;316    //		LL_I2C_SetSlaveAddr(I2CHw.I2Cx, SlaveAddr);                  //Конфигурирует SLAVE адрес для обмена (режим мастера). \
;;;317    //														                           Нельзя изменять при установленном START бите
;;;318    	   LL_I2C_SetTransferRequest( HW.If, LL_I2C_REQUEST_WRITE ); //Кофигурирует направление обмена (в режиме мастера). \
000022  2100              MOVS     r1,#0
000024  69a0              LDR      r0,[r4,#0x18]
000026  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c125LL_I2C_SetTransferRequestEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferRequest(I2C_TypeDef*, unsigned)
;;;319    	                                                               Нельзя изменять при установленном START бите. \
;;;320    																							                   Для всех реализуемых протоколов сначала необходимо \
;;;321                                                                     записать адрес slave регистра в микросхему.
;;;322    
;;;323    		__disable_irq();
00002a  b672              CPSID    i
;;;324            IsTxSlaveRegAddr = false;                                    //Сброс программного флага перед стартом отправки, т.е. адрес регистра в slave еще не отправлен 
00002c  2000              MOVS     r0,#0
00002e  4906              LDR      r1,|L25.72|
000030  7008              STRB     r0,[r1,#0]
;;;325    		__enable_irq();
000032  b662              CPSIE    i
;;;326    		
;;;327    	   LL_I2C_GenerateStartCondition( HW.If );                   //Generate a START or RESTART condition. \
000034  69a0              LDR      r0,[r4,#0x18]
000036  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c129LL_I2C_GenerateStartConditionEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_GenerateStartCondition(I2C_TypeDef*)
;;;328    	                                                               Старт бит может быть установлен даже если шина I2C занята или I2C в slave режиме. \
;;;329    	                                                               Не влияет когда установлен RELOAD.	
;;;330    //      RelFour.off();																					
;;;331    		LL_I2C_EnableIT_TX( HW.If ); // Enable TXIS interrupt
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  6801              LDR      r1,[r0,#0]
00003e  f0410102          ORR      r1,r1,#2
000042  6001              STR      r1,[r0,#0]
000044  bf00              NOP      
;;;332      }
000046  bd70              POP      {r4-r6,pc}
;;;333      
                          ENDP

                  |L25.72|
                          DCD      IsTxSlaveRegAddr

                          AREA ||i._ZN3I2C4TI2C16read_single_byteEPhhh||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C16read_single_byteEPhhh PROC ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;258    
;;;259      void TI2C::read_single_byte(uint8_t *RxByte, uint8_t RegAddr, uint8_t SlaveAddr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;260      {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;261        start: constexpr uint32_t DELAY_TIME_MS = 100;
00000c  bf00              NOP      
                  |L26.14|
00000e  f04f0864          MOV      r8,#0x64
;;;262        
;;;263    		__disable_irq();
000012  b672              CPSID    i
;;;264    	     OperationFlag = TOperation::_READ; //Общий флаг процесса - считывание, которое начинается с записи адреса slave.
000014  2000              MOVS     r0,#0
000016  4917              LDR      r1,|L26.116|
000018  7008              STRB     r0,[r1,#0]
;;;265    		  RxBufSize     = 0x01U;             //
00001a  2001              MOVS     r0,#1
00001c  4916              LDR      r1,|L26.120|
00001e  7008              STRB     r0,[r1,#0]
;;;266    		  RxBufPtr      = RxByte;
000020  4816              LDR      r0,|L26.124|
000022  6006              STR      r6,[r0,#0]  ; RxBufPtr
;;;267    		  StartRegAddr  = RegAddr;
000024  4816              LDR      r0,|L26.128|
000026  7007              STRB     r7,[r0,#0]
;;;268    		  RxSlaveAddr   = SlaveAddr;
000028  4816              LDR      r0,|L26.132|
00002a  7005              STRB     r5,[r0,#0]
;;;269    		  RxByteCtr     = 0U;
00002c  2000              MOVS     r0,#0
00002e  4916              LDR      r1,|L26.136|
000030  7008              STRB     r0,[r1,#0]
;;;270    		__enable_irq();
000032  b662              CPSIE    i
;;;271        
;;;272    		LL_I2C_SetTransferSize(  HW.If , 1U );            //Количество байтов для записи
000034  2101              MOVS     r1,#1
000036  69a0              LDR      r0,[r4,#0x18]
000038  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferSize(I2C_TypeDef*, unsigned)
;;;273        start_transfer( SlaveAddr );
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       _ZN3I2C4TI2C14start_transferEh ; I2C::TI2C::start_transfer(unsigned char)
;;;274        uint32_t HeapSize = xPortGetFreeHeapSize();
000044  f7fffffe          BL       xPortGetFreeHeapSize
000048  4681              MOV      r9,r0
;;;275    		
;;;276    	  if ( xSemaphoreTake( I2C_RxSem, pdMS_TO_TICKS(DELAY_TIME_MS) ) == pdFALSE ) //ждать семафор окончания приема байта с данными из прерывания
00004a  2300              MOVS     r3,#0
00004c  2264              MOVS     r2,#0x64
00004e  4619              MOV      r1,r3
000050  480e              LDR      r0,|L26.140|
000052  6800              LDR      r0,[r0,#0]  ; I2C_RxSem
000054  f7fffffe          BL       xQueueGenericReceive
000058  b948              CBNZ     r0,|L26.110|
;;;277    		{
;;;278          LL_I2C_Disable( HW.If );
00005a  69a0              LDR      r0,[r4,#0x18]
00005c  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Disable(I2C_TypeDef*)
;;;279          LL_I2C_ClearFlag_ARLO( HW.If );
000060  69a0              LDR      r0,[r4,#0x18]
000062  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_ARLO(I2C_TypeDef*)
;;;280          LL_I2C_Enable( HW.If );
000066  69a0              LDR      r0,[r4,#0x18]
000068  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Enable(I2C_TypeDef*)
;;;281          goto start;
00006c  e7cf              B        |L26.14|
                  |L26.110|
;;;282    		}
;;;283      }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;284      
                          ENDP

000072  0000              DCW      0x0000
                  |L26.116|
                          DCD      OperationFlag
                  |L26.120|
                          DCD      RxBufSize
                  |L26.124|
                          DCD      RxBufPtr
                  |L26.128|
                          DCD      StartRegAddr
                  |L26.132|
                          DCD      RxSlaveAddr
                  |L26.136|
                          DCD      RxByteCtr
                  |L26.140|
                          DCD      I2C_RxSem

                          AREA ||i._ZN3I2C4TI2C17i2c_set_interruptEv||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C17i2c_set_interruptEv PROC ; I2C::TI2C::i2c_set_interrupt()
;;;195    
;;;196      void TI2C::i2c_set_interrupt()
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;197      {
000004  4604              MOV      r4,r0
;;;198        // Настройка NVIC
;;;199        NVIC_SetPriority(
000006  f994101c          LDRSB    r1,[r4,#0x1c]
00000a  4b28              LDR      r3,|L27.172|
00000c  681b              LDR      r3,[r3,#0]
00000e  f3c32002          UBFX     r0,r3,#8,#3
000012  2505              MOVS     r5,#5
000014  2600              MOVS     r6,#0
000016  4603              MOV      r3,r0
000018  f1c30807          RSB      r8,r3,#7
00001c  f1b80f04          CMP      r8,#4
000020  d902              BLS      |L27.40|
000022  f04f0804          MOV      r8,#4
000026  e001              B        |L27.44|
                  |L27.40|
000028  f1c30807          RSB      r8,r3,#7
                  |L27.44|
00002c  46c4              MOV      r12,r8
00002e  f1030804          ADD      r8,r3,#4
000032  f1b80f07          CMP      r8,#7
000036  d202              BCS      |L27.62|
000038  f04f0800          MOV      r8,#0
00003c  e001              B        |L27.66|
                  |L27.62|
00003e  f1a30803          SUB      r8,r3,#3
                  |L27.66|
000042  4647              MOV      r7,r8
000044  f04f0801          MOV      r8,#1
000048  fa08f80c          LSL      r8,r8,r12
00004c  f1a80801          SUB      r8,r8,#1
000050  ea080805          AND      r8,r8,r5
000054  fa08f807          LSL      r8,r8,r7
000058  f04f0901          MOV      r9,#1
00005c  fa09f907          LSL      r9,r9,r7
000060  f1a90901          SUB      r9,r9,#1
000064  ea090906          AND      r9,r9,r6
000068  ea480209          ORR      r2,r8,r9
00006c  bf00              NOP      
00006e  2900              CMP      r1,#0
000070  da08              BGE      |L27.132|
000072  0710              LSLS     r0,r2,#28
000074  0e05              LSRS     r5,r0,#24
000076  480d              LDR      r0,|L27.172|
000078  300c              ADDS     r0,r0,#0xc
00007a  f001030f          AND      r3,r1,#0xf
00007e  1f1b              SUBS     r3,r3,#4
000080  54c5              STRB     r5,[r0,r3]
000082  e003              B        |L27.140|
                  |L27.132|
000084  0710              LSLS     r0,r2,#28
000086  0e03              LSRS     r3,r0,#24
000088  4809              LDR      r0,|L27.176|
00008a  5443              STRB     r3,[r0,r1]
                  |L27.140|
00008c  bf00              NOP      
;;;200                         HW.Ev_IRQ, 
;;;201                         NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 5, 0)
;;;202                        );                                                     //обработчик вызывает API функцию RTOS => приоритет д.б. \
;;;203                                                                                 логически ниже или равен, но численно больше или равен,\
;;;204                                                                                 установленному  в макросе \
;;;205                                                                                 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
;;;206        NVIC_EnableIRQ(HW.Ev_IRQ);
00008e  f994001c          LDRSB    r0,[r4,#0x1c]
000092  f000021f          AND      r2,r0,#0x1f
000096  2101              MOVS     r1,#1
000098  4091              LSLS     r1,r1,r2
00009a  0942              LSRS     r2,r0,#5
00009c  0092              LSLS     r2,r2,#2
00009e  f10222e0          ADD      r2,r2,#0xe000e000
0000a2  f8c21100          STR      r1,[r2,#0x100]
0000a6  bf00              NOP      
;;;207      }  
0000a8  e8bd83f0          POP      {r4-r9,pc}
;;;208        
                          ENDP

                  |L27.172|
                          DCD      0xe000ed0c
                  |L27.176|
                          DCD      0xe000e400

                          AREA ||i._ZN3I2C4TI2C17write_single_byteEPhhh||, CODE, READONLY, ALIGN=2

                  _ZN3I2C4TI2C17write_single_byteEPhhh PROC ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;208        
;;;209      void TI2C::write_single_byte(uint8_t *TxByte, uint8_t _RegAddr, uint8_t SlaveAddr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;210      {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;211        start: constexpr uint32_t DELAY_TIME_MS = 100;
00000c  bf00              NOP      
                  |L28.14|
00000e  f04f0864          MOV      r8,#0x64
;;;212        uint8_t BufSize = 0;
000012  f04f0900          MOV      r9,#0
;;;213    	 	  
;;;214    		__disable_irq();
000016  b672              CPSID    i
;;;215          TxBufSize     = 0x01U;
000018  2001              MOVS     r0,#1
00001a  4915              LDR      r1,|L28.112|
00001c  7008              STRB     r0,[r1,#0]
;;;216    		  BufSize       = TxBufSize;
00001e  4608              MOV      r0,r1
000020  f8909000          LDRB     r9,[r0,#0]  ; TxBufSize
;;;217          TxBufPtr      = TxByte;
000024  4813              LDR      r0,|L28.116|
000026  6005              STR      r5,[r0,#0]  ; TxBufPtr
;;;218          OperationFlag = TOperation::_WRITE; //Общий флаг процесса - запись, которая начинается с записи адреса slave.    
000028  2001              MOVS     r0,#1
00002a  4913              LDR      r1,|L28.120|
00002c  7008              STRB     r0,[r1,#0]
;;;219    		  StartRegAddr  = _RegAddr;
00002e  4813              LDR      r0,|L28.124|
000030  7006              STRB     r6,[r0,#0]
;;;220        __enable_irq();
000032  b662              CPSIE    i
;;;221    		LL_I2C_SetTransferSize(  HW.If, 1U + BufSize ); //Количество байтов для записи
000034  f1090101          ADD      r1,r9,#1
000038  69a0              LDR      r0,[r4,#0x18]
00003a  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj ; [local to I2C_driver_cpp]::LL_I2C_SetTransferSize(I2C_TypeDef*, unsigned)
;;;222        start_transfer( SlaveAddr );
00003e  4639              MOV      r1,r7
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       _ZN3I2C4TI2C14start_transferEh ; I2C::TI2C::start_transfer(unsigned char)
;;;223    		
;;;224        if ( xSemaphoreTake( I2C_TxSem, pdMS_TO_TICKS(DELAY_TIME_MS) ) == pdFALSE) //ждать семафор окончания отправки байта из прерывания
000046  2300              MOVS     r3,#0
000048  2264              MOVS     r2,#0x64
00004a  4619              MOV      r1,r3
00004c  480c              LDR      r0,|L28.128|
00004e  6800              LDR      r0,[r0,#0]  ; I2C_TxSem
000050  f7fffffe          BL       xQueueGenericReceive
000054  b948              CBNZ     r0,|L28.106|
;;;225    		{
;;;226          LL_I2C_Disable(  HW.If  );
000056  69a0              LDR      r0,[r4,#0x18]
000058  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Disable(I2C_TypeDef*)
;;;227          LL_I2C_ClearFlag_ARLO(  HW.If  );
00005c  69a0              LDR      r0,[r4,#0x18]
00005e  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_ClearFlag_ARLO(I2C_TypeDef*)
;;;228          LL_I2C_Enable(  HW.If  );
000062  69a0              LDR      r0,[r4,#0x18]
000064  f7fffffe          BL       _ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef ; [local to I2C_driver_cpp]::LL_I2C_Enable(I2C_TypeDef*)
;;;229          goto start;
000068  e7d1              B        |L28.14|
                  |L28.106|
;;;230    		}
;;;231    	  
;;;232      }
00006a  e8bd87f0          POP      {r4-r10,pc}
;;;233    
                          ENDP

00006e  0000              DCW      0x0000
                  |L28.112|
                          DCD      TxBufSize
                  |L28.116|
                          DCD      TxBufPtr
                  |L28.120|
                          DCD      OperationFlag
                  |L28.124|
                          DCD      StartRegAddr
                  |L28.128|
                          DCD      I2C_TxSem

                          AREA ||i._ZN3I2C4TI2CC1ERK7TI2C_HWNS_5TModeENS_5TRateENS_11TAddressingE||, CODE, READONLY, ALIGN=1

                  _ZN3I2C4TI2CC2ERK7TI2C_HWNS_5TModeENS_5TRateENS_11TAddressingE                  ; Alternate entry point ; I2C::TI2C::TI2C__sub_object(const TI2C_HW&, I2C::TMode, I2C::TRate, I2C::TAddressing)
                  _ZN3I2C4TI2CC1ERK7TI2C_HWNS_5TModeENS_5TRateENS_11TAddressingE PROC ; I2C::TI2C::TI2C(const TI2C_HW&, I2C::TMode, I2C::TRate, I2C::TAddressing)
;;;37     
;;;38       TI2C::TI2C(
;;;39                  const TI2C_HW &_HW,             
;;;40                  TMode _Mode, 
;;;41                  TRate _Rate, 
;;;42                  TAddressing _Addressing
;;;43                 ) 
;;;44       :
;;;45       HW( _HW ),
;;;46       Mode( _Mode ),
;;;47       Rate( _Rate ),
;;;48     	Addressing( _Addressing )
;;;49       {
;;;50     	  SlaveRegAddr = 0x00;
;;;51     	  TransferSize = 0x00;
;;;52     	  Addr         = 0x00;
;;;53     	 
;;;54     //	 for (auto item : Gpio)
;;;55     //	 {
;;;56     //	   if (I2Cx == item.I2Cx)
;;;57     //      {
;;;58     //		  I2CHw = item;
;;;59     //		  break;
;;;60     //		}		
;;;61     //	 }
;;;62     	 	 
;;;63       }
;;;64     
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
000010  2274              MOVS     r2,#0x74
000012  4639              MOV      r1,r7
000014  f1040018          ADD      r0,r4,#0x18
000018  f7fffffe          BL       __aeabi_memcpy4
00001c  f884508c          STRB     r5,[r4,#0x8c]
000020  f884608d          STRB     r6,[r4,#0x8d]
000024  f884808e          STRB     r8,[r4,#0x8e]
000028  2000              MOVS     r0,#0
00002a  7060              STRB     r0,[r4,#1]
00002c  70a0              STRB     r0,[r4,#2]
00002e  7020              STRB     r0,[r4,#0]
000030  4620              MOV      r0,r4
000032  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i._ZN3I2C4TI2CD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN3I2C4TI2CD2Ev                  ; Alternate entry point ; I2C::TI2C::~TI2C__sub_object()
                  _ZN3I2C4TI2CD1Ev PROC ; I2C::TI2C::~TI2C()
;;;64     
;;;65       TI2C::~TI2C()
;;;66       {
;;;67     
;;;68       }
;;;69       
000000  4770              BX       lr
                          ENDP


                          AREA ||i._ZNK3I2C4TI2C12get_i2c_signEv||, CODE, READONLY, ALIGN=2

                  _ZNK3I2C4TI2C12get_i2c_signEv PROC ; I2C::TI2C::get_i2c_sign() const
;;;333      
;;;334      const char *TI2C::get_i2c_sign() const
000000  4601              MOV      r1,r0
;;;335      {
;;;336        return "I2C1";
000002  a001              ADR      r0,|L31.8|
;;;337      }
000004  4770              BX       lr
;;;338    }
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
000008  49324331          DCB      "I2C1",0
00000c  00      
00000d  00                DCB      0
00000e  00                DCB      0
00000f  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||i.I2C1_EV_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.I2C1_EV_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i.I2C1_ER_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.I2C1_ER_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i.I2C2_EV_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.I2C2_EV_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i.I2C2_ER_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.I2C2_ER_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN3I2C4TI2CC1ERK7TI2C_HWNS_5TModeENS_5TRateENS_11TAddressingE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2CC1ERK7TI2C_HWNS_5TModeENS_5TRateENS_11TAddressingE||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZN3I2C4TI2CD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2CD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZNK3I2C4TI2C12get_i2c_signEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK3I2C4TI2C12get_i2c_signEv||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN3I2C4TI2C14pin_clk_configEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C14pin_clk_configEv||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN3I2C4TI2C17i2c_set_interruptEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C17i2c_set_interruptEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN3I2C4TI2C11i2c_hw_initEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C11i2c_hw_initEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN3I2C4TI2C14start_transferEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C14start_transferEh||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN3I2C4TI2C17write_single_byteEPhhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C17write_single_byteEPhhh||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN3I2C4TI2C11write_burstEPhhhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C11write_burstEPhhhh||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN3I2C4TI2C16read_single_byteEPhhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C16read_single_byteEPhhh||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN3I2C4TI2C10read_burstEPhhhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN3I2C4TI2C10read_burstEPhhhh||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113LL_I2C_EnableEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c114LL_I2C_DisableEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c130LL_I2C_SetMasterAddressingModeEP11I2C_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c130LL_I2C_SetMasterAddressingModeEP11I2C_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_ARLOEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c122LL_I2C_SetTransferSizeEP11I2C_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c129LL_I2C_GenerateStartConditionEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c129LL_I2C_GenerateStartConditionEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c125LL_I2C_SetTransferRequestEP11I2C_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c125LL_I2C_SetTransferRequestEP11I2C_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_SetSlaveAddrEP11I2C_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_SetSlaveAddrEP11I2C_TypeDefj||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_txis_activeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_txis_activeEv||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_rxne_activeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_rxne_activeEv||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_stop_activeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c115dks_stop_activeEv||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113dks_tc_activeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c113dks_tc_activeEv||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TXEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TXEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TCEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c119LL_I2C_DisableIT_TCEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_STOPEP11I2C_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c121LL_I2C_ClearFlag_STOPEP11I2C_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c120LL_I2C_TransmitData8EP11I2C_TypeDefh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c120LL_I2C_TransmitData8EP11I2C_TypeDefh||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  TxBufPtr
                          DCD      0x00000000
                  TxBufSize
000004  00                DCB      0x00
                  IsTxSlaveRegAddr
000005  000000            DCB      0x00,0x00,0x00
                  TxHigherPriorityTaskWoken
                          DCD      0x00000000
                  RxBufPtr
                          DCD      0x00000000
                  RxBufSize
000010  00                DCB      0x00
                  RxByteCtr
000011  00                DCB      0x00
                  RxSlaveAddr
000012  0000              DCB      0x00,0x00
                  RxHigherPriorityTaskWoken
                          DCD      0x00000000
                  OperationFlag
000018  00                DCB      0x00
                  StartRegAddr
000019  00                DCB      0x00
                  _ZN3I2C4TI2C13SlaveAddrFlagE ; I2C::TI2C::SlaveAddrFlag
00001a  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "Source\\MCU_Drivers\\src\\I2C_driver.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_I2C_driver_cpp_0101a1c1___ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c17__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___14_I2C_driver_cpp_0101a1c1___ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c17__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_I2C_driver_cpp_0101a1c1___ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c17__REVSHEi|
#line 402
|__asm___14_I2C_driver_cpp_0101a1c1___ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c17__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_I2C_driver_cpp_0101a1c1___ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c15__RRXEj|
#line 587
|__asm___14_I2C_driver_cpp_0101a1c1___ZN36_INTERNAL_14_I2C_driver_cpp_0101a1c15__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
