; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\modbus_app.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\modbus_app.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\modbus_app.crf Source\Protocols\src\modbus_app.cpp]
                          THUMB

                          AREA ||i._ZN10TModbusApp11chk_new_valEtNS_7TMbFnctE||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp11chk_new_valEtNS_7TMbFnctE PROC ; TModbusApp::chk_new_val(unsigned short, TModbusApp::TMbFnct)
;;;1328   
;;;1329   bool TModbusApp::chk_new_val( uint16_t NewVal, TMbFnct MbFnct )
000000  b508              PUSH     {r3,lr}
;;;1330   {
000002  4603              MOV      r3,r0
;;;1331     struct TRange
;;;1332     {
;;;1333       uint16_t MIN;
;;;1334       uint16_t MAX;
;;;1335     };
;;;1336     
;;;1337     TRange Range = { 0U, 0U };
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1338     
;;;1339     switch ( MbFnct )
000008  2a05              CMP      r2,#5
00000a  d004              BEQ      |L1.22|
00000c  2a06              CMP      r2,#6
00000e  d015              BEQ      |L1.60|
000010  2a10              CMP      r2,#0x10
000012  d138              BNE      |L1.134|
000014  e025              B        |L1.98|
                  |L1.22|
;;;1340     {
;;;1341       case TMbFnct::__WRITE_SINGLE_COIL:
;;;1342            Range.MIN = 0x0000;
000016  2000              MOVS     r0,#0
000018  f8ad0000          STRH     r0,[sp,#0]
;;;1343            Range.MAX = 0xFF00;
00001c  f44f407f          MOV      r0,#0xff00
000020  f8ad0002          STRH     r0,[sp,#2]
;;;1344            return ( 
000024  f8bd0000          LDRH     r0,[sp,#0]
000028  4288              CMP      r0,r1
00002a  d003              BEQ      |L1.52|
;;;1345                    NewVal == Range.MIN
;;;1346                    ||
;;;1347                    NewVal == Range.MAX
00002c  f8bd0002          LDRH     r0,[sp,#2]
000030  4288              CMP      r0,r1
000032  d101              BNE      |L1.56|
                  |L1.52|
000034  2001              MOVS     r0,#1                 ;1344
                  |L1.54|
;;;1348                   );
;;;1349       case TMbFnct::__WRITE_SINGLE_REGISTER:
;;;1350            Range.MIN = 0x0000;
;;;1351            Range.MAX = 0xFFFF;
;;;1352            return ( 
;;;1353                    NewVal >= Range.MIN
;;;1354                    &&
;;;1355                    NewVal <= Range.MAX
;;;1356                   );
;;;1357       case TMbFnct::__WRITE_MULTIPLE_REGISTERS:
;;;1358            Range.MIN = 0x0001;
;;;1359            Range.MAX = 0x007B;
;;;1360            return ( 
;;;1361                    NewVal >= Range.MIN
;;;1362                    &&
;;;1363                    NewVal <= Range.MAX
;;;1364                   );
;;;1365       default:
;;;1366            return false;
;;;1367     }
;;;1368   }
000036  bd08              POP      {r3,pc}
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;1344
00003a  e7fc              B        |L1.54|
                  |L1.60|
00003c  2000              MOVS     r0,#0                 ;1350
00003e  f8ad0000          STRH     r0,[sp,#0]            ;1350
000042  f64f70ff          MOV      r0,#0xffff            ;1351
000046  f8ad0002          STRH     r0,[sp,#2]            ;1351
00004a  f8bd0000          LDRH     r0,[sp,#0]            ;1352
00004e  4288              CMP      r0,r1                 ;1352
000050  dc05              BGT      |L1.94|
000052  f8bd0002          LDRH     r0,[sp,#2]            ;1355
000056  4288              CMP      r0,r1                 ;1355
000058  db01              BLT      |L1.94|
00005a  2001              MOVS     r0,#1                 ;1352
00005c  e7eb              B        |L1.54|
                  |L1.94|
00005e  2000              MOVS     r0,#0                 ;1352
000060  e7e9              B        |L1.54|
                  |L1.98|
000062  2001              MOVS     r0,#1                 ;1358
000064  f8ad0000          STRH     r0,[sp,#0]            ;1358
000068  207b              MOVS     r0,#0x7b              ;1359
00006a  f8ad0002          STRH     r0,[sp,#2]            ;1359
00006e  f8bd0000          LDRH     r0,[sp,#0]            ;1360
000072  4288              CMP      r0,r1                 ;1360
000074  dc05              BGT      |L1.130|
000076  f8bd0002          LDRH     r0,[sp,#2]            ;1363
00007a  4288              CMP      r0,r1                 ;1363
00007c  db01              BLT      |L1.130|
00007e  2001              MOVS     r0,#1                 ;1360
000080  e7d9              B        |L1.54|
                  |L1.130|
000082  2000              MOVS     r0,#0                 ;1360
000084  e7d7              B        |L1.54|
                  |L1.134|
000086  2000              MOVS     r0,#0                 ;1366
000088  e7d5              B        |L1.54|
;;;1369   
                          ENDP


                          AREA ||i._ZN10TModbusApp11cmp_if_setsEv||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp11cmp_if_setsEv PROC ; TModbusApp::cmp_if_sets()
;;;1369   
;;;1370   void TModbusApp::cmp_if_sets()
000000  b570              PUSH     {r4-r6,lr}
;;;1371   {
000002  b098              SUB      sp,sp,#0x60
000004  4605              MOV      r5,r0
;;;1372     TUsart::TSets Sets = get_sets();
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       _ZNK6TUsart8get_setsEv ; TUsart::get_sets() const
00000c  e9d01200          LDRD     r1,r2,[r0,#0]
000010  6880              LDR      r0,[r0,#8]
000012  e9cd1215          STRD     r1,r2,[sp,#0x54]
000016  9017              STR      r0,[sp,#0x5c]
;;;1373     
;;;1374     TBaudRate BaudRate[] =
000018  2228              MOVS     r2,#0x28
00001a  491a              LDR      r1,|L2.132|
00001c  a80b              ADD      r0,sp,#0x2c
00001e  f7fffffe          BL       __aeabi_memcpy4
;;;1375     {
;;;1376       TBaudRate::_1200,   //0
;;;1377       TBaudRate::_2400,   //1
;;;1378       TBaudRate::_4800,   //2
;;;1379       TBaudRate::_9600,   //3
;;;1380       TBaudRate::_14400,  //4
;;;1381       TBaudRate::_19200,  //5 - настройка по умолчанию
;;;1382       TBaudRate::_38400,  //6
;;;1383       TBaudRate::_56000,  //7
;;;1384       TBaudRate::_57600,  //8
;;;1385       TBaudRate::_115200, //9
;;;1386     };
;;;1387   
;;;1388     struct TParityAndStops
;;;1389     {
;;;1390       TParity Parity;
;;;1391       TStops  Stops;
;;;1392     };
;;;1393   
;;;1394     TParityAndStops ParityAndStops[] =
000022  2220              MOVS     r2,#0x20
000024  4917              LDR      r1,|L2.132|
000026  3128              ADDS     r1,r1,#0x28
000028  a803              ADD      r0,sp,#0xc
00002a  f7fffffe          BL       __aeabi_memcpy4
;;;1395     {
;;;1396       { TUsart::TParity::_NONE, TUsart::TStops::_STOPBITS_1 }, //0
;;;1397       { TUsart::TParity::_NONE, TUsart::TStops::_STOPBITS_2 }, //1
;;;1398       { TUsart::TParity::_ODD,  TUsart::TStops::_STOPBITS_1 }, //2
;;;1399       { TUsart::TParity::_EVEN, TUsart::TStops::_STOPBITS_1 }, //3 - настройка по умолчанию
;;;1400     };
;;;1401     
;;;1402     TBaudRate       BR = BaudRate[ Model.get_u_baud_rate() ];
00002e  4816              LDR      r0,|L2.136|
000030  f7fffffe          BL       _ZN6TModel15get_u_baud_rateEv ; TModel::get_u_baud_rate()
000034  a90b              ADD      r1,sp,#0x2c
000036  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;1403     TParityAndStops PS = ParityAndStops[ Model.get_u_par() ];
00003a  4813              LDR      r0,|L2.136|
00003c  f7fffffe          BL       _ZN6TModel9get_u_parEv ; TModel::get_u_par()
000040  a903              ADD      r1,sp,#0xc
000042  eb0101c0          ADD      r1,r1,r0,LSL #3
000046  c903              LDM      r1,{r0,r1}
000048  e9cd0101          STRD     r0,r1,[sp,#4]
;;;1404     
;;;1405     bool ChngFlag = false;
00004c  2600              MOVS     r6,#0
;;;1406     
;;;1407     if ( BR != Sets.BaudRate )
00004e  9815              LDR      r0,[sp,#0x54]
000050  42a0              CMP      r0,r4
000052  d001              BEQ      |L2.88|
;;;1408     {
;;;1409       Sets.BaudRate = BR;
000054  9415              STR      r4,[sp,#0x54]
;;;1410       ChngFlag      = true;
000056  2601              MOVS     r6,#1
                  |L2.88|
;;;1411     }
;;;1412     if ( PS.Parity != Sets.Parity )
000058  9916              LDR      r1,[sp,#0x58]
00005a  9801              LDR      r0,[sp,#4]
00005c  4288              CMP      r0,r1
00005e  d002              BEQ      |L2.102|
;;;1413     {
;;;1414       Sets.Parity = PS.Parity;
000060  9801              LDR      r0,[sp,#4]
000062  9016              STR      r0,[sp,#0x58]
;;;1415       ChngFlag    = true;
000064  2601              MOVS     r6,#1
                  |L2.102|
;;;1416     }
;;;1417     if ( PS.Stops != Sets.Stops )
000066  9917              LDR      r1,[sp,#0x5c]
000068  9802              LDR      r0,[sp,#8]
00006a  4288              CMP      r0,r1
00006c  d002              BEQ      |L2.116|
;;;1418     {
;;;1419       Sets.Stops = PS.Stops;
00006e  9802              LDR      r0,[sp,#8]
000070  9017              STR      r0,[sp,#0x5c]
;;;1420       ChngFlag   = true;
000072  2601              MOVS     r6,#1
                  |L2.116|
;;;1421     }
;;;1422     
;;;1423     if ( ChngFlag == true )
000074  2e01              CMP      r6,#1
000076  d103              BNE      |L2.128|
;;;1424     {
;;;1425       set_sets( Sets );
000078  a915              ADD      r1,sp,#0x54
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       _ZN6TUsart8set_setsERKNS_5TSetsE ; TUsart::set_sets(const TUsart::TSets&)
                  |L2.128|
;;;1426       //по флагу TCIF=1 в DMA_ISR: \
;;;1427         отключить USART \
;;;1428         вызвать функцию hw_init();
;;;1429     }  
;;;1430   }
000080  b018              ADD      sp,sp,#0x60
000082  bd70              POP      {r4-r6,pc}
;;;1431   
                          ENDP

                  |L2.132|
                          DCD      ||.constdata||+0x28
                  |L2.136|
                          DCD      Model

                          AREA ||i._ZN10TModbusApp11s_boot_modeEPht||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp11s_boot_modeEPht PROC ; TModbusApp::s_boot_mode(unsigned char*, unsigned short)
;;;723    
;;;724    void TModbusApp::s_boot_mode( uint8_t *Buf, uint16_t BUF_SIZE ) // 100
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;725    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4692              MOV      r10,r2
;;;726      __packed struct TReqPkt
;;;727    	{
;;;728        uint8_t  Addr;
;;;729        uint8_t  FnctCode;
;;;730        uint8_t  ByteCnt;
;;;731        uint8_t  Msg[sizeof TDevHandlers::__BOOT_MODE - 1];
;;;732        uint16_t Crc;
;;;733    	};
;;;734      
;;;735      TReqPkt *Pkt = ( TReqPkt * )Buf;
00000a  462e              MOV      r6,r5
;;;736      
;;;737      auto beg_r = reinterpret_cast<uint8_t *>(&Pkt->Msg);
00000c  1cf7              ADDS     r7,r6,#3
;;;738      auto end_r = reinterpret_cast<uint8_t *>(&Pkt->Crc);
00000e  f106080c          ADD      r8,r6,#0xc
;;;739      
;;;740      auto beg_t = &TDevHandlers::__BOOT_MODE[0U];
000012  f504790f          ADD      r9,r4,#0x23c
;;;741      
;;;742      static int16_t Determ = 0U;
;;;743      
;;;744      if ( std::equal( beg_r, end_r, beg_t ) ) //возвращает true, если элементы одинаковы в двух диапазонах
000016  464a              MOV      r2,r9
000018  4641              MOV      r1,r8
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       _ZSt5equalIPhPKcEbT_S3_T0_ ; bool std::equal<unsigned char*, const char*>(T1, T1, T2)
000020  b340              CBZ      r0,|L3.116|
;;;745      {
;;;746        //определен пакет с командой на обновление прошивки
;;;747        ++Determ;
000022  481d              LDR      r0,|L3.152|
000024  8800              LDRH     r0,[r0,#0]  ; _ZZN10TModbusApp11s_boot_modeEPhtE6Determ
000026  1c40              ADDS     r0,r0,#1
000028  b200              SXTH     r0,r0
00002a  491b              LDR      r1,|L3.152|
00002c  8008              STRH     r0,[r1,#0]
;;;748        Model.set_boot_mode_flag( TModel::TBootModeFlag::__BOOT_MODE ); //
00002e  f24a515a          MOV      r1,#0xa55a
000032  481a              LDR      r0,|L3.156|
000034  f7fffffe          BL       _ZN6TModel18set_boot_mode_flagEN9TSettings13TBootModeFlagE ; TModel::set_boot_mode_flag(TSettings::TBootModeFlag)
;;;749        NVIC_SystemReset();  //сброс
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  bf00              NOP      
000040  bf00              NOP      
000042  f3bf8f4f          DSB      
000046  bf00              NOP      
000048  bf00              NOP      
00004a  bf00              NOP      
00004c  4814              LDR      r0,|L3.160|
00004e  6800              LDR      r0,[r0,#0]
000050  f40060e0          AND      r0,r0,#0x700
000054  4913              LDR      r1,|L3.164|
000056  4308              ORRS     r0,r0,r1
000058  1d00              ADDS     r0,r0,#4
00005a  4911              LDR      r1,|L3.160|
00005c  6008              STR      r0,[r1,#0]
00005e  bf00              NOP      
000060  bf00              NOP      
000062  bf00              NOP      
000064  f3bf8f4f          DSB      
000068  bf00              NOP      
00006a  bf00              NOP      
00006c  bf00              NOP      
00006e  bf00              NOP      
                  |L3.112|
000070  bf00              NOP      
000072  e7fd              B        |L3.112|
                  |L3.116|
;;;750      }
;;;751      else
;;;752      {
;;;753        //пакет с командой на обновление прошивки не определен
;;;754        --Determ;
000074  4808              LDR      r0,|L3.152|
000076  8800              LDRH     r0,[r0,#0]  ; _ZZN10TModbusApp11s_boot_modeEPhtE6Determ
000078  1e40              SUBS     r0,r0,#1
00007a  b200              SXTH     r0,r0
00007c  4906              LDR      r1,|L3.152|
00007e  8008              STRH     r0,[r1,#0]
;;;755      }
;;;756      
;;;757      set_eof( StrIx, ProcType, false ); //на пакет с командой обновления прошивки отвечать не нужно
000080  f8941234          LDRB     r1,[r4,#0x234]
000084  f8940227          LDRB     r0,[r4,#0x227]
000088  2200              MOVS     r2,#0
00008a  f7fffffe          BL       _Z7set_eofhN11TModbusLink9TProcTypeEb ; set_eof(unsigned char, TModbusLink::TProcType, bool)
;;;758    	State = TState::__IDLE;
00008e  2000              MOVS     r0,#0
000090  f8840230          STRB     r0,[r4,#0x230]
;;;759    }
000094  e8bd87f0          POP      {r4-r10,pc}
;;;760    //----------------------------------------------------------
                          ENDP

                  |L3.152|
                          DCD      _ZZN10TModbusApp11s_boot_modeEPhtE6Determ ; TModbusApp::s_boot_mode(unsigned char*, unsigned short)::Determ
                  |L3.156|
                          DCD      Model
                  |L3.160|
                          DCD      0xe000ed0c
                  |L3.164|
                          DCD      0x05fa0000

                          AREA ||i._ZN10TModbusApp12s_read_coilsEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp12s_read_coilsEPht PROC ; TModbusApp::s_read_coils(unsigned char*, unsigned short)
;;;651    //----- обработчики функций протокола для слейва -----------
;;;652    void TModbusApp::s_read_coils( uint8_t *Buf, uint16_t BUF_SIZE ) //1
000000  b570              PUSH     {r4-r6,lr}
;;;653    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;654      read_bits( Buf, BUF_SIZE, TMbFnct::__READ_COILS );
000008  2301              MOVS     r3,#1
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp9read_bitsEPhtNS_7TMbFnctE ; TModbusApp::read_bits(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;655    }
000014  bd70              POP      {r4-r6,pc}
;;;656      
                          ENDP


                          AREA ||i._ZN10TModbusApp12write_singleEPhtNS_7TMbFnctE||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp12write_singleEPhtNS_7TMbFnctE PROC ; TModbusApp::write_single(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;1043   
;;;1044   void TModbusApp::write_single( uint8_t *Buf, uint16_t BUF_SIZE, TMbFnct MbFnct )
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1045   {
000004  b08b              SUB      sp,sp,#0x2c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
00000c  4698              MOV      r8,r3
;;;1046   	
;;;1047   //    Do.closed();
;;;1048     /*
;;;1049   	Buf[0] - адрес
;;;1050   	Buf[1] - код функции
;;;1051   	Buf[2] - адрес катушки/регистра (Hi)
;;;1052   	Buf[3] - адрес катушки/регистра (Lo)
;;;1053   	Buf[4] - новое состояние катушки/значение регистра (Hi)
;;;1054   	Buf[5] - новое состояние катушки/значение регистра (Lo)
;;;1055   	Buf[6] - CRC (Lo)
;;;1056   	Buf[7] - CRC (Hi)
;;;1057   	*/
;;;1058     auto beg = &PduHandler->Buf[ 0 ];
00000e  f8d50238          LDR      r0,[r5,#0x238]
000012  6800              LDR      r0,[r0,#0]
000014  9009              STR      r0,[sp,#0x24]
;;;1059   	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000016  f8d50238          LDR      r0,[r5,#0x238]
00001a  6800              LDR      r0,[r0,#0]
00001c  f8d51238          LDR      r1,[r5,#0x238]
000020  8889              LDRH     r1,[r1,#4]
000022  eb001001          ADD      r0,r0,r1,LSL #4
000026  9008              STR      r0,[sp,#0x20]
;;;1060   	
;;;1061   	struct TWriteSinglePkt
;;;1062   	{
;;;1063   		uint8_t Addr;
;;;1064   		uint8_t FnctCode;
;;;1065   		union
;;;1066   		{
;;;1067   			struct
;;;1068   			{
;;;1069   				uint8_t Hi;
;;;1070   				uint8_t Lo;
;;;1071   			} Part;
;;;1072   			uint16_t Data;
;;;1073   		} RegAddr;
;;;1074   		union
;;;1075   		{
;;;1076   			struct
;;;1077   			{
;;;1078   				uint8_t Hi;
;;;1079   				uint8_t Lo;
;;;1080   			} Part;
;;;1081   			uint16_t Data;
;;;1082   		} RegVal;
;;;1083   		union
;;;1084   		{
;;;1085   			struct
;;;1086   			{
;;;1087   				uint8_t Lo;
;;;1088   				uint8_t Hi;
;;;1089   			} Part;
;;;1090   			uint16_t Data;
;;;1091   		} Crc;			
;;;1092   	};
;;;1093   	
;;;1094   	const TWriteSinglePkt *WriteSinglePkt = reinterpret_cast<const TWriteSinglePkt *>(Buf);
000028  4627              MOV      r7,r4
;;;1095     uint16_t RegAddr = WriteSinglePkt->RegAddr.Part.Lo + ( WriteSinglePkt->RegAddr.Part.Hi << 8U );
00002a  78f8              LDRB     r0,[r7,#3]
00002c  78b9              LDRB     r1,[r7,#2]
00002e  eb002001          ADD      r0,r0,r1,LSL #8
000032  b280              UXTH     r0,r0
000034  9007              STR      r0,[sp,#0x1c]
;;;1096     int16_t NewVal  = WriteSinglePkt->RegVal.Part.Lo  + ( WriteSinglePkt->RegVal.Part.Hi  << 8U );
000036  7978              LDRB     r0,[r7,#5]
000038  7939              LDRB     r1,[r7,#4]
00003a  eb002001          ADD      r0,r0,r1,LSL #8
00003e  fa0ffb80          SXTH     r11,r0
;;;1097   
;;;1098     if ( 
000042  fa1ff18b          UXTH     r1,r11
000046  4642              MOV      r2,r8
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       _ZN10TModbusApp11chk_new_valEtNS_7TMbFnctE ; TModbusApp::chk_new_val(unsigned short, TModbusApp::TMbFnct)
00004e  b960              CBNZ     r0,|L5.106|
;;;1099         chk_new_val( NewVal, MbFnct ) == false    
;;;1100        )
;;;1101     {
;;;1102       //сформировать и отправить пакет с кодом исключения 3 (ILLEGAL DATA VALUE)
;;;1103       Buf[ 1U ] |= 0x80;                                  //Function
000050  7860              LDRB     r0,[r4,#1]
000052  f0400080          ORR      r0,r0,#0x80
000056  7060              STRB     r0,[r4,#1]
;;;1104       Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_VAL;       //Exception Code
000058  2003              MOVS     r0,#3
00005a  70a0              STRB     r0,[r4,#2]
;;;1105       
;;;1106   //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;1107       s_formatting_error_reply( Buf );
00005c  4621              MOV      r1,r4
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
                  |L5.100|
;;;1108   
;;;1109       return;
;;;1110     }
;;;1111   
;;;1112     const TPDU *PDU = nullptr;
;;;1113     
;;;1114     if (                          //если хотя-бы один из запрошенных регистров не найден или доступ к нему не разрешен
;;;1115         chk_legal_item(
;;;1116                        beg, 
;;;1117                        end, 
;;;1118                        RegAddr, 
;;;1119                        MbFnct,
;;;1120                        &TDevHandlers::chk_access,
;;;1121                        &PDU
;;;1122                       ) == false
;;;1123        )
;;;1124     {
;;;1125   		  //сформировать и отправить пакет с кодом исключения 2 (ILLEGAL DATA ADDRESS)
;;;1126   		  Buf[ 1U ] |= 0x80;                                  //Function
;;;1127   		  Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_ADDR;      //Exception Code
;;;1128   
;;;1129   //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;1130         s_formatting_error_reply( Buf );
;;;1131   
;;;1132   			return;
;;;1133     }
;;;1134   
;;;1135     *(TWriteSinglePkt *)TxBuf = *(TWriteSinglePkt *)Buf; //общее количество байтов в пакете = BUF_SIZE \
;;;1136                                                            ответ - эхо запроса
;;;1137                                                            
;;;1138     int16_t Data = NewVal;
;;;1139     
;;;1140     if (
;;;1141         ( this->*(PDU->Fnct) )( reinterpret_cast<uint32_t>(&Data) ) == true
;;;1142        )
;;;1143     {
;;;1144       *(uint16_t *)&TxBuf[ BUF_SIZE - 2U ] = CRC16( TxBuf, BUF_SIZE - 2U );
;;;1145   
;;;1146       start_transmit( BUF_SIZE ); //отправить сформированый пакет
;;;1147       
;;;1148   //    Do.open();
;;;1149       
;;;1150       State = TState::__IDLE;
;;;1151     }
;;;1152     else
;;;1153     {
;;;1154       //сформировать и отправить пакет с кодом исключения 4 (SERVER DEVICE FAILURE)
;;;1155       Buf[ 1U ] |= 0x80;                                  //Function
;;;1156       Buf[ 2U ] = TExceptCodes::__SERVER_DEVICE_FAILURE;  //Exception Code
;;;1157   
;;;1158   //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;1159       s_formatting_error_reply( Buf );
;;;1160   
;;;1161       return;
;;;1162     }
;;;1163   }
000064  b00b              ADD      sp,sp,#0x2c
000066  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.106|
00006a  2000              MOVS     r0,#0                 ;1112
00006c  9006              STR      r0,[sp,#0x18]         ;1112
00006e  a806              ADD      r0,sp,#0x18           ;1114
000070  492d              LDR      r1,|L5.296|
000072  9003              STR      r0,[sp,#0xc]          ;1114
000074  c903              LDM      r1,{r0,r1}            ;1114
000076  e9cd8000          STRD     r8,r0,[sp,#0]         ;1114
00007a  9102              STR      r1,[sp,#8]            ;1114
00007c  4628              MOV      r0,r5                 ;1114
00007e  e9dd3207          LDRD     r3,r2,[sp,#0x1c]      ;1114
000082  9909              LDR      r1,[sp,#0x24]         ;1114
000084  f7fffffe          BL       _ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_ ; TModbusApp::chk_legal_item(const TDevHandlers::TPDU*, const TDevHandlers::TPDU*, unsigned short, TModbusApp::TMbFnct, bool(TDevHandlers::*)(void*), const TDevHandlers::TPDU**)
000088  b950              CBNZ     r0,|L5.160|
00008a  7860              LDRB     r0,[r4,#1]            ;1126
00008c  f0400080          ORR      r0,r0,#0x80           ;1126
000090  7060              STRB     r0,[r4,#1]            ;1126
000092  2002              MOVS     r0,#2                 ;1127
000094  70a0              STRB     r0,[r4,#2]            ;1127
000096  4621              MOV      r1,r4                 ;1130
000098  4628              MOV      r0,r5                 ;1130
00009a  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
00009e  e7e1              B        |L5.100|
                  |L5.160|
0000a0  6821              LDR      r1,[r4,#0]            ;1135
0000a2  f8c51114          STR      r1,[r5,#0x114]        ;1135
0000a6  6861              LDR      r1,[r4,#4]            ;1135
0000a8  f8c51118          STR      r1,[r5,#0x118]        ;1135
0000ac  f8cdb014          STR      r11,[sp,#0x14]        ;1138
0000b0  9806              LDR      r0,[sp,#0x18]         ;1140
0000b2  68c1              LDR      r1,[r0,#0xc]          ;1140
0000b4  f505700e          ADD      r0,r5,#0x238          ;1140
0000b8  eb000961          ADD      r9,r0,r1,ASR #1       ;1140
0000bc  9806              LDR      r0,[sp,#0x18]         ;1140
0000be  7b00              LDRB     r0,[r0,#0xc]          ;1140
0000c0  f0000001          AND      r0,r0,#1              ;1140
0000c4  b910              CBNZ     r0,|L5.204|
0000c6  9806              LDR      r0,[sp,#0x18]         ;1141
0000c8  6880              LDR      r0,[r0,#8]            ;1141
0000ca  e007              B        |L5.220|
                  |L5.204|
0000cc  f8d90000          LDR      r0,[r9,#0]            ;1141
0000d0  9906              LDR      r1,[sp,#0x18]         ;1141
0000d2  6889              LDR      r1,[r1,#8]            ;1141
0000d4  eb000a01          ADD      r10,r0,r1             ;1141
0000d8  f8da0000          LDR      r0,[r10,#0]           ;1141
                  |L5.220|
0000dc  a905              ADD      r1,sp,#0x14           ;1141
0000de  900a              STR      r0,[sp,#0x28]         ;1141
0000e0  4648              MOV      r0,r9                 ;1141
0000e2  9a0a              LDR      r2,[sp,#0x28]         ;1141
0000e4  4790              BLX      r2                    ;1141
0000e6  2801              CMP      r0,#1                 ;1141
0000e8  d111              BNE      |L5.270|
0000ea  1eb0              SUBS     r0,r6,#2              ;1144
0000ec  b281              UXTH     r1,r0                 ;1144
0000ee  f505708a          ADD      r0,r5,#0x114          ;1144
0000f2  f7fffffe          BL       CRC16
0000f6  1eb1              SUBS     r1,r6,#2              ;1144
0000f8  f505728a          ADD      r2,r5,#0x114          ;1144
0000fc  5250              STRH     r0,[r2,r1]            ;1144
0000fe  b2f1              UXTB     r1,r6                 ;1146
000100  4628              MOV      r0,r5                 ;1146
000102  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
000106  2000              MOVS     r0,#0                 ;1150
000108  f8850230          STRB     r0,[r5,#0x230]        ;1150
00010c  e00a              B        |L5.292|
                  |L5.270|
00010e  7860              LDRB     r0,[r4,#1]            ;1155
000110  f0400080          ORR      r0,r0,#0x80           ;1155
000114  7060              STRB     r0,[r4,#1]            ;1155
000116  2004              MOVS     r0,#4                 ;1156
000118  70a0              STRB     r0,[r4,#2]            ;1156
00011a  4621              MOV      r1,r4                 ;1159
00011c  4628              MOV      r0,r5                 ;1159
00011e  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
000122  e79f              B        |L5.100|
                  |L5.292|
000124  bf00              NOP      
000126  e79d              B        |L5.100|
;;;1164   
                          ENDP

                  |L5.296|
                          DCD      ||<Data1>||

                          AREA ||i._ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_ PROC ; TModbusApp::chk_legal_item(const TDevHandlers::TPDU*, const TDevHandlers::TPDU*, unsigned short, TModbusApp::TMbFnct, bool(TDevHandlers::*)(void*), const TDevHandlers::TPDU**)
;;;1431   
;;;1432   bool TModbusApp::chk_legal_item(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1433                                   const TPDU  *beg, 
;;;1434                                   const TPDU  *end, 
;;;1435                                   uint16_t     CurAddr, 
;;;1436                                   TMbFnct      MbFnct,
;;;1437                                   TChkFnct     chk_fnct,
;;;1438                                   const TPDU **target
;;;1439                                  )
;;;1440   {
000004  b089              SUB      sp,sp,#0x24
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4615              MOV      r5,r2
00000c  4699              MOV      r9,r3
00000e  f8dda054          LDR      r10,[sp,#0x54]
;;;1441     for ( auto item = beg; item < end; ++item ) //end - интератор после конца
000012  4644              MOV      r4,r8
000014  e02f              B        |L6.118|
                  |L6.22|
;;;1442     {
;;;1443       if ( 
000016  8860              LDRH     r0,[r4,#2]
000018  4548              CMP      r0,r9
00001a  d12b              BNE      |L6.116|
;;;1444           item->RegAddr == CurAddr 
;;;1445           &&
;;;1446           item->FnctNbr == MbFnct
00001c  7821              LDRB     r1,[r4,#0]
00001e  9812              LDR      r0,[sp,#0x48]
000020  4281              CMP      r1,r0
000022  d127              BNE      |L6.116|
;;;1447           &&
;;;1448           ( this->*chk_fnct )( item->Chk )
000024  e9dd0113          LDRD     r0,r1,[sp,#0x4c]
000028  e9cd0100          STRD     r0,r1,[sp,#0]
00002c  f507700e          ADD      r0,r7,#0x238
000030  eb000661          ADD      r6,r0,r1,ASR #1
000034  9813              LDR      r0,[sp,#0x4c]
000036  e9cd0102          STRD     r0,r1,[sp,#8]
00003a  f0010001          AND      r0,r1,#1
00003e  b920              CBNZ     r0,|L6.74|
000040  e9dd0113          LDRD     r0,r1,[sp,#0x4c]
000044  e9cd0104          STRD     r0,r1,[sp,#0x10]
000048  e008              B        |L6.92|
                  |L6.74|
00004a  e9dd0113          LDRD     r0,r1,[sp,#0x4c]
00004e  e9cd0106          STRD     r0,r1,[sp,#0x18]
000052  6831              LDR      r1,[r6,#0]
000054  eb000b01          ADD      r11,r0,r1
000058  f8db0000          LDR      r0,[r11,#0]
                  |L6.92|
00005c  9008              STR      r0,[sp,#0x20]
00005e  4630              MOV      r0,r6
000060  6861              LDR      r1,[r4,#4]
000062  9a08              LDR      r2,[sp,#0x20]
000064  4790              BLX      r2
000066  b128              CBZ      r0,|L6.116|
;;;1449          )
;;;1450       {
;;;1451         *target = item;
000068  f8ca4000          STR      r4,[r10,#0]
;;;1452         
;;;1453         return true; //найден искомый элемент
00006c  2001              MOVS     r0,#1
                  |L6.110|
;;;1454       }
;;;1455     }
;;;1456     
;;;1457     *target = end;
;;;1458     
;;;1459     return false;
;;;1460   }
00006e  b009              ADD      sp,sp,#0x24
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.116|
000074  3410              ADDS     r4,r4,#0x10           ;1441
                  |L6.118|
000076  42ac              CMP      r4,r5                 ;1441
000078  d3cd              BCC      |L6.22|
00007a  f8ca5000          STR      r5,[r10,#0]           ;1457
00007e  2000              MOVS     r0,#0                 ;1459
000080  e7f5              B        |L6.110|
;;;1461   
                          ENDP


                          AREA ||i._ZN10TModbusApp18m_processing_errorEv||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp18m_processing_errorEv PROC ; TModbusApp::m_processing_error()
;;;416    
;;;417    void TModbusApp::m_processing_error()
000000  4770              BX       lr
;;;418    {
;;;419    
;;;420    }
;;;421    //-----------------------------------------------
                          ENDP


                          AREA ||i._ZN10TModbusApp18m_processing_replyEPht||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp18m_processing_replyEPht PROC ; TModbusApp::m_processing_reply(unsigned char*, unsigned short)
;;;373    
;;;374    void TModbusApp::m_processing_reply( uint8_t *Buf, uint16_t BUF_SIZE )
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;375    {
000004  b095              SUB      sp,sp,#0x54
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4691              MOV      r9,r2
;;;376      typedef void (TModbusApp::*TFnct)( uint8_t *, uint16_t );
;;;377      
;;;378      struct TAction
;;;379      {
;;;380        uint8_t Code;
;;;381        TFnct   Fnct;
;;;382      };
;;;383    
;;;384      TAction Action[] =
00000c  223c              MOVS     r2,#0x3c
00000e  4920              LDR      r1,|L8.144|
000010  a805              ADD      r0,sp,#0x14
000012  f7fffffe          BL       __aeabi_memcpy4
;;;385      {
;;;386        { TMbFnct::__READ_DISCRETE_INPUTS,     &TModbusApp::m_read_discrete_inputs,    }, // 2
;;;387        { TMbFnct::__READ_HOLDING_REGISTERS,   &TModbusApp::m_read_holding_registers,  }, // 3
;;;388        { TMbFnct::__READ_INPUT_REGISTERS,     &TModbusApp::m_read_input_registers,    }, // 4
;;;389        { TMbFnct::__WRITE_SINGLE_COIL,        &TModbusApp::m_write_single_coil,       }, // 5
;;;390        { TMbFnct::__WRITE_SINGLE_REGISTER,    &TModbusApp::m_write_single_register,   }, // 6
;;;391      };
;;;392        
;;;393      constexpr uint8_t ACTION_SIZE = sizeof Action / sizeof Action[0];
000016  2005              MOVS     r0,#5
000018  9004              STR      r0,[sp,#0x10]
;;;394      
;;;395      auto beg = &Action[0];
00001a  f10d0a14          ADD      r10,sp,#0x14
;;;396      auto end = &Action[ACTION_SIZE];
00001e  af14              ADD      r7,sp,#0x50
;;;397      
;;;398    	TAction *CurAction = 
000020  4650              MOV      r0,r10
000022  4639              MOV      r1,r7
000024  9614              STR      r6,[sp,#0x50]
000026  9603              STR      r6,[sp,#0xc]
000028  e000              B        |L8.44|
                  |L8.42|
00002a  300c              ADDS     r0,r0,#0xc
                  |L8.44|
00002c  4288              CMP      r0,r1
00002e  d00e              BEQ      |L8.78|
000030  e890100c          LDM      r0,{r2,r3,r12}
000034  e88d100c          STM      sp,{r2,r3,r12}
;;;399    	std::find_if( beg, end, [ Buf ]( TAction item ){
;;;400    		return ( item.Code == Buf[ 1U ] );
000038  f89d2000          LDRB     r2,[sp,#0]
00003c  9b03              LDR      r3,[sp,#0xc]
00003e  785b              LDRB     r3,[r3,#1]
000040  429a              CMP      r2,r3
000042  d101              BNE      |L8.72|
000044  2201              MOVS     r2,#1
000046  e000              B        |L8.74|
                  |L8.72|
000048  2200              MOVS     r2,#0
                  |L8.74|
00004a  2a00              CMP      r2,#0
00004c  d0ed              BEQ      |L8.42|
                  |L8.78|
00004e  4604              MOV      r4,r0                 ;398
;;;401    	} );
;;;402    	
;;;403      //проверка поддержки клиентом функции в ответе
;;;404    	if (
000050  42a7              CMP      r7,r4
000052  d103              BNE      |L8.92|
;;;405    			end == CurAction
;;;406    		 )                                                                    
;;;407    	{
;;;408        //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;409        State = TState::__IDLE;
000054  2000              MOVS     r0,#0
000056  f8850230          STRB     r0,[r5,#0x230]
00005a  e016              B        |L8.138|
                  |L8.92|
;;;410    	}
;;;411    	else
;;;412    	{
;;;413    	  ( this->*(CurAction->Fnct) )( Buf, BUF_SIZE ); //выполнение требуемой функции
00005c  68a0              LDR      r0,[r4,#8]
00005e  eb050860          ADD      r8,r5,r0,ASR #1
000062  7a20              LDRB     r0,[r4,#8]
000064  f0000001          AND      r0,r0,#1
000068  b908              CBNZ     r0,|L8.110|
00006a  6860              LDR      r0,[r4,#4]
00006c  e006              B        |L8.124|
                  |L8.110|
00006e  f8d80000          LDR      r0,[r8,#0]
000072  6861              LDR      r1,[r4,#4]
000074  eb000b01          ADD      r11,r0,r1
000078  f8db0000          LDR      r0,[r11,#0]
                  |L8.124|
00007c  464a              MOV      r2,r9
00007e  4631              MOV      r1,r6
000080  9003              STR      r0,[sp,#0xc]
000082  4640              MOV      r0,r8
000084  9b03              LDR      r3,[sp,#0xc]
000086  4798              BLX      r3
;;;414    	}
000088  bf00              NOP      
                  |L8.138|
;;;415    }
00008a  b015              ADD      sp,sp,#0x54
00008c  e8bd8ff0          POP      {r4-r11,pc}
;;;416    
                          ENDP

                  |L8.144|
                          DCD      ||.constdata||+0x70

                          AREA ||i._ZN10TModbusApp18s_checking_requestEv||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp18s_checking_requestEv PROC ; TModbusApp::s_checking_request()
;;;173    
;;;174    void TModbusApp::s_checking_request()
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;175    {  
000004  4604              MOV      r4,r0
;;;176      static uint8_t PrevQty = 0U;
;;;177      
;;;178      IxSlice.Head = get_rx_dma_data_qty();           //голова буфера
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       _ZN11TModbusLink19get_rx_dma_data_qtyEv ; TModbusLink::get_rx_dma_data_qty()
00000c  b2c1              UXTB     r1,r0
00000e  f2402033          MOV      r0,#0x233
000012  5501              STRB     r1,[r0,r4]
;;;179      
;;;180      if ( IxSlice.Head == IxSlice.Tail )
000014  5d00              LDRB     r0,[r0,r4]
000016  f8941232          LDRB     r1,[r4,#0x232]
00001a  4288              CMP      r0,r1
00001c  d104              BNE      |L9.40|
;;;181      {
;;;182    //    Do.open();
;;;183        static uint8_t Ctr = 0U;
;;;184        ++Ctr;
00001e  4852              LDR      r0,|L9.360|
000020  7800              LDRB     r0,[r0,#0]  ; _ZZN10TModbusApp18s_checking_requestEvE3Ctr
000022  1c40              ADDS     r0,r0,#1
000024  4950              LDR      r1,|L9.360|
000026  7008              STRB     r0,[r1,#0]
                  |L9.40|
;;;185    //    Do.toggle();
;;;186      }
;;;187      
;;;188      PrevQty = IxSlice.Head;
000028  f2402033          MOV      r0,#0x233
00002c  5d00              LDRB     r0,[r0,r4]
00002e  494f              LDR      r1,|L9.364|
000030  7008              STRB     r0,[r1,#0]
;;;189      
;;;190    //  en_eob_detect( TModbusLink::_3_5_CH_BITS_NBR ); //флаг RTO на 1.5Ch сработал перестраиваем RTO на 3.5Ch
;;;191      
;;;192      
;;;193      if ( IxSlice.Tail <= IxSlice.Head )
000032  f8941232          LDRB     r1,[r4,#0x232]
000036  f2402033          MOV      r0,#0x233
00003a  5d00              LDRB     r0,[r0,r4]
00003c  4281              CMP      r1,r0
00003e  dc19              BGT      |L9.116|
;;;194      {
;;;195        BUF_SIZE = IxSlice.Head - IxSlice.Tail;
000040  f2402033          MOV      r0,#0x233
000044  5d00              LDRB     r0,[r0,r4]
000046  f8941232          LDRB     r1,[r4,#0x232]
00004a  1a40              SUBS     r0,r0,r1
00004c  4948              LDR      r1,|L9.368|
00004e  7008              STRB     r0,[r1,#0]
;;;196        
;;;197        auto beg = &RxBuf[ IxSlice.Tail ];
000050  f8941232          LDRB     r1,[r4,#0x232]
000054  f1040015          ADD      r0,r4,#0x15
000058  180d              ADDS     r5,r1,r0
;;;198        auto end = &RxBuf[ IxSlice.Head ];
00005a  f2402033          MOV      r0,#0x233
00005e  5d01              LDRB     r1,[r0,r4]
000060  f1040015          ADD      r0,r4,#0x15
000064  180e              ADDS     r6,r1,r0
;;;199        std::copy( beg, end, &HandleBuf[ 0U ] );
000066  f5047294          ADD      r2,r4,#0x128
00006a  4631              MOV      r1,r6
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       _ZSt4copyIPhS0_ET0_T_S2_S1_ ; T2 std::copy<unsigned char*, unsigned char*>(T1, T1, T2)
;;;200      }
000072  e02b              B        |L9.204|
                  |L9.116|
;;;201      else
;;;202      {
;;;203        BUF_SIZE = RX_BUF_SIZE - IxSlice.Tail + IxSlice.Head;
000074  f8940232          LDRB     r0,[r4,#0x232]
000078  f1c001ff          RSB      r1,r0,#0xff
00007c  f2402033          MOV      r0,#0x233
000080  5d00              LDRB     r0,[r0,r4]
000082  4408              ADD      r0,r0,r1
000084  493a              LDR      r1,|L9.368|
000086  7008              STRB     r0,[r1,#0]
;;;204        
;;;205        auto beg = &RxBuf[ IxSlice.Tail ];
000088  f8941232          LDRB     r1,[r4,#0x232]
00008c  f1040015          ADD      r0,r4,#0x15
000090  180d              ADDS     r5,r1,r0
;;;206        auto end = &RxBuf[ RX_BUF_SIZE ];
000092  f504768a          ADD      r6,r4,#0x114
;;;207        std::copy( beg, end, &HandleBuf[ 0U ] );
000096  f5047294          ADD      r2,r4,#0x128
00009a  4631              MOV      r1,r6
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       _ZSt4copyIPhS0_ET0_T_S2_S1_ ; T2 std::copy<unsigned char*, unsigned char*>(T1, T1, T2)
;;;208        
;;;209        beg = &RxBuf[ 0U ];
0000a2  f1040515          ADD      r5,r4,#0x15
;;;210        end = &RxBuf[ IxSlice.Head ];
0000a6  f2402033          MOV      r0,#0x233
0000aa  5d01              LDRB     r1,[r0,r4]
0000ac  4628              MOV      r0,r5
0000ae  180e              ADDS     r6,r1,r0
;;;211        std::copy( beg, end, &HandleBuf[ BUF_SIZE - IxSlice.Head ] );
0000b0  f2402033          MOV      r0,#0x233
0000b4  5d00              LDRB     r0,[r0,r4]
0000b6  492e              LDR      r1,|L9.368|
0000b8  7809              LDRB     r1,[r1,#0]  ; BUF_SIZE
0000ba  1a09              SUBS     r1,r1,r0
0000bc  f5047094          ADD      r0,r4,#0x128
0000c0  180a              ADDS     r2,r1,r0
0000c2  4631              MOV      r1,r6
0000c4  4628              MOV      r0,r5
0000c6  f7fffffe          BL       _ZSt4copyIPhS0_ET0_T_S2_S1_ ; T2 std::copy<unsigned char*, unsigned char*>(T1, T1, T2)
;;;212      }
0000ca  bf00              NOP      
                  |L9.204|
;;;213      
;;;214      if ( RxBuf[IxSlice.Tail + 1] > 6U )
0000cc  f8940232          LDRB     r0,[r4,#0x232]
0000d0  1c40              ADDS     r0,r0,#1
0000d2  f1040115          ADD      r1,r4,#0x15
0000d6  5c08              LDRB     r0,[r1,r0]
0000d8  2806              CMP      r0,#6
0000da  d904              BLS      |L9.230|
;;;215      {
;;;216        static uint8_t Ctr = 0U;
;;;217        ++Ctr;
0000dc  4825              LDR      r0,|L9.372|
0000de  7800              LDRB     r0,[r0,#0]  ; _ZZN10TModbusApp18s_checking_requestEvE3Ctr_0
0000e0  1c40              ADDS     r0,r0,#1
0000e2  4924              LDR      r1,|L9.372|
0000e4  7008              STRB     r0,[r1,#0]
                  |L9.230|
;;;218      }
;;;219      
;;;220      if (
;;;221          StrIx == 0U
;;;222          &&      
;;;223          ProcType == TProcType::__MASTER
;;;224          &&
;;;225          HandleBuf[ 1 ] == 4U
;;;226         )
;;;227      {
;;;228    //    Do.closed();
;;;229      }
;;;230      
;;;231      if ( handle_frame( HandleBuf, BUF_SIZE ) == true )
0000e6  4822              LDR      r0,|L9.368|
0000e8  7802              LDRB     r2,[r0,#0]  ; BUF_SIZE
0000ea  f5047194          ADD      r1,r4,#0x128
0000ee  4620              MOV      r0,r4
0000f0  f7fffffe          BL       _ZN11TModbusLink12handle_frameEPKht ; TModbusLink::handle_frame(const unsigned char*, unsigned short)
0000f4  b338              CBZ      r0,|L9.326|
;;;232      {
;;;233    //    Do.closed();
;;;234        typedef void (TModbusApp::*TFnct)( uint8_t *, uint16_t );
;;;235        
;;;236        TFnct Fnct[] =
0000f6  4b20              LDR      r3,|L9.376|
0000f8  cb0f              LDM      r3,{r0-r3}
0000fa  e88d000f          STM      sp,{r0-r3}
;;;237        {
;;;238          &TModbusApp::m_processing_reply,           //__MASTER
;;;239          &TModbusApp::s_processing_required_action, //__SLAVE 
;;;240        };
;;;241        
;;;242        ( this->*Fnct[ ProcType ] )( HandleBuf, BUF_SIZE );
0000fe  f8940234          LDRB     r0,[r4,#0x234]
000102  4669              MOV      r1,sp
000104  eb0100c0          ADD      r0,r1,r0,LSL #3
000108  6840              LDR      r0,[r0,#4]
00010a  eb040560          ADD      r5,r4,r0,ASR #1
00010e  f8940234          LDRB     r0,[r4,#0x234]
000112  eb0100c0          ADD      r0,r1,r0,LSL #3
000116  7900              LDRB     r0,[r0,#4]
000118  f0000001          AND      r0,r0,#1
00011c  b920              CBNZ     r0,|L9.296|
00011e  f8940234          LDRB     r0,[r4,#0x234]
000122  f85d0030          LDR      r0,[sp,r0,LSL #3]
000126  e006              B        |L9.310|
                  |L9.296|
000128  f8941234          LDRB     r1,[r4,#0x234]
00012c  f85d1031          LDR      r1,[sp,r1,LSL #3]
000130  6828              LDR      r0,[r5,#0]
000132  1846              ADDS     r6,r0,r1
000134  6830              LDR      r0,[r6,#0]
                  |L9.310|
000136  4607              MOV      r7,r0
000138  480d              LDR      r0,|L9.368|
00013a  7802              LDRB     r2,[r0,#0]  ; BUF_SIZE
00013c  f5047194          ADD      r1,r4,#0x128
000140  4628              MOV      r0,r5
000142  47b8              BLX      r7
;;;243      }
000144  e002              B        |L9.332|
                  |L9.326|
;;;244      else
;;;245      {
;;;246        State = TState::__IDLE;
000146  2000              MOVS     r0,#0
000148  f8840230          STRB     r0,[r4,#0x230]
                  |L9.332|
;;;247      }
;;;248      
;;;249    //  Do.closed();
;;;250      stop_receive();
00014c  4620              MOV      r0,r4
00014e  f7fffffe          BL       _ZN11TModbusLink12stop_receiveEv ; TModbusLink::stop_receive()
;;;251      
;;;252      if ( State != TState::__IDLE)
000152  f8940230          LDRB     r0,[r4,#0x230]
000156  b120              CBZ      r0,|L9.354|
;;;253      {
;;;254        static uint8_t Ctr = 0U;
;;;255        ++Ctr;
000158  4808              LDR      r0,|L9.380|
00015a  7800              LDRB     r0,[r0,#0]  ; _ZZN10TModbusApp18s_checking_requestEvE3Ctr_1
00015c  1c40              ADDS     r0,r0,#1
00015e  4907              LDR      r1,|L9.380|
000160  7008              STRB     r0,[r1,#0]
                  |L9.354|
;;;256      }
;;;257    }
000162  e8bd81ff          POP      {r0-r8,pc}
;;;258    
                          ENDP

000166  0000              DCW      0x0000
                  |L9.360|
                          DCD      _ZZN10TModbusApp18s_checking_requestEvE3Ctr ; TModbusApp::s_checking_request()::Ctr
                  |L9.364|
                          DCD      _ZZN10TModbusApp18s_checking_requestEvE7PrevQty ; TModbusApp::s_checking_request()::PrevQty
                  |L9.368|
                          DCD      BUF_SIZE
                  |L9.372|
                          DCD      _ZZN10TModbusApp18s_checking_requestEvE3Ctr_0 ; TModbusApp::s_checking_request()::Ctr (instance 2)
                  |L9.376|
                          DCD      ||.constdata||+0xac
                  |L9.380|
                          DCD      _ZZN10TModbusApp18s_checking_requestEvE3Ctr_1 ; TModbusApp::s_checking_request()::Ctr (instance 3)

                          AREA ||i._ZN10TModbusApp18s_report_server_idEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp18s_report_server_idEPht PROC ; TModbusApp::s_report_server_id(unsigned char*, unsigned short)
;;;686    
;;;687    void TModbusApp::s_report_server_id( uint8_t *Buf, uint16_t BUF_SIZE ) // 17
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;688    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
;;;689    //  write_single( Buf, BUF_SIZE, TMbFnct::__WRITE_SINGLE_REGISTER );
;;;690      __packed struct TBasic
;;;691    	{
;;;692    	  uint8_t Addr;
;;;693    		uint8_t FnctCode;
;;;694    	};
;;;695    
;;;696      __packed struct TRespPkt
;;;697    	{
;;;698    	  TBasic Basic;
;;;699    		uint8_t ByteCnt;
;;;700    		uint8_t ServerID;
;;;701    	};
;;;702    
;;;703    	*(TBasic *)TxBuf = *(TBasic *)Buf;
00000a  f5047080          ADD      r0,r4,#0x100
00000e  8839              LDRH     r1,[r7,#0]
000010  f8a41114          STRH     r1,[r4,#0x114]
;;;704    
;;;705    	auto Src = get_id_17();
000014  f504700e          ADD      r0,r4,#0x238
000018  f7fffffe          BL       _ZN12TDevHandlers9get_id_17Ev ; TDevHandlers::get_id_17()
00001c  4680              MOV      r8,r0
;;;706    
;;;707      ((TRespPkt *)TxBuf)->ByteCnt = ( sizeof Src ) + 1U;
00001e  2105              MOVS     r1,#5
000020  f44f708b          MOV      r0,#0x116
000024  5501              STRB     r1,[r0,r4]
;;;708    	auto Dest = &((TRespPkt *)TxBuf)->ServerID;
000026  f2041517          ADD      r5,r4,#0x117
;;;709    
;;;710    
;;;711    
;;;712    	while ( *Dest++ = *Src++ ) {};
00002a  bf00              NOP      
                  |L10.44|
00002c  f8181b01          LDRB     r1,[r8],#1
000030  f8051b01          STRB     r1,[r5],#1
000034  2900              CMP      r1,#0
000036  d1f9              BNE      |L10.44|
;;;713    
;;;714    	*--Dest = 0xFF; //замена нулевого символа конца строки на Run Indicator Status = ON
000038  21ff              MOVS     r1,#0xff
00003a  1e68              SUBS     r0,r5,#1
00003c  4605              MOV      r5,r0
00003e  7001              STRB     r1,[r0,#0]
;;;715      Dest++;
000040  1c6d              ADDS     r5,r5,#1
;;;716    
;;;717      auto DataPktSize = sizeof (TRespPkt);
000042  2604              MOVS     r6,#4
;;;718      DataPktSize += std::strlen( get_id_17() ); //размер пакета без Crc
000044  f504700e          ADD      r0,r4,#0x238
000048  f7fffffe          BL       _ZN12TDevHandlers9get_id_17Ev ; TDevHandlers::get_id_17()
00004c  4682              MOV      r10,r0
00004e  f7fffffe          BL       strlen
000052  4406              ADD      r6,r6,r0
;;;719    	*(uint16_t *)Dest = CRC16( TxBuf, DataPktSize );
000054  b2b1              UXTH     r1,r6
000056  f504708a          ADD      r0,r4,#0x114
00005a  f7fffffe          BL       CRC16
00005e  8028              STRH     r0,[r5,#0]
;;;720    	start_transmit( DataPktSize + 2U ); //отправить сформированый пакет с Crc
000060  1cb0              ADDS     r0,r6,#2
000062  b2c1              UXTB     r1,r0
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
;;;721    	State = TState::__IDLE;
00006a  2000              MOVS     r0,#0
00006c  f8840230          STRB     r0,[r4,#0x230]
;;;722    }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;723    
                          ENDP


                          AREA ||i._ZN10TModbusApp19m_waiting_for_replyEv||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp19m_waiting_for_replyEv PROC ; TModbusApp::m_waiting_for_reply()
;;;368    
;;;369    void TModbusApp::m_waiting_for_reply()
000000  4770              BX       lr
;;;370    {
;;;371      //здесь должен работать прием через DMA
;;;372    }
;;;373    
                          ENDP


                          AREA ||i._ZN10TModbusApp19m_write_single_coilEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp19m_write_single_coilEPht PROC ; TModbusApp::m_write_single_coil(unsigned char*, unsigned short)
;;;568    
;;;569    void TModbusApp::m_write_single_coil( uint8_t *Buf, uint16_t BUF_SIZE ) //5
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;570    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
;;;571      auto beg = &PduHandler->Buf[ 0 ];
00000a  f8d40238          LDR      r0,[r4,#0x238]
00000e  f8d0a000          LDR      r10,[r0,#0]
;;;572    	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000012  f8d40238          LDR      r0,[r4,#0x238]
000016  6800              LDR      r0,[r0,#0]
000018  f8d41238          LDR      r1,[r4,#0x238]
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001701          ADD      r7,r0,r1,LSL #4
;;;573          
;;;574    	__packed struct TBasic
;;;575    	{
;;;576    		uint8_t  Addr;
;;;577    		uint8_t  FnctCode;
;;;578        THalfWordParse CoilAddr;
;;;579        uint16_t NewState;
;;;580        uint16_t Crc;		
;;;581    	};
;;;582    
;;;583      const TBasic *InputPkt = reinterpret_cast<const TBasic *>(Buf);
000022  46b0              MOV      r8,r6
;;;584      
;;;585      TLittleEndian CoilAddr;
;;;586      CoilAddr.Segment.Lo = InputPkt->CoilAddr.Segment.Lo;
000024  f8980003          LDRB     r0,[r8,#3]
000028  f88d0014          STRB     r0,[sp,#0x14]
;;;587      CoilAddr.Segment.Hi = InputPkt->CoilAddr.Segment.Hi;
00002c  f8980002          LDRB     r0,[r8,#2]
000030  f88d0015          STRB     r0,[sp,#0x15]
;;;588      
;;;589      TPDU *PDU =
000034  4650              MOV      r0,r10
000036  4639              MOV      r1,r7
000038  9a05              LDR      r2,[sp,#0x14]
00003a  9206              STR      r2,[sp,#0x18]
00003c  9204              STR      r2,[sp,#0x10]
00003e  e000              B        |L12.66|
                  |L12.64|
000040  3010              ADDS     r0,r0,#0x10
                  |L12.66|
000042  4288              CMP      r0,r1
000044  d012              BEQ      |L12.108|
000046  e890100c          LDM      r0,{r2,r3,r12}
00004a  f8d0900c          LDR      r9,[r0,#0xc]
00004e  e88d100c          STM      sp,{r2,r3,r12}
000052  f8cd900c          STR      r9,[sp,#0xc]
;;;590      std::find_if( beg, end, [ CoilAddr ]( TPDU item ){
;;;591        return ( item.RegAddr == CoilAddr.Val );
000056  f8bd2002          LDRH     r2,[sp,#2]
00005a  f8bd3010          LDRH     r3,[sp,#0x10]
00005e  429a              CMP      r2,r3
000060  d101              BNE      |L12.102|
000062  2201              MOVS     r2,#1
000064  e000              B        |L12.104|
                  |L12.102|
000066  2200              MOVS     r2,#0
                  |L12.104|
000068  2a00              CMP      r2,#0
00006a  d0e9              BEQ      |L12.64|
                  |L12.108|
00006c  4605              MOV      r5,r0                 ;589
;;;592      } );
;;;593      
;;;594      if ( PDU == end )
00006e  42bd              CMP      r5,r7
000070  d01a              BEQ      |L12.168|
;;;595      {
;;;596        //регистр не найден
;;;597        //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;598        //return;
;;;599      }
;;;600      else
;;;601      {
;;;602        uint16_t Data = __RESP_SUCCESS;    
000072  f24a505a          MOV      r0,#0xa55a
000076  9003              STR      r0,[sp,#0xc]
;;;603        ( this->*( PDU->Fnct ) )( reinterpret_cast<uint32_t>( &Data ) );    
000078  f504700e          ADD      r0,r4,#0x238
00007c  68e9              LDR      r1,[r5,#0xc]
00007e  eb000961          ADD      r9,r0,r1,ASR #1
000082  7b28              LDRB     r0,[r5,#0xc]
000084  f0000001          AND      r0,r0,#1
000088  b908              CBNZ     r0,|L12.142|
00008a  68a8              LDR      r0,[r5,#8]
00008c  e006              B        |L12.156|
                  |L12.142|
00008e  f8d90000          LDR      r0,[r9,#0]
000092  68a9              LDR      r1,[r5,#8]
000094  eb000b01          ADD      r11,r0,r1
000098  f8db0000          LDR      r0,[r11,#0]
                  |L12.156|
00009c  a903              ADD      r1,sp,#0xc
00009e  9004              STR      r0,[sp,#0x10]
0000a0  4648              MOV      r0,r9
0000a2  9a04              LDR      r2,[sp,#0x10]
0000a4  4790              BLX      r2
;;;604      }
0000a6  bf00              NOP      
                  |L12.168|
;;;605      
;;;606      State = TState::__IDLE;
0000a8  2000              MOVS     r0,#0
0000aa  f8840230          STRB     r0,[r4,#0x230]
;;;607    }
0000ae  b007              ADD      sp,sp,#0x1c
0000b0  e8bd8ff0          POP      {r4-r11,pc}
;;;608    
                          ENDP


                          AREA ||i._ZN10TModbusApp19s_write_single_coilEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp19s_write_single_coilEPht PROC ; TModbusApp::s_write_single_coil(unsigned char*, unsigned short)
;;;671      
;;;672    void TModbusApp::s_write_single_coil( uint8_t *Buf, uint16_t BUF_SIZE ) //5
000000  b570              PUSH     {r4-r6,lr}
;;;673    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;674      write_single( Buf, BUF_SIZE, TMbFnct::__WRITE_SINGLE_COIL );
000008  2305              MOVS     r3,#5
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp12write_singleEPhtNS_7TMbFnctE ; TModbusApp::write_single(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;675    }
000014  bd70              POP      {r4-r6,pc}
;;;676      
                          ENDP


                          AREA ||i._ZN10TModbusApp22m_read_discrete_inputsEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp22m_read_discrete_inputsEPht PROC ; TModbusApp::m_read_discrete_inputs(unsigned char*, unsigned short)
;;;423    //----- обработчики функций протокола для мастера ----------
;;;424    void TModbusApp::m_read_discrete_inputs( uint8_t *Buf, uint16_t BUF_SIZE ) //2
000000  4770              BX       lr
;;;425    {
;;;426    
;;;427    }
;;;428    
                          ENDP


                          AREA ||i._ZN10TModbusApp22m_read_input_registersEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp22m_read_input_registersEPht PROC ; TModbusApp::m_read_input_registers(unsigned char*, unsigned short)
;;;498    
;;;499    void TModbusApp::m_read_input_registers( uint8_t *Buf, uint16_t BUF_SIZE ) //4
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;500    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
;;;501      auto beg = &PduHandler->Buf[ 0 ];
00000a  f8d40238          LDR      r0,[r4,#0x238]
00000e  f8d0b000          LDR      r11,[r0,#0]
;;;502    	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000012  f8d40238          LDR      r0,[r4,#0x238]
000016  6800              LDR      r0,[r0,#0]
000018  f8d41238          LDR      r1,[r4,#0x238]
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001801          ADD      r8,r0,r1,LSL #4
;;;503    	
;;;504      __packed union TRegVal
;;;505      {
;;;506        __packed struct
;;;507        {
;;;508          uint8_t Hi;
;;;509          uint8_t Lo;
;;;510        } Part;
;;;511        uint16_t Data;
;;;512      };
;;;513      
;;;514    	__packed struct TBasic
;;;515    	{
;;;516    		uint8_t Addr;
;;;517    		uint8_t FnctCode;
;;;518        uint8_t BytesQty;
;;;519        TRegVal First;			
;;;520    	};
;;;521    	
;;;522    	const TBasic *InputPkt = reinterpret_cast<const TBasic *>(Buf);
000022  970a              STR      r7,[sp,#0x28]
;;;523      
;;;524      if ( InputPkt->BytesQty != m4RegInfo.Qty * 2U ) //если количество принятых байтов с данными не равно количеству запрошенных
000024  9f0a              LDR      r7,[sp,#0x28]
000026  78b9              LDRB     r1,[r7,#2]
000028  f44f7017          MOV      r0,#0x25c
00002c  5b00              LDRH     r0,[r0,r4]
00002e  ebb10f40          CMP      r1,r0,LSL #1
000032  d005              BEQ      |L15.64|
;;;525      {
;;;526        //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;527        State = TState::__IDLE;
000034  2000              MOVS     r0,#0
000036  f8840230          STRB     r0,[r4,#0x230]
                  |L15.58|
;;;528        
;;;529        return;
;;;530      }
;;;531     
;;;532      for ( uint8_t Ctr = 0U; Ctr < m4RegInfo.Qty; ++Ctr ) //Проверить существования всех регистров, которые пришли в ответном пакете
;;;533      {
;;;534        uint16_t CurAddr = m4RegInfo.StartAddr + Ctr;
;;;535        
;;;536        TPDU *PDU =
;;;537        std::find_if( beg, end, [ CurAddr ]( TPDU item ){
;;;538          return ( item.RegAddr == CurAddr );
;;;539        } );
;;;540        
;;;541        if ( PDU == end ) //если регистр не найден
;;;542        {
;;;543          //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;544          State = TState::__IDLE;
;;;545          return;
;;;546        }
;;;547      }
;;;548    
;;;549      for ( uint8_t Ctr = 0U; Ctr < m4RegInfo.Qty; ++Ctr )
;;;550      {
;;;551        uint16_t CurAddr = m4RegInfo.StartAddr + Ctr;
;;;552        const TRegVal *RegVal = &InputPkt->First + Ctr;
;;;553    
;;;554        TPDU *PDU =
;;;555        std::find_if( beg, end, [ CurAddr ]( TPDU item ){
;;;556          return ( item.RegAddr == CurAddr );
;;;557        } );
;;;558        
;;;559        uint16_t Data = RegVal->Data;
;;;560        Data = RegVal->Part.Lo + ( RegVal->Part.Hi << 8U );
;;;561        ( this->*( PDU->Fnct ) )( reinterpret_cast<uint32_t>(&Data) );
;;;562      }
;;;563    
;;;564      m_read_input_registers_complete(); //по окончании вызывается callback, реализация устройствозависимая
;;;565    
;;;566      State = TState::__IDLE;
;;;567    }
00003a  b00b              ADD      sp,sp,#0x2c
00003c  e8bd8ff0          POP      {r4-r11,pc}
                  |L15.64|
000040  2100              MOVS     r1,#0                 ;532
000042  e029              B        |L15.152|
                  |L15.68|
000044  f8b4025a          LDRH     r0,[r4,#0x25a]        ;534
000048  4408              ADD      r0,r0,r1              ;534
00004a  b285              UXTH     r5,r0                 ;534
00004c  4658              MOV      r0,r11                ;536
00004e  4643              MOV      r3,r8                 ;536
000050  9509              STR      r5,[sp,#0x24]         ;536
000052  9508              STR      r5,[sp,#0x20]         ;536
000054  e000              B        |L15.88|
                  |L15.86|
000056  3010              ADDS     r0,r0,#0x10           ;536
                  |L15.88|
000058  4298              CMP      r0,r3                 ;536
00005a  d014              BEQ      |L15.134|
00005c  e9d0c901          LDRD     r12,r9,[r0,#4]        ;536
000060  f8d0a00c          LDR      r10,[r0,#0xc]         ;536
000064  6806              LDR      r6,[r0,#0]            ;536
000066  e9cdc905          STRD     r12,r9,[sp,#0x14]     ;536
00006a  f8cda01c          STR      r10,[sp,#0x1c]        ;536
00006e  9604              STR      r6,[sp,#0x10]         ;536
000070  f8bd6012          LDRH     r6,[sp,#0x12]         ;538
000074  f8bdc020          LDRH     r12,[sp,#0x20]        ;538
000078  4566              CMP      r6,r12                ;538
00007a  d101              BNE      |L15.128|
00007c  2601              MOVS     r6,#1                 ;538
00007e  e000              B        |L15.130|
                  |L15.128|
000080  2600              MOVS     r6,#0                 ;538
                  |L15.130|
000082  2e00              CMP      r6,#0                 ;538
000084  d0e7              BEQ      |L15.86|
                  |L15.134|
000086  4602              MOV      r2,r0                 ;536
000088  4542              CMP      r2,r8                 ;541
00008a  d103              BNE      |L15.148|
00008c  2000              MOVS     r0,#0                 ;544
00008e  f8840230          STRB     r0,[r4,#0x230]        ;544
000092  e7d2              B        |L15.58|
                  |L15.148|
000094  1c48              ADDS     r0,r1,#1              ;532
000096  b2c1              UXTB     r1,r0                 ;532
                  |L15.152|
000098  f44f7017          MOV      r0,#0x25c             ;532
00009c  5b00              LDRH     r0,[r0,r4]            ;532
00009e  4288              CMP      r0,r1                 ;532
0000a0  dcd0              BGT      |L15.68|
0000a2  2600              MOVS     r6,#0                 ;549
0000a4  e044              B        |L15.304|
                  |L15.166|
0000a6  f8b4025a          LDRH     r0,[r4,#0x25a]        ;551
0000aa  4430              ADD      r0,r0,r6              ;551
0000ac  b280              UXTH     r0,r0                 ;551
0000ae  9006              STR      r0,[sp,#0x18]         ;551
0000b0  980a              LDR      r0,[sp,#0x28]         ;552
0000b2  1cc0              ADDS     r0,r0,#3              ;552
0000b4  eb000a46          ADD      r10,r0,r6,LSL #1      ;552
0000b8  4658              MOV      r0,r11                ;554
0000ba  4641              MOV      r1,r8                 ;554
0000bc  9a06              LDR      r2,[sp,#0x18]         ;554
0000be  9209              STR      r2,[sp,#0x24]         ;554
0000c0  9204              STR      r2,[sp,#0x10]         ;554
0000c2  e000              B        |L15.198|
                  |L15.196|
0000c4  3010              ADDS     r0,r0,#0x10           ;554
                  |L15.198|
0000c6  4288              CMP      r0,r1                 ;554
0000c8  d00e              BEQ      |L15.232|
0000ca  e890500c          LDM      r0,{r2,r3,r12,lr}     ;554
0000ce  e88d500c          STM      sp,{r2,r3,r12,lr}     ;554
0000d2  f8bd2002          LDRH     r2,[sp,#2]            ;556
0000d6  f8bd3010          LDRH     r3,[sp,#0x10]         ;556
0000da  429a              CMP      r2,r3                 ;556
0000dc  d101              BNE      |L15.226|
0000de  2201              MOVS     r2,#1                 ;556
0000e0  e000              B        |L15.228|
                  |L15.226|
0000e2  2200              MOVS     r2,#0                 ;556
                  |L15.228|
0000e4  2a00              CMP      r2,#0                 ;556
0000e6  d0ed              BEQ      |L15.196|
                  |L15.232|
0000e8  4605              MOV      r5,r0                 ;554
0000ea  f8ba0000          LDRH     r0,[r10,#0]           ;559
0000ee  9005              STR      r0,[sp,#0x14]         ;559
0000f0  f89a0001          LDRB     r0,[r10,#1]           ;560
0000f4  f89a1000          LDRB     r1,[r10,#0]           ;560
0000f8  eb002001          ADD      r0,r0,r1,LSL #8       ;560
0000fc  b280              UXTH     r0,r0                 ;560
0000fe  9005              STR      r0,[sp,#0x14]         ;560
000100  f504700e          ADD      r0,r4,#0x238          ;561
000104  68e9              LDR      r1,[r5,#0xc]          ;561
000106  eb000961          ADD      r9,r0,r1,ASR #1       ;561
00010a  7b28              LDRB     r0,[r5,#0xc]          ;561
00010c  f0000001          AND      r0,r0,#1              ;561
000110  b908              CBNZ     r0,|L15.278|
000112  68a8              LDR      r0,[r5,#8]            ;561
000114  e005              B        |L15.290|
                  |L15.278|
000116  f8d90000          LDR      r0,[r9,#0]            ;561
00011a  68a9              LDR      r1,[r5,#8]            ;561
00011c  4408              ADD      r0,r0,r1              ;561
00011e  9008              STR      r0,[sp,#0x20]         ;561
000120  6800              LDR      r0,[r0,#0]            ;561
                  |L15.290|
000122  a905              ADD      r1,sp,#0x14           ;561
000124  9007              STR      r0,[sp,#0x1c]         ;561
000126  4648              MOV      r0,r9                 ;561
000128  9a07              LDR      r2,[sp,#0x1c]         ;561
00012a  4790              BLX      r2                    ;561
00012c  1c70              ADDS     r0,r6,#1              ;549
00012e  b2c6              UXTB     r6,r0                 ;549
                  |L15.304|
000130  f44f7017          MOV      r0,#0x25c             ;549
000134  5b00              LDRH     r0,[r0,r4]            ;549
000136  42b0              CMP      r0,r6                 ;549
000138  dcb5              BGT      |L15.166|
00013a  f504700e          ADD      r0,r4,#0x238          ;564
00013e  f7fffffe          BL       _ZN12TDevHandlers31m_read_input_registers_completeEv ; TDevHandlers::m_read_input_registers_complete()
000142  2000              MOVS     r0,#0                 ;566
000144  f8840230          STRB     r0,[r4,#0x230]        ;566
000148  bf00              NOP      
00014a  e776              B        |L15.58|
;;;568    
                          ENDP


                          AREA ||i._ZN10TModbusApp22s_read_discrete_inputsEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp22s_read_discrete_inputsEPht PROC ; TModbusApp::s_read_discrete_inputs(unsigned char*, unsigned short)
;;;656      
;;;657    void TModbusApp::s_read_discrete_inputs( uint8_t *Buf, uint16_t BUF_SIZE ) //2
000000  b570              PUSH     {r4-r6,lr}
;;;658    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;659      read_bits( Buf, BUF_SIZE, TMbFnct::__READ_DISCRETE_INPUTS );
000008  2302              MOVS     r3,#2
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp9read_bitsEPhtNS_7TMbFnctE ; TModbusApp::read_bits(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;660    }
000014  bd70              POP      {r4-r6,pc}
;;;661      
                          ENDP


                          AREA ||i._ZN10TModbusApp22s_read_input_registersEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp22s_read_input_registersEPht PROC ; TModbusApp::s_read_input_registers(unsigned char*, unsigned short)
;;;666      
;;;667    void TModbusApp::s_read_input_registers( uint8_t *Buf, uint16_t BUF_SIZE ) //4
000000  b570              PUSH     {r4-r6,lr}
;;;668    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;669      read_regs( Buf, BUF_SIZE, TMbFnct::__READ_INPUT_REGISTERS );
000008  2304              MOVS     r3,#4
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp9read_regsEPhtNS_7TMbFnctE ; TModbusApp::read_regs(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;670    }
000014  bd70              POP      {r4-r6,pc}
;;;671      
                          ENDP


                          AREA ||i._ZN10TModbusApp23m_write_single_registerEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp23m_write_single_registerEPht PROC ; TModbusApp::m_write_single_register(unsigned char*, unsigned short)
;;;608    
;;;609    void TModbusApp::m_write_single_register( uint8_t *Buf, uint16_t BUF_SIZE ) //6
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;610    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
;;;611      auto beg = &PduHandler->Buf[ 0 ];
00000a  f8d40238          LDR      r0,[r4,#0x238]
00000e  f8d0a000          LDR      r10,[r0,#0]
;;;612    	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000012  f8d40238          LDR      r0,[r4,#0x238]
000016  6800              LDR      r0,[r0,#0]
000018  f8d41238          LDR      r1,[r4,#0x238]
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001801          ADD      r8,r0,r1,LSL #4
;;;613          
;;;614    	__packed struct TBasic
;;;615    	{
;;;616    		uint8_t        Addr;
;;;617    		uint8_t        FnctCode;
;;;618        THalfWordParse RegAddr;
;;;619        uint16_t       RegVal;
;;;620        uint16_t       Crc;		
;;;621    	};
;;;622    
;;;623      const TBasic *InputPkt = reinterpret_cast<const TBasic *>(Buf);
000022  4637              MOV      r7,r6
;;;624      
;;;625      TLittleEndian RegAddr;
;;;626      RegAddr.Segment.Lo = InputPkt->RegAddr.Segment.Lo;
000024  78f8              LDRB     r0,[r7,#3]
000026  f88d0014          STRB     r0,[sp,#0x14]
;;;627      RegAddr.Segment.Hi = InputPkt->RegAddr.Segment.Hi;
00002a  78b8              LDRB     r0,[r7,#2]
00002c  f88d0015          STRB     r0,[sp,#0x15]
;;;628      
;;;629      TPDU *PDU =
000030  4650              MOV      r0,r10
000032  4641              MOV      r1,r8
000034  9a05              LDR      r2,[sp,#0x14]
000036  9206              STR      r2,[sp,#0x18]
000038  9204              STR      r2,[sp,#0x10]
00003a  e000              B        |L18.62|
                  |L18.60|
00003c  3010              ADDS     r0,r0,#0x10
                  |L18.62|
00003e  4288              CMP      r0,r1
000040  d012              BEQ      |L18.104|
000042  e890100c          LDM      r0,{r2,r3,r12}
000046  f8d0900c          LDR      r9,[r0,#0xc]
00004a  e88d100c          STM      sp,{r2,r3,r12}
00004e  f8cd900c          STR      r9,[sp,#0xc]
;;;630      std::find_if( beg, end, [ RegAddr ]( TPDU item ){
;;;631        return ( item.RegAddr == RegAddr.Val );
000052  f8bd2002          LDRH     r2,[sp,#2]
000056  f8bd3010          LDRH     r3,[sp,#0x10]
00005a  429a              CMP      r2,r3
00005c  d101              BNE      |L18.98|
00005e  2201              MOVS     r2,#1
000060  e000              B        |L18.100|
                  |L18.98|
000062  2200              MOVS     r2,#0
                  |L18.100|
000064  2a00              CMP      r2,#0
000066  d0e9              BEQ      |L18.60|
                  |L18.104|
000068  4605              MOV      r5,r0                 ;629
;;;632      } );
;;;633      
;;;634      if ( PDU == end )
00006a  4545              CMP      r5,r8
00006c  d019              BEQ      |L18.162|
;;;635      {
;;;636        //регистр не найден
;;;637        //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;638        //return;
;;;639      }
;;;640      else
;;;641      {
;;;642        uint16_t Data = InputPkt->RegVal;    
00006e  88b8              LDRH     r0,[r7,#4]
000070  9003              STR      r0,[sp,#0xc]
;;;643        ( this->*( PDU->Fnct ) )( reinterpret_cast<uint32_t>( &Data ) );    
000072  f504700e          ADD      r0,r4,#0x238
000076  68e9              LDR      r1,[r5,#0xc]
000078  eb000961          ADD      r9,r0,r1,ASR #1
00007c  7b28              LDRB     r0,[r5,#0xc]
00007e  f0000001          AND      r0,r0,#1
000082  b908              CBNZ     r0,|L18.136|
000084  68a8              LDR      r0,[r5,#8]
000086  e006              B        |L18.150|
                  |L18.136|
000088  f8d90000          LDR      r0,[r9,#0]
00008c  68a9              LDR      r1,[r5,#8]
00008e  eb000b01          ADD      r11,r0,r1
000092  f8db0000          LDR      r0,[r11,#0]
                  |L18.150|
000096  a903              ADD      r1,sp,#0xc
000098  9004              STR      r0,[sp,#0x10]
00009a  4648              MOV      r0,r9
00009c  9a04              LDR      r2,[sp,#0x10]
00009e  4790              BLX      r2
;;;644      }
0000a0  bf00              NOP      
                  |L18.162|
;;;645      
;;;646      State = TState::__IDLE;
0000a2  2000              MOVS     r0,#0
0000a4  f8840230          STRB     r0,[r4,#0x230]
;;;647    }
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  e8bd8ff0          POP      {r4-r11,pc}
;;;648    
                          ENDP


                          AREA ||i._ZN10TModbusApp23s_write_single_registerEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp23s_write_single_registerEPht PROC ; TModbusApp::s_write_single_register(unsigned char*, unsigned short)
;;;676      
;;;677    void TModbusApp::s_write_single_register( uint8_t *Buf, uint16_t BUF_SIZE ) //6
000000  b570              PUSH     {r4-r6,lr}
;;;678    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;679      write_single( Buf, BUF_SIZE, TMbFnct::__WRITE_SINGLE_REGISTER );                                                                                             
000008  2306              MOVS     r3,#6
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp12write_singleEPhtNS_7TMbFnctE ; TModbusApp::write_single(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;680    }
000014  bd70              POP      {r4-r6,pc}
;;;681    
                          ENDP


                          AREA ||i._ZN10TModbusApp24m_read_holding_registersEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp24m_read_holding_registersEPht PROC ; TModbusApp::m_read_holding_registers(unsigned char*, unsigned short)
;;;428    
;;;429    void TModbusApp::m_read_holding_registers( uint8_t *Buf, uint16_t BUF_SIZE ) //3
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;430    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
;;;431      auto beg = &PduHandler->Buf[ 0 ];
00000a  f8d40238          LDR      r0,[r4,#0x238]
00000e  f8d0b000          LDR      r11,[r0,#0]
;;;432    	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000012  f8d40238          LDR      r0,[r4,#0x238]
000016  6800              LDR      r0,[r0,#0]
000018  f8d41238          LDR      r1,[r4,#0x238]
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001801          ADD      r8,r0,r1,LSL #4
;;;433    	
;;;434      __packed union TRegVal
;;;435      {
;;;436        __packed struct
;;;437        {
;;;438          uint8_t Hi;
;;;439          uint8_t Lo;
;;;440        } Part;
;;;441        uint16_t Data;
;;;442      };
;;;443      
;;;444    	__packed struct TBasic
;;;445    	{
;;;446    		uint8_t Addr;
;;;447    		uint8_t FnctCode;
;;;448        uint8_t BytesQty;
;;;449        TRegVal First;			
;;;450    	};
;;;451    	
;;;452    	const TBasic *InputPkt = reinterpret_cast<const TBasic *>(Buf);
000022  970a              STR      r7,[sp,#0x28]
;;;453      
;;;454      if ( InputPkt->BytesQty != m3RegInfo.Qty * 2U ) //если количество принятых байтов с данными не равно количеству запрошенных
000024  9f0a              LDR      r7,[sp,#0x28]
000026  78b9              LDRB     r1,[r7,#2]
000028  f44f7016          MOV      r0,#0x258
00002c  5b00              LDRH     r0,[r0,r4]
00002e  ebb10f40          CMP      r1,r0,LSL #1
000032  d005              BEQ      |L20.64|
;;;455      {
;;;456        //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;457        State = TState::__IDLE;
000034  2000              MOVS     r0,#0
000036  f8840230          STRB     r0,[r4,#0x230]
                  |L20.58|
;;;458        
;;;459        return;
;;;460      }
;;;461     
;;;462      for ( uint8_t Ctr = 0U; Ctr < m3RegInfo.Qty; ++Ctr ) //Проверить существования всех регистров, которые пришли в ответном пакете
;;;463      {
;;;464        uint16_t CurAddr = m3RegInfo.StartAddr + Ctr;
;;;465        
;;;466        TPDU *PDU =
;;;467        std::find_if( beg, end, [ CurAddr ]( TPDU item ){
;;;468          return ( item.RegAddr == CurAddr );
;;;469        } );
;;;470        
;;;471        if ( PDU == end ) //если регистр не найден
;;;472        {
;;;473          //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;474          State = TState::__IDLE;
;;;475          return;
;;;476        }
;;;477      }
;;;478    
;;;479      for ( uint8_t Ctr = 0U; Ctr < m3RegInfo.Qty; ++Ctr )
;;;480      {
;;;481        uint16_t CurAddr = m3RegInfo.StartAddr + Ctr;
;;;482        const TRegVal *RegVal = &InputPkt->First + Ctr;
;;;483    
;;;484        TPDU *PDU =
;;;485        std::find_if( beg, end, [ CurAddr ]( TPDU item ){
;;;486          return ( item.RegAddr == CurAddr );
;;;487        } );
;;;488        
;;;489        uint16_t Data = RegVal->Data;
;;;490        Data = RegVal->Part.Lo + ( RegVal->Part.Hi << 8U );
;;;491        ( this->*( PDU->Fnct ) )( reinterpret_cast<uint32_t>(&Data) );
;;;492      }
;;;493    
;;;494    //  m_read_input_registers_complete(); //по окончании вызывается callback, реализация устройствозависимая
;;;495    
;;;496      State = TState::__IDLE;
;;;497    }
00003a  b00b              ADD      sp,sp,#0x2c
00003c  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.64|
000040  2100              MOVS     r1,#0                 ;462
000042  e029              B        |L20.152|
                  |L20.68|
000044  f8b40256          LDRH     r0,[r4,#0x256]        ;464
000048  4408              ADD      r0,r0,r1              ;464
00004a  b285              UXTH     r5,r0                 ;464
00004c  4658              MOV      r0,r11                ;466
00004e  4643              MOV      r3,r8                 ;466
000050  9509              STR      r5,[sp,#0x24]         ;466
000052  9508              STR      r5,[sp,#0x20]         ;466
000054  e000              B        |L20.88|
                  |L20.86|
000056  3010              ADDS     r0,r0,#0x10           ;466
                  |L20.88|
000058  4298              CMP      r0,r3                 ;466
00005a  d014              BEQ      |L20.134|
00005c  e9d0c901          LDRD     r12,r9,[r0,#4]        ;466
000060  f8d0a00c          LDR      r10,[r0,#0xc]         ;466
000064  6806              LDR      r6,[r0,#0]            ;466
000066  e9cdc905          STRD     r12,r9,[sp,#0x14]     ;466
00006a  f8cda01c          STR      r10,[sp,#0x1c]        ;466
00006e  9604              STR      r6,[sp,#0x10]         ;466
000070  f8bd6012          LDRH     r6,[sp,#0x12]         ;468
000074  f8bdc020          LDRH     r12,[sp,#0x20]        ;468
000078  4566              CMP      r6,r12                ;468
00007a  d101              BNE      |L20.128|
00007c  2601              MOVS     r6,#1                 ;468
00007e  e000              B        |L20.130|
                  |L20.128|
000080  2600              MOVS     r6,#0                 ;468
                  |L20.130|
000082  2e00              CMP      r6,#0                 ;468
000084  d0e7              BEQ      |L20.86|
                  |L20.134|
000086  4602              MOV      r2,r0                 ;466
000088  4542              CMP      r2,r8                 ;471
00008a  d103              BNE      |L20.148|
00008c  2000              MOVS     r0,#0                 ;474
00008e  f8840230          STRB     r0,[r4,#0x230]        ;474
000092  e7d2              B        |L20.58|
                  |L20.148|
000094  1c48              ADDS     r0,r1,#1              ;462
000096  b2c1              UXTB     r1,r0                 ;462
                  |L20.152|
000098  f44f7016          MOV      r0,#0x258             ;462
00009c  5b00              LDRH     r0,[r0,r4]            ;462
00009e  4288              CMP      r0,r1                 ;462
0000a0  dcd0              BGT      |L20.68|
0000a2  2600              MOVS     r6,#0                 ;479
0000a4  e044              B        |L20.304|
                  |L20.166|
0000a6  f8b40256          LDRH     r0,[r4,#0x256]        ;481
0000aa  4430              ADD      r0,r0,r6              ;481
0000ac  b280              UXTH     r0,r0                 ;481
0000ae  9006              STR      r0,[sp,#0x18]         ;481
0000b0  980a              LDR      r0,[sp,#0x28]         ;482
0000b2  1cc0              ADDS     r0,r0,#3              ;482
0000b4  eb000a46          ADD      r10,r0,r6,LSL #1      ;482
0000b8  4658              MOV      r0,r11                ;484
0000ba  4641              MOV      r1,r8                 ;484
0000bc  9a06              LDR      r2,[sp,#0x18]         ;484
0000be  9209              STR      r2,[sp,#0x24]         ;484
0000c0  9204              STR      r2,[sp,#0x10]         ;484
0000c2  e000              B        |L20.198|
                  |L20.196|
0000c4  3010              ADDS     r0,r0,#0x10           ;484
                  |L20.198|
0000c6  4288              CMP      r0,r1                 ;484
0000c8  d00e              BEQ      |L20.232|
0000ca  e890500c          LDM      r0,{r2,r3,r12,lr}     ;484
0000ce  e88d500c          STM      sp,{r2,r3,r12,lr}     ;484
0000d2  f8bd2002          LDRH     r2,[sp,#2]            ;486
0000d6  f8bd3010          LDRH     r3,[sp,#0x10]         ;486
0000da  429a              CMP      r2,r3                 ;486
0000dc  d101              BNE      |L20.226|
0000de  2201              MOVS     r2,#1                 ;486
0000e0  e000              B        |L20.228|
                  |L20.226|
0000e2  2200              MOVS     r2,#0                 ;486
                  |L20.228|
0000e4  2a00              CMP      r2,#0                 ;486
0000e6  d0ed              BEQ      |L20.196|
                  |L20.232|
0000e8  4605              MOV      r5,r0                 ;484
0000ea  f8ba0000          LDRH     r0,[r10,#0]           ;489
0000ee  9005              STR      r0,[sp,#0x14]         ;489
0000f0  f89a0001          LDRB     r0,[r10,#1]           ;490
0000f4  f89a1000          LDRB     r1,[r10,#0]           ;490
0000f8  eb002001          ADD      r0,r0,r1,LSL #8       ;490
0000fc  b280              UXTH     r0,r0                 ;490
0000fe  9005              STR      r0,[sp,#0x14]         ;490
000100  f504700e          ADD      r0,r4,#0x238          ;491
000104  68e9              LDR      r1,[r5,#0xc]          ;491
000106  eb000961          ADD      r9,r0,r1,ASR #1       ;491
00010a  7b28              LDRB     r0,[r5,#0xc]          ;491
00010c  f0000001          AND      r0,r0,#1              ;491
000110  b908              CBNZ     r0,|L20.278|
000112  68a8              LDR      r0,[r5,#8]            ;491
000114  e005              B        |L20.290|
                  |L20.278|
000116  f8d90000          LDR      r0,[r9,#0]            ;491
00011a  68a9              LDR      r1,[r5,#8]            ;491
00011c  4408              ADD      r0,r0,r1              ;491
00011e  9008              STR      r0,[sp,#0x20]         ;491
000120  6800              LDR      r0,[r0,#0]            ;491
                  |L20.290|
000122  a905              ADD      r1,sp,#0x14           ;491
000124  9007              STR      r0,[sp,#0x1c]         ;491
000126  4648              MOV      r0,r9                 ;491
000128  9a07              LDR      r2,[sp,#0x1c]         ;491
00012a  4790              BLX      r2                    ;491
00012c  1c70              ADDS     r0,r6,#1              ;479
00012e  b2c6              UXTB     r6,r0                 ;479
                  |L20.304|
000130  f44f7016          MOV      r0,#0x258             ;479
000134  5b00              LDRH     r0,[r0,r4]            ;479
000136  42b0              CMP      r0,r6                 ;479
000138  dcb5              BGT      |L20.166|
00013a  2000              MOVS     r0,#0                 ;496
00013c  f8840230          STRB     r0,[r4,#0x230]        ;496
000140  bf00              NOP      
000142  e77a              B        |L20.58|
;;;498    
                          ENDP


                          AREA ||i._ZN10TModbusApp24s_formatting_error_replyEPh||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp24s_formatting_error_replyEPh PROC ; TModbusApp::s_formatting_error_reply(unsigned char*)
;;;327    
;;;328    void TModbusApp::s_formatting_error_reply( uint8_t *Buf )
000000  b570              PUSH     {r4-r6,lr}
;;;329    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;330      __packed struct TExceptPkt
;;;331      {
;;;332        uint8_t  Addr;
;;;333        uint8_t  FnctCode;
;;;334        uint8_t  ExcCode;
;;;335      };
;;;336      
;;;337      __packed struct TErrorPkt
;;;338      {
;;;339        TExceptPkt ExceptPkt;
;;;340        uint16_t   Crc;
;;;341      };
;;;342      
;;;343      *( TExceptPkt *)TxBuf = *( TExceptPkt *)Buf;
000006  f44f708b          MOV      r0,#0x116
00000a  8829              LDRH     r1,[r5,#0]
00000c  f8a41114          STRH     r1,[r4,#0x114]
000010  78a9              LDRB     r1,[r5,#2]
000012  5501              STRB     r1,[r0,r4]
;;;344      ( (TErrorPkt *)TxBuf )->Crc = CRC16( TxBuf, sizeof (TExceptPkt) );
000014  2103              MOVS     r1,#3
000016  f504708a          ADD      r0,r4,#0x114
00001a  f7fffffe          BL       CRC16
00001e  f504718a          ADD      r1,r4,#0x114
000022  f8a40117          STRH     r0,[r4,#0x117]
;;;345    
;;;346      if ( (( TExceptPkt *)TxBuf)->FnctCode == 1U )
000026  f2401015          MOV      r0,#0x115
00002a  5d00              LDRB     r0,[r0,r4]
00002c  2801              CMP      r0,#1
00002e  d104              BNE      |L21.58|
;;;347      {
;;;348        static uint8_t Ctr = 0U;
;;;349        
;;;350        ++Ctr;
000030  4806              LDR      r0,|L21.76|
000032  7800              LDRB     r0,[r0,#0]  ; _ZZN10TModbusApp24s_formatting_error_replyEPhE3Ctr
000034  1c40              ADDS     r0,r0,#1
000036  4905              LDR      r1,|L21.76|
000038  7008              STRB     r0,[r1,#0]
                  |L21.58|
;;;351      }
;;;352      
;;;353    	start_transmit( sizeof (TErrorPkt) ); //отправить сформированый пакет
00003a  2105              MOVS     r1,#5
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
;;;354      
;;;355      State = TState::__IDLE;
000042  2000              MOVS     r0,#0
000044  f8840230          STRB     r0,[r4,#0x230]
;;;356    }
000048  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

00004a  0000              DCW      0x0000
                  |L21.76|
                          DCD      _ZZN10TModbusApp24s_formatting_error_replyEPhE3Ctr ; TModbusApp::s_formatting_error_reply(unsigned char*)::Ctr

                          AREA ||i._ZN10TModbusApp24s_read_holding_registersEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp24s_read_holding_registersEPht PROC ; TModbusApp::s_read_holding_registers(unsigned char*, unsigned short)
;;;661      
;;;662    void TModbusApp::s_read_holding_registers( uint8_t *Buf, uint16_t BUF_SIZE ) //3
000000  b570              PUSH     {r4-r6,lr}
;;;663    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;664      read_regs( Buf, BUF_SIZE, TMbFnct::__READ_HOLDING_REGISTERS );
000008  2303              MOVS     r3,#3
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp9read_regsEPhtNS_7TMbFnctE ; TModbusApp::read_regs(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;665    }
000014  bd70              POP      {r4-r6,pc}
;;;666      
                          ENDP


                          AREA ||i._ZN10TModbusApp25s_formatting_normal_replyEv||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp25s_formatting_normal_replyEv PROC ; TModbusApp::s_formatting_normal_reply()
;;;258    
;;;259    void TModbusApp::s_formatting_normal_reply()
000000  4770              BX       lr
;;;260    {
;;;261    
;;;262    }
;;;263    
                          ENDP


                          AREA ||i._ZN10TModbusApp25s_write_multiple_registerEPht||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp25s_write_multiple_registerEPht PROC ; TModbusApp::s_write_multiple_register(unsigned char*, unsigned short)
;;;681    
;;;682    void TModbusApp::s_write_multiple_register( uint8_t *Buf, uint16_t BUF_SIZE ) //16
000000  b570              PUSH     {r4-r6,lr}
;;;683    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;684      write_mul( Buf, BUF_SIZE, TMbFnct::__WRITE_MULTIPLE_REGISTERS );
000008  2310              MOVS     r3,#0x10
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN10TModbusApp9write_mulEPhtNS_7TMbFnctE ; TModbusApp::write_mul(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;685    }
000014  bd70              POP      {r4-r6,pc}
;;;686    
                          ENDP


                          AREA ||i._ZN10TModbusApp26m_waiting_turnaround_delayEv||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp26m_waiting_turnaround_delayEv PROC ; TModbusApp::m_waiting_turnaround_delay()
;;;363    
;;;364    void TModbusApp::m_waiting_turnaround_delay() //реализация при необходимости широковещательного режима
000000  4770              BX       lr
;;;365    {
;;;366    
;;;367    }
;;;368    
                          ENDP


                          AREA ||i._ZN10TModbusApp28s_processing_required_actionEPht||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp28s_processing_required_actionEPht PROC ; TModbusApp::s_processing_required_action(unsigned char*, unsigned short)
;;;263    
;;;264    void TModbusApp::s_processing_required_action( uint8_t *Buf, uint16_t BUF_SIZE )
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;265    {
000004  b0a1              SUB      sp,sp,#0x84
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
00000a  4691              MOV      r9,r2
;;;266      typedef void (TModbusApp::*TFnct)( uint8_t *, uint16_t );
;;;267      
;;;268      struct TAction
;;;269      {
;;;270        uint8_t Code;
;;;271        TFnct   Fnct;
;;;272      };
;;;273    
;;;274      TAction Action[] =
00000c  226c              MOVS     r2,#0x6c
00000e  4924              LDR      r1,|L26.160|
000010  a805              ADD      r0,sp,#0x14
000012  f7fffffe          BL       __aeabi_memcpy4
;;;275      {
;;;276        { TMbFnct::__READ_COILS,               &TModbusApp::s_read_coils,              },
;;;277        { TMbFnct::__READ_DISCRETE_INPUTS,     &TModbusApp::s_read_discrete_inputs,    },
;;;278        { TMbFnct::__READ_HOLDING_REGISTERS,   &TModbusApp::s_read_holding_registers,  },
;;;279        { TMbFnct::__READ_INPUT_REGISTERS,     &TModbusApp::s_read_input_registers,    },
;;;280        { TMbFnct::__WRITE_SINGLE_COIL,        &TModbusApp::s_write_single_coil,       },
;;;281        { TMbFnct::__WRITE_SINGLE_REGISTER,    &TModbusApp::s_write_single_register,   },
;;;282        { TMbFnct::__WRITE_MULTIPLE_REGISTERS, &TModbusApp::s_write_multiple_register, },
;;;283        { TMbFnct::__REPORT_SERVER_ID,         &TModbusApp::s_report_server_id,        },
;;;284        { TMbFnct::__BOOT_MODE,                &TModbusApp::s_boot_mode,               },
;;;285      };
;;;286        
;;;287      constexpr uint8_t ACTION_SIZE = sizeof Action / sizeof Action[0];
000016  2009              MOVS     r0,#9
000018  9004              STR      r0,[sp,#0x10]
;;;288      
;;;289      auto beg = &Action[0];
00001a  f10d0a14          ADD      r10,sp,#0x14
;;;290      auto end = &Action[ACTION_SIZE];
00001e  af20              ADD      r7,sp,#0x80
;;;291      
;;;292    	TAction *CurAction = 
000020  4650              MOV      r0,r10
000022  4639              MOV      r1,r7
000024  9520              STR      r5,[sp,#0x80]
000026  9503              STR      r5,[sp,#0xc]
000028  e000              B        |L26.44|
                  |L26.42|
00002a  300c              ADDS     r0,r0,#0xc
                  |L26.44|
00002c  4288              CMP      r0,r1
00002e  d00e              BEQ      |L26.78|
000030  e890100c          LDM      r0,{r2,r3,r12}
000034  e88d100c          STM      sp,{r2,r3,r12}
;;;293    	std::find_if( beg, end, [ Buf ]( TAction item ){
;;;294    		return ( item.Code == Buf[ 1U ] );
000038  f89d2000          LDRB     r2,[sp,#0]
00003c  9b03              LDR      r3,[sp,#0xc]
00003e  785b              LDRB     r3,[r3,#1]
000040  429a              CMP      r2,r3
000042  d101              BNE      |L26.72|
000044  2201              MOVS     r2,#1
000046  e000              B        |L26.74|
                  |L26.72|
000048  2200              MOVS     r2,#0
                  |L26.74|
00004a  2a00              CMP      r2,#0
00004c  d0ed              BEQ      |L26.42|
                  |L26.78|
00004e  4604              MOV      r4,r0                 ;292
;;;295    	} );
;;;296    	
;;;297      //проверка поддержки сервером запрошенной функции
;;;298    	if (
000050  42a7              CMP      r7,r4
000052  d10c              BNE      |L26.110|
;;;299    			end == CurAction
;;;300    		 )                                                                    
;;;301    	{
;;;302    		//сформировать и отправить пакет с кодом исключения 1 (ILLEGAL FUNCTION)
;;;303    		Buf[ 1U ] |= 0x80;                                  //Function
000054  7868              LDRB     r0,[r5,#1]
000056  f0400080          ORR      r0,r0,#0x80
00005a  7068              STRB     r0,[r5,#1]
;;;304    		Buf[ 2U ] = TExceptCodes::__ILLEGAL_FNCT;           //Exception Code
00005c  2001              MOVS     r0,#1
00005e  70a8              STRB     r0,[r5,#2]
;;;305    
;;;306    //		State = TState::__FORMATTING_ERROR_REPLY;
;;;307        s_formatting_error_reply( Buf );
000060  4629              MOV      r1,r5
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
                  |L26.104|
;;;308        
;;;309        return;
;;;310    	}
;;;311    	else
;;;312    	{
;;;313    //    Do.closed();
;;;314    //    Do.toggle();
;;;315    //    if ( Buf[ 1U ] == 5U )
;;;316    //    {
;;;317    //      Do.closed();
;;;318    //    }
;;;319    //    if ( Buf[ 1U ] == 4U )
;;;320    //    {
;;;321    //      Do.open();
;;;322    //    }
;;;323        
;;;324    	  ( this->*(CurAction->Fnct) )( Buf, BUF_SIZE ); //выполнение требуемой функции
;;;325    	}
;;;326    }
000068  b021              ADD      sp,sp,#0x84
00006a  e8bd8ff0          POP      {r4-r11,pc}
                  |L26.110|
00006e  68a0              LDR      r0,[r4,#8]            ;324
000070  eb060860          ADD      r8,r6,r0,ASR #1       ;324
000074  7a20              LDRB     r0,[r4,#8]            ;324
000076  f0000001          AND      r0,r0,#1              ;324
00007a  b908              CBNZ     r0,|L26.128|
00007c  6860              LDR      r0,[r4,#4]            ;324
00007e  e006              B        |L26.142|
                  |L26.128|
000080  f8d80000          LDR      r0,[r8,#0]            ;324
000084  6861              LDR      r1,[r4,#4]            ;324
000086  eb000b01          ADD      r11,r0,r1             ;324
00008a  f8db0000          LDR      r0,[r11,#0]           ;324
                  |L26.142|
00008e  464a              MOV      r2,r9                 ;324
000090  4629              MOV      r1,r5                 ;324
000092  9003              STR      r0,[sp,#0xc]          ;324
000094  4640              MOV      r0,r8                 ;324
000096  9b03              LDR      r3,[sp,#0xc]          ;324
000098  4798              BLX      r3                    ;324
00009a  bf00              NOP                            ;325
00009c  bf00              NOP      
00009e  e7e3              B        |L26.104|
;;;327    
                          ENDP

                  |L26.160|
                          DCD      ||.constdata||+0xbc

                          AREA ||i._ZN10TModbusApp3fsmEv||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp3fsmEv PROC ; TModbusApp::fsm()
;;;76     
;;;77     void TModbusApp::fsm()
000000  b5f0              PUSH     {r4-r7,lr}
;;;78     {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;79       typedef void (TModbusApp::*TFnct)();
;;;80       
;;;81     //  constexpr uint16_t DLY_MS = 5U;
;;;82       
;;;83       TFnct Fnct[] =
000006  2218              MOVS     r2,#0x18
000008  4912              LDR      r1,|L27.84|
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;84       {
;;;85         &TModbusApp::idle,                       //начальное состояние после подачи питания
;;;86         &TModbusApp::s_checking_request,
;;;87         &TModbusApp::s_formatting_normal_reply
;;;88       };
;;;89       
;;;90       ( this->*Fnct[ State ] )();
000010  f8940230          LDRB     r0,[r4,#0x230]
000014  a901              ADD      r1,sp,#4
000016  eb0100c0          ADD      r0,r1,r0,LSL #3
00001a  6840              LDR      r0,[r0,#4]
00001c  eb040560          ADD      r5,r4,r0,ASR #1
000020  f8940230          LDRB     r0,[r4,#0x230]
000024  eb0100c0          ADD      r0,r1,r0,LSL #3
000028  7900              LDRB     r0,[r0,#4]
00002a  f0000001          AND      r0,r0,#1
00002e  b920              CBNZ     r0,|L27.58|
000030  f8940230          LDRB     r0,[r4,#0x230]
000034  f8510030          LDR      r0,[r1,r0,LSL #3]
000038  e007              B        |L27.74|
                  |L27.58|
00003a  f8941230          LDRB     r1,[r4,#0x230]
00003e  aa01              ADD      r2,sp,#4
000040  f8521031          LDR      r1,[r2,r1,LSL #3]
000044  6828              LDR      r0,[r5,#0]
000046  1846              ADDS     r6,r0,r1
000048  6830              LDR      r0,[r6,#0]
                  |L27.74|
00004a  4607              MOV      r7,r0
00004c  4628              MOV      r0,r5
00004e  47b8              BLX      r7
;;;91     }
000050  b007              ADD      sp,sp,#0x1c
000052  bdf0              POP      {r4-r7,pc}
;;;92     //-------------------------------------------------------------------------------------------------
                          ENDP

                  |L27.84|
                          DCD      ||.constdata||+0x10

                          AREA ||i._ZN10TModbusApp4idleEv||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp4idleEv PROC ; TModbusApp::idle()
;;;95     //----- обработчики состояний -------------------
;;;96     void TModbusApp::idle()
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
000002  4604              MOV      r4,r0
;;;98       //начальное состояние после подачи питания \
;;;99         ожидание принятия пакета с запросом
;;;100    //  IxSlice.Tail = IxSlice.Head;
;;;101      if ( get_eof( StrIx, ProcType ) == false ) //если нет неотправленного пакета
000004  f8941234          LDRB     r1,[r4,#0x234]
000008  f8940227          LDRB     r0,[r4,#0x227]
00000c  f7fffffe          BL       _Z7get_eofhN11TModbusLink9TProcTypeE ; get_eof(unsigned char, TModbusLink::TProcType)
000010  b918              CBNZ     r0,|L28.26|
;;;102      {
;;;103        if (
;;;104            StrIx == 0U
;;;105            &&      
;;;106            ProcType == TProcType::__SLAVE 
;;;107           )
;;;108        {
;;;109    //      Do.closed();
;;;110        }
;;;111        start_handle(); //запуск обработки пакета
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _ZN11TModbusLink12start_handleEv ; TModbusLink::start_handle()
000018  e003              B        |L28.34|
                  |L28.26|
;;;112      }
;;;113      else
;;;114      {
;;;115        if (
;;;116            StrIx == 0U
;;;117            &&      
;;;118            ProcType == TProcType::__MASTER 
;;;119           )
;;;120        {
;;;121    //      Do.toggle();
;;;122        }
;;;123        vTaskDelay( pdMS_TO_TICKS( 2U ) );
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       vTaskDelay
                  |L28.32|
;;;124        
;;;125        return; //есть неотправленный пакет => принимать нельзя
;;;126      }
;;;127     
;;;128    //  uint32_t xTicksToWait[] =
;;;129    //  {
;;;130    //    pdMS_TO_TICKS( 100U ), //__MASTER
;;;131    //    portMAX_DELAY,         //__SLAVE 
;;;132    //  };
;;;133      
;;;134      constexpr uint32_t xTicksToWait = 100U;
;;;135      
;;;136        if (
;;;137            StrIx == 0U
;;;138            &&      
;;;139            ProcType == TProcType::__SLAVE 
;;;140           )
;;;141        {
;;;142    //      Do.open();
;;;143        }
;;;144      if (
;;;145          xSemaphoreTake( *RtoTrigSem, xTicksToWait ) == pdPASS //ожидание срабатывания флага RTO в USART
;;;146          &&
;;;147          xSemaphoreTake( *CommErrSem, 0U ) == pdFAIL //семафор не был выдан
;;;148         )
;;;149      {
;;;150        if (
;;;151            StrIx == 0U
;;;152            &&      
;;;153            ProcType == TProcType::__SLAVE 
;;;154           )
;;;155        {
;;;156    //      Do.toggle();
;;;157        }
;;;158        
;;;159        State = TState::__CHECKING_REQUEST;
;;;160      }
;;;161      else
;;;162      {
;;;163        //на мастере здесь, возможно, необходимо выдавать семафор для повторной подачи запроса
;;;164        
;;;165        if ( ProcType == TProcType::__MASTER  )
;;;166        {
;;;167          stop_receive();                     
;;;168        }
;;;169        
;;;170        State = TState::__IDLE; //при приеме пакета произошли ошибки связи => пакет отбрасывается, ответ мастеру не возвращается
;;;171      }
;;;172    }
000020  bd70              POP      {r4-r6,pc}
                  |L28.34|
000022  2564              MOVS     r5,#0x64              ;134
000024  f8d41228          LDR      r1,[r4,#0x228]        ;144
000028  2300              MOVS     r3,#0                 ;144
00002a  2264              MOVS     r2,#0x64              ;144
00002c  6808              LDR      r0,[r1,#0]            ;144
00002e  4619              MOV      r1,r3                 ;144
000030  f7fffffe          BL       xQueueGenericReceive
000034  2801              CMP      r0,#1                 ;144
000036  d10c              BNE      |L28.82|
000038  f8d4122c          LDR      r1,[r4,#0x22c]        ;147
00003c  2300              MOVS     r3,#0                 ;147
00003e  461a              MOV      r2,r3                 ;147
000040  6808              LDR      r0,[r1,#0]            ;147
000042  4619              MOV      r1,r3                 ;147
000044  f7fffffe          BL       xQueueGenericReceive
000048  b918              CBNZ     r0,|L28.82|
00004a  2001              MOVS     r0,#1                 ;159
00004c  f8840230          STRB     r0,[r4,#0x230]        ;159
000050  e008              B        |L28.100|
                  |L28.82|
000052  f8940234          LDRB     r0,[r4,#0x234]        ;165
000056  b910              CBNZ     r0,|L28.94|
000058  4620              MOV      r0,r4                 ;167
00005a  f7fffffe          BL       _ZN11TModbusLink12stop_receiveEv ; TModbusLink::stop_receive()
                  |L28.94|
00005e  2000              MOVS     r0,#0                 ;170
000060  f8840230          STRB     r0,[r4,#0x230]        ;170
                  |L28.100|
000064  bf00              NOP      
000066  e7db              B        |L28.32|
;;;173    
                          ENDP


                          AREA ||i._ZN10TModbusApp6m_idleEv||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusApp6m_idleEv PROC ; TModbusApp::m_idle()
;;;358    //----- обработчики состояний для мастера -------
;;;359    void TModbusApp::m_idle()
000000  4770              BX       lr
;;;360    {
;;;361    
;;;362    }
;;;363    
                          ENDP


                          AREA ||i._ZN10TModbusApp9read_bitsEPhtNS_7TMbFnctE||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp9read_bitsEPhtNS_7TMbFnctE PROC ; TModbusApp::read_bits(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;761    
;;;762    void TModbusApp::read_bits( uint8_t *Buf, uint16_t BUF_SIZE, TMbFnct MbFnct )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;763    {
000004  b091              SUB      sp,sp,#0x44
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;764    	/*
;;;765    	Buf[0] - адрес
;;;766    	Buf[1] - код функции
;;;767    	Buf[2] - начальный адрес катушки (Hi)
;;;768    	Buf[3] - начальный адрес катушки (Lo)
;;;769    	Buf[4] - количество катушек (Hi)
;;;770    	Buf[5] - количество катушек (Lo)
;;;771    	Buf[6] - CRC (Lo)
;;;772    	Buf[7] - CRC (Hi)
;;;773    	*/
;;;774      TPDU *beg = &PduHandler->Buf[ 0 ];
00000a  f8d50238          LDR      r0,[r5,#0x238]
00000e  6800              LDR      r0,[r0,#0]
000010  9010              STR      r0,[sp,#0x40]
;;;775    	TPDU *end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000012  f8d50238          LDR      r0,[r5,#0x238]
000016  6800              LDR      r0,[r0,#0]
000018  f8d51238          LDR      r1,[r5,#0x238]
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001001          ADD      r0,r0,r1,LSL #4
000022  900f              STR      r0,[sp,#0x3c]
;;;776    	
;;;777    	struct TReadCoilsPkt
;;;778    	{
;;;779    		uint8_t Addr;
;;;780    		uint8_t FnctCode;
;;;781    		union
;;;782    		{
;;;783    			struct
;;;784    			{
;;;785    				uint8_t Hi;
;;;786    				uint8_t Lo;
;;;787    			} Part;
;;;788    			uint16_t Data;
;;;789    		} CoilAddr;
;;;790    		union
;;;791    		{
;;;792    			struct
;;;793    			{
;;;794    				uint8_t Hi;
;;;795    				uint8_t Lo;
;;;796    			} Part;
;;;797    			uint16_t Data;
;;;798    		} CoilQty;
;;;799    		union
;;;800    		{
;;;801    			struct
;;;802    			{
;;;803    				uint8_t Lo;
;;;804    				uint8_t Hi;
;;;805    			} Part;
;;;806    			uint16_t Data;
;;;807    		} Crc;			
;;;808    	};
;;;809    	
;;;810    	const TReadCoilsPkt *ReadCoilsPkt = reinterpret_cast<const TReadCoilsPkt *>(Buf);
000024  46a2              MOV      r10,r4
;;;811      uint16_t CoilAddr = ReadCoilsPkt->CoilAddr.Part.Lo + ( ReadCoilsPkt->CoilAddr.Part.Hi << 8U );
000026  f89a0003          LDRB     r0,[r10,#3]
00002a  f89a1002          LDRB     r1,[r10,#2]
00002e  eb002001          ADD      r0,r0,r1,LSL #8
000032  b280              UXTH     r0,r0
000034  900e              STR      r0,[sp,#0x38]
;;;812      uint16_t CoilQty_; 
;;;813      CoilQty_ = ReadCoilsPkt->CoilQty.Part.Lo  + ( ReadCoilsPkt->CoilQty.Part.Hi  << 8U );
000036  f89a0005          LDRB     r0,[r10,#5]
00003a  f89a1004          LDRB     r1,[r10,#4]
00003e  eb002001          ADD      r0,r0,r1,LSL #8
000042  b286              UXTH     r6,r0
;;;814    
;;;815      if (
000044  2e01              CMP      r6,#1
000046  db01              BLT      |L30.76|
;;;816          CoilQty_ < 1
;;;817          ||
;;;818          CoilQty_ > 0xA
000048  2e0a              CMP      r6,#0xa
00004a  dd0c              BLE      |L30.102|
                  |L30.76|
;;;819         )
;;;820      {
;;;821        //сформировать и отправить пакет с кодом исключения 3 (ILLEGAL DATA VALUE)
;;;822        Buf[ 1U ] |= 0x80;                                  //Function
00004c  7860              LDRB     r0,[r4,#1]
00004e  f0400080          ORR      r0,r0,#0x80
000052  7060              STRB     r0,[r4,#1]
;;;823        Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_VAL;       //Exception Code
000054  2003              MOVS     r0,#3
000056  70a0              STRB     r0,[r4,#2]
;;;824    
;;;825    //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;826        s_formatting_error_reply( Buf );
000058  4621              MOV      r1,r4
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
                  |L30.96|
;;;827    
;;;828        return;
;;;829      }
;;;830    
;;;831    	for ( uint16_t Ctr = 0; Ctr < CoilQty_; Ctr++ )
;;;832    	{
;;;833    		uint16_t CurAddr = CoilAddr + Ctr;
;;;834    
;;;835    //    typedef bool (TDevHandlers::*TChkFnct)( void * );
;;;836        
;;;837        const TPDU *PDU = nullptr;
;;;838        
;;;839        if (                          //если хотя-бы один из запрошенных регистров не найден или доступ к нему не разрешен
;;;840            chk_legal_item(
;;;841                           beg, 
;;;842                           end, 
;;;843                           CurAddr, 
;;;844                           MbFnct,
;;;845                           &TDevHandlers::chk_access,
;;;846                           &PDU
;;;847                          ) == false
;;;848           )
;;;849        {
;;;850    		  //сформировать и отправить пакет с кодом исключения 2 (ILLEGAL DATA ADDRESS)
;;;851    		  Buf[ 1U ] |= 0x80;                                  //Function
;;;852    		  Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_ADDR;      //Exception Code
;;;853          
;;;854    //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;855          s_formatting_error_reply( Buf );
;;;856    
;;;857    			return;
;;;858        }
;;;859    	}
;;;860    	
;;;861    	uint8_t BytesQty = 5U;             //( 1:Addr + 1:CodeFnct + 1:BytesQty + 2:CRC )
;;;862      uint8_t ByteCnt = 0U;
;;;863    	BytesQty += ( CoilQty_ / 8U != 0U )  
;;;864    	          ? ( ByteCnt = CoilQty_ / 8U )           
;;;865    	          : ( ByteCnt = 1U );           //+ n:Data
;;;866      
;;;867    //  uint8_t *DynBuf = new uint8_t [ BytesQty ]; //память под массив необходимо выделить динамически
;;;868    	
;;;869    	uint8_t ByteNbr = 0U;
;;;870    	TxBuf[ ByteNbr++ ] = Buf[0U];
;;;871    	TxBuf[ ByteNbr++ ] = Buf[1U];
;;;872    	TxBuf[ ByteNbr++ ] = ByteCnt;
;;;873    	
;;;874    	uint8_t CurByte = 0U;
;;;875    	for ( uint16_t Ctr = 0, BitsNbr = 0U; Ctr < CoilQty_; Ctr++ )
;;;876    	{
;;;877    		uint16_t CurAddr = CoilAddr + Ctr;
;;;878    
;;;879    		TPDU *PDU =
;;;880    		std::find_if( beg, end, [ CurAddr ]( TPDU item ){
;;;881          return ( item.RegAddr == CurAddr );
;;;882    		} );
;;;883        
;;;884    		uint8_t Data = 0U;
;;;885    		
;;;886    		( this->*(PDU->Fnct) )( reinterpret_cast<uint32_t>(&Data) );
;;;887    		
;;;888    		Data <<= BitsNbr;
;;;889    		CurByte |= Data;
;;;890    		if ( ++BitsNbr == 8U )
;;;891    		{
;;;892    	    TxBuf[ ByteNbr++ ] = CurByte;
;;;893    			
;;;894    			BitsNbr = 0U;
;;;895    			CurByte = 0U;
;;;896    		}
;;;897    		else
;;;898    		{
;;;899    		  TxBuf[ ByteNbr ] = CurByte;
;;;900    		}
;;;901    	}
;;;902    	
;;;903    	*(uint16_t *)&TxBuf[ BytesQty - 2U ] = CRC16( TxBuf, BytesQty - 2U );
;;;904      
;;;905      ++DinputCtr;
;;;906    
;;;907    	start_transmit( BytesQty ); //отправить сформированый пакет
;;;908      
;;;909      State = TState::__IDLE;
;;;910    }
000060  b015              ADD      sp,sp,#0x54
000062  e8bd8ff0          POP      {r4-r11,pc}
                  |L30.102|
000066  f04f0900          MOV      r9,#0                 ;831
00006a  e023              B        |L30.180|
                  |L30.108|
00006c  980e              LDR      r0,[sp,#0x38]         ;833
00006e  4448              ADD      r0,r0,r9              ;833
000070  b280              UXTH     r0,r0                 ;833
000072  900c              STR      r0,[sp,#0x30]         ;833
000074  2000              MOVS     r0,#0                 ;837
000076  900b              STR      r0,[sp,#0x2c]         ;837
000078  a80b              ADD      r0,sp,#0x2c           ;839
00007a  495f              LDR      r1,|L30.504|
00007c  9003              STR      r0,[sp,#0xc]          ;839
00007e  c903              LDM      r1,{r0,r1}            ;839
000080  e9cd0101          STRD     r0,r1,[sp,#4]         ;839
000084  9814              LDR      r0,[sp,#0x50]         ;839
000086  9000              STR      r0,[sp,#0]            ;839
000088  4628              MOV      r0,r5                 ;839
00008a  9b0c              LDR      r3,[sp,#0x30]         ;839
00008c  e9dd210f          LDRD     r2,r1,[sp,#0x3c]      ;839
000090  f7fffffe          BL       _ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_ ; TModbusApp::chk_legal_item(const TDevHandlers::TPDU*, const TDevHandlers::TPDU*, unsigned short, TModbusApp::TMbFnct, bool(TDevHandlers::*)(void*), const TDevHandlers::TPDU**)
000094  b950              CBNZ     r0,|L30.172|
000096  7860              LDRB     r0,[r4,#1]            ;851
000098  f0400080          ORR      r0,r0,#0x80           ;851
00009c  7060              STRB     r0,[r4,#1]            ;851
00009e  2002              MOVS     r0,#2                 ;852
0000a0  70a0              STRB     r0,[r4,#2]            ;852
0000a2  4621              MOV      r1,r4                 ;855
0000a4  4628              MOV      r0,r5                 ;855
0000a6  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
0000aa  e7d9              B        |L30.96|
                  |L30.172|
0000ac  f1090001          ADD      r0,r9,#1              ;831
0000b0  fa1ff980          UXTH     r9,r0                 ;831
                  |L30.180|
0000b4  45b1              CMP      r9,r6                 ;831
0000b6  dbd9              BLT      |L30.108|
0000b8  2705              MOVS     r7,#5                 ;861
0000ba  2000              MOVS     r0,#0                 ;862
0000bc  900d              STR      r0,[sp,#0x34]         ;862
0000be  08f0              LSRS     r0,r6,#3              ;863
0000c0  b118              CBZ      r0,|L30.202|
0000c2  f3c600c7          UBFX     r0,r6,#3,#8           ;864
0000c6  900d              STR      r0,[sp,#0x34]         ;864
0000c8  e001              B        |L30.206|
                  |L30.202|
0000ca  2001              MOVS     r0,#1                 ;865
0000cc  900d              STR      r0,[sp,#0x34]         ;865
                  |L30.206|
0000ce  4438              ADD      r0,r0,r7              ;865
0000d0  b2c7              UXTB     r7,r0                 ;865
0000d2  f04f0800          MOV      r8,#0                 ;869
0000d6  7822              LDRB     r2,[r4,#0]            ;870
0000d8  4641              MOV      r1,r8                 ;870
0000da  f1080801          ADD      r8,r8,#1              ;870
0000de  f505708a          ADD      r0,r5,#0x114          ;870
0000e2  5442              STRB     r2,[r0,r1]            ;870
0000e4  7862              LDRB     r2,[r4,#1]            ;871
0000e6  4641              MOV      r1,r8                 ;871
0000e8  f1080801          ADD      r8,r8,#1              ;871
0000ec  5442              STRB     r2,[r0,r1]            ;871
0000ee  4642              MOV      r2,r8                 ;872
0000f0  f1080801          ADD      r8,r8,#1              ;872
0000f4  990d              LDR      r1,[sp,#0x34]         ;872
0000f6  5481              STRB     r1,[r0,r2]            ;872
0000f8  f04f0b00          MOV      r11,#0                ;874
0000fc  2000              MOVS     r0,#0                 ;875
0000fe  900c              STR      r0,[sp,#0x30]         ;875
000100  900b              STR      r0,[sp,#0x2c]         ;875
000102  e05e              B        |L30.450|
                  |L30.260|
000104  990c              LDR      r1,[sp,#0x30]         ;877
000106  980e              LDR      r0,[sp,#0x38]         ;877
000108  4408              ADD      r0,r0,r1              ;877
00010a  b280              UXTH     r0,r0                 ;877
00010c  9006              STR      r0,[sp,#0x18]         ;877
00010e  9a06              LDR      r2,[sp,#0x18]         ;879
000110  e9dd100f          LDRD     r1,r0,[sp,#0x3c]      ;879
000114  920a              STR      r2,[sp,#0x28]         ;879
000116  9204              STR      r2,[sp,#0x10]         ;879
000118  e000              B        |L30.284|
                  |L30.282|
00011a  3010              ADDS     r0,r0,#0x10           ;879
                  |L30.284|
00011c  4288              CMP      r0,r1                 ;879
00011e  d00e              BEQ      |L30.318|
000120  e890500c          LDM      r0,{r2,r3,r12,lr}     ;879
000124  e88d500c          STM      sp,{r2,r3,r12,lr}     ;879
000128  f8bd2002          LDRH     r2,[sp,#2]            ;881
00012c  f8bd3010          LDRH     r3,[sp,#0x10]         ;881
000130  429a              CMP      r2,r3                 ;881
000132  d101              BNE      |L30.312|
000134  2201              MOVS     r2,#1                 ;881
000136  e000              B        |L30.314|
                  |L30.312|
000138  2200              MOVS     r2,#0                 ;881
                  |L30.314|
00013a  2a00              CMP      r2,#0                 ;881
00013c  d0ed              BEQ      |L30.282|
                  |L30.318|
00013e  4681              MOV      r9,r0                 ;879
000140  2000              MOVS     r0,#0                 ;884
000142  9005              STR      r0,[sp,#0x14]         ;884
000144  f505700e          ADD      r0,r5,#0x238          ;886
000148  f8d9100c          LDR      r1,[r9,#0xc]          ;886
00014c  eb000061          ADD      r0,r0,r1,ASR #1       ;886
000150  9009              STR      r0,[sp,#0x24]         ;886
000152  f899000c          LDRB     r0,[r9,#0xc]          ;886
000156  f0000001          AND      r0,r0,#1              ;886
00015a  b910              CBNZ     r0,|L30.354|
00015c  f8d90008          LDR      r0,[r9,#8]            ;886
000160  e006              B        |L30.368|
                  |L30.354|
000162  9809              LDR      r0,[sp,#0x24]         ;886
000164  6800              LDR      r0,[r0,#0]            ;886
000166  f8d91008          LDR      r1,[r9,#8]            ;886
00016a  4408              ADD      r0,r0,r1              ;886
00016c  9008              STR      r0,[sp,#0x20]         ;886
00016e  6800              LDR      r0,[r0,#0]            ;886
                  |L30.368|
000170  a905              ADD      r1,sp,#0x14           ;886
000172  9007              STR      r0,[sp,#0x1c]         ;886
000174  9a07              LDR      r2,[sp,#0x1c]         ;886
000176  9809              LDR      r0,[sp,#0x24]         ;886
000178  4790              BLX      r2                    ;886
00017a  f89d0014          LDRB     r0,[sp,#0x14]         ;888
00017e  990b              LDR      r1,[sp,#0x2c]         ;888
000180  4088              LSLS     r0,r0,r1              ;888
000182  b2c0              UXTB     r0,r0                 ;888
000184  9005              STR      r0,[sp,#0x14]         ;888
000186  f89d0014          LDRB     r0,[sp,#0x14]         ;889
00018a  ea4b0b00          ORR      r11,r11,r0            ;889
00018e  980b              LDR      r0,[sp,#0x2c]         ;890
000190  1c40              ADDS     r0,r0,#1              ;890
000192  b280              UXTH     r0,r0                 ;890
000194  900b              STR      r0,[sp,#0x2c]         ;890
000196  2808              CMP      r0,#8                 ;890
000198  d10b              BNE      |L30.434|
00019a  4640              MOV      r0,r8                 ;892
00019c  1c41              ADDS     r1,r0,#1              ;892
00019e  f00108ff          AND      r8,r1,#0xff           ;892
0001a2  f505718a          ADD      r1,r5,#0x114          ;892
0001a6  f801b000          STRB     r11,[r1,r0]           ;892
0001aa  2000              MOVS     r0,#0                 ;894
0001ac  900b              STR      r0,[sp,#0x2c]         ;894
0001ae  4683              MOV      r11,r0                ;895
0001b0  e003              B        |L30.442|
                  |L30.434|
0001b2  f505708a          ADD      r0,r5,#0x114          ;899
0001b6  f800b008          STRB     r11,[r0,r8]           ;899
                  |L30.442|
0001ba  980c              LDR      r0,[sp,#0x30]         ;875
0001bc  1c40              ADDS     r0,r0,#1              ;875
0001be  b280              UXTH     r0,r0                 ;875
0001c0  900c              STR      r0,[sp,#0x30]         ;875
                  |L30.450|
0001c2  980c              LDR      r0,[sp,#0x30]         ;875
0001c4  42b0              CMP      r0,r6                 ;875
0001c6  db9d              BLT      |L30.260|
0001c8  1eb8              SUBS     r0,r7,#2              ;903
0001ca  b281              UXTH     r1,r0                 ;903
0001cc  f505708a          ADD      r0,r5,#0x114          ;903
0001d0  f7fffffe          BL       CRC16
0001d4  1eb9              SUBS     r1,r7,#2              ;903
0001d6  f505728a          ADD      r2,r5,#0x114          ;903
0001da  5250              STRH     r0,[r2,r1]            ;903
0001dc  4807              LDR      r0,|L30.508|
0001de  7800              LDRB     r0,[r0,#0]            ;905  ; DinputCtr
0001e0  1c40              ADDS     r0,r0,#1              ;905
0001e2  4906              LDR      r1,|L30.508|
0001e4  7008              STRB     r0,[r1,#0]            ;905
0001e6  4639              MOV      r1,r7                 ;907
0001e8  4628              MOV      r0,r5                 ;907
0001ea  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
0001ee  2000              MOVS     r0,#0                 ;909
0001f0  f8850230          STRB     r0,[r5,#0x230]        ;909
0001f4  bf00              NOP      
0001f6  e733              B        |L30.96|
;;;911    
                          ENDP

                  |L30.504|
                          DCD      ||<Data1>||
                  |L30.508|
                          DCD      DinputCtr

                          AREA ||i._ZN10TModbusApp9read_regsEPhtNS_7TMbFnctE||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp9read_regsEPhtNS_7TMbFnctE PROC ; TModbusApp::read_regs(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;911    
;;;912    void TModbusApp::read_regs( uint8_t *Buf, uint16_t BUF_SIZE, TMbFnct MbFnct )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;913    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;914    //  Do.open();
;;;915      auto beg = &PduHandler->Buf[ 0 ];
00000a  f8d50238          LDR      r0,[r5,#0x238]
00000e  6800              LDR      r0,[r0,#0]
000010  900e              STR      r0,[sp,#0x38]
;;;916    	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000012  f8d50238          LDR      r0,[r5,#0x238]
000016  6800              LDR      r0,[r0,#0]
000018  f8d51238          LDR      r1,[r5,#0x238]
00001c  8889              LDRH     r1,[r1,#4]
00001e  eb001001          ADD      r0,r0,r1,LSL #4
000022  900d              STR      r0,[sp,#0x34]
;;;917    	
;;;918    	struct TReadRegsPkt
;;;919    	{
;;;920    		uint8_t Addr;
;;;921    		uint8_t FnctCode;
;;;922    		union
;;;923    		{
;;;924    			struct
;;;925    			{
;;;926    				uint8_t Hi;
;;;927    				uint8_t Lo;
;;;928    			} Part;
;;;929    			uint16_t Data;
;;;930    		} RegAddr;
;;;931    		union
;;;932    		{
;;;933    			struct
;;;934    			{
;;;935    				uint8_t Hi;
;;;936    				uint8_t Lo;
;;;937    			} Part;
;;;938    			uint16_t Data;
;;;939    		} RegQty;
;;;940    		union
;;;941    		{
;;;942    			struct
;;;943    			{
;;;944    				uint8_t Lo;
;;;945    				uint8_t Hi;
;;;946    			} Part;
;;;947    			uint16_t Data;
;;;948    		} Crc;			
;;;949    	};
;;;950    	
;;;951    	const TReadRegsPkt *ReadCoilsPkt = reinterpret_cast<const TReadRegsPkt *>(Buf);
000024  46a1              MOV      r9,r4
;;;952      uint16_t RegAddr = ReadCoilsPkt->RegAddr.Part.Lo + ( ReadCoilsPkt->RegAddr.Part.Hi << 8U );
000026  f8990003          LDRB     r0,[r9,#3]
00002a  f8991002          LDRB     r1,[r9,#2]
00002e  eb002001          ADD      r0,r0,r1,LSL #8
000032  b280              UXTH     r0,r0
000034  900c              STR      r0,[sp,#0x30]
;;;953      uint16_t RegQty_; 
;;;954      RegQty_ = ReadCoilsPkt->RegQty.Part.Lo  + ( ReadCoilsPkt->RegQty.Part.Hi  << 8U );
000036  f8990005          LDRB     r0,[r9,#5]
00003a  f8991004          LDRB     r1,[r9,#4]
00003e  eb002001          ADD      r0,r0,r1,LSL #8
000042  b286              UXTH     r6,r0
;;;955    
;;;956      if ( 
000044  2e01              CMP      r6,#1
000046  db01              BLT      |L31.76|
;;;957          RegQty_ < 1
;;;958          ||
;;;959          RegQty_ > 0xA      
000048  2e0a              CMP      r6,#0xa
00004a  dd0c              BLE      |L31.102|
                  |L31.76|
;;;960         )
;;;961      {
;;;962        //сформировать и отправить пакет с кодом исключения 3 (ILLEGAL DATA VALUE)
;;;963        Buf[ 1U ] |= 0x80;                                  //Function
00004c  7860              LDRB     r0,[r4,#1]
00004e  f0400080          ORR      r0,r0,#0x80
000052  7060              STRB     r0,[r4,#1]
;;;964        Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_VAL;       //Exception Code
000054  2003              MOVS     r0,#3
000056  70a0              STRB     r0,[r4,#2]
;;;965        
;;;966    //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;967        s_formatting_error_reply( Buf );
000058  4621              MOV      r1,r4
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
                  |L31.96|
;;;968    
;;;969        return;
;;;970      }
;;;971    
;;;972    	for ( uint16_t Ctr = 0; Ctr < RegQty_; Ctr++ )
;;;973    	{
;;;974    		uint16_t CurAddr = RegAddr + Ctr;
;;;975        
;;;976        const TPDU *PDU = nullptr;
;;;977        
;;;978        if (                          //если хотя-бы один из запрошенных регистров не найден или доступ к нему не разрешен
;;;979            chk_legal_item(
;;;980                           beg, 
;;;981                           end, 
;;;982                           CurAddr, 
;;;983                           MbFnct,
;;;984                           &TDevHandlers::chk_access,
;;;985                           &PDU
;;;986                          ) == false
;;;987           )
;;;988    		{
;;;989    		  //сформировать и отправить пакет с кодом исключения 2 (ILLEGAL DATA ADDRESS)
;;;990    		  Buf[ 1U ] |= 0x80;                                  //Function
;;;991    		  Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_ADDR;      //Exception Code
;;;992    
;;;993    //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;994          s_formatting_error_reply( Buf );
;;;995    
;;;996    			return;
;;;997    		}
;;;998    	}
;;;999    	
;;;1000   	uint8_t BytesQty = 5U;           //( 1:Addr + 1:CodeFnct + 1:BytesQty + 2:CRC )
;;;1001     uint8_t ByteCnt  = RegQty_ * 2U; //количество байтов с данными в PDU
;;;1002   	BytesQty        += ByteCnt;      //общее количество байтов в пакете
;;;1003     	
;;;1004   	uint8_t ByteNbr = 0U;            //номер текущего байта
;;;1005   	TxBuf[ ByteNbr++ ] = Buf[0U];
;;;1006   	TxBuf[ ByteNbr++ ] = Buf[1U];
;;;1007   	TxBuf[ ByteNbr++ ] = ByteCnt;
;;;1008   	  
;;;1009     for ( uint16_t RegCtr = 0U; RegCtr < RegQty_; ++RegCtr )
;;;1010     {
;;;1011   		uint16_t CurAddr = RegAddr + RegCtr;
;;;1012   
;;;1013   		TPDU *PDU =
;;;1014   		std::find_if( beg, end, [ CurAddr ]( TPDU item ){
;;;1015         return ( item.RegAddr == CurAddr );
;;;1016   		} );
;;;1017     
;;;1018       __packed union TDataParse
;;;1019       {
;;;1020         uint16_t Val;
;;;1021         __packed struct
;;;1022         {
;;;1023           uint8_t Lo;
;;;1024           uint8_t Hi;
;;;1025         } Segment;
;;;1026       };
;;;1027       
;;;1028       TDataParse Data;
;;;1029       Data.Val = 0U;
;;;1030   		
;;;1031   		( this->*(PDU->Fnct) )( reinterpret_cast<uint32_t>(&Data) );
;;;1032       TxBuf[ ByteNbr++ ] = Data.Segment.Hi;
;;;1033       TxBuf[ ByteNbr++ ] = Data.Segment.Lo;
;;;1034     }
;;;1035   	
;;;1036   	*(uint16_t *)&TxBuf[ BytesQty - 2U ] = CRC16( TxBuf, BytesQty - 2U );
;;;1037   
;;;1038     
;;;1039   	start_transmit( BytesQty ); //отправить сформированый пакет
;;;1040     
;;;1041     State = TState::__IDLE;
;;;1042   }
000060  b013              ADD      sp,sp,#0x4c
000062  e8bd8ff0          POP      {r4-r11,pc}
                  |L31.102|
000066  f04f0800          MOV      r8,#0                 ;972
00006a  e023              B        |L31.180|
                  |L31.108|
00006c  980c              LDR      r0,[sp,#0x30]         ;974
00006e  4440              ADD      r0,r0,r8              ;974
000070  fa1ffb80          UXTH     r11,r0                ;974
000074  2000              MOVS     r0,#0                 ;976
000076  900a              STR      r0,[sp,#0x28]         ;976
000078  a80a              ADD      r0,sp,#0x28           ;978
00007a  4951              LDR      r1,|L31.448|
00007c  9003              STR      r0,[sp,#0xc]          ;978
00007e  c903              LDM      r1,{r0,r1}            ;978
000080  e9cd0101          STRD     r0,r1,[sp,#4]         ;978
000084  9812              LDR      r0,[sp,#0x48]         ;978
000086  465b              MOV      r3,r11                ;978
000088  9000              STR      r0,[sp,#0]            ;978
00008a  4628              MOV      r0,r5                 ;978
00008c  e9dd210d          LDRD     r2,r1,[sp,#0x34]      ;978
000090  f7fffffe          BL       _ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_ ; TModbusApp::chk_legal_item(const TDevHandlers::TPDU*, const TDevHandlers::TPDU*, unsigned short, TModbusApp::TMbFnct, bool(TDevHandlers::*)(void*), const TDevHandlers::TPDU**)
000094  b950              CBNZ     r0,|L31.172|
000096  7860              LDRB     r0,[r4,#1]            ;990
000098  f0400080          ORR      r0,r0,#0x80           ;990
00009c  7060              STRB     r0,[r4,#1]            ;990
00009e  2002              MOVS     r0,#2                 ;991
0000a0  70a0              STRB     r0,[r4,#2]            ;991
0000a2  4621              MOV      r1,r4                 ;994
0000a4  4628              MOV      r0,r5                 ;994
0000a6  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
0000aa  e7d9              B        |L31.96|
                  |L31.172|
0000ac  f1080001          ADD      r0,r8,#1              ;972
0000b0  fa1ff880          UXTH     r8,r0                 ;972
                  |L31.180|
0000b4  45b0              CMP      r8,r6                 ;972
0000b6  dbd9              BLT      |L31.108|
0000b8  f04f0a05          MOV      r10,#5                ;1000
0000bc  0670              LSLS     r0,r6,#25             ;1001
0000be  0e00              LSRS     r0,r0,#24             ;1001
0000c0  900b              STR      r0,[sp,#0x2c]         ;1001
0000c2  980b              LDR      r0,[sp,#0x2c]         ;1002
0000c4  4450              ADD      r0,r0,r10             ;1002
0000c6  f0000aff          AND      r10,r0,#0xff          ;1002
0000ca  2700              MOVS     r7,#0                 ;1004
0000cc  7822              LDRB     r2,[r4,#0]            ;1005
0000ce  4639              MOV      r1,r7                 ;1005
0000d0  1c7f              ADDS     r7,r7,#1              ;1005
0000d2  f505708a          ADD      r0,r5,#0x114          ;1005
0000d6  5442              STRB     r2,[r0,r1]            ;1005
0000d8  7862              LDRB     r2,[r4,#1]            ;1006
0000da  4639              MOV      r1,r7                 ;1006
0000dc  1c7f              ADDS     r7,r7,#1              ;1006
0000de  5442              STRB     r2,[r0,r1]            ;1006
0000e0  463a              MOV      r2,r7                 ;1007
0000e2  1c7f              ADDS     r7,r7,#1              ;1007
0000e4  f505718a          ADD      r1,r5,#0x114          ;1007
0000e8  980b              LDR      r0,[sp,#0x2c]         ;1007
0000ea  5488              STRB     r0,[r1,r2]            ;1007
0000ec  2000              MOVS     r0,#0                 ;1009
0000ee  900a              STR      r0,[sp,#0x28]         ;1009
0000f0  e04d              B        |L31.398|
                  |L31.242|
0000f2  990a              LDR      r1,[sp,#0x28]         ;1011
0000f4  980c              LDR      r0,[sp,#0x30]         ;1011
0000f6  4408              ADD      r0,r0,r1              ;1011
0000f8  b280              UXTH     r0,r0                 ;1011
0000fa  9006              STR      r0,[sp,#0x18]         ;1011
0000fc  9a06              LDR      r2,[sp,#0x18]         ;1013
0000fe  e9dd100d          LDRD     r1,r0,[sp,#0x34]      ;1013
000102  9209              STR      r2,[sp,#0x24]         ;1013
000104  9204              STR      r2,[sp,#0x10]         ;1013
000106  e000              B        |L31.266|
                  |L31.264|
000108  3010              ADDS     r0,r0,#0x10           ;1013
                  |L31.266|
00010a  4288              CMP      r0,r1                 ;1013
00010c  d00e              BEQ      |L31.300|
00010e  e890500c          LDM      r0,{r2,r3,r12,lr}     ;1013
000112  e88d500c          STM      sp,{r2,r3,r12,lr}     ;1013
000116  f8bd2002          LDRH     r2,[sp,#2]            ;1015
00011a  f8bd3010          LDRH     r3,[sp,#0x10]         ;1015
00011e  429a              CMP      r2,r3                 ;1015
000120  d101              BNE      |L31.294|
000122  2201              MOVS     r2,#1                 ;1015
000124  e000              B        |L31.296|
                  |L31.294|
000126  2200              MOVS     r2,#0                 ;1015
                  |L31.296|
000128  2a00              CMP      r2,#0                 ;1015
00012a  d0ed              BEQ      |L31.264|
                  |L31.300|
00012c  4680              MOV      r8,r0                 ;1013
00012e  2000              MOVS     r0,#0                 ;1029
000130  9005              STR      r0,[sp,#0x14]         ;1029
000132  f505700e          ADD      r0,r5,#0x238          ;1031
000136  f8d8100c          LDR      r1,[r8,#0xc]          ;1031
00013a  eb000b61          ADD      r11,r0,r1,ASR #1      ;1031
00013e  f898000c          LDRB     r0,[r8,#0xc]          ;1031
000142  f0000001          AND      r0,r0,#1              ;1031
000146  b910              CBNZ     r0,|L31.334|
000148  f8d80008          LDR      r0,[r8,#8]            ;1031
00014c  e006              B        |L31.348|
                  |L31.334|
00014e  f8db0000          LDR      r0,[r11,#0]           ;1031
000152  f8d81008          LDR      r1,[r8,#8]            ;1031
000156  4408              ADD      r0,r0,r1              ;1031
000158  9008              STR      r0,[sp,#0x20]         ;1031
00015a  6800              LDR      r0,[r0,#0]            ;1031
                  |L31.348|
00015c  a905              ADD      r1,sp,#0x14           ;1031
00015e  9007              STR      r0,[sp,#0x1c]         ;1031
000160  4658              MOV      r0,r11                ;1031
000162  9a07              LDR      r2,[sp,#0x1c]         ;1031
000164  4790              BLX      r2                    ;1031
000166  f89d2015          LDRB     r2,[sp,#0x15]         ;1032
00016a  4638              MOV      r0,r7                 ;1032
00016c  1c79              ADDS     r1,r7,#1              ;1032
00016e  b2cf              UXTB     r7,r1                 ;1032
000170  f505718a          ADD      r1,r5,#0x114          ;1032
000174  540a              STRB     r2,[r1,r0]            ;1032
000176  f89d2014          LDRB     r2,[sp,#0x14]         ;1033
00017a  4638              MOV      r0,r7                 ;1033
00017c  1c79              ADDS     r1,r7,#1              ;1033
00017e  b2cf              UXTB     r7,r1                 ;1033
000180  f505718a          ADD      r1,r5,#0x114          ;1033
000184  540a              STRB     r2,[r1,r0]            ;1033
000186  980a              LDR      r0,[sp,#0x28]         ;1009
000188  1c40              ADDS     r0,r0,#1              ;1009
00018a  b280              UXTH     r0,r0                 ;1009
00018c  900a              STR      r0,[sp,#0x28]         ;1009
                  |L31.398|
00018e  980a              LDR      r0,[sp,#0x28]         ;1009
000190  42b0              CMP      r0,r6                 ;1009
000192  dbae              BLT      |L31.242|
000194  f1aa0002          SUB      r0,r10,#2             ;1036
000198  b281              UXTH     r1,r0                 ;1036
00019a  f505708a          ADD      r0,r5,#0x114          ;1036
00019e  f7fffffe          BL       CRC16
0001a2  f1aa0102          SUB      r1,r10,#2             ;1036
0001a6  f505728a          ADD      r2,r5,#0x114          ;1036
0001aa  5250              STRH     r0,[r2,r1]            ;1036
0001ac  4651              MOV      r1,r10                ;1039
0001ae  4628              MOV      r0,r5                 ;1039
0001b0  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
0001b4  2000              MOVS     r0,#0                 ;1041
0001b6  f8850230          STRB     r0,[r5,#0x230]        ;1041
0001ba  bf00              NOP      
0001bc  e750              B        |L31.96|
;;;1043   
                          ENDP

0001be  0000              DCW      0x0000
                  |L31.448|
                          DCD      ||<Data1>||

                          AREA ||i._ZN10TModbusApp9write_mulEPhtNS_7TMbFnctE||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusApp9write_mulEPhtNS_7TMbFnctE PROC ; TModbusApp::write_mul(unsigned char*, unsigned short, TModbusApp::TMbFnct)
;;;1164   
;;;1165   void TModbusApp::write_mul( uint8_t *Buf, uint16_t BUF_SIZE, TMbFnct MbFnct )
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1166   {
000004  b08f              SUB      sp,sp,#0x3c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4699              MOV      r9,r3
;;;1167   	/*
;;;1168   	Buf[0] - адрес
;;;1169   	Buf[1] - код функции
;;;1170   	Buf[2] - начальный адрес регистра (Hi)
;;;1171   	Buf[3] - начальный адрес регистра (Lo)
;;;1172   	Buf[4] - количество регистров (Hi)
;;;1173   	Buf[5] - количество регистров (Lo)
;;;1174   	Buf[6] - количество байтов - содержимое регистров
;;;1175   	Buf[7] - CRC (Lo)
;;;1176   	Buf[8] - CRC (Hi)
;;;1177   	*/
;;;1178     auto beg = &PduHandler->Buf[ 0 ];
00000c  f8d50238          LDR      r0,[r5,#0x238]
000010  6800              LDR      r0,[r0,#0]
000012  900e              STR      r0,[sp,#0x38]
;;;1179   	auto end = &PduHandler->Buf[ PduHandler->BUF_SIZE ];
000014  f8d50238          LDR      r0,[r5,#0x238]
000018  6800              LDR      r0,[r0,#0]
00001a  f8d51238          LDR      r1,[r5,#0x238]
00001e  8889              LDRH     r1,[r1,#4]
000020  eb001001          ADD      r0,r0,r1,LSL #4
000024  900d              STR      r0,[sp,#0x34]
;;;1180   	
;;;1181   	__packed struct TBasic
;;;1182   	{
;;;1183   		uint8_t Addr;
;;;1184   		uint8_t FnctCode;
;;;1185   		__packed union
;;;1186   		{
;;;1187   			__packed struct
;;;1188   			{
;;;1189   				uint8_t Hi;
;;;1190   				uint8_t Lo;
;;;1191   			} Part;
;;;1192   			uint16_t Data;
;;;1193   		} RegAddr;
;;;1194   		
;;;1195   		__packed union
;;;1196   		{
;;;1197   			__packed struct
;;;1198   			{
;;;1199   				uint8_t Hi;
;;;1200   				uint8_t Lo;
;;;1201   			} Part;
;;;1202   			uint16_t Data;
;;;1203   		} RegQty;
;;;1204   	};
;;;1205   	
;;;1206   	__packed struct TReqPkt
;;;1207   	{
;;;1208   		TBasic Basic;
;;;1209       uint8_t ByteCnt;
;;;1210   		__packed union
;;;1211   		{
;;;1212   			__packed struct
;;;1213   			{
;;;1214   				uint8_t Hi;
;;;1215   				uint8_t Lo;
;;;1216   			} Part;
;;;1217   			int16_t Data;
;;;1218   		} RegStartVal;		
;;;1219   	};
;;;1220   	
;;;1221   	__packed struct TRespPkt
;;;1222   	{
;;;1223   		TBasic Basic;
;;;1224   		uint16_t Crc;
;;;1225   	};
;;;1226   	
;;;1227   	const TReqPkt *ReqPkt = reinterpret_cast<const TReqPkt *>(Buf);
000026  4626              MOV      r6,r4
;;;1228     uint16_t RegAddr = ReqPkt->Basic.RegAddr.Part.Lo + ( ReqPkt->Basic.RegAddr.Part.Hi << 8U ); //начальный адрес регистра для записи
000028  78f0              LDRB     r0,[r6,#3]
00002a  78b1              LDRB     r1,[r6,#2]
00002c  eb002001          ADD      r0,r0,r1,LSL #8
000030  b280              UXTH     r0,r0
000032  900c              STR      r0,[sp,#0x30]
;;;1229     uint16_t RegQty  = ReqPkt->Basic.RegQty.Part.Lo  + ( ReqPkt->Basic.RegQty.Part.Hi  << 8U ); //количество регистров для записи
000034  7970              LDRB     r0,[r6,#5]
000036  7931              LDRB     r1,[r6,#4]
000038  eb002001          ADD      r0,r0,r1,LSL #8
00003c  b287              UXTH     r7,r0
;;;1230   	uint8_t ByteCnt  = ReqPkt->ByteCnt;
00003e  79b0              LDRB     r0,[r6,#6]
000040  900b              STR      r0,[sp,#0x2c]
;;;1231   
;;;1232     if ( 
000042  464a              MOV      r2,r9
000044  4639              MOV      r1,r7
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       _ZN10TModbusApp11chk_new_valEtNS_7TMbFnctE ; TModbusApp::chk_new_val(unsigned short, TModbusApp::TMbFnct)
00004c  b118              CBZ      r0,|L32.86|
;;;1233         chk_new_val( RegQty, MbFnct ) == false
;;;1234   			||
;;;1235   			ByteCnt != RegQty * 2U
00004e  980b              LDR      r0,[sp,#0x2c]
000050  ebb00f47          CMP      r0,r7,LSL #1
000054  d00c              BEQ      |L32.112|
                  |L32.86|
;;;1236        )
;;;1237     {
;;;1238       //сформировать и отправить пакет с кодом исключения 3 (ILLEGAL DATA VALUE)
;;;1239       Buf[ 1U ] |= 0x80;                                  //Function
000056  7860              LDRB     r0,[r4,#1]
000058  f0400080          ORR      r0,r0,#0x80
00005c  7060              STRB     r0,[r4,#1]
;;;1240       Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_VAL;       //Exception Code
00005e  2003              MOVS     r0,#3
000060  70a0              STRB     r0,[r4,#2]
;;;1241       
;;;1242   //		  State = TState::__FORMATTING_ERROR_REPLY;
;;;1243       s_formatting_error_reply( Buf );
000062  4621              MOV      r1,r4
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
                  |L32.106|
;;;1244   
;;;1245       return;
;;;1246     }
;;;1247       
;;;1248   	for ( uint8_t Ctr = 0U; Ctr < RegQty; ++Ctr )
;;;1249   	{
;;;1250   		uint16_t CurRegAddr = RegAddr + Ctr;
;;;1251   
;;;1252       const TPDU *PDU = nullptr;
;;;1253       
;;;1254       if (                          //если хотя-бы один из запрошенных регистров не найден или доступ к нему не разрешен
;;;1255           chk_legal_item(
;;;1256                          beg, 
;;;1257                          end, 
;;;1258                          CurRegAddr, 
;;;1259                          MbFnct,
;;;1260                          &TDevHandlers::chk_access,
;;;1261                          &PDU
;;;1262                         ) == false
;;;1263          )                                                                 //если запрошенный регистр не найден или доступ к нему не разрешен
;;;1264   		{
;;;1265   				//сформировать и отправить пакет с кодом исключения 2 (ILLEGAL DATA ADDRESS)
;;;1266   				Buf[ 1U ] |= 0x80;                                  //Function
;;;1267   				Buf[ 2U ] = TExceptCodes::__ILLEGAL_DATA_ADDR;      //Exception Code
;;;1268   
;;;1269   	//		  State = TState::__FORMATTING_ERROR_REPLY;
;;;1270   				s_formatting_error_reply( Buf );
;;;1271   
;;;1272   				return;
;;;1273   		}
;;;1274   	}
;;;1275     
;;;1276     TPDU *PDU = nullptr;
;;;1277   	
;;;1278   	for ( uint8_t Ctr = 0U; Ctr < RegQty; ++Ctr )
;;;1279   	{
;;;1280   		uint16_t CurRegAddr = RegAddr + Ctr;
;;;1281   		
;;;1282   		PDU = std::find_if( beg, end, [ CurRegAddr, MbFnct ]( TPDU item ){
;;;1283   						return ( 
;;;1284   										item.RegAddr == CurRegAddr 
;;;1285   										&&
;;;1286   										item.FnctNbr == MbFnct
;;;1287   									 );
;;;1288   		} );
;;;1289   		
;;;1290       
;;;1291       __packed union TLittleEndian
;;;1292       {
;;;1293         uint16_t Val;
;;;1294         __packed struct
;;;1295         {
;;;1296           uint8_t Lo;
;;;1297           uint8_t Hi;
;;;1298         } Segment;
;;;1299       };
;;;1300       
;;;1301   		uint16_t Data = *( &ReqPkt->RegStartVal.Data + Ctr );
;;;1302       Data = ( (TLittleEndian *)&Data )->Segment.Hi + ( ( (TLittleEndian *)&Data )->Segment.Lo << 8U );
;;;1303   		
;;;1304   		if (
;;;1305   				( this->*(PDU->Fnct) )( reinterpret_cast<uint32_t>(&Data) ) == true
;;;1306   			 )
;;;1307   		{
;;;1308   
;;;1309   		}
;;;1310   		else
;;;1311   		{
;;;1312   			//сформировать и отправить пакет с кодом исключения 4 (SERVER DEVICE FAILURE)
;;;1313   			Buf[ 1U ] |= 0x80;                                  //Function
;;;1314   			Buf[ 2U ] = TExceptCodes::__SERVER_DEVICE_FAILURE;  //Exception Code
;;;1315   
;;;1316   	//		  State = TState::__FORMATTING_ERROR_REPLY;
;;;1317   			s_formatting_error_reply( Buf );
;;;1318   
;;;1319   			return;
;;;1320   		}
;;;1321   	}
;;;1322   	
;;;1323   	*(TBasic *)TxBuf = *(TBasic *)Buf;
;;;1324   	( (TRespPkt *)TxBuf )->Crc = CRC16( TxBuf, sizeof (TBasic) );
;;;1325   	start_transmit( sizeof (TRespPkt) ); //отправить сформированый пакет	
;;;1326   	State = TState::__IDLE;	
;;;1327   }
00006a  b00f              ADD      sp,sp,#0x3c
00006c  e8bd8ff0          POP      {r4-r11,pc}
                  |L32.112|
000070  f04f0a00          MOV      r10,#0                ;1248
000074  e022              B        |L32.188|
                  |L32.118|
000076  980c              LDR      r0,[sp,#0x30]         ;1250
000078  4450              ADD      r0,r0,r10             ;1250
00007a  fa1ffb80          UXTH     r11,r0                ;1250
00007e  2000              MOVS     r0,#0                 ;1252
000080  900a              STR      r0,[sp,#0x28]         ;1252
000082  a80a              ADD      r0,sp,#0x28           ;1254
000084  494e              LDR      r1,|L32.448|
000086  9003              STR      r0,[sp,#0xc]          ;1254
000088  c903              LDM      r1,{r0,r1}            ;1254
00008a  465b              MOV      r3,r11                ;1254
00008c  e9cd9000          STRD     r9,r0,[sp,#0]         ;1254
000090  9102              STR      r1,[sp,#8]            ;1254
000092  4628              MOV      r0,r5                 ;1254
000094  e9dd210d          LDRD     r2,r1,[sp,#0x34]      ;1254
000098  f7fffffe          BL       _ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_ ; TModbusApp::chk_legal_item(const TDevHandlers::TPDU*, const TDevHandlers::TPDU*, unsigned short, TModbusApp::TMbFnct, bool(TDevHandlers::*)(void*), const TDevHandlers::TPDU**)
00009c  b950              CBNZ     r0,|L32.180|
00009e  7860              LDRB     r0,[r4,#1]            ;1266
0000a0  f0400080          ORR      r0,r0,#0x80           ;1266
0000a4  7060              STRB     r0,[r4,#1]            ;1266
0000a6  2002              MOVS     r0,#2                 ;1267
0000a8  70a0              STRB     r0,[r4,#2]            ;1267
0000aa  4621              MOV      r1,r4                 ;1270
0000ac  4628              MOV      r0,r5                 ;1270
0000ae  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
0000b2  e7da              B        |L32.106|
                  |L32.180|
0000b4  f10a0001          ADD      r0,r10,#1             ;1248
0000b8  f0000aff          AND      r10,r0,#0xff          ;1248
                  |L32.188|
0000bc  45ba              CMP      r10,r7                ;1248
0000be  dbda              BLT      |L32.118|
0000c0  f04f0800          MOV      r8,#0                 ;1276
0000c4  46c2              MOV      r10,r8                ;1278
0000c6  e061              B        |L32.396|
                  |L32.200|
0000c8  980c              LDR      r0,[sp,#0x30]         ;1280
0000ca  4450              ADD      r0,r0,r10             ;1280
0000cc  b280              UXTH     r0,r0                 ;1280
0000ce  9007              STR      r0,[sp,#0x1c]         ;1280
0000d0  9a07              LDR      r2,[sp,#0x1c]         ;1282
0000d2  e9dd100d          LDRD     r1,r0,[sp,#0x34]      ;1282
0000d6  f8ad2028          STRH     r2,[sp,#0x28]         ;1282
0000da  f88d902a          STRB     r9,[sp,#0x2a]         ;1282
0000de  9a0a              LDR      r2,[sp,#0x28]         ;1282
0000e0  9205              STR      r2,[sp,#0x14]         ;1282
0000e2  e000              B        |L32.230|
                  |L32.228|
0000e4  3010              ADDS     r0,r0,#0x10           ;1282
                  |L32.230|
0000e6  4288              CMP      r0,r1                 ;1282
0000e8  d016              BEQ      |L32.280|
0000ea  e890500c          LDM      r0,{r2,r3,r12,lr}     ;1282
0000ee  e9cdce03          STRD     r12,lr,[sp,#0xc]      ;1282
0000f2  e9cd2301          STRD     r2,r3,[sp,#4]         ;1282
0000f6  f8bd2006          LDRH     r2,[sp,#6]            ;1283
0000fa  f8bd3014          LDRH     r3,[sp,#0x14]         ;1283
0000fe  429a              CMP      r2,r3                 ;1283
000100  d107              BNE      |L32.274|
000102  f89d2004          LDRB     r2,[sp,#4]            ;1286
000106  f89d3016          LDRB     r3,[sp,#0x16]         ;1286
00010a  429a              CMP      r2,r3                 ;1286
00010c  d101              BNE      |L32.274|
00010e  2201              MOVS     r2,#1                 ;1283
000110  e000              B        |L32.276|
                  |L32.274|
000112  2200              MOVS     r2,#0                 ;1283
                  |L32.276|
000114  2a00              CMP      r2,#0                 ;1283
000116  d0e5              BEQ      |L32.228|
                  |L32.280|
000118  4680              MOV      r8,r0                 ;1282
00011a  1df0              ADDS     r0,r6,#7              ;1301
00011c  eb00004a          ADD      r0,r0,r10,LSL #1      ;1301
000120  8800              LDRH     r0,[r0,#0]            ;1301
000122  b280              UXTH     r0,r0                 ;1301
000124  9006              STR      r0,[sp,#0x18]         ;1301
000126  f89d0019          LDRB     r0,[sp,#0x19]         ;1302
00012a  f89d1018          LDRB     r1,[sp,#0x18]         ;1302
00012e  eb002001          ADD      r0,r0,r1,LSL #8       ;1302
000132  b280              UXTH     r0,r0                 ;1302
000134  9006              STR      r0,[sp,#0x18]         ;1302
000136  f505700e          ADD      r0,r5,#0x238          ;1304
00013a  f8d8100c          LDR      r1,[r8,#0xc]          ;1304
00013e  eb000b61          ADD      r11,r0,r1,ASR #1      ;1304
000142  f898000c          LDRB     r0,[r8,#0xc]          ;1304
000146  f0000001          AND      r0,r0,#1              ;1304
00014a  b910              CBNZ     r0,|L32.338|
00014c  f8d80008          LDR      r0,[r8,#8]            ;1305
000150  e006              B        |L32.352|
                  |L32.338|
000152  f8db0000          LDR      r0,[r11,#0]           ;1305
000156  f8d81008          LDR      r1,[r8,#8]            ;1305
00015a  4408              ADD      r0,r0,r1              ;1305
00015c  9009              STR      r0,[sp,#0x24]         ;1305
00015e  6800              LDR      r0,[r0,#0]            ;1305
                  |L32.352|
000160  a906              ADD      r1,sp,#0x18           ;1305
000162  9008              STR      r0,[sp,#0x20]         ;1305
000164  4658              MOV      r0,r11                ;1305
000166  9a08              LDR      r2,[sp,#0x20]         ;1305
000168  4790              BLX      r2                    ;1305
00016a  2801              CMP      r0,#1                 ;1305
00016c  d00a              BEQ      |L32.388|
00016e  7860              LDRB     r0,[r4,#1]            ;1313
000170  f0400080          ORR      r0,r0,#0x80           ;1313
000174  7060              STRB     r0,[r4,#1]            ;1313
000176  2004              MOVS     r0,#4                 ;1314
000178  70a0              STRB     r0,[r4,#2]            ;1314
00017a  4621              MOV      r1,r4                 ;1317
00017c  4628              MOV      r0,r5                 ;1317
00017e  f7fffffe          BL       _ZN10TModbusApp24s_formatting_error_replyEPh ; TModbusApp::s_formatting_error_reply(unsigned char*)
000182  e772              B        |L32.106|
                  |L32.388|
000184  f10a0001          ADD      r0,r10,#1             ;1278
000188  f0000aff          AND      r10,r0,#0xff          ;1278
                  |L32.396|
00018c  45ba              CMP      r10,r7                ;1278
00018e  db9b              BLT      |L32.200|
000190  f5057080          ADD      r0,r5,#0x100          ;1323
000194  6821              LDR      r1,[r4,#0]            ;1323
000196  f8c51114          STR      r1,[r5,#0x114]        ;1323
00019a  88a1              LDRH     r1,[r4,#4]            ;1323
00019c  f8a51118          STRH     r1,[r5,#0x118]        ;1323
0001a0  2106              MOVS     r1,#6                 ;1324
0001a2  3014              ADDS     r0,r0,#0x14           ;1324
0001a4  f7fffffe          BL       CRC16
0001a8  f44f718d          MOV      r1,#0x11a             ;1324
0001ac  5348              STRH     r0,[r1,r5]            ;1324
0001ae  2108              MOVS     r1,#8                 ;1325
0001b0  4628              MOV      r0,r5                 ;1325
0001b2  f7fffffe          BL       _ZN11TModbusLink14start_transmitEh ; TModbusLink::start_transmit(unsigned char)
0001b6  2000              MOVS     r0,#0                 ;1326
0001b8  f8850230          STRB     r0,[r5,#0x230]        ;1326
0001bc  bf00              NOP      
0001be  e754              B        |L32.106|
;;;1328   
                          ENDP

                  |L32.448|
                          DCD      ||<Data1>||

                          AREA ||i._ZN10TModbusAppC1ERK9TUsart_HWN11TModbusLink9TProcTypeEPN12TDevHandlers11TPduHandlerEPPvS9_||, CODE, READONLY, ALIGN=2

                  _ZN10TModbusAppC2ERK9TUsart_HWN11TModbusLink9TProcTypeEPN12TDevHandlers11TPduHandlerEPPvS9_                  ; Alternate entry point ; TModbusApp::TModbusApp__sub_object(const TUsart_HW&, TModbusLink::TProcType, TDevHandlers::TPduHandler*, void**, void**)
                  _ZN10TModbusAppC1ERK9TUsart_HWN11TModbusLink9TProcTypeEPN12TDevHandlers11TPduHandlerEPPvS9_ PROC ; TModbusApp::TModbusApp(const TUsart_HW&, TModbusLink::TProcType, TDevHandlers::TPduHandler*, void**, void**)
;;;53     
;;;54     TModbusApp::TModbusApp(
;;;55                            const TUsart_HW &Usart_HW,
;;;56                            TProcType _ProcType,
;;;57     											 TPduHandler *_PduHandler,
;;;58                            SemaphoreHandle_t *_RtoTrigSem,
;;;59                            SemaphoreHandle_t *_CommErrSem        
;;;60                           )
;;;61     :
;;;62     TModbusLink( Usart_HW, _ProcType, _RtoTrigSem, _CommErrSem ),
;;;63     TDevHandlers( _PduHandler ),
;;;64     m3RegInfo( { 0U, 0U } ),
;;;65     m4RegInfo( { 0U, 0U } )
;;;66     {
;;;67     
;;;68     }
;;;69     
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
000010  4643              MOV      r3,r8
000012  463a              MOV      r2,r7
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f8cd9000          STR      r9,[sp,#0]
00001c  f7fffffe          BL       _ZN11TModbusLinkC1ERK9TUsart_HWNS_9TProcTypeEPPvS5_ ; TModbusLink::TModbusLink(const TUsart_HW&, TModbusLink::TProcType, void**, void**)
000020  4604              MOV      r4,r0
000022  4629              MOV      r1,r5
000024  f504700e          ADD      r0,r4,#0x238
000028  f7fffffe          BL       _ZN12TDevHandlersC1EPNS_11TPduHandlerE ; TDevHandlers::TDevHandlers(TDevHandlers::TPduHandler*)
00002c  f5a0740e          SUB      r4,r0,#0x238
000030  4905              LDR      r1,|L33.72|
000032  6809              LDR      r1,[r1,#0]  ; <Data2>
000034  f8c41256          STR      r1,[r4,#0x256]
000038  4904              LDR      r1,|L33.76|
00003a  6809              LDR      r1,[r1,#0]  ; <Data3>
00003c  f8c4125a          STR      r1,[r4,#0x25a]
000040  4620              MOV      r0,r4
000042  e8bd83f8          POP      {r3-r9,pc}
                          ENDP

000046  0000              DCW      0x0000
                  |L33.72|
                          DCD      ||<Data2>||
                  |L33.76|
                          DCD      ||<Data3>||

                          AREA ||i._ZN10TModbusAppD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN10TModbusAppD2Ev                  ; Alternate entry point ; TModbusApp::~TModbusApp__sub_object()
                  _ZN10TModbusAppD1Ev PROC ; TModbusApp::~TModbusApp()
;;;69     
;;;70     TModbusApp::~TModbusApp()
;;;71     {
;;;72     
;;;73     }
;;;74     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  f504700e          ADD      r0,r4,#0x238
000008  f7fffffe          BL       _ZN12TDevHandlersD1Ev ; TDevHandlers::~TDevHandlers()
00000c  f5a0740e          SUB      r4,r0,#0x238
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _ZN11TModbusLinkD1Ev ; TModbusLink::~TModbusLink()
000016  4604              MOV      r4,r0
000018  4620              MOV      r0,r4
00001a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN10TModbusAppC1ERK9TUsart_HWN11TModbusLink9TProcTypeEPN12TDevHandlers11TPduHandlerEPPvS9_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusAppC1ERK9TUsart_HWN11TModbusLink9TProcTypeEPN12TDevHandlers11TPduHandlerEPPvS9_||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN10TModbusAppD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusAppD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZN10TModbusApp3fsmEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp3fsmEv||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN10TModbusApp11cmp_if_setsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp11cmp_if_setsEv||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN10TModbusApp6m_idleEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp6m_idleEv||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN10TModbusApp26m_waiting_turnaround_delayEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp26m_waiting_turnaround_delayEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN10TModbusApp19m_waiting_for_replyEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp19m_waiting_for_replyEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN10TModbusApp18m_processing_replyEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp18m_processing_replyEPht||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN10TModbusApp18m_processing_errorEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp18m_processing_errorEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN10TModbusApp4idleEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp4idleEv||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN10TModbusApp18s_checking_requestEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp18s_checking_requestEv||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN10TModbusApp25s_formatting_normal_replyEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp25s_formatting_normal_replyEv||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN10TModbusApp24s_formatting_error_replyEPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp24s_formatting_error_replyEPh||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN10TModbusApp28s_processing_required_actionEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp28s_processing_required_actionEPht||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN10TModbusApp22m_read_discrete_inputsEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp22m_read_discrete_inputsEPht||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN10TModbusApp24m_read_holding_registersEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp24m_read_holding_registersEPht||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN10TModbusApp22m_read_input_registersEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp22m_read_input_registersEPht||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN10TModbusApp19m_write_single_coilEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp19m_write_single_coilEPht||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN10TModbusApp23m_write_single_registerEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp23m_write_single_registerEPht||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp14chk_legal_itemEPKN12TDevHandlers4TPDUES3_tNS_7TMbFnctEMS0_FbPvEPS3_||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN10TModbusApp9read_bitsEPhtNS_7TMbFnctE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp9read_bitsEPhtNS_7TMbFnctE||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN10TModbusApp12s_read_coilsEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp12s_read_coilsEPht||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN10TModbusApp22s_read_discrete_inputsEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp22s_read_discrete_inputsEPht||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN10TModbusApp9read_regsEPhtNS_7TMbFnctE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp9read_regsEPhtNS_7TMbFnctE||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN10TModbusApp24s_read_holding_registersEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp24s_read_holding_registersEPht||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN10TModbusApp22s_read_input_registersEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp22s_read_input_registersEPht||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN10TModbusApp11chk_new_valEtNS_7TMbFnctE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp11chk_new_valEtNS_7TMbFnctE||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN10TModbusApp12write_singleEPhtNS_7TMbFnctE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp12write_singleEPhtNS_7TMbFnctE||
                          DCD      0x00000001

                          AREA ||area_number.63||, LINKORDER=||i._ZN10TModbusApp19s_write_single_coilEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp19s_write_single_coilEPht||
                          DCD      0x00000001

                          AREA ||area_number.64||, LINKORDER=||i._ZN10TModbusApp23s_write_single_registerEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp23s_write_single_registerEPht||
                          DCD      0x00000001

                          AREA ||area_number.65||, LINKORDER=||i._ZN10TModbusApp9write_mulEPhtNS_7TMbFnctE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp9write_mulEPhtNS_7TMbFnctE||
                          DCD      0x00000001

                          AREA ||area_number.66||, LINKORDER=||i._ZN10TModbusApp25s_write_multiple_registerEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.66||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp25s_write_multiple_registerEPht||
                          DCD      0x00000001

                          AREA ||area_number.67||, LINKORDER=||i._ZN10TModbusApp18s_report_server_idEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp18s_report_server_idEPht||
                          DCD      0x00000001

                          AREA ||area_number.68||, LINKORDER=||i._ZN10TModbusApp11s_boot_modeEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.68||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN10TModbusApp11s_boot_modeEPht||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ||<Data1>||
                          DCD      _ZN12TDevHandlers10chk_accessEPv ; TDevHandlers::chk_access(void*)
                          DCD      0x00000000
                  ||<Data2>||
000008  00000000          DCW      0x0000,0x0000
                  ||<Data3>||
00000c  00000000          DCW      0x0000,0x0000
                          DCD      _ZN10TModbusApp4idleEv ; TModbusApp::idle()
                          DCD      0x00000000
                          DCD      _ZN10TModbusApp18s_checking_requestEv ; TModbusApp::s_checking_request()
                          DCD      0x00000000
                          DCD      _ZN10TModbusApp25s_formatting_normal_replyEv ; TModbusApp::s_formatting_normal_reply()
                          DCD      0x00000000
                          DCD      0x000004b0
                          DCD      0x00000960
                          DCD      0x000012c0
                          DCD      0x00002580
                          DCD      0x00003840
                          DCD      0x00004b00
                          DCD      0x00009600
                          DCD      0x0000dac0
                          DCD      0x0000e100
                          DCD      0x0001c200
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
000070  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp22m_read_discrete_inputsEPht ; TModbusApp::m_read_discrete_inputs(unsigned char*, unsigned short)
                          DCD      0x00000000
00007c  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp24m_read_holding_registersEPht ; TModbusApp::m_read_holding_registers(unsigned char*, unsigned short)
                          DCD      0x00000000
000088  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp22m_read_input_registersEPht ; TModbusApp::m_read_input_registers(unsigned char*, unsigned short)
                          DCD      0x00000000
000094  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp19m_write_single_coilEPht ; TModbusApp::m_write_single_coil(unsigned char*, unsigned short)
                          DCD      0x00000000
0000a0  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp23m_write_single_registerEPht ; TModbusApp::m_write_single_register(unsigned char*, unsigned short)
                          DCD      0x00000000
                          DCD      _ZN10TModbusApp18m_processing_replyEPht ; TModbusApp::m_processing_reply(unsigned char*, unsigned short)
                          DCD      0x00000000
                          DCD      _ZN10TModbusApp28s_processing_required_actionEPht ; TModbusApp::s_processing_required_action(unsigned char*, unsigned short)
                          DCD      0x00000000
0000bc  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp12s_read_coilsEPht ; TModbusApp::s_read_coils(unsigned char*, unsigned short)
                          DCD      0x00000000
0000c8  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp22s_read_discrete_inputsEPht ; TModbusApp::s_read_discrete_inputs(unsigned char*, unsigned short)
                          DCD      0x00000000
0000d4  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp24s_read_holding_registersEPht ; TModbusApp::s_read_holding_registers(unsigned char*, unsigned short)
                          DCD      0x00000000
0000e0  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp22s_read_input_registersEPht ; TModbusApp::s_read_input_registers(unsigned char*, unsigned short)
                          DCD      0x00000000
0000ec  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp19s_write_single_coilEPht ; TModbusApp::s_write_single_coil(unsigned char*, unsigned short)
                          DCD      0x00000000
0000f8  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp23s_write_single_registerEPht ; TModbusApp::s_write_single_register(unsigned char*, unsigned short)
                          DCD      0x00000000
000104  10000000          DCB      0x10,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp25s_write_multiple_registerEPht ; TModbusApp::s_write_multiple_register(unsigned char*, unsigned short)
                          DCD      0x00000000
000110  11000000          DCB      0x11,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp18s_report_server_idEPht ; TModbusApp::s_report_server_id(unsigned char*, unsigned short)
                          DCD      0x00000000
00011c  64000000          DCB      0x64,0x00,0x00,0x00
                          DCD      _ZN10TModbusApp11s_boot_modeEPht ; TModbusApp::s_boot_mode(unsigned char*, unsigned short)
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=1

                  BUF_SIZE
000000  00                DCB      0x00
                  DinputCtr
000001  00                DCB      0x00
                  _ZZN10TModbusApp18s_checking_requestEvE7PrevQty ; TModbusApp::s_checking_request()::PrevQty
000002  00                DCB      0x00
                  _ZZN10TModbusApp18s_checking_requestEvE3Ctr ; TModbusApp::s_checking_request()::Ctr
000003  00                DCB      0x00
                  _ZZN10TModbusApp18s_checking_requestEvE3Ctr_0 ; TModbusApp::s_checking_request()::Ctr (instance 2)
000004  00                DCB      0x00
                  _ZZN10TModbusApp18s_checking_requestEvE3Ctr_1 ; TModbusApp::s_checking_request()::Ctr (instance 3)
000005  00                DCB      0x00
                  _ZZN10TModbusApp24s_formatting_error_replyEPhE3Ctr ; TModbusApp::s_formatting_error_reply(unsigned char*)::Ctr
000006  0000              DCB      0x00,0x00
                  _ZZN10TModbusApp11s_boot_modeEPhtE6Determ ; TModbusApp::s_boot_mode(unsigned char*, unsigned short)::Determ
000008  0000              DCW      0x0000

                          AREA ||t._ZSt4copyIPhS0_ET0_T_S2_S1_||, COMGROUP=_ZSt4copyIPhS0_ET0_T_S2_S1_, CODE, READONLY, ALIGN=1

                  _ZSt4copyIPhS0_ET0_T_S2_S1_ PROC ; T2 std::copy<unsigned char*, unsigned char*>(T1, T1, T2)
;;;96     inline _OutputIter
;;;97     copy (_InputIter __first, _InputIter __last, _OutputIter __res)
000000  4603              MOV      r3,r0
;;;98     {
;;;99         _RWSTD_ASSERT_RANGE (__first, __last);
;;;100    
;;;101        for (; __first != __last; ++__first,++__res)
000002  e003              B        |L215.12|
                  |L215.4|
;;;102            *__res = *__first;
000004  7818              LDRB     r0,[r3,#0]
000006  7010              STRB     r0,[r2,#0]
000008  1c5b              ADDS     r3,r3,#1              ;101
00000a  1c52              ADDS     r2,r2,#1              ;101
                  |L215.12|
00000c  428b              CMP      r3,r1                 ;101
00000e  d1f9              BNE      |L215.4|
;;;103        return __res;
000010  4610              MOV      r0,r2
;;;104    }
000012  4770              BX       lr
;;;105    
                          ENDP


                          AREA ||area_number.216||, COMGROUP=_ZSt4copyIPhS0_ET0_T_S2_S1_, LINKORDER=||t._ZSt4copyIPhS0_ET0_T_S2_S1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.216||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZSt4copyIPhS0_ET0_T_S2_S1_||
                          DCD      0x00000001

                          AREA ||t._ZSt5equalIPhPKcEbT_S3_T0_||, COMGROUP=_ZSt5equalIPhPKcEbT_S3_T0_, CODE, READONLY, ALIGN=1

                  _ZSt5equalIPhPKcEbT_S3_T0_ PROC ; bool std::equal<unsigned char*, const char*>(T1, T1, T2)
;;;241    inline bool
;;;242    equal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
000000  b5ff              PUSH     {r0-r7,lr}
;;;243    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4615              MOV      r5,r2
;;;244        return __last1 == _STD::mismatch (__first1, __last1, __first2).first;
000008  a802              ADD      r0,sp,#8
00000a  4621              MOV      r1,r4
00000c  461e              MOV      r6,r3
00000e  462a              MOV      r2,r5
000010  e001              B        |L222.22|
                  |L222.18|
000012  1c49              ADDS     r1,r1,#1
000014  1c52              ADDS     r2,r2,#1
                  |L222.22|
000016  42b1              CMP      r1,r6
000018  d004              BEQ      |L222.36|
00001a  780f              LDRB     r7,[r1,#0]
00001c  f892c000          LDRB     r12,[r2,#0]
000020  4567              CMP      r7,r12
000022  d0f6              BEQ      |L222.18|
                  |L222.36|
000024  bf00              NOP      
000026  6001              STR      r1,[r0,#0]
000028  6042              STR      r2,[r0,#4]
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  e9dd0102          LDRD     r0,r1,[sp,#8]
000032  e9cd0100          STRD     r0,r1,[sp,#0]
000036  4298              CMP      r0,r3
000038  d102              BNE      |L222.64|
00003a  2001              MOVS     r0,#1
                  |L222.60|
;;;245    }
00003c  b004              ADD      sp,sp,#0x10
00003e  bdf0              POP      {r4-r7,pc}
                  |L222.64|
000040  2000              MOVS     r0,#0                 ;244
000042  e7fb              B        |L222.60|
;;;246    
                          ENDP


                          AREA ||area_number.223||, COMGROUP=_ZSt5equalIPhPKcEbT_S3_T0_, LINKORDER=||t._ZSt5equalIPhPKcEbT_S3_T0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.223||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZSt5equalIPhPKcEbT_S3_T0_||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "Source\\Protocols\\src\\modbus_app.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_app_cpp_BUF_SIZE___ZN36_INTERNAL_14_modbus_app_cpp_BUF_SIZE7__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___14_modbus_app_cpp_BUF_SIZE___ZN36_INTERNAL_14_modbus_app_cpp_BUF_SIZE7__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_app_cpp_BUF_SIZE___ZN36_INTERNAL_14_modbus_app_cpp_BUF_SIZE7__REVSHEi|
#line 402
|__asm___14_modbus_app_cpp_BUF_SIZE___ZN36_INTERNAL_14_modbus_app_cpp_BUF_SIZE7__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_app_cpp_BUF_SIZE___ZN36_INTERNAL_14_modbus_app_cpp_BUF_SIZE5__RRXEj|
#line 587
|__asm___14_modbus_app_cpp_BUF_SIZE___ZN36_INTERNAL_14_modbus_app_cpp_BUF_SIZE5__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
