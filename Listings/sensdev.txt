; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\sensdev.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sensdev.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\sensdev.crf Source\Main\src\SensDev.c]
                          THUMB

                          AREA ||i.HardSaveConst||, CODE, READONLY, ALIGN=1

                  HardSaveConst PROC
;;;317    // Сохраняет обе копии с подсчетом CRC
;;;318    void HardSaveConst(uint8_t *Flag) 
000000  4770              BX       lr
;;;319    {
;;;320    	
;;;321    }
;;;322    
                          ENDP


                          AREA ||i.IsEmuMode||, CODE, READONLY, ALIGN=2

                  IsEmuMode PROC
;;;455    // Возвращает 1 если включен режим эмуляции
;;;456    uint8_t IsEmuMode(void) 
000000  4803              LDR      r0,|L2.16|
;;;457    {
;;;458      return emutime?1:0;
000002  6800              LDR      r0,[r0,#0]  ; emutime
000004  b108              CBZ      r0,|L2.10|
000006  2001              MOVS     r0,#1
                  |L2.8|
;;;459    }
000008  4770              BX       lr
                  |L2.10|
00000a  2000              MOVS     r0,#0                 ;458
00000c  e7fc              B        |L2.8|
;;;460    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      emutime

                          AREA ||i.LoadConst||, CODE, READONLY, ALIGN=2

                  LoadConst PROC
;;;300    //данная функция вызывается для копирования настроек в буфер в ОЗУ
;;;301    void LoadConst(void) 
000000  b510              PUSH     {r4,lr}
;;;302    {
;;;303      Model.get_sets( DSt ); //запись в DSt из Model
000002  4902              LDR      r1,|L3.12|
000004  4802              LDR      r0,|L3.16|
000006  f7fffffe          BL       _ZN6TModel8get_setsER10MySettings ; TModel::get_sets(MySettings&)
;;;304    }
00000a  bd10              POP      {r4,pc}
;;;305    
                          ENDP

                  |L3.12|
                          DCD      ||DSt||
                  |L3.16|
                          DCD      Model

                          AREA ||i.ReadConst||, CODE, READONLY, ALIGN=1

                  ReadConst PROC
;;;326    // 2 - не устранимая ошибка
;;;327    uint8_t ReadConst(void) 
000000  4770              BX       lr
;;;328    {
;;;329      //должны проверяться 2 банка настроек, хранящихся во внешней памяти (flash/eeprom/fram/...)
;;;330      uint8_t res;
;;;331    //	res = EReadConst();
;;;332      return res;
;;;333    }
;;;334    
                          ENDP


                          AREA ||i.ReadTCTab||, CODE, READONLY, ALIGN=1

                  ReadTCTab PROC
;;;338    // 2 - не устранимая ошибка
;;;339    uint8_t ReadTCTab(void) 
000000  4770              BX       lr
;;;340    {
;;;341    	uint8_t res;
;;;342    	return res;
;;;343    //	return EReadTCTable();
;;;344    }
;;;345    
                          ENDP


                          AREA ||i.ReinitMemory||, CODE, READONLY, ALIGN=1

                  ReinitMemory PROC
;;;123    
;;;124    void ReinitMemory(void)
000000  4770              BX       lr
;;;125    {
;;;126    /*
;;;127    //// Начальное заполнение памяти
;;;128    //	uint32_t n,l;
;;;129    //	__packed uint8_t * p;
;;;130    //	l=sizeof(DSt);
;;;131    //	p=(__packed uint8_t *)(&DSt);
;;;132    //	for (n=0;n<l;n++) *(p++)=0;
;;;133    //	DSt.Addr = 1;
;;;134    //	DSt.optsens = 0x00; // последовательный интерфейс
;;;135    //	DSt.PswAdmin = 1234;
;;;136    //	DSt.PswSuper = 31.41;
;;;137    //	
;;;138    
;;;139    //	//метод измерения температуры (PNT8,0xE8) (0x00,0x16,0x0A)	
;;;140    
;;;141    //	// *((uint32_t*)(&HardDSt.tmethod)) = 0x0A160000; // метод измерения температуры
;;;142    //	*((uint32_t*)(&DSt.tmethod)) = 0x0A101200; // метод измерения температуры
;;;143    //	*((uint32_t*)(&DSt.izmprm)) = 0x00010000; // наличие измеряемых параметров(сейчас одно давление)
;;;144    //	DSt.adcgain = 1; // коэффициент усиления АЦП по давлению = 2
;;;145    
;;;146    //	DSt.kmul = 1; // мультипликативный коэф. PNT2
;;;147    //	DSt.kadd = 0; // аддитивный коэф. PNT1
;;;148    //	// В ЕДИНИЦАХ ИЗМЕРЕНИЯ ОТОБРАЖЕНИЯ ДОБАВИЛИСЬ ПРОЦЕНТЫ, 0x5E585B00 изменилось на 0x5F585B00 
;;;149    ////	*((uint32_t*)(&DSt.eizm5)) = 0x5E585B00; // единицы измерения отображения кгс/см^2
;;;150    ////	*((uint32_t*)(&DSt.eizmc)) = 0x5E585B00; // единицы измерения калибровки кгс/см^2
;;;151    ////	*((uint32_t*)(&DSt.eizmd)) = 0x5E585B00; // единицы измерения таблицы кгс/см^2
;;;152    //	*((uint32_t*)(&DSt.eizm5)) = 0x5F585900; // единицы измерения отображения кПа
;;;153    //	*((uint32_t*)(&DSt.eizmc)) = 0x5F585900; // единицы измерения калибровки кПа
;;;154    //	*((uint32_t*)(&DSt.eizmd)) = 0x5F585900; // единицы измерения таблицы кПа
;;;155    //	DSt.plow = 0; // PRESS_L
;;;156    //	DSt.phigh = 600; // PRESS_H
;;;157    //	
;;;158    //	DSt.pgist = 0.1; // гистерезис
;;;159    
;;;160    //	DSt.optsens = 0x00; // НЕ ВКЛЮЧАЕМ RS-485
;;;161    //	// Параметры RS485
;;;162    //	DSt.MBAddr = 1;
;;;163    //	DSt.OAddr = 0;  
;;;164    //	DSt.ProtMod = 0; // автоопределение протокола
;;;165    //	DSt.UMode = 0;  
;;;166    //	DSt.UPar = 0; //   битность/четность
;;;167    //	DSt.USpeed = 5; // 19200
;;;168    //	
;;;169    ////#################### Линия СЕНС #######################	
;;;170    //#ifdef __SENS
;;;171    //	SaveConst(0);
;;;172    //#endif
;;;173    ////^^^^^^^^^^^^^^^^^^^^^ Линия СЕНС ^^^^^^^^^^^^^^^^^^^^^^
;;;174    */
;;;175    }
;;;176    
                          ENDP


                          AREA ||i.SaveConst||, CODE, READONLY, ALIGN=1

                  SaveConst PROC
;;;309    //Передаваемый параметр - код измененного параметра или 0, если сохранять все
;;;310    void SaveConst(uint8_t pnum)
000000  4770              BX       lr
;;;311    {
;;;312    //  xSemaphoreGive( FlashData_WrSem ); //данные в DSt готовы, необходима валидация перед записью\
;;;313                                           в Model и во Flash микроконтроллера                                       
;;;314    }
;;;315    
                          ENDP


                          AREA ||i.SetProgNum||, CODE, READONLY, ALIGN=2

                  SetProgNum PROC
;;;471    
;;;472    void SetProgNum(uint32_t pgn) {
000000  0c01              LSRS     r1,r0,#16
;;;473      ProgNum[0]=(pgn>>16)&0xFF;
000002  4a03              LDR      r2,|L8.16|
000004  7011              STRB     r1,[r2,#0]
;;;474      ProgNum[1]=(pgn>>24)&0xFF;
000006  0e01              LSRS     r1,r0,#24
000008  7051              STRB     r1,[r2,#1]
;;;475      ProgNum[2]=(pgn>>8)&0xFF;
00000a  0a01              LSRS     r1,r0,#8
00000c  7091              STRB     r1,[r2,#2]
;;;476    }
00000e  4770              BX       lr
                          ENDP

                  |L8.16|
                          DCD      ProgNum

                          AREA ||i.SetTCPnt||, CODE, READONLY, ALIGN=1

                  SetTCPnt PROC
;;;353    //Номер команды - в buf[3]
;;;354    uint8_t SetTCPnt(uint8_t *buf)
000000  b520              PUSH     {r5,lr}
;;;355    {
000002  4605              MOV      r5,r0
;;;356      if (GetAccessMode() >= ADMINMODE)
000004  f7fffffe          BL       GetAccessMode
000008  2801              CMP      r0,#1
00000a  db01              BLT      |L9.16|
;;;357      {
;;;358        return 1; //калибровка доступна только для суперадминистратора
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;359      }
;;;360        
;;;361      bool CalReq;
;;;362    	
;;;363      taskENTER_CRITICAL();
;;;364    //    CalReq = MagCalReq;
;;;365      taskEXIT_CRITICAL();
;;;366      
;;;367      if (CalReq) //если калибровка уже запрошена через ЛИН или через Modbus
;;;368      {
;;;369        return 255U; //команда неизвестна
;;;370      }
;;;371      return 255U;
;;;372    //  else
;;;373    //  {
;;;374    //    /*
;;;375    //     * Определяем задачу из которой произошла попытка запустить калибровку
;;;376    //    */		
;;;377    //    TaskHandle_t CurTaskHandle = xTaskGetCurrentTaskHandle();
;;;378    //    
;;;379    //    if (CurTaskHandle == USARTHandle)
;;;380    //    {
;;;381    //      return cmd_handle(buf, NULL);  //при запросе на калибровку через USART по Modbus, сбрасывать таймер обратного отсчета в МСК не нужно
;;;382    //    }
;;;383    //    else if (CurTaskHandle == LineDataHandle)
;;;384    //    {
;;;385    //      return cmd_handle(buf, WaitCalStartSemphr); //при запрос калибровки через ЛИН, необходимо сбрасывать таймер обратного отсчета в МСК
;;;386    //    }
;;;387    //    else
;;;388    //    {
;;;389    //      return 255; //SetTCPnt() вызвана некорректно
;;;390    //    }
;;;391    //  }
;;;392    }
00000e  bd20              POP      {r5,pc}
                  |L9.16|
000010  f7fffffe          BL       vPortEnterCritical
000014  f7fffffe          BL       vPortExitCritical
000018  b10c              CBZ      r4,|L9.30|
00001a  20ff              MOVS     r0,#0xff              ;369
00001c  e7f7              B        |L9.14|
                  |L9.30|
00001e  20ff              MOVS     r0,#0xff              ;371
000020  e7f5              B        |L9.14|
;;;393    
                          ENDP


                          AREA ||i.TCPProc||, CODE, READONLY, ALIGN=2

                  TCPProc PROC
;;;462    // Вызывать постоянно в основном цикле
;;;463    void TCPProc(void) 
000000  b510              PUSH     {r4,lr}
;;;464    {
;;;465    	if(emutime) 
000002  4807              LDR      r0,|L10.32|
000004  6800              LDR      r0,[r0,#0]  ; emutime
000006  b148              CBZ      r0,|L10.28|
;;;466    	{
;;;467    		if (tdlt(emutime) > 600000) emutime = 0;
000008  4805              LDR      r0,|L10.32|
00000a  6800              LDR      r0,[r0,#0]  ; emutime
00000c  f7fffffe          BL       tdlt
000010  4904              LDR      r1,|L10.36|
000012  4288              CMP      r0,r1
000014  d902              BLS      |L10.28|
000016  2000              MOVS     r0,#0
000018  4901              LDR      r1,|L10.32|
00001a  6008              STR      r0,[r1,#0]  ; emutime
                  |L10.28|
;;;468    	}
;;;469    	
;;;470    }
00001c  bd10              POP      {r4,pc}
;;;471    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      emutime
                  |L10.36|
                          DCD      0x000927c0

                          AREA ||i.ThePredef||, CODE, READONLY, ALIGN=1

                  ThePredef PROC
;;;294    ////// Неизведанные меню - пустые
;;;295    uint8_t ThePredef(uint8_t mnum,uint8_t * buf) 
000000  b570              PUSH     {r4-r6,lr}
;;;296    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;297    	return Menu(mnum,buf);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _Z4MenuhPh ; Menu(unsigned char, unsigned char*)
;;;298    }
00000e  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP


                          AREA ||i._Z4MenuhPh||, CODE, READONLY, ALIGN=1

                  _Z4MenuhPh PROC ; Menu(unsigned char, unsigned char*)
;;;196    // СБОРКА СТРУКТУРЫ МЕНЮ
;;;197    uint8_t Menu(uint8_t mnum, uint8_t *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;199      uint8_t pos    = 3;
000006  2503              MOVS     r5,#3
;;;200    //  uint8_t access = 2;
;;;201      switch (mnum)
000008  2e03              CMP      r6,#3
00000a  d039              BEQ      |L12.128|
00000c  dc04              BGT      |L12.24|
00000e  2e01              CMP      r6,#1
000010  d007              BEQ      |L12.34|
000012  2e02              CMP      r6,#2
000014  d17e              BNE      |L12.276|
000016  e014              B        |L12.66|
                  |L12.24|
000018  2e80              CMP      r6,#0x80
00001a  d054              BEQ      |L12.198|
00001c  2e83              CMP      r6,#0x83
00001e  d179              BNE      |L12.276|
000020  e063              B        |L12.234|
                  |L12.34|
;;;202      {
;;;203        case (CMD_GETPI):               //получение всех измеряемых параметров
;;;204    //         buf[pos++] = PNT7;
;;;205    //         buf[pos++] = PNT8;
;;;206    //         buf[pos++] = CELS;
;;;207             buf[pos++] = LEVEL;
000022  2201              MOVS     r2,#1
000024  4628              MOV      r0,r5
000026  1c69              ADDS     r1,r5,#1
000028  b2cd              UXTB     r5,r1
00002a  5422              STRB     r2,[r4,r0]
;;;208             buf[pos++] = CELS;
00002c  2202              MOVS     r2,#2
00002e  4628              MOV      r0,r5
000030  1c69              ADDS     r1,r5,#1
000032  b2cd              UXTB     r5,r1
000034  5422              STRB     r2,[r4,r0]
;;;209             buf[pos++] = PERCENT;
000036  2203              MOVS     r2,#3
000038  4628              MOV      r0,r5
00003a  1c69              ADDS     r1,r5,#1
00003c  b2cd              UXTB     r5,r1
00003e  5422              STRB     r2,[r4,r0]
;;;210    //         buf[pos++] = PERCENT;
;;;211    //         access = GetAccessMode();  //получаем уровень доступа
;;;212    //         if(access < 1)             //в режиме суперпользователя
;;;213    //         {
;;;214    //           buf[pos++] = PLTIZM;   //код АЦП канала давления
;;;215    //         }
;;;216             break;
000040  e068              B        |L12.276|
                  |L12.66|
;;;217        case (CMD_GETPS):               //получение всех установочных параметров
;;;218             buf[pos++] = PNT1;
000042  22e1              MOVS     r2,#0xe1
000044  4628              MOV      r0,r5
000046  1c69              ADDS     r1,r5,#1
000048  b2cd              UXTB     r5,r1
00004a  5422              STRB     r2,[r4,r0]
;;;219             buf[pos++] = GIST1;
00004c  2281              MOVS     r2,#0x81
00004e  4628              MOV      r0,r5
000050  1c69              ADDS     r1,r5,#1
000052  b2cd              UXTB     r5,r1
000054  5422              STRB     r2,[r4,r0]
;;;220             buf[pos++] = PNT2;
000056  22e2              MOVS     r2,#0xe2
000058  4628              MOV      r0,r5
00005a  1c69              ADDS     r1,r5,#1
00005c  b2cd              UXTB     r5,r1
00005e  5422              STRB     r2,[r4,r0]
;;;221             buf[pos++] = GIST2;
000060  2282              MOVS     r2,#0x82
000062  4628              MOV      r0,r5
000064  1c69              ADDS     r1,r5,#1
000066  b2cd              UXTB     r5,r1
000068  5422              STRB     r2,[r4,r0]
;;;222             buf[pos++] = PNTB;
00006a  22eb              MOVS     r2,#0xeb
00006c  4628              MOV      r0,r5
00006e  1c69              ADDS     r1,r5,#1
000070  b2cd              UXTB     r5,r1
000072  5422              STRB     r2,[r4,r0]
;;;223             buf[pos++] = PNTC;
000074  22ec              MOVS     r2,#0xec
000076  4628              MOV      r0,r5
000078  1c69              ADDS     r1,r5,#1
00007a  b2cd              UXTB     r5,r1
00007c  5422              STRB     r2,[r4,r0]
;;;224             break;   
00007e  e049              B        |L12.276|
                  |L12.128|
;;;225        case (CMD_GETTN):               //получение кода программы и всех таблиц
;;;226        	   buf[pos++] = VERSION;
000080  22f2              MOVS     r2,#0xf2
000082  4628              MOV      r0,r5
000084  1c69              ADDS     r1,r5,#1
000086  b2cd              UXTB     r5,r1
000088  5422              STRB     r2,[r4,r0]
;;;227    //    	   buf[pos++] = LEVTAB;    	   
;;;228    //			if(HardDSt.pgist == 0)
;;;229    //    	   {
;;;230    //           buf[pos++] =  GISTF;	
;;;231    //    	   }   	   
;;;232    			if (GetAccessMode() < USERMODE) 
00008a  f7fffffe          BL       GetAccessMode
00008e  2802              CMP      r0,#2
000090  da09              BGE      |L12.166|
;;;233        	   {
;;;234        	   	buf[pos++] = MENUMOD;
000092  22ff              MOVS     r2,#0xff
000094  4628              MOV      r0,r5
000096  1c69              ADDS     r1,r5,#1
000098  b2cd              UXTB     r5,r1
00009a  5422              STRB     r2,[r4,r0]
;;;235        	   	buf[pos++] = MENU_PSWD;
00009c  2280              MOVS     r2,#0x80
00009e  4628              MOV      r0,r5
0000a0  1c69              ADDS     r1,r5,#1
0000a2  b2cd              UXTB     r5,r1
0000a4  5422              STRB     r2,[r4,r0]
                  |L12.166|
;;;236        	   }   	   
;;;237    //			if(HardDSt.optsens & OPT_UART)
;;;238    //    	   {  
;;;239    //    	   	buf[pos++] = MENUMOD;
;;;240    //    	   	buf[pos++] = MENU_SADA;
;;;241    //    	   }   	   
;;;242             buf[pos++] = M_TPNT;
0000a6  22e0              MOVS     r2,#0xe0
0000a8  4628              MOV      r0,r5
0000aa  1c69              ADDS     r1,r5,#1
0000ac  b2cd              UXTB     r5,r1
0000ae  5422              STRB     r2,[r4,r0]
;;;243        	   buf[pos++] = MENUMOD;
0000b0  22ff              MOVS     r2,#0xff
0000b2  4628              MOV      r0,r5
0000b4  1c69              ADDS     r1,r5,#1
0000b6  b2cd              UXTB     r5,r1
0000b8  5422              STRB     r2,[r4,r0]
;;;244             buf[pos++] = MENU_SADA;
0000ba  2283              MOVS     r2,#0x83
0000bc  4628              MOV      r0,r5
0000be  1c69              ADDS     r1,r5,#1
0000c0  b2cd              UXTB     r5,r1
0000c2  5422              STRB     r2,[r4,r0]
;;;245    //    	   if(GetAccessMode() == SUPERMODE)
;;;246    //			{
;;;247    //			  NumTPnt = cnNumTPnt[SUPERMODE]; //у суперадмина все калибровочные точки
;;;248    //			}
;;;249    //    	   else
;;;250    //			{
;;;251    //			  NumTPnt = cnNumTPnt[ADMINMODE]; //пользователь и администратор видит только 3 калибровочные точки
;;;252    //			}
;;;253        	   break;
0000c4  e026              B        |L12.276|
                  |L12.198|
;;;254    //    case (MENU_USER):                      //меню быстрого доступа
;;;255    //    	   buf[pos++] = MENUMOD;
;;;256    //    	   buf[pos++] = MENU_INPRM;
;;;257    //    	   buf[pos++] = MENUMOD;
;;;258    //    	   buf[pos++] = MENU_OUTPRM;
;;;259    //    	   break;
;;;260    //    case (MENU_INPRM):                     //вводимые параметры
;;;261    //    	   if(IsEmuMode())
;;;262    //			{
;;;263    //			  buf[pos++] = PRESS;
;;;264    //			}
;;;265    //    	   break;
;;;266    //    case (MENU_OUTPRM):                    //выводимые параметры 
;;;267    //    	   buf[pos++] = PRESS;
;;;268    //    	   break;
;;;269        case (MENU_PSWD):                      //пароли к режимам !!! УТОЧНИТЬ ПРИ ОТЛАДКЕ
;;;270        	   if (GetAccessMode() != USERMODE)
0000c6  f7fffffe          BL       GetAccessMode
0000ca  2802              CMP      r0,#2
0000cc  d004              BEQ      |L12.216|
;;;271    			{
;;;272    			  buf[pos++] = PASSWD1;
0000ce  22f5              MOVS     r2,#0xf5
0000d0  4628              MOV      r0,r5
0000d2  1c69              ADDS     r1,r5,#1
0000d4  b2cd              UXTB     r5,r1
0000d6  5422              STRB     r2,[r4,r0]
                  |L12.216|
;;;273    			}
;;;274        	   if (GetAccessMode() == SUPERMODE)
0000d8  f7fffffe          BL       GetAccessMode
0000dc  b920              CBNZ     r0,|L12.232|
;;;275    			{
;;;276    			  buf[pos++] = PASSWD2;
0000de  22f6              MOVS     r2,#0xf6
0000e0  4628              MOV      r0,r5
0000e2  1c69              ADDS     r1,r5,#1
0000e4  b2cd              UXTB     r5,r1
0000e6  5422              STRB     r2,[r4,r0]
                  |L12.232|
;;;277    			} 
;;;278        	   break;
0000e8  e014              B        |L12.276|
                  |L12.234|
;;;279        case (MENU_SADA): //меню настройки адаптера
;;;280        	   buf[pos++] = RS232SPEED;
0000ea  2240              MOVS     r2,#0x40
0000ec  4628              MOV      r0,r5
0000ee  1c69              ADDS     r1,r5,#1
0000f0  b2cd              UXTB     r5,r1
0000f2  5422              STRB     r2,[r4,r0]
;;;281        	   buf[pos++] = RS232PARITY;
0000f4  2241              MOVS     r2,#0x41
0000f6  4628              MOV      r0,r5
0000f8  1c69              ADDS     r1,r5,#1
0000fa  b2cd              UXTB     r5,r1
0000fc  5422              STRB     r2,[r4,r0]
;;;282        	   buf[pos++] = MODIFY;
0000fe  2244              MOVS     r2,#0x44
000100  4628              MOV      r0,r5
000102  1c69              ADDS     r1,r5,#1
000104  b2cd              UXTB     r5,r1
000106  5422              STRB     r2,[r4,r0]
;;;283        	   buf[pos++] = MODADDR;
000108  2242              MOVS     r2,#0x42
00010a  4628              MOV      r0,r5
00010c  1c69              ADDS     r1,r5,#1
00010e  b2cd              UXTB     r5,r1
000110  5422              STRB     r2,[r4,r0]
;;;284        	   break;
000112  bf00              NOP      
                  |L12.276|
000114  bf00              NOP                            ;216
;;;285      }
;;;286     
;;;287      buf[0] = --pos;
000116  1e68              SUBS     r0,r5,#1
000118  b2c0              UXTB     r0,r0
00011a  4605              MOV      r5,r0
00011c  7020              STRB     r0,[r4,#0]
;;;288      return pos;
00011e  4628              MOV      r0,r5
;;;289    }
000120  bd70              POP      {r4-r6,pc}
;;;290    
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i.ReinitMemory||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.ReinitMemory||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._Z4MenuhPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z4MenuhPh||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i.ThePredef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ThePredef||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i.LoadConst||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.LoadConst||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i.SaveConst||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.SaveConst||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.HardSaveConst||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.HardSaveConst||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i.ReadConst||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ReadConst||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i.ReadTCTab||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ReadTCTab||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i.SetTCPnt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.SetTCPnt||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i.IsEmuMode||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.IsEmuMode||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i.TCPProc||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.TCPProc||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i.SetProgNum||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.SetProgNum||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UserDSt
                          %        22
                  FactoryDSt
                          %        22

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  cnNumTPnt
000000  40e00000          DCFS     0x40e00000 ; 7
000004  40400000          DCFS     0x40400000 ; 3
000008  40400000          DCFS     0x40400000 ; 3
                  Params
00000c  e1e0              DCB      0xe1,0xe0
                          DCDU     ||DSt||+0x9
000012  81e0              DCB      0x81,0xe0
                          DCD      ||DSt||+0xa
000018  ebe0              DCB      0xeb,0xe0
                          DCDU     ||DSt||+0xb
00001e  46ed              DCB      0x46,0xed
                          DCD      ||DSt||+0x10
000024  01c0              DCB      0x01,0xc0
                          DCDU     ||cdt||
00002a  02c0              DCB      0x02,0xc0
                          DCD      ||cdt||+0x4
000030  03c0              DCB      0x03,0xc0
                          DCDU     ||cdt||+0x8
000036  1fc0              DCB      0x1f,0xc0
                          DCD      ||cdt||+0x10
00003c  42e1              DCB      0x42,0xe1
                          DCDU     ||DSt||+0x13
000042  40e1              DCB      0x40,0xe1
                          DCD      ||DSt||+0x14
000048  41e1              DCB      0x41,0xe1
                          DCDU     ||DSt||+0x15
00004e  f3cc              DCB      0xf3,0xcc
                          DCD      ProgNum
000054  f2cc              DCB      0xf2,0xcc
                          DCDU     ProgNum
00005a  f1ee              DCB      0xf1,0xee
                          DCD      ||DSt||
000060  f5a0              DCB      0xf5,0xa0
                          DCDU     ||DSt||+0x1
000066  f650              DCB      0xf6,0x50
                          DCD      ||DSt||+0x5
00006c  f0cc              DCB      0xf0,0xcc
                          DCDU     ||cdt||+0x14
000072  e0c0              DCB      0xe0,0xc0
                          DCD      NumTPnt
000078  0000              DCB      0x00,0x00
                          DCDU     0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  dbg_val
000000  07000000          DCB      0x07,0x00,0x00,0x00
                  NumTPnt
000004  40400000          DCFS     0x40400000 ; 3
                  emutime
                          DCD      0x00000000
                  ProgNum
00000c  00fc0000          DCB      0x00,0xfc,0x00,0x00
                  emumode
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\Main\\src\\SensDev.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_SensDev_c_dbg_val___ZN29_INTERNAL_9_SensDev_c_dbg_val7__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___9_SensDev_c_dbg_val___ZN29_INTERNAL_9_SensDev_c_dbg_val7__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_SensDev_c_dbg_val___ZN29_INTERNAL_9_SensDev_c_dbg_val7__REVSHEi|
#line 402
|__asm___9_SensDev_c_dbg_val___ZN29_INTERNAL_9_SensDev_c_dbg_val7__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_SensDev_c_dbg_val___ZN29_INTERNAL_9_SensDev_c_dbg_val5__RRXEj|
#line 587
|__asm___9_SensDev_c_dbg_val___ZN29_INTERNAL_9_SensDev_c_dbg_val5__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
