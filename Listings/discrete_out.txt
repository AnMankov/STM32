; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\discrete_out.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\discrete_out.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\discrete_out.crf Source\Tasks\src\discrete_out.cpp]
                          THUMB

                          AREA ||i._Z10test_calibh||, CODE, READONLY, ALIGN=2

                  _Z10test_calibh PROC ; test_calib(unsigned char)
;;;140    //----- Тестовая функция --------------------------------------------------------------------------------------------
;;;141    void test_calib( uint8_t Nbr )
000000  b510              PUSH     {r4,lr}
;;;142    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;143      SemaphoreHandle_t *Sem[] =
000006  2218              MOVS     r2,#0x18
000008  4907              LDR      r1,|L1.40|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;144      {
;;;145        &AccCalib_X_UP_Sem, 
;;;146        &AccCalib_X_DOWN_Sem,
;;;147        &AccCalib_Y_UP_Sem, 
;;;148        &AccCalib_Y_DOWN_Sem,
;;;149        &AccCalib_Z_UP_Sem, 
;;;150        &AccCalib_Z_DOWN_Sem,
;;;151      };
;;;152    
;;;153      if ( Nbr != 10U )
000010  2c0a              CMP      r4,#0xa
000012  d007              BEQ      |L1.36|
;;;154      {
;;;155        xSemaphoreGive( *Sem[Nbr] );
000014  f85d1024          LDR      r1,[sp,r4,LSL #2]
000018  2300              MOVS     r3,#0
00001a  461a              MOV      r2,r3
00001c  6808              LDR      r0,[r1,#0]
00001e  4619              MOV      r1,r3
000020  f7fffffe          BL       xQueueGenericSend
                  |L1.36|
;;;156      }
;;;157    }
000024  b006              ADD      sp,sp,#0x18
000026  bd10              POP      {r4,pc}
;;;158    //\---- Таймер RTOS -------------------------------------------------------------------------------------------------
                          ENDP

                  |L1.40|
                          DCD      ||.constdata||+0x20

                          AREA ||i._Z12discrete_outPv||, CODE, READONLY, ALIGN=1

                  _Z12discrete_outPv PROC ; discrete_out(void*)
;;;70     //----- Задача RTOS -------------------------------------------------------------------------------------------------
;;;71     void discrete_out( void *Params ) //управление дискретным выходом
000000  bf00              NOP      
;;;72     {
;;;73       constexpr uint8_t DLY = 10U; //[мс]
;;;74       
;;;75       for ( ;; )
000002  bf00              NOP      
                  |L2.4|
;;;76       {
;;;77         vTaskDelay( pdMS_TO_TICKS( DLY ) );
000004  200a              MOVS     r0,#0xa
000006  f7fffffe          BL       vTaskDelay
00000a  e7fb              B        |L2.4|
;;;78       }
;;;79     
;;;80       Do.init();
;;;81     
;;;82       typedef void (TDiscreteOut::*TFnct)();
;;;83     
;;;84       TFnct Fnct[  ][ TSettings::_HC_MAX ] =
;;;85       {
;;;86         &TDiscreteOut::open,   //[ _N_OPENED ][ _CLOSED ]
;;;87         &TDiscreteOut::closed, //[ _N_OPENED ][ _OPEN   ]
;;;88         &TDiscreteOut::closed, //[ _N_CLOSED ][ _CLOSED ]
;;;89         &TDiscreteOut::open,   //[ _N_CLOSED ][ _OPEN   ]
;;;90       };
;;;91     
;;;92     //  while ( Model.get_accel_calib_sign() == TModel::_ACC_UNCALIBRATED )
;;;93     //  {
;;;94     //    Do.uncalib_acc(); //при некалиброванном акселерометре на дискретном выходе формируется спец сигнал
;;;95     //  }
;;;96     
;;;97       for (;;)
;;;98       {
;;;99         TModel::TDevType DevType = Model.get_dev_type();
;;;100    
;;;101        uint8_t CodeSw = Model.get_code_sw();
;;;102    
;;;103        TContact Set;
;;;104        Set = Model.get_d_o_sets();
;;;105    
;;;106        TSettings::THC HCState = Model.get_hc_state();
;;;107    
;;;108        if ( 
;;;109            DevType == TModel::_HC //для датчика первичным является состояние кодового переключателя
;;;110            &&
;;;111            CodeSw == 0U           //"0" => датчик ждет синхронизацию с базой и ...
;;;112           )
;;;113        {
;;;114          Do.open();               //отключает (размыкает) свой дискретный выход
;;;115        }
;;;116        else
;;;117        {
;;;118          ( Do.*Fnct[Set][HCState] )();
;;;119        }
;;;120    
;;;121        vTaskDelay( pdMS_TO_TICKS( DLY ) );
;;;122        
;;;123        static uint8_t Nbr = 10U;
;;;124        
;;;125        test_calib( Nbr );    
;;;126        
;;;127      }
;;;128    }
;;;129    //\---- Задача RTOS -------------------------------------------------------------------------------------------------
                          ENDP


                          AREA ||i._Z14do_uncalib_tmrPv||, CODE, READONLY, ALIGN=2

                  _Z14do_uncalib_tmrPv PROC ; do_uncalib_tmr(void*)
;;;132    //----- Таймер RTOS -------------------------------------------------------------------------------------------------
;;;133    void do_uncalib_tmr( TimerHandle_t xTimer ) //обработка таймера кодового переключателя
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135      xSemaphoreGive(DoUncalibTmr_TrigSem);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  4619              MOV      r1,r3
00000a  4802              LDR      r0,|L3.20|
00000c  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr_TrigSem
00000e  f7fffffe          BL       xQueueGenericSend
;;;136    }
000012  bd10              POP      {r4,pc}
;;;137    //\---- Таймер RTOS -------------------------------------------------------------------------------------------------
                          ENDP

                  |L3.20|
                          DCD      DoUncalibTmr_TrigSem

                          AREA ||i._ZN12TDiscreteOut11uncalib_accEv||, CODE, READONLY, ALIGN=2

                  _ZN12TDiscreteOut11uncalib_accEv PROC ; TDiscreteOut::uncalib_acc()
;;;49     
;;;50     void TDiscreteOut::uncalib_acc() //формирование спец сигнала при некалиброванном акселерометре
000000  b5f8              PUSH     {r3-r7,lr}
;;;51     {
000002  4604              MOV      r4,r0
;;;52     //  LL_GPIO_ResetOutputPin( Pin.Gpio, Pin.Nbr );
;;;53       constexpr uint8_t MAX_PULSE_NBR = 3;
000004  2603              MOVS     r6,#3
;;;54     
;;;55       LL_GPIO_SetOutputPin( Pin.Gpio, Pin.Nbr );
000006  6822              LDR      r2,[r4,#0]
000008  ca03              LDM      r2!,{r0,r1}
00000a  f7fffffe          BL       _ZN32_INTERNAL_16_discrete_out_cpp_Do20LL_GPIO_SetOutputPinEP12GPIO_TypeDefj ; [local to discrete_out_cpp]::LL_GPIO_SetOutputPin(GPIO_TypeDef*, unsigned)
;;;56       for ( uint8_t Ctr = 0; Ctr < MAX_PULSE_NBR ; ++Ctr)
00000e  2500              MOVS     r5,#0
000010  e014              B        |L4.60|
                  |L4.18|
;;;57       {
;;;58         xTimerStart( DoUncalibTmr, 0U );
000012  f7fffffe          BL       xTaskGetTickCount
000016  4607              MOV      r7,r0
000018  2000              MOVS     r0,#0
00001a  4603              MOV      r3,r0
00001c  463a              MOV      r2,r7
00001e  2101              MOVS     r1,#1
000020  9000              STR      r0,[sp,#0]
000022  481f              LDR      r0,|L4.160|
000024  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr
000026  f7fffffe          BL       xTimerGenericCommand
;;;59         xSemaphoreTake( DoUncalibTmr_TrigSem, portMAX_DELAY ); //ожидание срабатывания таймера
00002a  2300              MOVS     r3,#0
00002c  1e5a              SUBS     r2,r3,#1
00002e  4619              MOV      r1,r3
000030  481c              LDR      r0,|L4.164|
000032  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr_TrigSem
000034  f7fffffe          BL       xQueueGenericReceive
000038  1c68              ADDS     r0,r5,#1              ;56
00003a  b2c5              UXTB     r5,r0                 ;56
                  |L4.60|
00003c  2d03              CMP      r5,#3                 ;56
00003e  dbe8              BLT      |L4.18|
;;;60       }
;;;61       xTimerStop( DoUncalibTmr, 0U ); //если таймер по неопределенной причине не закончил считать
000040  2000              MOVS     r0,#0
000042  4603              MOV      r3,r0
000044  4602              MOV      r2,r0
000046  2103              MOVS     r1,#3
000048  9000              STR      r0,[sp,#0]
00004a  4815              LDR      r0,|L4.160|
00004c  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr
00004e  f7fffffe          BL       xTimerGenericCommand
;;;62       xTimerChangePeriod( DoUncalibTmr, pdMS_TO_TICKS( DLY_TIME_MS ), 0U );
000052  2000              MOVS     r0,#0
000054  4603              MOV      r3,r0
000056  f44f722f          MOV      r2,#0x2bc
00005a  2104              MOVS     r1,#4
00005c  9000              STR      r0,[sp,#0]
00005e  4810              LDR      r0,|L4.160|
000060  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr
000062  f7fffffe          BL       xTimerGenericCommand
;;;63       xTimerStart( DoUncalibTmr, 0U );
000066  f7fffffe          BL       xTaskGetTickCount
00006a  4605              MOV      r5,r0
00006c  2000              MOVS     r0,#0
00006e  4603              MOV      r3,r0
000070  462a              MOV      r2,r5
000072  2101              MOVS     r1,#1
000074  9000              STR      r0,[sp,#0]
000076  480a              LDR      r0,|L4.160|
000078  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr
00007a  f7fffffe          BL       xTimerGenericCommand
;;;64       xSemaphoreTake( DoUncalibTmr_TrigSem, portMAX_DELAY ); //ожидание срабатывания таймера
00007e  2300              MOVS     r3,#0
000080  1e5a              SUBS     r2,r3,#1
000082  4619              MOV      r1,r3
000084  4807              LDR      r0,|L4.164|
000086  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr_TrigSem
000088  f7fffffe          BL       xQueueGenericReceive
;;;65       xTimerChangePeriod( DoUncalibTmr, pdMS_TO_TICKS( PULSE_TIME_MS ), 0U );
00008c  2000              MOVS     r0,#0
00008e  4603              MOV      r3,r0
000090  2264              MOVS     r2,#0x64
000092  2104              MOVS     r1,#4
000094  9000              STR      r0,[sp,#0]
000096  4802              LDR      r0,|L4.160|
000098  6800              LDR      r0,[r0,#0]  ; DoUncalibTmr
00009a  f7fffffe          BL       xTimerGenericCommand
;;;66     }
00009e  bdf8              POP      {r3-r7,pc}
;;;67     
                          ENDP

                  |L4.160|
                          DCD      DoUncalibTmr
                  |L4.164|
                          DCD      DoUncalibTmr_TrigSem

                          AREA ||i._ZN12TDiscreteOut4initEv||, CODE, READONLY, ALIGN=2

                  _ZN12TDiscreteOut4initEv PROC ; TDiscreteOut::init()
;;;17     
;;;18     void TDiscreteOut::init()
000000  b510              PUSH     {r4,lr}
;;;19     {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;20       if ( !LL_AHB2_GRP1_IsEnabledClock( Pin.ClkPortMask ) )
000006  6821              LDR      r1,[r4,#0]
000008  6888              LDR      r0,[r1,#8]
00000a  4913              LDR      r1,|L5.88|
00000c  6cc9              LDR      r1,[r1,#0x4c]
00000e  4001              ANDS     r1,r1,r0
000010  4281              CMP      r1,r0
000012  d101              BNE      |L5.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L5.26|
                  |L5.24|
000018  2100              MOVS     r1,#0
                  |L5.26|
00001a  b969              CBNZ     r1,|L5.56|
;;;21       {
;;;22         LL_AHB2_GRP1_EnableClock( Pin.ClkPortMask );
00001c  6821              LDR      r1,[r4,#0]
00001e  6888              LDR      r0,[r1,#8]
000020  490d              LDR      r1,|L5.88|
000022  6cc9              LDR      r1,[r1,#0x4c]
000024  4301              ORRS     r1,r1,r0
000026  4a0c              LDR      r2,|L5.88|
000028  64d1              STR      r1,[r2,#0x4c]
00002a  4611              MOV      r1,r2
00002c  6cc9              LDR      r1,[r1,#0x4c]
00002e  4001              ANDS     r1,r1,r0
000030  9101              STR      r1,[sp,#4]
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
                  |L5.56|
;;;23       }
;;;24     
;;;25       LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;26       GPIO_InitStruct.Pin        = Pin.Nbr;
000038  6820              LDR      r0,[r4,#0]
00003a  6840              LDR      r0,[r0,#4]
00003c  9002              STR      r0,[sp,#8]
;;;27       GPIO_InitStruct.Mode       = LL_GPIO_MODE_OUTPUT;
00003e  2001              MOVS     r0,#1
000040  9003              STR      r0,[sp,#0xc]
;;;28       GPIO_InitStruct.Speed      = LL_GPIO_SPEED_FREQ_LOW;
000042  2000              MOVS     r0,#0
000044  9004              STR      r0,[sp,#0x10]
;;;29       GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
000046  9005              STR      r0,[sp,#0x14]
;;;30       GPIO_InitStruct.Pull       = LL_GPIO_PULL_NO;
000048  9006              STR      r0,[sp,#0x18]
;;;31     
;;;32       LL_GPIO_Init( Pin.Gpio, &GPIO_InitStruct );
00004a  6821              LDR      r1,[r4,#0]
00004c  6808              LDR      r0,[r1,#0]
00004e  a902              ADD      r1,sp,#8
000050  f7fffffe          BL       LL_GPIO_Init
;;;33     }
000054  b008              ADD      sp,sp,#0x20
000056  bd10              POP      {r4,pc}
;;;34     
                          ENDP

                  |L5.88|
                          DCD      0x40021000

                          AREA ||i._ZN12TDiscreteOut4openEv||, CODE, READONLY, ALIGN=1

                  _ZN12TDiscreteOut4openEv PROC ; TDiscreteOut::open()
;;;39     
;;;40     void TDiscreteOut::open() //разомкнуть
000000  6803              LDR      r3,[r0,#0]
;;;41     {
;;;42       LL_GPIO_ResetOutputPin( Pin.Gpio, Pin.Nbr );
000002  cb06              LDM      r3!,{r1,r2}
000004  628a              STR      r2,[r1,#0x28]
000006  bf00              NOP      
;;;43     }
000008  4770              BX       lr
;;;44     
                          ENDP


                          AREA ||i._ZN12TDiscreteOut6closedEv||, CODE, READONLY, ALIGN=1

                  _ZN12TDiscreteOut6closedEv PROC ; TDiscreteOut::closed()
;;;34     
;;;35     void TDiscreteOut::closed() //замкнуть
000000  b510              PUSH     {r4,lr}
;;;36     {
000002  4604              MOV      r4,r0
;;;37       LL_GPIO_SetOutputPin( Pin.Gpio, Pin.Nbr );
000004  6822              LDR      r2,[r4,#0]
000006  ca03              LDM      r2!,{r0,r1}
000008  f7fffffe          BL       _ZN32_INTERNAL_16_discrete_out_cpp_Do20LL_GPIO_SetOutputPinEP12GPIO_TypeDefj ; [local to discrete_out_cpp]::LL_GPIO_SetOutputPin(GPIO_TypeDef*, unsigned)
;;;38     }
00000c  bd10              POP      {r4,pc}
;;;39     
                          ENDP


                          AREA ||i._ZN12TDiscreteOut6toggleEv||, CODE, READONLY, ALIGN=1

                  _ZN12TDiscreteOut6toggleEv PROC ; TDiscreteOut::toggle()
;;;44     
;;;45     void TDiscreteOut::toggle() //переключить
000000  6803              LDR      r3,[r0,#0]
;;;46     {
;;;47       LL_GPIO_TogglePin( Pin.Gpio, Pin.Nbr );
000002  cb06              LDM      r3!,{r1,r2}
000004  694b              LDR      r3,[r1,#0x14]
000006  4053              EORS     r3,r3,r2
000008  614b              STR      r3,[r1,#0x14]
00000a  bf00              NOP      
;;;48     }
00000c  4770              BX       lr
;;;49     
                          ENDP


                          AREA ||i._ZN12TDiscreteOutC1ERK4TPin||, CODE, READONLY, ALIGN=1

                  _ZN12TDiscreteOutC2ERK4TPin                  ; Alternate entry point ; TDiscreteOut::TDiscreteOut__sub_object(const TPin&)
                  _ZN12TDiscreteOutC1ERK4TPin PROC ; TDiscreteOut::TDiscreteOut(const TPin&)
;;;5      
;;;6      TDiscreteOut::TDiscreteOut( const TPin &_Pin )
;;;7      :
;;;8      Pin( _Pin )
;;;9      {
;;;10     
;;;11     }
;;;12     
000000  6001              STR      r1,[r0,#0]
000002  4770              BX       lr
                          ENDP


                          AREA ||i._ZN12TDiscreteOutD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN12TDiscreteOutD2Ev                  ; Alternate entry point ; TDiscreteOut::~TDiscreteOut__sub_object()
                  _ZN12TDiscreteOutD1Ev PROC ; TDiscreteOut::~TDiscreteOut()
;;;12     
;;;13     TDiscreteOut::~TDiscreteOut()
;;;14     {
;;;15     
;;;16     }
;;;17     
000000  4770              BX       lr
                          ENDP


                          AREA ||i._ZN32_INTERNAL_16_discrete_out_cpp_Do20LL_GPIO_SetOutputPinEP12GPIO_TypeDefj||, CODE, READONLY, ALIGN=1

                  _ZN32_INTERNAL_16_discrete_out_cpp_Do20LL_GPIO_SetOutputPinEP12GPIO_TypeDefj PROC ; [local to discrete_out_cpp]::LL_GPIO_SetOutputPin(GPIO_TypeDef*, unsigned)
;;;963      */
;;;964    __STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
000000  6181              STR      r1,[r0,#0x18]
;;;965    {
;;;966      WRITE_REG(GPIOx->BSRR, PinMask);
;;;967    }
000002  4770              BX       lr
;;;968    
                          ENDP


                          AREA ||i.__sti___16_discrete_out_cpp_Do||, CODE, READONLY, ALIGN=2

                  __sti___16_discrete_out_cpp_Do PROC
000000  b510              PUSH     {r4,lr}
000002  4905              LDR      r1,|L12.24|
000004  4805              LDR      r0,|L12.28|
000006  f7fffffe          BL       _ZN12TDiscreteOutC1ERK4TPin ; TDiscreteOut::TDiscreteOut(const TPin&)
00000a  4604              MOV      r4,r0
00000c  4a04              LDR      r2,|L12.32|
00000e  4905              LDR      r1,|L12.36|
000010  f7fffffe          BL       __aeabi_atexit
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      DO_HW
                  |L12.28|
                          DCD      ||Do||
                  |L12.32|
                          DCD      __dso_handle
                  |L12.36|
                          DCD      _ZN12TDiscreteOutD1Ev ; TDiscreteOut::~TDiscreteOut()

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z10test_calibh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z10test_calibh||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._ZN12TDiscreteOut4openEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOut4openEv||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i._ZN12TDiscreteOut4initEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOut4initEv||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._Z12discrete_outPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z12discrete_outPv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._Z14do_uncalib_tmrPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14do_uncalib_tmrPv||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._ZN12TDiscreteOutC1ERK4TPin||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOutC1ERK4TPin||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._ZN12TDiscreteOutD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOutD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._ZN12TDiscreteOut6closedEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOut6closedEv||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._ZN12TDiscreteOut6toggleEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOut6toggleEv||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._ZN12TDiscreteOut11uncalib_accEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN12TDiscreteOut11uncalib_accEv||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i.__sti___16_discrete_out_cpp_Do||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___16_discrete_out_cpp_Do||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i._ZN32_INTERNAL_16_discrete_out_cpp_Do20LL_GPIO_SetOutputPinEP12GPIO_TypeDefj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN32_INTERNAL_16_discrete_out_cpp_Do20LL_GPIO_SetOutputPinEP12GPIO_TypeDefj||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      _ZN12TDiscreteOut4openEv ; TDiscreteOut::open()
                          DCD      0x00000000
                          DCD      _ZN12TDiscreteOut6closedEv ; TDiscreteOut::closed()
                          DCD      0x00000000
                          DCD      _ZN12TDiscreteOut6closedEv ; TDiscreteOut::closed()
                          DCD      0x00000000
                          DCD      _ZN12TDiscreteOut4openEv ; TDiscreteOut::open()
                          DCD      0x00000000
                          DCD      AccCalib_X_UP_Sem
                          DCD      AccCalib_X_DOWN_Sem
                          DCD      AccCalib_Y_UP_Sem
                          DCD      AccCalib_Y_DOWN_Sem
                          DCD      AccCalib_Z_UP_Sem
                          DCD      AccCalib_Z_DOWN_Sem

                          AREA ||.data||, DATA, ALIGN=2

                  ||Do||
                          DCD      0x00000000
                  _ZZ12discrete_outPvE3Nbr ; discrete_out(void*)::Nbr
000004  0a                DCB      0x0a

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___16_discrete_out_cpp_Do

;*** Start embedded assembler ***

#line 1 "Source\\Tasks\\src\\discrete_out.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_discrete_out_cpp_Do___ZN32_INTERNAL_16_discrete_out_cpp_Do7__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___16_discrete_out_cpp_Do___ZN32_INTERNAL_16_discrete_out_cpp_Do7__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_discrete_out_cpp_Do___ZN32_INTERNAL_16_discrete_out_cpp_Do7__REVSHEi|
#line 402
|__asm___16_discrete_out_cpp_Do___ZN32_INTERNAL_16_discrete_out_cpp_Do7__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_discrete_out_cpp_Do___ZN32_INTERNAL_16_discrete_out_cpp_Do5__RRXEj|
#line 587
|__asm___16_discrete_out_cpp_Do___ZN32_INTERNAL_16_discrete_out_cpp_Do5__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
