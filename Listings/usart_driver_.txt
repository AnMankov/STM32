; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\usart_driver_.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart_driver_.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I.\Source\Ext_Dev\inc\AT45 -I.\Objects -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\usart_driver_.crf Source\MCU_Drivers\src\usart_driver_.cpp]
                          THUMB

                          AREA ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17520LL_USART_SetBaudRateEP13USART_TypeDefjjj||, CODE, READONLY, ALIGN=1

                  _ZN39_INTERNAL_17_usart_driver__cpp_b612a17520LL_USART_SetBaudRateEP13USART_TypeDefjjj PROC ; [local to usart_driver__cpp]::LL_USART_SetBaudRate(USART_TypeDef*, unsigned, unsigned, unsigned)
;;;1987   #else
;;;1988   __STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
000000  b570              PUSH     {r4-r6,lr}
;;;1989                                             uint32_t BaudRate)
;;;1990   #endif
;;;1991   {
;;;1992     register uint32_t usartdiv = 0x0U;
000002  2400              MOVS     r4,#0
;;;1993     register uint32_t brrtemp = 0x0U;
000004  2500              MOVS     r5,#0
;;;1994   
;;;1995     if (OverSampling == LL_USART_OVERSAMPLING_8)
000006  f5b24f00          CMP      r2,#0x8000
00000a  d10e              BNE      |L1.42|
;;;1996     {
;;;1997   #if defined(USART_PRESC_PRESCALER)
;;;1998       usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint16_t)PrescalerValue, BaudRate));
;;;1999   #else
;;;2000       usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
00000c  004e              LSLS     r6,r1,#1
00000e  eb060653          ADD      r6,r6,r3,LSR #1
000012  fbb6f6f3          UDIV     r6,r6,r3
000016  b2b4              UXTH     r4,r6
;;;2001   #endif
;;;2002       brrtemp = usartdiv & 0xFFF0U;
000018  f64f76f0          MOV      r6,#0xfff0
00001c  ea040506          AND      r5,r4,r6
;;;2003       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
000020  f3c40642          UBFX     r6,r4,#1,#3
000024  4335              ORRS     r5,r5,r6
;;;2004       USARTx->BRR = brrtemp;
000026  60c5              STR      r5,[r0,#0xc]
000028  e005              B        |L1.54|
                  |L1.42|
;;;2005     }
;;;2006     else
;;;2007     {
;;;2008   #if defined(USART_PRESC_PRESCALER)
;;;2009       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint16_t)PrescalerValue, BaudRate));
;;;2010   #else
;;;2011       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
00002a  eb010653          ADD      r6,r1,r3,LSR #1
00002e  fbb6f6f3          UDIV     r6,r6,r3
000032  b2b6              UXTH     r6,r6
000034  60c6              STR      r6,[r0,#0xc]
                  |L1.54|
;;;2012   #endif
;;;2013     }
;;;2014   }
000036  bd70              POP      {r4-r6,pc}
;;;2015   
                          ENDP


                          AREA ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17521LL_USART_ReceiveData8EP13USART_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN39_INTERNAL_17_usart_driver__cpp_b612a17521LL_USART_ReceiveData8EP13USART_TypeDef PROC ; [local to usart_driver__cpp]::LL_USART_ReceiveData8(USART_TypeDef*)
;;;4526     */
;;;4527   __STATIC_INLINE uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
000000  4601              MOV      r1,r0
;;;4528   {
;;;4529     return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
000002  8c88              LDRH     r0,[r1,#0x24]
000004  b2c0              UXTB     r0,r0
;;;4530   }
000006  4770              BX       lr
;;;4531   
                          ENDP


                          AREA ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17522LL_USART_ClearFlag_RTOEP13USART_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN39_INTERNAL_17_usart_driver__cpp_b612a17522LL_USART_ClearFlag_RTOEP13USART_TypeDef PROC ; [local to usart_driver__cpp]::LL_USART_ClearFlag_RTO(USART_TypeDef*)
;;;3550     */
;;;3551   __STATIC_INLINE void LL_USART_ClearFlag_RTO(USART_TypeDef *USARTx)
000000  f44f6100          MOV      r1,#0x800
;;;3552   {
;;;3553     WRITE_REG(USARTx->ICR, USART_ICR_RTOCF);
000004  6201              STR      r1,[r0,#0x20]
;;;3554   }
000006  4770              BX       lr
;;;3555   
                          ENDP


                          AREA ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17526LL_USART_IsActiveFlag_RXNEEP13USART_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN39_INTERNAL_17_usart_driver__cpp_b612a17526LL_USART_IsActiveFlag_RXNEEP13USART_TypeDef PROC ; [local to usart_driver__cpp]::LL_USART_IsActiveFlag_RXNE(USART_TypeDef*)
;;;3123     */
;;;3124   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx)
000000  4601              MOV      r1,r0
;;;3125   {
;;;3126     return (READ_BIT(USARTx->ISR, USART_ISR_RXNE) == (USART_ISR_RXNE));
000002  69c8              LDR      r0,[r1,#0x1c]
000004  f3c01040          UBFX     r0,r0,#5,#1
;;;3127   }
000008  4770              BX       lr
;;;3128   #endif
                          ENDP


                          AREA ||i._ZN6TUsart10disable_rxEv||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart10disable_rxEv PROC ; TUsart::disable_rx()
;;;294    
;;;295    void TUsart::disable_rx()
000000  4601              MOV      r1,r0
;;;296    { 
;;;297      LL_USART_DisableDirectionRx( HW.If ); 
000002  684a              LDR      r2,[r1,#4]
000004  6810              LDR      r0,[r2,#0]
000006  6802              LDR      r2,[r0,#0]
000008  f0220204          BIC      r2,r2,#4
00000c  6002              STR      r2,[r0,#0]
00000e  bf00              NOP      
;;;298    }
000010  4770              BX       lr
                          ENDP


                          AREA ||i._ZN6TUsart10read_burstEPhh||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart10read_burstEPhh PROC ; TUsart::read_burst(unsigned char*, unsigned char)
;;;241    
;;;242    void TUsart::read_burst( uint8_t *DataBurst, uint8_t Size )        //многобайтное считывание
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;243    {                                                                  
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;244      for ( uint8_t Ctr = 0; Ctr < Size ; ++Ctr )                      
00000a  2500              MOVS     r5,#0
00000c  e010              B        |L6.48|
                  |L6.14|
;;;245      {                                                                
;;;246        clr_error_flags();                                             
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZN6TUsart15clr_error_flagsEv ; TUsart::clr_error_flags()
;;;247        do {} while ( LL_USART_IsActiveFlag_RXNE( HW.If ) == false );  //блокировка пока байт не принят
000014  bf00              NOP      
                  |L6.22|
000016  6861              LDR      r1,[r4,#4]
000018  6808              LDR      r0,[r1,#0]
00001a  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17526LL_USART_IsActiveFlag_RXNEEP13USART_TypeDef ; [local to usart_driver__cpp]::LL_USART_IsActiveFlag_RXNE(USART_TypeDef*)
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L6.22|
;;;248                                                                       
;;;249        DataBurst[ Ctr ] = LL_USART_ReceiveData8( HW.If );             //флаг RXNE сбрасывается при считывании байта
000022  6861              LDR      r1,[r4,#4]
000024  6808              LDR      r0,[r1,#0]
000026  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17521LL_USART_ReceiveData8EP13USART_TypeDef ; [local to usart_driver__cpp]::LL_USART_ReceiveData8(USART_TypeDef*)
00002a  5570              STRB     r0,[r6,r5]
00002c  1c68              ADDS     r0,r5,#1              ;244
00002e  b2c5              UXTB     r5,r0                 ;244
                  |L6.48|
000030  42bd              CMP      r5,r7                 ;244
000032  dbec              BLT      |L6.14|
;;;250      }
;;;251    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;252    
                          ENDP


                          AREA ||i._ZN6TUsart10set_485_hdEjj||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart10set_485_hdEjj PROC ; TUsart::set_485_hd(unsigned, unsigned)
;;;165    
;;;166    void TUsart::set_485_hd( uint32_t Fck, uint32_t OvS )
000000  b570              PUSH     {r4-r6,lr}
;;;167    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;168      LL_USART_EnableDEMode( HW.If );                                   //включается внутренняя подтяжка на Rx
000008  6861              LDR      r1,[r4,#4]
00000a  6808              LDR      r0,[r1,#0]
00000c  6881              LDR      r1,[r0,#8]
00000e  f4414180          ORR      r1,r1,#0x4000
000012  6081              STR      r1,[r0,#8]
000014  bf00              NOP      
;;;169      LL_USART_SetBaudRate( HW.If, Fck, OvS, (uint32_t)Sets.BaudRate ); //значение из данных объекта
000016  e9d41301          LDRD     r1,r3,[r4,#4]
00001a  4632              MOV      r2,r6
00001c  6808              LDR      r0,[r1,#0]
00001e  4629              MOV      r1,r5
000020  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17520LL_USART_SetBaudRateEP13USART_TypeDefjjj ; [local to usart_driver__cpp]::LL_USART_SetBaudRate(USART_TypeDef*, unsigned, unsigned, unsigned)
;;;170      LL_USART_SetDEDeassertionTime( HW.If, MAX_DEDT );
000024  6862              LDR      r2,[r4,#4]
000026  211f              MOVS     r1,#0x1f
000028  6810              LDR      r0,[r2,#0]
00002a  6802              LDR      r2,[r0,#0]
00002c  f42212f8          BIC      r2,r2,#0x1f0000
000030  ea424201          ORR      r2,r2,r1,LSL #16
000034  6002              STR      r2,[r0,#0]
000036  bf00              NOP      
;;;171      LL_USART_SetDEAssertionTime( HW.If, MAX_DEAT );
000038  6862              LDR      r2,[r4,#4]
00003a  6810              LDR      r0,[r2,#0]
00003c  6802              LDR      r2,[r0,#0]
00003e  f0227278          BIC      r2,r2,#0x3e00000
000042  ea425241          ORR      r2,r2,r1,LSL #21
000046  6002              STR      r2,[r0,#0]
000048  bf00              NOP      
;;;172      LL_USART_SetDESignalPolarity( HW.If, LL_USART_DE_POLARITY_HIGH );
00004a  6862              LDR      r2,[r4,#4]
00004c  2100              MOVS     r1,#0
00004e  6810              LDR      r0,[r2,#0]
000050  6882              LDR      r2,[r0,#8]
000052  f4224200          BIC      r2,r2,#0x8000
000056  430a              ORRS     r2,r2,r1
000058  6082              STR      r2,[r0,#8]
00005a  bf00              NOP      
;;;173    }
00005c  bd70              POP      {r4-r6,pc}
;;;174      
                          ENDP


                          AREA ||i._ZN6TUsart11write_burstEPKht||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart11write_burstEPKht PROC ; TUsart::write_burst(const unsigned char*, unsigned short)
;;;252    
;;;253    void TUsart::write_burst( const uint8_t *DataBurst, uint16_t Size ) //многобайтная запись
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;255      clr_error_flags();
000008  4618              MOV      r0,r3
00000a  f7fffffe          BL       _ZN6TUsart15clr_error_flagsEv ; TUsart::clr_error_flags()
;;;256      LL_USART_EnableDirectionTx( HW.If );
00000e  6859              LDR      r1,[r3,#4]
000010  6808              LDR      r0,[r1,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f0410108          ORR      r1,r1,#8
000018  6001              STR      r1,[r0,#0]
00001a  bf00              NOP      
;;;257      
;;;258      for ( uint16_t Ctr = 0; Ctr < Size ; ++Ctr )
00001c  2100              MOVS     r1,#0
00001e  4608              MOV      r0,r1
000020  e00f              B        |L8.66|
                  |L8.34|
;;;259      { 
;;;260        do 
000022  bf00              NOP      
                  |L8.36|
;;;261        {
;;;262        
;;;263        } while ( !LL_USART_IsActiveFlag_TXE( HW.If ) );
000024  685a              LDR      r2,[r3,#4]
000026  6811              LDR      r1,[r2,#0]
000028  69ca              LDR      r2,[r1,#0x1c]
00002a  f3c212c0          UBFX     r2,r2,#7,#1
00002e  2a00              CMP      r2,#0
000030  d0f8              BEQ      |L8.36|
;;;264        
;;;265        LL_USART_TransmitData8( HW.If, DataBurst[ Ctr ] );
000032  685e              LDR      r6,[r3,#4]
000034  5c22              LDRB     r2,[r4,r0]
000036  6831              LDR      r1,[r6,#0]
000038  850a              STRH     r2,[r1,#0x28]
00003a  bf00              NOP      
00003c  1c41              ADDS     r1,r0,#1              ;258
00003e  b289              UXTH     r1,r1                 ;258
000040  4608              MOV      r0,r1                 ;258
                  |L8.66|
000042  42a8              CMP      r0,r5                 ;258
000044  dbed              BLT      |L8.34|
;;;266      }
;;;267      
;;;268      do 
000046  bf00              NOP      
                  |L8.72|
;;;269      {
;;;270      
;;;271      }
;;;272      while ( !LL_USART_IsActiveFlag_TC( HW.If ) );
000048  6859              LDR      r1,[r3,#4]
00004a  6808              LDR      r0,[r1,#0]
00004c  69c1              LDR      r1,[r0,#0x1c]
00004e  f3c11180          UBFX     r1,r1,#6,#1
000052  2900              CMP      r1,#0
000054  d0f8              BEQ      |L8.72|
;;;273      
;;;274      LL_USART_DisableDirectionTx( HW.If );
000056  6859              LDR      r1,[r3,#4]
000058  6808              LDR      r0,[r1,#0]
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210108          BIC      r1,r1,#8
000060  6001              STR      r1,[r0,#0]
000062  bf00              NOP      
;;;275      clr_error_flags();
000064  4618              MOV      r0,r3
000066  f7fffffe          BL       _ZN6TUsart15clr_error_flagsEv ; TUsart::clr_error_flags()
;;;276    }
00006a  bd70              POP      {r4-r6,pc}
;;;277    
                          ENDP


                          AREA ||i._ZN6TUsart13en_eob_detectEh||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart13en_eob_detectEh PROC ; TUsart::en_eob_detect(unsigned char)
;;;179    
;;;180    void TUsart::en_eob_detect( uint8_t Timeout )
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;182      //----- Настройка определения конца блока по программируемому таймауту ------------------------------------
;;;183      LL_USART_EnableRxTimeout( HW.If ); //включить функцию определения конца блока по программируемому таймауту
000006  6861              LDR      r1,[r4,#4]
000008  6808              LDR      r0,[r1,#0]
00000a  6841              LDR      r1,[r0,#4]
00000c  f4410100          ORR      r1,r1,#0x800000
000010  6041              STR      r1,[r0,#4]
000012  bf00              NOP      
;;;184      
;;;185    	LL_USART_SetRxTimeout( HW.If, Timeout ); //установка величины таймаута в битах принимаемого символа
000014  6861              LDR      r1,[r4,#4]
000016  6808              LDR      r0,[r1,#0]
000018  6941              LDR      r1,[r0,#0x14]
00001a  f001417f          AND      r1,r1,#0xff000000
00001e  4329              ORRS     r1,r1,r5
000020  6141              STR      r1,[r0,#0x14]
000022  bf00              NOP      
;;;186    	
;;;187    	LL_USART_ClearFlag_RTO( HW.If );
000024  6861              LDR      r1,[r4,#4]
000026  6808              LDR      r0,[r1,#0]
000028  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17522LL_USART_ClearFlag_RTOEP13USART_TypeDef ; [local to usart_driver__cpp]::LL_USART_ClearFlag_RTO(USART_TypeDef*)
;;;188    	LL_USART_EnableIT_RTO( HW.If );   //разрешение прерывания по RTO
00002c  6861              LDR      r1,[r4,#4]
00002e  6808              LDR      r0,[r1,#0]
000030  6801              LDR      r1,[r0,#0]
000032  f0416180          ORR      r1,r1,#0x4000000
000036  6001              STR      r1,[r0,#0]
000038  bf00              NOP      
;;;189    //  LL_USART_EnableIT_RXNE( HW.If );
;;;190    	LL_USART_EnableIT_PE( HW.If );    //разрешение прерывания по PE
00003a  6861              LDR      r1,[r4,#4]
00003c  6808              LDR      r0,[r1,#0]
00003e  6801              LDR      r1,[r0,#0]
000040  f4417180          ORR      r1,r1,#0x100
000044  6001              STR      r1,[r0,#0]
000046  bf00              NOP      
;;;191    	LL_USART_EnableIT_ERROR( HW.If ); //разрешение прерываний: framing error, overrun error or noise flag
000048  6861              LDR      r1,[r4,#4]
00004a  6808              LDR      r0,[r1,#0]
00004c  6881              LDR      r1,[r0,#8]
00004e  f0410101          ORR      r1,r1,#1
000052  6081              STR      r1,[r0,#8]
000054  bf00              NOP      
;;;192      //---------------------------------------------------------------------------------------------------------
;;;193    }
000056  bd70              POP      {r4-r6,pc}
;;;194    
                          ENDP


                          AREA ||i._ZN6TUsart13set_interruptEv||, CODE, READONLY, ALIGN=2

                  _ZN6TUsart13set_interruptEv PROC ; TUsart::set_interrupt()
;;;203    
;;;204    void TUsart::set_interrupt()
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;205    {
000004  4604              MOV      r4,r0
;;;206      //Настройка NVIC
;;;207      NVIC_SetPriority( HW.IRQ, NVIC_EncodePriority( NVIC_GetPriorityGrouping(), 5, 0 ) ); //обработчик вызывает API функцию RTOS => приоритет д.б. логически ниже или равен, \
000006  6860              LDR      r0,[r4,#4]
000008  f9901004          LDRSB    r1,[r0,#4]
00000c  4b28              LDR      r3,|L10.176|
00000e  681b              LDR      r3,[r3,#0]
000010  f3c32002          UBFX     r0,r3,#8,#3
000014  2505              MOVS     r5,#5
000016  2600              MOVS     r6,#0
000018  4603              MOV      r3,r0
00001a  f1c30807          RSB      r8,r3,#7
00001e  f1b80f04          CMP      r8,#4
000022  d902              BLS      |L10.42|
000024  f04f0804          MOV      r8,#4
000028  e001              B        |L10.46|
                  |L10.42|
00002a  f1c30807          RSB      r8,r3,#7
                  |L10.46|
00002e  46c4              MOV      r12,r8
000030  f1030804          ADD      r8,r3,#4
000034  f1b80f07          CMP      r8,#7
000038  d202              BCS      |L10.64|
00003a  f04f0800          MOV      r8,#0
00003e  e001              B        |L10.68|
                  |L10.64|
000040  f1a30803          SUB      r8,r3,#3
                  |L10.68|
000044  4647              MOV      r7,r8
000046  f04f0801          MOV      r8,#1
00004a  fa08f80c          LSL      r8,r8,r12
00004e  f1a80801          SUB      r8,r8,#1
000052  ea080805          AND      r8,r8,r5
000056  fa08f807          LSL      r8,r8,r7
00005a  f04f0901          MOV      r9,#1
00005e  fa09f907          LSL      r9,r9,r7
000062  f1a90901          SUB      r9,r9,#1
000066  ea090906          AND      r9,r9,r6
00006a  ea480209          ORR      r2,r8,r9
00006e  bf00              NOP      
000070  2900              CMP      r1,#0
000072  da08              BGE      |L10.134|
000074  0710              LSLS     r0,r2,#28
000076  0e05              LSRS     r5,r0,#24
000078  480d              LDR      r0,|L10.176|
00007a  300c              ADDS     r0,r0,#0xc
00007c  f001030f          AND      r3,r1,#0xf
000080  1f1b              SUBS     r3,r3,#4
000082  54c5              STRB     r5,[r0,r3]
000084  e003              B        |L10.142|
                  |L10.134|
000086  0710              LSLS     r0,r2,#28
000088  0e03              LSRS     r3,r0,#24
00008a  480a              LDR      r0,|L10.180|
00008c  5443              STRB     r3,[r0,r1]
                  |L10.142|
00008e  bf00              NOP      
;;;208                                                                                             но численно больше или равен, установленнму в макросе configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
;;;209      NVIC_EnableIRQ( HW.IRQ );
000090  6861              LDR      r1,[r4,#4]
000092  f9910004          LDRSB    r0,[r1,#4]
000096  f000021f          AND      r2,r0,#0x1f
00009a  2101              MOVS     r1,#1
00009c  4091              LSLS     r1,r1,r2
00009e  0942              LSRS     r2,r0,#5
0000a0  0092              LSLS     r2,r2,#2
0000a2  f10222e0          ADD      r2,r2,#0xe000e000
0000a6  f8c21100          STR      r1,[r2,#0x100]
0000aa  bf00              NOP      
;;;210    }
0000ac  e8bd83f0          POP      {r4-r9,pc}
;;;211    
                          ENDP

                  |L10.176|
                          DCD      0xe000ed0c
                  |L10.180|
                          DCD      0xe000e400

                          AREA ||i._ZN6TUsart14dis_eob_detectEv||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart14dis_eob_detectEv PROC ; TUsart::dis_eob_detect()
;;;194    
;;;195    void TUsart::dis_eob_detect()
000000  b510              PUSH     {r4,lr}
;;;196    {
000002  4604              MOV      r4,r0
;;;197      LL_USART_DisableRxTimeout( HW.If ); //отключить функцию определения конца блока по программируемому таймауту
000004  6861              LDR      r1,[r4,#4]
000006  6808              LDR      r0,[r1,#0]
000008  6841              LDR      r1,[r0,#4]
00000a  f4210100          BIC      r1,r1,#0x800000
00000e  6041              STR      r1,[r0,#4]
000010  bf00              NOP      
;;;198    	LL_USART_ClearFlag_RTO( HW.If );
000012  6861              LDR      r1,[r4,#4]
000014  6808              LDR      r0,[r1,#0]
000016  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17522LL_USART_ClearFlag_RTOEP13USART_TypeDef ; [local to usart_driver__cpp]::LL_USART_ClearFlag_RTO(USART_TypeDef*)
;;;199    	LL_USART_DisableIT_RTO( HW.If );    //запрет прерывания по RTO
00001a  6861              LDR      r1,[r4,#4]
00001c  6808              LDR      r0,[r1,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0216180          BIC      r1,r1,#0x4000000
000024  6001              STR      r1,[r0,#0]
000026  bf00              NOP      
;;;200    	LL_USART_DisableIT_PE( HW.If );     //запрет прерывания по PE
000028  6861              LDR      r1,[r4,#4]
00002a  6808              LDR      r0,[r1,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  f4217180          BIC      r1,r1,#0x100
000032  6001              STR      r1,[r0,#0]
000034  bf00              NOP      
;;;201    	LL_USART_DisableIT_ERROR( HW.If );  //запрет прерывания: framing error, overrun error or noise flag
000036  6861              LDR      r1,[r4,#4]
000038  6808              LDR      r0,[r1,#0]
00003a  6881              LDR      r1,[r0,#8]
00003c  f0210101          BIC      r1,r1,#1
000040  6081              STR      r1,[r0,#8]
000042  bf00              NOP      
;;;202    }
000044  bd10              POP      {r4,pc}
;;;203    
                          ENDP


                          AREA ||i._ZN6TUsart14pin_clk_configEv||, CODE, READONLY, ALIGN=2

                  _ZN6TUsart14pin_clk_configEv PROC ; TUsart::pin_clk_config()
;;;29     
;;;30     void TUsart::pin_clk_config()
000000  b510              PUSH     {r4,lr}
;;;31     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;32       HW.TX.en_clk( HW.TX.ClkPortMask ); //включение тактирования GPIO для порта с Tx
000006  6862              LDR      r2,[r4,#4]
000008  e9d20108          LDRD     r0,r1,[r2,#0x20]
00000c  4788              BLX      r1
;;;33       HW.RX.en_clk( HW.RX.ClkPortMask ); //включение тактирования GPIO для порта с Rx
00000e  6862              LDR      r2,[r4,#4]
000010  e9d2010d          LDRD     r0,r1,[r2,#0x34]
000014  4788              BLX      r1
;;;34       HW.DE.en_clk( HW.DE.ClkPortMask ); //включение тактирования GPIO для порта с DE
000016  6862              LDR      r2,[r4,#4]
000018  e9d20112          LDRD     r0,r1,[r2,#0x48]
00001c  4788              BLX      r1
;;;35     
;;;36       HW.Clk.en_periph( HW.Clk.PeriphMask ); //включение тактирования USART'a
00001e  6862              LDR      r2,[r4,#4]
000020  e9d21002          LDRD     r1,r0,[r2,#8]
000024  4788              BLX      r1
;;;37       
;;;38       LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;39       
;;;40       do
000026  bf00              NOP      
                  |L12.40|
;;;41       {
;;;42         GPIO_InitStruct.Pin        = HW.TX.Nbr;
000028  6860              LDR      r0,[r4,#4]
00002a  69c0              LDR      r0,[r0,#0x1c]
00002c  9000              STR      r0,[sp,#0]
;;;43         GPIO_InitStruct.Mode       = LL_GPIO_MODE_ALTERNATE;
00002e  2002              MOVS     r0,#2
000030  9001              STR      r0,[sp,#4]
;;;44         GPIO_InitStruct.Speed      = LL_GPIO_SPEED_FREQ_HIGH;
000032  9002              STR      r0,[sp,#8]
;;;45         GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
000034  2000              MOVS     r0,#0
000036  9003              STR      r0,[sp,#0xc]
;;;46         GPIO_InitStruct.Pull       = LL_GPIO_PULL_NO;
000038  9004              STR      r0,[sp,#0x10]
;;;47         GPIO_InitStruct.Alternate  = LL_GPIO_AF_7;
00003a  2007              MOVS     r0,#7
00003c  9005              STR      r0,[sp,#0x14]
;;;48       } while ( SUCCESS != LL_GPIO_Init( HW.TX.Gpio, &GPIO_InitStruct ) );
00003e  6861              LDR      r1,[r4,#4]
000040  6988              LDR      r0,[r1,#0x18]
000042  4669              MOV      r1,sp
000044  f7fffffe          BL       LL_GPIO_Init
000048  2800              CMP      r0,#0
00004a  d1ed              BNE      |L12.40|
;;;49       do
00004c  bf00              NOP      
                  |L12.78|
;;;50       {
;;;51         GPIO_InitStruct.Pin        = HW.RX.Nbr;
00004e  6860              LDR      r0,[r4,#4]
000050  6b00              LDR      r0,[r0,#0x30]
000052  9000              STR      r0,[sp,#0]
;;;52       } while ( SUCCESS != LL_GPIO_Init( HW.RX.Gpio, &GPIO_InitStruct ) );
000054  6861              LDR      r1,[r4,#4]
000056  6ac8              LDR      r0,[r1,#0x2c]
000058  4669              MOV      r1,sp
00005a  f7fffffe          BL       LL_GPIO_Init
00005e  2800              CMP      r0,#0
000060  d1f5              BNE      |L12.78|
;;;53       do
000062  bf00              NOP      
                  |L12.100|
;;;54       {
;;;55         GPIO_InitStruct.Pin        = HW.DE.Nbr;
000064  6860              LDR      r0,[r4,#4]
000066  6c40              LDR      r0,[r0,#0x44]
000068  9000              STR      r0,[sp,#0]
;;;56       } while ( SUCCESS != LL_GPIO_Init( HW.DE.Gpio, &GPIO_InitStruct ) );
00006a  6861              LDR      r1,[r4,#4]
00006c  6c08              LDR      r0,[r1,#0x40]
00006e  4669              MOV      r1,sp
000070  f7fffffe          BL       LL_GPIO_Init
000074  2800              CMP      r0,#0
000076  d1f5              BNE      |L12.100|
;;;57     
;;;58       LL_RCC_SetUSARTClockSource( HW.Clk.SrcMask ); //The clock source must be chosen before enabling the USART \
000078  6861              LDR      r1,[r4,#4]
00007a  6908              LDR      r0,[r1,#0x10]
00007c  4906              LDR      r1,|L12.152|
00007e  6809              LDR      r1,[r1,#0]
000080  ea214110          BIC      r1,r1,r0,LSR #16
000084  b282              UXTH     r2,r0
000086  4311              ORRS     r1,r1,r2
000088  4a03              LDR      r2,|L12.152|
00008a  3a88              SUBS     r2,r2,#0x88
00008c  f8c21088          STR      r1,[r2,#0x88]
000090  bf00              NOP      
;;;59                                                       (by setting the UE bit)
;;;60     }
000092  b006              ADD      sp,sp,#0x18
000094  bd10              POP      {r4,pc}
;;;61     
                          ENDP

000096  0000              DCW      0x0000
                  |L12.152|
                          DCD      0x40021088

                          AREA ||i._ZN6TUsart15clr_error_flagsEv||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart15clr_error_flagsEv PROC ; TUsart::clr_error_flags()
;;;152    
;;;153    void TUsart::clr_error_flags()
000000  6842              LDR      r2,[r0,#4]
;;;154    {
;;;155      LL_USART_ClearFlag_PE( HW.If );
000002  6811              LDR      r1,[r2,#0]
000004  2201              MOVS     r2,#1
000006  620a              STR      r2,[r1,#0x20]
000008  bf00              NOP      
;;;156      LL_USART_ClearFlag_FE( HW.If );
00000a  6842              LDR      r2,[r0,#4]
00000c  6811              LDR      r1,[r2,#0]
00000e  2202              MOVS     r2,#2
000010  620a              STR      r2,[r1,#0x20]
000012  bf00              NOP      
;;;157      LL_USART_ClearFlag_NE( HW.If );
000014  6842              LDR      r2,[r0,#4]
000016  6811              LDR      r1,[r2,#0]
000018  2204              MOVS     r2,#4
00001a  620a              STR      r2,[r1,#0x20]
00001c  bf00              NOP      
;;;158      LL_USART_ClearFlag_ORE( HW.If );
00001e  6842              LDR      r2,[r0,#4]
000020  6811              LDR      r1,[r2,#0]
000022  2208              MOVS     r2,#8
000024  620a              STR      r2,[r1,#0x20]
000026  bf00              NOP      
;;;159    }
000028  4770              BX       lr
;;;160    
                          ENDP


                          AREA ||i._ZN6TUsart6dis_ifEv||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart6dis_ifEv PROC ; TUsart::dis_if()
;;;160    
;;;161    void TUsart::dis_if()
000000  4601              MOV      r1,r0
;;;162    {
;;;163      LL_USART_Disable( HW.If );
000002  684a              LDR      r2,[r1,#4]
000004  6810              LDR      r0,[r2,#0]
000006  6802              LDR      r2,[r0,#0]
000008  f0220201          BIC      r2,r2,#1
00000c  6002              STR      r2,[r0,#0]
00000e  bf00              NOP      
;;;164    }
000010  4770              BX       lr
;;;165    
                          ENDP


                          AREA ||i._ZN6TUsart7hw_initEh||, CODE, READONLY, ALIGN=2

                  _ZN6TUsart7hw_initEh PROC ; TUsart::hw_init(unsigned char)
;;;61     
;;;62     void TUsart::hw_init( uint8_t TimeoutBitsQty )
000000  b5f0              PUSH     {r4-r7,lr}
;;;63     {  
000002  b099              SUB      sp,sp,#0x64
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;64       struct TParityCtrl
;;;65     	{
;;;66     	  uint32_t ParityMask;
;;;67     		uint32_t StopsMask;
;;;68     		uint32_t DataWidth;
;;;69     	};
;;;70     
;;;71     	TParityCtrl ParityCtrl[TParity::_MAX_PARITY][TStops::_MAX_STOPS] =
000008  2248              MOVS     r2,#0x48
00000a  4945              LDR      r1,|L15.288|
00000c  a807              ADD      r0,sp,#0x1c
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;72     	{
;;;73     	  {
;;;74     		  {
;;;75     			  LL_USART_PARITY_NONE, LL_USART_STOPBITS_1, LL_USART_DATAWIDTH_8B
;;;76     			},
;;;77     		  {
;;;78     			  LL_USART_PARITY_NONE, LL_USART_STOPBITS_2, LL_USART_DATAWIDTH_8B
;;;79     			}
;;;80     		},
;;;81     		{
;;;82     		  {
;;;83     			  LL_USART_PARITY_EVEN, LL_USART_STOPBITS_1, LL_USART_DATAWIDTH_9B
;;;84     			},
;;;85     		  {
;;;86     			  LL_USART_PARITY_EVEN, LL_USART_STOPBITS_2, LL_USART_DATAWIDTH_8B
;;;87     			}		
;;;88     		},
;;;89     		{
;;;90     		  {
;;;91     			  LL_USART_PARITY_ODD, LL_USART_STOPBITS_1, LL_USART_DATAWIDTH_9B
;;;92     			},
;;;93     		  {
;;;94     			  LL_USART_PARITY_ODD, LL_USART_STOPBITS_2, LL_USART_DATAWIDTH_8B
;;;95     			}		
;;;96     		}
;;;97     	};
;;;98       
;;;99       LL_USART_InitTypeDef USART_InitStruct;
;;;100    
;;;101      USART_InitStruct.OverSampling        = LL_USART_OVERSAMPLING_16;
000012  2000              MOVS     r0,#0
000014  9006              STR      r0,[sp,#0x18]
;;;102    //  USART_InitStruct.DataWidth           = LL_USART_DATAWIDTH_8B;
;;;103      USART_InitStruct.DataWidth           = ParityCtrl[ Sets.Parity ][ Sets.Stops ].DataWidth;
000016  68e0              LDR      r0,[r4,#0xc]
000018  eb000040          ADD      r0,r0,r0,LSL #1
00001c  a907              ADD      r1,sp,#0x1c
00001e  eb0101c0          ADD      r1,r1,r0,LSL #3
000022  6920              LDR      r0,[r4,#0x10]
000024  eb000040          ADD      r0,r0,r0,LSL #1
000028  eb010080          ADD      r0,r1,r0,LSL #2
00002c  6880              LDR      r0,[r0,#8]
00002e  9001              STR      r0,[sp,#4]
;;;104      USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
000030  2000              MOVS     r0,#0
000032  9005              STR      r0,[sp,#0x14]
;;;105    //  USART_InitStruct.Parity              = ParityMask[Sets.Parity];                          //значение из данных объекта
;;;106      USART_InitStruct.Parity              = ParityCtrl[ Sets.Parity ][ Sets.Stops ].ParityMask; //значение из данных объекта
000034  68e0              LDR      r0,[r4,#0xc]
000036  eb000040          ADD      r0,r0,r0,LSL #1
00003a  a907              ADD      r1,sp,#0x1c
00003c  eb0101c0          ADD      r1,r1,r0,LSL #3
000040  6920              LDR      r0,[r4,#0x10]
000042  eb000040          ADD      r0,r0,r0,LSL #1
000046  f8510020          LDR      r0,[r1,r0,LSL #2]
00004a  9003              STR      r0,[sp,#0xc]
;;;107    //  USART_InitStruct.StopBits            = StopsMask[Sets.Stops];                            //значение из данных объекта
;;;108      USART_InitStruct.StopBits            = ParityCtrl[ Sets.Parity ][ Sets.Stops ].StopsMask;  //значение из данных объекта
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  eb000040          ADD      r0,r0,r0,LSL #1
000052  a907              ADD      r1,sp,#0x1c
000054  eb0101c0          ADD      r1,r1,r0,LSL #3
000058  6920              LDR      r0,[r4,#0x10]
00005a  eb000040          ADD      r0,r0,r0,LSL #1
00005e  eb010080          ADD      r0,r1,r0,LSL #2
000062  6840              LDR      r0,[r0,#4]
000064  9002              STR      r0,[sp,#8]
;;;109    //  USART_InitStruct.TransferDirection   = LL_USART_DIRECTION_TX_RX;                         //Transmitter and Receiver are enabled
;;;110      USART_InitStruct.TransferDirection   = LL_USART_DIRECTION_NONE;                            //Transmitter and Receiver are disabled
000066  2000              MOVS     r0,#0
000068  9004              STR      r0,[sp,#0x10]
;;;111    
;;;112      LL_USART_Init( HW.If, &USART_InitStruct );
00006a  6861              LDR      r1,[r4,#4]
00006c  6808              LDR      r0,[r1,#0]
00006e  4669              MOV      r1,sp
000070  f7fffffe          BL       LL_USART_Init
;;;113    
;;;114      uint32_t Fck = LL_RCC_GetUSARTClockFreq( HW.Clk.FreqMask );
000074  6861              LDR      r1,[r4,#4]
000076  6948              LDR      r0,[r1,#0x14]
000078  f7fffffe          BL       LL_RCC_GetUSARTClockFreq
00007c  4605              MOV      r5,r0
;;;115      uint32_t OvS = LL_USART_GetOverSampling( HW.If );
00007e  6861              LDR      r1,[r4,#4]
000080  6808              LDR      r0,[r1,#0]
000082  6801              LDR      r1,[r0,#0]
000084  f4014100          AND      r1,r1,#0x8000
000088  460e              MOV      r6,r1
;;;116        
;;;117      LL_USART_SetTransferBitOrder( HW.If, LL_USART_BITORDER_LSBFIRST ); 
00008a  6862              LDR      r2,[r4,#4]
00008c  2100              MOVS     r1,#0
00008e  6810              LDR      r0,[r2,#0]
000090  6842              LDR      r2,[r0,#4]
000092  f4222200          BIC      r2,r2,#0x80000
000096  430a              ORRS     r2,r2,r1
000098  6042              STR      r2,[r0,#4]
00009a  bf00              NOP      
;;;118      LL_USART_ClearFlag_TC( HW.If );
00009c  6861              LDR      r1,[r4,#4]
00009e  6808              LDR      r0,[r1,#0]
0000a0  2140              MOVS     r1,#0x40
0000a2  6201              STR      r1,[r0,#0x20]
0000a4  bf00              NOP      
;;;119      
;;;120      if ( IS_UART_DRIVER_ENABLE_INSTANCE( HW.If ) )
0000a6  6860              LDR      r0,[r4,#4]
0000a8  6800              LDR      r0,[r0,#0]
0000aa  491e              LDR      r1,|L15.292|
0000ac  4288              CMP      r0,r1
0000ae  d00e              BEQ      |L15.206|
0000b0  6860              LDR      r0,[r4,#4]
0000b2  6800              LDR      r0,[r0,#0]
0000b4  491c              LDR      r1,|L15.296|
0000b6  4288              CMP      r0,r1
0000b8  d009              BEQ      |L15.206|
0000ba  6860              LDR      r0,[r4,#4]
0000bc  6800              LDR      r0,[r0,#0]
0000be  491b              LDR      r1,|L15.300|
0000c0  4288              CMP      r0,r1
0000c2  d004              BEQ      |L15.206|
0000c4  6860              LDR      r0,[r4,#4]
0000c6  6800              LDR      r0,[r0,#0]
0000c8  4919              LDR      r1,|L15.304|
0000ca  4288              CMP      r0,r1
0000cc  d11c              BNE      |L15.264|
                  |L15.206|
;;;121      {
;;;122        switch ( Mode )
0000ce  7d20              LDRB     r0,[r4,#0x14]
0000d0  b190              CBZ      r0,|L15.248|
0000d2  2806              CMP      r0,#6
0000d4  d116              BNE      |L15.260|
;;;123        {
;;;124          case TMode::_RS485_DE:
;;;125               switch ( get_config() )
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       _ZN12T_RS_485_phy10get_configEv ; T_RS_485_phy::get_config()
0000dc  b110              CBZ      r0,|L15.228|
0000de  2801              CMP      r0,#1
0000e0  d107              BNE      |L15.242|
0000e2  e005              B        |L15.240|
                  |L15.228|
;;;126               {
;;;127                 case ( TConfigurable::_HALF_DUPLEX ):
;;;128      	              set_485_hd(Fck, OvS);
0000e4  4632              MOV      r2,r6
0000e6  4629              MOV      r1,r5
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       _ZN6TUsart10set_485_hdEjj ; TUsart::set_485_hd(unsigned, unsigned)
;;;129        	            break;
0000ee  e001              B        |L15.244|
                  |L15.240|
;;;130                 case ( TConfigurable::_FULL_DUPLEX ):
;;;131        	      	    break;
0000f0  e000              B        |L15.244|
                  |L15.242|
;;;132                 default:
;;;133                      break;
0000f2  bf00              NOP      
                  |L15.244|
0000f4  bf00              NOP                            ;129
;;;134               }
;;;135      	       break;
0000f6  e006              B        |L15.262|
                  |L15.248|
;;;136      	  case TMode::_STANDARD:
;;;137               set_232(Fck, OvS);
0000f8  4632              MOV      r2,r6
0000fa  4629              MOV      r1,r5
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       _ZN6TUsart7set_232Ejj ; TUsart::set_232(unsigned, unsigned)
;;;138      	       break;
000102  e000              B        |L15.262|
                  |L15.260|
;;;139          default:  //реализация остальных режимов - по необходимости
;;;140      	       break;
000104  bf00              NOP      
                  |L15.262|
000106  bf00              NOP                            ;135
                  |L15.264|
;;;141        }
;;;142      }
;;;143      else
;;;144      {
;;;145        //какие-то действия,  если данный экземпляр USART'a не поддерживает Driver Enable
;;;146    	  //реализация по мере необходимости
;;;147      }
;;;148      
;;;149      LL_USART_Enable( HW.If ); //Idle кадр отправляется после установки бита TE
000108  6861              LDR      r1,[r4,#4]
00010a  6808              LDR      r0,[r1,#0]
00010c  6801              LDR      r1,[r0,#0]
00010e  f0410101          ORR      r1,r1,#1
000112  6001              STR      r1,[r0,#0]
000114  bf00              NOP      
;;;150      clr_error_flags();
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       _ZN6TUsart15clr_error_flagsEv ; TUsart::clr_error_flags()
;;;151    }
00011c  b019              ADD      sp,sp,#0x64
00011e  bdf0              POP      {r4-r7,pc}
;;;152    
                          ENDP

                  |L15.288|
                          DCD      ||.constdata||+0xc
                  |L15.292|
                          DCD      0x40013800
                  |L15.296|
                          DCD      0x40004400
                  |L15.300|
                          DCD      0x40004800
                  |L15.304|
                          DCD      0x40008000

                          AREA ||i._ZN6TUsart7set_232Ejj||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart7set_232Ejj PROC ; TUsart::set_232(unsigned, unsigned)
;;;174      
;;;175    void TUsart::set_232( uint32_t Fck, uint32_t OvS )
000000  b570              PUSH     {r4-r6,lr}
;;;176    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;177      LL_USART_SetBaudRate( HW.If, Fck, OvS, (uint32_t)Sets.BaudRate );
000008  e9d41301          LDRD     r1,r3,[r4,#4]
00000c  4632              MOV      r2,r6
00000e  6808              LDR      r0,[r1,#0]
000010  4629              MOV      r1,r5
000012  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17520LL_USART_SetBaudRateEP13USART_TypeDefjjj ; [local to usart_driver__cpp]::LL_USART_SetBaudRate(USART_TypeDef*, unsigned, unsigned, unsigned)
;;;178    }
000016  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP


                          AREA ||i._ZN6TUsart8chk_setsERKNS_5TSetsE||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart8chk_setsERKNS_5TSetsE PROC ; TUsart::chk_sets(const TUsart::TSets&)
;;;230    
;;;231    bool TUsart::chk_sets( const TSets &_Sets )
000000  4602              MOV      r2,r0
;;;232    {
;;;233      return (
000002  6890              LDR      r0,[r2,#8]
000004  680b              LDR      r3,[r1,#0]
000006  4298              CMP      r0,r3
000008  d108              BNE      |L17.28|
;;;234              Sets.BaudRate == _Sets.BaudRate
;;;235              &&
;;;236              Sets.Parity == _Sets.Parity
00000a  68d0              LDR      r0,[r2,#0xc]
00000c  684b              LDR      r3,[r1,#4]
00000e  4298              CMP      r0,r3
000010  d104              BNE      |L17.28|
;;;237              &&
;;;238              Sets.Stops == Sets.Stops
000012  6910              LDR      r0,[r2,#0x10]
000014  4280              CMP      r0,r0
000016  d101              BNE      |L17.28|
000018  2001              MOVS     r0,#1                 ;233
                  |L17.26|
;;;239             );
;;;240    }
00001a  4770              BX       lr
                  |L17.28|
00001c  2000              MOVS     r0,#0                 ;233
00001e  e7fc              B        |L17.26|
;;;241    
                          ENDP


                          AREA ||i._ZN6TUsart8set_setsERKNS_5TSetsE||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart8set_setsERKNS_5TSetsE PROC ; TUsart::set_sets(const TUsart::TSets&)
;;;216    
;;;217    void TUsart::set_sets( const TSets &_Sets )
000000  b570              PUSH     {r4-r6,lr}
;;;218    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;219      if ( chk_sets( _Sets ) == true ) //если новые настройки совпадают с уже установленными в usart
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       _ZN6TUsart8chk_setsERKNS_5TSetsE ; TUsart::chk_sets(const TUsart::TSets&)
00000e  b958              CBNZ     r0,|L18.40|
;;;220      {
;;;221      
;;;222      }
;;;223      else //если не совпадают
;;;224      {
;;;225        dis_if();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       _ZN6TUsart6dis_ifEv ; TUsart::dis_if()
;;;226        Sets = _Sets;
000016  e8940007          LDM      r4,{r0-r2}
00001a  e9c51203          STRD     r1,r2,[r5,#0xc]
00001e  60a8              STR      r0,[r5,#8]
;;;227        hw_init( 17U );
000020  2111              MOVS     r1,#0x11
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       _ZN6TUsart7hw_initEh ; TUsart::hw_init(unsigned char)
                  |L18.40|
;;;228      }
;;;229    }
000028  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP


                          AREA ||i._ZN6TUsart9enable_rxEv||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart9enable_rxEv PROC ; TUsart::enable_rx()
;;;289    
;;;290    void TUsart::enable_rx()
000000  4601              MOV      r1,r0
;;;291    { 
;;;292      LL_USART_EnableDirectionRx( HW.If ); 
000002  684a              LDR      r2,[r1,#4]
000004  6810              LDR      r0,[r2,#0]
000006  6802              LDR      r2,[r0,#0]
000008  f0420204          ORR      r2,r2,#4
00000c  6002              STR      r2,[r0,#0]
00000e  bf00              NOP      
;;;293    }
000010  4770              BX       lr
;;;294    
                          ENDP


                          AREA ||i._ZN6TUsart9read_byteEv||, CODE, READONLY, ALIGN=1

                  _ZN6TUsart9read_byteEv PROC ; TUsart::read_byte()
;;;277    
;;;278    uint8_t TUsart::read_byte()                                        //считывание одного байта
000000  b510              PUSH     {r4,lr}
;;;279    {
000002  4604              MOV      r4,r0
;;;280      clr_error_flags();
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _ZN6TUsart15clr_error_flagsEv ; TUsart::clr_error_flags()
;;;281      
;;;282      do
00000a  bf00              NOP      
                  |L20.12|
;;;283      {
;;;284        
;;;285      } while ( LL_USART_IsActiveFlag_RXNE( HW.If ) == false );
00000c  6861              LDR      r1,[r4,#4]
00000e  6808              LDR      r0,[r1,#0]
000010  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17526LL_USART_IsActiveFlag_RXNEEP13USART_TypeDef ; [local to usart_driver__cpp]::LL_USART_IsActiveFlag_RXNE(USART_TypeDef*)
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L20.12|
;;;286      
;;;287      return LL_USART_ReceiveData8( HW.If );
000018  6861              LDR      r1,[r4,#4]
00001a  6808              LDR      r0,[r1,#0]
00001c  f7fffffe          BL       _ZN39_INTERNAL_17_usart_driver__cpp_b612a17521LL_USART_ReceiveData8EP13USART_TypeDef ; [local to usart_driver__cpp]::LL_USART_ReceiveData8(USART_TypeDef*)
;;;288    }
000020  bd10              POP      {r4,pc}
;;;289    
                          ENDP


                          AREA ||i._ZN6TUsartC1ERK9TUsart_HWRKNS_5TSetsENS_5TModeE||, CODE, READONLY, ALIGN=1

                  _ZN6TUsartC2ERK9TUsart_HWRKNS_5TSetsENS_5TModeE                  ; Alternate entry point ; TUsart::TUsart__sub_object(const TUsart_HW&, const TUsart::TSets&, TUsart::TMode)
                  _ZN6TUsartC1ERK9TUsart_HWRKNS_5TSetsENS_5TModeE PROC ; TUsart::TUsart(const TUsart_HW&, const TUsart::TSets&, TUsart::TMode)
;;;11                                 
;;;12     TUsart::TUsart(
;;;13                    const TUsart_HW &_HW,
;;;14                    const TSets &_Sets,
;;;15                    TMode _Mode
;;;16                   )
;;;17     :
;;;18     HW(_HW),
;;;19     Sets( _Sets ),
;;;20     Mode( _Mode )
;;;21     {
;;;22       
;;;23     }
;;;24     
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       _ZN12T_RS_485_phyC1Ev ; T_RS_485_phy::T_RS_485_phy()
000012  4604              MOV      r4,r0
000014  6065              STR      r5,[r4,#4]
000016  e8960007          LDM      r6,{r0-r2}
00001a  e9c41203          STRD     r1,r2,[r4,#0xc]
00001e  60a0              STR      r0,[r4,#8]
000020  7527              STRB     r7,[r4,#0x14]
000022  4620              MOV      r0,r4
000024  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i._ZN6TUsartD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN6TUsartD2Ev                  ; Alternate entry point ; TUsart::~TUsart__sub_object()
                  _ZN6TUsartD1Ev PROC ; TUsart::~TUsart()
;;;24     
;;;25     TUsart::~TUsart()
;;;26     {
;;;27     
;;;28     }
;;;29     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _ZN12T_RS_485_phyD1Ev ; T_RS_485_phy::~T_RS_485_phy()
00000a  4604              MOV      r4,r0
00000c  4620              MOV      r0,r4
00000e  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i._ZNK6TUsart8get_setsEv||, CODE, READONLY, ALIGN=1

                  _ZNK6TUsart8get_setsEv PROC ; TUsart::get_sets() const
;;;211    
;;;212    const TUsart::TSets &TUsart::get_sets() const
000000  4601              MOV      r1,r0
;;;213    {
;;;214      return Sets;
000002  f1010008          ADD      r0,r1,#8
;;;215    }
000006  4770              BX       lr
;;;216    
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17520LL_USART_SetBaudRateEP13USART_TypeDefjjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17520LL_USART_SetBaudRateEP13USART_TypeDefjjj||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i._ZN6TUsartC1ERK9TUsart_HWRKNS_5TSetsENS_5TModeE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsartC1ERK9TUsart_HWRKNS_5TSetsENS_5TModeE||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i._ZN6TUsartD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsartD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i._ZN6TUsart14pin_clk_configEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart14pin_clk_configEv||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i._ZN6TUsart15clr_error_flagsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart15clr_error_flagsEv||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i._ZN6TUsart7set_232Ejj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart7set_232Ejj||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i._ZN6TUsart10set_485_hdEjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart10set_485_hdEjj||
                          DCD      0x00000001

                          AREA ||area_number.31||, LINKORDER=||i._ZN6TUsart7hw_initEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart7hw_initEh||
                          DCD      0x00000001

                          AREA ||area_number.32||, LINKORDER=||i._ZN6TUsart6dis_ifEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart6dis_ifEv||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i._ZN6TUsart8chk_setsERKNS_5TSetsE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart8chk_setsERKNS_5TSetsE||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN6TUsart8set_setsERKNS_5TSetsE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart8set_setsERKNS_5TSetsE||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZN6TUsart13en_eob_detectEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart13en_eob_detectEh||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN6TUsart14dis_eob_detectEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart14dis_eob_detectEv||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZNK6TUsart8get_setsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK6TUsart8get_setsEv||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN6TUsart10read_burstEPhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart10read_burstEPhh||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN6TUsart11write_burstEPKht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart11write_burstEPKht||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN6TUsart9read_byteEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart9read_byteEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN6TUsart9enable_rxEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart9enable_rxEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN6TUsart10disable_rxEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart10disable_rxEv||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN6TUsart13set_interruptEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6TUsart13set_interruptEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17526LL_USART_IsActiveFlag_RXNEEP13USART_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17526LL_USART_IsActiveFlag_RXNEEP13USART_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17522LL_USART_ClearFlag_RTOEP13USART_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17522LL_USART_ClearFlag_RTOEP13USART_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17521LL_USART_ReceiveData8EP13USART_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN39_INTERNAL_17_usart_driver__cpp_b612a17521LL_USART_ReceiveData8EP13USART_TypeDef||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _ZN6TUsart8DEF_SETSE ; TUsart::DEF_SETS
                          DCD      0x00004b00
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002000
                          DCD      0x00000000
                          DCD      0x00000400
                          DCD      0x00000000
                          DCD      0x00001000
                          DCD      0x00000400
                          DCD      0x00002000
                          DCD      0x00000000
                          DCD      0x00000600
                          DCD      0x00000000
                          DCD      0x00001000
                          DCD      0x00000600
                          DCD      0x00002000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\MCU_Drivers\\src\\usart_driver_.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_usart_driver__cpp_b612a175___ZN39_INTERNAL_17_usart_driver__cpp_b612a1757__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___17_usart_driver__cpp_b612a175___ZN39_INTERNAL_17_usart_driver__cpp_b612a1757__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_usart_driver__cpp_b612a175___ZN39_INTERNAL_17_usart_driver__cpp_b612a1757__REVSHEi|
#line 402
|__asm___17_usart_driver__cpp_b612a175___ZN39_INTERNAL_17_usart_driver__cpp_b612a1757__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_usart_driver__cpp_b612a175___ZN39_INTERNAL_17_usart_driver__cpp_b612a1755__RRXEj|
#line 587
|__asm___17_usart_driver__cpp_b612a175___ZN39_INTERNAL_17_usart_driver__cpp_b612a1755__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
