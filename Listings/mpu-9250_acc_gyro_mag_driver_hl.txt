; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\mpu-9250_acc_gyro_mag_driver_hl.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mpu-9250_acc_gyro_mag_driver_hl.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\mpu-9250_acc_gyro_mag_driver_hl.crf Source\Ext_Dev\src\MPU-9250_acc_gyro_mag_driver_hl.cpp]
                          THUMB

                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI15_10_IRQHandler PROC
;;;682    
;;;683    extern "C" void EXTI15_10_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;684    {
;;;685    //    Do.closed();
;;;686    //  RelFour.on();
;;;687    //		RelThree.on();
;;;688      if ( LL_EXTI_IsActiveFlag_0_31( I2C_HW.Exti.Line ) )
000002  4913              LDR      r1,|L1.80|
000004  6d08              LDR      r0,[r1,#0x50]
000006  4913              LDR      r1,|L1.84|
000008  6809              LDR      r1,[r1,#0]
00000a  4001              ANDS     r1,r1,r0
00000c  4281              CMP      r1,r0
00000e  d101              BNE      |L1.20|
000010  2101              MOVS     r1,#1
000012  e000              B        |L1.22|
                  |L1.20|
000014  2100              MOVS     r1,#0
                  |L1.22|
000016  b1d1              CBZ      r1,|L1.78|
;;;689      {
;;;690        LL_EXTI_ClearFlag_0_31( I2C_HW.Exti.Line  );
000018  490d              LDR      r1,|L1.80|
00001a  6d08              LDR      r0,[r1,#0x50]
00001c  490d              LDR      r1,|L1.84|
00001e  6008              STR      r0,[r1,#0]
000020  bf00              NOP      
;;;691    	 
;;;692    	 Int1HigherPriorityTaskWoken = pdFALSE;
000022  2000              MOVS     r0,#0
000024  490c              LDR      r1,|L1.88|
000026  6008              STR      r0,[r1,#0]  ; Int1HigherPriorityTaskWoken
;;;693    //   RelFour.on();
;;;694    	 if (xSemaphoreGiveFromISR(RawDataMems_RdySem, &Int1HigherPriorityTaskWoken) == pdFAIL) //отправить семафор окончания записи
000028  480c              LDR      r0,|L1.92|
00002a  6800              LDR      r0,[r0,#0]  ; RawDataMems_RdySem
00002c  f7fffffe          BL       xQueueGiveFromISR
;;;695        {
;;;696          //семафор уже был доступен, т.е. ранее отдан другой задачей или прерыванием
;;;697    //   RelFour.toggle();
;;;698          
;;;699        }  
;;;700    	 if (Int1HigherPriorityTaskWoken == pdTRUE)
000030  4809              LDR      r0,|L1.88|
000032  6800              LDR      r0,[r0,#0]  ; Int1HigherPriorityTaskWoken
000034  2801              CMP      r0,#1
000036  d10a              BNE      |L1.78|
;;;701    	 {
;;;702       
;;;703          portYIELD_FROM_ISR(Int1HigherPriorityTaskWoken); //принудительное переключение контекста для разблокировки задачи - обработчика
000038  4807              LDR      r0,|L1.88|
00003a  6800              LDR      r0,[r0,#0]  ; Int1HigherPriorityTaskWoken
00003c  b138              CBZ      r0,|L1.78|
00003e  f04f5080          MOV      r0,#0x10000000
000042  4907              LDR      r1,|L1.96|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L1.78|
;;;704    	                                                    //максимально быстро перейти к считыванию данных с датчиков микросхемы MPU-9250
;;;705    	                                                    //для FreeRTOS время от выдачи семафора до перехода к задаче на stm32f3 - 7мкс
;;;706    	 }	 
;;;707      }
;;;708    //  Do.open();
;;;709    }
00004e  bd10              POP      {r4,pc}
;;;710    
                          ENDP

                  |L1.80|
                          DCD      I2C_HW
                  |L1.84|
                          DCD      0x40010414
                  |L1.88|
                          DCD      Int1HigherPriorityTaskWoken
                  |L1.92|
                          DCD      RawDataMems_RdySem
                  |L1.96|
                          DCD      0xe000ed04

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL10config_accEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL10config_accEv PROC ; MPU_9250::TAccGyroMagDriver_HL::config_acc()
;;;286      
;;;287      void TAccGyroMagDriver_HL::config_acc()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;288      {
000004  4604              MOV      r4,r0
;;;289        uint8_t TxByte;
;;;290    #ifndef __DEBUG__
;;;291    	  uint8_t AccGyroAddr = get_acc_gyro_addr(_HIGH);
000006  2101              MOVS     r1,#1
000008  f104007b          ADD      r0,r4,#0x7b
00000c  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
000010  4607              MOV      r7,r0
;;;292    #else
;;;293    	  uint8_t AccGyroAddr = get_acc_gyro_addr(_LOW);
;;;294    #endif
;;;295     
;;;296    	  uint8_t RegAddr = accel_full_scale_select(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000012  2203              MOVS     r2,#3
000014  2100              MOVS     r1,#0
000016  f104007b          ADD      r0,r4,#0x7b
00001a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23accel_full_scale_selectEPhNS_21VAccelFullScaleSelectE ; MPU_9250::TAccGyroMagDriver_LL::accel_full_scale_select(unsigned char*, MPU_9250::VAccelFullScaleSelect)
00001e  4680              MOV      r8,r0
;;;297    	  VAccelFullScaleSelect FullScale = VAccelFullScaleSelect::_8G;
000020  2502              MOVS     r5,#2
;;;298        
;;;299    	  read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000022  463b              MOV      r3,r7
000024  4642              MOV      r2,r8
000026  a901              ADD      r1,sp,#4
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;300    	  accel_full_scale_select(&TxByte, FullScale); //модифицировать TxByte записью только необходимых настроек
00002e  462a              MOV      r2,r5
000030  a901              ADD      r1,sp,#4
000032  f104007b          ADD      r0,r4,#0x7b
000036  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23accel_full_scale_selectEPhNS_21VAccelFullScaleSelectE ; MPU_9250::TAccGyroMagDriver_LL::accel_full_scale_select(unsigned char*, MPU_9250::VAccelFullScaleSelect)
;;;301        
;;;302    	  switch (FullScale)
00003a  b1a5              CBZ      r5,|L2.102|
00003c  2d01              CMP      r5,#1
00003e  d00d              BEQ      |L2.92|
000040  2d02              CMP      r5,#2
000042  d006              BEQ      |L2.82|
000044  2d03              CMP      r5,#3
000046  d113              BNE      |L2.112|
;;;303    	  {
;;;304    	    case VAccelFullScaleSelect::_16G:
;;;305    		      AccelSensitivity = sensitivity_accel::_3_FS_SEL;
000048  f44f6000          MOV      r0,#0x800
00004c  f8a40084          STRH     r0,[r4,#0x84]
;;;306    		      break;
000050  e00f              B        |L2.114|
                  |L2.82|
;;;307    	    case VAccelFullScaleSelect::_8G:
;;;308    		      AccelSensitivity = sensitivity_accel::_2_FS_SEL;
000052  f44f5080          MOV      r0,#0x1000
000056  f8a40084          STRH     r0,[r4,#0x84]
;;;309    		      break;
00005a  e00a              B        |L2.114|
                  |L2.92|
;;;310    	    case VAccelFullScaleSelect::_4G:
;;;311    		      AccelSensitivity = sensitivity_accel::_1_FS_SEL;
00005c  f44f5000          MOV      r0,#0x2000
000060  f8a40084          STRH     r0,[r4,#0x84]
;;;312    		      break;
000064  e005              B        |L2.114|
                  |L2.102|
;;;313    	    case VAccelFullScaleSelect::_2G:
;;;314    		      AccelSensitivity = sensitivity_accel::_0_FS_SEL;
000066  f44f4080          MOV      r0,#0x4000
00006a  f8a40084          STRH     r0,[r4,#0x84]
;;;315    		      break;
00006e  e000              B        |L2.114|
                  |L2.112|
;;;316    	    default:
;;;317    		      break;
000070  bf00              NOP      
                  |L2.114|
000072  bf00              NOP                            ;306
;;;318    	  }
;;;319    
;;;320    	  write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
000074  463b              MOV      r3,r7
000076  4642              MOV      r2,r8
000078  a901              ADD      r1,sp,#4
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;321        
;;;322    //	 //----- Включение возможности выбора полосы пропускания фильтра гироскопа и термодатчика - Fchoice --------------------
;;;323    //	 RegAddr = gyro_filter_choise(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
;;;324    //	 VGyroFilterChoise FilterChoise = VGyroFilterChoise::_11;
;;;325    
;;;326    //	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
;;;327    //	 gyro_filter_choise(&TxByte, FilterChoise); //модифицировать TxByte записью только необходимых настроек
;;;328    //	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
;;;329    //   
;;;330    //   //----- Настройка делителя частоты выборки для 1000Гц (при частоте выборки 8000Гц)
;;;331    //	 RegAddr = sample_rate_divider(); //получить адрес регистра микросхемы с необходимой настройкой
;;;332    //	 TxByte = 0x07;
;;;333    //	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
;;;334       
;;;335    	  //----- Настройка скорости и полосы пропускания фильтра акселерометра ------------------------------------------------
;;;336    	  RegAddr = accel_filter_choise(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000080  2201              MOVS     r2,#1
000082  2100              MOVS     r1,#0
000084  f104007b          ADD      r0,r4,#0x7b
000088  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL19accel_filter_choiseEPhNS_18VAccelFilterChoiseE ; MPU_9250::TAccGyroMagDriver_LL::accel_filter_choise(unsigned char*, MPU_9250::VAccelFilterChoise)
00008c  4680              MOV      r8,r0
;;;337    	  VAccelFilterChoise AccelFilterChoise = VAccelFilterChoise::_1;
00008e  2600              MOVS     r6,#0
;;;338    	  VSetAccelFilter SetAccelFilter = VSetAccelFilter::_218_1Hz_1_88ms;
000090  2000              MOVS     r0,#0
000092  9000              STR      r0,[sp,#0]
;;;339        
;;;340    	  read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000094  463b              MOV      r3,r7
000096  4642              MOV      r2,r8
000098  a901              ADD      r1,sp,#4
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;341    	  accel_filter_choise(&TxByte, AccelFilterChoise); //модифицировать TxByte записью только необходимых настроек
0000a0  4632              MOV      r2,r6
0000a2  a901              ADD      r1,sp,#4
0000a4  f104007b          ADD      r0,r4,#0x7b
0000a8  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL19accel_filter_choiseEPhNS_18VAccelFilterChoiseE ; MPU_9250::TAccGyroMagDriver_LL::accel_filter_choise(unsigned char*, MPU_9250::VAccelFilterChoise)
;;;342    	  set_accel_filter(&TxByte, SetAccelFilter); //модифицировать TxByte записью только необходимых настроек
0000ac  f89d2000          LDRB     r2,[sp,#0]
0000b0  a901              ADD      r1,sp,#4
0000b2  f104007b          ADD      r0,r4,#0x7b
0000b6  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL16set_accel_filterEPhNS_15VSetAccelFilterE ; MPU_9250::TAccGyroMagDriver_LL::set_accel_filter(unsigned char*, MPU_9250::VSetAccelFilter)
;;;343    	  write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
0000ba  463b              MOV      r3,r7
0000bc  4642              MOV      r2,r8
0000be  a901              ADD      r1,sp,#4
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;344        
;;;345    	  //----- Проверка установленной полосы пропускания фильтра гироскопа и термодатчика ------------------------------------
;;;346    	  read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
0000c6  463b              MOV      r3,r7
0000c8  4642              MOV      r2,r8
0000ca  a901              ADD      r1,sp,#4
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;347        
;;;348    	  accel_filter_read(TxByte, &SetAccelFilter);
0000d2  466a              MOV      r2,sp
0000d4  f89d1004          LDRB     r1,[sp,#4]
0000d8  f104007b          ADD      r0,r4,#0x7b
0000dc  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL17accel_filter_readEhPNS_15VSetAccelFilterE ; MPU_9250::TAccGyroMagDriver_LL::accel_filter_read(unsigned char, MPU_9250::VSetAccelFilter*)
;;;349    	  switch (SetAccelFilter)
0000e0  f89d0000          LDRB     r0,[sp,#0]
0000e4  2808              CMP      r0,#8
0000e6  d210              BCS      |L2.266|
0000e8  e8dff000          TBB      [pc,r0]
0000ec  050f0a08          DCB      0x05,0x0f,0x0a,0x08
0000f0  06040907          DCB      0x06,0x04,0x09,0x07
;;;350    	  {
;;;351    	    case VSetAccelFilter::_10_2Hz_16_83ms:
;;;352    	    case VSetAccelFilter::_218_1Hz_1_88ms:
0000f4  bf00              NOP      
;;;353    	    case VSetAccelFilter::_21_2Hz_8_87ms:
0000f6  bf00              NOP      
;;;354    	    case VSetAccelFilter::_420Hz_1_38ms:
0000f8  bf00              NOP      
;;;355    	    case VSetAccelFilter::_44_8Hz_4_88ms:
0000fa  bf00              NOP      
;;;356    	    case VSetAccelFilter::_5_05Hz_32_48ms:
0000fc  bf00              NOP      
;;;357    	    case VSetAccelFilter::_99Hz_2_88ms:
0000fe  bf00              NOP      
;;;358    		       AccelSampleRate_us = ACCEL_1_kHz_SAMPLE_RATE_us;
000100  f44f707a          MOV      r0,#0x3e8
000104  f8c40090          STR      r0,[r4,#0x90]
;;;359               break;
000108  e000              B        |L2.268|
                  |L2.266|
;;;360    	    default:
;;;361    		       break;
00010a  bf00              NOP      
                  |L2.268|
00010c  bf00              NOP                            ;359
;;;362    	  }
;;;363      }
00010e  e8bd81fc          POP      {r2-r8,pc}
;;;364    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL10config_magEv||, CODE, READONLY, ALIGN=2

                  _ZN8MPU_925020TAccGyroMagDriver_HL10config_magEv PROC ; MPU_9250::TAccGyroMagDriver_HL::config_mag()
;;;364    
;;;365      void TAccGyroMagDriver_HL::config_mag()
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;366      {
000004  4604              MOV      r4,r0
;;;367        //----- Перед работой с магнитометром необходимо проверить: включен ли Pass-Through Mode ---------------------------------
;;;368    	 //----- Если не включен, включить Pass-Through Mode ----------------------------------------------------------------------
;;;369    	 uint8_t TxByte;
;;;370    #ifndef __DEBUG__
;;;371    	 uint8_t SlaveAddr = get_acc_gyro_addr(_HIGH);
000006  2101              MOVS     r1,#1
000008  f104007b          ADD      r0,r4,#0x7b
00000c  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
000010  4607              MOV      r7,r0
;;;372    #else
;;;373    	 uint8_t SlaveAddr = get_acc_gyro_addr(_LOW);
;;;374    #endif
;;;375     
;;;376    	 uint8_t RegAddr = i2c_master_pins_ctrl(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000012  2200              MOVS     r2,#0
000014  4611              MOV      r1,r2
000016  f104007b          ADD      r0,r4,#0x7b
00001a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL20i2c_master_pins_ctrlEPhNS_6VEnDisE ; MPU_9250::TAccGyroMagDriver_LL::i2c_master_pins_ctrl(unsigned char*, MPU_9250::VEnDis)
00001e  4680              MOV      r8,r0
;;;377    	 
;;;378    	 read_single_byte(&TxByte, RegAddr, SlaveAddr); //считать содержимое регистра микросхемы в TxByte
000020  463b              MOV      r3,r7
000022  4642              MOV      r2,r8
000024  a903              ADD      r1,sp,#0xc
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;379    //    RelFour.off();
;;;380    	 
;;;381    	 VEnDis I2CBypassCtrl; //включить проброс выводов I2C к магнитометру
;;;382    	 i2c_master_pins_read(TxByte, &I2CBypassCtrl);
00002c  aa02              ADD      r2,sp,#8
00002e  f89d100c          LDRB     r1,[sp,#0xc]
000032  f104007b          ADD      r0,r4,#0x7b
000036  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL20i2c_master_pins_readEhPNS_6VEnDisE ; MPU_9250::TAccGyroMagDriver_LL::i2c_master_pins_read(unsigned char, MPU_9250::VEnDis*)
;;;383    	 
;;;384    	 switch (I2CBypassCtrl)
00003a  f89d0008          LDRB     r0,[sp,#8]
00003e  b110              CBZ      r0,|L3.70|
000040  2801              CMP      r0,#1
000042  d111              BNE      |L3.104|
000044  e00f              B        |L3.102|
                  |L3.70|
;;;385    	 {
;;;386    	   case VEnDis::_DISABLE:
;;;387    	        I2CBypassCtrl = VEnDis::_ENABLE; //включить проброс выводов I2C к магнитометру
000046  2001              MOVS     r0,#1
000048  9002              STR      r0,[sp,#8]
;;;388    	        i2c_master_pins_ctrl(&TxByte, I2CBypassCtrl); //модифицировать TxByte записью только необходимых настроек
00004a  f89d2008          LDRB     r2,[sp,#8]
00004e  a903              ADD      r1,sp,#0xc
000050  f104007b          ADD      r0,r4,#0x7b
000054  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL20i2c_master_pins_ctrlEPhNS_6VEnDisE ; MPU_9250::TAccGyroMagDriver_LL::i2c_master_pins_ctrl(unsigned char*, MPU_9250::VEnDis)
;;;389    	        write_single_byte(&TxByte, RegAddr, SlaveAddr); //записать модифицированный TxByte в микросхему
000058  463b              MOV      r3,r7
00005a  4642              MOV      r2,r8
00005c  a903              ADD      r1,sp,#0xc
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;390    		     break;
000064  e001              B        |L3.106|
                  |L3.102|
;;;391    	   case VEnDis::_ENABLE:
;;;392    		     //Pass-Through Mode включен, можно настраивать магнитометр 
;;;393    		     break;
000066  e000              B        |L3.106|
                  |L3.104|
;;;394    	   default:
;;;395    		     break;
000068  bf00              NOP      
                  |L3.106|
00006a  bf00              NOP                            ;390
;;;396    	 }
;;;397    
;;;398    	 if (!check_id_mag())
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL12check_id_magEv ; MPU_9250::TAccGyroMagDriver_HL::check_id_mag()
000072  b920              CBNZ     r0,|L3.126|
;;;399    	 { 
;;;400    		MagState = TMagCheck::_MAG_ERROR;
000074  2000              MOVS     r0,#0
000076  f8840098          STRB     r0,[r4,#0x98]
                  |L3.122|
;;;401    		return;
;;;402    	 }
;;;403    	 else
;;;404    	 {
;;;405    	   MagState = TMagCheck::_MAG_OK;
;;;406    	 }
;;;407    	 
;;;408        
;;;409    	 //----- Настройка разрядности выходных данных и режима работы магнитометра -----------------------------------------------
;;;410    	 SlaveAddr = get_mag_addr(); 
;;;411    	 RegAddr   = mag_output_bit_set(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
;;;412    	 VMagOutputBitSet MagOutputBitSet = VMagOutputBitSet::_16_BIT_OUTPUT;
;;;413    	 VMagOperationModeSet MagOperationModeSet = VMagOperationModeSet::_CONTINUOUS_MEAS_MODE_2;
;;;414    	 
;;;415    	 read_single_byte(&TxByte, RegAddr, SlaveAddr); //считать содержимое регистра микросхемы в TxByte
;;;416    	 mag_output_bit_set(&TxByte, MagOutputBitSet); //модифицировать TxByte записью только необходимых настроек
;;;417    	 mag_operation_mode_set(&TxByte, MagOperationModeSet); //модифицировать TxByte записью только необходимых настроек
;;;418    	 write_single_byte(&TxByte, RegAddr, SlaveAddr); //записать модифицированный TxByte в микросхему
;;;419        
;;;420    	 //----- Проверка установленной разрядности магнитометра -------------------------------------------------------------------
;;;421    	 read_single_byte(&TxByte, RegAddr, SlaveAddr); //считать содержимое регистра микросхемы в TxByte	 
;;;422    	 
;;;423    	 VMagOutputBitSet BIT;
;;;424    	 VMagOperationModeSet MODE;
;;;425    	 mag_output_bit_read(TxByte, &BIT);
;;;426    	 mag_operation_mode_read(TxByte, &MODE);
;;;427    	 switch (BIT)
;;;428    	 {
;;;429    	   case VMagOutputBitSet::_14_BIT_OUTPUT:
;;;430    		     MagSensitivity = sensitivity_mag::_14_BIT_SENS;
;;;431    		     break;
;;;432    	   case VMagOutputBitSet::_16_BIT_OUTPUT:
;;;433    		     MagSensitivity = sensitivity_mag::_16_BIT_SENS;
;;;434    		     break;
;;;435    	   default:
;;;436    		     break;
;;;437    	 }
;;;438    	 
;;;439    	 switch (MODE)
;;;440    	 {
;;;441    	   case VMagOperationModeSet::_CONTINUOUS_MEAS_MODE_1:
;;;442    		     MagSampleRate_us = MAG_MODE1_RATE_us;
;;;443    		     break;
;;;444    	   case VMagOperationModeSet::_CONTINUOUS_MEAS_MODE_2:
;;;445    		     MagSampleRate_us = MAG_MODE2_RATE_us;
;;;446    		     break;
;;;447    	   default:
;;;448    		     break;
;;;449    	 }
;;;450    	 
;;;451    	 MagWorkFlag = true; //после установки режима, магнитометр начинает измерять
;;;452      }
00007a  e8bd81ff          POP      {r0-r8,pc}
                  |L3.126|
00007e  2001              MOVS     r0,#1                 ;405
000080  f8840098          STRB     r0,[r4,#0x98]         ;405
000084  f104007b          ADD      r0,r4,#0x7b           ;410
000088  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL12get_mag_addrEv ; MPU_9250::TAccGyroMagDriver_LL::get_mag_addr() const
00008c  4607              MOV      r7,r0                 ;410
00008e  2201              MOVS     r2,#1                 ;411
000090  2100              MOVS     r1,#0                 ;411
000092  f104007b          ADD      r0,r4,#0x7b           ;411
000096  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL18mag_output_bit_setEPhNS_16VMagOutputBitSetE ; MPU_9250::TAccGyroMagDriver_LL::mag_output_bit_set(unsigned char*, MPU_9250::VMagOutputBitSet)
00009a  4680              MOV      r8,r0                 ;411
00009c  2501              MOVS     r5,#1                 ;412
00009e  2606              MOVS     r6,#6                 ;413
0000a0  463b              MOV      r3,r7                 ;415
0000a2  4642              MOV      r2,r8                 ;415
0000a4  a903              ADD      r1,sp,#0xc            ;415
0000a6  4620              MOV      r0,r4                 ;415
0000a8  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
0000ac  462a              MOV      r2,r5                 ;416
0000ae  a903              ADD      r1,sp,#0xc            ;416
0000b0  f104007b          ADD      r0,r4,#0x7b           ;416
0000b4  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL18mag_output_bit_setEPhNS_16VMagOutputBitSetE ; MPU_9250::TAccGyroMagDriver_LL::mag_output_bit_set(unsigned char*, MPU_9250::VMagOutputBitSet)
0000b8  4632              MOV      r2,r6                 ;417
0000ba  a903              ADD      r1,sp,#0xc            ;417
0000bc  f104007b          ADD      r0,r4,#0x7b           ;417
0000c0  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL22mag_operation_mode_setEPhNS_20VMagOperationModeSetE ; MPU_9250::TAccGyroMagDriver_LL::mag_operation_mode_set(unsigned char*, MPU_9250::VMagOperationModeSet)
0000c4  463b              MOV      r3,r7                 ;418
0000c6  4642              MOV      r2,r8                 ;418
0000c8  a903              ADD      r1,sp,#0xc            ;418
0000ca  4620              MOV      r0,r4                 ;418
0000cc  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
0000d0  463b              MOV      r3,r7                 ;421
0000d2  4642              MOV      r2,r8                 ;421
0000d4  a903              ADD      r1,sp,#0xc            ;421
0000d6  4620              MOV      r0,r4                 ;421
0000d8  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
0000dc  aa01              ADD      r2,sp,#4              ;425
0000de  f89d100c          LDRB     r1,[sp,#0xc]          ;425
0000e2  f104007b          ADD      r0,r4,#0x7b           ;425
0000e6  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL19mag_output_bit_readEhPNS_16VMagOutputBitSetE ; MPU_9250::TAccGyroMagDriver_LL::mag_output_bit_read(unsigned char, MPU_9250::VMagOutputBitSet*)
0000ea  466a              MOV      r2,sp                 ;426
0000ec  f89d100c          LDRB     r1,[sp,#0xc]          ;426
0000f0  f104007b          ADD      r0,r4,#0x7b           ;426
0000f4  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23mag_operation_mode_readEhPNS_20VMagOperationModeSetE ; MPU_9250::TAccGyroMagDriver_LL::mag_operation_mode_read(unsigned char, MPU_9250::VMagOperationModeSet*)
0000f8  f89d0004          LDRB     r0,[sp,#4]            ;427
0000fc  b110              CBZ      r0,|L3.260|
0000fe  2801              CMP      r0,#1                 ;427
000100  d10a              BNE      |L3.280|
000102  e004              B        |L3.270|
                  |L3.260|
000104  ed9f0a11          VLDR     s0,|L3.332|
000108  ed840a22          VSTR     s0,[r4,#0x88]         ;430
00010c  e005              B        |L3.282|
                  |L3.270|
00010e  ed9f0a10          VLDR     s0,|L3.336|
000112  ed840a22          VSTR     s0,[r4,#0x88]         ;433
000116  e000              B        |L3.282|
                  |L3.280|
000118  bf00              NOP                            ;436
                  |L3.282|
00011a  bf00              NOP                            ;431
00011c  f89d0000          LDRB     r0,[sp,#0]            ;439
000120  2802              CMP      r0,#2                 ;439
000122  d002              BEQ      |L3.298|
000124  2806              CMP      r0,#6                 ;439
000126  d109              BNE      |L3.316|
000128  e003              B        |L3.306|
                  |L3.298|
00012a  480a              LDR      r0,|L3.340|
00012c  f8c40094          STR      r0,[r4,#0x94]         ;442
000130  e005              B        |L3.318|
                  |L3.306|
000132  f2427010          MOV      r0,#0x2710            ;445
000136  f8c40094          STR      r0,[r4,#0x94]         ;445
00013a  e000              B        |L3.318|
                  |L3.316|
00013c  bf00              NOP                            ;448
                  |L3.318|
00013e  bf00              NOP                            ;443
000140  2001              MOVS     r0,#1                 ;451
000142  f884007e          STRB     r0,[r4,#0x7e]         ;451
000146  bf00              NOP      
000148  e797              B        |L3.122|
;;;453      
                          ENDP

00014a  0000              DCW      0x0000
                  |L3.332|
00014c  3f19999a          DCFS     0x3f19999a ; 0.60000002384185791
                  |L3.336|
000150  3e19999a          DCFS     0x3e19999a ; 0.15000000596046448
                  |L3.340|
                          DCD      0x0001e848

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL10count_gyroEPKNS_12TRawAxesDataE||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL10count_gyroEPKNS_12TRawAxesDataE PROC ; MPU_9250::TAccGyroMagDriver_HL::count_gyro(const MPU_9250::TRawAxesData*)
;;;632    
;;;633      void TAccGyroMagDriver_HL::count_gyro(const TRawAxesData *DataPtr)
000000  f9b12000          LDRSH    r2,[r1,#0]
;;;634      {
;;;635        Gyro.X = static_cast<float>(DataPtr->X) / GyroSensitivity;
000004  ee002a10          VMOV     s0,r2
000008  eeb80ac0          VCVT.F32.S32 s0,s0
00000c  edd00a20          VLDR     s1,[r0,#0x80]
000010  ee801a20          VDIV.F32 s2,s0,s1
000014  ed801a2b          VSTR     s2,[r0,#0xac]
;;;636        Gyro.Y = static_cast<float>(DataPtr->Y) / GyroSensitivity;
000018  f9b12002          LDRSH    r2,[r1,#2]
00001c  ee002a10          VMOV     s0,r2
000020  eeb80ac0          VCVT.F32.S32 s0,s0
000024  edd00a20          VLDR     s1,[r0,#0x80]
000028  ee801a20          VDIV.F32 s2,s0,s1
00002c  ed801a2c          VSTR     s2,[r0,#0xb0]
;;;637        Gyro.Z = static_cast<float>(DataPtr->Z) / GyroSensitivity;
000030  f9b12004          LDRSH    r2,[r1,#4]
000034  ee002a10          VMOV     s0,r2
000038  eeb80ac0          VCVT.F32.S32 s0,s0
00003c  edd00a20          VLDR     s1,[r0,#0x80]
000040  ee801a20          VDIV.F32 s2,s0,s1
000044  ed801a2d          VSTR     s2,[r0,#0xb4]
;;;638      }
000048  4770              BX       lr
;;;639    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL11config_gyroEv||, CODE, READONLY, ALIGN=2

                  _ZN8MPU_925020TAccGyroMagDriver_HL11config_gyroEv PROC ; MPU_9250::TAccGyroMagDriver_HL::config_gyro()
;;;204      
;;;205      void TAccGyroMagDriver_HL::config_gyro()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;206      {
000004  4604              MOV      r4,r0
;;;207        uint8_t TxByte;
;;;208    #ifndef __DEBUG__
;;;209    	 uint8_t AccGyroAddr = get_acc_gyro_addr(_HIGH);
000006  2101              MOVS     r1,#1
000008  f104007b          ADD      r0,r4,#0x7b
00000c  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
000010  4607              MOV      r7,r0
;;;210    #else
;;;211    	 uint8_t AccGyroAddr = get_acc_gyro_addr(_LOW);
;;;212    #endif
;;;213     
;;;214    	 uint8_t RegAddr = gyro_full_scale_select(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000012  2203              MOVS     r2,#3
000014  2100              MOVS     r1,#0
000016  f104007b          ADD      r0,r4,#0x7b
00001a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL22gyro_full_scale_selectEPhNS_20VGyroFullScaleSelectE ; MPU_9250::TAccGyroMagDriver_LL::gyro_full_scale_select(unsigned char*, MPU_9250::VGyroFullScaleSelect)
00001e  4680              MOV      r8,r0
;;;215    	 VGyroFullScaleSelect FullScale = VGyroFullScaleSelect::_2000_DPS;
000020  2503              MOVS     r5,#3
;;;216    //	 VGyroFullScaleSelect FullScale = VGyroFullScaleSelect::_1000_DPS;
;;;217    //	 VGyroFullScaleSelect FullScale = VGyroFullScaleSelect::_250_DPS;
;;;218    	 
;;;219    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000022  463b              MOV      r3,r7
000024  4642              MOV      r2,r8
000026  a901              ADD      r1,sp,#4
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;220    	 gyro_full_scale_select(&TxByte, FullScale); //модифицировать TxByte записью только необходимых настроек
00002e  462a              MOV      r2,r5
000030  a901              ADD      r1,sp,#4
000032  f104007b          ADD      r0,r4,#0x7b
000036  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL22gyro_full_scale_selectEPhNS_20VGyroFullScaleSelectE ; MPU_9250::TAccGyroMagDriver_LL::gyro_full_scale_select(unsigned char*, MPU_9250::VGyroFullScaleSelect)
;;;221    	 switch (FullScale)
00003a  b1a5              CBZ      r5,|L5.102|
00003c  2d01              CMP      r5,#1
00003e  d00d              BEQ      |L5.92|
000040  2d02              CMP      r5,#2
000042  d006              BEQ      |L5.82|
000044  2d03              CMP      r5,#3
000046  d113              BNE      |L5.112|
;;;222    	 {
;;;223    	   case VGyroFullScaleSelect::_2000_DPS:
;;;224    		     GyroSensitivity = sensitivity_gyro::_3_FS_SEL;
000048  ed9f0a3d          VLDR     s0,|L5.320|
00004c  ed840a20          VSTR     s0,[r4,#0x80]
;;;225    		     break;
000050  e00f              B        |L5.114|
                  |L5.82|
;;;226    	   case VGyroFullScaleSelect::_1000_DPS:
;;;227    		     GyroSensitivity = sensitivity_gyro::_2_FS_SEL;
000052  ed9f0a3c          VLDR     s0,|L5.324|
000056  ed840a20          VSTR     s0,[r4,#0x80]
;;;228    		     break;
00005a  e00a              B        |L5.114|
                  |L5.92|
;;;229    	   case VGyroFullScaleSelect::_500_DPS:
;;;230    		     GyroSensitivity = sensitivity_gyro::_1_FS_SEL;
00005c  ed9f0a3a          VLDR     s0,|L5.328|
000060  ed840a20          VSTR     s0,[r4,#0x80]
;;;231    		     break;
000064  e005              B        |L5.114|
                  |L5.102|
;;;232    	   case VGyroFullScaleSelect::_250_DPS:
;;;233               GyroSensitivity = sensitivity_gyro::_0_FS_SEL;
000066  ed9f0a39          VLDR     s0,|L5.332|
00006a  ed840a20          VSTR     s0,[r4,#0x80]
;;;234               break;
00006e  e000              B        |L5.114|
                  |L5.112|
;;;235    	   default:
;;;236    		     break;
000070  bf00              NOP      
                  |L5.114|
000072  bf00              NOP                            ;225
;;;237    	 }
;;;238    	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
000074  463b              MOV      r3,r7
000076  4642              MOV      r2,r8
000078  a901              ADD      r1,sp,#4
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;239       	 
;;;240    	 //----- Включение возможности выбора полосы пропускания фильтра гироскопа и термодатчика - Fchoice --------------------
;;;241    	 RegAddr = gyro_filter_choise(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000080  2200              MOVS     r2,#0
000082  4611              MOV      r1,r2
000084  f104007b          ADD      r0,r4,#0x7b
000088  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL18gyro_filter_choiseEPhNS_17VGyroFilterChoiseE ; MPU_9250::TAccGyroMagDriver_LL::gyro_filter_choise(unsigned char*, MPU_9250::VGyroFilterChoise)
00008c  4680              MOV      r8,r0
;;;242    	 VGyroFilterChoise FilterChoise = VGyroFilterChoise::_11;
00008e  2600              MOVS     r6,#0
;;;243    
;;;244    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000090  463b              MOV      r3,r7
000092  4642              MOV      r2,r8
000094  a901              ADD      r1,sp,#4
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;245    	 gyro_filter_choise(&TxByte, FilterChoise); //модифицировать TxByte записью только необходимых настроек
00009c  4632              MOV      r2,r6
00009e  a901              ADD      r1,sp,#4
0000a0  f104007b          ADD      r0,r4,#0x7b
0000a4  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL18gyro_filter_choiseEPhNS_17VGyroFilterChoiseE ; MPU_9250::TAccGyroMagDriver_LL::gyro_filter_choise(unsigned char*, MPU_9250::VGyroFilterChoise)
;;;246    	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
0000a8  463b              MOV      r3,r7
0000aa  4642              MOV      r2,r8
0000ac  a901              ADD      r1,sp,#4
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;247    
;;;248    	 //----- Конфигурация полосы пропускания фильтра гироскопа и термодатчика ----------------------------------------------
;;;249    	 RegAddr = filter_gyro_temp_config(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
0000b4  2207              MOVS     r2,#7
0000b6  2100              MOVS     r1,#0
0000b8  f104007b          ADD      r0,r4,#0x7b
0000bc  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23filter_gyro_temp_configEPhNS_21VFilterGyroTempConfigE ; MPU_9250::TAccGyroMagDriver_LL::filter_gyro_temp_config(unsigned char*, MPU_9250::VFilterGyroTempConfig)
0000c0  4680              MOV      r8,r0
;;;250    	 VFilterGyroTempConfig FilterGyroTempConfig = VFilterGyroTempConfig::_G184_2d9_1_T188_1d9;
0000c2  2001              MOVS     r0,#1
0000c4  9000              STR      r0,[sp,#0]
;;;251    	 
;;;252    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
0000c6  463b              MOV      r3,r7
0000c8  4642              MOV      r2,r8
0000ca  a901              ADD      r1,sp,#4
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;253    	 filter_gyro_temp_config(&TxByte, FilterGyroTempConfig); //модифицировать TxByte записью только необходимых настроек
0000d2  f89d2000          LDRB     r2,[sp,#0]
0000d6  a901              ADD      r1,sp,#4
0000d8  f104007b          ADD      r0,r4,#0x7b
0000dc  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23filter_gyro_temp_configEPhNS_21VFilterGyroTempConfigE ; MPU_9250::TAccGyroMagDriver_LL::filter_gyro_temp_config(unsigned char*, MPU_9250::VFilterGyroTempConfig)
;;;254    	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
0000e0  463b              MOV      r3,r7
0000e2  4642              MOV      r2,r8
0000e4  a901              ADD      r1,sp,#4
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;255    	   
;;;256    	 //----- Проверка установленной полосы пропускания фильтра гироскопа и термодатчика ------------------------------------
;;;257    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte	 
0000ec  463b              MOV      r3,r7
0000ee  4642              MOV      r2,r8
0000f0  a901              ADD      r1,sp,#4
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;258    	 
;;;259    	 filter_gyro_temp_read(TxByte, &FilterGyroTempConfig);
0000f8  466a              MOV      r2,sp
0000fa  f89d1004          LDRB     r1,[sp,#4]
0000fe  f104007b          ADD      r0,r4,#0x7b
000102  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL21filter_gyro_temp_readEhPNS_21VFilterGyroTempConfigE ; MPU_9250::TAccGyroMagDriver_LL::filter_gyro_temp_read(unsigned char, MPU_9250::VFilterGyroTempConfig*)
;;;260    	 switch (FilterGyroTempConfig)
000106  f89d0000          LDRB     r0,[sp,#0]
00010a  2808              CMP      r0,#8
00010c  d214              BCS      |L5.312|
00010e  e8dff000          TBB      [pc,r0]
000112  0e05              DCB      0x0e,0x05
000114  09070604          DCB      0x09,0x07,0x06,0x04
000118  080f              DCB      0x08,0x0f
;;;261    	 {
;;;262    	   case VFilterGyroTempConfig::_G10_17d85_1_T10_13d4:
;;;263    	   case VFilterGyroTempConfig::_G184_2d9_1_T188_1d9:
00011a  bf00              NOP      
;;;264    	   case VFilterGyroTempConfig::_G20_9d9_1_T20_8d3:
00011c  bf00              NOP      
;;;265    	   case VFilterGyroTempConfig::_G41_5d9_1_T42_4d8:
00011e  bf00              NOP      
;;;266    	   case VFilterGyroTempConfig::_G5_33d48_1_T5_18d6:
000120  bf00              NOP      
;;;267    	   case VFilterGyroTempConfig::_G92_3d9_1_T98_2d8:
000122  bf00              NOP      
;;;268    		     GyroSampleRate_us = GYRO_1_kHz_SAMPLE_RATE_us;
000124  f44f707a          MOV      r0,#0x3e8
000128  f8c4008c          STR      r0,[r4,#0x8c]
;;;269               break;
00012c  e005              B        |L5.314|
;;;270    	   case VFilterGyroTempConfig::_G250_097_8_T4000_004:
;;;271    	   case VFilterGyroTempConfig::_G3600_0d17_8_T4000_0d04:
00012e  bf00              NOP      
;;;272    		     GyroSampleRate_us = GYRO_8_kHz_SAMPLE_RATE_us;
000130  207d              MOVS     r0,#0x7d
000132  f8c4008c          STR      r0,[r4,#0x8c]
;;;273               break;
000136  e000              B        |L5.314|
                  |L5.312|
;;;274    	   default:
;;;275    		     break;
000138  bf00              NOP      
                  |L5.314|
00013a  bf00              NOP                            ;269
;;;276    	 } 
;;;277       
;;;278    //   //----- Настройка делителя частоты выборки для 100Гц (при частоте выборки 1000Гц)
;;;279    //	 RegAddr = sample_rate_divider(); //получить адрес регистра микросхемы с необходимой настройкой
;;;280    //	 TxByte = 0x09;
;;;281    //	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
;;;282    //   TxByte = 0x00;
;;;283    //	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte	 
;;;284       
;;;285      }
00013c  e8bd81fc          POP      {r2-r8,pc}
;;;286      
                          ENDP

                  |L5.320|
000140  41833333          DCFS     0x41833333 ; 16.399999618530273
                  |L5.324|
000144  42033333          DCFS     0x42033333 ; 32.799999237060547
                  |L5.328|
000148  42830000          DCFS     0x42830000 ; 65.5
                  |L5.332|
00014c  43030000          DCFS     0x43030000 ; 131

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL11count_accelEPKNS_12TRawAxesDataE||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL11count_accelEPKNS_12TRawAxesDataE PROC ; MPU_9250::TAccGyroMagDriver_HL::count_accel(const MPU_9250::TRawAxesData*)
;;;625    
;;;626      void TAccGyroMagDriver_HL::count_accel(const TRawAxesData *DataPtr)
000000  f9b12000          LDRSH    r2,[r1,#0]
;;;627      {
;;;628        Accel.X = static_cast<float>(DataPtr->X) / AccelSensitivity;
000004  ee002a10          VMOV     s0,r2
000008  eef80ac0          VCVT.F32.S32 s1,s0
00000c  f8b02084          LDRH     r2,[r0,#0x84]
000010  ee002a10          VMOV     s0,r2
000014  eeb80a40          VCVT.F32.U32 s0,s0
000018  ee801a80          VDIV.F32 s2,s1,s0
00001c  ed801a28          VSTR     s2,[r0,#0xa0]
;;;629        Accel.Y = static_cast<float>(DataPtr->Y) / AccelSensitivity;
000020  f9b12002          LDRSH    r2,[r1,#2]
000024  ee002a10          VMOV     s0,r2
000028  eef80ac0          VCVT.F32.S32 s1,s0
00002c  f8b02084          LDRH     r2,[r0,#0x84]
000030  ee002a10          VMOV     s0,r2
000034  eeb80a40          VCVT.F32.U32 s0,s0
000038  ee801a80          VDIV.F32 s2,s1,s0
00003c  ed801a29          VSTR     s2,[r0,#0xa4]
;;;630        Accel.Z = static_cast<float>(DataPtr->Z) / AccelSensitivity;
000040  f9b12004          LDRSH    r2,[r1,#4]
000044  ee002a10          VMOV     s0,r2
000048  eef80ac0          VCVT.F32.S32 s1,s0
00004c  f8b02084          LDRH     r2,[r0,#0x84]
000050  ee002a10          VMOV     s0,r2
000054  eeb80a40          VCVT.F32.U32 s0,s0
000058  ee801a80          VDIV.F32 s2,s1,s0
00005c  ed801a2a          VSTR     s2,[r0,#0xa8]
;;;631      }
000060  4770              BX       lr
;;;632    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL11init_driverEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL11init_driverEv PROC ; MPU_9250::TAccGyroMagDriver_HL::init_driver()
;;;57     
;;;58       void TAccGyroMagDriver_HL::init_driver()
000000  b510              PUSH     {r4,lr}
;;;59       {
000002  4604              MOV      r4,r0
;;;60         pin_clk_config();
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _ZN3I2C4TI2C14pin_clk_configEv ; I2C::TI2C::pin_clk_config()
;;;61         i2c_hw_init();
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       _ZN3I2C4TI2C11i2c_hw_initEv ; I2C::TI2C::i2c_hw_init()
;;;62       }
000010  bd10              POP      {r4,pc}
;;;63       
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL12check_id_magEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL12check_id_magEv PROC ; MPU_9250::TAccGyroMagDriver_HL::check_id_mag()
;;;187    
;;;188      bool TAccGyroMagDriver_HL::check_id_mag()
000000  b5f8              PUSH     {r3-r7,lr}
;;;189      {
000002  4604              MOV      r4,r0
;;;190        uint8_t TxByte;
;;;191    	 
;;;192    	 //Для доступа к регистрам магнитометра, необходимо предварительно установить режим Pass-Through
;;;193    	 
;;;194    	 uint8_t RegAddr = mag_device_id(); //получить адрес регистра микросхемы
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  4605              MOV      r5,r0
;;;195    //	 read_single_byte(TAccGyroMagDriver_LL::ProtocolRdOne, &TxByte, RegAddr, 0x06); //считать содержимое регистра микросхемы в TxByte
;;;196    
;;;197    //    RelFour.on();	
;;;198    	 read_single_byte(&TxByte, RegAddr, get_mag_addr()); //считать содержимое регистра микросхемы в TxByte	
00000a  f104007b          ADD      r0,r4,#0x7b
00000e  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL12get_mag_addrEv ; MPU_9250::TAccGyroMagDriver_LL::get_mag_addr() const
000012  4606              MOV      r6,r0
000014  4633              MOV      r3,r6
000016  462a              MOV      r2,r5
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;199    //    RelFour.off();	 
;;;200    	 
;;;201    	 AKM_ID = TxByte;
000020  f89d0000          LDRB     r0,[sp,#0]
000024  f884007f          STRB     r0,[r4,#0x7f]
;;;202    	 return TxByte == WIA;
000028  f894007b          LDRB     r0,[r4,#0x7b]
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  4288              CMP      r0,r1
000032  d101              BNE      |L8.56|
000034  2001              MOVS     r0,#1
                  |L8.54|
;;;203      }
000036  bdf8              POP      {r3-r7,pc}
                  |L8.56|
000038  2000              MOVS     r0,#0                 ;202
00003a  e7fc              B        |L8.54|
;;;204      
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL13count_magnetoEPKNS_12TRawAxesDataE||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL13count_magnetoEPKNS_12TRawAxesDataE PROC ; MPU_9250::TAccGyroMagDriver_HL::count_magneto(const MPU_9250::TRawAxesData*)
;;;639    
;;;640      void TAccGyroMagDriver_HL::count_magneto(const TRawAxesData *DataPtr)
000000  f9b12000          LDRSH    r2,[r1,#0]
;;;641      {
;;;642        Magneto.X = static_cast<float>(DataPtr->X) * MagSensitivity;
000004  ee002a10          VMOV     s0,r2
000008  eeb80ac0          VCVT.F32.S32 s0,s0
00000c  edd00a22          VLDR     s1,[r0,#0x88]
000010  ee200a20          VMUL.F32 s0,s0,s1
000014  ed800a2e          VSTR     s0,[r0,#0xb8]
;;;643        Magneto.Y = static_cast<float>(DataPtr->Y) * MagSensitivity;
000018  f9b12002          LDRSH    r2,[r1,#2]
00001c  ee002a10          VMOV     s0,r2
000020  eeb80ac0          VCVT.F32.S32 s0,s0
000024  edd00a22          VLDR     s1,[r0,#0x88]
000028  ee200a20          VMUL.F32 s0,s0,s1
00002c  ed800a2f          VSTR     s0,[r0,#0xbc]
;;;644        Magneto.Z = static_cast<float>(DataPtr->Z) * MagSensitivity;
000030  f9b12004          LDRSH    r2,[r1,#4]
000034  ee002a10          VMOV     s0,r2
000038  eeb80ac0          VCVT.F32.S32 s0,s0
00003c  edd00a22          VLDR     s1,[r0,#0x88]
000040  ee200a20          VMUL.F32 s0,s0,s1
000044  ed800a30          VSTR     s0,[r0,#0xc0]
;;;645      }
000048  4770              BX       lr
;;;646    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL13get_mag_stateEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL13get_mag_stateEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_mag_state()
;;;453      
;;;454      TMagCheck TAccGyroMagDriver_HL::get_mag_state()
000000  4601              MOV      r1,r0
;;;455      {
;;;456        return MagState;
000002  f8910098          LDRB     r0,[r1,#0x98]
;;;457      }
000006  4770              BX       lr
;;;458      
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_acc_dataEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL16collect_acc_dataEv PROC ; MPU_9250::TAccGyroMagDriver_HL::collect_acc_data()
;;;537    
;;;538      void TAccGyroMagDriver_HL::collect_acc_data()
000000  b5fe              PUSH     {r1-r7,lr}
;;;539      {
000002  4604              MOV      r4,r0
;;;540    #ifndef __DEBUG__
;;;541    	 uint8_t SlaveAddr = get_acc_gyro_addr(_HIGH);
000004  2101              MOVS     r1,#1
000006  f104007b          ADD      r0,r4,#0x7b
00000a  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
00000e  4605              MOV      r5,r0
;;;542    #else
;;;543    	 uint8_t SlaveAddr = get_acc_gyro_addr(_LOW);
;;;544    #endif
;;;545    
;;;546        uint8_t SensorData[ACC_DATA_BYTES]= {0}; //MAX_DATA_BYTES не учитывает магнитометр \
000010  2000              MOVS     r0,#0
000012  9001              STR      r0,[sp,#4]
000014  9002              STR      r0,[sp,#8]
;;;547                                                   !!!Не забывать о доступе к массиву из прерываний
;;;548    	  uint8_t RegAddr = accel_data_x_h(); //получить адрес регистра микросхемы с необходимой настройкой
000016  bf00              NOP      
000018  203b              MOVS     r0,#0x3b
00001a  4606              MOV      r6,r0
;;;549        read_burst(SensorData, ACC_DATA_BYTES, RegAddr, SlaveAddr);
00001c  4633              MOV      r3,r6
00001e  2206              MOVS     r2,#6
000020  a901              ADD      r1,sp,#4
000022  4620              MOV      r0,r4
000024  9500              STR      r5,[sp,#0]
000026  f7fffffe          BL       _ZN3I2C4TI2C10read_burstEPhhhh ; I2C::TI2C::read_burst(unsigned char*, unsigned char, unsigned char, unsigned char)
;;;550           
;;;551        convert_acc_data(SensorData);                                            
00002a  a901              ADD      r1,sp,#4
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL16convert_acc_dataEPh ; MPU_9250::TAccGyroMagDriver_HL::convert_acc_data(unsigned char*)
;;;552    
;;;553    
;;;554      }
000032  bdfe              POP      {r1-r7,pc}
;;;555    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_all_dataEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL16collect_all_dataEv PROC ; MPU_9250::TAccGyroMagDriver_HL::collect_all_data()
;;;519      
;;;520      void TAccGyroMagDriver_HL::collect_all_data()
000000  b570              PUSH     {r4-r6,lr}
;;;521      {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;522    #ifndef __DEBUG__
;;;523    	 uint8_t SlaveAddr = get_acc_gyro_addr(_HIGH);
000006  2101              MOVS     r1,#1
000008  f104007b          ADD      r0,r4,#0x7b
00000c  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
000010  4605              MOV      r5,r0
;;;524    #else
;;;525    	 uint8_t SlaveAddr = get_acc_gyro_addr(_LOW);
;;;526    #endif
;;;527     
;;;528        uint8_t SensorData[MAX_DATA_BYTES]= {0}; //MAX_DATA_BYTES не учитывает магнитометр
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
000016  9003              STR      r0,[sp,#0xc]
000018  9004              STR      r0,[sp,#0x10]
00001a  9005              STR      r0,[sp,#0x14]
;;;529    	                                          //!!!Не забывать о доступе к массиву из прерываний
;;;530    	  uint8_t RegAddr = accel_data_x_h(); //получить адрес регистра микросхемы с необходимой настройкой
00001c  bf00              NOP      
00001e  203b              MOVS     r0,#0x3b
000020  4606              MOV      r6,r0
;;;531    
;;;532    //    RelFour.on();
;;;533        read_burst(SensorData, MAX_DATA_BYTES, RegAddr, SlaveAddr);
000022  4633              MOV      r3,r6
000024  220e              MOVS     r2,#0xe
000026  a902              ADD      r1,sp,#8
000028  4620              MOV      r0,r4
00002a  9500              STR      r5,[sp,#0]
00002c  f7fffffe          BL       _ZN3I2C4TI2C10read_burstEPhhhh ; I2C::TI2C::read_burst(unsigned char*, unsigned char, unsigned char, unsigned char)
;;;534    	 
;;;535        convert_all_data(SensorData);
000030  a902              ADD      r1,sp,#8
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL16convert_all_dataEPh ; MPU_9250::TAccGyroMagDriver_HL::convert_all_data(unsigned char*)
;;;536      }
000038  b006              ADD      sp,sp,#0x18
00003a  bd70              POP      {r4-r6,pc}
;;;537    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_mag_dataEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL16collect_mag_dataEv PROC ; MPU_9250::TAccGyroMagDriver_HL::collect_mag_data()
;;;588      
;;;589      void TAccGyroMagDriver_HL::collect_mag_data()
000000  b5fe              PUSH     {r1-r7,lr}
;;;590      {
000002  4604              MOV      r4,r0
;;;591        uint8_t SlaveAddr = get_mag_addr();
000004  f104007b          ADD      r0,r4,#0x7b
000008  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL12get_mag_addrEv ; MPU_9250::TAccGyroMagDriver_LL::get_mag_addr() const
00000c  4605              MOV      r5,r0
;;;592        uint8_t SensorData[MAX_AXES_NUM * NUM_BYTES_PER_AXIS + 1]= {0}; //MAX_DATA_BYTES не учитывает магнитометр
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
000012  9002              STR      r0,[sp,#8]
;;;593    	                                                                 //!!!Не забывать о доступе к массиву из прерываний
;;;594    																						  //дополнительно к данным считываем регистр с флагом переполнения, который показывает валидность считанных данных
;;;595    	 uint8_t RegAddr = mag_lower_x_data(); //получить адрес регистра микросхемы с необходимой настройкой	 
000014  bf00              NOP      
000016  2003              MOVS     r0,#3
000018  4606              MOV      r6,r0
;;;596    
;;;597    //	 RelFour.on();
;;;598    	 read_burst(SensorData, sizeof SensorData, RegAddr, SlaveAddr);
00001a  4633              MOV      r3,r6
00001c  2207              MOVS     r2,#7
00001e  a901              ADD      r1,sp,#4
000020  4620              MOV      r0,r4
000022  9500              STR      r5,[sp,#0]
000024  f7fffffe          BL       _ZN3I2C4TI2C10read_burstEPhhhh ; I2C::TI2C::read_burst(unsigned char*, unsigned char, unsigned char, unsigned char)
;;;599    //	 RelFour.off();
;;;600    	 convert_mag_data(SensorData);
000028  a901              ADD      r1,sp,#4
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL16convert_mag_dataEPh ; MPU_9250::TAccGyroMagDriver_HL::convert_mag_data(unsigned char*)
;;;601      }
000030  bdfe              POP      {r1-r7,pc}
;;;602    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_acc_dataEPh||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL16convert_acc_dataEPh PROC ; MPU_9250::TAccGyroMagDriver_HL::convert_acc_data(unsigned char*)
;;;573      
;;;574      void TAccGyroMagDriver_HL::convert_acc_data(uint8_t *SensorData)
000000  b5f8              PUSH     {r3-r7,lr}
;;;575      {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;576        //приведение данных с датчика к формату Little-endian
;;;577    //	   uint8_t RD_DATA_SIZE = sizeof (TAccData);
;;;578        
;;;579    	   for (uint8_t DataCtr = 0; DataCtr < sizeof (TAccData) / sizeof(uint16_t) ; ++DataCtr)
000006  2400              MOVS     r4,#0
000008  e00a              B        |L14.32|
                  |L14.10|
;;;580    	   {
;;;581    	     TSensorData RawData;
;;;582    		    RawData.Data = ((uint16_t *)SensorData)[DataCtr];
00000a  f8350014          LDRH     r0,[r5,r4,LSL #1]
00000e  9000              STR      r0,[sp,#0]
;;;583    		    ((uint16_t *)SensorData)[DataCtr] = rev_half_word(RawData);
000010  4630              MOV      r0,r6
000012  9900              LDR      r1,[sp,#0]
000014  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE ; MPU_9250::TAccGyroMagDriver_HL::rev_half_word(MPU_9250::TSensorData)
000018  f8250014          STRH     r0,[r5,r4,LSL #1]
00001c  1c60              ADDS     r0,r4,#1              ;579
00001e  b2c4              UXTB     r4,r0                 ;579
                  |L14.32|
000020  2c03              CMP      r4,#3                 ;579
000022  d3f2              BCC      |L14.10|
;;;584    	   }
;;;585         
;;;586    	   count_accel( (TRawAxesData *)&(((TAccTempGyroData *)SensorData)->AccelX) );
000024  4629              MOV      r1,r5
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL11count_accelEPKNS_12TRawAxesDataE ; MPU_9250::TAccGyroMagDriver_HL::count_accel(const MPU_9250::TRawAxesData*)
;;;587      }
00002c  bdf8              POP      {r3-r7,pc}
;;;588      
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_all_dataEPh||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL16convert_all_dataEPh PROC ; MPU_9250::TAccGyroMagDriver_HL::convert_all_data(unsigned char*)
;;;555    
;;;556      void TAccGyroMagDriver_HL::convert_all_data(uint8_t *SensorData)
000000  b5f8              PUSH     {r3-r7,lr}
;;;557      {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;558        //приведение данных с датчика к формату Little-endian
;;;559    //	   uint8_t RD_DATA_SIZE = sizeof (TReadData);
;;;560        
;;;561    	   for (uint8_t DataCtr = 0; DataCtr < sizeof (TReadData) / sizeof(uint16_t) ; ++DataCtr)
000006  2500              MOVS     r5,#0
000008  e00a              B        |L15.32|
                  |L15.10|
;;;562    	   {
;;;563    	     TSensorData RawData;
;;;564    		    RawData.Data = ((uint16_t *)SensorData)[DataCtr];
00000a  f8340015          LDRH     r0,[r4,r5,LSL #1]
00000e  9000              STR      r0,[sp,#0]
;;;565    		    ((uint16_t *)SensorData)[DataCtr] = rev_half_word(RawData);
000010  4630              MOV      r0,r6
000012  9900              LDR      r1,[sp,#0]
000014  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE ; MPU_9250::TAccGyroMagDriver_HL::rev_half_word(MPU_9250::TSensorData)
000018  f8240015          STRH     r0,[r4,r5,LSL #1]
00001c  1c68              ADDS     r0,r5,#1              ;561
00001e  b2c5              UXTB     r5,r0                 ;561
                  |L15.32|
000020  2d07              CMP      r5,#7                 ;561
000022  d3f2              BCC      |L15.10|
;;;566    	   }
;;;567        
;;;568    	   //преобразование полученных данных
;;;569    	   count_temperature(((TAccTempGyroData *)SensorData)->Temp);
000024  f9b41006          LDRSH    r1,[r4,#6]
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL17count_temperatureEs ; MPU_9250::TAccGyroMagDriver_HL::count_temperature(short)
;;;570    	   count_accel( (TRawAxesData *)&(((TAccTempGyroData *)SensorData)->AccelX) );
00002e  4621              MOV      r1,r4
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL11count_accelEPKNS_12TRawAxesDataE ; MPU_9250::TAccGyroMagDriver_HL::count_accel(const MPU_9250::TRawAxesData*)
;;;571    	   count_gyro( (TRawAxesData *)&(((TAccTempGyroData *)SensorData)->GyroX) );
000036  f1040108          ADD      r1,r4,#8
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL10count_gyroEPKNS_12TRawAxesDataE ; MPU_9250::TAccGyroMagDriver_HL::count_gyro(const MPU_9250::TRawAxesData*)
;;;572      }
000040  bdf8              POP      {r3-r7,pc}
;;;573      
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_mag_dataEPh||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL16convert_mag_dataEPh PROC ; MPU_9250::TAccGyroMagDriver_HL::convert_mag_data(unsigned char*)
;;;602    
;;;603      void TAccGyroMagDriver_HL::convert_mag_data(uint8_t *SensorData) 
000000  b57c              PUSH     {r2-r6,lr}
;;;604      {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;605    	 VStatusFlag BITM;
;;;606    	 mag_mirror_data_bit(((TRawMagData *)SensorData)->ST2, &BITM);
000006  79a9              LDRB     r1,[r5,#6]
000008  aa01              ADD      r2,sp,#4
00000a  f104007b          ADD      r0,r4,#0x7b
00000e  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL19mag_mirror_data_bitEhPNS_11VStatusFlagE ; MPU_9250::TAccGyroMagDriver_LL::mag_mirror_data_bit(unsigned char, MPU_9250::VStatusFlag*)
;;;607    	 
;;;608    	 VStatusFlag HOFL;
;;;609    	 mag_overflow(((TRawMagData *)SensorData)->ST2, &HOFL);
000012  79a9              LDRB     r1,[r5,#6]
000014  466a              MOV      r2,sp
000016  f104007b          ADD      r0,r4,#0x7b
00001a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL12mag_overflowEhPNS_11VStatusFlagE ; MPU_9250::TAccGyroMagDriver_LL::mag_overflow(unsigned char, MPU_9250::VStatusFlag*)
;;;610    	 if (HOFL == VStatusFlag::_NO) //если нет переполнения, т.е. если |X|+|Y|+|Z| < 4912μT (AsahiKASEI AK8963 6.4.3.6. Magnetic Sensor Overflow)
00001e  f89d0000          LDRB     r0,[sp,#0]
000022  b918              CBNZ     r0,|L16.44|
;;;611    	 {
;;;612    	   //данные валидны
;;;613    		count_magneto( (TRawAxesData *)&(((TRawMagData *)SensorData)->MagData) );
000024  4629              MOV      r1,r5
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL13count_magnetoEPKNS_12TRawAxesDataE ; MPU_9250::TAccGyroMagDriver_HL::count_magneto(const MPU_9250::TRawAxesData*)
                  |L16.44|
;;;614    	 }
;;;615    	 else
;;;616    	 {
;;;617    	   //данные не валидны, в выборку не попадают
;;;618    	 }
;;;619      }
00002c  bd7c              POP      {r2-r6,pc}
;;;620    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL17check_id_acc_gyroEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL17check_id_acc_gyroEv PROC ; MPU_9250::TAccGyroMagDriver_HL::check_id_acc_gyro()
;;;171    
;;;172      bool TAccGyroMagDriver_HL::check_id_acc_gyro()
000000  b5f8              PUSH     {r3-r7,lr}
;;;173      {
000002  4604              MOV      r4,r0
;;;174        uint8_t TxByte;
;;;175    	 uint8_t RegAddr = get_who_am_i(); //получить адрес регистра микросхемы
000004  bf00              NOP      
000006  2075              MOVS     r0,#0x75
000008  4605              MOV      r5,r0
;;;176    	 
;;;177    #ifndef __DEBUG__
;;;178    	 uint8_t AccGyroAddr = get_acc_gyro_addr(_HIGH);
00000a  2101              MOVS     r1,#1
00000c  f104007b          ADD      r0,r4,#0x7b
000010  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
000014  4606              MOV      r6,r0
;;;179    #else
;;;180    	 uint8_t AccGyroAddr = get_acc_gyro_addr(_LOW);
;;;181    #endif
;;;182     
;;;183    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000016  4633              MOV      r3,r6
000018  462a              MOV      r2,r5
00001a  4669              MOV      r1,sp
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;184    	 
;;;185    	 return TxByte == WHO_AM_I;
000022  207c              MOVS     r0,#0x7c
000024  5d00              LDRB     r0,[r0,r4]
000026  f89d1000          LDRB     r1,[sp,#0]
00002a  4288              CMP      r0,r1
00002c  d101              BNE      |L17.50|
00002e  2001              MOVS     r0,#1
                  |L17.48|
;;;186      }
000030  bdf8              POP      {r3-r7,pc}
                  |L17.50|
000032  2000              MOVS     r0,#0                 ;185
000034  e7fc              B        |L17.48|
;;;187    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL17count_temperatureEs||, CODE, READONLY, ALIGN=2

                  _ZN8MPU_925020TAccGyroMagDriver_HL17count_temperatureEs PROC ; MPU_9250::TAccGyroMagDriver_HL::count_temperature(short)
;;;620    
;;;621      void TAccGyroMagDriver_HL::count_temperature(const int16_t Data)
000000  f1a10215          SUB      r2,r1,#0x15
;;;622      {
;;;623        Temperature = (Data - temp_mpu_9250::ROOM_TEMP_OFFSET) / temp_mpu_9250::SENSITIVITY + 21; //MPU-9250 Register Map and Descriptions Revision: 1.6
000004  ee002a10          VMOV     s0,r2
000008  eeb80ac0          VCVT.F32.S32 s0,s0
00000c  ed9f1a05          VLDR     s2,|L18.36|
000010  eec00a01          VDIV.F32 s1,s0,s2
000014  eeb30a05          VMOV.F32 s0,#21.00000000
000018  ee300a80          VADD.F32 s0,s1,s0
00001c  ed800a27          VSTR     s0,[r0,#0x9c]
;;;624      }
000020  4770              BX       lr
;;;625    
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
000024  43aa0000          DCFS     0x43aa0000 ; 340

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL3powEhh||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL3powEhh PROC ; MPU_9250::TAccGyroMagDriver_HL::pow(unsigned char, unsigned char)
;;;509    //  
;;;510      uint32_t TAccGyroMagDriver_HL::pow(uint8_t Num, uint8_t Exp)
000000  b530              PUSH     {r4,r5,lr}
;;;511      {
000002  4603              MOV      r3,r0
;;;512        uint32_t Product = 1;
000004  2001              MOVS     r0,#1
;;;513    	 while (Exp--)
000006  e000              B        |L19.10|
                  |L19.8|
;;;514    	 {
;;;515    	   Product *= Num;
000008  4348              MULS     r0,r1,r0
                  |L19.10|
00000a  1e14              SUBS     r4,r2,#0              ;513
00000c  f1a20501          SUB      r5,r2,#1              ;513
000010  b2ea              UXTB     r2,r5                 ;513
000012  d1f9              BNE      |L19.8|
;;;516    	 }
;;;517    	 return Product;
;;;518      }
000014  bd30              POP      {r4,r5,pc}
;;;519      
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL8init_auxEv||, CODE, READONLY, ALIGN=2

                  _ZN8MPU_925020TAccGyroMagDriver_HL8init_auxEv PROC ; MPU_9250::TAccGyroMagDriver_HL::init_aux()
;;;63       
;;;64       void TAccGyroMagDriver_HL::init_aux()
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;65       {
000004  b08b              SUB      sp,sp,#0x2c
000006  4604              MOV      r4,r0
;;;66     	  HW.INT.en_clk( HW.INT.ClkPortMask ); //включение тактирования GPIO для вывода с INT, если не включено
000008  e9d40116          LDRD     r0,r1,[r4,#0x58]
00000c  4788              BLX      r1
;;;67     	  LL_APB2_GRP1_EnableClock( LL_APB2_GRP1_PERIPH_SYSCFG ); //включение тактирования SYSCFG, если не включено
00000e  2001              MOVS     r0,#1
000010  4951              LDR      r1,|L20.344|
000012  6e09              LDR      r1,[r1,#0x60]
000014  4301              ORRS     r1,r1,r0
000016  4a50              LDR      r2,|L20.344|
000018  6611              STR      r1,[r2,#0x60]
00001a  4611              MOV      r1,r2
00001c  6e09              LDR      r1,[r1,#0x60]
00001e  4001              ANDS     r1,r1,r0
000020  9101              STR      r1,[sp,#4]
000022  bf00              NOP      
000024  bf00              NOP      
;;;68         
;;;69         LL_GPIO_InitTypeDef GPIO_InitStruct; //сконфигурировать вывод порта как вход (п. 11.3.8 17-Jan-2017 Rev.8)
;;;70     	  do
000026  bf00              NOP      
                  |L20.40|
;;;71     	  {
;;;72     	    GPIO_InitStruct.Pin  = HW.INT.Nbr;
000028  6d60              LDR      r0,[r4,#0x54]
00002a  9005              STR      r0,[sp,#0x14]
;;;73     	    GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
00002c  2000              MOVS     r0,#0
00002e  9006              STR      r0,[sp,#0x18]
;;;74     	    GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
000030  9009              STR      r0,[sp,#0x24]
;;;75     	  } while ( SUCCESS != LL_GPIO_Init( HW.INT.Gpio, &GPIO_InitStruct ) );
000032  a905              ADD      r1,sp,#0x14
000034  6d20              LDR      r0,[r4,#0x50]
000036  f7fffffe          BL       LL_GPIO_Init
00003a  2800              CMP      r0,#0
00003c  d1f4              BNE      |L20.40|
;;;76     	  
;;;77     	  /*
;;;78     	   * System configuration controller (SYSCFG)
;;;79     	   * В том числе управляет соединением линии внешнего прерывания EXTI к GPIO
;;;80     	   */
;;;81     	  if ( HW.Exti.SysCfgPort != LL_SYSCFG_GetEXTISource( HW.Exti.SysCfgLine ) ) //проверка соединения линии внешнего прерывания EXTI к порту
00003e  6e60              LDR      r0,[r4,#0x64]
000040  4946              LDR      r1,|L20.348|
000042  b2c2              UXTB     r2,r0
000044  f8511022          LDR      r1,[r1,r2,LSL #2]
000048  ea014110          AND      r1,r1,r0,LSR #16
00004c  0c02              LSRS     r2,r0,#16
00004e  fa92f2a2          RBIT     r2,r2
000052  fab2f282          CLZ      r2,r2
000056  40d1              LSRS     r1,r1,r2
000058  6e20              LDR      r0,[r4,#0x60]
00005a  4281              CMP      r1,r0
00005c  d015              BEQ      |L20.138|
;;;82     	  {
;;;83     	    LL_SYSCFG_SetEXTISource(HW.Exti.SysCfgPort, HW.Exti.SysCfgLine); //настроить EXTI в SYSCFG
00005e  e9d41018          LDRD     r1,r0,[r4,#0x60]
000062  4a3e              LDR      r2,|L20.348|
000064  b2c3              UXTB     r3,r0
000066  f8522023          LDR      r2,[r2,r3,LSL #2]
00006a  ea224210          BIC      r2,r2,r0,LSR #16
00006e  0c03              LSRS     r3,r0,#16
000070  fa93f3a3          RBIT     r3,r3
000074  fab3f383          CLZ      r3,r3
000078  fa01f303          LSL      r3,r1,r3
00007c  431a              ORRS     r2,r2,r3
00007e  4b37              LDR      r3,|L20.348|
000080  b2c5              UXTB     r5,r0
000082  f8432025          STR      r2,[r3,r5,LSL #2]
000086  bf00              NOP      
000088  bf00              NOP      
                  |L20.138|
;;;84     	  }
;;;85     	  /*
;;;86     	  * Cконфигурировать линию как источник прерывания:
;;;87     	  *   сконфигурировать бит маски в регистре EXTI_IMR - по умолч. все линии замаскированы
;;;88     	  *	  сконфигурировать биты Trigger Selection (EXTI_RTSR и EXTI_FTSR)
;;;89     	  *	  сконфигурировать биты разрешения и маски, которые управляют NVIC IRQ каналом, отображенным на EXTI, так чтобы прерываниие с одной из линий EXTI могло быть корректно подтверждено
;;;90          */
;;;91     	  LL_EXTI_InitTypeDef EXTI_InitStruct;
;;;92     	  do
00008a  bf00              NOP      
                  |L20.140|
;;;93     	  {
;;;94     	    EXTI_InitStruct.Line_0_31   = HW.Exti.Line;
00008c  6ea0              LDR      r0,[r4,#0x68]
00008e  9002              STR      r0,[sp,#8]
;;;95     	    EXTI_InitStruct.LineCommand = ENABLE; //новое состояние выбранных EXTI линий
000090  2001              MOVS     r0,#1
000092  f88d0010          STRB     r0,[sp,#0x10]
;;;96     	    EXTI_InitStruct.Mode        = HW.Exti.Mode;
000096  f894006c          LDRB     r0,[r4,#0x6c]
00009a  f88d0011          STRB     r0,[sp,#0x11]
;;;97     	    EXTI_InitStruct.Trigger     = HW.Exti.Trigger;
00009e  f8940070          LDRB     r0,[r4,#0x70]
0000a2  f88d0012          STRB     r0,[sp,#0x12]
;;;98     	  } while (SUCCESS != LL_EXTI_Init(&EXTI_InitStruct));
0000a6  a802              ADD      r0,sp,#8
0000a8  f7fffffe          BL       LL_EXTI_Init
0000ac  2800              CMP      r0,#0
0000ae  d1ed              BNE      |L20.140|
;;;99     
;;;100        // Настройка NVIC
;;;101        NVIC_SetPriority( HW.Exti.IRQ, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 3, 0) ); //обработчик вызывает API функцию RTOS => приоритет д.б. логически ниже,
0000b0  f9941074          LDRSB    r1,[r4,#0x74]
0000b4  4b2a              LDR      r3,|L20.352|
0000b6  681b              LDR      r3,[r3,#0]
0000b8  f3c32002          UBFX     r0,r3,#8,#3
0000bc  2503              MOVS     r5,#3
0000be  2600              MOVS     r6,#0
0000c0  4603              MOV      r3,r0
0000c2  f1c30807          RSB      r8,r3,#7
0000c6  f1b80f04          CMP      r8,#4
0000ca  d902              BLS      |L20.210|
0000cc  f04f0804          MOV      r8,#4
0000d0  e001              B        |L20.214|
                  |L20.210|
0000d2  f1c30807          RSB      r8,r3,#7
                  |L20.214|
0000d6  46c4              MOV      r12,r8
0000d8  f1030804          ADD      r8,r3,#4
0000dc  f1b80f07          CMP      r8,#7
0000e0  d202              BCS      |L20.232|
0000e2  f04f0800          MOV      r8,#0
0000e6  e001              B        |L20.236|
                  |L20.232|
0000e8  f1a30803          SUB      r8,r3,#3
                  |L20.236|
0000ec  4647              MOV      r7,r8
0000ee  f04f0801          MOV      r8,#1
0000f2  fa08f80c          LSL      r8,r8,r12
0000f6  f1a80801          SUB      r8,r8,#1
0000fa  ea080805          AND      r8,r8,r5
0000fe  fa08f807          LSL      r8,r8,r7
000102  f04f0901          MOV      r9,#1
000106  fa09f907          LSL      r9,r9,r7
00010a  f1a90901          SUB      r9,r9,#1
00010e  ea090906          AND      r9,r9,r6
000112  ea480209          ORR      r2,r8,r9
000116  bf00              NOP      
000118  2900              CMP      r1,#0
00011a  da08              BGE      |L20.302|
00011c  0710              LSLS     r0,r2,#28
00011e  0e05              LSRS     r5,r0,#24
000120  480f              LDR      r0,|L20.352|
000122  300c              ADDS     r0,r0,#0xc
000124  f001030f          AND      r3,r1,#0xf
000128  1f1b              SUBS     r3,r3,#4
00012a  54c5              STRB     r5,[r0,r3]
00012c  e003              B        |L20.310|
                  |L20.302|
00012e  0710              LSLS     r0,r2,#28
000130  0e03              LSRS     r3,r0,#24
000132  480c              LDR      r0,|L20.356|
000134  5443              STRB     r3,[r0,r1]
                  |L20.310|
000136  bf00              NOP      
;;;102    	                                                                                          //но численно больше, установленного в макросе configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  
;;;103    	                                                                                          //3 - максимальный уровень приоритета в программе ввиду важности своевременной обработки INT'a от микросхемы
;;;104        NVIC_EnableIRQ(HW.Exti.IRQ);
000138  f9940074          LDRSB    r0,[r4,#0x74]
00013c  f000021f          AND      r2,r0,#0x1f
000140  2101              MOVS     r1,#1
000142  4091              LSLS     r1,r1,r2
000144  0942              LSRS     r2,r0,#5
000146  0092              LSLS     r2,r2,#2
000148  f10222e0          ADD      r2,r2,#0xe000e000
00014c  f8c21100          STR      r1,[r2,#0x100]
000150  bf00              NOP      
;;;105      }
000152  b00b              ADD      sp,sp,#0x2c
000154  e8bd83f0          POP      {r4-r9,pc}
;;;106    	 
                          ENDP

                  |L20.344|
                          DCD      0x40021000
                  |L20.348|
                          DCD      0x40010008
                  |L20.352|
                          DCD      0xe000ed0c
                  |L20.356|
                          DCD      0xe000e400

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL9init_chipEv||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL9init_chipEv PROC ; MPU_9250::TAccGyroMagDriver_HL::init_chip()
;;;106    	 
;;;107      void TAccGyroMagDriver_HL::init_chip()
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;108      {
000004  4604              MOV      r4,r0
;;;109    #ifndef __DEBUG__
;;;110    	 uint8_t AccGyroAddr = get_acc_gyro_addr(_HIGH);
000006  2101              MOVS     r1,#1
000008  f104007b          ADD      r0,r4,#0x7b
00000c  f7fffffe          BL       _ZNK8MPU_925020TAccGyroMagDriver_LL17get_acc_gyro_addrENS_14TLogicLevelAD0E ; MPU_9250::TAccGyroMagDriver_LL::get_acc_gyro_addr(MPU_9250::TLogicLevelAD0) const
000010  4682              MOV      r10,r0
;;;111    #else
;;;112    	 uint8_t AccGyroAddr = get_acc_gyro_addr(_LOW);
;;;113    #endif
;;;114    	 
;;;115        //----- Настройка вывода INT микросхемы ------------------------------------------------------------
;;;116    	 uint8_t TxByte;
;;;117    	 uint8_t RegAddr = int_logic_level(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000012  2200              MOVS     r2,#0
000014  4611              MOV      r1,r2
000016  f104007b          ADD      r0,r4,#0x7b
00001a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL15int_logic_levelEPhNS_14VLogicLevelINTE ; MPU_9250::TAccGyroMagDriver_LL::int_logic_level(unsigned char*, MPU_9250::VLogicLevelINT)
00001e  4683              MOV      r11,r0
;;;118    	 VLogicLevelINT LogicLevelINT = VLogicLevelINT::_ACTIVE_HIGH;
000020  2500              MOVS     r5,#0
;;;119    	 VPinConfigINT PinConfigINT = VPinConfigINT::_PUSH_PULL;
000022  2600              MOVS     r6,#0
;;;120    	 VLatchINT LatchINT = VLatchINT::_PULSE_50us;
000024  2700              MOVS     r7,#0
;;;121    
;;;122    //    RelFour.on();
;;;123    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000026  4653              MOV      r3,r10
000028  465a              MOV      r2,r11
00002a  4669              MOV      r1,sp
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;124    //    RelFour.off(); 
;;;125    
;;;126    	 int_logic_level(&TxByte, LogicLevelINT); //модифицировать TxByte записью только необходимых настроек
000032  462a              MOV      r2,r5
000034  4669              MOV      r1,sp
000036  f104007b          ADD      r0,r4,#0x7b
00003a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL15int_logic_levelEPhNS_14VLogicLevelINTE ; MPU_9250::TAccGyroMagDriver_LL::int_logic_level(unsigned char*, MPU_9250::VLogicLevelINT)
;;;127    	 int_pin_config(&TxByte, PinConfigINT); //модифицировать TxByte записью только необходимых настроек
00003e  4632              MOV      r2,r6
000040  4669              MOV      r1,sp
000042  f104007b          ADD      r0,r4,#0x7b
000046  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL14int_pin_configEPhNS_13VPinConfigINTE ; MPU_9250::TAccGyroMagDriver_LL::int_pin_config(unsigned char*, MPU_9250::VPinConfigINT)
;;;128    	 int_latch_ctrl(&TxByte, LatchINT); //модифицировать TxByte записью только необходимых настроек
00004a  463a              MOV      r2,r7
00004c  4669              MOV      r1,sp
00004e  f104007b          ADD      r0,r4,#0x7b
000052  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL14int_latch_ctrlEPhNS_9VLatchINTE ; MPU_9250::TAccGyroMagDriver_LL::int_latch_ctrl(unsigned char*, MPU_9250::VLatchINT)
;;;129    
;;;130    //	 RelFour.on();
;;;131    	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему	 
000056  4653              MOV      r3,r10
000058  465a              MOV      r2,r11
00005a  4669              MOV      r1,sp
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;132    //	 RelFour.off();
;;;133    
;;;134        //----- Настройка источника прерывания, выдаваемого на вывод INT -----------------------------------
;;;135    	 RegAddr = raw_data_ready_int_ctrl(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000062  2200              MOVS     r2,#0
000064  4611              MOV      r1,r2
000066  f104007b          ADD      r0,r4,#0x7b
00006a  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23raw_data_ready_int_ctrlEPhNS_6VEnDisE ; MPU_9250::TAccGyroMagDriver_LL::raw_data_ready_int_ctrl(unsigned char*, MPU_9250::VEnDis)
00006e  4683              MOV      r11,r0
;;;136    	 VEnDis DataReadyINT = VEnDis::_ENABLE;
000070  f04f0801          MOV      r8,#1
;;;137    
;;;138    //    RelFour.on();
;;;139    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
000074  4653              MOV      r3,r10
000076  465a              MOV      r2,r11
000078  4669              MOV      r1,sp
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;140    //    RelFour.off(); 
;;;141    	 
;;;142    	 raw_data_ready_int_ctrl(&TxByte, DataReadyINT); //модифицировать TxByte записью только необходимых настроек
000080  4642              MOV      r2,r8
000082  4669              MOV      r1,sp
000084  f104007b          ADD      r0,r4,#0x7b
000088  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL23raw_data_ready_int_ctrlEPhNS_6VEnDisE ; MPU_9250::TAccGyroMagDriver_LL::raw_data_ready_int_ctrl(unsigned char*, MPU_9250::VEnDis)
;;;143    //	 RelFour.on();
;;;144    	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
00008c  4653              MOV      r3,r10
00008e  465a              MOV      r2,r11
000090  4669              MOV      r1,sp
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;145    //	 RelFour.off();
;;;146        //----- Настройка режима I2C Master микросхемы -----------------------------------------------------
;;;147    	 RegAddr = i2c_master_if_module_ctrl(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
000098  2200              MOVS     r2,#0
00009a  4611              MOV      r1,r2
00009c  f104007b          ADD      r0,r4,#0x7b
0000a0  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL25i2c_master_if_module_ctrlEPhNS_14VI2CMasterCtrlE ; MPU_9250::TAccGyroMagDriver_LL::i2c_master_if_module_ctrl(unsigned char*, MPU_9250::VI2CMasterCtrl)
0000a4  4683              MOV      r11,r0
;;;148    	 VI2CMasterCtrl I2CMasterCtrl = VI2CMasterCtrl::_DISABLE_I2C_MASTER_MODULE; //выводы AUX_DA и AUX_SCL логически управляются \
0000a6  46a9              MOV      r9,r5
;;;149                                                                                     выводами  SDA/SDI и SCL/ SCL																											
;;;150    //	 RelFour.on();
;;;151    	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
0000a8  4653              MOV      r3,r10
0000aa  465a              MOV      r2,r11
0000ac  4669              MOV      r1,sp
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       _ZN3I2C4TI2C16read_single_byteEPhhh ; I2C::TI2C::read_single_byte(unsigned char*, unsigned char, unsigned char)
;;;152    //	 RelFour.off();
;;;153    	 i2c_master_if_module_ctrl(&TxByte, I2CMasterCtrl); //модифицировать TxByte записью только необходимых настроек
0000b4  464a              MOV      r2,r9
0000b6  4669              MOV      r1,sp
0000b8  f104007b          ADD      r0,r4,#0x7b
0000bc  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LL25i2c_master_if_module_ctrlEPhNS_14VI2CMasterCtrlE ; MPU_9250::TAccGyroMagDriver_LL::i2c_master_if_module_ctrl(unsigned char*, MPU_9250::VI2CMasterCtrl)
;;;154    	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
0000c0  4653              MOV      r3,r10
0000c2  465a              MOV      r2,r11
0000c4  4669              MOV      r1,sp
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       _ZN3I2C4TI2C17write_single_byteEPhhh ; I2C::TI2C::write_single_byte(unsigned char*, unsigned char, unsigned char)
;;;155    	 
;;;156        //----- Настройка Pass-Through Mode микросхемы -----------------------------------------------------
;;;157        //----- Позволяет пробросить I2C микроконтроллера к магнитометру -----------------------------------
;;;158    //	 RegAddr = i2c_master_pins_ctrl(nullptr); //получить адрес регистра микросхемы с необходимой настройкой
;;;159    //	 VEnDis I2CBypassCtrl = VEnDis::_ENABLE; //включить проброс выводов I2C к магнитометру
;;;160    ////	 LatchINT = VLatchINT::_LEVEL_HELD_UNTIL_CLR; 
;;;161    //	 
;;;162    //	 read_single_byte(&TxByte, RegAddr, AccGyroAddr); //считать содержимое регистра микросхемы в TxByte
;;;163    //	 i2c_master_pins_ctrl(&TxByte, I2CBypassCtrl); //модифицировать TxByte записью только необходимых настроек
;;;164    ////	 int_latch_ctrl(&TxByte, LatchINT);
;;;165    //	 write_single_byte(&TxByte, RegAddr, AccGyroAddr); //записать модифицированный TxByte в микросхему
;;;166    	 
;;;167    	 config_gyro();
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL11config_gyroEv ; MPU_9250::TAccGyroMagDriver_HL::config_gyro()
;;;168    	 config_acc();
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HL10config_accEv ; MPU_9250::TAccGyroMagDriver_HL::config_acc()
;;;169    //	 config_mag();
;;;170      }
0000d8  e8bd8ff8          POP      {r3-r11,pc}
;;;171    
                          ENDP


                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HLC1ERK7TI2C_HW||, CODE, READONLY, ALIGN=2

                  _ZN8MPU_925020TAccGyroMagDriver_HLC2ERK7TI2C_HW                  ; Alternate entry point ; MPU_9250::TAccGyroMagDriver_HL::TAccGyroMagDriver_HL__sub_object(const TI2C_HW&)
                  _ZN8MPU_925020TAccGyroMagDriver_HLC1ERK7TI2C_HW PROC ; MPU_9250::TAccGyroMagDriver_HL::TAccGyroMagDriver_HL(const TI2C_HW&)
;;;31     //  TAccGyroMagDriver_HL::TAccGyroMagDriver_HL( I2C_TypeDef *I2Cx ) 
;;;32       TAccGyroMagDriver_HL::TAccGyroMagDriver_HL( const TI2C_HW &_I2C_HW ) 
;;;33       : 
;;;34       I2C::TI2C
;;;35       ( 
;;;36        _I2C_HW, 
;;;37        I2C::TMode::_MASTER, 
;;;38     	 I2C::TRate::_FAST, 
;;;39     	 I2C::TAddressing::_7_BIT 
;;;40       ), //настройки, по которым будет работать I2C драйвер
;;;41       SampleCount(0),
;;;42       MagWorkFlag(false),
;;;43       GyroSensitivity(sensitivity_gyro::_3_FS_SEL),
;;;44       AccelSensitivity(sensitivity_accel::_3_FS_SEL),
;;;45       MagSensitivity(sensitivity_mag::_16_BIT_SENS),
;;;46       GyroSampleRate_us(),
;;;47       AccelSampleRate_us(),
;;;48       MagSampleRate_us(MAG_MODE2_RATE_us)
;;;49       {
;;;50     
;;;51       }
;;;52       
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  461a              MOV      r2,r3
00000c  4629              MOV      r1,r5
00000e  9000              STR      r0,[sp,#0]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _ZN3I2C4TI2CC1ERK7TI2C_HWNS_5TModeENS_5TRateENS_11TAddressingE ; I2C::TI2C::TI2C(const TI2C_HW&, I2C::TMode, I2C::TRate, I2C::TAddressing)
000016  4604              MOV      r4,r0
000018  f104007b          ADD      r0,r4,#0x7b
00001c  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LLC1Ev ; MPU_9250::TAccGyroMagDriver_LL::TAccGyroMagDriver_LL()
000020  f1a0047b          SUB      r4,r0,#0x7b
000024  2000              MOVS     r0,#0
000026  347c              ADDS     r4,r4,#0x7c
000028  7060              STRB     r0,[r4,#1]
00002a  70a0              STRB     r0,[r4,#2]
00002c  ed9f0a09          VLDR     s0,|L22.84|
000030  ed840a01          VSTR     s0,[r4,#4]
000034  f44f6000          MOV      r0,#0x800
000038  8120              STRH     r0,[r4,#8]
00003a  ed9f0a07          VLDR     s0,|L22.88|
00003e  ed840a03          VSTR     s0,[r4,#0xc]
000042  2000              MOVS     r0,#0
000044  6120              STR      r0,[r4,#0x10]
000046  6160              STR      r0,[r4,#0x14]
000048  f2427010          MOV      r0,#0x2710
00004c  61a0              STR      r0,[r4,#0x18]
00004e  3c7c              SUBS     r4,r4,#0x7c
000050  4620              MOV      r0,r4
000052  bd38              POP      {r3-r5,pc}
                          ENDP

                  |L22.84|
000054  41833333          DCFS     0x41833333 ; 16.399999618530273
                  |L22.88|
000058  3e19999a          DCFS     0x3e19999a ; 0.15000000596046448

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HLD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HLD2Ev                  ; Alternate entry point ; MPU_9250::TAccGyroMagDriver_HL::~TAccGyroMagDriver_HL__sub_object()
                  _ZN8MPU_925020TAccGyroMagDriver_HLD1Ev PROC ; MPU_9250::TAccGyroMagDriver_HL::~TAccGyroMagDriver_HL()
;;;52       
;;;53       TAccGyroMagDriver_HL::~TAccGyroMagDriver_HL()
;;;54       {
;;;55       
;;;56       }
;;;57     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  f104007b          ADD      r0,r4,#0x7b
000008  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_LLD1Ev ; MPU_9250::TAccGyroMagDriver_LL::~TAccGyroMagDriver_LL()
00000c  f1a0047b          SUB      r4,r0,#0x7b
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _ZN3I2C4TI2CD1Ev ; I2C::TI2C::~TI2C()
000016  4604              MOV      r4,r0
000018  4620              MOV      r0,r4
00001a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL12get_acc_dataEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL12get_acc_dataEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_acc_data() const
;;;646    
;;;647      const TModel::TAccelData *TAccGyroMagDriver_HL::get_acc_data() const
000000  4601              MOV      r1,r0
;;;648      {
;;;649        return &Accel;
000002  f10100a0          ADD      r0,r1,#0xa0
;;;650      }
000006  4770              BX       lr
;;;651    
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL13get_gyro_dataEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL13get_gyro_dataEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_gyro_data() const
;;;651    
;;;652      const TGyroData *TAccGyroMagDriver_HL::get_gyro_data() const
000000  4601              MOV      r1,r0
;;;653      {
;;;654        return &Gyro;
000002  f10100ac          ADD      r0,r1,#0xac
;;;655      }
000006  4770              BX       lr
;;;656    
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL15get_temperatureEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL15get_temperatureEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_temperature() const
;;;661    
;;;662      float TAccGyroMagDriver_HL::get_temperature() const
000000  ed900a27          VLDR     s0,[r0,#0x9c]
;;;663      {
;;;664        return Temperature;
;;;665      }
000004  4770              BX       lr
;;;666    
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL16get_magneto_dataEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL16get_magneto_dataEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_magneto_data() const
;;;656    
;;;657      const TMagData *TAccGyroMagDriver_HL::get_magneto_data() const
000000  4601              MOV      r1,r0
;;;658      {
;;;659        return &Magneto;
000002  f10100b8          ADD      r0,r1,#0xb8
;;;660      }
000006  4770              BX       lr
;;;661    
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL19get_mag_sample_rateEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL19get_mag_sample_rateEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_mag_sample_rate() const
;;;676    
;;;677      uint32_t TAccGyroMagDriver_HL::get_mag_sample_rate() const
000000  4601              MOV      r1,r0
;;;678      {
;;;679        return MagSampleRate_us;
000002  f8d10094          LDR      r0,[r1,#0x94]
;;;680      }
000006  4770              BX       lr
;;;681    }
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL20get_gyro_sample_rateEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL20get_gyro_sample_rateEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_gyro_sample_rate() const
;;;666    
;;;667      uint32_t TAccGyroMagDriver_HL::get_gyro_sample_rate() const
000000  4601              MOV      r1,r0
;;;668      {
;;;669        return GyroSampleRate_us;
000002  f8d1008c          LDR      r0,[r1,#0x8c]
;;;670      }
000006  4770              BX       lr
;;;671    
                          ENDP


                          AREA ||i._ZNK8MPU_925020TAccGyroMagDriver_HL21get_accel_sample_rateEv||, CODE, READONLY, ALIGN=1

                  _ZNK8MPU_925020TAccGyroMagDriver_HL21get_accel_sample_rateEv PROC ; MPU_9250::TAccGyroMagDriver_HL::get_accel_sample_rate() const
;;;671    
;;;672      uint32_t TAccGyroMagDriver_HL::get_accel_sample_rate() const
000000  4601              MOV      r1,r0
;;;673      {
;;;674        return AccelSampleRate_us;
000002  f8d10090          LDR      r0,[r1,#0x90]
;;;675      }
000006  4770              BX       lr
;;;676    
                          ENDP


                          AREA ||i.__sti___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c||, CODE, READONLY, ALIGN=2

                  __sti___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c PROC
000000  b510              PUSH     {r4,lr}
000002  4905              LDR      r1,|L31.24|
000004  4805              LDR      r0,|L31.28|
000006  f7fffffe          BL       _ZN8MPU_925020TAccGyroMagDriver_HLC1ERK7TI2C_HW ; MPU_9250::TAccGyroMagDriver_HL::TAccGyroMagDriver_HL(const TI2C_HW&)
00000a  4604              MOV      r4,r0
00000c  4a04              LDR      r2,|L31.32|
00000e  4905              LDR      r1,|L31.36|
000010  f7fffffe          BL       __aeabi_atexit
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      I2C_HW
                  |L31.28|
                          DCD      AccMagGyro
                  |L31.32|
                          DCD      __dso_handle
                  |L31.36|
                          DCD      _ZN8MPU_925020TAccGyroMagDriver_HLD1Ev ; MPU_9250::TAccGyroMagDriver_HL::~TAccGyroMagDriver_HL()

                          AREA ||.ARM.exidx||, LINKORDER=||i.EXTI15_10_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.EXTI15_10_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HLC1ERK7TI2C_HW||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HLC1ERK7TI2C_HW||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HLD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HLD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL12get_acc_dataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL12get_acc_dataEv||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL13get_gyro_dataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL13get_gyro_dataEv||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL16get_magneto_dataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL16get_magneto_dataEv||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL15get_temperatureEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL15get_temperatureEv||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL20get_gyro_sample_rateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL20get_gyro_sample_rateEv||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL21get_accel_sample_rateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL21get_accel_sample_rateEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZNK8MPU_925020TAccGyroMagDriver_HL19get_mag_sample_rateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK8MPU_925020TAccGyroMagDriver_HL19get_mag_sample_rateEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL13get_mag_stateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL13get_mag_stateEv||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL11init_driverEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL11init_driverEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL8init_auxEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL8init_auxEv||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL10config_accEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL10config_accEv||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL11config_gyroEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL11config_gyroEv||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL9init_chipEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL9init_chipEv||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL17check_id_acc_gyroEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL17check_id_acc_gyroEv||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL10count_gyroEPKNS_12TRawAxesDataE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL10count_gyroEPKNS_12TRawAxesDataE||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL11count_accelEPKNS_12TRawAxesDataE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL11count_accelEPKNS_12TRawAxesDataE||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL17count_temperatureEs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL17count_temperatureEs||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_all_dataEPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_all_dataEPh||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_all_dataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_all_dataEv||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_acc_dataEPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_acc_dataEPh||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_acc_dataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_acc_dataEv||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL13count_magnetoEPKNS_12TRawAxesDataE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL13count_magnetoEPKNS_12TRawAxesDataE||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_mag_dataEPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL16convert_mag_dataEPh||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_mag_dataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL16collect_mag_dataEv||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL12check_id_magEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL12check_id_magEv||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL10config_magEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL10config_magEv||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL3powEhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL3powEhh||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i.__sti___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  AccMagGyro
                          %        208

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _ZN8MPU_92505IntHwE ; MPU_9250::IntHw
                          DCD      0x48000400
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00001000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x000f0003
                          DCD      0x00001000
                          DCD      0x00000000
                          DCD      0x00000001
00002c  28000000          DCB      0x28,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  Int1HigherPriorityTaskWoken
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c

                          AREA ||i._ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE||, COMGROUP=_ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE, CODE, READONLY, ALIGN=1

                  _ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE PROC ; MPU_9250::TAccGyroMagDriver_HL::rev_half_word(MPU_9250::TSensorData)
;;;166    	  	 
;;;167        uint16_t rev_half_word(TSensorData Src){return (Src.HighByte << 8) + Src.LowByte;} //обмен байтами в полуслове
000000  b503              PUSH     {r0,r1,lr}
000002  4602              MOV      r2,r0
000004  f89d0005          LDRB     r0,[sp,#5]
000008  f89d1004          LDRB     r1,[sp,#4]
00000c  eb002001          ADD      r0,r0,r1,LSL #8
000010  b280              UXTH     r0,r0
000012  bd0c              POP      {r2,r3,pc}
;;;168    	  uint32_t pow(uint8_t Num, uint8_t Exp);
                          ENDP


                          AREA ||area_number.198||, COMGROUP=_ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE, LINKORDER=||i._ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.198||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8MPU_925020TAccGyroMagDriver_HL13rev_half_wordENS_11TSensorDataE||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "Source\\Ext_Dev\\src\\MPU-9250_acc_gyro_mag_driver_hl.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c___ZN57_INTERNAL_35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c7__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c___ZN57_INTERNAL_35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c7__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c___ZN57_INTERNAL_35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c7__REVSHEi|
#line 402
|__asm___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c___ZN57_INTERNAL_35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c7__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c___ZN57_INTERNAL_35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c5__RRXEj|
#line 587
|__asm___35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c___ZN57_INTERNAL_35_MPU_9250_acc_gyro_mag_driver_hl_cpp_f9f9292c5__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
