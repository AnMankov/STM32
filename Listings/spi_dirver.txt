; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\spi_dirver.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi_dirver.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I.\Source\Ext_Dev\inc\AT45 -I.\Objects -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\spi_dirver.crf Source\MCU_Drivers\src\SPI_dirver.cpp]
                          THUMB

                          AREA ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC2EP11DMA_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC2EP11DMA_TypeDef PROC ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC2(DMA_TypeDef*)
;;;2047     */
;;;2048   __STATIC_INLINE void LL_DMA_ClearFlag_TC2(DMA_TypeDef *DMAx)
000000  2120              MOVS     r1,#0x20
;;;2049   {
;;;2050     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF2);
000002  6041              STR      r1,[r0,#4]
;;;2051   }
000004  4770              BX       lr
;;;2052   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC3EP11DMA_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC3EP11DMA_TypeDef PROC ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC3(DMA_TypeDef*)
;;;2058     */
;;;2059   __STATIC_INLINE void LL_DMA_ClearFlag_TC3(DMA_TypeDef *DMAx)
000000  f44f7100          MOV      r1,#0x200
;;;2060   {
;;;2061     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF3);
000004  6041              STR      r1,[r0,#4]
;;;2062   }
000006  4770              BX       lr
;;;2063   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC4EP11DMA_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC4EP11DMA_TypeDef PROC ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC4(DMA_TypeDef*)
;;;2069     */
;;;2070   __STATIC_INLINE void LL_DMA_ClearFlag_TC4(DMA_TypeDef *DMAx)
000000  f44f5100          MOV      r1,#0x2000
;;;2071   {
;;;2072     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF4);
000004  6041              STR      r1,[r0,#4]
;;;2073   }
000006  4770              BX       lr
;;;2074   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC5EP11DMA_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC5EP11DMA_TypeDef PROC ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC5(DMA_TypeDef*)
;;;2080     */
;;;2081   __STATIC_INLINE void LL_DMA_ClearFlag_TC5(DMA_TypeDef *DMAx)
000000  f44f3100          MOV      r1,#0x20000
;;;2082   {
;;;2083     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF5);
000004  6041              STR      r1,[r0,#4]
;;;2084   }
000006  4770              BX       lr
;;;2085   
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068423LL_SPI_IsActiveFlag_BSYEP11SPI_TypeDef||, CODE, READONLY, ALIGN=1

                  _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068423LL_SPI_IsActiveFlag_BSYEP11SPI_TypeDef PROC ; [local to SPI_dirver_cpp]::LL_SPI_IsActiveFlag_BSY(SPI_TypeDef*)
;;;983      */
;;;984    __STATIC_INLINE uint32_t LL_SPI_IsActiveFlag_BSY(SPI_TypeDef *SPIx)
000000  4601              MOV      r1,r0
;;;985    {
;;;986      return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
000002  6888              LDR      r0,[r1,#8]
000004  f3c010c0          UBFX     r0,r0,#7,#1
;;;987    }
000008  4770              BX       lr
;;;988    
                          ENDP


                          AREA ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj||, CODE, READONLY, ALIGN=2

                  _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj PROC ; [local to SPI_dirver_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
;;;341    */
;;;342    __STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
000000  b508              PUSH     {r3,lr}
;;;343    {
;;;344      __IO uint32_t tmpreg;
;;;345      SET_BIT(RCC->AHB1ENR, Periphs);
000002  4905              LDR      r1,|L6.24|
000004  6c89              LDR      r1,[r1,#0x48]
000006  4301              ORRS     r1,r1,r0
000008  4a03              LDR      r2,|L6.24|
00000a  6491              STR      r1,[r2,#0x48]
;;;346      /* Delay after an RCC peripheral clock enabling */
;;;347      tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
00000c  4611              MOV      r1,r2
00000e  6c89              LDR      r1,[r1,#0x48]
000010  4001              ANDS     r1,r1,r0
000012  9100              STR      r1,[sp,#0]
;;;348      (void)tmpreg;
000014  bf00              NOP      
;;;349    }
000016  bd08              POP      {r3,pc}
;;;350    
                          ENDP

                  |L6.24|
                          DCD      0x40021000

                          AREA ||i._ZN4TSPI10check_busyEv||, CODE, READONLY, ALIGN=1

                  _ZN4TSPI10check_busyEv PROC ; TSPI::check_busy()
;;;315    
;;;316    TSPI::TSpiState TSPI::check_busy()
000000  b510              PUSH     {r4,lr}
;;;317    {
000002  4604              MOV      r4,r0
;;;318      if (                                            //проверка наличия транзакции SPI
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068423LL_SPI_IsActiveFlag_BSYEP11SPI_TypeDef ; [local to SPI_dirver_cpp]::LL_SPI_IsActiveFlag_BSY(SPI_TypeDef*)
00000a  b920              CBNZ     r0,|L7.22|
;;;319          LL_SPI_IsActiveFlag_BSY( HW.If )
;;;320          ||
;;;321          !LL_SPI_IsActiveFlag_TXE( HW.If )
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  f3c10140          UBFX     r1,r1,#1,#1
000014  b909              CBNZ     r1,|L7.26|
                  |L7.22|
;;;322         )
;;;323      {
;;;324        return TSpiState::__BSY;                      //SPI занят => передача нового кадра не запускается
000016  2000              MOVS     r0,#0
                  |L7.24|
;;;325      }
;;;326    
;;;327      return (
;;;328              LL_SPI_IsActiveFlag_BSY( HW.If )
;;;329             )
;;;330             ? TSpiState::__BSY
;;;331             : TSpiState::__FREE;
;;;332    }
000018  bd10              POP      {r4,pc}
                  |L7.26|
00001a  6820              LDR      r0,[r4,#0]            ;327
00001c  f7fffffe          BL       _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068423LL_SPI_IsActiveFlag_BSYEP11SPI_TypeDef ; [local to SPI_dirver_cpp]::LL_SPI_IsActiveFlag_BSY(SPI_TypeDef*)
000020  b108              CBZ      r0,|L7.38|
000022  2000              MOVS     r0,#0                 ;330
000024  e7f8              B        |L7.24|
                  |L7.38|
000026  2002              MOVS     r0,#2                 ;331
000028  e7f6              B        |L7.24|
                          ENDP


                          AREA ||i._ZN4TSPI10read_frameEv||, CODE, READONLY, ALIGN=1

                  _ZN4TSPI10read_frameEv PROC ; TSPI::read_frame()
;;;291    
;;;292    void TSPI::read_frame()
000000  4770              BX       lr
;;;293    {
;;;294    
;;;295    }
;;;296    
                          ENDP


                          AREA ||i._ZN4TSPI10write_byteEh||, CODE, READONLY, ALIGN=1

                  _ZN4TSPI10write_byteEh PROC ; TSPI::write_byte(unsigned char)
;;;296    
;;;297    TSPI::TSpiState TSPI::write_byte( uint8_t Byte )
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;299      if ( check_busy() != TSpiState::__FREE)
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       _ZN4TSPI10check_busyEv ; TSPI::check_busy()
00000c  2802              CMP      r0,#2
00000e  d001              BEQ      |L9.20|
;;;300      {
;;;301        return TSpiState::__BSY;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;302      }
;;;303        
;;;304      LL_GPIO_ResetOutputPin( HW.CS.Gpio, HW.CS.Nbr );
;;;305    //  LL_DMA_DisableChannel( DMA.Nbr, DMA.TxCh ); //для передачи одного байта DMA не используется
;;;306    
;;;307      LL_SPI_TransmitData8( HW.If, Byte);
;;;308      LL_SPI_Enable( HW.If );                              //Enable SPI peripheral \
;;;309                                                             на выводе NSS уровень, если включено аппаратное управление 
;;;310    
;;;311      LL_SPI_EnableIT_TXE( HW.If ); //включить прерывание TXE
;;;312    
;;;313      return TSpiState::__START;
;;;314    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  e9d40115          LDRD     r0,r1,[r4,#0x54]      ;304
000018  6281              STR      r1,[r0,#0x28]         ;304
00001a  bf00              NOP                            ;304
00001c  6820              LDR      r0,[r4,#0]            ;307
00001e  7305              STRB     r5,[r0,#0xc]          ;307
000020  bf00              NOP                            ;307
000022  6820              LDR      r0,[r4,#0]            ;308
000024  6801              LDR      r1,[r0,#0]            ;308
000026  f0410140          ORR      r1,r1,#0x40           ;308
00002a  6001              STR      r1,[r0,#0]            ;308
00002c  bf00              NOP                            ;308
00002e  6820              LDR      r0,[r4,#0]            ;311
000030  6841              LDR      r1,[r0,#4]            ;311
000032  f0410180          ORR      r1,r1,#0x80           ;311
000036  6041              STR      r1,[r0,#4]            ;311
000038  bf00              NOP                            ;311
00003a  2001              MOVS     r0,#1                 ;313
00003c  e7e9              B        |L9.18|
;;;315    
                          ENDP


                          AREA ||i._ZN4TSPI11write_frameEPKhh||, CODE, READONLY, ALIGN=1

                  _ZN4TSPI11write_frameEPKhh PROC ; TSPI::write_frame(const unsigned char*, unsigned char)
;;;286      
;;;287    void TSPI::write_frame( const uint8_t *Buf, uint8_t Size )
000000  4770              BX       lr
;;;288    {
;;;289    
;;;290    }
;;;291    
                          ENDP


                          AREA ||i._ZN4TSPI14pin_clk_configEv||, CODE, READONLY, ALIGN=1

                  _ZN4TSPI14pin_clk_configEv PROC ; TSPI::pin_clk_config()
;;;19     
;;;20     void TSPI::pin_clk_config()
000000  b510              PUSH     {r4,lr}
;;;21     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;22       /*тактирование GPIO, к которым подключены SDA и SCL и тактирование интерфейса SPI*/
;;;23       HW.SO.en_clk( HW.SO.ClkPortMask );
000006  e9d40108          LDRD     r0,r1,[r4,#0x20]
00000a  4788              BLX      r1
;;;24       HW.SI.en_clk( HW.SI.ClkPortMask );
00000c  e9d4010d          LDRD     r0,r1,[r4,#0x34]
000010  4788              BLX      r1
;;;25       HW.SCK.en_clk( HW.SCK.ClkPortMask );
000012  e9d40112          LDRD     r0,r1,[r4,#0x48]
000016  4788              BLX      r1
;;;26       HW.CS.en_clk( HW.CS.ClkPortMask );
000018  e9d40117          LDRD     r0,r1,[r4,#0x5c]
00001c  4788              BLX      r1
;;;27       
;;;28       HW.Clk.en_periph( HW.Clk.PeriphMask );
00001e  e9d41002          LDRD     r1,r0,[r4,#8]
000022  4788              BLX      r1
;;;29       
;;;30       /* инициализация выводов с I2C */
;;;31       LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;32       do
000024  bf00              NOP      
                  |L11.38|
;;;33       {
;;;34         GPIO_InitStruct.Pin        = HW.SO.Nbr;
000026  69e0              LDR      r0,[r4,#0x1c]
000028  9000              STR      r0,[sp,#0]
;;;35         GPIO_InitStruct.Mode       = LL_GPIO_MODE_ALTERNATE;
00002a  2002              MOVS     r0,#2
00002c  9001              STR      r0,[sp,#4]
;;;36         GPIO_InitStruct.Speed      = LL_GPIO_SPEED_FREQ_HIGH;
00002e  9002              STR      r0,[sp,#8]
;;;37     //    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
;;;38         GPIO_InitStruct.Pull       = LL_GPIO_PULL_NO;
000030  2000              MOVS     r0,#0
000032  9004              STR      r0,[sp,#0x10]
;;;39         GPIO_InitStruct.Alternate  = LL_GPIO_AF_5;
000034  2005              MOVS     r0,#5
000036  9005              STR      r0,[sp,#0x14]
;;;40       } while ( SUCCESS != LL_GPIO_Init( HW.SO.Gpio, &GPIO_InitStruct ) );
000038  4669              MOV      r1,sp
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  f7fffffe          BL       LL_GPIO_Init
000040  2800              CMP      r0,#0
000042  d1f0              BNE      |L11.38|
;;;41       
;;;42       do
000044  bf00              NOP      
                  |L11.70|
;;;43       {
;;;44         GPIO_InitStruct.Pin        = HW.SI.Nbr;
000046  6b20              LDR      r0,[r4,#0x30]
000048  9000              STR      r0,[sp,#0]
;;;45         GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
00004a  2000              MOVS     r0,#0
00004c  9003              STR      r0,[sp,#0xc]
;;;46       } while ( SUCCESS != LL_GPIO_Init( HW.SI.Gpio, &GPIO_InitStruct ) );
00004e  4669              MOV      r1,sp
000050  6ae0              LDR      r0,[r4,#0x2c]
000052  f7fffffe          BL       LL_GPIO_Init
000056  2800              CMP      r0,#0
000058  d1f5              BNE      |L11.70|
;;;47       
;;;48       do
00005a  bf00              NOP      
                  |L11.92|
;;;49       {
;;;50         GPIO_InitStruct.Pin        = HW.SCK.Nbr;
00005c  6c60              LDR      r0,[r4,#0x44]
00005e  9000              STR      r0,[sp,#0]
;;;51         GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
000060  2000              MOVS     r0,#0
000062  9003              STR      r0,[sp,#0xc]
;;;52       } while ( SUCCESS != LL_GPIO_Init( HW.SCK.Gpio, &GPIO_InitStruct ) );
000064  4669              MOV      r1,sp
000066  6c20              LDR      r0,[r4,#0x40]
000068  f7fffffe          BL       LL_GPIO_Init
00006c  2800              CMP      r0,#0
00006e  d1f5              BNE      |L11.92|
;;;53       
;;;54       do
000070  bf00              NOP      
                  |L11.114|
;;;55       {
;;;56         GPIO_InitStruct.Pin        = HW.CS.Nbr;
000072  6da0              LDR      r0,[r4,#0x58]
000074  9000              STR      r0,[sp,#0]
;;;57         GPIO_InitStruct.Mode       = LL_GPIO_MODE_OUTPUT;
000076  2001              MOVS     r0,#1
000078  9001              STR      r0,[sp,#4]
;;;58         GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
00007a  2000              MOVS     r0,#0
00007c  9003              STR      r0,[sp,#0xc]
;;;59       } while ( SUCCESS != LL_GPIO_Init( HW.CS.Gpio, &GPIO_InitStruct ) );
00007e  4669              MOV      r1,sp
000080  6d60              LDR      r0,[r4,#0x54]
000082  f7fffffe          BL       LL_GPIO_Init
000086  2800              CMP      r0,#0
000088  d1f3              BNE      |L11.114|
;;;60     }
00008a  b006              ADD      sp,sp,#0x18
00008c  bd10              POP      {r4,pc}
;;;61     
                          ENDP


                          AREA ||i._ZN4TSPI7hw_initEv||, CODE, READONLY, ALIGN=2

                  _ZN4TSPI7hw_initEv PROC ; TSPI::hw_init()
;;;61     
;;;62     void TSPI::hw_init()
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;63     {
000004  b099              SUB      sp,sp,#0x64
000006  4604              MOV      r4,r0
;;;64       LL_RCC_ClocksTypeDef RCC_Clocks;
;;;65       LL_RCC_GetSystemClocksFreq(&RCC_Clocks);
000008  a815              ADD      r0,sp,#0x54
00000a  f7fffffe          BL       LL_RCC_GetSystemClocksFreq
;;;66     
;;;67       uint32_t BrPresc[] =
00000e  2228              MOVS     r2,#0x28
000010  493f              LDR      r1,|L12.272|
000012  a80b              ADD      r0,sp,#0x2c
000014  f7fffffe          BL       __aeabi_memcpy4
;;;68       {
;;;69         LL_SPI_BAUDRATEPRESCALER_DIV256, //__MIN         
;;;70         LL_SPI_BAUDRATEPRESCALER_DIV2,   //__MAX         
;;;71         LL_SPI_BAUDRATEPRESCALER_DIV2,   //__PCLK_DIV_2  
;;;72         LL_SPI_BAUDRATEPRESCALER_DIV4,   //__PCLK_DIV_4  
;;;73         LL_SPI_BAUDRATEPRESCALER_DIV8,   //__PCLK_DIV_8  
;;;74         LL_SPI_BAUDRATEPRESCALER_DIV16,  //__PCLK_DIV_16 
;;;75         LL_SPI_BAUDRATEPRESCALER_DIV32,  //__PCLK_DIV_32 
;;;76         LL_SPI_BAUDRATEPRESCALER_DIV64,  //__PCLK_DIV_64 
;;;77         LL_SPI_BAUDRATEPRESCALER_DIV128, //__PCLK_DIV_128
;;;78         LL_SPI_BAUDRATEPRESCALER_DIV256, //__PCLK_DIV_256
;;;79       };
;;;80       
;;;81       LL_SPI_DeInit( HW.If );
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       LL_SPI_DeInit
;;;82       LL_SPI_InitTypeDef SPI_InitStruct;
;;;83       
;;;84       SPI_InitStruct.TransferDirection = LL_SPI_FULL_DUPLEX; //Для Simplex и Full-duplex настройка не отличается \
00001e  2000              MOVS     r0,#0
000020  9001              STR      r0,[sp,#4]
;;;85                                                                неиспользуемый Spi-вывод, для Simplex, инициализировать как GPIO
;;;86       SPI_InitStruct.Mode              = LL_SPI_MODE_MASTER;
000022  f44f7082          MOV      r0,#0x104
000026  9002              STR      r0,[sp,#8]
;;;87       SPI_InitStruct.DataWidth         = LL_SPI_DATAWIDTH_8BIT;
000028  f44f60e0          MOV      r0,#0x700
00002c  9003              STR      r0,[sp,#0xc]
;;;88     //  SPI_InitStruct.ClockPolarity     = LL_SPI_POLARITY_HIGH;
;;;89     //  SPI_InitStruct.ClockPhase        = LL_SPI_PHASE_2EDGE;
;;;90       SPI_InitStruct.ClockPolarity     = LL_SPI_POLARITY_HIGH; /*!< Clock to 0 when idle */
00002e  2002              MOVS     r0,#2
000030  9004              STR      r0,[sp,#0x10]
;;;91       SPI_InitStruct.ClockPhase        = LL_SPI_PHASE_2EDGE;   /*!< Second clock transition is the first data capture edge */
000032  2001              MOVS     r0,#1
000034  9005              STR      r0,[sp,#0x14]
;;;92       SPI_InitStruct.NSS               = LL_SPI_NSS_SOFT;
000036  0240              LSLS     r0,r0,#9
000038  9006              STR      r0,[sp,#0x18]
;;;93     //  SPI_InitStruct.NSS               = LL_SPI_NSS_HARD_OUTPUT;
;;;94       SPI_InitStruct.BaudRate          = BrPresc[ Rate ];
00003a  f8940068          LDRB     r0,[r4,#0x68]
00003e  a90b              ADD      r1,sp,#0x2c
000040  f8510020          LDR      r0,[r1,r0,LSL #2]
000044  9007              STR      r0,[sp,#0x1c]
;;;95       SPI_InitStruct.BitOrder          = LL_SPI_MSB_FIRST;
000046  2000              MOVS     r0,#0
000048  9008              STR      r0,[sp,#0x20]
;;;96       SPI_InitStruct.CRCCalculation    = LL_SPI_CRCCALCULATION_DISABLE;
00004a  9009              STR      r0,[sp,#0x24]
;;;97     //  SPI_InitStruct.CRCPoly           = ;
;;;98       
;;;99       LL_SPI_Init( HW.If, &SPI_InitStruct );
00004c  a901              ADD      r1,sp,#4
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       LL_SPI_Init
;;;100      
;;;101      LL_SPI_SetRxFIFOThreshold( HW.If, LL_SPI_RX_FIFO_TH_QUARTER ); /*!< RXNE event is generated if FIFO level is greater than or equel to 1/4 (8-bit)  */
000054  f44f5180          MOV      r1,#0x1000
000058  6820              LDR      r0,[r4,#0]
00005a  6842              LDR      r2,[r0,#4]
00005c  f4225280          BIC      r2,r2,#0x1000
000060  430a              ORRS     r2,r2,r1
000062  6042              STR      r2,[r0,#4]
000064  bf00              NOP      
;;;102      
;;;103      // Настройка NVIC
;;;104      NVIC_SetPriority(
000066  f9941004          LDRSB    r1,[r4,#4]
00006a  4b2a              LDR      r3,|L12.276|
00006c  681b              LDR      r3,[r3,#0]
00006e  f3c32002          UBFX     r0,r3,#8,#3
000072  2505              MOVS     r5,#5
000074  2600              MOVS     r6,#0
000076  4603              MOV      r3,r0
000078  f1c30807          RSB      r8,r3,#7
00007c  f1b80f04          CMP      r8,#4
000080  d902              BLS      |L12.136|
000082  f04f0804          MOV      r8,#4
000086  e001              B        |L12.140|
                  |L12.136|
000088  f1c30807          RSB      r8,r3,#7
                  |L12.140|
00008c  46c4              MOV      r12,r8
00008e  f1030804          ADD      r8,r3,#4
000092  f1b80f07          CMP      r8,#7
000096  d202              BCS      |L12.158|
000098  f04f0800          MOV      r8,#0
00009c  e001              B        |L12.162|
                  |L12.158|
00009e  f1a30803          SUB      r8,r3,#3
                  |L12.162|
0000a2  4647              MOV      r7,r8
0000a4  f04f0801          MOV      r8,#1
0000a8  fa08f80c          LSL      r8,r8,r12
0000ac  f1a80801          SUB      r8,r8,#1
0000b0  ea080805          AND      r8,r8,r5
0000b4  fa08f807          LSL      r8,r8,r7
0000b8  f04f0901          MOV      r9,#1
0000bc  fa09f907          LSL      r9,r9,r7
0000c0  f1a90901          SUB      r9,r9,#1
0000c4  ea090906          AND      r9,r9,r6
0000c8  ea480209          ORR      r2,r8,r9
0000cc  bf00              NOP      
0000ce  2900              CMP      r1,#0
0000d0  da08              BGE      |L12.228|
0000d2  0710              LSLS     r0,r2,#28
0000d4  0e05              LSRS     r5,r0,#24
0000d6  4b0f              LDR      r3,|L12.276|
0000d8  330c              ADDS     r3,r3,#0xc
0000da  f001000f          AND      r0,r1,#0xf
0000de  1f00              SUBS     r0,r0,#4
0000e0  541d              STRB     r5,[r3,r0]
0000e2  e003              B        |L12.236|
                  |L12.228|
0000e4  0710              LSLS     r0,r2,#28
0000e6  0e03              LSRS     r3,r0,#24
0000e8  480b              LDR      r0,|L12.280|
0000ea  5443              STRB     r3,[r0,r1]
                  |L12.236|
0000ec  bf00              NOP      
;;;105                       HW.IRQ,
;;;106                       NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 5, 0)
;;;107                      );                                                     //обработчик вызывает API функцию RTOS => приоритет д.б. \
;;;108                                                                               логически ниже или равен, но численно больше или равен,\
;;;109                                                                               установленному  в макросе \
;;;110                                                                               configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
;;;111      NVIC_EnableIRQ( HW.IRQ);
0000ee  f9940004          LDRSB    r0,[r4,#4]
0000f2  f000021f          AND      r2,r0,#0x1f
0000f6  2101              MOVS     r1,#1
0000f8  4091              LSLS     r1,r1,r2
0000fa  0942              LSRS     r2,r0,#5
0000fc  0092              LSLS     r2,r2,#2
0000fe  f10222e0          ADD      r2,r2,#0xe000e000
000102  f8c21100          STR      r1,[r2,#0x100]
000106  bf00              NOP      
;;;112      
;;;113      
;;;114    //   dma_init();
;;;115      //procedure for enabling SPI
;;;116      //SPI включается и данные для отправки записаны в Tx буфер => мастер начинает обмен
;;;117      //как обработать DMA 26.3.11
;;;118      
;;;119    //  Для мастера
;;;120    //  1. MOSI и SCK запускаются только когда SPI включен.
;;;121    //  Отключается SPI => уровни на выводах зависят от настроек GPIO
;;;122    //  2. SCK запущен => BSY в активном состоянии
;;;123    //  3. TXFIFO переполняется => TXE сбрасывается
;;;124    //  4. TXDMAEN устанавливается => запускается процесс арбитража DMA
;;;125    //  TXE прерывание генерируется после установки TXEIE
;;;126    //  
;;;127    //  5.Если все данные для отправки могут поместиться в TxFIFO, TCIF может 
;;;128    //  быть поднят перед началом связи по шине SPI.
;;;129    //  TCIF всегда поднимается перед завершение SPI транзакции.
;;;130    //  
;;;131    //  6. В режиме с упаковкой данных, события TxE и RxNE являются парными и
;;;132    //  каждый доступ на чтение/запись в FIFO происходит по 16 бит, при этом
;;;133    //  количество кадров является четным. 
;;;134      
;;;135      
;;;136      
;;;137      
;;;138    }
000108  b019              ADD      sp,sp,#0x64
00010a  e8bd83f0          POP      {r4-r9,pc}
;;;139    
                          ENDP

00010e  0000              DCW      0x0000
                  |L12.272|
                          DCD      ||.constdata||
                  |L12.276|
                          DCD      0xe000ed0c
                  |L12.280|
                          DCD      0xe000e400

                          AREA ||i._ZN4TSPI8dma_initEv||, CODE, READONLY, ALIGN=2

                  _ZN4TSPI8dma_initEv PROC ; TSPI::dma_init()
;;;139    
;;;140    void TSPI::dma_init()
000000  b510              PUSH     {r4,lr}
;;;141    {
000002  b0a4              SUB      sp,sp,#0x90
000004  4604              MOV      r4,r0
;;;142      struct TSpiDma
;;;143      {
;;;144        SPI_TypeDef *If;
;;;145        TDma         Dma;
;;;146      };
;;;147      
;;;148      TSpiDma SpiDma[] =
000006  2290              MOVS     r2,#0x90
000008  4902              LDR      r1,|L13.20|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;149      {
;;;150        {
;;;151          SPI1,
;;;152          {
;;;153            { 
;;;154              DMA1,
;;;155              LL_AHB1_GRP1_EnableClock,
;;;156              LL_AHB1_GRP1_PERIPH_DMA1,
;;;157              LL_DMA_ClearFlag_TC3
;;;158            },                                                              //Nbr
;;;159    	      { LL_DMA_CHANNEL_2, DMA1_Channel2_IRQn },                       //RxChannel
;;;160    	      { LL_DMA_CHANNEL_3, DMA1_Channel3_IRQn }                        //TxChannel
;;;161          }
;;;162        },
;;;163        {
;;;164          SPI1,
;;;165          {
;;;166            { 
;;;167              DMA2,
;;;168              LL_AHB1_GRP1_EnableClock,
;;;169              LL_AHB1_GRP1_PERIPH_DMA2,
;;;170              LL_DMA_ClearFlag_TC4
;;;171            },                                                              //Nbr
;;;172    	      { LL_DMA_CHANNEL_3, DMA1_Channel3_IRQn },                       //RxChannel
;;;173    	      { LL_DMA_CHANNEL_4, DMA1_Channel4_IRQn }                        //TxChannel
;;;174          }
;;;175        },
;;;176        {
;;;177          SPI2,
;;;178          {
;;;179            { 
;;;180              DMA1,
;;;181              LL_AHB1_GRP1_EnableClock,
;;;182              LL_AHB1_GRP1_PERIPH_DMA1,
;;;183              LL_DMA_ClearFlag_TC5
;;;184            },                                                              //Nbr
;;;185    	      { LL_DMA_CHANNEL_4, DMA1_Channel4_IRQn },                       //RxChannel
;;;186    	      { LL_DMA_CHANNEL_5, DMA1_Channel5_IRQn }                        //TxChannel
;;;187          }
;;;188        },
;;;189        {
;;;190          SPI3,
;;;191          {
;;;192            { 
;;;193              DMA2,
;;;194              LL_AHB1_GRP1_EnableClock,
;;;195              LL_AHB1_GRP1_PERIPH_DMA2,
;;;196              LL_DMA_ClearFlag_TC2
;;;197            },                                                              //Nbr
;;;198    	      { LL_DMA_CHANNEL_1, DMA1_Channel1_IRQn },                       //RxChannel
;;;199    	      { LL_DMA_CHANNEL_2, DMA1_Channel2_IRQn }                        //TxChannel
;;;200          }
;;;201        },
;;;202      };
;;;203      
;;;204    //  HW.If->
;;;205    //  
;;;206    //  TChannelSets Rx =
;;;207    //  {
;;;208    //    (uint32_t)&HW.If->RDR,
;;;209    //    (uint32_t)RxBuf,
;;;210    //    LL_DMA_DIRECTION_PERIPH_TO_MEMORY,
;;;211    //    LL_DMA_MODE_CIRCULAR,
;;;212    //    RX_BUF_SIZE,
;;;213    //  };
;;;214    //  
;;;215    //  TChannelSets Tx =
;;;216    //  {
;;;217    //    (uint32_t)&HW.If->TDR,
;;;218    //    (uint32_t)TxBuf,
;;;219    //    LL_DMA_DIRECTION_MEMORY_TO_PERIPH,
;;;220    //    LL_DMA_MODE_NORMAL,
;;;221    //    TX_BUF_SIZE,
;;;222    //  };
;;;223    //  
;;;224    //  Dma[ StrIx ][ ProcType ].Periph.en_clk( Dma[ StrIx ][ ProcType ].Periph.ClkMask );
;;;225    
;;;226    //  LL_DMA_InitTypeDef DMA_Init;
;;;227    //  
;;;228    //	DMA_Init.PeriphOrM2MSrcAddress  = Tx.PeriphAddr;             //базовый адрес источника
;;;229    //	DMA_Init.MemoryOrM2MDstAddress  = Tx.MemAddr;                //базовый адрес места назначения
;;;230    //	DMA_Init.Direction              = Tx.Direction;              //направление трансфера
;;;231    //	DMA_Init.Mode                   = Tx.Mode;                   //режим работы DMA (нормальный или кольцевой)
;;;232    //	DMA_Init.PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT; //инкремент блоков источника данных (периферии или ОЗУ)
;;;233    //	DMA_Init.MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_INCREMENT;   //инкремент блоков места назначения данных (периферии или ОЗУ)
;;;234    //	DMA_Init.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;    //выравнивание данных источника данных (периферии или ОЗУ)
;;;235    //	DMA_Init.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;    //выравнивание данных места назначения данных (периферии или ОЗУ)
;;;236    //	DMA_Init.NbData                 = Tx.NbData;                 //количество блоков данных для обмена - перезаписывается под актуальный буфер
;;;237    //	DMA_Init.PeriphRequest          = LL_DMA_REQUEST_2;          //запрос периферии
;;;238    //	DMA_Init.Priority               = LL_DMA_PRIORITY_MEDIUM;  //приоритет DMA канала
;;;239    //  
;;;240    //  do { } while ( 
;;;241    //                LL_DMA_Init( 
;;;242    //                            Dma[ StrIx ][ ProcType ].Periph.Nbr,
;;;243    //                            Dma[ StrIx ][ ProcType ].TxChannel.Nbr,
;;;244    //                            &DMA_Init
;;;245    //                           ) != SUCCESS           
;;;246    //               );
;;;247    //               
;;;248    //	DMA_Init.PeriphOrM2MSrcAddress  = Rx.PeriphAddr;    //базовый адрес источника
;;;249    //	DMA_Init.MemoryOrM2MDstAddress  = Rx.MemAddr;       //базовый адрес места назначения
;;;250    //	DMA_Init.Direction              = Rx.Direction;     //направление трансфера
;;;251    //	DMA_Init.Mode                   = Rx.Mode;          //режим работы DMA (нормальный или кольцевой)
;;;252    //	DMA_Init.NbData                 = Rx.NbData;        //количество блоков данных для обмена
;;;253    //	DMA_Init.PeriphRequest          = LL_DMA_REQUEST_2; //запрос периферии
;;;254    //  
;;;255    //  do { } while ( 
;;;256    //                LL_DMA_Init( 
;;;257    //                            Dma[ StrIx ][ ProcType ].Periph.Nbr,
;;;258    //                            Dma[ StrIx ][ ProcType ].RxChannel.Nbr,
;;;259    //                            &DMA_Init
;;;260    //                           ) != SUCCESS           
;;;261    //               );
;;;262    
;;;263    //  //настройка NVIC
;;;264    //  NVIC_SetPriority( 
;;;265    //                   Dma[ StrIx ][ ProcType ].TxChannel.IRQ, 
;;;266    //                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 5, 0) 
;;;267    //                  );                                                     //5 - максимальный уровень приоритета для прерывания \
;;;268    //                                                                           из которого можно вызывать API функции FreeRTOS 
;;;269    //  NVIC_EnableIRQ( Dma[ StrIx ][ ProcType ].TxChannel.IRQ );            //прерывания при передаче через USART
;;;270    //  
;;;271    //	LL_DMA_EnableIT_TC(
;;;272    //                     Dma[ StrIx ][ ProcType ].Periph.Nbr, 
;;;273    //                     Dma[ StrIx ][ ProcType ].TxChannel.Nbr 
;;;274    //                    );                                                   //Transfer complete interrupt
;;;275    //    
;;;276    //  LL_USART_EnableDMAReq_RX( HW.If );                                     //включение DMA режима для приема через USART
;;;277    //  LL_USART_EnableDMAReq_TX( HW.If );                                     //включение DMA режима для передачи через USART
;;;278    
;;;279    //	//активация DMA каналов
;;;280    //  LL_DMA_EnableChannel( Dma[ StrIx ][ ProcType ].Periph.Nbr, Dma[ StrIx ][ ProcType ].RxChannel.Nbr ); //канал включен => канал контроллера DMA может \
;;;281    //                                                                                                         обработать запрос от периферии, \
;;;282    //	                                                                                                       подключенной к этому каналу
;;;283    //	LL_DMA_DisableChannel( Dma[ StrIx ][ ProcType ].Periph.Nbr, Dma[ StrIx ][ ProcType ].TxChannel.Nbr );
;;;284      
;;;285    }
000010  b024              ADD      sp,sp,#0x90
000012  bd10              POP      {r4,pc}
;;;286      
                          ENDP

                  |L13.20|
                          DCD      ||.constdata||+0x28

                          AREA ||i._ZN4TSPIC1ERK7TSpi_HWNS_5TRateE||, CODE, READONLY, ALIGN=1

                  _ZN4TSPIC2ERK7TSpi_HWNS_5TRateE                  ; Alternate entry point ; TSPI::TSPI__sub_object(const TSpi_HW&, TSPI::TRate)
                  _ZN4TSPIC1ERK7TSpi_HWNS_5TRateE PROC ; TSPI::TSPI(const TSpi_HW&, TSPI::TRate)
;;;3      
;;;4      TSPI::TSPI( 
;;;5                 const TSpi_HW &_HW,
;;;6                 TRate _Rate
;;;7                )
;;;8      :
;;;9      HW( _HW ),
;;;10     Rate( _Rate )
;;;11     {
;;;12     
;;;13     }
;;;14     
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
000008  2268              MOVS     r2,#0x68
00000a  4631              MOV      r1,r6
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       __aeabi_memcpy4
000012  f8845068          STRB     r5,[r4,#0x68]
000016  4620              MOV      r0,r4
000018  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||i._ZN4TSPID1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4TSPID2Ev                  ; Alternate entry point ; TSPI::~TSPI__sub_object()
                  _ZN4TSPID1Ev PROC ; TSPI::~TSPI()
;;;14     
;;;15     TSPI::~TSPI()
;;;16     {
;;;17     
;;;18     }
;;;19     
000000  4770              BX       lr
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4TSPIC1ERK7TSpi_HWNS_5TRateE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPIC1ERK7TSpi_HWNS_5TRateE||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._ZN4TSPID1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPID1Ev||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._ZN4TSPI14pin_clk_configEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI14pin_clk_configEv||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._ZN4TSPI7hw_initEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI7hw_initEv||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._ZN4TSPI11write_frameEPKhh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI11write_frameEPKhh||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._ZN4TSPI10read_frameEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI10read_frameEv||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._ZN4TSPI10check_busyEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI10check_busyEv||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i._ZN4TSPI10write_byteEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI10write_byteEh||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i._ZN4TSPI8dma_initEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4TSPI8dma_initEv||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC2EP11DMA_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC2EP11DMA_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC3EP11DMA_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC3EP11DMA_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC4EP11DMA_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC4EP11DMA_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC5EP11DMA_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC5EP11DMA_TypeDef||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068423LL_SPI_IsActiveFlag_BSYEP11SPI_TypeDef||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068423LL_SPI_IsActiveFlag_BSYEP11SPI_TypeDef||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000038
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000018
                          DCD      0x00000020
                          DCD      0x00000028
                          DCD      0x00000030
                          DCD      0x00000038
                          DCD      0x40013000
                          DCD      0x40020000
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj ; [local to SPI_dirver_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
                          DCD      0x00000001
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC3EP11DMA_TypeDef ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC3(DMA_TypeDef*)
                          DCD      0x00000002
000040  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x00000003
000048  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x40013000
                          DCD      0x40020400
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj ; [local to SPI_dirver_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
                          DCD      0x00000002
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC4EP11DMA_TypeDef ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC4(DMA_TypeDef*)
                          DCD      0x00000003
000064  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00000004
00006c  0e000000          DCB      0x0e,0x00,0x00,0x00
                          DCD      0x40003800
                          DCD      0x40020000
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj ; [local to SPI_dirver_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
                          DCD      0x00000001
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC5EP11DMA_TypeDef ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC5(DMA_TypeDef*)
                          DCD      0x00000004
000088  0e000000          DCB      0x0e,0x00,0x00,0x00
                          DCD      0x00000005
000090  0f000000          DCB      0x0f,0x00,0x00,0x00
                          DCD      0x40003c00
                          DCD      0x40020400
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068424LL_AHB1_GRP1_EnableClockEj ; [local to SPI_dirver_cpp]::LL_AHB1_GRP1_EnableClock(unsigned)
                          DCD      0x00000002
                          DCD      _ZN36_INTERNAL_14_SPI_dirver_cpp_4f82068420LL_DMA_ClearFlag_TC2EP11DMA_TypeDef ; [local to SPI_dirver_cpp]::LL_DMA_ClearFlag_TC2(DMA_TypeDef*)
                          DCD      0x00000001
0000ac  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x00000002
0000b4  0c000000          DCB      0x0c,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "Source\\MCU_Drivers\\src\\SPI_dirver.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_SPI_dirver_cpp_4f820684___ZN36_INTERNAL_14_SPI_dirver_cpp_4f8206847__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___14_SPI_dirver_cpp_4f820684___ZN36_INTERNAL_14_SPI_dirver_cpp_4f8206847__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_SPI_dirver_cpp_4f820684___ZN36_INTERNAL_14_SPI_dirver_cpp_4f8206847__REVSHEi|
#line 402
|__asm___14_SPI_dirver_cpp_4f820684___ZN36_INTERNAL_14_SPI_dirver_cpp_4f8206847__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_SPI_dirver_cpp_4f820684___ZN36_INTERNAL_14_SPI_dirver_cpp_4f8206845__RRXEj|
#line 587
|__asm___14_SPI_dirver_cpp_4f820684___ZN36_INTERNAL_14_SPI_dirver_cpp_4f8206845__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
