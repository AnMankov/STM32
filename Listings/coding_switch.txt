; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--cpp11 --list --split_sections --debug -c --asm --interleave -o.\objects\coding_switch.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\coding_switch.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I".\STM32L4 Low Layer drivers\inc" -I"..\Lib\CRC Modbus\inc" -I.\Source\Core\inc -I.\Source\Protocols\inc -I.\Source\Ext_Dev\inc -I.\Source\Ext_Dev\inc\LSM6DS3 -I.\Source\Ext_Dev\inc\LSM303DLHC -I.\Source\Ext_Dev\inc\MPU-9250 -I.\Source\Line\inc -I.\Source\Main\inc -I.\Source\MCU_Drivers\inc -I.\Source\MCU_Drivers\inc -I.\Source\MotionTL\inc -I.\Source\RTOS\inc -I.\Source\Tasks\inc -I..\Lib\Objects -I.\Source\Ext_Dev\inc\AT45 -I.\RTE\_DEBUG -IC:\Keil_v5\ARM\PACK\Keil\STM32L4xx_DFP\2.2.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32L431xx -DHSE_VALUE=8000000 -DUSE_FULL_LL_DRIVER -DSTM32L431xx -DDEBUG --omf_browse=.\objects\coding_switch.crf Source\Tasks\src\coding_switch.cpp]
                          THUMB

                          AREA ||i._Z11code_sw_tmrPv||, CODE, READONLY, ALIGN=2

                  _Z11code_sw_tmrPv PROC ; code_sw_tmr(void*)
;;;137    //----- Таймер RTOS -------------------------------------------------------------------------------------------------
;;;138    void code_sw_tmr( TimerHandle_t xTimer ) //обработка таймера кодового переключателя
000000  b510              PUSH     {r4,lr}
;;;139    {
000002  4604              MOV      r4,r0
;;;140      xSemaphoreGive(CodeSwTmr_TrigSem);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  4619              MOV      r1,r3
00000a  4802              LDR      r0,|L1.20|
00000c  6800              LDR      r0,[r0,#0]  ; CodeSwTmr_TrigSem
00000e  f7fffffe          BL       xQueueGenericSend
;;;141    }
000012  bd10              POP      {r4,pc}
;;;142    //\---- Таймер RTOS -------------------------------------------------------------------------------------------------
                          ENDP

                  |L1.20|
                          DCD      CodeSwTmr_TrigSem

                          AREA ||i._Z13coding_switchPv||, CODE, READONLY, ALIGN=2

                  _Z13coding_switchPv PROC ; coding_switch(void*)
;;;113    //----- Задача RTOS -------------------------------------------------------------------------------------------------
;;;114    void coding_switch( void *Params ) //обработка кодового переключателя
000000  b086              SUB      sp,sp,#0x18
;;;115    {
;;;116      //В течение 100мс 1 раз в секунду происходит опрос кодового переключателя
;;;117      CodeSw.init();
000002  4822              LDR      r0,|L2.140|
000004  f7fffffe          BL       _ZN13TCodingSwitch4initEv ; TCodingSwitch::init()
;;;118    
;;;119      typedef void (TCodingSwitch::*TFnct)( TimerHandle_t & );
;;;120    
;;;121      TFnct Fnct[] =
000008  4b21              LDR      r3,|L2.144|
00000a  e9d32101          LDRD     r2,r1,[r3,#4]
00000e  6818              LDR      r0,[r3,#0]  ; <Data3>
000010  68db              LDR      r3,[r3,#0xc]  ; <Data3>
000012  e9cd1304          STRD     r1,r3,[sp,#0x10]
000016  e9cd0202          STRD     r0,r2,[sp,#8]
;;;122      {
;;;123        &TCodingSwitch::sample_ctrl,
;;;124        &TCodingSwitch::dly_ctrl,
;;;125      };
;;;126    
;;;127      xTimerStart( CodeSwTmr, 0U );
00001a  f7fffffe          BL       xTaskGetTickCount
00001e  4604              MOV      r4,r0
000020  2000              MOVS     r0,#0
000022  4603              MOV      r3,r0
000024  4622              MOV      r2,r4
000026  2101              MOVS     r1,#1
000028  9000              STR      r0,[sp,#0]
00002a  481a              LDR      r0,|L2.148|
00002c  6800              LDR      r0,[r0,#0]  ; CodeSwTmr
00002e  f7fffffe          BL       xTimerGenericCommand
;;;128      for (;;)
000032  bf00              NOP      
                  |L2.52|
;;;129      {
;;;130        xSemaphoreTake( CodeSwTmr_TrigSem, portMAX_DELAY ); //ожидание срабатывания таймера
000034  2300              MOVS     r3,#0
000036  1e5a              SUBS     r2,r3,#1
000038  4619              MOV      r1,r3
00003a  4817              LDR      r0,|L2.152|
00003c  6800              LDR      r0,[r0,#0]  ; CodeSwTmr_TrigSem
00003e  f7fffffe          BL       xQueueGenericReceive
;;;131          ( CodeSw.*Fnct[CodeSw.State] )( CodeSwTmr );
000042  4812              LDR      r0,|L2.140|
000044  7f00              LDRB     r0,[r0,#0x1c]  ; CodeSw
000046  a902              ADD      r1,sp,#8
000048  eb0100c0          ADD      r0,r1,r0,LSL #3
00004c  6840              LDR      r0,[r0,#4]
00004e  490f              LDR      r1,|L2.140|
000050  eb010460          ADD      r4,r1,r0,ASR #1
000054  4608              MOV      r0,r1
000056  7f00              LDRB     r0,[r0,#0x1c]  ; CodeSw
000058  a902              ADD      r1,sp,#8
00005a  eb0100c0          ADD      r0,r1,r0,LSL #3
00005e  7900              LDRB     r0,[r0,#4]
000060  f0000001          AND      r0,r0,#1
000064  b920              CBNZ     r0,|L2.112|
000066  4809              LDR      r0,|L2.140|
000068  7f00              LDRB     r0,[r0,#0x1c]  ; CodeSw
00006a  f8510030          LDR      r0,[r1,r0,LSL #3]
00006e  e007              B        |L2.128|
                  |L2.112|
000070  4906              LDR      r1,|L2.140|
000072  7f09              LDRB     r1,[r1,#0x1c]  ; CodeSw
000074  aa02              ADD      r2,sp,#8
000076  f8521031          LDR      r1,[r2,r1,LSL #3]
00007a  6820              LDR      r0,[r4,#0]
00007c  1845              ADDS     r5,r0,r1
00007e  6828              LDR      r0,[r5,#0]
                  |L2.128|
000080  4606              MOV      r6,r0
000082  4904              LDR      r1,|L2.148|
000084  4620              MOV      r0,r4
000086  47b0              BLX      r6
;;;132      }
000088  e7d4              B        |L2.52|
;;;133    }
;;;134    //\---- Задача RTOS -------------------------------------------------------------------------------------------------
                          ENDP

00008a  0000              DCW      0x0000
                  |L2.140|
                          DCD      CodeSw
                  |L2.144|
                          DCD      ||.constdata||
                  |L2.148|
                          DCD      CodeSwTmr
                  |L2.152|
                          DCD      CodeSwTmr_TrigSem

                          AREA ||i._ZN13TCodingSwitch11sample_ctrlERPv||, CODE, READONLY, ALIGN=2

                  _ZN13TCodingSwitch11sample_ctrlERPv PROC ; TCodingSwitch::sample_ctrl(void*&)
;;;61     
;;;62     void TCodingSwitch::sample_ctrl( TimerHandle_t &CodeSwTmr )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;63     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;64     //  RelFour.toggle();
;;;65       SampleBuf[SampleTmr.Qty] = rd_addr();
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN13TCodingSwitch7rd_addrEv ; TCodingSwitch::rd_addr()
00000e  7de1              LDRB     r1,[r4,#0x17]
000010  5460              STRB     r0,[r4,r1]
;;;66     
;;;67       if ( ++SampleTmr.Qty == SampleTmr.MAX_QTY )
000012  7de0              LDRB     r0,[r4,#0x17]
000014  1c40              ADDS     r0,r0,#1
000016  b2c1              UXTB     r1,r0
000018  75e1              STRB     r1,[r4,#0x17]
00001a  7da0              LDRB     r0,[r4,#0x16]
00001c  4281              CMP      r1,r0
00001e  d134              BNE      |L3.138|
;;;68       {
;;;69         State = __DLY;
000020  2001              MOVS     r0,#1
000022  7720              STRB     r0,[r4,#0x1c]
;;;70         SampleTmr.Qty = 0U;
000024  2100              MOVS     r1,#0
000026  75e1              STRB     r1,[r4,#0x17]
;;;71         
;;;72         auto beg = SampleBuf;
000028  4626              MOV      r6,r4
;;;73         auto end = &SampleBuf[BUF_SIZE];
00002a  f1040814          ADD      r8,r4,#0x14
;;;74         
;;;75         if ( xTimerIsTimerActive( CodeSwTmr ) != pdFALSE ) //если таймер по неопределенной причине не закончил считать
00002e  6828              LDR      r0,[r5,#0]
000030  f7fffffe          BL       xTimerIsTimerActive
000034  b138              CBZ      r0,|L3.70|
;;;76         {
;;;77           xTimerStop( CodeSwTmr, 0U );
000036  2000              MOVS     r0,#0
000038  9000              STR      r0,[sp,#0]
00003a  2300              MOVS     r3,#0
00003c  461a              MOV      r2,r3
00003e  2103              MOVS     r1,#3
000040  6828              LDR      r0,[r5,#0]
000042  f7fffffe          BL       xTimerGenericCommand
                  |L3.70|
;;;78         }
;;;79         xTimerChangePeriod( CodeSwTmr, pdMS_TO_TICKS( DlyTmr.TIME_MS ), 0U );
000046  8b20              LDRH     r0,[r4,#0x18]
000048  f44f717a          MOV      r1,#0x3e8
00004c  4348              MULS     r0,r1,r0
00004e  fbb0f9f1          UDIV     r9,r0,r1
000052  2000              MOVS     r0,#0
000054  9000              STR      r0,[sp,#0]
000056  2300              MOVS     r3,#0
000058  464a              MOV      r2,r9
00005a  2104              MOVS     r1,#4
00005c  6828              LDR      r0,[r5,#0]
00005e  f7fffffe          BL       xTimerGenericCommand
;;;80         
;;;81         if ( std::equal( beg + 1U, end, beg ) ) //если все элементы массива равны
000062  4632              MOV      r2,r6
000064  4641              MOV      r1,r8
000066  1c70              ADDS     r0,r6,#1
000068  f7fffffe          BL       _ZSt5equalIPhS0_EbT_S1_T0_ ; bool std::equal<unsigned char*, unsigned char*>(T1, T1, T2)
00006c  b118              CBZ      r0,|L3.118|
;;;82         {
;;;83           Model.set_code_sw( SampleBuf[0] );
00006e  7821              LDRB     r1,[r4,#0]
000070  480c              LDR      r0,|L3.164|
000072  f7fffffe          BL       _ZN6TModel11set_code_swEh ; TModel::set_code_sw(unsigned char)
                  |L3.118|
;;;84         }
;;;85         
;;;86         std::fill( beg, end, 0U );
000076  4630              MOV      r0,r6
000078  4641              MOV      r1,r8
00007a  2700              MOVS     r7,#0
00007c  e001              B        |L3.130|
                  |L3.126|
00007e  7007              STRB     r7,[r0,#0]
000080  1c40              ADDS     r0,r0,#1
                  |L3.130|
000082  4288              CMP      r0,r1
000084  d1fb              BNE      |L3.126|
000086  bf00              NOP      
;;;87         
;;;88     //    RelFour.on();
;;;89       }
000088  bf00              NOP      
                  |L3.138|
;;;90       else
;;;91       {
;;;92       
;;;93       }
;;;94       
;;;95       xTimerStart( CodeSwTmr, 0U );
00008a  f7fffffe          BL       xTaskGetTickCount
00008e  4606              MOV      r6,r0
000090  2000              MOVS     r0,#0
000092  9000              STR      r0,[sp,#0]
000094  2300              MOVS     r3,#0
000096  4632              MOV      r2,r6
000098  2101              MOVS     r1,#1
00009a  6828              LDR      r0,[r5,#0]
00009c  f7fffffe          BL       xTimerGenericCommand
;;;96     }
0000a0  e8bd83f8          POP      {r3-r9,pc}
;;;97     
                          ENDP

                  |L3.164|
                          DCD      Model

                          AREA ||i._ZN13TCodingSwitch4initEv||, CODE, READONLY, ALIGN=1

                  _ZN13TCodingSwitch4initEv PROC ; TCodingSwitch::init()
;;;25     
;;;26     void TCodingSwitch::init()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;27     {
000004  b08e              SUB      sp,sp,#0x38
000006  4605              MOV      r5,r0
;;;28       auto beg = &DevAddr_HW[0];
000008  6a2f              LDR      r7,[r5,#0x20]
;;;29       auto end = &DevAddr_HW[ sizeof DevAddr_HW / sizeof DevAddr_HW[0] ];
00000a  6a28              LDR      r0,[r5,#0x20]
00000c  f1000850          ADD      r8,r0,#0x50
;;;30     
;;;31       std::for_each( beg, end, []( TDevAddr_HW item ){
000010  463c              MOV      r4,r7
000012  4646              MOV      r6,r8
000014  e014              B        |L4.64|
                  |L4.22|
000016  2214              MOVS     r2,#0x14
000018  4621              MOV      r1,r4
00001a  a807              ADD      r0,sp,#0x1c
00001c  f7fffffe          BL       __aeabi_memcpy4
;;;32         item.Pin.en_clk( item.Pin.ClkPortMask );
000020  e9dd0109          LDRD     r0,r1,[sp,#0x24]
000024  4788              BLX      r1
;;;33     
;;;34         LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;35         GPIO_InitStruct.Pin   = item.Pin.Nbr;
000026  9808              LDR      r0,[sp,#0x20]
000028  9001              STR      r0,[sp,#4]
;;;36         GPIO_InitStruct.Mode  = LL_GPIO_MODE_INPUT;
00002a  2000              MOVS     r0,#0
00002c  9002              STR      r0,[sp,#8]
;;;37         GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
00002e  9003              STR      r0,[sp,#0xc]
;;;38         GPIO_InitStruct.Pull  = LL_GPIO_PULL_UP;
000030  2001              MOVS     r0,#1
000032  9005              STR      r0,[sp,#0x14]
;;;39     
;;;40         LL_GPIO_Init( item.Pin.Gpio, &GPIO_InitStruct );
000034  a901              ADD      r1,sp,#4
000036  9807              LDR      r0,[sp,#0x1c]
000038  f7fffffe          BL       LL_GPIO_Init
;;;41     
;;;42       } );
00003c  bf00              NOP      
00003e  3414              ADDS     r4,r4,#0x14
                  |L4.64|
000040  42b4              CMP      r4,r6
000042  d1e8              BNE      |L4.22|
000044  bf00              NOP      
;;;43     }
000046  b00e              ADD      sp,sp,#0x38
000048  e8bd81f0          POP      {r4-r8,pc}
;;;44     
                          ENDP


                          AREA ||i._ZN13TCodingSwitch7rd_addrEv||, CODE, READONLY, ALIGN=1

                  _ZN13TCodingSwitch7rd_addrEv PROC ; TCodingSwitch::rd_addr()
;;;44     
;;;45     uint8_t TCodingSwitch::rd_addr()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;46     {
000004  b08a              SUB      sp,sp,#0x28
000006  4605              MOV      r5,r0
;;;47       uint8_t Addr = 0;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
;;;48       
;;;49       auto *beg = &DevAddr_HW[0];
00000c  6a2f              LDR      r7,[r5,#0x20]
;;;50       auto *end = &DevAddr_HW[ sizeof DevAddr_HW / sizeof DevAddr_HW[0] ];
00000e  6a28              LDR      r0,[r5,#0x20]
000010  f1000850          ADD      r8,r0,#0x50
;;;51       
;;;52       std::for_each( beg, end, [&Addr](TDevAddr_HW item){
000014  463c              MOV      r4,r7
000016  4646              MOV      r6,r8
000018  a808              ADD      r0,sp,#0x20
00001a  9009              STR      r0,[sp,#0x24]
00001c  9006              STR      r0,[sp,#0x18]
00001e  e01a              B        |L5.86|
                  |L5.32|
000020  2214              MOVS     r2,#0x14
000022  4621              MOV      r1,r4
000024  a801              ADD      r0,sp,#4
000026  f7fffffe          BL       __aeabi_memcpy4
;;;53         if ( LL_GPIO_IsInputPinSet( item.Pin.Gpio, item.Pin.Nbr ) == item.Pull )
00002a  e9dd1001          LDRD     r1,r0,[sp,#4]
00002e  690a              LDR      r2,[r1,#0x10]
000030  4002              ANDS     r2,r2,r0
000032  4282              CMP      r2,r0
000034  d101              BNE      |L5.58|
000036  2201              MOVS     r2,#1
000038  e000              B        |L5.60|
                  |L5.58|
00003a  2200              MOVS     r2,#0
                  |L5.60|
00003c  f89d0015          LDRB     r0,[sp,#0x15]
000040  4282              CMP      r2,r0
000042  d106              BNE      |L5.82|
;;;54         {
;;;55           Addr += item.WeightCoeff;
000044  9806              LDR      r0,[sp,#0x18]
000046  7800              LDRB     r0,[r0,#0]
000048  f89d1014          LDRB     r1,[sp,#0x14]
00004c  4408              ADD      r0,r0,r1
00004e  9906              LDR      r1,[sp,#0x18]
000050  7008              STRB     r0,[r1,#0]
                  |L5.82|
;;;56         }
;;;57       } );
000052  bf00              NOP      
000054  3414              ADDS     r4,r4,#0x14
                  |L5.86|
000056  42b4              CMP      r4,r6
000058  d1e2              BNE      |L5.32|
00005a  9806              LDR      r0,[sp,#0x18]         ;52
00005c  9007              STR      r0,[sp,#0x1c]         ;52
;;;58       
;;;59       return Addr;
00005e  f89d0020          LDRB     r0,[sp,#0x20]
;;;60     }
000062  b00a              ADD      sp,sp,#0x28
000064  e8bd81f0          POP      {r4-r8,pc}
;;;61     
                          ENDP


                          AREA ||i._ZN13TCodingSwitch8dly_ctrlERPv||, CODE, READONLY, ALIGN=1

                  _ZN13TCodingSwitch8dly_ctrlERPv PROC ; TCodingSwitch::dly_ctrl(void*&)
;;;97     
;;;98     void TCodingSwitch::dly_ctrl( TimerHandle_t &CodeSwTmr )
000000  b5f8              PUSH     {r3-r7,lr}
;;;99     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;100    //  RelFour.off();
;;;101      
;;;102      State = __SAMPLE;   
000006  2000              MOVS     r0,#0
000008  7728              STRB     r0,[r5,#0x1c]
;;;103      if ( xTimerIsTimerActive( CodeSwTmr ) != pdFALSE ) //если таймер по неопределенной причине не закончил считать
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       xTimerIsTimerActive
000010  b138              CBZ      r0,|L6.34|
;;;104      {
;;;105        xTimerStop( CodeSwTmr, 0U );
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  2300              MOVS     r3,#0
000018  461a              MOV      r2,r3
00001a  2103              MOVS     r1,#3
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       xTimerGenericCommand
                  |L6.34|
;;;106      } 
;;;107      xTimerChangePeriod( CodeSwTmr, pdMS_TO_TICKS( SampleTmr.TIME_MS ), 0U );
000022  8aa8              LDRH     r0,[r5,#0x14]
000024  f44f717a          MOV      r1,#0x3e8
000028  4348              MULS     r0,r1,r0
00002a  fbb0f6f1          UDIV     r6,r0,r1
00002e  2000              MOVS     r0,#0
000030  9000              STR      r0,[sp,#0]
000032  2300              MOVS     r3,#0
000034  4632              MOV      r2,r6
000036  2104              MOVS     r1,#4
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       xTimerGenericCommand
;;;108      
;;;109      xTimerStart( CodeSwTmr, 0U );
00003e  f7fffffe          BL       xTaskGetTickCount
000042  4606              MOV      r6,r0
000044  2000              MOVS     r0,#0
000046  9000              STR      r0,[sp,#0]
000048  2300              MOVS     r3,#0
00004a  4632              MOV      r2,r6
00004c  2101              MOVS     r1,#1
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       xTimerGenericCommand
;;;110      
;;;111    }
000054  bdf8              POP      {r3-r7,pc}
;;;112    
                          ENDP


                          AREA ||i._ZN13TCodingSwitchC1ERA4_K11TDevAddr_HW||, CODE, READONLY, ALIGN=2

                  _ZN13TCodingSwitchC2ERA4_K11TDevAddr_HW                  ; Alternate entry point ; TCodingSwitch::TCodingSwitch__sub_object(const TDevAddr_HW(&)[4])
                  _ZN13TCodingSwitchC1ERA4_K11TDevAddr_HW PROC ; TCodingSwitch::TCodingSwitch(const TDevAddr_HW(&)[4])
;;;10     
;;;11     TCodingSwitch::TCodingSwitch( const TDevAddr_HWr &_DevAddr_HW )
;;;12     :
;;;13     SampleTmr( { SAMPLE_TIME_MS, POLL_TIME_MS / SAMPLE_TIME_MS, 0U } ),
;;;14     DlyTmr( { DLY_TIME_MS, 1U, 0U } ),
;;;15     State( __SAMPLE ),
;;;16     DevAddr_HW( _DevAddr_HW )
;;;17     {
;;;18     
;;;19     }
;;;20     
000000  4a04              LDR      r2,|L7.20|
000002  6812              LDR      r2,[r2,#0]  ; <Data1>
000004  6142              STR      r2,[r0,#0x14]
000006  4a04              LDR      r2,|L7.24|
000008  6812              LDR      r2,[r2,#0]  ; <Data2>
00000a  6182              STR      r2,[r0,#0x18]
00000c  2200              MOVS     r2,#0
00000e  7702              STRB     r2,[r0,#0x1c]
000010  6201              STR      r1,[r0,#0x20]
000012  4770              BX       lr
                          ENDP

                  |L7.20|
                          DCD      ||<Data1>||
                  |L7.24|
                          DCD      ||<Data2>||

                          AREA ||i._ZN13TCodingSwitchD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN13TCodingSwitchD2Ev                  ; Alternate entry point ; TCodingSwitch::~TCodingSwitch__sub_object()
                  _ZN13TCodingSwitchD1Ev PROC ; TCodingSwitch::~TCodingSwitch()
;;;20     
;;;21     TCodingSwitch::~TCodingSwitch()
;;;22     {
;;;23     
;;;24     }
;;;25     
000000  4770              BX       lr
                          ENDP


                          AREA ||i.__sti___17_coding_switch_cpp_CodeSw||, CODE, READONLY, ALIGN=2

                  __sti___17_coding_switch_cpp_CodeSw PROC
000000  b510              PUSH     {r4,lr}
000002  4905              LDR      r1,|L9.24|
000004  4805              LDR      r0,|L9.28|
000006  f7fffffe          BL       _ZN13TCodingSwitchC1ERA4_K11TDevAddr_HW ; TCodingSwitch::TCodingSwitch(const TDevAddr_HW(&)[4])
00000a  4604              MOV      r4,r0
00000c  4a04              LDR      r2,|L9.32|
00000e  4905              LDR      r1,|L9.36|
000010  f7fffffe          BL       __aeabi_atexit
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      DevAddr_HW
                  |L9.28|
                          DCD      CodeSw
                  |L9.32|
                          DCD      __dso_handle
                  |L9.36|
                          DCD      _ZN13TCodingSwitchD1Ev ; TCodingSwitch::~TCodingSwitch()

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN13TCodingSwitch4initEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN13TCodingSwitch4initEv||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._Z13coding_switchPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z13coding_switchPv||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._Z11code_sw_tmrPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z11code_sw_tmrPv||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._ZN13TCodingSwitchC1ERA4_K11TDevAddr_HW||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN13TCodingSwitchC1ERA4_K11TDevAddr_HW||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._ZN13TCodingSwitchD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN13TCodingSwitchD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i._ZN13TCodingSwitch7rd_addrEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN13TCodingSwitch7rd_addrEv||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._ZN13TCodingSwitch11sample_ctrlERPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN13TCodingSwitch11sample_ctrlERPv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._ZN13TCodingSwitch8dly_ctrlERPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN13TCodingSwitch8dly_ctrlERPv||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.__sti___17_coding_switch_cpp_CodeSw||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___17_coding_switch_cpp_CodeSw||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  CodeSw
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      _ZN13TCodingSwitch11sample_ctrlERPv ; TCodingSwitch::sample_ctrl(void*&)
                          DCD      0x00000000
                          DCD      _ZN13TCodingSwitch8dly_ctrlERPv ; TCodingSwitch::dly_ctrl(void*&)
                          DCD      0x00000000
                  ||<Data1>||
000010  0005              DCW      0x0005
000012  1400              DCB      0x14,0x00
                  ||<Data2>||
000014  0384              DCW      0x0384
000016  0100              DCB      0x01,0x00

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___17_coding_switch_cpp_CodeSw

                          AREA ||t._ZSt5equalIPhS0_EbT_S1_T0_||, COMGROUP=_ZSt5equalIPhS0_EbT_S1_T0_, CODE, READONLY, ALIGN=1

                  _ZSt5equalIPhS0_EbT_S1_T0_ PROC ; bool std::equal<unsigned char*, unsigned char*>(T1, T1, T2)
;;;241    inline bool
;;;242    equal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
000000  b5ff              PUSH     {r0-r7,lr}
;;;243    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4615              MOV      r5,r2
;;;244        return __last1 == _STD::mismatch (__first1, __last1, __first2).first;
000008  a802              ADD      r0,sp,#8
00000a  4621              MOV      r1,r4
00000c  461e              MOV      r6,r3
00000e  462a              MOV      r2,r5
000010  e001              B        |L65.22|
                  |L65.18|
000012  1c49              ADDS     r1,r1,#1
000014  1c52              ADDS     r2,r2,#1
                  |L65.22|
000016  42b1              CMP      r1,r6
000018  d004              BEQ      |L65.36|
00001a  780f              LDRB     r7,[r1,#0]
00001c  f892c000          LDRB     r12,[r2,#0]
000020  4567              CMP      r7,r12
000022  d0f6              BEQ      |L65.18|
                  |L65.36|
000024  bf00              NOP      
000026  6001              STR      r1,[r0,#0]
000028  6042              STR      r2,[r0,#4]
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  e9dd0102          LDRD     r0,r1,[sp,#8]
000032  e9cd0100          STRD     r0,r1,[sp,#0]
000036  4298              CMP      r0,r3
000038  d102              BNE      |L65.64|
00003a  2001              MOVS     r0,#1
                  |L65.60|
;;;245    }
00003c  b004              ADD      sp,sp,#0x10
00003e  bdf0              POP      {r4-r7,pc}
                  |L65.64|
000040  2000              MOVS     r0,#0                 ;244
000042  e7fb              B        |L65.60|
;;;246    
                          ENDP


                          AREA ||area_number.66||, COMGROUP=_ZSt5equalIPhS0_EbT_S1_T0_, LINKORDER=||t._ZSt5equalIPhS0_EbT_S1_T0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.66||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZSt5equalIPhS0_EbT_S1_T0_||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "Source\\Tasks\\src\\coding_switch.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_coding_switch_cpp_CodeSw___ZN37_INTERNAL_17_coding_switch_cpp_CodeSw7__REV16Ej|
#line 388 ".\\Source\\Core\\inc\\cmsis_armcc.h"
|__asm___17_coding_switch_cpp_CodeSw___ZN37_INTERNAL_17_coding_switch_cpp_CodeSw7__REV16Ej| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_coding_switch_cpp_CodeSw___ZN37_INTERNAL_17_coding_switch_cpp_CodeSw7__REVSHEi|
#line 402
|__asm___17_coding_switch_cpp_CodeSw___ZN37_INTERNAL_17_coding_switch_cpp_CodeSw7__REVSHEi| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_coding_switch_cpp_CodeSw___ZN37_INTERNAL_17_coding_switch_cpp_CodeSw5__RRXEj|
#line 587
|__asm___17_coding_switch_cpp_CodeSw___ZN37_INTERNAL_17_coding_switch_cpp_CodeSw5__RRXEj| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
